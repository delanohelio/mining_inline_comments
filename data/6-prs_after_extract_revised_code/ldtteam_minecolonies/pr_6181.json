{"pr_number": 6181, "pr_title": "Move Research System To Datapack", "pr_createdAt": "2020-12-02T03:08:28Z", "pr_url": "https://github.com/ldtteam/minecolonies/pull/6181", "timeline": [{"oid": "5716825a67c118a5795c87b1fef0d61959f1df60", "url": "https://github.com/ldtteam/minecolonies/commit/5716825a67c118a5795c87b1fef0d61959f1df60", "message": "Merge cleanup", "committedDate": "2021-01-28T18:40:02Z", "type": "commit"}, {"oid": "ce93b260dbcf59d586e6b0fd4f111fd71437f5b6", "url": "https://github.com/ldtteam/minecolonies/commit/ce93b260dbcf59d586e6b0fd4f111fd71437f5b6", "message": "AbstractBlockHut and AbstractBuilding Research Check Improvements\n\nImproves readability, jdoc, and moves the conversion from block to researcheffect identifier into its own API-accessible method.", "committedDate": "2021-01-28T19:48:44Z", "type": "commit"}, {"oid": "90e558d6a9f5929a3e1741b27b1d5c4d67a08f49", "url": "https://github.com/ldtteam/minecolonies/commit/90e558d6a9f5929a3e1741b27b1d5c4d67a08f49", "message": "Merge branch 'version/1.16.3' into version/1.16.3-research-datapack", "committedDate": "2021-01-29T03:28:35Z", "type": "commit"}, {"oid": "529ad8aaaa64794874321b8a72e76df10c0ebbd9", "url": "https://github.com/ldtteam/minecolonies/commit/529ad8aaaa64794874321b8a72e76df10c0ebbd9", "message": "Renames\n\nRequested name changes from #suggestions for knockbackaoeability to Whirlwind and the +melee damage whirl(d)wind to Savage Strike.", "committedDate": "2021-01-31T22:47:44Z", "type": "commit"}, {"oid": "c10ce1c73fb789edb377dbac32b308d33a2cb865", "url": "https://github.com/ldtteam/minecolonies/commit/c10ce1c73fb789edb377dbac32b308d33a2cb865", "message": "Merge branch 'version/1.16.3' into version/1.16.3-research-datapack", "committedDate": "2021-02-07T22:39:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDA4MjY3MA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574082670", "bodyText": "Why'd you add this whitespace?", "author": "ravenbuilder934", "createdAt": "2021-02-10T21:15:50Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/planter/EntityAIWorkPlanter.java", "diffHunk": "@@ -199,7 +199,7 @@ protected IAIState decide()\n                 return PLANTATION_PLANT;\n             }\n         }\n-\n+        ", "originalCommit": "c10ce1c73fb789edb377dbac32b308d33a2cb865", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDIxODY0MA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574218640", "bodyText": "Think it was accidentally left-over from fighting with PLANT2.  Will see about fixing that next commit.", "author": "gattsuru", "createdAt": "2021-02-11T02:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDA4MjY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDIzODI2MA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574238260", "bodyText": "Probably accidental when working on the PLANT_2 research effect.  Thanks for catching that.", "author": "gattsuru", "createdAt": "2021-02-11T03:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDA4MjY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI0MDA2OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574240069", "bodyText": "Ofc, no problem", "author": "ravenbuilder934", "createdAt": "2021-02-11T04:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDA4MjY3MA=="}], "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/entity/ai/citizen/planter/EntityAIWorkPlanter.java b/src/main/java/com/minecolonies/coremod/entity/ai/citizen/planter/EntityAIWorkPlanter.java\nindex 8d35a606ab..056cdb3659 100755\n--- a/src/main/java/com/minecolonies/coremod/entity/ai/citizen/planter/EntityAIWorkPlanter.java\n+++ b/src/main/java/com/minecolonies/coremod/entity/ai/citizen/planter/EntityAIWorkPlanter.java\n\n@@ -199,7 +199,6 @@ public class EntityAIWorkPlanter extends AbstractEntityAICrafting<JobPlanter, Bu\n                 return PLANTATION_PLANT;\n             }\n         }\n-        \n         return START_WORKING;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNDgwMg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551814802", "bodyText": "Needs to be a translation key.\nIf it is already then this needs to be documented.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:32:09Z", "path": "src/api/java/com/minecolonies/api/research/IGlobalResearch.java", "diffHunk": "@@ -53,26 +48,43 @@\n \n     /**\n      * Start the research.\n-     *\n-     * @param player            the player starting it.\n      * @param localResearchTree the local research tree to store in the colony.\n      */\n-    void startResearch(@NotNull final PlayerEntity player, @NotNull final ILocalResearchTree localResearchTree);\n+    void startResearch(@NotNull final ILocalResearchTree localResearchTree);\n \n     /**\n      * Human readable description of research.\n-     *\n      * @return the description.\n      */\n     String getDesc();\n \n+    /**\n+     * Subtitle description of research.\n+     * @return the optional subtitle name.\n+     */\n+    String getSubtitle();", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\nindex 2cd48d5d0b..831766c3d3 100755\n--- a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n+++ b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n\n@@ -56,7 +54,7 @@ public interface IGlobalResearch\n      * Human readable description of research.\n      * @return the description.\n      */\n-    String getDesc();\n+    String getName();\n \n     /**\n      * Subtitle description of research.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNDkyMg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551814922", "bodyText": "This needs to be a ResourceLocation.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:32:23Z", "path": "src/api/java/com/minecolonies/api/research/IGlobalResearch.java", "diffHunk": "@@ -53,26 +48,43 @@\n \n     /**\n      * Start the research.\n-     *\n-     * @param player            the player starting it.\n      * @param localResearchTree the local research tree to store in the colony.\n      */\n-    void startResearch(@NotNull final PlayerEntity player, @NotNull final ILocalResearchTree localResearchTree);\n+    void startResearch(@NotNull final ILocalResearchTree localResearchTree);\n \n     /**\n      * Human readable description of research.\n-     *\n      * @return the description.\n      */\n     String getDesc();\n \n+    /**\n+     * Subtitle description of research.\n+     * @return the optional subtitle name.\n+     */\n+    String getSubtitle();\n+\n     /**\n      * Getter of the id of the research.\n-     *\n      * @return the String id.\n      */\n     String getId();", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\nindex 2cd48d5d0b..831766c3d3 100755\n--- a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n+++ b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n\n@@ -56,7 +54,7 @@ public interface IGlobalResearch\n      * Human readable description of research.\n      * @return the description.\n      */\n-    String getDesc();\n+    String getName();\n \n     /**\n      * Subtitle description of research.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTAwNA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551815004", "bodyText": "This needs to be a ResourceLocation.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:32:34Z", "path": "src/api/java/com/minecolonies/api/research/IGlobalResearch.java", "diffHunk": "@@ -53,26 +48,43 @@\n \n     /**\n      * Start the research.\n-     *\n-     * @param player            the player starting it.\n      * @param localResearchTree the local research tree to store in the colony.\n      */\n-    void startResearch(@NotNull final PlayerEntity player, @NotNull final ILocalResearchTree localResearchTree);\n+    void startResearch(@NotNull final ILocalResearchTree localResearchTree);\n \n     /**\n      * Human readable description of research.\n-     *\n      * @return the description.\n      */\n     String getDesc();\n \n+    /**\n+     * Subtitle description of research.\n+     * @return the optional subtitle name.\n+     */\n+    String getSubtitle();\n+\n     /**\n      * Getter of the id of the research.\n-     *\n      * @return the String id.\n      */\n     String getId();\n \n+    /**\n+     * Getter of the research icon's resource location.\n+     * @return the string of the ResourceLocation of the icon, in the pattern namespace:directory:(optional count).\n+     */\n+    String getIcon();", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDIzOTgxNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574239815", "bodyText": "That one can possibly include pseudo-ItemStack data, including item counts, or a texture location.  I'll change the jdoc to be clearer on that, but it can't be a ResourceLocation, and it can't be turned into other relevant objects because textures at least may not exist on the server side.\n((Also currently under debate if it should even be used; the current commit has drawing of research icons disabled.))", "author": "gattsuru", "createdAt": "2021-02-11T04:00:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI5NjY2Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574296666", "bodyText": "Then make it something like IIcon and add a parser which can parse the json spec into the IIcon object used for rendering.\nBut leaving this as a string is just asking for problems", "author": "OrionDevelopment", "createdAt": "2021-02-11T07:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTAwNA=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\nindex 2cd48d5d0b..831766c3d3 100755\n--- a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n+++ b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n\n@@ -56,7 +54,7 @@ public interface IGlobalResearch\n      * Human readable description of research.\n      * @return the description.\n      */\n-    String getDesc();\n+    String getName();\n \n     /**\n      * Subtitle description of research.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTE5Mg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551815192", "bodyText": "This can be collapsed into the id of the research.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:32:56Z", "path": "src/api/java/com/minecolonies/api/research/IGlobalResearch.java", "diffHunk": "@@ -53,26 +48,43 @@\n \n     /**\n      * Start the research.\n-     *\n-     * @param player            the player starting it.\n      * @param localResearchTree the local research tree to store in the colony.\n      */\n-    void startResearch(@NotNull final PlayerEntity player, @NotNull final ILocalResearchTree localResearchTree);\n+    void startResearch(@NotNull final ILocalResearchTree localResearchTree);\n \n     /**\n      * Human readable description of research.\n-     *\n      * @return the description.\n      */\n     String getDesc();\n \n+    /**\n+     * Subtitle description of research.\n+     * @return the optional subtitle name.\n+     */\n+    String getSubtitle();\n+\n     /**\n      * Getter of the id of the research.\n-     *\n      * @return the String id.\n      */\n     String getId();\n \n+    /**\n+     * Getter of the research icon's resource location.\n+     * @return the string of the ResourceLocation of the icon, in the pattern namespace:directory:(optional count).\n+     */\n+    String getIcon();\n+\n+    /**\n+     * Getter of the resource location of the research, if loaded by datapack.\n+     *\n+     * @return the resource location for a dynamically loaded research,\n+     * minecolonies:staticresearch/id if statically assigned,\n+     * or minecolonies:clientlocal/id if received from a server in a remote environment.\n+     */\n+    ResourceLocation getResourceLocation();", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTM4MA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551815380", "bodyText": "Id == Location on disk, as with everything else that MC loads from datapacks.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTE5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\nindex 2cd48d5d0b..831766c3d3 100755\n--- a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n+++ b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n\n@@ -56,7 +54,7 @@ public interface IGlobalResearch\n      * Human readable description of research.\n      * @return the description.\n      */\n-    String getDesc();\n+    String getName();\n \n     /**\n      * Subtitle description of research.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTY1Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551815657", "bodyText": "ResearchIds should be resource locations.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:33:45Z", "path": "src/api/java/com/minecolonies/api/research/IGlobalResearch.java", "diffHunk": "@@ -123,12 +163,36 @@\n      */\n     void addChild(IGlobalResearch child);\n \n+    /**\n+     * Add a child to a research, without setting parentage.\n+     * @param child the child to add\n+     */\n+    void addChild(final String child);", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\nindex 2cd48d5d0b..0fe4925787 100755\n--- a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n+++ b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n\n@@ -167,60 +173,39 @@ public interface IGlobalResearch\n      * Add a child to a research, without setting parentage.\n      * @param child the child to add\n      */\n-    void addChild(final String child);\n+    void addChild(final ResourceLocation child);\n \n     /**\n      * Add an individual cost.\n-     * @param cost the individual itemstack to add to the cost list, as a string.\n+     * @param cost the individual item to add to the cost list, as an ItemStorage.\n      */\n-    void addCost(final String cost);\n+    void addCost(final ItemStorage cost);\n \n     /**\n      * Add an individual effect.\n-     * @param effect the individual effect to add to the research, as a string.\n+     * @param effect the individual effect to add to the research, as a IResearchEffect.\n      */\n-    void addEffect(final String effect);\n+    void addEffect(final IResearchEffect<?> effect);\n \n     /**\n      * Add an individual requirement\n-     * @param requirement the individual requirement to add to the research, as a string.\n+     * @param requirement the individual requirement to add to the research, as an IResearchRequirement.\n      */\n-    void addRequirement(final String requirement);\n+    void addRequirement(final IResearchRequirement requirement);\n \n     /**\n      * Get the list of children of the research.\n      *\n      * @return a copy of the list of child identifiers.\n      */\n-    List<String> getChildren();\n+    List<ResourceLocation> getChildren();\n \n     /**\n      * Set the parent of a research.\n      *\n      * @param id the id of the parent.\n      */\n-    void setParent(String id);\n-\n-    /**\n-     * Set the research requirement.\n-     *\n-     * @param requirements the requirements.\n-     */\n-    void setRequirement(final List<IResearchRequirement> requirements);\n-\n-    /**\n-     * Set the research effects.\n-     *\n-     * @param effects      the effects of research completion.\n-     */\n-    void setEffects(final List<IResearchEffect<?>> effects);\n-\n-    /**\n-     * Set the research costs.\n-     *\n-     * @param costs the items consumed to begin research.\n-     */\n-    void setCosts(final List<ItemStorage> costs);\n+    void setParent(ResourceLocation id);\n \n     /**\n      * Getter for the research requirement.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTcxNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551815715", "bodyText": "ResearchIds should be resource locations.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:33:51Z", "path": "src/api/java/com/minecolonies/api/research/IGlobalResearch.java", "diffHunk": "@@ -123,12 +163,36 @@\n      */\n     void addChild(IGlobalResearch child);\n \n+    /**\n+     * Add a child to a research, without setting parentage.\n+     * @param child the child to add\n+     */\n+    void addChild(final String child);\n+\n+    /**\n+     * Add an individual cost.\n+     * @param cost the individual itemstack to add to the cost list, as a string.\n+     */\n+    void addCost(final String cost);", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI0MDk4NQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574240985", "bodyText": "Costs are ItemStacks, including quantity (and, while not currently supported, down the road possibly NBT) information.  These ones I can pre-format into their ItemStacks if that's preferred, but it will make the serialization/deserialization much worse from a performance perspective.", "author": "gattsuru", "createdAt": "2021-02-11T04:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI5NzExMA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574297110", "bodyText": "Then make it item stacks\nOr something that generally represents itemstacks or other objects like an interface implemented on wrappers.\nWe are in an object oriented language with java. Make use of it and it's compiler to prevent runtime problems.", "author": "OrionDevelopment", "createdAt": "2021-02-11T07:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTcxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\nindex 2cd48d5d0b..0fe4925787 100755\n--- a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n+++ b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n\n@@ -167,60 +173,39 @@ public interface IGlobalResearch\n      * Add a child to a research, without setting parentage.\n      * @param child the child to add\n      */\n-    void addChild(final String child);\n+    void addChild(final ResourceLocation child);\n \n     /**\n      * Add an individual cost.\n-     * @param cost the individual itemstack to add to the cost list, as a string.\n+     * @param cost the individual item to add to the cost list, as an ItemStorage.\n      */\n-    void addCost(final String cost);\n+    void addCost(final ItemStorage cost);\n \n     /**\n      * Add an individual effect.\n-     * @param effect the individual effect to add to the research, as a string.\n+     * @param effect the individual effect to add to the research, as a IResearchEffect.\n      */\n-    void addEffect(final String effect);\n+    void addEffect(final IResearchEffect<?> effect);\n \n     /**\n      * Add an individual requirement\n-     * @param requirement the individual requirement to add to the research, as a string.\n+     * @param requirement the individual requirement to add to the research, as an IResearchRequirement.\n      */\n-    void addRequirement(final String requirement);\n+    void addRequirement(final IResearchRequirement requirement);\n \n     /**\n      * Get the list of children of the research.\n      *\n      * @return a copy of the list of child identifiers.\n      */\n-    List<String> getChildren();\n+    List<ResourceLocation> getChildren();\n \n     /**\n      * Set the parent of a research.\n      *\n      * @param id the id of the parent.\n      */\n-    void setParent(String id);\n-\n-    /**\n-     * Set the research requirement.\n-     *\n-     * @param requirements the requirements.\n-     */\n-    void setRequirement(final List<IResearchRequirement> requirements);\n-\n-    /**\n-     * Set the research effects.\n-     *\n-     * @param effects      the effects of research completion.\n-     */\n-    void setEffects(final List<IResearchEffect<?>> effects);\n-\n-    /**\n-     * Set the research costs.\n-     *\n-     * @param costs the items consumed to begin research.\n-     */\n-    void setCosts(final List<ItemStorage> costs);\n+    void setParent(ResourceLocation id);\n \n     /**\n      * Getter for the research requirement.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTc1Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551815753", "bodyText": "ResearchIds should be resource locations.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:33:56Z", "path": "src/api/java/com/minecolonies/api/research/IGlobalResearch.java", "diffHunk": "@@ -123,12 +163,36 @@\n      */\n     void addChild(IGlobalResearch child);\n \n+    /**\n+     * Add a child to a research, without setting parentage.\n+     * @param child the child to add\n+     */\n+    void addChild(final String child);\n+\n+    /**\n+     * Add an individual cost.\n+     * @param cost the individual itemstack to add to the cost list, as a string.\n+     */\n+    void addCost(final String cost);\n+\n+    /**\n+     * Add an individual effect.\n+     * @param effect the individual effect to add to the research, as a string.\n+     */\n+    void addEffect(final String effect);", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\nindex 2cd48d5d0b..0fe4925787 100755\n--- a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n+++ b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n\n@@ -167,60 +173,39 @@ public interface IGlobalResearch\n      * Add a child to a research, without setting parentage.\n      * @param child the child to add\n      */\n-    void addChild(final String child);\n+    void addChild(final ResourceLocation child);\n \n     /**\n      * Add an individual cost.\n-     * @param cost the individual itemstack to add to the cost list, as a string.\n+     * @param cost the individual item to add to the cost list, as an ItemStorage.\n      */\n-    void addCost(final String cost);\n+    void addCost(final ItemStorage cost);\n \n     /**\n      * Add an individual effect.\n-     * @param effect the individual effect to add to the research, as a string.\n+     * @param effect the individual effect to add to the research, as a IResearchEffect.\n      */\n-    void addEffect(final String effect);\n+    void addEffect(final IResearchEffect<?> effect);\n \n     /**\n      * Add an individual requirement\n-     * @param requirement the individual requirement to add to the research, as a string.\n+     * @param requirement the individual requirement to add to the research, as an IResearchRequirement.\n      */\n-    void addRequirement(final String requirement);\n+    void addRequirement(final IResearchRequirement requirement);\n \n     /**\n      * Get the list of children of the research.\n      *\n      * @return a copy of the list of child identifiers.\n      */\n-    List<String> getChildren();\n+    List<ResourceLocation> getChildren();\n \n     /**\n      * Set the parent of a research.\n      *\n      * @param id the id of the parent.\n      */\n-    void setParent(String id);\n-\n-    /**\n-     * Set the research requirement.\n-     *\n-     * @param requirements the requirements.\n-     */\n-    void setRequirement(final List<IResearchRequirement> requirements);\n-\n-    /**\n-     * Set the research effects.\n-     *\n-     * @param effects      the effects of research completion.\n-     */\n-    void setEffects(final List<IResearchEffect<?>> effects);\n-\n-    /**\n-     * Set the research costs.\n-     *\n-     * @param costs the items consumed to begin research.\n-     */\n-    void setCosts(final List<ItemStorage> costs);\n+    void setParent(ResourceLocation id);\n \n     /**\n      * Getter for the research requirement.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTc5NA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551815794", "bodyText": "ResearchIds should be resource locations.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:34:00Z", "path": "src/api/java/com/minecolonies/api/research/IGlobalResearch.java", "diffHunk": "@@ -123,12 +163,36 @@\n      */\n     void addChild(IGlobalResearch child);\n \n+    /**\n+     * Add a child to a research, without setting parentage.\n+     * @param child the child to add\n+     */\n+    void addChild(final String child);\n+\n+    /**\n+     * Add an individual cost.\n+     * @param cost the individual itemstack to add to the cost list, as a string.\n+     */\n+    void addCost(final String cost);\n+\n+    /**\n+     * Add an individual effect.\n+     * @param effect the individual effect to add to the research, as a string.\n+     */\n+    void addEffect(final String effect);\n+\n+    /**\n+     * Add an individual requirement\n+     * @param requirement the individual requirement to add to the research, as a string.\n+     */\n+    void addRequirement(final String requirement);", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\nindex 2cd48d5d0b..0fe4925787 100755\n--- a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n+++ b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n\n@@ -167,60 +173,39 @@ public interface IGlobalResearch\n      * Add a child to a research, without setting parentage.\n      * @param child the child to add\n      */\n-    void addChild(final String child);\n+    void addChild(final ResourceLocation child);\n \n     /**\n      * Add an individual cost.\n-     * @param cost the individual itemstack to add to the cost list, as a string.\n+     * @param cost the individual item to add to the cost list, as an ItemStorage.\n      */\n-    void addCost(final String cost);\n+    void addCost(final ItemStorage cost);\n \n     /**\n      * Add an individual effect.\n-     * @param effect the individual effect to add to the research, as a string.\n+     * @param effect the individual effect to add to the research, as a IResearchEffect.\n      */\n-    void addEffect(final String effect);\n+    void addEffect(final IResearchEffect<?> effect);\n \n     /**\n      * Add an individual requirement\n-     * @param requirement the individual requirement to add to the research, as a string.\n+     * @param requirement the individual requirement to add to the research, as an IResearchRequirement.\n      */\n-    void addRequirement(final String requirement);\n+    void addRequirement(final IResearchRequirement requirement);\n \n     /**\n      * Get the list of children of the research.\n      *\n      * @return a copy of the list of child identifiers.\n      */\n-    List<String> getChildren();\n+    List<ResourceLocation> getChildren();\n \n     /**\n      * Set the parent of a research.\n      *\n      * @param id the id of the parent.\n      */\n-    void setParent(String id);\n-\n-    /**\n-     * Set the research requirement.\n-     *\n-     * @param requirements the requirements.\n-     */\n-    void setRequirement(final List<IResearchRequirement> requirements);\n-\n-    /**\n-     * Set the research effects.\n-     *\n-     * @param effects      the effects of research completion.\n-     */\n-    void setEffects(final List<IResearchEffect<?>> effects);\n-\n-    /**\n-     * Set the research costs.\n-     *\n-     * @param costs the items consumed to begin research.\n-     */\n-    void setCosts(final List<ItemStorage> costs);\n+    void setParent(ResourceLocation id);\n \n     /**\n      * Getter for the research requirement.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTg0MQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551815841", "bodyText": "ResearchIds should be resource locations.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:34:08Z", "path": "src/api/java/com/minecolonies/api/research/IGlobalResearch.java", "diffHunk": "@@ -123,12 +163,36 @@\n      */\n     void addChild(IGlobalResearch child);\n \n+    /**\n+     * Add a child to a research, without setting parentage.\n+     * @param child the child to add\n+     */\n+    void addChild(final String child);\n+\n+    /**\n+     * Add an individual cost.\n+     * @param cost the individual itemstack to add to the cost list, as a string.\n+     */\n+    void addCost(final String cost);\n+\n+    /**\n+     * Add an individual effect.\n+     * @param effect the individual effect to add to the research, as a string.\n+     */\n+    void addEffect(final String effect);\n+\n+    /**\n+     * Add an individual requirement\n+     * @param requirement the individual requirement to add to the research, as a string.\n+     */\n+    void addRequirement(final String requirement);\n+\n     /**\n      * Get the list of children of the research.\n      *\n      * @return a copy of the list of child identifiers.\n      */\n-    ImmutableList<String> getChilds();\n+    List<String> getChildren();", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\nindex 2cd48d5d0b..0fe4925787 100755\n--- a/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n+++ b/src/api/java/com/minecolonies/api/research/IGlobalResearch.java\n\n@@ -167,60 +173,39 @@ public interface IGlobalResearch\n      * Add a child to a research, without setting parentage.\n      * @param child the child to add\n      */\n-    void addChild(final String child);\n+    void addChild(final ResourceLocation child);\n \n     /**\n      * Add an individual cost.\n-     * @param cost the individual itemstack to add to the cost list, as a string.\n+     * @param cost the individual item to add to the cost list, as an ItemStorage.\n      */\n-    void addCost(final String cost);\n+    void addCost(final ItemStorage cost);\n \n     /**\n      * Add an individual effect.\n-     * @param effect the individual effect to add to the research, as a string.\n+     * @param effect the individual effect to add to the research, as a IResearchEffect.\n      */\n-    void addEffect(final String effect);\n+    void addEffect(final IResearchEffect<?> effect);\n \n     /**\n      * Add an individual requirement\n-     * @param requirement the individual requirement to add to the research, as a string.\n+     * @param requirement the individual requirement to add to the research, as an IResearchRequirement.\n      */\n-    void addRequirement(final String requirement);\n+    void addRequirement(final IResearchRequirement requirement);\n \n     /**\n      * Get the list of children of the research.\n      *\n      * @return a copy of the list of child identifiers.\n      */\n-    List<String> getChildren();\n+    List<ResourceLocation> getChildren();\n \n     /**\n      * Set the parent of a research.\n      *\n      * @param id the id of the parent.\n      */\n-    void setParent(String id);\n-\n-    /**\n-     * Set the research requirement.\n-     *\n-     * @param requirements the requirements.\n-     */\n-    void setRequirement(final List<IResearchRequirement> requirements);\n-\n-    /**\n-     * Set the research effects.\n-     *\n-     * @param effects      the effects of research completion.\n-     */\n-    void setEffects(final List<IResearchEffect<?>> effects);\n-\n-    /**\n-     * Set the research costs.\n-     *\n-     * @param costs the items consumed to begin research.\n-     */\n-    void setCosts(final List<ItemStorage> costs);\n+    void setParent(ResourceLocation id);\n \n     /**\n      * Getter for the research requirement.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNTk5OA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551815998", "bodyText": "ResearchIds should be resource locations.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:34:24Z", "path": "src/api/java/com/minecolonies/api/research/IGlobalResearchTree.java", "diffHunk": "@@ -37,15 +45,40 @@ static IGlobalResearchTree getInstance()\n      * @param id    the id of the research.\n      * @return the effect id\n      */\n-    String getEffectIdForResearch(final @NotNull String id);\n+    List<IResearchEffect<?>> getEffectsForResearch(final @NotNull String id);", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/IGlobalResearchTree.java b/src/api/java/com/minecolonies/api/research/IGlobalResearchTree.java\nindex db1c1a401e..83218847b3 100755\n--- a/src/api/java/com/minecolonies/api/research/IGlobalResearchTree.java\n+++ b/src/api/java/com/minecolonies/api/research/IGlobalResearchTree.java\n\n@@ -47,13 +46,6 @@ public interface IGlobalResearchTree\n      */\n     List<IResearchEffect<?>> getEffectsForResearch(final @NotNull String id);\n \n-   /** Get a research's resource location.\n-     *\n-     * @param id     the id of the research.\n-     * @return the IResearch object.\n-     */\n-    ResourceLocation getResearchResourceLocation(final String branch, final String id);\n-\n     /**\n      * Check if a research exists, by id.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNjIwMA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551816200", "bodyText": "This should be collapsed into the research id as stated above.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:34:45Z", "path": "src/api/java/com/minecolonies/api/research/IGlobalResearchTree.java", "diffHunk": "@@ -37,15 +45,40 @@ static IGlobalResearchTree getInstance()\n      * @param id    the id of the research.\n      * @return the effect id\n      */\n-    String getEffectIdForResearch(final @NotNull String id);\n+    List<IResearchEffect<?>> getEffectsForResearch(final @NotNull String id);\n+\n+   /** Get a research's resource location.\n+     *\n+     * @param id     the id of the research.\n+     * @return the IResearch object.\n+     */\n+    ResourceLocation getResearchResourceLocation(final String branch, final String id);", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/IGlobalResearchTree.java b/src/api/java/com/minecolonies/api/research/IGlobalResearchTree.java\nindex db1c1a401e..83218847b3 100755\n--- a/src/api/java/com/minecolonies/api/research/IGlobalResearchTree.java\n+++ b/src/api/java/com/minecolonies/api/research/IGlobalResearchTree.java\n\n@@ -47,13 +46,6 @@ public interface IGlobalResearchTree\n      */\n     List<IResearchEffect<?>> getEffectsForResearch(final @NotNull String id);\n \n-   /** Get a research's resource location.\n-     *\n-     * @param id     the id of the research.\n-     * @return the IResearch object.\n-     */\n-    ResourceLocation getResearchResourceLocation(final String branch, final String id);\n-\n     /**\n      * Check if a research exists, by id.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNjI4Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551816286", "bodyText": "ResearchIds should be resource locations.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:34:54Z", "path": "src/api/java/com/minecolonies/api/research/ILocalResearchTree.java", "diffHunk": "@@ -42,13 +45,37 @@\n      */\n     List<ILocalResearch> getResearchInProgress();\n \n+    /**\n+     * Checks if a given research is complete.\n+     *\n+     * @return true if complete or if no such research is loaded, false if not completed.\n+     */\n+     boolean hasCompletedResearch(final String researchId);", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java b/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java\nindex 4f9805a60b..0c571c9247 100755\n--- a/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java\n+++ b/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java\n\n@@ -50,14 +51,14 @@ public interface ILocalResearchTree\n      *\n      * @return true if complete or if no such research is loaded, false if not completed.\n      */\n-     boolean hasCompletedResearch(final String researchId);\n+     boolean hasCompletedResearch(final ResourceLocation researchId);\n \n     /**\n      * Finish a research and remove it from the inProgress list.\n      *\n      * @param id the id of the research to finish.\n      */\n-    void finishResearch(final String id);\n+    void finishResearch(final ResourceLocation id);\n \n     /**\n      * Attempt to begin a research.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNjM0NA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551816344", "bodyText": "ResearchIds should be resource locations.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:34:59Z", "path": "src/api/java/com/minecolonies/api/research/ILocalResearchTree.java", "diffHunk": "@@ -42,13 +45,37 @@\n      */\n     List<ILocalResearch> getResearchInProgress();\n \n+    /**\n+     * Checks if a given research is complete.\n+     *\n+     * @return true if complete or if no such research is loaded, false if not completed.\n+     */\n+     boolean hasCompletedResearch(final String researchId);\n+\n     /**\n      * Finish a research and remove it from the inProgress list.\n      *\n-     * @param id the id of the research to remove.\n+     * @param id the id of the research to finish.\n      */\n     void finishResearch(final String id);", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java b/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java\nindex 4f9805a60b..0c571c9247 100755\n--- a/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java\n+++ b/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java\n\n@@ -50,14 +51,14 @@ public interface ILocalResearchTree\n      *\n      * @return true if complete or if no such research is loaded, false if not completed.\n      */\n-     boolean hasCompletedResearch(final String researchId);\n+     boolean hasCompletedResearch(final ResourceLocation researchId);\n \n     /**\n      * Finish a research and remove it from the inProgress list.\n      *\n      * @param id the id of the research to finish.\n      */\n-    void finishResearch(final String id);\n+    void finishResearch(final ResourceLocation id);\n \n     /**\n      * Attempt to begin a research.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNjc5NA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551816794", "bodyText": "Why is the colony needed here? Are instances of this interface not linked to the actuall colony they work on?", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:35:51Z", "path": "src/api/java/com/minecolonies/api/research/IResearchManager.java", "diffHunk": "@@ -36,4 +37,11 @@\n      * @return the ResearchEffects object.\n      */\n     IResearchEffectManager getResearchEffects();\n+\n+    /**\n+     * Checks if any autostart research has its prerequisites filled,\n+     * and if so, prompts the player for resources or begins research if no resources required.\n+     * @param colony       The colony where the research is being checked.\n+     */\n+    void checkAutoStartResearch(IColony colony);", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDIyNzUwNg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574227506", "bodyText": "ResearchManagers exist within the Colony, but they don't have the colony as an internally-accessible property the way that RequestManagers do.  I can change that if it'd be considered a cleaner option, but I wasn't sure if that would be preferable given the colony/colonyview split.", "author": "gattsuru", "createdAt": "2021-02-11T03:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNjc5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI5NzU3Mg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574297572", "bodyText": "If the manager is inheritable linked to the colony then it should have the colony internally.\nIf there is a need for you to have a view then your research manager needs a view class of it's own", "author": "OrionDevelopment", "createdAt": "2021-02-11T07:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNjc5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDU0OTQwOQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574549409", "bodyText": "I can make that change if desired, but ResearchManager may be linked to Colony or a ColonyView depending on where it's created, and there are a lot of ColonyView properties that will return nulls where Colony would not, many of them places it would be really bulky to do the necessary null or instanceof checks.\nThat's not a problem for checkAutoStartResearch (or startCostlessResearch), which neither request or would need something that fails that problem, and they're always called on the server-side anyway.  But it seems like setting up a landmine for other coders.", "author": "gattsuru", "createdAt": "2021-02-11T14:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNjc5NA=="}], "type": "inlineReview", "revised_code": {"commit": "ce93b260dbcf59d586e6b0fd4f111fd71437f5b6", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/IResearchManager.java b/src/api/java/com/minecolonies/api/research/IResearchManager.java\nindex f0e3d951d6..8e3fb6d2ed 100755\n--- a/src/api/java/com/minecolonies/api/research/IResearchManager.java\n+++ b/src/api/java/com/minecolonies/api/research/IResearchManager.java\n\n@@ -38,6 +39,14 @@ public interface IResearchManager\n      */\n     IResearchEffectManager getResearchEffects();\n \n+    /**\n+     * Gets the Research Effect Identifier for a given Block\n+     * Format is namespace:effects/path\n+     * @param block       The block to get a research identifier for.\n+     * @return            The string format of that research identifier.\n+     */\n+    String getResearchEffectIdFrom(Block block);\n+\n     /**\n      * Checks if any autostart research has its prerequisites filled,\n      * and if so, prompts the player for resources or begins research if no resources required.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNzAyNw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551817027", "bodyText": "More documentation is needed.\nI have no clue what this is.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:36:15Z", "path": "src/api/java/com/minecolonies/api/research/IResearchRequirement.java", "diffHunk": "@@ -22,4 +22,11 @@\n      * @return translation text component.\n      */\n     TranslationTextComponent getDesc();\n+\n+    /**\n+     * Get a string description of the requirement, to simplify serialization.\n+     * @return string description of the research requirement.\n+     */\n+    String getAttributes();", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNzI0MA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551817240", "bodyText": "Are these effects?\nAre these the results of the research?\nAre theese requirements?\nWhat are these?", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:36:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNzAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDIyODgxNg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574228816", "bodyText": "They return a string containing the necessary information to rebuild the client-visible traits for the given research requirement, whatever those may be.\nI can get them out of the API methods, if that'd be preferred, since in practice there's not a huge benefit from parsing them versus the traits individually, and most likely only need to be called from within coremod (specifically GlobalResearchFactory).  But they are traits that people making new types of ResearchRequirements would need to implement, or the requirements won't show up properly for the .\nThe goal here was to provide an easy way for other mods to include new types of ResearchRequirements without having to have a deep understanding of the GlobalResearchFactory's internal implementation, or even necessarily having to implement a full serialization/deserialization for ResearchRequirements where that would be impractical (eg, the client side doesn't need to understand the trigger behavior, or where the mod maker would want to have misleading results on the client sides when connecting to a multiplayer server).\nI can make them into serialize/deserialize functions instead of constructor and getX, instead, if the concern is readability/legibility.", "author": "gattsuru", "createdAt": "2021-02-11T03:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNzAyNw=="}], "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/IResearchRequirement.java b/src/api/java/com/minecolonies/api/research/IResearchRequirement.java\nindex b4a552d85b..4337159496 100755\n--- a/src/api/java/com/minecolonies/api/research/IResearchRequirement.java\n+++ b/src/api/java/com/minecolonies/api/research/IResearchRequirement.java\n\n@@ -17,16 +19,23 @@ public interface IResearchRequirement\n     boolean isFulfilled(final IColony colony);\n \n     /**\n-     * Get a description of the requirement.\n+     * Get a human-readable description of the requirement, or a translation key.\n      *\n      * @return translation text component.\n      */\n     TranslationTextComponent getDesc();\n \n     /**\n-     * Get a string description of the requirement, to simplify serialization.\n-     * @return string description of the research requirement.\n+     * Get the {@link ResearchRequirementEntry} for this Research Requirement.\n+     *\n+     * @return a registry entry.\n      */\n-    String getAttributes();\n+    ResearchRequirementEntry getRegistryEntry();\n \n+    /**\n+     * Write the ResearchRequirement's traits to NBT, to simplify serialization for client-viewable data.\n+     *\n+     * @return an NBT file which must, at minimum, contain the necessary traits to reassemble the effect.\n+     */\n+    CompoundNBT writeToNBT();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNzQ2OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551817469", "bodyText": "Again needs to be a translation key, or if it is already one it should be documented.", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:36:58Z", "path": "src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java", "diffHunk": "@@ -38,11 +38,31 @@\n      */\n     TranslationTextComponent getDesc();\n \n+    /**\n+     * Effect subtitle description.\n+     *\n+     * @return the Subtitle desc.\n+     */\n+    String getSubtitle();", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java b/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java\nindex c3df633108..0cf3cfe370 100755\n--- a/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java\n+++ b/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java\n\n@@ -27,42 +30,42 @@ public interface IResearchEffect<T>\n     /**\n      * Getter for the ID of the effect.\n      *\n-     * @return the String id.\n+     * @return the effect id as a ResourceLocation.\n      */\n-    String getId();\n+    ResourceLocation getId();\n \n     /**\n-     * Effect description.\n+     * Human-readable effect description, or a translation key.\n      *\n      * @return the desc.\n      */\n     TranslationTextComponent getDesc();\n \n     /**\n-     * Effect subtitle description.\n+     * Human-readable effect subtitle description, or a translation key.\n      *\n      * @return the Subtitle desc.\n      */\n-    String getSubtitle();\n+    TranslationTextComponent getSubtitle();\n \n     /**\n-     * Returns the effect's display value\n+     * Does this effect override another effect with the same id?\n      *\n-     * @return the display value.\n+     * @param other the effect to check.\n+     * @return true if so, generally meaning a higher magnitude effect.\n      */\n-    Double getDisplay();\n+    boolean overrides(@NotNull final IResearchEffect<?> other);\n \n     /**\n-     * Does this effect override another effect with the same id?\n+     * Get the {@link ResearchEffectEntry} for this Research Effect.\n      *\n-     * @param other the effect to check.\n-     * @return true if so.\n+     * @return a registry entry.\n      */\n-    boolean overrides(@NotNull final IResearchEffect<?> other);\n+    ResearchEffectEntry getRegistryEntry();\n \n     /**\n-     * Get the attributes of the research effect, for easier serialization.\n-     * @return the string representation of the effect and its magnitudes.\n+     * Write the ResearchEffect's traits to NBT, to simplify serialization for client-viewable data.\n+     * @return an NBT file containing at least the necessary traits to reassemble user-visible traits of the effect.\n      */\n-    String getAttributes();\n+    CompoundNBT writeToNBT();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNzc1Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551817757", "bodyText": "What does this \"display\" value represent in the context of the effect?\nIs the the strength/level?", "author": "OrionDevelopment", "createdAt": "2021-01-05T09:37:38Z", "path": "src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java", "diffHunk": "@@ -38,11 +38,31 @@\n      */\n     TranslationTextComponent getDesc();\n \n+    /**\n+     * Effect subtitle description.\n+     *\n+     * @return the Subtitle desc.\n+     */\n+    String getSubtitle();\n+\n+    /**\n+     * Returns the effect's display value\n+     *\n+     * @return the display value.\n+     */\n+    Double getDisplay();", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDIzNzgyOQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574237829", "bodyText": "At least as currently implemented, it's the difference between the effect's strength at that level of effect, and the previous level, ie the relative effect.  If the effect strength goes [0, 0.1, 0.2, 0.5], the display values will be [0, 0.1, 0.1, 0.3].  I'd used the more specific relative/absolute names previously, but that was shot down as imprecise because these values are only and should only be used for display purposes, and their internal implementation would have to become more varied to support the data-driven effect PR-to-PR.\nI will copy more of the GlobalResearchEffect jdoc which explains this behavior in greater detail to this location, though.", "author": "gattsuru", "createdAt": "2021-02-11T03:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNzc1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java b/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java\nindex c3df633108..0cf3cfe370 100755\n--- a/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java\n+++ b/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java\n\n@@ -27,42 +30,42 @@ public interface IResearchEffect<T>\n     /**\n      * Getter for the ID of the effect.\n      *\n-     * @return the String id.\n+     * @return the effect id as a ResourceLocation.\n      */\n-    String getId();\n+    ResourceLocation getId();\n \n     /**\n-     * Effect description.\n+     * Human-readable effect description, or a translation key.\n      *\n      * @return the desc.\n      */\n     TranslationTextComponent getDesc();\n \n     /**\n-     * Effect subtitle description.\n+     * Human-readable effect subtitle description, or a translation key.\n      *\n      * @return the Subtitle desc.\n      */\n-    String getSubtitle();\n+    TranslationTextComponent getSubtitle();\n \n     /**\n-     * Returns the effect's display value\n+     * Does this effect override another effect with the same id?\n      *\n-     * @return the display value.\n+     * @param other the effect to check.\n+     * @return true if so, generally meaning a higher magnitude effect.\n      */\n-    Double getDisplay();\n+    boolean overrides(@NotNull final IResearchEffect<?> other);\n \n     /**\n-     * Does this effect override another effect with the same id?\n+     * Get the {@link ResearchEffectEntry} for this Research Effect.\n      *\n-     * @param other the effect to check.\n-     * @return true if so.\n+     * @return a registry entry.\n      */\n-    boolean overrides(@NotNull final IResearchEffect<?> other);\n+    ResearchEffectEntry getRegistryEntry();\n \n     /**\n-     * Get the attributes of the research effect, for easier serialization.\n-     * @return the string representation of the effect and its magnitudes.\n+     * Write the ResearchEffect's traits to NBT, to simplify serialization for client-viewable data.\n+     * @return an NBT file containing at least the necessary traits to reassemble user-visible traits of the effect.\n      */\n-    String getAttributes();\n+    CompoundNBT writeToNBT();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5OTkyNw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551899927", "bodyText": "With datadriven how is overriding supposed to work?", "author": "OrionDevelopment", "createdAt": "2021-01-05T12:24:40Z", "path": "src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java", "diffHunk": "@@ -38,11 +38,31 @@\n      */\n     TranslationTextComponent getDesc();\n \n+    /**\n+     * Effect subtitle description.\n+     *\n+     * @return the Subtitle desc.\n+     */\n+    String getSubtitle();\n+\n+    /**\n+     * Returns the effect's display value\n+     *\n+     * @return the display value.\n+     */\n+    Double getDisplay();\n+\n     /**\n      * Does this effect override another effect with the same id?\n      *\n      * @param other the effect to check.\n      * @return true if so.\n      */\n     boolean overrides(@NotNull final IResearchEffect<?> other);", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDIzNDcxNw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574234717", "bodyText": "That's been one of the challenges for the data-driven effects PR-to-PR you asked for.\nWhere a numeric output exists these comparisons aren't terribly hard to work with, but for tagged functions that overrides method may well get removed.  I've left it for now because a) it existed and b) it will provide some protection against packmaker created research trees where an effect of the same type exists on multiple different branches or subbranches, but, yes, the data-driven effects will probably see it disappear.", "author": "gattsuru", "createdAt": "2021-02-11T03:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5OTkyNw=="}], "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java b/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java\nindex c3df633108..0cf3cfe370 100755\n--- a/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java\n+++ b/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java\n\n@@ -27,42 +30,42 @@ public interface IResearchEffect<T>\n     /**\n      * Getter for the ID of the effect.\n      *\n-     * @return the String id.\n+     * @return the effect id as a ResourceLocation.\n      */\n-    String getId();\n+    ResourceLocation getId();\n \n     /**\n-     * Effect description.\n+     * Human-readable effect description, or a translation key.\n      *\n      * @return the desc.\n      */\n     TranslationTextComponent getDesc();\n \n     /**\n-     * Effect subtitle description.\n+     * Human-readable effect subtitle description, or a translation key.\n      *\n      * @return the Subtitle desc.\n      */\n-    String getSubtitle();\n+    TranslationTextComponent getSubtitle();\n \n     /**\n-     * Returns the effect's display value\n+     * Does this effect override another effect with the same id?\n      *\n-     * @return the display value.\n+     * @param other the effect to check.\n+     * @return true if so, generally meaning a higher magnitude effect.\n      */\n-    Double getDisplay();\n+    boolean overrides(@NotNull final IResearchEffect<?> other);\n \n     /**\n-     * Does this effect override another effect with the same id?\n+     * Get the {@link ResearchEffectEntry} for this Research Effect.\n      *\n-     * @param other the effect to check.\n-     * @return true if so.\n+     * @return a registry entry.\n      */\n-    boolean overrides(@NotNull final IResearchEffect<?> other);\n+    ResearchEffectEntry getRegistryEntry();\n \n     /**\n-     * Get the attributes of the research effect, for easier serialization.\n-     * @return the string representation of the effect and its magnitudes.\n+     * Write the ResearchEffect's traits to NBT, to simplify serialization for client-viewable data.\n+     * @return an NBT file containing at least the necessary traits to reassemble user-visible traits of the effect.\n      */\n-    String getAttributes();\n+    CompoundNBT writeToNBT();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMDA1NA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551900054", "bodyText": "See comment before on this.\nWhat are attributes?", "author": "OrionDevelopment", "createdAt": "2021-01-05T12:24:56Z", "path": "src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java", "diffHunk": "@@ -38,11 +38,31 @@\n      */\n     TranslationTextComponent getDesc();\n \n+    /**\n+     * Effect subtitle description.\n+     *\n+     * @return the Subtitle desc.\n+     */\n+    String getSubtitle();\n+\n+    /**\n+     * Returns the effect's display value\n+     *\n+     * @return the display value.\n+     */\n+    Double getDisplay();\n+\n     /**\n      * Does this effect override another effect with the same id?\n      *\n      * @param other the effect to check.\n      * @return true if so.\n      */\n     boolean overrides(@NotNull final IResearchEffect<?> other);\n+\n+    /**\n+     * Get the attributes of the research effect, for easier serialization.\n+     * @return the string representation of the effect and its magnitudes.\n+     */\n+    String getAttributes();", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java b/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java\nindex c3df633108..0cf3cfe370 100755\n--- a/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java\n+++ b/src/api/java/com/minecolonies/api/research/effects/IResearchEffect.java\n\n@@ -27,42 +30,42 @@ public interface IResearchEffect<T>\n     /**\n      * Getter for the ID of the effect.\n      *\n-     * @return the String id.\n+     * @return the effect id as a ResourceLocation.\n      */\n-    String getId();\n+    ResourceLocation getId();\n \n     /**\n-     * Effect description.\n+     * Human-readable effect description, or a translation key.\n      *\n      * @return the desc.\n      */\n     TranslationTextComponent getDesc();\n \n     /**\n-     * Effect subtitle description.\n+     * Human-readable effect subtitle description, or a translation key.\n      *\n      * @return the Subtitle desc.\n      */\n-    String getSubtitle();\n+    TranslationTextComponent getSubtitle();\n \n     /**\n-     * Returns the effect's display value\n+     * Does this effect override another effect with the same id?\n      *\n-     * @return the display value.\n+     * @param other the effect to check.\n+     * @return true if so, generally meaning a higher magnitude effect.\n      */\n-    Double getDisplay();\n+    boolean overrides(@NotNull final IResearchEffect<?> other);\n \n     /**\n-     * Does this effect override another effect with the same id?\n+     * Get the {@link ResearchEffectEntry} for this Research Effect.\n      *\n-     * @param other the effect to check.\n-     * @return true if so.\n+     * @return a registry entry.\n      */\n-    boolean overrides(@NotNull final IResearchEffect<?> other);\n+    ResearchEffectEntry getRegistryEntry();\n \n     /**\n-     * Get the attributes of the research effect, for easier serialization.\n-     * @return the string representation of the effect and its magnitudes.\n+     * Write the ResearchEffect's traits to NBT, to simplify serialization for client-viewable data.\n+     * @return an NBT file containing at least the necessary traits to reassemble user-visible traits of the effect.\n      */\n-    String getAttributes();\n+    CompoundNBT writeToNBT();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMDI0NQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551900245", "bodyText": "Again this makes no sense to me.\nWhat is the value? The Strength? The Multiplier?", "author": "OrionDevelopment", "createdAt": "2021-01-05T12:25:18Z", "path": "src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java", "diffHunk": "@@ -17,10 +17,32 @@\n      */\n     <W extends IResearchEffect<?>> W getEffect(final String id, @NotNull final Class<W> type);\n \n+    /**\n+     * Get the research effect strength which is assigned to a particular string\n+     * or zero, if no matching effect is present.\n+     *\n+     * @param id   the id of the effect.\n+     * @return the strength of the effect, or zero if it isn't present.\n+     */\n+     double getEffectValue(final String id);", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java b/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\nindex 1cbc003c21..4b79bc415b 100755\n--- a/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\n+++ b/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\n\n@@ -15,24 +16,16 @@ public interface IResearchEffectManager\n      * @param <W>  the Generic type.\n      * @return one of the expected type or null.\n      */\n-    <W extends IResearchEffect<?>> W getEffect(final String id, @NotNull final Class<W> type);\n+    <W extends IResearchEffect<?>> W getEffect(final ResourceLocation id, @NotNull final Class<W> type);\n \n     /**\n-     * Get the research effect strength which is assigned to a particular string\n+     * Get the research effect strength for a given ResearchEffect type,\n      * or zero, if no matching effect is present.\n      *\n      * @param id   the id of the effect.\n      * @return the strength of the effect, or zero if it isn't present.\n      */\n-     double getEffectValue(final String id);\n-\n-    /**\n-     * Gets whether a research effect is enabled with a non-zero value.\n-     *\n-     * @param id   the id of the effect.\n-     * @return true if the is greater than zero, false if less than or equal to zero or not present.\n-     */\n-    boolean getEffectBoolean(final String id);\n+     double getEffectStrength(final ResourceLocation id);\n \n     /**\n      * Apply the effect to the research effects class.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMDUzMA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551900530", "bodyText": "And what is this doing here?\nThis feels like a massive code smell if the manager has different methods to get the type of an effect.", "author": "OrionDevelopment", "createdAt": "2021-01-05T12:25:57Z", "path": "src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java", "diffHunk": "@@ -17,10 +17,32 @@\n      */\n     <W extends IResearchEffect<?>> W getEffect(final String id, @NotNull final Class<W> type);\n \n+    /**\n+     * Get the research effect strength which is assigned to a particular string\n+     * or zero, if no matching effect is present.\n+     *\n+     * @param id   the id of the effect.\n+     * @return the strength of the effect, or zero if it isn't present.\n+     */\n+     double getEffectValue(final String id);\n+\n+    /**\n+     * Gets whether a research effect is enabled with a non-zero value.\n+     *\n+     * @param id   the id of the effect.\n+     * @return true if the is greater than zero, false if less than or equal to zero or not present.\n+     */\n+    boolean getEffectBoolean(final String id);", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI0NjIxMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574246211", "bodyText": "Was largely a helper method to make it easier to move back and forth during December when there was debate over retaining the multiple implementations of IResearchEffect for multiplier/additive/unlockbuilding/unlockability, and over supporting multiple levels of building unlocks.\nWill remove the boolean variant, as with the movement to make buildings and abilities support different strengths, it's become little more than a != null && > 0 check.", "author": "gattsuru", "createdAt": "2021-02-11T04:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMDUzMA=="}], "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java b/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\nindex 1cbc003c21..4b79bc415b 100755\n--- a/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\n+++ b/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\n\n@@ -15,24 +16,16 @@ public interface IResearchEffectManager\n      * @param <W>  the Generic type.\n      * @return one of the expected type or null.\n      */\n-    <W extends IResearchEffect<?>> W getEffect(final String id, @NotNull final Class<W> type);\n+    <W extends IResearchEffect<?>> W getEffect(final ResourceLocation id, @NotNull final Class<W> type);\n \n     /**\n-     * Get the research effect strength which is assigned to a particular string\n+     * Get the research effect strength for a given ResearchEffect type,\n      * or zero, if no matching effect is present.\n      *\n      * @param id   the id of the effect.\n      * @return the strength of the effect, or zero if it isn't present.\n      */\n-     double getEffectValue(final String id);\n-\n-    /**\n-     * Gets whether a research effect is enabled with a non-zero value.\n-     *\n-     * @param id   the id of the effect.\n-     * @return true if the is greater than zero, false if less than or equal to zero or not present.\n-     */\n-    boolean getEffectBoolean(final String id);\n+     double getEffectStrength(final ResourceLocation id);\n \n     /**\n      * Apply the effect to the research effects class.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMDgxOA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551900818", "bodyText": "Okey..... So we have effects with a numeric value, with a boolean value, and with no value......\nThis does really feel wrong.", "author": "OrionDevelopment", "createdAt": "2021-01-05T12:26:30Z", "path": "src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java", "diffHunk": "@@ -17,10 +17,32 @@\n      */\n     <W extends IResearchEffect<?>> W getEffect(final String id, @NotNull final Class<W> type);\n \n+    /**\n+     * Get the research effect strength which is assigned to a particular string\n+     * or zero, if no matching effect is present.\n+     *\n+     * @param id   the id of the effect.\n+     * @return the strength of the effect, or zero if it isn't present.\n+     */\n+     double getEffectValue(final String id);\n+\n+    /**\n+     * Gets whether a research effect is enabled with a non-zero value.\n+     *\n+     * @param id   the id of the effect.\n+     * @return true if the is greater than zero, false if less than or equal to zero or not present.\n+     */\n+    boolean getEffectBoolean(final String id);\n+\n     /**\n      * Apply the effect to the research effects class.\n      *\n      * @param effect the effect to apply.\n      */\n     void applyEffect(final IResearchEffect<?> effect);", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java b/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\nindex 1cbc003c21..4b79bc415b 100755\n--- a/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\n+++ b/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\n\n@@ -15,24 +16,16 @@ public interface IResearchEffectManager\n      * @param <W>  the Generic type.\n      * @return one of the expected type or null.\n      */\n-    <W extends IResearchEffect<?>> W getEffect(final String id, @NotNull final Class<W> type);\n+    <W extends IResearchEffect<?>> W getEffect(final ResourceLocation id, @NotNull final Class<W> type);\n \n     /**\n-     * Get the research effect strength which is assigned to a particular string\n+     * Get the research effect strength for a given ResearchEffect type,\n      * or zero, if no matching effect is present.\n      *\n      * @param id   the id of the effect.\n      * @return the strength of the effect, or zero if it isn't present.\n      */\n-     double getEffectValue(final String id);\n-\n-    /**\n-     * Gets whether a research effect is enabled with a non-zero value.\n-     *\n-     * @param id   the id of the effect.\n-     * @return true if the is greater than zero, false if less than or equal to zero or not present.\n-     */\n-    boolean getEffectBoolean(final String id);\n+     double getEffectStrength(final ResourceLocation id);\n \n     /**\n      * Apply the effect to the research effects class.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMTAwOQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551901009", "bodyText": "Documentation: When is this needed? How and why?", "author": "OrionDevelopment", "createdAt": "2021-01-05T12:26:52Z", "path": "src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java", "diffHunk": "@@ -17,10 +17,32 @@\n      */\n     <W extends IResearchEffect<?>> W getEffect(final String id, @NotNull final Class<W> type);\n \n+    /**\n+     * Get the research effect strength which is assigned to a particular string\n+     * or zero, if no matching effect is present.\n+     *\n+     * @param id   the id of the effect.\n+     * @return the strength of the effect, or zero if it isn't present.\n+     */\n+     double getEffectValue(final String id);\n+\n+    /**\n+     * Gets whether a research effect is enabled with a non-zero value.\n+     *\n+     * @param id   the id of the effect.\n+     * @return true if the is greater than zero, false if less than or equal to zero or not present.\n+     */\n+    boolean getEffectBoolean(final String id);\n+\n     /**\n      * Apply the effect to the research effects class.\n      *\n      * @param effect the effect to apply.\n      */\n     void applyEffect(final IResearchEffect<?> effect);\n+\n+    /**\n+     * Clear the contents of the effect manager.\n+     */\n+    void clear();", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java b/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\nindex 1cbc003c21..4b79bc415b 100755\n--- a/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\n+++ b/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\n\n@@ -15,24 +16,16 @@ public interface IResearchEffectManager\n      * @param <W>  the Generic type.\n      * @return one of the expected type or null.\n      */\n-    <W extends IResearchEffect<?>> W getEffect(final String id, @NotNull final Class<W> type);\n+    <W extends IResearchEffect<?>> W getEffect(final ResourceLocation id, @NotNull final Class<W> type);\n \n     /**\n-     * Get the research effect strength which is assigned to a particular string\n+     * Get the research effect strength for a given ResearchEffect type,\n      * or zero, if no matching effect is present.\n      *\n      * @param id   the id of the effect.\n      * @return the strength of the effect, or zero if it isn't present.\n      */\n-     double getEffectValue(final String id);\n-\n-    /**\n-     * Gets whether a research effect is enabled with a non-zero value.\n-     *\n-     * @param id   the id of the effect.\n-     * @return true if the is greater than zero, false if less than or equal to zero or not present.\n-     */\n-    boolean getEffectBoolean(final String id);\n+     double getEffectStrength(final ResourceLocation id);\n \n     /**\n      * Apply the effect to the research effects class.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwNTA1OA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551905058", "bodyText": "If you have a better idea how to make this (some sort of functional programming with codecs?!?!?) then I am all ears.", "author": "OrionDevelopment", "createdAt": "2021-01-05T12:35:47Z", "path": "src/api/java/com/minecolonies/api/research/factories/IGlobalResearchFactory.java", "diffHunk": "@@ -25,55 +25,101 @@ default IGlobalResearch getNewInstance(@NotNull final IFactoryController factory\n \n         if (!(context[0] instanceof String))\n         {\n-            throw new IllegalArgumentException(\"First parameter is supposed to be the String ID!\");\n+            throw new IllegalArgumentException(\"First parameter is supposed to be the ID (String)!\");\n         }\n \n         if (!(context[1] instanceof String))\n         {\n-            throw new IllegalArgumentException(\"Second parameter is supposed to be the IResearch parent!\");\n+            throw new IllegalArgumentException(\"Second parameter is supposed to be the ResourceLocation Path (String)!\");\n         }\n \n         if (!(context[2] instanceof String))\n         {\n-            throw new IllegalArgumentException(\"Third parameter is supposed to be the Branch (String)!\");\n+            throw new IllegalArgumentException(\"Third parameter is supposed to be the branchID (String)!\");\n         }\n \n         if (!(context[3] instanceof String))\n         {\n-            throw new IllegalArgumentException(\"Fourth parameter is supposed to be the Desc (String)!\");\n+            throw new IllegalArgumentException(\"Fourth parameter is supposed to be the parent (String)!\");\n         }\n \n-        if (!(context[4] instanceof Integer))\n+        if (!(context[4] instanceof String))\n         {\n-            throw new IllegalArgumentException(\"Fifth parameter is supposed to be the Depth (int)!\");\n+            throw new IllegalArgumentException(\"Fifth parameter is supposed to be the description (String)!\");\n         }\n \n-        if (!(context[5] instanceof IResearchEffect))\n+        if (!(context[5] instanceof Integer))\n         {\n-            throw new IllegalArgumentException(\"Last parameter is supposed to be the IResearchEffect!\");\n+            throw new IllegalArgumentException(\"Sixth parameter is supposed to be the Depth (int)!\");\n         }\n \n         final String id = (String) context[0];\n-        final String parent = (String) context[1];\n+        final String resourcePath = (String) context[1];\n         final String branch = (String) context[2];\n-        final String desc = (String) context[3];\n-        final int depth = (int) context[4];\n-        final IResearchEffect<?> effect = (IResearchEffect<?>) context[5];\n-        return getNewInstance(id, parent, branch, desc, depth, effect);\n+        final String parent = (String) context[3];\n+        final String desc = (String) context[4];\n+        final int depth = (int) context[5];\n+        final String icon;\n+        if(context.length > 6)\n+        {\n+            icon = (String) context[6];\n+        }\n+        else\n+        {\n+            icon = \"\";\n+        }\n+        final String subtitle;\n+        if(context.length > 7)\n+        {\n+            subtitle = (String) context[7];\n+        }\n+        else\n+        {\n+            subtitle = \"\";\n+        }\n+        final boolean onlyChild;\n+        final boolean hidden;\n+        final boolean autostart;\n+        final boolean instant;\n+        final boolean immutable;\n+        if (context.length == 13)\n+        {\n+            onlyChild = (boolean) context[8];\n+            hidden = (boolean) context[9];\n+            autostart = (boolean) context[10];\n+            instant = (boolean) context[11];\n+            immutable = (boolean) context[12];\n+        }\n+        else\n+        {\n+            onlyChild = false;\n+            hidden = false;\n+            autostart = false;\n+            instant = false;\n+            immutable = false;\n+        }\n+        return getNewInstance(id, resourcePath, branch, parent, desc, depth, icon, subtitle, onlyChild, hidden, autostart, instant, immutable);\n     }\n \n     /**\n      * Method to get a new Instance of a Research.\n      *\n-     * @param id     the id.\n-     * @param parent the parent.\n-     * @param branch the branch.\n-     * @param desc   the description.\n-     * @param depth  the depth.\n-     * @param effect the effect.\n+     * @param id                the id.\n+     * @param resourcePath      the path representation of the ResourceLocation for the research.\n+     * @param branch            the branch.\n+     * @param parent            the research's parent, or \"\" if no parent.\n+     * @param desc              the description of the research.\n+     * @param universityLevel   the university tier of the research.\n+     * @param icon              the string of the icon's characteristics.\n+     * @param subtitle          the optional subtitle description of the research.\n+     * @param onlyChild         if the research's completion prohibits its siblings from being completed.\n+     * @param hidden            if the research is visible only when it is eligible for research.\n+     * @param autostart         if the research attempts to automatically start when eligible, or reports to the player if unable.\n+     * @param instant           if the research should complete immediately.\n+     * @param immutable         if the research is locking, and can not be undone once completed.\n      * @return a new Instance of Research.\n      */\n     @NotNull\n-    IGlobalResearch getNewInstance(final String id, final String parent, final String branch, @NotNull final String desc, final int depth, final IResearchEffect<?> effect);\n+    IGlobalResearch getNewInstance(final String id, final String resourcePath, final String branch, final String parent, final String desc, final int universityLevel,\n+      final String icon,final String subtitle, final boolean onlyChild, final boolean hidden, final boolean autostart, final boolean instant, final boolean immutable);\n }", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/factories/IGlobalResearchFactory.java b/src/api/java/com/minecolonies/api/research/factories/IGlobalResearchFactory.java\nindex 9054f2958a..5f342f55ec 100755\n--- a/src/api/java/com/minecolonies/api/research/factories/IGlobalResearchFactory.java\n+++ b/src/api/java/com/minecolonies/api/research/factories/IGlobalResearchFactory.java\n\n@@ -30,35 +30,38 @@ public interface IGlobalResearchFactory extends IFactory<FactoryVoidInput, IGlob\n \n         if (!(context[1] instanceof String))\n         {\n-            throw new IllegalArgumentException(\"Second parameter is supposed to be the ResourceLocation Path (String)!\");\n+            throw new IllegalArgumentException(\"Second parameter is supposed to be the branchID (String)!\");\n         }\n \n         if (!(context[2] instanceof String))\n         {\n-            throw new IllegalArgumentException(\"Third parameter is supposed to be the branchID (String)!\");\n+            throw new IllegalArgumentException(\"Third parameter is supposed to be the parent (String)!\");\n         }\n \n         if (!(context[3] instanceof String))\n         {\n-            throw new IllegalArgumentException(\"Fourth parameter is supposed to be the parent (String)!\");\n+            throw new IllegalArgumentException(\"Fourth parameter is supposed to be the description (String)!\");\n         }\n \n-        if (!(context[4] instanceof String))\n+        if (!(context[4] instanceof Integer))\n         {\n-            throw new IllegalArgumentException(\"Fifth parameter is supposed to be the description (String)!\");\n+            throw new IllegalArgumentException(\"Fifth parameter is supposed to be the Depth (int)!\");\n         }\n \n-        if (!(context[5] instanceof Integer))\n+        final String id = (String) context[0];\n+        final String branch = (String) context[1];\n+        final String parent = (String) context[2];\n+        final String desc = (String) context[3];\n+        final int depth = (int) context[4];\n+        final int sortOrder;\n+        if(context.length > 5)\n         {\n-            throw new IllegalArgumentException(\"Sixth parameter is supposed to be the Depth (int)!\");\n+            sortOrder = (int) context[5];\n+        }\n+        else\n+        {\n+            sortOrder = 1;\n         }\n-\n-        final String id = (String) context[0];\n-        final String resourcePath = (String) context[1];\n-        final String branch = (String) context[2];\n-        final String parent = (String) context[3];\n-        final String desc = (String) context[4];\n-        final int depth = (int) context[5];\n         final String icon;\n         if(context.length > 6)\n         {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwNjIzMA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551906230", "bodyText": "I think this can already be done with existing handlers, since builders etc need this logic.", "author": "OrionDevelopment", "createdAt": "2021-01-05T12:38:10Z", "path": "src/api/java/com/minecolonies/api/util/InventoryUtils.java", "diffHunk": "@@ -282,6 +282,33 @@ public static int getItemCountInItemHandlers(@Nullable final Collection<IItemHan\n         return count;\n     }\n \n+    /**\n+     * Checks if an ItemHandler has an ItemStack, including count, optionally checking to match damage and NBT.\n+     *\n+     * @param handler       ItemHandler to search in.\n+     * @param input         ItemStack to search for.\n+     * @param matchDamage   If item damage values should be used.\n+     * @param matchNBT      If item NBT values should be used.\n+     * @return      true if the ItemHandler has the items, false if not.\n+     */\n+    public static boolean hasItemStackInItemHandler(IItemHandler handler, @NotNull ItemStack input, boolean matchDamage, boolean matchNBT)\n+    {\n+        int amount = input.getCount();\n+        for (int i = 0; i < handler.getSlots(); i++)\n+        {\n+            if (ItemStackUtils.compareItemStacksIgnoreStackSize(handler.getStackInSlot(i), input, matchDamage, matchNBT))\n+            {\n+                amount = amount - handler.extractItem(i, amount, false).getCount();\n+\n+                if (amount <= 0)\n+                {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f8908f8c1636c3966450176571629e57993ffded", "chunk": "diff --git a/src/api/java/com/minecolonies/api/util/InventoryUtils.java b/src/api/java/com/minecolonies/api/util/InventoryUtils.java\nindex e24c98d4a7..49ef499012 100755\n--- a/src/api/java/com/minecolonies/api/util/InventoryUtils.java\n+++ b/src/api/java/com/minecolonies/api/util/InventoryUtils.java\n\n@@ -282,33 +282,6 @@ public class InventoryUtils\n         return count;\n     }\n \n-    /**\n-     * Checks if an ItemHandler has an ItemStack, including count, optionally checking to match damage and NBT.\n-     *\n-     * @param handler       ItemHandler to search in.\n-     * @param input         ItemStack to search for.\n-     * @param matchDamage   If item damage values should be used.\n-     * @param matchNBT      If item NBT values should be used.\n-     * @return      true if the ItemHandler has the items, false if not.\n-     */\n-    public static boolean hasItemStackInItemHandler(IItemHandler handler, @NotNull ItemStack input, boolean matchDamage, boolean matchNBT)\n-    {\n-        int amount = input.getCount();\n-        for (int i = 0; i < handler.getSlots(); i++)\n-        {\n-            if (ItemStackUtils.compareItemStacksIgnoreStackSize(handler.getStackInSlot(i), input, matchDamage, matchNBT))\n-            {\n-                amount = amount - handler.extractItem(i, amount, false).getCount();\n-\n-                if (amount <= 0)\n-                {\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n     /**\n      * Checks if a player has a block in the {@link IItemHandler}. Checked by {@link #getItemCountInItemHandler(IItemHandler, Block)} &gt; 0;\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwNjQ3Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551906476", "bodyText": "Double loop: Extremely bad for performance.", "author": "OrionDevelopment", "createdAt": "2021-01-05T12:38:41Z", "path": "src/api/java/com/minecolonies/api/util/InventoryUtils.java", "diffHunk": "@@ -2149,13 +2180,47 @@ public static boolean tryRemoveStackFromItemHandler(final IItemHandler handler,\n                 }\n             }\n         }\n-\n-        final ItemStack revertStack = input.copy();\n-        revertStack.setCount(input.getCount() - amount);\n-        addItemStackToItemHandler(handler, revertStack);\n+        // This should never happen.\n         return false;\n     }", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwNjc1NA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551906754", "bodyText": "Since this has nothing todo with data driven research, I see no reason to have these changes in this PR.\nCreate a new PR if you want bugs to be fixed.", "author": "OrionDevelopment", "createdAt": "2021-01-05T12:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwNjQ3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f8908f8c1636c3966450176571629e57993ffded", "chunk": "diff --git a/src/api/java/com/minecolonies/api/util/InventoryUtils.java b/src/api/java/com/minecolonies/api/util/InventoryUtils.java\nindex e24c98d4a7..49ef499012 100755\n--- a/src/api/java/com/minecolonies/api/util/InventoryUtils.java\n+++ b/src/api/java/com/minecolonies/api/util/InventoryUtils.java\n\n@@ -2180,45 +2149,11 @@ public class InventoryUtils\n                 }\n             }\n         }\n-        // This should never happen.\n-        return false;\n-    }\n \n-    /**\n-     * Tries to remove a group of ItemStorages with its size from a given ItemHandler. Only removes stacks if every stack's full count is present.\n-     *\n-     * @param handler      the itemHandler.\n-     * @param input        the List of ItemStorage to remove.\n-     * @return true if removed the stacks\n-     */\n-    public static boolean tryRemoveStorageFromItemHandler(final IItemHandler handler, final List<ItemStorage> input)\n-    {\n-        for(final ItemStorage is : input)\n-        {\n-            if(!hasItemStackInItemHandler(handler, is.getItemStack(), is.ignoreDamageValue(), is.ignoreNBT()))\n-            {\n-                return false;\n-            }\n-        }\n-\n-        for(final ItemStorage is : input)\n-        {\n-            int amount = is.getItemStack().getCount();\n-\n-            for (int i = 0; i < handler.getSlots(); i++)\n-            {\n-                if (ItemStackUtils.compareItemStacksIgnoreStackSize(handler.getStackInSlot(i), is.getItemStack()))\n-                {\n-                    amount = amount - handler.extractItem(i, amount, false).getCount();\n-\n-                    if (amount == 0)\n-                    {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-        return true;\n+        final ItemStack revertStack = input.copy();\n+        revertStack.setCount(input.getCount() - amount);\n+        addItemStackToItemHandler(handler, revertStack);\n+        return false;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwNzAzNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551907035", "bodyText": "This again makes no sense here.\nWhy was this added? What has this todo with data driven PRs?", "author": "OrionDevelopment", "createdAt": "2021-01-05T12:39:54Z", "path": "src/api/java/com/minecolonies/api/util/InventoryUtils.java", "diffHunk": "@@ -2149,13 +2180,47 @@ public static boolean tryRemoveStackFromItemHandler(final IItemHandler handler,\n                 }\n             }\n         }\n-\n-        final ItemStack revertStack = input.copy();\n-        revertStack.setCount(input.getCount() - amount);\n-        addItemStackToItemHandler(handler, revertStack);\n+        // This should never happen.\n         return false;\n     }\n \n+    /**\n+     * Tries to remove a group of ItemStorages with its size from a given ItemHandler. Only removes stacks if every stack's full count is present.\n+     *\n+     * @param handler      the itemHandler.\n+     * @param input        the List of ItemStorage to remove.\n+     * @return true if removed the stacks\n+     */\n+    public static boolean tryRemoveStorageFromItemHandler(final IItemHandler handler, final List<ItemStorage> input)\n+    {\n+        for(final ItemStorage is : input)\n+        {\n+            if(!hasItemStackInItemHandler(handler, is.getItemStack(), is.ignoreDamageValue(), is.ignoreNBT()))\n+            {\n+                return false;\n+            }\n+        }\n+\n+        for(final ItemStorage is : input)\n+        {\n+            int amount = is.getItemStack().getCount();\n+\n+            for (int i = 0; i < handler.getSlots(); i++)\n+            {\n+                if (ItemStackUtils.compareItemStacksIgnoreStackSize(handler.getStackInSlot(i), is.getItemStack()))\n+                {\n+                    amount = amount - handler.extractItem(i, amount, false).getCount();\n+\n+                    if (amount == 0)\n+                    {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDIzMTM3OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r574231379", "bodyText": "As far as I can tell, all of the similar functions use either require NBT and damage matching (recipes, builder items), or use Predicates (builder tools).  Because one of the possible supported (and default) items for the Undo Research function is Ancient Tomes (which always have NBT data when held by players) and this was better handled in the server-config file than a datapack, we need some approach for item selection which can be implemented in the config readably.\nOnce it came to that, the previous method was functional enough for me to use and copy, but had potential issues and the change to this implementation was requested as part of the conversation here with Raycoms.", "author": "gattsuru", "createdAt": "2021-02-11T03:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwNzAzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "f8908f8c1636c3966450176571629e57993ffded", "chunk": "diff --git a/src/api/java/com/minecolonies/api/util/InventoryUtils.java b/src/api/java/com/minecolonies/api/util/InventoryUtils.java\nindex e24c98d4a7..49ef499012 100755\n--- a/src/api/java/com/minecolonies/api/util/InventoryUtils.java\n+++ b/src/api/java/com/minecolonies/api/util/InventoryUtils.java\n\n@@ -2180,45 +2149,11 @@ public class InventoryUtils\n                 }\n             }\n         }\n-        // This should never happen.\n-        return false;\n-    }\n \n-    /**\n-     * Tries to remove a group of ItemStorages with its size from a given ItemHandler. Only removes stacks if every stack's full count is present.\n-     *\n-     * @param handler      the itemHandler.\n-     * @param input        the List of ItemStorage to remove.\n-     * @return true if removed the stacks\n-     */\n-    public static boolean tryRemoveStorageFromItemHandler(final IItemHandler handler, final List<ItemStorage> input)\n-    {\n-        for(final ItemStorage is : input)\n-        {\n-            if(!hasItemStackInItemHandler(handler, is.getItemStack(), is.ignoreDamageValue(), is.ignoreNBT()))\n-            {\n-                return false;\n-            }\n-        }\n-\n-        for(final ItemStorage is : input)\n-        {\n-            int amount = is.getItemStack().getCount();\n-\n-            for (int i = 0; i < handler.getSlots(); i++)\n-            {\n-                if (ItemStackUtils.compareItemStacksIgnoreStackSize(handler.getStackInSlot(i), is.getItemStack()))\n-                {\n-                    amount = amount - handler.extractItem(i, amount, false).getCount();\n-\n-                    if (amount == 0)\n-                    {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-        return true;\n+        final ItemStack revertStack = input.copy();\n+        revertStack.setCount(input.getCount() - amount);\n+        addItemStackToItemHandler(handler, revertStack);\n+        return false;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwNzExMA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r551907110", "bodyText": "NOOP Line change. Please remove.", "author": "OrionDevelopment", "createdAt": "2021-01-05T12:40:07Z", "path": "src/api/java/com/minecolonies/api/util/InventoryUtils.java", "diffHunk": "@@ -2188,6 +2253,7 @@ public static void removeStackFromItemHandler(final IItemHandler handler, final\n             }\n             tries++;\n         }\n+        return;", "originalCommit": "14d6e68d321cfbc7fa9980d73db1387c8b51fadb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "chunk": "diff --git a/src/api/java/com/minecolonies/api/util/InventoryUtils.java b/src/api/java/com/minecolonies/api/util/InventoryUtils.java\nindex e24c98d4a7..b755693014 100755\n--- a/src/api/java/com/minecolonies/api/util/InventoryUtils.java\n+++ b/src/api/java/com/minecolonies/api/util/InventoryUtils.java\n\n@@ -2253,7 +2253,6 @@ public class InventoryUtils\n             }\n             tries++;\n         }\n-        return;\n     }\n \n     /**\n"}}, {"oid": "d6e30f04e2a034772b700dd41e4e448c65a9579d", "url": "https://github.com/ldtteam/minecolonies/commit/d6e30f04e2a034772b700dd41e4e448c65a9579d", "message": "Merge branch 'version/1.16.3' into version/1.16.3-research-datapack", "committedDate": "2021-02-13T00:21:58Z", "type": "commit"}, {"oid": "a9d63006624bcd975ce2058c5c6e291eb3fac159", "url": "https://github.com/ldtteam/minecolonies/commit/a9d63006624bcd975ce2058c5c6e291eb3fac159", "message": "Format, Type, Return Type, and Clean Up Work from Code Review\n\n* researchIds, researchEffectIds and branchIds always ResourceLocation.  Research and Effect Subtitles, Descriptions, and Names always TranslationTexts.  ItemCosts for research and Reset Costs for resetting research are all turned into ItemStorage.\n* getIcon() is now split into getIconTextureResourceLocation() and getIconItemStack(), which return just the ResourceLocation or ItemStack, respectively.\n\n* Removed IResearchEffect.getDisplay and IResearchEffect.getBoolean.\n* Renamed IResearchEffect.getEffectValue to getEffectStrength.\n* Replaced IResearchEffect and IResearchRequirement getAttributes with writeToNBT, and created relevant constructors to reassemble from nbt.\n* Implemented an extremely simple pair of ForgeRegistry for ResearchEffects and ResearchRequirements.  The ResearchEffectRegistry will expand over time.\n* Changed `EffectManager.clear` to `EffectManager.removeAllEffects`, and significantly expanded the jdoc to explain its current and expected use cases.\n* ResearchManagers have an internal field storing the IColony.\n* Removal of noop edits or extraneous line breaks.", "committedDate": "2021-02-13T23:52:00Z", "type": "commit"}, {"oid": "00533236c96bee2767122cb8e30858869a650eb4", "url": "https://github.com/ldtteam/minecolonies/commit/00533236c96bee2767122cb8e30858869a650eb4", "message": "Merge remote-tracking branch 'gattsuru/version/1.16.3-research-datapack' into version/1.16.3-research-datapack", "committedDate": "2021-02-13T23:53:45Z", "type": "commit"}, {"oid": "d9436838bd8bb3ab42f6f5d348758aab2f927369", "url": "https://github.com/ldtteam/minecolonies/commit/d9436838bd8bb3ab42f6f5d348758aab2f927369", "message": "Turn off Icons, Access\n\nActually disable DRAW_ICONS, and clean up access modifiers and some related jdocs.", "committedDate": "2021-02-14T05:12:29Z", "type": "commit"}, {"oid": "db05258b9e27aae972211ec645236ded62b1d64d", "url": "https://github.com/ldtteam/minecolonies/commit/db05258b9e27aae972211ec645236ded62b1d64d", "message": "Merge branch 'version/1.16.3' into version/1.16.3-research-datapack", "committedDate": "2021-02-14T12:25:26Z", "type": "commit"}, {"oid": "f8908f8c1636c3966450176571629e57993ffded", "url": "https://github.com/ldtteam/minecolonies/commit/f8908f8c1636c3966450176571629e57993ffded", "message": "Revert InventoryUtils, Begin DataGenerator Work\n\nReverts all changes to InventoryUtils to match the ldtteam/version1.16.3 current version.\nMoves to predicate-based test approaches for ResearchCosts and ResearchReset costs.\nBlatantly copies the CustomRecipe nbt parser.\nPartial commit for the research DataGenerator.  Abstract Class and its children are together, but need to fill out the actual implementation listing the current researches and effects.\nSome misc cleanup.", "committedDate": "2021-02-15T06:02:23Z", "type": "commit"}, {"oid": "4aa5db1e5b89c662fd7e6ce01910c728d4580884", "url": "https://github.com/ldtteam/minecolonies/commit/4aa5db1e5b89c662fd7e6ce01910c728d4580884", "message": "Prototype-Level Research Data Generator\n\nInitial version completes, runs, and outputs branch, effect, research files, along with a single lang file.", "committedDate": "2021-02-16T03:38:07Z", "type": "commit"}, {"oid": "02c013f6ebc55c548006d3b94ede4e574bc5bcbd", "url": "https://github.com/ldtteam/minecolonies/commit/02c013f6ebc55c548006d3b94ede4e574bc5bcbd", "message": "Merge remote-tracking branch 'ldtteam/version/1.16.3' into version/1.16.3-research-datapack", "committedDate": "2021-02-17T15:12:33Z", "type": "commit"}, {"oid": "4ed1dbabde858dc38935c1d292e869d2b30ecef2", "url": "https://github.com/ldtteam/minecolonies/commit/4ed1dbabde858dc38935c1d292e869d2b30ecef2", "message": "Updates Research GUI for New BlockOut Compatibility\n\nMoves for compatibility with Text over Label, with the new TooltipBuilder, and for general better compliance. \n\nDoesn't have the TooltipBuilder formatting arguments right, yet.  Effectively a transfer commit, but wanted to get the merge in place.", "committedDate": "2021-02-18T03:27:33Z", "type": "commit"}, {"oid": "0f274ecadf6833396f3c19627cf6dfb5e5e3a38b", "url": "https://github.com/ldtteam/minecolonies/commit/0f274ecadf6833396f3c19627cf6dfb5e5e3a38b", "message": "Some TooltipBuilder Cleanup\n\nGets rid of unnecessary resetStyles, readds the deepCopy to styled Research Names to avoid gilding the wrong spots.", "committedDate": "2021-02-18T05:39:57Z", "type": "commit"}, {"oid": "3f417cebaac06a2f544b3e251e3bbcd1ba6a1fb4", "url": "https://github.com/ldtteam/minecolonies/commit/3f417cebaac06a2f544b3e251e3bbcd1ba6a1fb4", "message": "Merge branch 'version/1.16.3' into version/1.16.3-research-datapack", "committedDate": "2021-02-18T16:41:59Z", "type": "commit"}, {"oid": "14f603ff9fb72e770472fef349efc4200f98e0a7", "url": "https://github.com/ldtteam/minecolonies/commit/14f603ff9fb72e770472fef349efc4200f98e0a7", "message": "Merge branch 'version/1.16.3' into version/1.16.3-research-datapack", "committedDate": "2021-02-20T15:32:17Z", "type": "commit"}, {"oid": "185fb2b796f6dc2d13ec5a1d33348129d7ee9d69", "url": "https://github.com/ldtteam/minecolonies/commit/185fb2b796f6dc2d13ec5a1d33348129d7ee9d69", "message": "Further BlockOut Tooltip Compat\n\nFixes to use the .style and .color commands properly, instead of styling the translationText before applying it.", "committedDate": "2021-02-20T15:37:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTY4NzM5MA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r579687390", "bodyText": "contains what? sth is missing here", "author": "ravenbuilder934", "createdAt": "2021-02-20T17:56:01Z", "path": "src/api/java/com/minecolonies/api/research/effects/ModResearchEffects.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package com.minecolonies.api.research.effects;\n+\n+import com.minecolonies.api.research.effects.registry.ResearchEffectEntry;\n+import com.minecolonies.api.util.constant.Constants;\n+import net.minecraft.util.ResourceLocation;\n+\n+/**\n+ *  Contains", "originalCommit": "185fb2b796f6dc2d13ec5a1d33348129d7ee9d69", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf1a8722550cf9bb704b382a9313a38d4ff65f09", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/effects/ModResearchEffects.java b/src/api/java/com/minecolonies/api/research/effects/ModResearchEffects.java\nindex d3ba1624f5..9464554572 100644\n--- a/src/api/java/com/minecolonies/api/research/effects/ModResearchEffects.java\n+++ b/src/api/java/com/minecolonies/api/research/effects/ModResearchEffects.java\n\n@@ -5,7 +5,7 @@ import com.minecolonies.api.util.constant.Constants;\n import net.minecraft.util.ResourceLocation;\n \n /**\n- *  Contains\n+ *  Contains a list of research effects by type.  Currently only supports absolute modifiers through Global Research Effect.\n  */\n public class ModResearchEffects\n {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTY4ODM0Mg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r579688342", "bodyText": "still have a change here \ud83d\ude1b", "author": "ravenbuilder934", "createdAt": "2021-02-20T18:04:45Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/planter/EntityAIWorkPlanter.java", "diffHunk": "@@ -199,7 +199,6 @@ protected IAIState decide()\n                 return PLANTATION_PLANT;\n             }\n         }\n-", "originalCommit": "185fb2b796f6dc2d13ec5a1d33348129d7ee9d69", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf1a8722550cf9bb704b382a9313a38d4ff65f09", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/entity/ai/citizen/planter/EntityAIWorkPlanter.java b/src/main/java/com/minecolonies/coremod/entity/ai/citizen/planter/EntityAIWorkPlanter.java\nindex 056cdb3659..811a8eaf81 100755\n--- a/src/main/java/com/minecolonies/coremod/entity/ai/citizen/planter/EntityAIWorkPlanter.java\n+++ b/src/main/java/com/minecolonies/coremod/entity/ai/citizen/planter/EntityAIWorkPlanter.java\n\n@@ -199,6 +199,7 @@ public class EntityAIWorkPlanter extends AbstractEntityAICrafting<JobPlanter, Bu\n                 return PLANTATION_PLANT;\n             }\n         }\n+\n         return START_WORKING;\n     }\n \n"}}, {"oid": "bf1a8722550cf9bb704b382a9313a38d4ff65f09", "url": "https://github.com/ldtteam/minecolonies/commit/bf1a8722550cf9bb704b382a9313a38d4ff65f09", "message": "JDoc Cleanup, some fixes to match new BlockOut PR\n\nFixes a number of edge cases regarding tooltips, especially related to the undo/cancel research functions.  Cleans up a number of jdocs and comments, tightens down some access modifiers. \nHopefully actually removes EntityAIWorkPlanter's erroneously added line this time.", "committedDate": "2021-02-20T22:22:27Z", "type": "commit"}, {"oid": "04b34ba68cfa4ef836fc9b7ceaebbc9783606032", "url": "https://github.com/ldtteam/minecolonies/commit/04b34ba68cfa4ef836fc9b7ceaebbc9783606032", "message": "Merge branch 'version/1.16.3' into version/1.16.3-research-datapack", "committedDate": "2021-02-23T16:23:35Z", "type": "commit"}, {"oid": "de33bde053c332ee85329ce47f9f746888b36441", "url": "https://github.com/ldtteam/minecolonies/commit/de33bde053c332ee85329ce47f9f746888b36441", "message": "Merge branch 'version/1.16.3' into version/1.16.3-research-datapack", "committedDate": "2021-02-24T16:47:43Z", "type": "commit"}, {"oid": "e5f61076819aef16dc12c4422f6f5c8eb58488f3", "url": "https://github.com/ldtteam/minecolonies/commit/e5f61076819aef16dc12c4422f6f5c8eb58488f3", "message": "Merge remote-tracking branch 'ldtteam/version/1.16.3' into version/1.16.3-research-datapack", "committedDate": "2021-02-27T01:46:02Z", "type": "commit"}, {"oid": "f0f6655c6ef992d19ba5fd0f06d914f15f858503", "url": "https://github.com/ldtteam/minecolonies/commit/f0f6655c6ef992d19ba5fd0f06d914f15f858503", "message": "Cleanup of Mystical Site, Plate Armor Merge\n\nMoves the new Mystical Site and Plate Armor researches into datagen and existing jsons together.\n\nSome unrelated cleanup of datagen, text positioning, and improved handling of malformed jsons.", "committedDate": "2021-02-27T03:08:54Z", "type": "commit"}, {"oid": "4bdc3fa494da069fc258fe8b82252824e68dbf9b", "url": "https://github.com/ldtteam/minecolonies/commit/4bdc3fa494da069fc258fe8b82252824e68dbf9b", "message": "Update src/main/resources/assets/minecolonies/lang/en_us.json\n\nCo-authored-by: ravenbuilder934 <sabrinajamie@outlook.com>", "committedDate": "2021-02-27T18:48:15Z", "type": "commit"}, {"oid": "8cce83d7f4b0a3f2d493d828c1147f22baad0f06", "url": "https://github.com/ldtteam/minecolonies/commit/8cce83d7f4b0a3f2d493d828c1147f22baad0f06", "message": "Final Compat Layer Pass, Grammar Fix\n\nFixes the datagen side of the fix Raven caught, and adds upgrade compat for the Ambition and PlateArmor researches.", "committedDate": "2021-02-27T18:53:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg5MTYwNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r533891605", "bodyText": "We should consider storing the ResourceLocation on each research. This loading code is great for adding researches, but but we need a way to remove researches too, and the best match for that is going to the resource location.\nPlease add a mechanism for removing researches.", "author": "Mekle001", "createdAt": "2020-12-02T04:38:35Z", "path": "src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.minecolonies.coremod.datalistener;\n+\n+import com.google.gson.*;\n+import com.minecolonies.api.MinecoloniesAPIProxy;\n+import com.minecolonies.api.research.IGlobalResearchTree;\n+import com.minecolonies.api.util.Log;\n+\n+import com.minecolonies.coremod.research.GlobalResearch;\n+import net.minecraft.client.resources.JsonReloadListener;\n+import net.minecraft.profiler.IProfiler;\n+import net.minecraft.resources.IResourceManager;\n+import net.minecraft.util.ResourceLocation;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Loader for Json based crafter specific recipes\n+ */\n+public class ResearchListener extends JsonReloadListener\n+{\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().create();\n+\n+    /**\n+     * Set up the core loading, with the directory in the datapack that contains this data\n+     * Directory is: <namespace>/researches/<path>\n+     */\n+    public ResearchListener()\n+    {\n+        super(GSON, \"researches\");\n+    }\n+\n+    @Override\n+    protected void apply(final Map<ResourceLocation, JsonElement> object, final IResourceManager resourceManagerIn, final IProfiler profilerIn)\n+    {\n+        Log.getLogger().info(\"Beginning load of research for University.\");\n+\n+        // First, populate a new map of IGlobalResearches, identified by researchID.\n+        // This allows us to figure out root/branch relationships more sanely.\n+        final Map<String, GlobalResearch> researchMap = new HashMap<String, GlobalResearch>();\n+        for(final Map.Entry<ResourceLocation, JsonElement> entry : object.entrySet())\n+        {\n+            //Note that we don't actually use the resource folders or file names; those are only for organization purposes.", "originalCommit": "af6b37f2f56ad33702cec2d24493beab62614ad3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkwNDc3NA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r533904774", "bodyText": "Ok.  I can put that in pretty fast, though I will warn that deregistering a research will need to hide all of its children on the University UI, at least without a significant rewrite there,, and deregistering a researchEffect may cause it to lose progress or reset, so going to put in different methods for each of those two use cases.", "author": "gattsuru", "createdAt": "2020-12-02T05:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg5MTYwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkyMDE1MQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r533920151", "bodyText": "Yup. There isn't a clean solution for removing a research from an existing world, but for a modpack, removal should allow it to never exist in the world.  As for the children issue, yeah, a child without a parent should either 'disappear' or move to the top.", "author": "Mekle001", "createdAt": "2020-12-02T06:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg5MTYwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\nindex 91ecf42b1f..e4975dd43d 100644\n--- a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n+++ b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n\n@@ -2,20 +2,31 @@ package com.minecolonies.coremod.datalistener;\n \n import com.google.gson.*;\n import com.minecolonies.api.MinecoloniesAPIProxy;\n+import com.minecolonies.api.crafting.ItemStorage;\n import com.minecolonies.api.research.IGlobalResearchTree;\n+import com.minecolonies.api.research.IResearchRequirement;\n+import com.minecolonies.api.research.effects.IResearchEffect;\n import com.minecolonies.api.util.Log;\n \n import com.minecolonies.coremod.research.GlobalResearch;\n+import com.minecolonies.coremod.research.ResearchEffectCategory;\n import net.minecraft.client.resources.JsonReloadListener;\n+import net.minecraft.entity.player.ServerPlayerEntity;\n import net.minecraft.profiler.IProfiler;\n import net.minecraft.resources.IResourceManager;\n+import net.minecraft.server.MinecraftServer;\n+import net.minecraft.server.dedicated.DedicatedServer;\n import net.minecraft.util.ResourceLocation;\n+import net.minecraftforge.fml.server.ServerLifecycleHooks;\n \n import java.util.HashMap;\n import java.util.Map;\n \n+import static com.minecolonies.coremod.research.GlobalResearch.*;\n+import static com.minecolonies.coremod.research.ResearchEffectCategory.*;\n+\n /**\n- * Loader for Json based crafter specific recipes\n+ * Loader for Json-based researches\n  */\n public class ResearchListener extends JsonReloadListener\n {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg5NDQ2MA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r533894460", "bodyText": "We're doing something similar for recipes in the RecipeManager. We should use a common approach for this problem.", "author": "Mekle001", "createdAt": "2020-12-02T04:48:51Z", "path": "src/main/java/com/minecolonies/coremod/event/EventHandler.java", "diffHunk": "@@ -754,5 +755,8 @@ public static void onWorldUnload(@NotNull final WorldEvent.Unload event)\n             ItemBlockHut.checkResearch(null);\n             Log.getLogger().info(\"Removed all colony views\");\n         }\n+        // Since there doesn't seem to be a Forge event for a datapack being unloaded, there's not many better places to handle this.\n+        // Otherwise, loading a world with any custom research will show research effects that don't exist on other worlds in the same instance.\n+        IResearchEffectRegistry.getInstance().resetRegistry();", "originalCommit": "af6b37f2f56ad33702cec2d24493beab62614ad3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/event/EventHandler.java b/src/main/java/com/minecolonies/coremod/event/EventHandler.java\nindex a971266b8f..bf656f9fc9 100755\n--- a/src/main/java/com/minecolonies/coremod/event/EventHandler.java\n+++ b/src/main/java/com/minecolonies/coremod/event/EventHandler.java\n\n@@ -755,8 +769,5 @@ public class EventHandler\n             ItemBlockHut.checkResearch(null);\n             Log.getLogger().info(\"Removed all colony views\");\n         }\n-        // Since there doesn't seem to be a Forge event for a datapack being unloaded, there's not many better places to handle this.\n-        // Otherwise, loading a world with any custom research will show research effects that don't exist on other worlds in the same instance.\n-        IResearchEffectRegistry.getInstance().resetRegistry();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAwMzEzMg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r534003132", "bodyText": "I've been wondering wether we need this at all, as our current effects are already very general and the way I see it are enclosing all possible use cases. We've got a boolean yes/no effect and a numeric effect to retrive as information, so not sure if this isnt just an overkill.", "author": "someaddons", "createdAt": "2020-12-02T09:08:32Z", "path": "src/api/java/com/minecolonies/api/research/registry/IResearchEffectRegistry.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.minecolonies.api.research.registry;\n+\n+import com.minecolonies.api.IMinecoloniesAPI;\n+import com.minecolonies.api.research.effects.IResearchEffect;\n+\n+import java.util.Collection;\n+import java.util.Set;\n+\n+/**\n+ *   An interface providing information about Minecolonies Research Effects,\n+ *   and the ability to register new effects.  Also some helper classes to reduce later sorting.\n+ *   This ResearchEffectRegistry should include both research effects regardless of status:\n+ *   Use {@link com.minecolonies.api.research.effects.IResearchEffectManager}\n+ *   to set and apply effects for completed research.\n+ *   Use {MinecoloniesAPIProxy.getInstance().getGlobalResearchTree()}\n+ *   to add research to the University Research System.\n+ */\n+\n+public interface IResearchEffectRegistry", "originalCommit": "af6b37f2f56ad33702cec2d24493beab62614ad3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE4NTk2OA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r534185968", "bodyText": "Raycoms requested it in #5842 (comment) . It's implemented as an interface to specific effects (healthboost, invslots, citizen-cap, unlock Building X) rather than of effect types (unlockBuilding, unlockAbility, multiplication, addition).\nIt's currently not used at all, and the only real use case I can come up with inside the mod proper is for more generic implementations, so if it's out of scope it's not hard to delete.  I think the intended situation was more for outside modders intending to register effects without putting them into the research tree (such as a consumed item from another mod unlocking a crafterrecipe) or where the effect might not normally exist and they can't use the existing blockhut checkResearch approach (such as if they want a behavior in their own mod to be dependent on a research unlock, but only if that unlock exists).", "author": "gattsuru", "createdAt": "2020-12-02T13:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAwMzEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE4NzczOA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r534187738", "bodyText": "Yeah, I had talked that over with someaddons 1-2 days ago. I had thought we might need a bunch of additional ones, but I think overally we're actually fine. The generic types we have (number, unlock) are probably all we need. And even if someone come sup with sth more complex we can still PR that into the mod.", "author": "Raycoms", "createdAt": "2020-12-02T14:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAwMzEzMg=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/registry/IResearchEffectRegistry.java b/src/api/java/com/minecolonies/api/research/registry/IResearchEffectRegistry.java\ndeleted file mode 100644\nindex 1b34a51c65..0000000000\n--- a/src/api/java/com/minecolonies/api/research/registry/IResearchEffectRegistry.java\n+++ /dev/null\n\n@@ -1,41 +0,0 @@\n-package com.minecolonies.api.research.registry;\n-\n-import com.minecolonies.api.IMinecoloniesAPI;\n-import com.minecolonies.api.research.effects.IResearchEffect;\n-\n-import java.util.Collection;\n-import java.util.Set;\n-\n-/**\n- *   An interface providing information about Minecolonies Research Effects,\n- *   and the ability to register new effects.  Also some helper classes to reduce later sorting.\n- *   This ResearchEffectRegistry should include both research effects regardless of status:\n- *   Use {@link com.minecolonies.api.research.effects.IResearchEffectManager}\n- *   to set and apply effects for completed research.\n- *   Use {MinecoloniesAPIProxy.getInstance().getGlobalResearchTree()}\n- *   to add research to the University Research System.\n- */\n-\n-public interface IResearchEffectRegistry\n-{\n-    static IResearchEffectRegistry getInstance()\n-    {\n-        return IMinecoloniesAPI.getInstance().getResearchEffectRegistry();\n-    }\n-\n-    boolean register(IResearchEffect effect, Boolean isSetOnWorldLoad);\n-\n-    Collection<IResearchEffect> getAllEffects();\n-\n-    Collection<IResearchEffect> getEffect(String id);\n-\n-    // Deriving underlying types of effects is relatively complex in code.\n-    // These caches should simplify code access, at little memory cost.\n-    Set<String> getUnlockBuildingEffects();\n-\n-    Set<String> getUnlockAbilityEffects();\n-\n-    boolean isBuildingUnlockable(String buildingHutDesc);\n-\n-    void resetRegistry();\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwMjc1NA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r536902754", "bodyText": "this JDoc doesn't seem to match?", "author": "Mekle001", "createdAt": "2020-12-05T22:15:01Z", "path": "src/api/java/com/minecolonies/api/blocks/AbstractBlockHut.java", "diffHunk": "@@ -89,6 +89,12 @@\n      */\n     protected boolean needsResearch = false;\n \n+    /**", "originalCommit": "765a14c06e0aee88995ee83e03d5031ffc373f41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwNDg5NA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r536904894", "bodyText": "Ah, thanks.", "author": "gattsuru", "createdAt": "2020-12-05T22:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwMjc1NA=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/blocks/AbstractBlockHut.java b/src/api/java/com/minecolonies/api/blocks/AbstractBlockHut.java\nindex b9efb97b57..4d90dcb749 100755\n--- a/src/api/java/com/minecolonies/api/blocks/AbstractBlockHut.java\n+++ b/src/api/java/com/minecolonies/api/blocks/AbstractBlockHut.java\n\n@@ -90,8 +90,7 @@ public abstract class AbstractBlockHut<B extends AbstractBlockHut<B>> extends Ab\n     protected boolean needsResearch = false;\n \n     /**\n-     * Whether this hut is yet to be researched in the current colony.\n-     * This is only ever used client side, but adding @OnlyIn(Dist.CLIENT) causes the server to crash, so its not there.\n+     * The hut's lower-case building-registry-compatible name.\n      */\n     private final String name;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwMzIwMg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r536903202", "bodyText": "Should both of these be translated?", "author": "Mekle001", "createdAt": "2020-12-05T22:17:40Z", "path": "src/api/java/com/minecolonies/api/items/ItemBlockHut.java", "diffHunk": "@@ -47,7 +47,7 @@ public void addInformation(@NotNull ItemStack stack, World worldIn, @NotNull Lis\n         super.addInformation(stack, worldIn, tooltip, flagIn);\n         if (block.needsResearch())\n         {\n-            tooltip.add(new TranslationTextComponent(TranslationConstants.HUT_NEEDS_RESEARCH_TOOLTIP_1, block.getName()));\n+            tooltip.add(new TranslationTextComponent(TranslationConstants.HUT_NEEDS_RESEARCH_TOOLTIP_1, block.getTranslatedName()));\n             tooltip.add(new TranslationTextComponent(TranslationConstants.HUT_NEEDS_RESEARCH_TOOLTIP_2, block.getName()));", "originalCommit": "765a14c06e0aee88995ee83e03d5031ffc373f41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwMzgxMA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r536903810", "bodyText": "Only HUT_NEEDS_RESEARCH_TOOLTIP_1 (\"\u00a7cThe %s requires research\") actually supports arguments, the second is just \"\u00a7cat the University to be built.\"  I could see a point where people would want a way to get the block's id as used in the argument, and using a lang file to do so seems reasonable.  But that could also be done other ways, or using translatedName as the first argument as Name as the second.", "author": "gattsuru", "createdAt": "2020-12-05T22:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwMzIwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwNjU5Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r536906597", "bodyText": "Yeah, I'd update this to pass the parameters you expect somebody might need to both of these, even if we're not using them today.", "author": "Mekle001", "createdAt": "2020-12-05T22:40:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwMzIwMg=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/items/ItemBlockHut.java b/src/api/java/com/minecolonies/api/items/ItemBlockHut.java\nindex b725657212..bca1ff1db9 100644\n--- a/src/api/java/com/minecolonies/api/items/ItemBlockHut.java\n+++ b/src/api/java/com/minecolonies/api/items/ItemBlockHut.java\n\n@@ -47,8 +47,8 @@ public class ItemBlockHut extends BlockItem\n         super.addInformation(stack, worldIn, tooltip, flagIn);\n         if (block.needsResearch())\n         {\n-            tooltip.add(new TranslationTextComponent(TranslationConstants.HUT_NEEDS_RESEARCH_TOOLTIP_1, block.getTranslatedName()));\n-            tooltip.add(new TranslationTextComponent(TranslationConstants.HUT_NEEDS_RESEARCH_TOOLTIP_2, block.getName()));\n+            tooltip.add(new TranslationTextComponent(TranslationConstants.HUT_NEEDS_RESEARCH_TOOLTIP_1, block.getTranslatedName(), block.getName()));\n+            tooltip.add(new TranslationTextComponent(TranslationConstants.HUT_NEEDS_RESEARCH_TOOLTIP_2, block.getTranslatedName(), block.getName()));\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwMzYwMw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r536903603", "bodyText": "this seems in confusing/conflicting with the function right above. Perhaps hasEffect or effectExists as a name?", "author": "Mekle001", "createdAt": "2020-12-05T22:20:37Z", "path": "src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java", "diffHunk": "@@ -17,6 +17,13 @@\n      */\n     <W extends IResearchEffect<?>> W getEffect(final String id, @NotNull final Class<W> type);\n \n+    /**\n+     * Check if the research effect exists, and if so, if it has been completed.\n+     * @param  id   the id of the effect\n+     * @return null if not existing, false if incomplete, true if complete.\n+     */\n+    Boolean getEffect(final String id);", "originalCommit": "765a14c06e0aee88995ee83e03d5031ffc373f41", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java b/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\nindex 4d92b7232c..1cbc003c21 100755\n--- a/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\n+++ b/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\n\n@@ -18,11 +18,21 @@ public interface IResearchEffectManager\n     <W extends IResearchEffect<?>> W getEffect(final String id, @NotNull final Class<W> type);\n \n     /**\n-     * Check if the research effect exists, and if so, if it has been completed.\n-     * @param  id   the id of the effect\n-     * @return null if not existing, false if incomplete, true if complete.\n+     * Get the research effect strength which is assigned to a particular string\n+     * or zero, if no matching effect is present.\n+     *\n+     * @param id   the id of the effect.\n+     * @return the strength of the effect, or zero if it isn't present.\n+     */\n+     double getEffectValue(final String id);\n+\n+    /**\n+     * Gets whether a research effect is enabled with a non-zero value.\n+     *\n+     * @param id   the id of the effect.\n+     * @return true if the is greater than zero, false if less than or equal to zero or not present.\n      */\n-    Boolean getEffect(final String id);\n+    boolean getEffectBoolean(final String id);\n \n     /**\n      * Apply the effect to the research effects class.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwNDI3MQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r536904271", "bodyText": "do we still need this override? or can we centralize this?", "author": "Mekle001", "createdAt": "2020-12-05T22:25:06Z", "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingArchery.java", "diffHunk": "@@ -127,7 +127,7 @@ else if (block == Blocks.GLOWSTONE)\n     @Override\n     public void requestUpgrade(final PlayerEntity player, final BlockPos builder)\n     {\n-        final UnlockBuildingResearchEffect effect = colony.getResearchManager().getResearchEffects().getEffect(ResearchInitializer.ARCHERY_RESEARCH, UnlockBuildingResearchEffect.class);\n+        final UnlockBuildingResearchEffect effect = colony.getResearchManager().getResearchEffects().getEffect(ARCHERY_RESEARCH, UnlockBuildingResearchEffect.class);", "originalCommit": "765a14c06e0aee88995ee83e03d5031ffc373f41", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingArchery.java b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingArchery.java\nindex 63b2833d5c..a0c15b73fc 100755\n--- a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingArchery.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingArchery.java\n\n@@ -124,18 +117,6 @@ public class BuildingArchery extends AbstractBuildingWorker implements IBuilding\n         super.registerBlockPosition(block, pos, world);\n     }\n \n-    @Override\n-    public void requestUpgrade(final PlayerEntity player, final BlockPos builder)\n-    {\n-        final UnlockBuildingResearchEffect effect = colony.getResearchManager().getResearchEffects().getEffect(ARCHERY_RESEARCH, UnlockBuildingResearchEffect.class);\n-        if (effect == null)\n-        {\n-            player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.havetounlock\"), player.getUniqueID());\n-            return;\n-        }\n-        super.requestUpgrade(player, builder);\n-    }\n-\n     @Override\n     public void deserializeNBT(final CompoundNBT compound)\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkwNDcwMw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r536904703", "bodyText": "Ok, this change doesn't make any sense. You're potentially setting the required effect multiple times, with the last one winning. I'd rather see us pick the first unlockability effect, or correctly recognize all of them.", "author": "Mekle001", "createdAt": "2020-12-05T22:27:57Z", "path": "src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java", "diffHunk": "@@ -363,12 +363,18 @@ public boolean isValidForBuilding(IBuildingWorker building)\n         IGlobalResearchTree gr = IGlobalResearchTree.getInstance();\n         if (researchId != null)\n         {\n-            requiredEffect = colony.getResearchManager().getResearchEffects().getEffect(gr.getEffectIdForResearch(researchId), AbstractResearchEffect.class);\n+            for(IResearchEffect effect : gr.getEffectsForResearch(researchId))", "originalCommit": "765a14c06e0aee88995ee83e03d5031ffc373f41", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java b/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java\nindex 43e5263b8d..aef36c5667 100644\n--- a/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java\n\n@@ -348,97 +409,147 @@ public class CustomRecipe\n     {\n         this.recipeId = recipeId;\n     }\n- \n+\n     /**\n      * Check to see if the recipe is currently valid for the building\n      * This does research checks, to verify that the appropriate researches are in the correct states\n+     * @param building      Building to check recipe against.\n      */\n     public boolean isValidForBuilding(IBuildingWorker building)\n     {\n-        AbstractResearchEffect<?> requiredEffect = null;\n-        AbstractResearchEffect<?> excludedEffect = null;\n         final IColony colony = building.getColony();\n-        final int bldgLevel = building.getBuildingLevel();\n-\n-        IGlobalResearchTree gr = IGlobalResearchTree.getInstance();\n+        final boolean requiredEffectPresent;\n         if (researchId != null)\n         {\n-            for(IResearchEffect effect : gr.getEffectsForResearch(researchId))\n-            {\n-                requiredEffect = colony.getResearchManager().getResearchEffects().getEffect(effect.getId(), AbstractResearchEffect.class);\n-            }\n+            requiredEffectPresent = isUnlockEffectResearched(researchId, colony);\n         }\n-\n+        else\n+        {\n+            requiredEffectPresent = false;\n+        }\n+        final boolean excludedEffectPresent;\n         if (excludedResearchId != null)\n         {\n-            for(IResearchEffect effect : gr.getEffectsForResearch(excludedResearchId))\n+            excludedEffectPresent = isUnlockEffectResearched(excludedResearchId, colony);\n+        }\n+        else\n+        {\n+            excludedEffectPresent = false;\n+        }\n+        if (isPrecursorRecipeMissing(building))\n+        {\n+            return false;\n+        }\n+\n+        final int bldgLevel = building.getBuildingLevel();\n+\n+        return (researchId == null || requiredEffectPresent)\n+                 && (excludedResearchId == null || !excludedEffectPresent)\n+                 && (bldgLevel >= minBldgLevel)\n+                 && (bldgLevel <= maxBldgLevel);\n+    }\n+\n+    /**\n+     * Check if a given researchId has been completed and has an unlock ability effect.\n+     * @param researchId    The id of the research to check for.\n+     * @param colony        The colony being checked against.\n+     */\n+    private boolean isUnlockEffectResearched(String researchId, IColony colony)\n+    {\n+        //Check first if the research effect exists.\n+        if (!IGlobalResearchTree.getInstance().hasResearchEffect(researchId) && !IGlobalResearchTree.getInstance().hasResearch(researchId))\n+        {\n+            // If there's nothing registered with this effect, and no research with this key, we'll default to acting as if research was completed.\n+            return true;\n+        }\n+        else\n+        {\n+            if (colony.getResearchManager().getResearchEffects().getEffectBoolean(researchId))\n+            {\n+                // Research effect queried, present, and set to true.\n+                return true;\n+            }\n+            if (colony.getResearchManager().getResearchTree().hasCompletedResearch(researchId))\n             {\n-                excludedEffect = colony.getResearchManager().getResearchEffects().getEffect(effect.getId(), AbstractResearchEffect.class);\n+                // Research ID queried and present.\n+                // This will allow simple Recipe-style unlocks to exist without needing an extra effect category.\n+                return true;\n             }\n         }\n+        // Research ID queried and present or present as an effect, but not completed or does not have an unlock effect.\n+        return false;\n+    }\n \n+    /**\n+     * Check if a precursor recipe is missing from the building.\n+     * @param building      The building which would contain the precursor recipe.\n+     * @return              True if a precusor recipe was required and not present.\n+     */\n+    private boolean isPrecursorRecipeMissing(IBuildingWorker building)\n+    {\n         if(mustExist)\n         {\n-            boolean found = false;\n             final IRecipeStorage compareStorage = this.getRecipeStorage();\n             final ResourceLocation recipeSource = this.getRecipeId();\n-            for(IToken<?> recipeToken: building.getRecipes())\n+            for (IToken<?> recipeToken : building.getRecipes())\n             {\n                 final IRecipeStorage storage = IColonyManager.getInstance().getRecipeManager().getRecipes().get(recipeToken);\n-                if((storage.getRecipeSource() != null && storage.getRecipeSource().equals(recipeSource)) || (storage.getCleanedInput().containsAll(compareStorage.getCleanedInput()) && compareStorage.getCleanedInput().containsAll(storage.getCleanedInput())))\n+                if ((storage.getRecipeSource() != null && storage.getRecipeSource().equals(recipeSource)) || (\n+                  storage.getCleanedInput().containsAll(compareStorage.getCleanedInput())\n+                    && compareStorage.getCleanedInput()\n+                         .containsAll(storage.getCleanedInput())))\n                 {\n-                    found = true;\n-                    break;\n+                    return false;\n                 }\n             }\n-            if(!found)\n-            {\n-                return false; \n-            }\n+            return true;\n         }\n-\n-        return (researchId == null || requiredEffect != null) \n-            && (excludedResearchId == null || excludedEffect == null)\n-            && (bldgLevel >= minBldgLevel)\n-            && (bldgLevel <= maxBldgLevel);\n+        // if no precursor needed.\n+        return false;\n     }\n \n     /**\n      * Get a the recipe storage represented by this recipe\n-     * @return\n+     * @return Recipe Storage\n      */\n     public IRecipeStorage getRecipeStorage()\n     {\n-        if(altOutputs.isEmpty())\n-        {\n-            return StandardFactoryController.getInstance().getNewInstance(\n-                TypeConstants.RECIPE,\n-                StandardFactoryController.getInstance().getNewInstance(TypeConstants.ITOKEN),\n-                inputs,\n-                1,\n-                result,\n-                intermediate,\n-                this.getRecipeId(),\n-                ModRecipeTypes.CLASSIC_ID,\n-                null, //alternate outputs\n-                null //secondary output\n-                );\n-        }\n-        else\n+        if(cachedRecipeStorage == null)\n         {\n-            return StandardFactoryController.getInstance().getNewInstance(\n-                TypeConstants.RECIPE,\n-                StandardFactoryController.getInstance().getNewInstance(TypeConstants.ITOKEN),\n-                inputs,\n-                1,\n-                result,\n-                intermediate,\n-                this.getRecipeId(),\n-                ModRecipeTypes.MULTI_OUTPUT_ID,\n-                altOutputs, //alternate outputs\n-                null //secondary output\n-                );\n+            if(altOutputs.isEmpty())\n+            {\n+                cachedRecipeStorage = StandardFactoryController.getInstance().getNewInstance(\n+                    TypeConstants.RECIPE,\n+                    StandardFactoryController.getInstance().getNewInstance(TypeConstants.ITOKEN),\n+                    inputs,\n+                    1,\n+                    result,\n+                    intermediate,\n+                    this.getRecipeId(),\n+                    ModRecipeTypes.CLASSIC_ID,\n+                    null, //alternate outputs\n+                    secondary, //secondary output\n+                    lootTable\n+                    );\n+            }\n+            else\n+            {\n+                cachedRecipeStorage = StandardFactoryController.getInstance().getNewInstance(\n+                    TypeConstants.RECIPE,\n+                    StandardFactoryController.getInstance().getNewInstance(TypeConstants.ITOKEN),\n+                    inputs,\n+                    1,\n+                    result,\n+                    intermediate,\n+                    this.getRecipeId(),\n+                    ModRecipeTypes.MULTI_OUTPUT_ID,\n+                    altOutputs, //alternate outputs\n+                    secondary, //secondary output\n+                    lootTable\n+                    );\n+            }\n         }\n+        return cachedRecipeStorage;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA4NzI4MA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r537087280", "bodyText": "This looks off. The check is against excluded, but changing required?", "author": "Mekle001", "createdAt": "2020-12-06T17:37:53Z", "path": "src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java", "diffHunk": "@@ -391,16 +395,18 @@ public boolean isValidForBuilding(IBuildingWorker building)\n         {\n             if(Boolean.TRUE.equals(IGlobalResearchTree.getInstance().hasUnlockAbilityEffect(excludedResearchId)))\n             {\n-                excludedEffect = true;\n+                requiredEffect = true;", "originalCommit": "3b23746b3ae37e9548d30a96039c1614e52deb48", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java b/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java\nindex b62b93d833..aef36c5667 100644\n--- a/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java\n\n@@ -355,125 +409,147 @@ public class CustomRecipe\n     {\n         this.recipeId = recipeId;\n     }\n- \n+\n     /**\n      * Check to see if the recipe is currently valid for the building\n      * This does research checks, to verify that the appropriate researches are in the correct states\n+     * @param building      Building to check recipe against.\n      */\n     public boolean isValidForBuilding(IBuildingWorker building)\n     {\n-        boolean requiredEffect = false;\n-        boolean excludedEffect = false;\n-        //List<AbstractResearchEffect<?>> requiredEffects = new ArrayList<>();\n-        //List<AbstractResearchEffect<?>> excludedEffects = new ArrayList<>();\n         final IColony colony = building.getColony();\n-        final int bldgLevel = building.getBuildingLevel();\n-\n-        IGlobalResearchTree gr = IGlobalResearchTree.getInstance();\n+        final boolean requiredEffectPresent;\n         if (researchId != null)\n         {\n-            if(Boolean.TRUE.equals(IGlobalResearchTree.getInstance().hasUnlockAbilityEffect(researchId)))\n-            {\n-                requiredEffect = true;\n-            }\n-            else\n-            {\n-                if(Boolean.TRUE.equals(colony.getResearchManager().getResearchTree().hasCompletedResearch(researchId)))\n-                {\n-                    for(IResearchEffect effect : IGlobalResearchTree.getInstance().getEffectsForResearch(researchId))\n-                    {\n-                        if(effect instanceof UnlockAbilityResearchEffect)\n-                        {\n-                            requiredEffect = true;\n-                        }\n-                    }\n-                }\n-            }\n+            requiredEffectPresent = isUnlockEffectResearched(researchId, colony);\n         }\n-\n+        else\n+        {\n+            requiredEffectPresent = false;\n+        }\n+        final boolean excludedEffectPresent;\n         if (excludedResearchId != null)\n         {\n-            if(Boolean.TRUE.equals(IGlobalResearchTree.getInstance().hasUnlockAbilityEffect(excludedResearchId)))\n+            excludedEffectPresent = isUnlockEffectResearched(excludedResearchId, colony);\n+        }\n+        else\n+        {\n+            excludedEffectPresent = false;\n+        }\n+        if (isPrecursorRecipeMissing(building))\n+        {\n+            return false;\n+        }\n+\n+        final int bldgLevel = building.getBuildingLevel();\n+\n+        return (researchId == null || requiredEffectPresent)\n+                 && (excludedResearchId == null || !excludedEffectPresent)\n+                 && (bldgLevel >= minBldgLevel)\n+                 && (bldgLevel <= maxBldgLevel);\n+    }\n+\n+    /**\n+     * Check if a given researchId has been completed and has an unlock ability effect.\n+     * @param researchId    The id of the research to check for.\n+     * @param colony        The colony being checked against.\n+     */\n+    private boolean isUnlockEffectResearched(String researchId, IColony colony)\n+    {\n+        //Check first if the research effect exists.\n+        if (!IGlobalResearchTree.getInstance().hasResearchEffect(researchId) && !IGlobalResearchTree.getInstance().hasResearch(researchId))\n+        {\n+            // If there's nothing registered with this effect, and no research with this key, we'll default to acting as if research was completed.\n+            return true;\n+        }\n+        else\n+        {\n+            if (colony.getResearchManager().getResearchEffects().getEffectBoolean(researchId))\n             {\n-                requiredEffect = true;\n+                // Research effect queried, present, and set to true.\n+                return true;\n             }\n-            else\n+            if (colony.getResearchManager().getResearchTree().hasCompletedResearch(researchId))\n             {\n-                if(Boolean.TRUE.equals(colony.getResearchManager().getResearchTree().hasCompletedResearch(excludedResearchId)))\n-                {\n-                    for(IResearchEffect effect : IGlobalResearchTree.getInstance().getEffectsForResearch(excludedResearchId))\n-                    {\n-                        if(effect instanceof UnlockAbilityResearchEffect)\n-                        {\n-                            requiredEffect = true;\n-                        }\n-                    }\n-                }\n+                // Research ID queried and present.\n+                // This will allow simple Recipe-style unlocks to exist without needing an extra effect category.\n+                return true;\n             }\n         }\n+        // Research ID queried and present or present as an effect, but not completed or does not have an unlock effect.\n+        return false;\n+    }\n \n+    /**\n+     * Check if a precursor recipe is missing from the building.\n+     * @param building      The building which would contain the precursor recipe.\n+     * @return              True if a precusor recipe was required and not present.\n+     */\n+    private boolean isPrecursorRecipeMissing(IBuildingWorker building)\n+    {\n         if(mustExist)\n         {\n-            boolean found = false;\n             final IRecipeStorage compareStorage = this.getRecipeStorage();\n             final ResourceLocation recipeSource = this.getRecipeId();\n-            for(IToken<?> recipeToken: building.getRecipes())\n+            for (IToken<?> recipeToken : building.getRecipes())\n             {\n                 final IRecipeStorage storage = IColonyManager.getInstance().getRecipeManager().getRecipes().get(recipeToken);\n-                if((storage.getRecipeSource() != null && storage.getRecipeSource().equals(recipeSource)) || (storage.getCleanedInput().containsAll(compareStorage.getCleanedInput()) && compareStorage.getCleanedInput().containsAll(storage.getCleanedInput())))\n+                if ((storage.getRecipeSource() != null && storage.getRecipeSource().equals(recipeSource)) || (\n+                  storage.getCleanedInput().containsAll(compareStorage.getCleanedInput())\n+                    && compareStorage.getCleanedInput()\n+                         .containsAll(storage.getCleanedInput())))\n                 {\n-                    found = true;\n-                    break;\n+                    return false;\n                 }\n             }\n-            if(!found)\n-            {\n-                return false; \n-            }\n+            return true;\n         }\n-\n-        return (researchId == null || requiredEffect)\n-            && (excludedResearchId == null || !excludedEffect)\n-            && (bldgLevel >= minBldgLevel)\n-            && (bldgLevel <= maxBldgLevel);\n+        // if no precursor needed.\n+        return false;\n     }\n \n     /**\n      * Get a the recipe storage represented by this recipe\n-     * @return\n+     * @return Recipe Storage\n      */\n     public IRecipeStorage getRecipeStorage()\n     {\n-        if(altOutputs.isEmpty())\n+        if(cachedRecipeStorage == null)\n         {\n-            return StandardFactoryController.getInstance().getNewInstance(\n-                TypeConstants.RECIPE,\n-                StandardFactoryController.getInstance().getNewInstance(TypeConstants.ITOKEN),\n-                inputs,\n-                1,\n-                result,\n-                intermediate,\n-                this.getRecipeId(),\n-                ModRecipeTypes.CLASSIC_ID,\n-                null, //alternate outputs\n-                null //secondary output\n-                );\n-        }\n-        else\n-        {\n-            return StandardFactoryController.getInstance().getNewInstance(\n-                TypeConstants.RECIPE,\n-                StandardFactoryController.getInstance().getNewInstance(TypeConstants.ITOKEN),\n-                inputs,\n-                1,\n-                result,\n-                intermediate,\n-                this.getRecipeId(),\n-                ModRecipeTypes.MULTI_OUTPUT_ID,\n-                altOutputs, //alternate outputs\n-                null //secondary output\n-                );\n+            if(altOutputs.isEmpty())\n+            {\n+                cachedRecipeStorage = StandardFactoryController.getInstance().getNewInstance(\n+                    TypeConstants.RECIPE,\n+                    StandardFactoryController.getInstance().getNewInstance(TypeConstants.ITOKEN),\n+                    inputs,\n+                    1,\n+                    result,\n+                    intermediate,\n+                    this.getRecipeId(),\n+                    ModRecipeTypes.CLASSIC_ID,\n+                    null, //alternate outputs\n+                    secondary, //secondary output\n+                    lootTable\n+                    );\n+            }\n+            else\n+            {\n+                cachedRecipeStorage = StandardFactoryController.getInstance().getNewInstance(\n+                    TypeConstants.RECIPE,\n+                    StandardFactoryController.getInstance().getNewInstance(TypeConstants.ITOKEN),\n+                    inputs,\n+                    1,\n+                    result,\n+                    intermediate,\n+                    this.getRecipeId(),\n+                    ModRecipeTypes.MULTI_OUTPUT_ID,\n+                    altOutputs, //alternate outputs\n+                    secondary, //secondary output\n+                    lootTable\n+                    );\n+            }\n         }\n+        return cachedRecipeStorage;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA4NzQxNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r537087415", "bodyText": "This also looks off", "author": "Mekle001", "createdAt": "2020-12-06T17:38:58Z", "path": "src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java", "diffHunk": "@@ -391,16 +395,18 @@ public boolean isValidForBuilding(IBuildingWorker building)\n         {\n             if(Boolean.TRUE.equals(IGlobalResearchTree.getInstance().hasUnlockAbilityEffect(excludedResearchId)))\n             {\n-                excludedEffect = true;\n+                requiredEffect = true;\n             }\n             else\n             {\n-                for (ILocalResearch research : colony.getResearchManager().getResearchTree().getCompletedResearch())\n+                if(Boolean.TRUE.equals(colony.getResearchManager().getResearchTree().hasCompletedResearch(excludedResearchId)))\n                 {\n-                    if(research.getId().equals(excludedResearchId) && MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().hasUnlockAbilityEffect(research.getId()))\n+                    for(IResearchEffect effect : IGlobalResearchTree.getInstance().getEffectsForResearch(excludedResearchId))\n                     {\n-                        excludedEffect = true;\n-                        //return false;\n+                        if(effect instanceof UnlockAbilityResearchEffect)\n+                        {\n+                            requiredEffect = true;", "originalCommit": "3b23746b3ae37e9548d30a96039c1614e52deb48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA5MTUyMg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r537091522", "bodyText": "Yeah, those seem to be it.  Testing against Crusher and Bakery.", "author": "gattsuru", "createdAt": "2020-12-06T18:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA4NzQxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA5NDMwNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r537094305", "bodyText": "Takes about 30 seconds to update the recipes being used, working now.  The hut recipe list doesn't seem to update for much longer (I had to open/close the world), not sure if that's worth fixing at this point.", "author": "gattsuru", "createdAt": "2020-12-06T18:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA4NzQxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE0NjQxNA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r537146414", "bodyText": "Eh, I've not see the UI out of date like that, but if resolution is working with the right counts, I'm good.", "author": "Mekle001", "createdAt": "2020-12-06T23:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA4NzQxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java b/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java\nindex b62b93d833..aef36c5667 100644\n--- a/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java\n\n@@ -355,125 +409,147 @@ public class CustomRecipe\n     {\n         this.recipeId = recipeId;\n     }\n- \n+\n     /**\n      * Check to see if the recipe is currently valid for the building\n      * This does research checks, to verify that the appropriate researches are in the correct states\n+     * @param building      Building to check recipe against.\n      */\n     public boolean isValidForBuilding(IBuildingWorker building)\n     {\n-        boolean requiredEffect = false;\n-        boolean excludedEffect = false;\n-        //List<AbstractResearchEffect<?>> requiredEffects = new ArrayList<>();\n-        //List<AbstractResearchEffect<?>> excludedEffects = new ArrayList<>();\n         final IColony colony = building.getColony();\n-        final int bldgLevel = building.getBuildingLevel();\n-\n-        IGlobalResearchTree gr = IGlobalResearchTree.getInstance();\n+        final boolean requiredEffectPresent;\n         if (researchId != null)\n         {\n-            if(Boolean.TRUE.equals(IGlobalResearchTree.getInstance().hasUnlockAbilityEffect(researchId)))\n-            {\n-                requiredEffect = true;\n-            }\n-            else\n-            {\n-                if(Boolean.TRUE.equals(colony.getResearchManager().getResearchTree().hasCompletedResearch(researchId)))\n-                {\n-                    for(IResearchEffect effect : IGlobalResearchTree.getInstance().getEffectsForResearch(researchId))\n-                    {\n-                        if(effect instanceof UnlockAbilityResearchEffect)\n-                        {\n-                            requiredEffect = true;\n-                        }\n-                    }\n-                }\n-            }\n+            requiredEffectPresent = isUnlockEffectResearched(researchId, colony);\n         }\n-\n+        else\n+        {\n+            requiredEffectPresent = false;\n+        }\n+        final boolean excludedEffectPresent;\n         if (excludedResearchId != null)\n         {\n-            if(Boolean.TRUE.equals(IGlobalResearchTree.getInstance().hasUnlockAbilityEffect(excludedResearchId)))\n+            excludedEffectPresent = isUnlockEffectResearched(excludedResearchId, colony);\n+        }\n+        else\n+        {\n+            excludedEffectPresent = false;\n+        }\n+        if (isPrecursorRecipeMissing(building))\n+        {\n+            return false;\n+        }\n+\n+        final int bldgLevel = building.getBuildingLevel();\n+\n+        return (researchId == null || requiredEffectPresent)\n+                 && (excludedResearchId == null || !excludedEffectPresent)\n+                 && (bldgLevel >= minBldgLevel)\n+                 && (bldgLevel <= maxBldgLevel);\n+    }\n+\n+    /**\n+     * Check if a given researchId has been completed and has an unlock ability effect.\n+     * @param researchId    The id of the research to check for.\n+     * @param colony        The colony being checked against.\n+     */\n+    private boolean isUnlockEffectResearched(String researchId, IColony colony)\n+    {\n+        //Check first if the research effect exists.\n+        if (!IGlobalResearchTree.getInstance().hasResearchEffect(researchId) && !IGlobalResearchTree.getInstance().hasResearch(researchId))\n+        {\n+            // If there's nothing registered with this effect, and no research with this key, we'll default to acting as if research was completed.\n+            return true;\n+        }\n+        else\n+        {\n+            if (colony.getResearchManager().getResearchEffects().getEffectBoolean(researchId))\n             {\n-                requiredEffect = true;\n+                // Research effect queried, present, and set to true.\n+                return true;\n             }\n-            else\n+            if (colony.getResearchManager().getResearchTree().hasCompletedResearch(researchId))\n             {\n-                if(Boolean.TRUE.equals(colony.getResearchManager().getResearchTree().hasCompletedResearch(excludedResearchId)))\n-                {\n-                    for(IResearchEffect effect : IGlobalResearchTree.getInstance().getEffectsForResearch(excludedResearchId))\n-                    {\n-                        if(effect instanceof UnlockAbilityResearchEffect)\n-                        {\n-                            requiredEffect = true;\n-                        }\n-                    }\n-                }\n+                // Research ID queried and present.\n+                // This will allow simple Recipe-style unlocks to exist without needing an extra effect category.\n+                return true;\n             }\n         }\n+        // Research ID queried and present or present as an effect, but not completed or does not have an unlock effect.\n+        return false;\n+    }\n \n+    /**\n+     * Check if a precursor recipe is missing from the building.\n+     * @param building      The building which would contain the precursor recipe.\n+     * @return              True if a precusor recipe was required and not present.\n+     */\n+    private boolean isPrecursorRecipeMissing(IBuildingWorker building)\n+    {\n         if(mustExist)\n         {\n-            boolean found = false;\n             final IRecipeStorage compareStorage = this.getRecipeStorage();\n             final ResourceLocation recipeSource = this.getRecipeId();\n-            for(IToken<?> recipeToken: building.getRecipes())\n+            for (IToken<?> recipeToken : building.getRecipes())\n             {\n                 final IRecipeStorage storage = IColonyManager.getInstance().getRecipeManager().getRecipes().get(recipeToken);\n-                if((storage.getRecipeSource() != null && storage.getRecipeSource().equals(recipeSource)) || (storage.getCleanedInput().containsAll(compareStorage.getCleanedInput()) && compareStorage.getCleanedInput().containsAll(storage.getCleanedInput())))\n+                if ((storage.getRecipeSource() != null && storage.getRecipeSource().equals(recipeSource)) || (\n+                  storage.getCleanedInput().containsAll(compareStorage.getCleanedInput())\n+                    && compareStorage.getCleanedInput()\n+                         .containsAll(storage.getCleanedInput())))\n                 {\n-                    found = true;\n-                    break;\n+                    return false;\n                 }\n             }\n-            if(!found)\n-            {\n-                return false; \n-            }\n+            return true;\n         }\n-\n-        return (researchId == null || requiredEffect)\n-            && (excludedResearchId == null || !excludedEffect)\n-            && (bldgLevel >= minBldgLevel)\n-            && (bldgLevel <= maxBldgLevel);\n+        // if no precursor needed.\n+        return false;\n     }\n \n     /**\n      * Get a the recipe storage represented by this recipe\n-     * @return\n+     * @return Recipe Storage\n      */\n     public IRecipeStorage getRecipeStorage()\n     {\n-        if(altOutputs.isEmpty())\n+        if(cachedRecipeStorage == null)\n         {\n-            return StandardFactoryController.getInstance().getNewInstance(\n-                TypeConstants.RECIPE,\n-                StandardFactoryController.getInstance().getNewInstance(TypeConstants.ITOKEN),\n-                inputs,\n-                1,\n-                result,\n-                intermediate,\n-                this.getRecipeId(),\n-                ModRecipeTypes.CLASSIC_ID,\n-                null, //alternate outputs\n-                null //secondary output\n-                );\n-        }\n-        else\n-        {\n-            return StandardFactoryController.getInstance().getNewInstance(\n-                TypeConstants.RECIPE,\n-                StandardFactoryController.getInstance().getNewInstance(TypeConstants.ITOKEN),\n-                inputs,\n-                1,\n-                result,\n-                intermediate,\n-                this.getRecipeId(),\n-                ModRecipeTypes.MULTI_OUTPUT_ID,\n-                altOutputs, //alternate outputs\n-                null //secondary output\n-                );\n+            if(altOutputs.isEmpty())\n+            {\n+                cachedRecipeStorage = StandardFactoryController.getInstance().getNewInstance(\n+                    TypeConstants.RECIPE,\n+                    StandardFactoryController.getInstance().getNewInstance(TypeConstants.ITOKEN),\n+                    inputs,\n+                    1,\n+                    result,\n+                    intermediate,\n+                    this.getRecipeId(),\n+                    ModRecipeTypes.CLASSIC_ID,\n+                    null, //alternate outputs\n+                    secondary, //secondary output\n+                    lootTable\n+                    );\n+            }\n+            else\n+            {\n+                cachedRecipeStorage = StandardFactoryController.getInstance().getNewInstance(\n+                    TypeConstants.RECIPE,\n+                    StandardFactoryController.getInstance().getNewInstance(TypeConstants.ITOKEN),\n+                    inputs,\n+                    1,\n+                    result,\n+                    intermediate,\n+                    this.getRecipeId(),\n+                    ModRecipeTypes.MULTI_OUTPUT_ID,\n+                    altOutputs, //alternate outputs\n+                    secondary, //secondary output\n+                    lootTable\n+                    );\n+            }\n         }\n+        return cachedRecipeStorage;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY5NDkzNA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r537694934", "bodyText": "I love this possibility. I believe that to do this right though, we need to notify that a new research has been discovered, which means checking for these being unlocked onColonyTick somewhere. I'd suggest not on the university itself, but on the TownHall, so that it could be extended to auto-start researches marked appropriately there, and enable scenarios like blocking the university itself until some other criteria is met (School built?)", "author": "Mekle001", "createdAt": "2020-12-07T17:35:39Z", "path": "src/main/java/com/minecolonies/coremod/research/GlobalResearch.java", "diffHunk": "@@ -312,6 +317,12 @@ public int getDepth()\n         return this.depth;\n     }\n \n+    @Override\n+    public boolean isHidden()", "originalCommit": "b41294b0cd5e9325163fb60bc55ff8f0ae370e65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\nindex bdabfa3344..c96ded62f1 100755\n--- a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n+++ b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n\n@@ -317,12 +430,36 @@ public class GlobalResearch implements IGlobalResearch\n         return this.depth;\n     }\n \n+    @Override\n+    public int getSortOrder()\n+    {\n+        return this.sortOrder;\n+    }\n+\n+    @Override\n+    public boolean isInstant()\n+    {\n+        return this.instant;\n+    }\n+\n     @Override\n     public boolean isHidden()\n     {\n         return this.hidden;\n     }\n \n+    @Override\n+    public boolean isAutostart()\n+    {\n+        return this.autostart;\n+    }\n+\n+    @Override\n+    public boolean isImmutable()\n+    {\n+        return this.immutable;\n+    }\n+\n     @Override\n     public boolean hasOnlyChild()\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2MjIwMA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540462200", "bodyText": "do we need the Boolean wrapper?", "author": "someaddons", "createdAt": "2020-12-10T20:07:20Z", "path": "src/api/java/com/minecolonies/api/research/ILocalResearchTree.java", "diffHunk": "@@ -42,6 +42,13 @@\n      */\n     List<ILocalResearch> getResearchInProgress();\n \n+    /**\n+     * Checks if a given research is complete.\n+     *\n+     * @return null if doesn't exist, true if complete, false if not completed.\n+     */\n+     Boolean hasCompletedResearch(String researchId);", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0Mzg1NQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540543855", "bodyText": "It's not really used anywhere right now, so it's easy enough to swap.  The goal down the road would be to support cases where an Unlock behaves differently if the research doesn't exist -- say, if you wanted a world with Plant2 removed to allow Sugar Cane and Cactus but not bamboo -- but that is enough of an edge case that we can wait til it comes up and then handle it (or to numeric unlock levels, which I think is what Mekle001 was starting to push toward).", "author": "gattsuru", "createdAt": "2020-12-10T22:28:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2MjIwMA=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java b/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java\nindex b6eda44ee4..4f9805a60b 100755\n--- a/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java\n+++ b/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java\n\n@@ -45,17 +48,34 @@ public interface ILocalResearchTree\n     /**\n      * Checks if a given research is complete.\n      *\n-     * @return null if doesn't exist, true if complete, false if not completed.\n+     * @return true if complete or if no such research is loaded, false if not completed.\n      */\n-     Boolean hasCompletedResearch(String researchId);\n+     boolean hasCompletedResearch(final String researchId);\n \n     /**\n      * Finish a research and remove it from the inProgress list.\n      *\n-     * @param id the id of the research to remove.\n+     * @param id the id of the research to finish.\n      */\n     void finishResearch(final String id);\n \n+    /**\n+     * Attempt to begin a research.\n+     * @param player     the player(s) making the request (and to apply costs toward)\n+     * @param colony     the colony doing the research\n+     * @param research   the research.\n+     */\n+    void attemptBeginResearch(final PlayerEntity player, final IColony colony, final IGlobalResearch research);\n+\n+    /**\n+     * Reset a research, and optionally undo its effects.  If the research is begun but incomplete, cancel it.\n+     *\n+     * @param player     the player to notify of research cancellation results.\n+     * @param colony     the colony to remove effects from, or null if no effect reset is desired.\n+     * @param research   the local research descriptor.\n+     */\n+    void attemptResetResearch(PlayerEntity player, @Nullable final IColony colony, ILocalResearch research);\n+\n     /**\n      * Write the research tree to NBT.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2NDk0OA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540464948", "bodyText": "javadoc", "author": "someaddons", "createdAt": "2020-12-10T20:12:05Z", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutUniversity.java", "diffHunk": "@@ -36,19 +43,92 @@ public WindowHutUniversity(final BuildingUniversity.View building)\n \n         final View view = this.findPaneOfTypeByID(BRANCH_VIEW_ID, View.class);\n         int offset = 0;\n-        for (final String branch : IGlobalResearchTree.getInstance().getBranches())\n+        // For now, sort research branches by name, as they may be loaded in any order.\n+        branches.addAll(IGlobalResearchTree.getInstance().getBranches());\n+        branches.sort(Comparator.comparing(String::toString, String.CASE_INSENSITIVE_ORDER));\n+        for (final String branch : branches)\n         {\n-            final ButtonImage button = new ButtonImage();\n-            button.setImage(new ResourceLocation(Constants.MOD_ID, MEDIUM_SIZED_BUTTON_RES));\n-            button.setLabel(branch);\n-            button.setSize(BUTTON_LENGTH, BUTTON_HEIGHT);\n-            button.setTextColor(SLIGHTLY_BLUE);\n-            button.setPosition(x + INITITAL_X_OFFSET, y + offset + INITITAL_Y_OFFSET);\n-            view.addChild(button);\n-            branches.add(branch);\n+            List<IFormattableTextComponent> requirements = getHidingRequirementDesc(branch);\n+            if(requirements.isEmpty())\n+            {\n+                final ButtonImage button = new ButtonImage();\n+                button.setImage(new ResourceLocation(Constants.MOD_ID, MEDIUM_SIZED_BUTTON_RES));\n+                button.setLabel(branch);\n+                button.setSize(BUTTON_LENGTH, BUTTON_HEIGHT);\n+                button.setTextColor(SLIGHTLY_BLUE);\n+                button.setPosition(x + INITITAL_X_OFFSET, y + offset + INITITAL_Y_OFFSET);\n+                view.addChild(button);\n \n-            offset += button.getHeight() + BUTTON_PADDING;\n+                offset += button.getHeight() + BUTTON_PADDING;\n+            }\n+            else\n+            {\n+                final Gradient gradient = new Gradient();\n+                gradient.setSize(BUTTON_LENGTH, BUTTON_HEIGHT);\n+                gradient.setPosition(x + INITITAL_X_OFFSET, y + offset + INITITAL_Y_OFFSET);\n+                gradient.setGradientStart(239, 230, 215, 255);\n+                gradient.setGradientEnd(239, 230, 215, 255);\n+                gradient.setHoverToolTip(requirements);\n+                view.addChild(gradient);\n+                final ButtonImage button = new ButtonImage();\n+                button.setImage(new ResourceLocation(Constants.MOD_ID, MEDIUM_SIZED_BUTTON_RES));\n+                button.setLabel(\"-----------\");\n+                button.setSize(BUTTON_LENGTH, BUTTON_HEIGHT);\n+                button.setTextColor(SLIGHTLY_BLUE);\n+                button.setPosition(x + INITITAL_X_OFFSET, y + offset + INITITAL_Y_OFFSET);\n+                view.addChild(button);\n+\n+                offset += button.getHeight() + BUTTON_PADDING;\n+            }\n+        }\n+    }\n+\n+    public List<IFormattableTextComponent> getHidingRequirementDesc(String branch)", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/client/gui/WindowHutUniversity.java b/src/main/java/com/minecolonies/coremod/client/gui/WindowHutUniversity.java\nindex 7ef58428d9..26b8ae9d60 100755\n--- a/src/main/java/com/minecolonies/coremod/client/gui/WindowHutUniversity.java\n+++ b/src/main/java/com/minecolonies/coremod/client/gui/WindowHutUniversity.java\n\n@@ -53,7 +55,8 @@ public class WindowHutUniversity extends AbstractWindowWorkerBuilding<BuildingUn\n             {\n                 final ButtonImage button = new ButtonImage();\n                 button.setImage(new ResourceLocation(Constants.MOD_ID, MEDIUM_SIZED_BUTTON_RES));\n-                button.setLabel(branch);\n+                button.setLabel(IGlobalResearchTree.getInstance().getBranchName(branch));\n+                button.setID(branch);\n                 button.setSize(BUTTON_LENGTH, BUTTON_HEIGHT);\n                 button.setTextColor(SLIGHTLY_BLUE);\n                 button.setPosition(x + INITITAL_X_OFFSET, y + offset + INITITAL_Y_OFFSET);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2Nzg5Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540467893", "bodyText": "hm what is the purpose of resetting on world unloads? those also do happen for e.g. a modded dimension or then end/may not happen when the server crashes", "author": "someaddons", "createdAt": "2020-12-10T20:17:05Z", "path": "src/main/java/com/minecolonies/coremod/colony/ColonyManager.java", "diffHunk": "@@ -713,6 +714,7 @@ public void onWorldUnload(@NotNull final World world)\n                 loaded = false;\n             }\n         }\n+        IGlobalResearchTree.getInstance().reset();", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU5MjY1OA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540592658", "bodyText": "The goal is to handle situations where one save file on a single-player instance has different data pack configuration than another save.  If someone enters World A where there's a datapack with an additional research locking the Mine, then goes back to the menu, and enters World B where there is no such research, some way of purging the GlobalResearchTree of dynamically-assigned researches is necessary.\nBut I misunderstood its behavior on servers.  Thanks for catching that, and to Raycoms for also helping explain what it does.  Probably saner to have the reset just done during the first stage of the ResearchListener for world load events.", "author": "gattsuru", "createdAt": "2020-12-11T00:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2Nzg5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/ColonyManager.java b/src/main/java/com/minecolonies/coremod/colony/ColonyManager.java\nindex b45abea40c..291792cbaf 100755\n--- a/src/main/java/com/minecolonies/coremod/colony/ColonyManager.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/ColonyManager.java\n\n@@ -714,7 +720,6 @@ public final class ColonyManager implements IColonyManager\n                 loaded = false;\n             }\n         }\n-        IGlobalResearchTree.getInstance().reset();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3MjY0MA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540472640", "bodyText": "what are these new autostartedresearches about? What are they used for?\nNot sure if this is the right places, as a colony can exist without a townhall", "author": "someaddons", "createdAt": "2020-12-10T20:25:03Z", "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java", "diffHunk": "@@ -85,6 +93,86 @@ public BuildingEntry getBuildingRegistryEntry()\n         return ModBuildings.townHall;\n     }\n \n+    @Override\n+    public void onColonyTick(final IColony colony)\n+    {\n+        super.onColonyTick(colony);\n+\n+        List<IGlobalResearch> removes = new ArrayList<>();\n+        for(IGlobalResearch research : MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().getAutostartResearches())", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3ODQwNg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540578406", "bodyText": "I believe Mekle001's more extreme use case was someone intending to thoroughly rework the trees, to such extent where the University itself was locked; having a way to start research outside of the University thus becomes necessary.  Outside of that, I think it's fairly plausible to see a more progression-oriented modpack use the research trees such that they'd have low or no research start costs, but intend to have a lot of low-tier research that's intended to be started as soon as it was unlocked.\nYou're probably right in the Town Hall not being the right place for it; there's a lot of early-game where you might not even have a constructed town hall, and maybe not even have the town hall block placed.  Maybe Colony itself?", "author": "gattsuru", "createdAt": "2020-12-10T23:32:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3MjY0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4NDY3OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540584679", "bodyText": "So, I see several places where onColonyTick is fired from: Citizens through CitizenManager, Visitors through visitorManager, buildings through BuidingManager, workorders through workManager, and colonyEvents through eventManager.\nFinally, you could do it directly in worldTickSlow for the colony. I'm going to suggest that is where we should do this work, as it will handle the case where the townhall block is broken and not yet placed again.  The colony doesn't exist until it's created from the town hall, which is why I originally suggested there, but I had forgotten about the broken townhall case.", "author": "Mekle001", "createdAt": "2020-12-10T23:47:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3MjY0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY1NDY1NQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540654655", "bodyText": "Is it okay if I add an onColonyTick to ResearchManager and attach it to the worldTicksSlow in colony?  That seems like the logical place, and should reduce clutter in since ResearchManager is a lot less crowded than Colony right now.", "author": "gattsuru", "createdAt": "2020-12-11T03:00:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3MjY0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY2MzA5NQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540663095", "bodyText": "That seems like a fantastic solution.", "author": "Mekle001", "createdAt": "2020-12-11T03:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3MjY0MA=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\nindex ea08d87448..2a44d4ece1 100755\n--- a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\n\n@@ -93,86 +84,6 @@ public class BuildingTownHall extends AbstractBuilding implements ITownHall\n         return ModBuildings.townHall;\n     }\n \n-    @Override\n-    public void onColonyTick(final IColony colony)\n-    {\n-        super.onColonyTick(colony);\n-\n-        List<IGlobalResearch> removes = new ArrayList<>();\n-        for(IGlobalResearch research : MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().getAutostartResearches())\n-        {\n-            if (!IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(research.getResearchRequirement(), colony))\n-            {\n-                continue;\n-            }\n-            Map<BlockPos, IBuilding> buildings = colony.getBuildingManager().getBuildings();\n-            int level = 0;\n-            for (Map.Entry<BlockPos, IBuilding> building : buildings.entrySet())\n-            {\n-                if (building.getValue().getSchematicName().equals(ModBuildings.UNIVERSITY_ID))\n-                {\n-                    if (building.getValue().getBuildingLevel() > level)\n-                    {\n-                        level = building.getValue().getBuildingLevel();\n-                    }\n-                }\n-            }\n-            if (level < research.getDepth())\n-            {\n-                continue;\n-            }\n-            boolean researchAlreadyRun = false;\n-            for (ILocalResearch progressResearch : colony.getResearchManager().getResearchTree().getResearchInProgress())\n-            {\n-                if(progressResearch.getId().equals(research.getId()))\n-                {\n-                    researchAlreadyRun = true;\n-                    break;\n-                }\n-            }\n-            // Don't want to spam people about in-progress or already-completed research.  Because these might change within a world,\n-            // we can't just save them or check against effects.\n-            if(researchAlreadyRun || Boolean.TRUE.equals(colony.getResearchManager().getResearchTree().hasCompletedResearch(research.getId())))\n-            {\n-                removes.add(research);\n-                continue;\n-            }\n-\n-            // if research has item requirements, only notify player; we don't want to have items disappearing from inventories.\n-            if (!research.getCostList().isEmpty())\n-            {\n-                for (PlayerEntity player : this.colony.getMessagePlayerEntities())\n-                {\n-                    player.sendMessage(new TranslationTextComponent(TranslationConstants.RESEARCH_AVAILABLE, research.getDesc()), player.getUniqueID());\n-                }\n-            }\n-            // Otherwise, we can start the research without user intervention.\n-            else\n-            {\n-                boolean creativePlayer = false;\n-                for (PlayerEntity player : this.colony.getMessagePlayerEntities())\n-                {\n-                    player.sendMessage(new TranslationTextComponent(TranslationConstants.RESEARCH_AVAILABLE, research.getDesc()), player.getUniqueID());\n-                    player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.started\", new TranslationTextComponent(research.getDesc())),\n-                      player.getUniqueID());\n-                    if (player.isCreative() && MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n-                    {\n-                        creativePlayer = true;\n-                    }\n-                }\n-                if (creativePlayer && MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n-                {\n-                    colony.getResearchManager().getResearchTree().getResearch(research.getBranch(),\n-                      research.getId()).setProgress((int)(BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n-                }\n-            }\n-            //  If we've successfully done all those things, now we can remove the object from the list.\n-            //  This will reannounce on world reload, but that's probably ideal, in case someone missed the message once.\n-            removes.add(research);\n-        }\n-        MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().getAutostartResearches().removeAll(removes);\n-    }\n-\n     @Override\n     public void addPermissionEvent(final PermissionEvent event)\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3NDYzOA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540474638", "bodyText": "is there a reason for only requiring the name?  like having another schematic with the same name and different building?\nThink you want to compared getBuildingEntry() == ModBuildings.university", "author": "someaddons", "createdAt": "2020-12-10T20:28:38Z", "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java", "diffHunk": "@@ -85,6 +93,86 @@ public BuildingEntry getBuildingRegistryEntry()\n         return ModBuildings.townHall;\n     }\n \n+    @Override\n+    public void onColonyTick(final IColony colony)\n+    {\n+        super.onColonyTick(colony);\n+\n+        List<IGlobalResearch> removes = new ArrayList<>();\n+        for(IGlobalResearch research : MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().getAutostartResearches())\n+        {\n+            if (!IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(research.getResearchRequirement(), colony))\n+            {\n+                continue;\n+            }\n+            Map<BlockPos, IBuilding> buildings = colony.getBuildingManager().getBuildings();\n+            int level = 0;\n+            for (Map.Entry<BlockPos, IBuilding> building : buildings.entrySet())\n+            {\n+                if (building.getValue().getSchematicName().equals(ModBuildings.UNIVERSITY_ID))", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\nindex ea08d87448..2a44d4ece1 100755\n--- a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\n\n@@ -93,86 +84,6 @@ public class BuildingTownHall extends AbstractBuilding implements ITownHall\n         return ModBuildings.townHall;\n     }\n \n-    @Override\n-    public void onColonyTick(final IColony colony)\n-    {\n-        super.onColonyTick(colony);\n-\n-        List<IGlobalResearch> removes = new ArrayList<>();\n-        for(IGlobalResearch research : MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().getAutostartResearches())\n-        {\n-            if (!IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(research.getResearchRequirement(), colony))\n-            {\n-                continue;\n-            }\n-            Map<BlockPos, IBuilding> buildings = colony.getBuildingManager().getBuildings();\n-            int level = 0;\n-            for (Map.Entry<BlockPos, IBuilding> building : buildings.entrySet())\n-            {\n-                if (building.getValue().getSchematicName().equals(ModBuildings.UNIVERSITY_ID))\n-                {\n-                    if (building.getValue().getBuildingLevel() > level)\n-                    {\n-                        level = building.getValue().getBuildingLevel();\n-                    }\n-                }\n-            }\n-            if (level < research.getDepth())\n-            {\n-                continue;\n-            }\n-            boolean researchAlreadyRun = false;\n-            for (ILocalResearch progressResearch : colony.getResearchManager().getResearchTree().getResearchInProgress())\n-            {\n-                if(progressResearch.getId().equals(research.getId()))\n-                {\n-                    researchAlreadyRun = true;\n-                    break;\n-                }\n-            }\n-            // Don't want to spam people about in-progress or already-completed research.  Because these might change within a world,\n-            // we can't just save them or check against effects.\n-            if(researchAlreadyRun || Boolean.TRUE.equals(colony.getResearchManager().getResearchTree().hasCompletedResearch(research.getId())))\n-            {\n-                removes.add(research);\n-                continue;\n-            }\n-\n-            // if research has item requirements, only notify player; we don't want to have items disappearing from inventories.\n-            if (!research.getCostList().isEmpty())\n-            {\n-                for (PlayerEntity player : this.colony.getMessagePlayerEntities())\n-                {\n-                    player.sendMessage(new TranslationTextComponent(TranslationConstants.RESEARCH_AVAILABLE, research.getDesc()), player.getUniqueID());\n-                }\n-            }\n-            // Otherwise, we can start the research without user intervention.\n-            else\n-            {\n-                boolean creativePlayer = false;\n-                for (PlayerEntity player : this.colony.getMessagePlayerEntities())\n-                {\n-                    player.sendMessage(new TranslationTextComponent(TranslationConstants.RESEARCH_AVAILABLE, research.getDesc()), player.getUniqueID());\n-                    player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.started\", new TranslationTextComponent(research.getDesc())),\n-                      player.getUniqueID());\n-                    if (player.isCreative() && MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n-                    {\n-                        creativePlayer = true;\n-                    }\n-                }\n-                if (creativePlayer && MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n-                {\n-                    colony.getResearchManager().getResearchTree().getResearch(research.getBranch(),\n-                      research.getId()).setProgress((int)(BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n-                }\n-            }\n-            //  If we've successfully done all those things, now we can remove the object from the list.\n-            //  This will reannounce on world reload, but that's probably ideal, in case someone missed the message once.\n-            removes.add(research);\n-        }\n-        MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().getAutostartResearches().removeAll(removes);\n-    }\n-\n     @Override\n     public void addPermissionEvent(final PermissionEvent event)\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3NTcwMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540475701", "bodyText": "thinking it may confuse the user when researches are completed which he did not start?", "author": "someaddons", "createdAt": "2020-12-10T20:30:27Z", "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java", "diffHunk": "@@ -85,6 +93,86 @@ public BuildingEntry getBuildingRegistryEntry()\n         return ModBuildings.townHall;\n     }\n \n+    @Override\n+    public void onColonyTick(final IColony colony)\n+    {\n+        super.onColonyTick(colony);\n+\n+        List<IGlobalResearch> removes = new ArrayList<>();\n+        for(IGlobalResearch research : MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().getAutostartResearches())\n+        {\n+            if (!IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(research.getResearchRequirement(), colony))\n+            {\n+                continue;\n+            }\n+            Map<BlockPos, IBuilding> buildings = colony.getBuildingManager().getBuildings();\n+            int level = 0;\n+            for (Map.Entry<BlockPos, IBuilding> building : buildings.entrySet())\n+            {\n+                if (building.getValue().getSchematicName().equals(ModBuildings.UNIVERSITY_ID))\n+                {\n+                    if (building.getValue().getBuildingLevel() > level)\n+                    {\n+                        level = building.getValue().getBuildingLevel();\n+                    }\n+                }\n+            }\n+            if (level < research.getDepth())\n+            {\n+                continue;\n+            }\n+            boolean researchAlreadyRun = false;\n+            for (ILocalResearch progressResearch : colony.getResearchManager().getResearchTree().getResearchInProgress())\n+            {\n+                if(progressResearch.getId().equals(research.getId()))\n+                {\n+                    researchAlreadyRun = true;\n+                    break;\n+                }\n+            }\n+            // Don't want to spam people about in-progress or already-completed research.  Because these might change within a world,\n+            // we can't just save them or check against effects.\n+            if(researchAlreadyRun || Boolean.TRUE.equals(colony.getResearchManager().getResearchTree().hasCompletedResearch(research.getId())))\n+            {\n+                removes.add(research);\n+                continue;\n+            }\n+\n+            // if research has item requirements, only notify player; we don't want to have items disappearing from inventories.\n+            if (!research.getCostList().isEmpty())\n+            {\n+                for (PlayerEntity player : this.colony.getMessagePlayerEntities())\n+                {\n+                    player.sendMessage(new TranslationTextComponent(TranslationConstants.RESEARCH_AVAILABLE, research.getDesc()), player.getUniqueID());\n+                }\n+            }\n+            // Otherwise, we can start the research without user intervention.", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY3NDU3Mg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540674572", "bodyText": "Possible.  I think a lot of the intended use case involves places where the player doesn't have a user interface to click yet, either because they don't have the University unlocked or it's not part of the intended gameplay path at that point, but there's definitely a tradeoff between requiring players to run back and forth with every unlock, and it being kinda mysterious why some start themselves and others don't.", "author": "gattsuru", "createdAt": "2020-12-11T04:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3NTcwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\nindex ea08d87448..2a44d4ece1 100755\n--- a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\n\n@@ -93,86 +84,6 @@ public class BuildingTownHall extends AbstractBuilding implements ITownHall\n         return ModBuildings.townHall;\n     }\n \n-    @Override\n-    public void onColonyTick(final IColony colony)\n-    {\n-        super.onColonyTick(colony);\n-\n-        List<IGlobalResearch> removes = new ArrayList<>();\n-        for(IGlobalResearch research : MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().getAutostartResearches())\n-        {\n-            if (!IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(research.getResearchRequirement(), colony))\n-            {\n-                continue;\n-            }\n-            Map<BlockPos, IBuilding> buildings = colony.getBuildingManager().getBuildings();\n-            int level = 0;\n-            for (Map.Entry<BlockPos, IBuilding> building : buildings.entrySet())\n-            {\n-                if (building.getValue().getSchematicName().equals(ModBuildings.UNIVERSITY_ID))\n-                {\n-                    if (building.getValue().getBuildingLevel() > level)\n-                    {\n-                        level = building.getValue().getBuildingLevel();\n-                    }\n-                }\n-            }\n-            if (level < research.getDepth())\n-            {\n-                continue;\n-            }\n-            boolean researchAlreadyRun = false;\n-            for (ILocalResearch progressResearch : colony.getResearchManager().getResearchTree().getResearchInProgress())\n-            {\n-                if(progressResearch.getId().equals(research.getId()))\n-                {\n-                    researchAlreadyRun = true;\n-                    break;\n-                }\n-            }\n-            // Don't want to spam people about in-progress or already-completed research.  Because these might change within a world,\n-            // we can't just save them or check against effects.\n-            if(researchAlreadyRun || Boolean.TRUE.equals(colony.getResearchManager().getResearchTree().hasCompletedResearch(research.getId())))\n-            {\n-                removes.add(research);\n-                continue;\n-            }\n-\n-            // if research has item requirements, only notify player; we don't want to have items disappearing from inventories.\n-            if (!research.getCostList().isEmpty())\n-            {\n-                for (PlayerEntity player : this.colony.getMessagePlayerEntities())\n-                {\n-                    player.sendMessage(new TranslationTextComponent(TranslationConstants.RESEARCH_AVAILABLE, research.getDesc()), player.getUniqueID());\n-                }\n-            }\n-            // Otherwise, we can start the research without user intervention.\n-            else\n-            {\n-                boolean creativePlayer = false;\n-                for (PlayerEntity player : this.colony.getMessagePlayerEntities())\n-                {\n-                    player.sendMessage(new TranslationTextComponent(TranslationConstants.RESEARCH_AVAILABLE, research.getDesc()), player.getUniqueID());\n-                    player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.started\", new TranslationTextComponent(research.getDesc())),\n-                      player.getUniqueID());\n-                    if (player.isCreative() && MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n-                    {\n-                        creativePlayer = true;\n-                    }\n-                }\n-                if (creativePlayer && MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n-                {\n-                    colony.getResearchManager().getResearchTree().getResearch(research.getBranch(),\n-                      research.getId()).setProgress((int)(BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n-                }\n-            }\n-            //  If we've successfully done all those things, now we can remove the object from the list.\n-            //  This will reannounce on world reload, but that's probably ideal, in case someone missed the message once.\n-            removes.add(research);\n-        }\n-        MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().getAutostartResearches().removeAll(removes);\n-    }\n-\n     @Override\n     public void addPermissionEvent(final PermissionEvent event)\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3NjYwNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540476605", "bodyText": "here when one colony finishes and removes a research we are removing it for all colonies?", "author": "someaddons", "createdAt": "2020-12-10T20:32:03Z", "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java", "diffHunk": "@@ -85,6 +93,86 @@ public BuildingEntry getBuildingRegistryEntry()\n         return ModBuildings.townHall;\n     }\n \n+    @Override\n+    public void onColonyTick(final IColony colony)\n+    {\n+        super.onColonyTick(colony);\n+\n+        List<IGlobalResearch> removes = new ArrayList<>();\n+        for(IGlobalResearch research : MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().getAutostartResearches())\n+        {\n+            if (!IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(research.getResearchRequirement(), colony))\n+            {\n+                continue;\n+            }\n+            Map<BlockPos, IBuilding> buildings = colony.getBuildingManager().getBuildings();\n+            int level = 0;\n+            for (Map.Entry<BlockPos, IBuilding> building : buildings.entrySet())\n+            {\n+                if (building.getValue().getSchematicName().equals(ModBuildings.UNIVERSITY_ID))\n+                {\n+                    if (building.getValue().getBuildingLevel() > level)\n+                    {\n+                        level = building.getValue().getBuildingLevel();\n+                    }\n+                }\n+            }\n+            if (level < research.getDepth())\n+            {\n+                continue;\n+            }\n+            boolean researchAlreadyRun = false;\n+            for (ILocalResearch progressResearch : colony.getResearchManager().getResearchTree().getResearchInProgress())\n+            {\n+                if(progressResearch.getId().equals(research.getId()))\n+                {\n+                    researchAlreadyRun = true;\n+                    break;\n+                }\n+            }\n+            // Don't want to spam people about in-progress or already-completed research.  Because these might change within a world,\n+            // we can't just save them or check against effects.\n+            if(researchAlreadyRun || Boolean.TRUE.equals(colony.getResearchManager().getResearchTree().hasCompletedResearch(research.getId())))\n+            {\n+                removes.add(research);\n+                continue;\n+            }\n+\n+            // if research has item requirements, only notify player; we don't want to have items disappearing from inventories.\n+            if (!research.getCostList().isEmpty())\n+            {\n+                for (PlayerEntity player : this.colony.getMessagePlayerEntities())\n+                {\n+                    player.sendMessage(new TranslationTextComponent(TranslationConstants.RESEARCH_AVAILABLE, research.getDesc()), player.getUniqueID());\n+                }\n+            }\n+            // Otherwise, we can start the research without user intervention.\n+            else\n+            {\n+                boolean creativePlayer = false;\n+                for (PlayerEntity player : this.colony.getMessagePlayerEntities())\n+                {\n+                    player.sendMessage(new TranslationTextComponent(TranslationConstants.RESEARCH_AVAILABLE, research.getDesc()), player.getUniqueID());\n+                    player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.started\", new TranslationTextComponent(research.getDesc())),\n+                      player.getUniqueID());\n+                    if (player.isCreative() && MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n+                    {\n+                        creativePlayer = true;\n+                    }\n+                }\n+                if (creativePlayer && MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n+                {\n+                    colony.getResearchManager().getResearchTree().getResearch(research.getBranch(),\n+                      research.getId()).setProgress((int)(BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n+                }\n+            }\n+            //  If we've successfully done all those things, now we can remove the object from the list.\n+            //  This will reannounce on world reload, but that's probably ideal, in case someone missed the message once.\n+            removes.add(research);\n+        }\n+        MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().getAutostartResearches().removeAll(removes);", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\nindex ea08d87448..2a44d4ece1 100755\n--- a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\n\n@@ -93,86 +84,6 @@ public class BuildingTownHall extends AbstractBuilding implements ITownHall\n         return ModBuildings.townHall;\n     }\n \n-    @Override\n-    public void onColonyTick(final IColony colony)\n-    {\n-        super.onColonyTick(colony);\n-\n-        List<IGlobalResearch> removes = new ArrayList<>();\n-        for(IGlobalResearch research : MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().getAutostartResearches())\n-        {\n-            if (!IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(research.getResearchRequirement(), colony))\n-            {\n-                continue;\n-            }\n-            Map<BlockPos, IBuilding> buildings = colony.getBuildingManager().getBuildings();\n-            int level = 0;\n-            for (Map.Entry<BlockPos, IBuilding> building : buildings.entrySet())\n-            {\n-                if (building.getValue().getSchematicName().equals(ModBuildings.UNIVERSITY_ID))\n-                {\n-                    if (building.getValue().getBuildingLevel() > level)\n-                    {\n-                        level = building.getValue().getBuildingLevel();\n-                    }\n-                }\n-            }\n-            if (level < research.getDepth())\n-            {\n-                continue;\n-            }\n-            boolean researchAlreadyRun = false;\n-            for (ILocalResearch progressResearch : colony.getResearchManager().getResearchTree().getResearchInProgress())\n-            {\n-                if(progressResearch.getId().equals(research.getId()))\n-                {\n-                    researchAlreadyRun = true;\n-                    break;\n-                }\n-            }\n-            // Don't want to spam people about in-progress or already-completed research.  Because these might change within a world,\n-            // we can't just save them or check against effects.\n-            if(researchAlreadyRun || Boolean.TRUE.equals(colony.getResearchManager().getResearchTree().hasCompletedResearch(research.getId())))\n-            {\n-                removes.add(research);\n-                continue;\n-            }\n-\n-            // if research has item requirements, only notify player; we don't want to have items disappearing from inventories.\n-            if (!research.getCostList().isEmpty())\n-            {\n-                for (PlayerEntity player : this.colony.getMessagePlayerEntities())\n-                {\n-                    player.sendMessage(new TranslationTextComponent(TranslationConstants.RESEARCH_AVAILABLE, research.getDesc()), player.getUniqueID());\n-                }\n-            }\n-            // Otherwise, we can start the research without user intervention.\n-            else\n-            {\n-                boolean creativePlayer = false;\n-                for (PlayerEntity player : this.colony.getMessagePlayerEntities())\n-                {\n-                    player.sendMessage(new TranslationTextComponent(TranslationConstants.RESEARCH_AVAILABLE, research.getDesc()), player.getUniqueID());\n-                    player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.started\", new TranslationTextComponent(research.getDesc())),\n-                      player.getUniqueID());\n-                    if (player.isCreative() && MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n-                    {\n-                        creativePlayer = true;\n-                    }\n-                }\n-                if (creativePlayer && MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n-                {\n-                    colony.getResearchManager().getResearchTree().getResearch(research.getBranch(),\n-                      research.getId()).setProgress((int)(BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n-                }\n-            }\n-            //  If we've successfully done all those things, now we can remove the object from the list.\n-            //  This will reannounce on world reload, but that's probably ideal, in case someone missed the message once.\n-            removes.add(research);\n-        }\n-        MinecoloniesAPIProxy.getInstance().getGlobalResearchTree().getAutostartResearches().removeAll(removes);\n-    }\n-\n     @Override\n     public void addPermissionEvent(final PermissionEvent event)\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3NzQyNg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540477426", "bodyText": "Do we need the Boolean wrappers? if(IGlobalResearchTree.getInstance().hasUnlockAbilityEffect(researchId)) would be so much simpler", "author": "someaddons", "createdAt": "2020-12-10T20:33:29Z", "path": "src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java", "diffHunk": "@@ -409,20 +416,54 @@ public void setRecipeId(ResourceLocation recipeId)\n      */\n     public boolean isValidForBuilding(IBuildingWorker building)\n     {\n-        AbstractResearchEffect<?> requiredEffect = null;\n-        AbstractResearchEffect<?> excludedEffect = null;\n+        boolean requiredEffect = false;\n+        boolean excludedEffect = false;\n+        //List<AbstractResearchEffect<?>> requiredEffects = new ArrayList<>();\n+        //List<AbstractResearchEffect<?>> excludedEffects = new ArrayList<>();\n         final IColony colony = building.getColony();\n         final int bldgLevel = building.getBuildingLevel();\n \n         IGlobalResearchTree gr = IGlobalResearchTree.getInstance();\n         if (researchId != null)\n         {\n-            requiredEffect = colony.getResearchManager().getResearchEffects().getEffect(gr.getEffectIdForResearch(researchId), AbstractResearchEffect.class);\n+            if(Boolean.TRUE.equals(IGlobalResearchTree.getInstance().hasUnlockAbilityEffect(researchId)))", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java b/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java\nindex 36e73c02e6..aef36c5667 100644\n--- a/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/crafting/CustomRecipe.java\n\n@@ -409,92 +409,108 @@ public class CustomRecipe\n     {\n         this.recipeId = recipeId;\n     }\n- \n+\n     /**\n      * Check to see if the recipe is currently valid for the building\n      * This does research checks, to verify that the appropriate researches are in the correct states\n+     * @param building      Building to check recipe against.\n      */\n     public boolean isValidForBuilding(IBuildingWorker building)\n     {\n-        boolean requiredEffect = false;\n-        boolean excludedEffect = false;\n-        //List<AbstractResearchEffect<?>> requiredEffects = new ArrayList<>();\n-        //List<AbstractResearchEffect<?>> excludedEffects = new ArrayList<>();\n         final IColony colony = building.getColony();\n-        final int bldgLevel = building.getBuildingLevel();\n-\n-        IGlobalResearchTree gr = IGlobalResearchTree.getInstance();\n+        final boolean requiredEffectPresent;\n         if (researchId != null)\n         {\n-            if(Boolean.TRUE.equals(IGlobalResearchTree.getInstance().hasUnlockAbilityEffect(researchId)))\n-            {\n-                requiredEffect = true;\n-            }\n-            else\n-            {\n-                if(Boolean.TRUE.equals(colony.getResearchManager().getResearchTree().hasCompletedResearch(researchId)))\n-                {\n-                    for(IResearchEffect effect : IGlobalResearchTree.getInstance().getEffectsForResearch(researchId))\n-                    {\n-                        if(effect instanceof UnlockAbilityResearchEffect)\n-                        {\n-                            requiredEffect = true;\n-                        }\n-                    }\n-                }\n-            }\n+            requiredEffectPresent = isUnlockEffectResearched(researchId, colony);\n         }\n-\n+        else\n+        {\n+            requiredEffectPresent = false;\n+        }\n+        final boolean excludedEffectPresent;\n         if (excludedResearchId != null)\n         {\n-            if(Boolean.TRUE.equals(IGlobalResearchTree.getInstance().hasUnlockAbilityEffect(excludedResearchId)))\n+            excludedEffectPresent = isUnlockEffectResearched(excludedResearchId, colony);\n+        }\n+        else\n+        {\n+            excludedEffectPresent = false;\n+        }\n+        if (isPrecursorRecipeMissing(building))\n+        {\n+            return false;\n+        }\n+\n+        final int bldgLevel = building.getBuildingLevel();\n+\n+        return (researchId == null || requiredEffectPresent)\n+                 && (excludedResearchId == null || !excludedEffectPresent)\n+                 && (bldgLevel >= minBldgLevel)\n+                 && (bldgLevel <= maxBldgLevel);\n+    }\n+\n+    /**\n+     * Check if a given researchId has been completed and has an unlock ability effect.\n+     * @param researchId    The id of the research to check for.\n+     * @param colony        The colony being checked against.\n+     */\n+    private boolean isUnlockEffectResearched(String researchId, IColony colony)\n+    {\n+        //Check first if the research effect exists.\n+        if (!IGlobalResearchTree.getInstance().hasResearchEffect(researchId) && !IGlobalResearchTree.getInstance().hasResearch(researchId))\n+        {\n+            // If there's nothing registered with this effect, and no research with this key, we'll default to acting as if research was completed.\n+            return true;\n+        }\n+        else\n+        {\n+            if (colony.getResearchManager().getResearchEffects().getEffectBoolean(researchId))\n             {\n-                excludedEffect = true;\n+                // Research effect queried, present, and set to true.\n+                return true;\n             }\n-            else\n+            if (colony.getResearchManager().getResearchTree().hasCompletedResearch(researchId))\n             {\n-                if(Boolean.TRUE.equals(colony.getResearchManager().getResearchTree().hasCompletedResearch(excludedResearchId)))\n-                {\n-                    for(IResearchEffect effect : IGlobalResearchTree.getInstance().getEffectsForResearch(excludedResearchId))\n-                    {\n-                        if(effect instanceof UnlockAbilityResearchEffect)\n-                        {\n-                            excludedEffect = true;\n-                        }\n-                    }\n-                }\n+                // Research ID queried and present.\n+                // This will allow simple Recipe-style unlocks to exist without needing an extra effect category.\n+                return true;\n             }\n         }\n+        // Research ID queried and present or present as an effect, but not completed or does not have an unlock effect.\n+        return false;\n+    }\n \n+    /**\n+     * Check if a precursor recipe is missing from the building.\n+     * @param building      The building which would contain the precursor recipe.\n+     * @return              True if a precusor recipe was required and not present.\n+     */\n+    private boolean isPrecursorRecipeMissing(IBuildingWorker building)\n+    {\n         if(mustExist)\n         {\n-            boolean found = false;\n             final IRecipeStorage compareStorage = this.getRecipeStorage();\n             final ResourceLocation recipeSource = this.getRecipeId();\n-            for(IToken<?> recipeToken: building.getRecipes())\n+            for (IToken<?> recipeToken : building.getRecipes())\n             {\n                 final IRecipeStorage storage = IColonyManager.getInstance().getRecipeManager().getRecipes().get(recipeToken);\n-                if((storage.getRecipeSource() != null && storage.getRecipeSource().equals(recipeSource)) || (storage.getCleanedInput().containsAll(compareStorage.getCleanedInput()) && compareStorage.getCleanedInput().containsAll(storage.getCleanedInput())))\n+                if ((storage.getRecipeSource() != null && storage.getRecipeSource().equals(recipeSource)) || (\n+                  storage.getCleanedInput().containsAll(compareStorage.getCleanedInput())\n+                    && compareStorage.getCleanedInput()\n+                         .containsAll(storage.getCleanedInput())))\n                 {\n-                    found = true;\n-                    break;\n+                    return false;\n                 }\n             }\n-            if(!found)\n-            {\n-                return false; \n-            }\n+            return true;\n         }\n-\n-        return (researchId == null || requiredEffect)\n-            && (excludedResearchId == null || !excludedEffect)\n-            && (bldgLevel >= minBldgLevel)\n-            && (bldgLevel <= maxBldgLevel);\n+        // if no precursor needed.\n+        return false;\n     }\n \n     /**\n      * Get a the recipe storage represented by this recipe\n-     * @return\n+     * @return Recipe Storage\n      */\n     public IRecipeStorage getRecipeStorage()\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4MDA1MA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540480050", "bodyText": "crafter recipes? xD", "author": "someaddons", "createdAt": "2020-12-10T20:37:55Z", "path": "src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.minecolonies.coremod.datalistener;\n+\n+import com.google.gson.*;\n+import com.minecolonies.api.MinecoloniesAPIProxy;\n+import com.minecolonies.api.configuration.Configuration;\n+import com.minecolonies.api.crafting.ItemStorage;\n+import com.minecolonies.api.research.IGlobalResearch;\n+import com.minecolonies.api.research.IGlobalResearchTree;\n+import com.minecolonies.api.research.IResearchRequirement;\n+import com.minecolonies.api.research.effects.IResearchEffect;\n+import com.minecolonies.api.util.Log;\n+\n+import com.minecolonies.coremod.research.GlobalResearch;\n+import com.minecolonies.coremod.research.ResearchEffectCategory;\n+import jdk.nashorn.internal.objects.Global;\n+import net.minecraft.client.resources.JsonReloadListener;\n+import net.minecraft.profiler.IProfiler;\n+import net.minecraft.resources.IResourceManager;\n+import net.minecraft.util.ResourceLocation;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.minecolonies.coremod.research.GlobalResearch.*;\n+import static com.minecolonies.coremod.research.ResearchEffectCategory.*;\n+\n+/**\n+ * Loader for Json based crafter specific recipes", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYwNTIyMg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540605222", "bodyText": "My not-so secret shame of copy-pasting code and comments!  Thanks for catching that.", "author": "gattsuru", "createdAt": "2020-12-11T00:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4MDA1MA=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\nindex 82084cf914..e4975dd43d 100644\n--- a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n+++ b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n\n@@ -2,9 +2,7 @@ package com.minecolonies.coremod.datalistener;\n \n import com.google.gson.*;\n import com.minecolonies.api.MinecoloniesAPIProxy;\n-import com.minecolonies.api.configuration.Configuration;\n import com.minecolonies.api.crafting.ItemStorage;\n-import com.minecolonies.api.research.IGlobalResearch;\n import com.minecolonies.api.research.IGlobalResearchTree;\n import com.minecolonies.api.research.IResearchRequirement;\n import com.minecolonies.api.research.effects.IResearchEffect;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4MDkwMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540480901", "bodyText": "javadoc", "author": "someaddons", "createdAt": "2020-12-10T20:39:25Z", "path": "src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.minecolonies.coremod.datalistener;\n+\n+import com.google.gson.*;\n+import com.minecolonies.api.MinecoloniesAPIProxy;\n+import com.minecolonies.api.configuration.Configuration;\n+import com.minecolonies.api.crafting.ItemStorage;\n+import com.minecolonies.api.research.IGlobalResearch;\n+import com.minecolonies.api.research.IGlobalResearchTree;\n+import com.minecolonies.api.research.IResearchRequirement;\n+import com.minecolonies.api.research.effects.IResearchEffect;\n+import com.minecolonies.api.util.Log;\n+\n+import com.minecolonies.coremod.research.GlobalResearch;\n+import com.minecolonies.coremod.research.ResearchEffectCategory;\n+import jdk.nashorn.internal.objects.Global;\n+import net.minecraft.client.resources.JsonReloadListener;\n+import net.minecraft.profiler.IProfiler;\n+import net.minecraft.resources.IResourceManager;\n+import net.minecraft.util.ResourceLocation;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.minecolonies.coremod.research.GlobalResearch.*;\n+import static com.minecolonies.coremod.research.ResearchEffectCategory.*;\n+\n+/**\n+ * Loader for Json based crafter specific recipes\n+ */\n+public class ResearchListener extends JsonReloadListener\n+{\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().create();\n+\n+    /**\n+     * Set up the core loading, with the directory in the datapack that contains this data\n+     * Directory is: <namespace>/researches/<path>\n+     */\n+    public ResearchListener()\n+    {\n+        super(GSON, \"researches\");\n+    }\n+\n+    @Override\n+    protected void apply(final Map<ResourceLocation, JsonElement> object, final IResourceManager resourceManagerIn, final IProfiler profilerIn)\n+    {\n+        Log.getLogger().info(\"Beginning load of research for University.\");\n+\n+        // First, index and map out all research effects.  We need to be able to map them before creating Researches themselves.\n+        // Because datapacks, can't assume effects are in one specific location.\n+        // For now, we'll populate relative levels when doing so, but we probably want to do that dynamically.\n+        Map<String, ResearchEffectCategory> effectCategories = parseResearchEffects(object);\n+\n+        // Next, populate a new map of IGlobalResearches, identified by researchID.\n+        // This allows us to figure out root/branch relationships more sanely.\n+        // We need the effectCategories and levels to do this.\n+        Map<String, GlobalResearch> researchMap = parseResearches(object, effectCategories);\n+\n+        // We /shouldn't/ get any removes before the Research they're trying to remove exists,\n+        // but it can happen if multiple datapacks affect each other.\n+        // So now that we've loaded everything, then we can start removes.\n+        parseRemoveResearches(object, researchMap);\n+\n+        // After we've loaded all researches, we can then try to assign child relationships.\n+        // This is also the phase where we'd try to support back-calculating university levels for researches without them/with incorrect ones.\n+        IGlobalResearchTree researchTree = calcResearchTree(researchMap);\n+\n+        Log.getLogger().info(\"Loaded \" + researchMap.values().size() + \" recipes for \" + researchTree.getBranches().size() + \" research branches\");\n+    }\n+\n+    private Map<String, ResearchEffectCategory> parseResearchEffects(Map<ResourceLocation, JsonElement> object)", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\nindex 82084cf914..e4975dd43d 100644\n--- a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n+++ b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n\n@@ -2,9 +2,7 @@ package com.minecolonies.coremod.datalistener;\n \n import com.google.gson.*;\n import com.minecolonies.api.MinecoloniesAPIProxy;\n-import com.minecolonies.api.configuration.Configuration;\n import com.minecolonies.api.crafting.ItemStorage;\n-import com.minecolonies.api.research.IGlobalResearch;\n import com.minecolonies.api.research.IGlobalResearchTree;\n import com.minecolonies.api.research.IResearchRequirement;\n import com.minecolonies.api.research.effects.IResearchEffect;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4MjcxNg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540482716", "bodyText": "Do we maybe want some error logs when we get a malformed input?", "author": "someaddons", "createdAt": "2020-12-10T20:42:24Z", "path": "src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.minecolonies.coremod.datalistener;\n+\n+import com.google.gson.*;\n+import com.minecolonies.api.MinecoloniesAPIProxy;\n+import com.minecolonies.api.configuration.Configuration;\n+import com.minecolonies.api.crafting.ItemStorage;\n+import com.minecolonies.api.research.IGlobalResearch;\n+import com.minecolonies.api.research.IGlobalResearchTree;\n+import com.minecolonies.api.research.IResearchRequirement;\n+import com.minecolonies.api.research.effects.IResearchEffect;\n+import com.minecolonies.api.util.Log;\n+\n+import com.minecolonies.coremod.research.GlobalResearch;\n+import com.minecolonies.coremod.research.ResearchEffectCategory;\n+import jdk.nashorn.internal.objects.Global;\n+import net.minecraft.client.resources.JsonReloadListener;\n+import net.minecraft.profiler.IProfiler;\n+import net.minecraft.resources.IResourceManager;\n+import net.minecraft.util.ResourceLocation;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.minecolonies.coremod.research.GlobalResearch.*;\n+import static com.minecolonies.coremod.research.ResearchEffectCategory.*;\n+\n+/**\n+ * Loader for Json based crafter specific recipes\n+ */\n+public class ResearchListener extends JsonReloadListener\n+{\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().create();\n+\n+    /**\n+     * Set up the core loading, with the directory in the datapack that contains this data\n+     * Directory is: <namespace>/researches/<path>\n+     */\n+    public ResearchListener()\n+    {\n+        super(GSON, \"researches\");\n+    }\n+\n+    @Override\n+    protected void apply(final Map<ResourceLocation, JsonElement> object, final IResourceManager resourceManagerIn, final IProfiler profilerIn)\n+    {\n+        Log.getLogger().info(\"Beginning load of research for University.\");\n+\n+        // First, index and map out all research effects.  We need to be able to map them before creating Researches themselves.\n+        // Because datapacks, can't assume effects are in one specific location.\n+        // For now, we'll populate relative levels when doing so, but we probably want to do that dynamically.\n+        Map<String, ResearchEffectCategory> effectCategories = parseResearchEffects(object);\n+\n+        // Next, populate a new map of IGlobalResearches, identified by researchID.\n+        // This allows us to figure out root/branch relationships more sanely.\n+        // We need the effectCategories and levels to do this.\n+        Map<String, GlobalResearch> researchMap = parseResearches(object, effectCategories);\n+\n+        // We /shouldn't/ get any removes before the Research they're trying to remove exists,\n+        // but it can happen if multiple datapacks affect each other.\n+        // So now that we've loaded everything, then we can start removes.\n+        parseRemoveResearches(object, researchMap);\n+\n+        // After we've loaded all researches, we can then try to assign child relationships.\n+        // This is also the phase where we'd try to support back-calculating university levels for researches without them/with incorrect ones.\n+        IGlobalResearchTree researchTree = calcResearchTree(researchMap);\n+\n+        Log.getLogger().info(\"Loaded \" + researchMap.values().size() + \" recipes for \" + researchTree.getBranches().size() + \" research branches\");\n+    }\n+\n+    private Map<String, ResearchEffectCategory> parseResearchEffects(Map<ResourceLocation, JsonElement> object)\n+    {\n+        final Map<String, ResearchEffectCategory> effectCategories = new HashMap<>();\n+        for(final Map.Entry<ResourceLocation, JsonElement> entry : object.entrySet())\n+        {\n+            JsonObject effectJson = entry.getValue().getAsJsonObject();\n+\n+            if (effectJson.has(RESEARCH_EFFECT_PROP) && effectJson.has(RESEARCH_ID_PROP)\n+                  && effectJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && effectJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString()\n+                  &&  effectJson.has(RESEARCH_EFFECT_TYPE_PROP) && effectJson.get(RESEARCH_EFFECT_TYPE_PROP).isJsonPrimitive()\n+                  && effectJson.get(RESEARCH_EFFECT_TYPE_PROP).getAsJsonPrimitive().isString())", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\nindex 82084cf914..e4975dd43d 100644\n--- a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n+++ b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n\n@@ -2,9 +2,7 @@ package com.minecolonies.coremod.datalistener;\n \n import com.google.gson.*;\n import com.minecolonies.api.MinecoloniesAPIProxy;\n-import com.minecolonies.api.configuration.Configuration;\n import com.minecolonies.api.crafting.ItemStorage;\n-import com.minecolonies.api.research.IGlobalResearch;\n import com.minecolonies.api.research.IGlobalResearchTree;\n import com.minecolonies.api.research.IResearchRequirement;\n import com.minecolonies.api.research.effects.IResearchEffect;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4NDQ3Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540484476", "bodyText": "should proably print the fields that are required", "author": "someaddons", "createdAt": "2020-12-10T20:45:29Z", "path": "src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.minecolonies.coremod.datalistener;\n+\n+import com.google.gson.*;\n+import com.minecolonies.api.MinecoloniesAPIProxy;\n+import com.minecolonies.api.configuration.Configuration;\n+import com.minecolonies.api.crafting.ItemStorage;\n+import com.minecolonies.api.research.IGlobalResearch;\n+import com.minecolonies.api.research.IGlobalResearchTree;\n+import com.minecolonies.api.research.IResearchRequirement;\n+import com.minecolonies.api.research.effects.IResearchEffect;\n+import com.minecolonies.api.util.Log;\n+\n+import com.minecolonies.coremod.research.GlobalResearch;\n+import com.minecolonies.coremod.research.ResearchEffectCategory;\n+import jdk.nashorn.internal.objects.Global;\n+import net.minecraft.client.resources.JsonReloadListener;\n+import net.minecraft.profiler.IProfiler;\n+import net.minecraft.resources.IResourceManager;\n+import net.minecraft.util.ResourceLocation;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.minecolonies.coremod.research.GlobalResearch.*;\n+import static com.minecolonies.coremod.research.ResearchEffectCategory.*;\n+\n+/**\n+ * Loader for Json based crafter specific recipes\n+ */\n+public class ResearchListener extends JsonReloadListener\n+{\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().create();\n+\n+    /**\n+     * Set up the core loading, with the directory in the datapack that contains this data\n+     * Directory is: <namespace>/researches/<path>\n+     */\n+    public ResearchListener()\n+    {\n+        super(GSON, \"researches\");\n+    }\n+\n+    @Override\n+    protected void apply(final Map<ResourceLocation, JsonElement> object, final IResourceManager resourceManagerIn, final IProfiler profilerIn)\n+    {\n+        Log.getLogger().info(\"Beginning load of research for University.\");\n+\n+        // First, index and map out all research effects.  We need to be able to map them before creating Researches themselves.\n+        // Because datapacks, can't assume effects are in one specific location.\n+        // For now, we'll populate relative levels when doing so, but we probably want to do that dynamically.\n+        Map<String, ResearchEffectCategory> effectCategories = parseResearchEffects(object);\n+\n+        // Next, populate a new map of IGlobalResearches, identified by researchID.\n+        // This allows us to figure out root/branch relationships more sanely.\n+        // We need the effectCategories and levels to do this.\n+        Map<String, GlobalResearch> researchMap = parseResearches(object, effectCategories);\n+\n+        // We /shouldn't/ get any removes before the Research they're trying to remove exists,\n+        // but it can happen if multiple datapacks affect each other.\n+        // So now that we've loaded everything, then we can start removes.\n+        parseRemoveResearches(object, researchMap);\n+\n+        // After we've loaded all researches, we can then try to assign child relationships.\n+        // This is also the phase where we'd try to support back-calculating university levels for researches without them/with incorrect ones.\n+        IGlobalResearchTree researchTree = calcResearchTree(researchMap);\n+\n+        Log.getLogger().info(\"Loaded \" + researchMap.values().size() + \" recipes for \" + researchTree.getBranches().size() + \" research branches\");\n+    }\n+\n+    private Map<String, ResearchEffectCategory> parseResearchEffects(Map<ResourceLocation, JsonElement> object)\n+    {\n+        final Map<String, ResearchEffectCategory> effectCategories = new HashMap<>();\n+        for(final Map.Entry<ResourceLocation, JsonElement> entry : object.entrySet())\n+        {\n+            JsonObject effectJson = entry.getValue().getAsJsonObject();\n+\n+            if (effectJson.has(RESEARCH_EFFECT_PROP) && effectJson.has(RESEARCH_ID_PROP)\n+                  && effectJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && effectJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString()\n+                  &&  effectJson.has(RESEARCH_EFFECT_TYPE_PROP) && effectJson.get(RESEARCH_EFFECT_TYPE_PROP).isJsonPrimitive()\n+                  && effectJson.get(RESEARCH_EFFECT_TYPE_PROP).getAsJsonPrimitive().isString())\n+            {\n+                final ResearchEffectCategory category;\n+                if((effectJson.has(RESEARCH_NAME_PROP) && effectJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && effectJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString()))\n+                {\n+                    category = new ResearchEffectCategory(effectJson.get(RESEARCH_ID_PROP).getAsString(), effectJson.get(RESEARCH_NAME_PROP).getAsString(), effectJson.get(RESEARCH_EFFECT_TYPE_PROP).getAsString());\n+                }\n+                else\n+                {\n+                    category = new ResearchEffectCategory(effectJson.get(RESEARCH_ID_PROP).getAsString(), effectJson.get(RESEARCH_EFFECT_TYPE_PROP).getAsString());\n+                }\n+                if (effectJson.has(RESEARCH_EFFECT_LEVELS_PROP) && effectJson.get(RESEARCH_EFFECT_LEVELS_PROP).isJsonArray())\n+                {\n+                    for(JsonElement levelElement : effectJson.get(RESEARCH_EFFECT_LEVELS_PROP).getAsJsonArray())\n+                    {\n+                        if(levelElement.isJsonPrimitive() && levelElement.getAsJsonPrimitive().isNumber())\n+                        {\n+                            category.add(levelElement.getAsNumber().floatValue());\n+                        }\n+                    }\n+                }\n+                // If no levels are defined, assume temporarily boolean, and store on/off.\n+                else\n+                {\n+                    category.add(1f);\n+                }\n+                effectCategories.put(category.getId(), category);\n+            }\n+        }\n+        return effectCategories;\n+    }\n+\n+    private Map<String, GlobalResearch> parseResearches(Map<ResourceLocation, JsonElement> object, Map<String, ResearchEffectCategory> effectCategories)\n+    {\n+        final Map<String, GlobalResearch> researchMap = new HashMap<String, GlobalResearch>();\n+        for(final Map.Entry<ResourceLocation, JsonElement> entry : object.entrySet())\n+        {\n+            //Note that we don't actually use the resource folders or file names; those are only for organization purposes.\n+            JsonObject researchJson = entry.getValue().getAsJsonObject();\n+\n+            //Can ignore those effect jsons now:\n+            if (researchJson.has(RESEARCH_EFFECT_PROP))\n+            {\n+                continue;\n+            }\n+\n+            //Check for absolute minimum required types, and log as warning if malformed.\n+            if (MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchDebugLog.get() &&\n+                  !(researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive()\n+                    && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+                  || !(researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive()\n+                         && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString()))\n+            {\n+                Log.getLogger().warn(entry.getKey() + \"missing required fields\");", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\nindex 82084cf914..e4975dd43d 100644\n--- a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n+++ b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n\n@@ -2,9 +2,7 @@ package com.minecolonies.coremod.datalistener;\n \n import com.google.gson.*;\n import com.minecolonies.api.MinecoloniesAPIProxy;\n-import com.minecolonies.api.configuration.Configuration;\n import com.minecolonies.api.crafting.ItemStorage;\n-import com.minecolonies.api.research.IGlobalResearch;\n import com.minecolonies.api.research.IGlobalResearchTree;\n import com.minecolonies.api.research.IResearchRequirement;\n import com.minecolonies.api.research.effects.IResearchEffect;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4NDY3Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540484677", "bodyText": "javadoc", "author": "someaddons", "createdAt": "2020-12-10T20:45:50Z", "path": "src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.minecolonies.coremod.datalistener;\n+\n+import com.google.gson.*;\n+import com.minecolonies.api.MinecoloniesAPIProxy;\n+import com.minecolonies.api.configuration.Configuration;\n+import com.minecolonies.api.crafting.ItemStorage;\n+import com.minecolonies.api.research.IGlobalResearch;\n+import com.minecolonies.api.research.IGlobalResearchTree;\n+import com.minecolonies.api.research.IResearchRequirement;\n+import com.minecolonies.api.research.effects.IResearchEffect;\n+import com.minecolonies.api.util.Log;\n+\n+import com.minecolonies.coremod.research.GlobalResearch;\n+import com.minecolonies.coremod.research.ResearchEffectCategory;\n+import jdk.nashorn.internal.objects.Global;\n+import net.minecraft.client.resources.JsonReloadListener;\n+import net.minecraft.profiler.IProfiler;\n+import net.minecraft.resources.IResourceManager;\n+import net.minecraft.util.ResourceLocation;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.minecolonies.coremod.research.GlobalResearch.*;\n+import static com.minecolonies.coremod.research.ResearchEffectCategory.*;\n+\n+/**\n+ * Loader for Json based crafter specific recipes\n+ */\n+public class ResearchListener extends JsonReloadListener\n+{\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().create();\n+\n+    /**\n+     * Set up the core loading, with the directory in the datapack that contains this data\n+     * Directory is: <namespace>/researches/<path>\n+     */\n+    public ResearchListener()\n+    {\n+        super(GSON, \"researches\");\n+    }\n+\n+    @Override\n+    protected void apply(final Map<ResourceLocation, JsonElement> object, final IResourceManager resourceManagerIn, final IProfiler profilerIn)\n+    {\n+        Log.getLogger().info(\"Beginning load of research for University.\");\n+\n+        // First, index and map out all research effects.  We need to be able to map them before creating Researches themselves.\n+        // Because datapacks, can't assume effects are in one specific location.\n+        // For now, we'll populate relative levels when doing so, but we probably want to do that dynamically.\n+        Map<String, ResearchEffectCategory> effectCategories = parseResearchEffects(object);\n+\n+        // Next, populate a new map of IGlobalResearches, identified by researchID.\n+        // This allows us to figure out root/branch relationships more sanely.\n+        // We need the effectCategories and levels to do this.\n+        Map<String, GlobalResearch> researchMap = parseResearches(object, effectCategories);\n+\n+        // We /shouldn't/ get any removes before the Research they're trying to remove exists,\n+        // but it can happen if multiple datapacks affect each other.\n+        // So now that we've loaded everything, then we can start removes.\n+        parseRemoveResearches(object, researchMap);\n+\n+        // After we've loaded all researches, we can then try to assign child relationships.\n+        // This is also the phase where we'd try to support back-calculating university levels for researches without them/with incorrect ones.\n+        IGlobalResearchTree researchTree = calcResearchTree(researchMap);\n+\n+        Log.getLogger().info(\"Loaded \" + researchMap.values().size() + \" recipes for \" + researchTree.getBranches().size() + \" research branches\");\n+    }\n+\n+    private Map<String, ResearchEffectCategory> parseResearchEffects(Map<ResourceLocation, JsonElement> object)\n+    {\n+        final Map<String, ResearchEffectCategory> effectCategories = new HashMap<>();\n+        for(final Map.Entry<ResourceLocation, JsonElement> entry : object.entrySet())\n+        {\n+            JsonObject effectJson = entry.getValue().getAsJsonObject();\n+\n+            if (effectJson.has(RESEARCH_EFFECT_PROP) && effectJson.has(RESEARCH_ID_PROP)\n+                  && effectJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && effectJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString()\n+                  &&  effectJson.has(RESEARCH_EFFECT_TYPE_PROP) && effectJson.get(RESEARCH_EFFECT_TYPE_PROP).isJsonPrimitive()\n+                  && effectJson.get(RESEARCH_EFFECT_TYPE_PROP).getAsJsonPrimitive().isString())\n+            {\n+                final ResearchEffectCategory category;\n+                if((effectJson.has(RESEARCH_NAME_PROP) && effectJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && effectJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString()))\n+                {\n+                    category = new ResearchEffectCategory(effectJson.get(RESEARCH_ID_PROP).getAsString(), effectJson.get(RESEARCH_NAME_PROP).getAsString(), effectJson.get(RESEARCH_EFFECT_TYPE_PROP).getAsString());\n+                }\n+                else\n+                {\n+                    category = new ResearchEffectCategory(effectJson.get(RESEARCH_ID_PROP).getAsString(), effectJson.get(RESEARCH_EFFECT_TYPE_PROP).getAsString());\n+                }\n+                if (effectJson.has(RESEARCH_EFFECT_LEVELS_PROP) && effectJson.get(RESEARCH_EFFECT_LEVELS_PROP).isJsonArray())\n+                {\n+                    for(JsonElement levelElement : effectJson.get(RESEARCH_EFFECT_LEVELS_PROP).getAsJsonArray())\n+                    {\n+                        if(levelElement.isJsonPrimitive() && levelElement.getAsJsonPrimitive().isNumber())\n+                        {\n+                            category.add(levelElement.getAsNumber().floatValue());\n+                        }\n+                    }\n+                }\n+                // If no levels are defined, assume temporarily boolean, and store on/off.\n+                else\n+                {\n+                    category.add(1f);\n+                }\n+                effectCategories.put(category.getId(), category);\n+            }\n+        }\n+        return effectCategories;\n+    }\n+\n+    private Map<String, GlobalResearch> parseResearches(Map<ResourceLocation, JsonElement> object, Map<String, ResearchEffectCategory> effectCategories)", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\nindex 82084cf914..e4975dd43d 100644\n--- a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n+++ b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n\n@@ -2,9 +2,7 @@ package com.minecolonies.coremod.datalistener;\n \n import com.google.gson.*;\n import com.minecolonies.api.MinecoloniesAPIProxy;\n-import com.minecolonies.api.configuration.Configuration;\n import com.minecolonies.api.crafting.ItemStorage;\n-import com.minecolonies.api.research.IGlobalResearch;\n import com.minecolonies.api.research.IGlobalResearchTree;\n import com.minecolonies.api.research.IResearchRequirement;\n import com.minecolonies.api.research.effects.IResearchEffect;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4NDgyNg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540484826", "bodyText": "javadoc", "author": "someaddons", "createdAt": "2020-12-10T20:46:05Z", "path": "src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.minecolonies.coremod.datalistener;\n+\n+import com.google.gson.*;\n+import com.minecolonies.api.MinecoloniesAPIProxy;\n+import com.minecolonies.api.configuration.Configuration;\n+import com.minecolonies.api.crafting.ItemStorage;\n+import com.minecolonies.api.research.IGlobalResearch;\n+import com.minecolonies.api.research.IGlobalResearchTree;\n+import com.minecolonies.api.research.IResearchRequirement;\n+import com.minecolonies.api.research.effects.IResearchEffect;\n+import com.minecolonies.api.util.Log;\n+\n+import com.minecolonies.coremod.research.GlobalResearch;\n+import com.minecolonies.coremod.research.ResearchEffectCategory;\n+import jdk.nashorn.internal.objects.Global;\n+import net.minecraft.client.resources.JsonReloadListener;\n+import net.minecraft.profiler.IProfiler;\n+import net.minecraft.resources.IResourceManager;\n+import net.minecraft.util.ResourceLocation;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.minecolonies.coremod.research.GlobalResearch.*;\n+import static com.minecolonies.coremod.research.ResearchEffectCategory.*;\n+\n+/**\n+ * Loader for Json based crafter specific recipes\n+ */\n+public class ResearchListener extends JsonReloadListener\n+{\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().create();\n+\n+    /**\n+     * Set up the core loading, with the directory in the datapack that contains this data\n+     * Directory is: <namespace>/researches/<path>\n+     */\n+    public ResearchListener()\n+    {\n+        super(GSON, \"researches\");\n+    }\n+\n+    @Override\n+    protected void apply(final Map<ResourceLocation, JsonElement> object, final IResourceManager resourceManagerIn, final IProfiler profilerIn)\n+    {\n+        Log.getLogger().info(\"Beginning load of research for University.\");\n+\n+        // First, index and map out all research effects.  We need to be able to map them before creating Researches themselves.\n+        // Because datapacks, can't assume effects are in one specific location.\n+        // For now, we'll populate relative levels when doing so, but we probably want to do that dynamically.\n+        Map<String, ResearchEffectCategory> effectCategories = parseResearchEffects(object);\n+\n+        // Next, populate a new map of IGlobalResearches, identified by researchID.\n+        // This allows us to figure out root/branch relationships more sanely.\n+        // We need the effectCategories and levels to do this.\n+        Map<String, GlobalResearch> researchMap = parseResearches(object, effectCategories);\n+\n+        // We /shouldn't/ get any removes before the Research they're trying to remove exists,\n+        // but it can happen if multiple datapacks affect each other.\n+        // So now that we've loaded everything, then we can start removes.\n+        parseRemoveResearches(object, researchMap);\n+\n+        // After we've loaded all researches, we can then try to assign child relationships.\n+        // This is also the phase where we'd try to support back-calculating university levels for researches without them/with incorrect ones.\n+        IGlobalResearchTree researchTree = calcResearchTree(researchMap);\n+\n+        Log.getLogger().info(\"Loaded \" + researchMap.values().size() + \" recipes for \" + researchTree.getBranches().size() + \" research branches\");\n+    }\n+\n+    private Map<String, ResearchEffectCategory> parseResearchEffects(Map<ResourceLocation, JsonElement> object)\n+    {\n+        final Map<String, ResearchEffectCategory> effectCategories = new HashMap<>();\n+        for(final Map.Entry<ResourceLocation, JsonElement> entry : object.entrySet())\n+        {\n+            JsonObject effectJson = entry.getValue().getAsJsonObject();\n+\n+            if (effectJson.has(RESEARCH_EFFECT_PROP) && effectJson.has(RESEARCH_ID_PROP)\n+                  && effectJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && effectJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString()\n+                  &&  effectJson.has(RESEARCH_EFFECT_TYPE_PROP) && effectJson.get(RESEARCH_EFFECT_TYPE_PROP).isJsonPrimitive()\n+                  && effectJson.get(RESEARCH_EFFECT_TYPE_PROP).getAsJsonPrimitive().isString())\n+            {\n+                final ResearchEffectCategory category;\n+                if((effectJson.has(RESEARCH_NAME_PROP) && effectJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && effectJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString()))\n+                {\n+                    category = new ResearchEffectCategory(effectJson.get(RESEARCH_ID_PROP).getAsString(), effectJson.get(RESEARCH_NAME_PROP).getAsString(), effectJson.get(RESEARCH_EFFECT_TYPE_PROP).getAsString());\n+                }\n+                else\n+                {\n+                    category = new ResearchEffectCategory(effectJson.get(RESEARCH_ID_PROP).getAsString(), effectJson.get(RESEARCH_EFFECT_TYPE_PROP).getAsString());\n+                }\n+                if (effectJson.has(RESEARCH_EFFECT_LEVELS_PROP) && effectJson.get(RESEARCH_EFFECT_LEVELS_PROP).isJsonArray())\n+                {\n+                    for(JsonElement levelElement : effectJson.get(RESEARCH_EFFECT_LEVELS_PROP).getAsJsonArray())\n+                    {\n+                        if(levelElement.isJsonPrimitive() && levelElement.getAsJsonPrimitive().isNumber())\n+                        {\n+                            category.add(levelElement.getAsNumber().floatValue());\n+                        }\n+                    }\n+                }\n+                // If no levels are defined, assume temporarily boolean, and store on/off.\n+                else\n+                {\n+                    category.add(1f);\n+                }\n+                effectCategories.put(category.getId(), category);\n+            }\n+        }\n+        return effectCategories;\n+    }\n+\n+    private Map<String, GlobalResearch> parseResearches(Map<ResourceLocation, JsonElement> object, Map<String, ResearchEffectCategory> effectCategories)\n+    {\n+        final Map<String, GlobalResearch> researchMap = new HashMap<String, GlobalResearch>();\n+        for(final Map.Entry<ResourceLocation, JsonElement> entry : object.entrySet())\n+        {\n+            //Note that we don't actually use the resource folders or file names; those are only for organization purposes.\n+            JsonObject researchJson = entry.getValue().getAsJsonObject();\n+\n+            //Can ignore those effect jsons now:\n+            if (researchJson.has(RESEARCH_EFFECT_PROP))\n+            {\n+                continue;\n+            }\n+\n+            //Check for absolute minimum required types, and log as warning if malformed.\n+            if (MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchDebugLog.get() &&\n+                  !(researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive()\n+                    && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+                  || !(researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive()\n+                         && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString()))\n+            {\n+                Log.getLogger().warn(entry.getKey() + \"missing required fields\");\n+                continue;\n+            }\n+\n+            //Missing university level data may not necessarily be a show-stopper, but it is worth warning about.\n+            if(MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchDebugLog.get() &&\n+                 (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isNumber()))\n+            {\n+                Log.getLogger().warn(entry.getKey() + \"has invalid or no university level requirements.\");\n+            }\n+\n+            //Next, check for remove-type recipes.  We don't want to accidentally add them just because they have too much detail.\n+            if ((researchJson.has(RESEARCH_REMOVE_PROP) && researchJson.get(RESEARCH_REMOVE_PROP).getAsJsonPrimitive().isBoolean())\n+                  && researchJson.get(RESEARCH_REMOVE_PROP).getAsJsonPrimitive().getAsBoolean())\n+            {\n+                continue;\n+            }\n+\n+            //Pretty much anything else should be allowed: it's plausible pack designers may want a research type without a cost or effect.\n+            //It's possible we could dynamically derive university levels from parents, but doing so as a rule will prevent research branches that start at T2 or deeper.\n+            final GlobalResearch research = new GlobalResearch(researchJson, entry.getKey(), effectCategories);\n+            if(MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchDebugLog.get())\n+            {\n+                Log.getLogger().info(\"Parsed research recipe from \" + entry.getKey() + \" [\" + research.getBranch() + \"/\" + research.getId() + \"]\");\n+                Log.getLogger().info(research.getDesc() + \" at \" + research.getDepth() + \"/\" + research.getParent());\n+                for(IResearchRequirement requirement : research.getResearchRequirement())\n+                {\n+                    Log.getLogger().info(\"Requirement: \" + requirement.getDesc());\n+                }\n+                for(ItemStorage itemS : research.getCostList())\n+                {\n+                    Log.getLogger().info(\"Cost: \" + itemS.toString());\n+                }\n+                for(IResearchEffect researchEffect : research.getEffects())\n+                {\n+                    Log.getLogger().info(\"Effect: \" + researchEffect.getId() + \" \" + researchEffect.getDesc());\n+                }\n+            }\n+            researchMap.put(research.getId(), research);\n+        }\n+        return researchMap;\n+    }\n+\n+    private void parseRemoveResearches(Map<ResourceLocation, JsonElement> object, Map<String, GlobalResearch> researchMap)", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\nindex 82084cf914..e4975dd43d 100644\n--- a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n+++ b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n\n@@ -2,9 +2,7 @@ package com.minecolonies.coremod.datalistener;\n \n import com.google.gson.*;\n import com.minecolonies.api.MinecoloniesAPIProxy;\n-import com.minecolonies.api.configuration.Configuration;\n import com.minecolonies.api.crafting.ItemStorage;\n-import com.minecolonies.api.research.IGlobalResearch;\n import com.minecolonies.api.research.IGlobalResearchTree;\n import com.minecolonies.api.research.IResearchRequirement;\n import com.minecolonies.api.research.effects.IResearchEffect;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4NTEzMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540485131", "bodyText": "javadoc", "author": "someaddons", "createdAt": "2020-12-10T20:46:36Z", "path": "src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.minecolonies.coremod.datalistener;\n+\n+import com.google.gson.*;\n+import com.minecolonies.api.MinecoloniesAPIProxy;\n+import com.minecolonies.api.configuration.Configuration;\n+import com.minecolonies.api.crafting.ItemStorage;\n+import com.minecolonies.api.research.IGlobalResearch;\n+import com.minecolonies.api.research.IGlobalResearchTree;\n+import com.minecolonies.api.research.IResearchRequirement;\n+import com.minecolonies.api.research.effects.IResearchEffect;\n+import com.minecolonies.api.util.Log;\n+\n+import com.minecolonies.coremod.research.GlobalResearch;\n+import com.minecolonies.coremod.research.ResearchEffectCategory;\n+import jdk.nashorn.internal.objects.Global;\n+import net.minecraft.client.resources.JsonReloadListener;\n+import net.minecraft.profiler.IProfiler;\n+import net.minecraft.resources.IResourceManager;\n+import net.minecraft.util.ResourceLocation;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.minecolonies.coremod.research.GlobalResearch.*;\n+import static com.minecolonies.coremod.research.ResearchEffectCategory.*;\n+\n+/**\n+ * Loader for Json based crafter specific recipes\n+ */\n+public class ResearchListener extends JsonReloadListener\n+{\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().create();\n+\n+    /**\n+     * Set up the core loading, with the directory in the datapack that contains this data\n+     * Directory is: <namespace>/researches/<path>\n+     */\n+    public ResearchListener()\n+    {\n+        super(GSON, \"researches\");\n+    }\n+\n+    @Override\n+    protected void apply(final Map<ResourceLocation, JsonElement> object, final IResourceManager resourceManagerIn, final IProfiler profilerIn)\n+    {\n+        Log.getLogger().info(\"Beginning load of research for University.\");\n+\n+        // First, index and map out all research effects.  We need to be able to map them before creating Researches themselves.\n+        // Because datapacks, can't assume effects are in one specific location.\n+        // For now, we'll populate relative levels when doing so, but we probably want to do that dynamically.\n+        Map<String, ResearchEffectCategory> effectCategories = parseResearchEffects(object);\n+\n+        // Next, populate a new map of IGlobalResearches, identified by researchID.\n+        // This allows us to figure out root/branch relationships more sanely.\n+        // We need the effectCategories and levels to do this.\n+        Map<String, GlobalResearch> researchMap = parseResearches(object, effectCategories);\n+\n+        // We /shouldn't/ get any removes before the Research they're trying to remove exists,\n+        // but it can happen if multiple datapacks affect each other.\n+        // So now that we've loaded everything, then we can start removes.\n+        parseRemoveResearches(object, researchMap);\n+\n+        // After we've loaded all researches, we can then try to assign child relationships.\n+        // This is also the phase where we'd try to support back-calculating university levels for researches without them/with incorrect ones.\n+        IGlobalResearchTree researchTree = calcResearchTree(researchMap);\n+\n+        Log.getLogger().info(\"Loaded \" + researchMap.values().size() + \" recipes for \" + researchTree.getBranches().size() + \" research branches\");\n+    }\n+\n+    private Map<String, ResearchEffectCategory> parseResearchEffects(Map<ResourceLocation, JsonElement> object)\n+    {\n+        final Map<String, ResearchEffectCategory> effectCategories = new HashMap<>();\n+        for(final Map.Entry<ResourceLocation, JsonElement> entry : object.entrySet())\n+        {\n+            JsonObject effectJson = entry.getValue().getAsJsonObject();\n+\n+            if (effectJson.has(RESEARCH_EFFECT_PROP) && effectJson.has(RESEARCH_ID_PROP)\n+                  && effectJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && effectJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString()\n+                  &&  effectJson.has(RESEARCH_EFFECT_TYPE_PROP) && effectJson.get(RESEARCH_EFFECT_TYPE_PROP).isJsonPrimitive()\n+                  && effectJson.get(RESEARCH_EFFECT_TYPE_PROP).getAsJsonPrimitive().isString())\n+            {\n+                final ResearchEffectCategory category;\n+                if((effectJson.has(RESEARCH_NAME_PROP) && effectJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && effectJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString()))\n+                {\n+                    category = new ResearchEffectCategory(effectJson.get(RESEARCH_ID_PROP).getAsString(), effectJson.get(RESEARCH_NAME_PROP).getAsString(), effectJson.get(RESEARCH_EFFECT_TYPE_PROP).getAsString());\n+                }\n+                else\n+                {\n+                    category = new ResearchEffectCategory(effectJson.get(RESEARCH_ID_PROP).getAsString(), effectJson.get(RESEARCH_EFFECT_TYPE_PROP).getAsString());\n+                }\n+                if (effectJson.has(RESEARCH_EFFECT_LEVELS_PROP) && effectJson.get(RESEARCH_EFFECT_LEVELS_PROP).isJsonArray())\n+                {\n+                    for(JsonElement levelElement : effectJson.get(RESEARCH_EFFECT_LEVELS_PROP).getAsJsonArray())\n+                    {\n+                        if(levelElement.isJsonPrimitive() && levelElement.getAsJsonPrimitive().isNumber())\n+                        {\n+                            category.add(levelElement.getAsNumber().floatValue());\n+                        }\n+                    }\n+                }\n+                // If no levels are defined, assume temporarily boolean, and store on/off.\n+                else\n+                {\n+                    category.add(1f);\n+                }\n+                effectCategories.put(category.getId(), category);\n+            }\n+        }\n+        return effectCategories;\n+    }\n+\n+    private Map<String, GlobalResearch> parseResearches(Map<ResourceLocation, JsonElement> object, Map<String, ResearchEffectCategory> effectCategories)\n+    {\n+        final Map<String, GlobalResearch> researchMap = new HashMap<String, GlobalResearch>();\n+        for(final Map.Entry<ResourceLocation, JsonElement> entry : object.entrySet())\n+        {\n+            //Note that we don't actually use the resource folders or file names; those are only for organization purposes.\n+            JsonObject researchJson = entry.getValue().getAsJsonObject();\n+\n+            //Can ignore those effect jsons now:\n+            if (researchJson.has(RESEARCH_EFFECT_PROP))\n+            {\n+                continue;\n+            }\n+\n+            //Check for absolute minimum required types, and log as warning if malformed.\n+            if (MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchDebugLog.get() &&\n+                  !(researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive()\n+                    && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+                  || !(researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive()\n+                         && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString()))\n+            {\n+                Log.getLogger().warn(entry.getKey() + \"missing required fields\");\n+                continue;\n+            }\n+\n+            //Missing university level data may not necessarily be a show-stopper, but it is worth warning about.\n+            if(MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchDebugLog.get() &&\n+                 (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isNumber()))\n+            {\n+                Log.getLogger().warn(entry.getKey() + \"has invalid or no university level requirements.\");\n+            }\n+\n+            //Next, check for remove-type recipes.  We don't want to accidentally add them just because they have too much detail.\n+            if ((researchJson.has(RESEARCH_REMOVE_PROP) && researchJson.get(RESEARCH_REMOVE_PROP).getAsJsonPrimitive().isBoolean())\n+                  && researchJson.get(RESEARCH_REMOVE_PROP).getAsJsonPrimitive().getAsBoolean())\n+            {\n+                continue;\n+            }\n+\n+            //Pretty much anything else should be allowed: it's plausible pack designers may want a research type without a cost or effect.\n+            //It's possible we could dynamically derive university levels from parents, but doing so as a rule will prevent research branches that start at T2 or deeper.\n+            final GlobalResearch research = new GlobalResearch(researchJson, entry.getKey(), effectCategories);\n+            if(MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchDebugLog.get())\n+            {\n+                Log.getLogger().info(\"Parsed research recipe from \" + entry.getKey() + \" [\" + research.getBranch() + \"/\" + research.getId() + \"]\");\n+                Log.getLogger().info(research.getDesc() + \" at \" + research.getDepth() + \"/\" + research.getParent());\n+                for(IResearchRequirement requirement : research.getResearchRequirement())\n+                {\n+                    Log.getLogger().info(\"Requirement: \" + requirement.getDesc());\n+                }\n+                for(ItemStorage itemS : research.getCostList())\n+                {\n+                    Log.getLogger().info(\"Cost: \" + itemS.toString());\n+                }\n+                for(IResearchEffect researchEffect : research.getEffects())\n+                {\n+                    Log.getLogger().info(\"Effect: \" + researchEffect.getId() + \" \" + researchEffect.getDesc());\n+                }\n+            }\n+            researchMap.put(research.getId(), research);\n+        }\n+        return researchMap;\n+    }\n+\n+    private void parseRemoveResearches(Map<ResourceLocation, JsonElement> object, Map<String, GlobalResearch> researchMap)\n+    {\n+        for(final Map.Entry<ResourceLocation, JsonElement> entry : object.entrySet())\n+        {\n+            JsonObject researchJson = entry.getValue().getAsJsonObject();\n+\n+            //not allowing duplicate id across separate branches for now, so we just need removes and Id.\n+            if ((researchJson.has(RESEARCH_REMOVE_PROP) && researchJson.get(RESEARCH_REMOVE_PROP).getAsJsonPrimitive().isBoolean())\n+                  && researchJson.get(RESEARCH_REMOVE_PROP).getAsJsonPrimitive().getAsBoolean()\n+                  && researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString()\n+                /*&& (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())*/)\n+            {\n+                if(researchMap.containsKey(researchJson.get(RESEARCH_ID_PROP).getAsString()))\n+                {\n+                    researchMap.remove(researchJson.get(RESEARCH_ID_PROP).getAsString());\n+                }\n+            }\n+        }\n+    }\n+\n+    private IGlobalResearchTree calcResearchTree(Map<String, GlobalResearch> researchMap)", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\nindex 82084cf914..e4975dd43d 100644\n--- a/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n+++ b/src/main/java/com/minecolonies/coremod/datalistener/ResearchListener.java\n\n@@ -2,9 +2,7 @@ package com.minecolonies.coremod.datalistener;\n \n import com.google.gson.*;\n import com.minecolonies.api.MinecoloniesAPIProxy;\n-import com.minecolonies.api.configuration.Configuration;\n import com.minecolonies.api.crafting.ItemStorage;\n-import com.minecolonies.api.research.IGlobalResearch;\n import com.minecolonies.api.research.IGlobalResearchTree;\n import com.minecolonies.api.research.IResearchRequirement;\n import com.minecolonies.api.research.effects.IResearchEffect;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ5NjkyNg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540496926", "bodyText": "javadoc", "author": "someaddons", "createdAt": "2020-12-10T21:07:16Z", "path": "src/main/java/com/minecolonies/coremod/research/GlobalResearch.java", "diffHunk": "@@ -262,8 +401,239 @@ public void setParent(final String id)\n     }\n \n     @Override\n-    public IResearchEffect<?> getEffect()\n+    public List<IResearchEffect<?>> getEffects()\n+    {\n+        return effects;\n+    }\n+\n+    /**\n+     * Parse a Json object into a new GlobalResearch.\n+     *\n+     * @param researchJson the json representing the recipe\n+     * @return new instance of ResearchRecipe\n+     */\n+    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    {\n+        this.resourceLocation = resourceLocation;\n+\n+        this.id = getResearchId(researchJson, resourceLocation);\n+        this.name = getResearchName(researchJson);\n+        this.branch = getBranch(researchJson, resourceLocation);\n+        this.depth = getUniversityLevel(researchJson);\n+        this.parent = getParent(researchJson);\n+        this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n+        this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n+        this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n+        this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+\n+        parseRequirements(researchJson);\n+        parseEffects(researchJson, effectCategories);\n+    }\n+\n+    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\nindex 482b1287e6..c96ded62f1 100755\n--- a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n+++ b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n\n@@ -395,97 +569,197 @@ public class GlobalResearch implements IGlobalResearch\n     }\n \n     @Override\n-    public ImmutableList<String> getChilds()\n+    public List<String> getChildren()\n     {\n-        return ImmutableList.copyOf(this.childs);\n+        return this.children;\n     }\n \n     @Override\n     public List<IResearchEffect<?>> getEffects()\n     {\n-        return effects;\n+        return this.effects;\n     }\n \n+    @Override\n+    public String getIcon() {return this.icon;}\n+\n     /**\n      * Parse a Json object into a new GlobalResearch.\n      *\n-     * @param researchJson the json representing the recipe\n-     * @return new instance of ResearchRecipe\n+     * @param researchJson      the json representing the recipe\n+     * @param resourceLocation  the json's location.\n+     * @param effectCategories  a map of effect categories, by id.\n+     * @param validateIcons     if icons need to be validated.  This can only be performed on the client, and should only need to be done once.\n      */\n-    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    public GlobalResearch(@NotNull final JsonObject researchJson, final ResourceLocation resourceLocation, final Map<String, ResearchEffectCategory> effectCategories, final boolean validateIcons)\n     {\n-        this.resourceLocation = resourceLocation;\n-\n-        this.id = getResearchId(researchJson, resourceLocation);\n-        this.name = getResearchName(researchJson);\n+        this.id = resourceLocation.toString();\n+        final String autogenKey = \"com.\" + this.id.split(\":\")[0] + \".research.\" + this.id.split(\":\")[1].replaceAll(\"[ /:]\",\".\");\n+        this.name = getStringSafe(researchJson, RESEARCH_NAME_PROP, autogenKey + \".name\");\n+        this.subtitle = getStringSafe(researchJson, RESEARCH_SUBTITLE_PROP, autogenKey + \".subtitle\");\n         this.branch = getBranch(researchJson, resourceLocation);\n+        if (validateIcons && MineColonies.proxy.isClient())\n+        {\n+            this.icon = validateIcons(getStringSafe(researchJson, RESEARCH_ICON_PROP,\"\"));\n+        }\n+        else\n+        {\n+            this.icon = getStringSafe(researchJson, RESEARCH_ICON_PROP, \"\");\n+        }\n         this.depth = getUniversityLevel(researchJson);\n-        this.parent = getParent(researchJson);\n+        this.sortOrder = getSortOrder(researchJson);\n+        this.parent = getStringSafe(researchJson, RESEARCH_PARENT_PROP, \"\");\n         this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n         this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n         this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n         this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+        this.immutable = getBooleanSafe(researchJson, RESEARCH_NO_RESET_PROP);\n \n         parseRequirements(researchJson);\n         parseEffects(researchJson, effectCategories);\n     }\n \n-    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the branch for a research from a JSON object, if it exists and is valid, or \"parseerrors\" otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the ID from.\n+     * @param resourceLocation    The {@link ResourceLocation} of the json being parsed.\n+     * @return                    The Research Branch as a String.\n+     */\n+    private String getBranch(final JsonObject researchJson, final ResourceLocation resourceLocation)\n     {\n-        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n         {\n-            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n-            return \"\";\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parseerrors\";\n         }\n     }\n \n-    private String getResearchName(JsonObject researchJson)\n+    /**\n+     * Gets the required university level from a JSON object, if it exists and is valid, or returns 1 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getUniversityLevel(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            return \"\";\n+            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n+            return 1;\n         }\n     }\n \n-    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the sort order JSON object, if it exists and is valid, or returns 0 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getSortOrder(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_SORT_PROP) && researchJson.get(RESEARCH_SORT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_SORT_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+            return researchJson.get(RESEARCH_SORT_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n-            return \"parserrors\";\n+            return 0;\n         }\n     }\n \n-    private int getUniversityLevel(JsonObject researchJson)\n+    /**\n+     * Gets the optional icon location from a research json, if present.  If not available, or if requests a file or block that does not exist, returns an empty string.\n+     * @param icon                The unvalidated string representing an icon's resource location or texture file location.\n+     * @return                    The string, or an empty string if the texture does not exist.\n+     */\n+    private String validateIcons(final String icon)\n     {\n-        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+        final String[] iconParts = icon.split(\":\");\n+        final String[] outputString = new String[3];\n+        // Do preliminary validation here, as later uses will always be in UI space.\n+        if (iconParts.length > 3)\n         {\n-            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n+            Log.getLogger().info(\"Malformed icon property for \" + this.branch + \"/\" + this.id + \".  Icons may contain at most namespace:identifier:count.\");\n+            return \"\";\n+        }\n+\n+        if (iconParts.length == 3)\n+        {\n+            try\n+            {\n+                Integer.parseInt(iconParts[2]);\n+                outputString[2] = iconParts[2];\n+            }\n+            catch (NumberFormatException parseError)\n+            {\n+                Log.getLogger().info(\"Non-integer count assigned to icon of \" + this.branch + \"/\" + this.id + \" : \" + parseError.getLocalizedMessage());\n+                outputString[2] = \"1\";\n+            }\n         }\n         else\n         {\n-            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n-            return 1;\n+            outputString[2] = \"1\";\n         }\n+\n+        if (iconParts.length == 1)\n+        {\n+            outputString[0] = \"minecraft\";\n+            outputString[1] = iconParts[0];\n+        }\n+        else\n+        {\n+            outputString[0] = iconParts[0];\n+            outputString[1] = iconParts[1];\n+        }\n+\n+        // If looking for a texture file, check if the file exists here, both to better assist debugging, and to avoid exceptions in GUI thread.\n+        // For non-texture-file missing values, Forge will automatically replace with minecraft:air.\n+        if (outputString[1].contains(\".\"))\n+        {\n+            try\n+            {\n+                Minecraft.getInstance().getResourceManager().getResource(new ResourceLocation(outputString[0], outputString[1]));\n+            }\n+            catch (IOException notFoundError)\n+            {\n+                Log.getLogger()\n+                  .info(\"Resource file for Minecraft:\" + iconParts[1] + \" not found for \" + this.branch + \"/\" + this.id + \" : \" + notFoundError.getLocalizedMessage());\n+                outputString[0] = \"minecraft\";\n+                outputString[1] = \"air\";\n+            }\n+        }\n+        return outputString[0] + \":\" + outputString[1] + \":\" + outputString[2];\n     }\n \n-    private String getParent(JsonObject researchJson)\n+    /**\n+     * Gets a string from a json safely, if present, a default string if present but malformed or empty, and returns an empty string otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the Name from.\n+     * @param propertyName        The name of the property to retrieve.\n+     * @param defaultRet          The fallback String if not present or if not valid.\n+     * @return                    The Research Name as a String.\n+     */\n+    private String getStringSafe(final JsonObject researchJson, final String propertyName, final String defaultRet)\n     {\n-        if (researchJson.has(RESEARCH_PARENT_PROP) && researchJson.get(RESEARCH_PARENT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_PARENT_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(propertyName))\n         {\n-            return researchJson.get(RESEARCH_PARENT_PROP).getAsString();\n+            if(researchJson.get(propertyName).isJsonPrimitive() && researchJson.get(propertyName).getAsJsonPrimitive().isString())\n+            {\n+                return researchJson.get(propertyName).getAsString();\n+            }\n+            else\n+            {\n+                return defaultRet;\n+            }\n         }\n         else\n         {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ5NzQxMw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540497413", "bodyText": "javadoc", "author": "someaddons", "createdAt": "2020-12-10T21:08:09Z", "path": "src/main/java/com/minecolonies/coremod/research/GlobalResearch.java", "diffHunk": "@@ -262,8 +401,239 @@ public void setParent(final String id)\n     }\n \n     @Override\n-    public IResearchEffect<?> getEffect()\n+    public List<IResearchEffect<?>> getEffects()\n+    {\n+        return effects;\n+    }\n+\n+    /**\n+     * Parse a Json object into a new GlobalResearch.\n+     *\n+     * @param researchJson the json representing the recipe\n+     * @return new instance of ResearchRecipe\n+     */\n+    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    {\n+        this.resourceLocation = resourceLocation;\n+\n+        this.id = getResearchId(researchJson, resourceLocation);\n+        this.name = getResearchName(researchJson);\n+        this.branch = getBranch(researchJson, resourceLocation);\n+        this.depth = getUniversityLevel(researchJson);\n+        this.parent = getParent(researchJson);\n+        this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n+        this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n+        this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n+        this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+\n+        parseRequirements(researchJson);\n+        parseEffects(researchJson, effectCategories);\n+    }\n+\n+    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n+            return \"\";\n+        }\n+    }\n+\n+    private String getResearchName(JsonObject researchJson)", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\nindex 482b1287e6..c96ded62f1 100755\n--- a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n+++ b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n\n@@ -395,97 +569,197 @@ public class GlobalResearch implements IGlobalResearch\n     }\n \n     @Override\n-    public ImmutableList<String> getChilds()\n+    public List<String> getChildren()\n     {\n-        return ImmutableList.copyOf(this.childs);\n+        return this.children;\n     }\n \n     @Override\n     public List<IResearchEffect<?>> getEffects()\n     {\n-        return effects;\n+        return this.effects;\n     }\n \n+    @Override\n+    public String getIcon() {return this.icon;}\n+\n     /**\n      * Parse a Json object into a new GlobalResearch.\n      *\n-     * @param researchJson the json representing the recipe\n-     * @return new instance of ResearchRecipe\n+     * @param researchJson      the json representing the recipe\n+     * @param resourceLocation  the json's location.\n+     * @param effectCategories  a map of effect categories, by id.\n+     * @param validateIcons     if icons need to be validated.  This can only be performed on the client, and should only need to be done once.\n      */\n-    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    public GlobalResearch(@NotNull final JsonObject researchJson, final ResourceLocation resourceLocation, final Map<String, ResearchEffectCategory> effectCategories, final boolean validateIcons)\n     {\n-        this.resourceLocation = resourceLocation;\n-\n-        this.id = getResearchId(researchJson, resourceLocation);\n-        this.name = getResearchName(researchJson);\n+        this.id = resourceLocation.toString();\n+        final String autogenKey = \"com.\" + this.id.split(\":\")[0] + \".research.\" + this.id.split(\":\")[1].replaceAll(\"[ /:]\",\".\");\n+        this.name = getStringSafe(researchJson, RESEARCH_NAME_PROP, autogenKey + \".name\");\n+        this.subtitle = getStringSafe(researchJson, RESEARCH_SUBTITLE_PROP, autogenKey + \".subtitle\");\n         this.branch = getBranch(researchJson, resourceLocation);\n+        if (validateIcons && MineColonies.proxy.isClient())\n+        {\n+            this.icon = validateIcons(getStringSafe(researchJson, RESEARCH_ICON_PROP,\"\"));\n+        }\n+        else\n+        {\n+            this.icon = getStringSafe(researchJson, RESEARCH_ICON_PROP, \"\");\n+        }\n         this.depth = getUniversityLevel(researchJson);\n-        this.parent = getParent(researchJson);\n+        this.sortOrder = getSortOrder(researchJson);\n+        this.parent = getStringSafe(researchJson, RESEARCH_PARENT_PROP, \"\");\n         this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n         this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n         this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n         this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+        this.immutable = getBooleanSafe(researchJson, RESEARCH_NO_RESET_PROP);\n \n         parseRequirements(researchJson);\n         parseEffects(researchJson, effectCategories);\n     }\n \n-    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the branch for a research from a JSON object, if it exists and is valid, or \"parseerrors\" otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the ID from.\n+     * @param resourceLocation    The {@link ResourceLocation} of the json being parsed.\n+     * @return                    The Research Branch as a String.\n+     */\n+    private String getBranch(final JsonObject researchJson, final ResourceLocation resourceLocation)\n     {\n-        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n         {\n-            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n-            return \"\";\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parseerrors\";\n         }\n     }\n \n-    private String getResearchName(JsonObject researchJson)\n+    /**\n+     * Gets the required university level from a JSON object, if it exists and is valid, or returns 1 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getUniversityLevel(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            return \"\";\n+            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n+            return 1;\n         }\n     }\n \n-    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the sort order JSON object, if it exists and is valid, or returns 0 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getSortOrder(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_SORT_PROP) && researchJson.get(RESEARCH_SORT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_SORT_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+            return researchJson.get(RESEARCH_SORT_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n-            return \"parserrors\";\n+            return 0;\n         }\n     }\n \n-    private int getUniversityLevel(JsonObject researchJson)\n+    /**\n+     * Gets the optional icon location from a research json, if present.  If not available, or if requests a file or block that does not exist, returns an empty string.\n+     * @param icon                The unvalidated string representing an icon's resource location or texture file location.\n+     * @return                    The string, or an empty string if the texture does not exist.\n+     */\n+    private String validateIcons(final String icon)\n     {\n-        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+        final String[] iconParts = icon.split(\":\");\n+        final String[] outputString = new String[3];\n+        // Do preliminary validation here, as later uses will always be in UI space.\n+        if (iconParts.length > 3)\n         {\n-            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n+            Log.getLogger().info(\"Malformed icon property for \" + this.branch + \"/\" + this.id + \".  Icons may contain at most namespace:identifier:count.\");\n+            return \"\";\n+        }\n+\n+        if (iconParts.length == 3)\n+        {\n+            try\n+            {\n+                Integer.parseInt(iconParts[2]);\n+                outputString[2] = iconParts[2];\n+            }\n+            catch (NumberFormatException parseError)\n+            {\n+                Log.getLogger().info(\"Non-integer count assigned to icon of \" + this.branch + \"/\" + this.id + \" : \" + parseError.getLocalizedMessage());\n+                outputString[2] = \"1\";\n+            }\n         }\n         else\n         {\n-            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n-            return 1;\n+            outputString[2] = \"1\";\n         }\n+\n+        if (iconParts.length == 1)\n+        {\n+            outputString[0] = \"minecraft\";\n+            outputString[1] = iconParts[0];\n+        }\n+        else\n+        {\n+            outputString[0] = iconParts[0];\n+            outputString[1] = iconParts[1];\n+        }\n+\n+        // If looking for a texture file, check if the file exists here, both to better assist debugging, and to avoid exceptions in GUI thread.\n+        // For non-texture-file missing values, Forge will automatically replace with minecraft:air.\n+        if (outputString[1].contains(\".\"))\n+        {\n+            try\n+            {\n+                Minecraft.getInstance().getResourceManager().getResource(new ResourceLocation(outputString[0], outputString[1]));\n+            }\n+            catch (IOException notFoundError)\n+            {\n+                Log.getLogger()\n+                  .info(\"Resource file for Minecraft:\" + iconParts[1] + \" not found for \" + this.branch + \"/\" + this.id + \" : \" + notFoundError.getLocalizedMessage());\n+                outputString[0] = \"minecraft\";\n+                outputString[1] = \"air\";\n+            }\n+        }\n+        return outputString[0] + \":\" + outputString[1] + \":\" + outputString[2];\n     }\n \n-    private String getParent(JsonObject researchJson)\n+    /**\n+     * Gets a string from a json safely, if present, a default string if present but malformed or empty, and returns an empty string otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the Name from.\n+     * @param propertyName        The name of the property to retrieve.\n+     * @param defaultRet          The fallback String if not present or if not valid.\n+     * @return                    The Research Name as a String.\n+     */\n+    private String getStringSafe(final JsonObject researchJson, final String propertyName, final String defaultRet)\n     {\n-        if (researchJson.has(RESEARCH_PARENT_PROP) && researchJson.get(RESEARCH_PARENT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_PARENT_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(propertyName))\n         {\n-            return researchJson.get(RESEARCH_PARENT_PROP).getAsString();\n+            if(researchJson.get(propertyName).isJsonPrimitive() && researchJson.get(propertyName).getAsJsonPrimitive().isString())\n+            {\n+                return researchJson.get(propertyName).getAsString();\n+            }\n+            else\n+            {\n+                return defaultRet;\n+            }\n         }\n         else\n         {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ5NzUxNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540497515", "bodyText": "javadoc", "author": "someaddons", "createdAt": "2020-12-10T21:08:20Z", "path": "src/main/java/com/minecolonies/coremod/research/GlobalResearch.java", "diffHunk": "@@ -262,8 +401,239 @@ public void setParent(final String id)\n     }\n \n     @Override\n-    public IResearchEffect<?> getEffect()\n+    public List<IResearchEffect<?>> getEffects()\n+    {\n+        return effects;\n+    }\n+\n+    /**\n+     * Parse a Json object into a new GlobalResearch.\n+     *\n+     * @param researchJson the json representing the recipe\n+     * @return new instance of ResearchRecipe\n+     */\n+    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    {\n+        this.resourceLocation = resourceLocation;\n+\n+        this.id = getResearchId(researchJson, resourceLocation);\n+        this.name = getResearchName(researchJson);\n+        this.branch = getBranch(researchJson, resourceLocation);\n+        this.depth = getUniversityLevel(researchJson);\n+        this.parent = getParent(researchJson);\n+        this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n+        this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n+        this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n+        this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+\n+        parseRequirements(researchJson);\n+        parseEffects(researchJson, effectCategories);\n+    }\n+\n+    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n+            return \"\";\n+        }\n+    }\n+\n+    private String getResearchName(JsonObject researchJson)\n     {\n-        return effect;\n+        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+\n+    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\nindex 482b1287e6..c96ded62f1 100755\n--- a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n+++ b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n\n@@ -395,97 +569,197 @@ public class GlobalResearch implements IGlobalResearch\n     }\n \n     @Override\n-    public ImmutableList<String> getChilds()\n+    public List<String> getChildren()\n     {\n-        return ImmutableList.copyOf(this.childs);\n+        return this.children;\n     }\n \n     @Override\n     public List<IResearchEffect<?>> getEffects()\n     {\n-        return effects;\n+        return this.effects;\n     }\n \n+    @Override\n+    public String getIcon() {return this.icon;}\n+\n     /**\n      * Parse a Json object into a new GlobalResearch.\n      *\n-     * @param researchJson the json representing the recipe\n-     * @return new instance of ResearchRecipe\n+     * @param researchJson      the json representing the recipe\n+     * @param resourceLocation  the json's location.\n+     * @param effectCategories  a map of effect categories, by id.\n+     * @param validateIcons     if icons need to be validated.  This can only be performed on the client, and should only need to be done once.\n      */\n-    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    public GlobalResearch(@NotNull final JsonObject researchJson, final ResourceLocation resourceLocation, final Map<String, ResearchEffectCategory> effectCategories, final boolean validateIcons)\n     {\n-        this.resourceLocation = resourceLocation;\n-\n-        this.id = getResearchId(researchJson, resourceLocation);\n-        this.name = getResearchName(researchJson);\n+        this.id = resourceLocation.toString();\n+        final String autogenKey = \"com.\" + this.id.split(\":\")[0] + \".research.\" + this.id.split(\":\")[1].replaceAll(\"[ /:]\",\".\");\n+        this.name = getStringSafe(researchJson, RESEARCH_NAME_PROP, autogenKey + \".name\");\n+        this.subtitle = getStringSafe(researchJson, RESEARCH_SUBTITLE_PROP, autogenKey + \".subtitle\");\n         this.branch = getBranch(researchJson, resourceLocation);\n+        if (validateIcons && MineColonies.proxy.isClient())\n+        {\n+            this.icon = validateIcons(getStringSafe(researchJson, RESEARCH_ICON_PROP,\"\"));\n+        }\n+        else\n+        {\n+            this.icon = getStringSafe(researchJson, RESEARCH_ICON_PROP, \"\");\n+        }\n         this.depth = getUniversityLevel(researchJson);\n-        this.parent = getParent(researchJson);\n+        this.sortOrder = getSortOrder(researchJson);\n+        this.parent = getStringSafe(researchJson, RESEARCH_PARENT_PROP, \"\");\n         this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n         this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n         this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n         this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+        this.immutable = getBooleanSafe(researchJson, RESEARCH_NO_RESET_PROP);\n \n         parseRequirements(researchJson);\n         parseEffects(researchJson, effectCategories);\n     }\n \n-    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the branch for a research from a JSON object, if it exists and is valid, or \"parseerrors\" otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the ID from.\n+     * @param resourceLocation    The {@link ResourceLocation} of the json being parsed.\n+     * @return                    The Research Branch as a String.\n+     */\n+    private String getBranch(final JsonObject researchJson, final ResourceLocation resourceLocation)\n     {\n-        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n         {\n-            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n-            return \"\";\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parseerrors\";\n         }\n     }\n \n-    private String getResearchName(JsonObject researchJson)\n+    /**\n+     * Gets the required university level from a JSON object, if it exists and is valid, or returns 1 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getUniversityLevel(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            return \"\";\n+            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n+            return 1;\n         }\n     }\n \n-    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the sort order JSON object, if it exists and is valid, or returns 0 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getSortOrder(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_SORT_PROP) && researchJson.get(RESEARCH_SORT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_SORT_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+            return researchJson.get(RESEARCH_SORT_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n-            return \"parserrors\";\n+            return 0;\n         }\n     }\n \n-    private int getUniversityLevel(JsonObject researchJson)\n+    /**\n+     * Gets the optional icon location from a research json, if present.  If not available, or if requests a file or block that does not exist, returns an empty string.\n+     * @param icon                The unvalidated string representing an icon's resource location or texture file location.\n+     * @return                    The string, or an empty string if the texture does not exist.\n+     */\n+    private String validateIcons(final String icon)\n     {\n-        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+        final String[] iconParts = icon.split(\":\");\n+        final String[] outputString = new String[3];\n+        // Do preliminary validation here, as later uses will always be in UI space.\n+        if (iconParts.length > 3)\n         {\n-            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n+            Log.getLogger().info(\"Malformed icon property for \" + this.branch + \"/\" + this.id + \".  Icons may contain at most namespace:identifier:count.\");\n+            return \"\";\n+        }\n+\n+        if (iconParts.length == 3)\n+        {\n+            try\n+            {\n+                Integer.parseInt(iconParts[2]);\n+                outputString[2] = iconParts[2];\n+            }\n+            catch (NumberFormatException parseError)\n+            {\n+                Log.getLogger().info(\"Non-integer count assigned to icon of \" + this.branch + \"/\" + this.id + \" : \" + parseError.getLocalizedMessage());\n+                outputString[2] = \"1\";\n+            }\n         }\n         else\n         {\n-            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n-            return 1;\n+            outputString[2] = \"1\";\n         }\n+\n+        if (iconParts.length == 1)\n+        {\n+            outputString[0] = \"minecraft\";\n+            outputString[1] = iconParts[0];\n+        }\n+        else\n+        {\n+            outputString[0] = iconParts[0];\n+            outputString[1] = iconParts[1];\n+        }\n+\n+        // If looking for a texture file, check if the file exists here, both to better assist debugging, and to avoid exceptions in GUI thread.\n+        // For non-texture-file missing values, Forge will automatically replace with minecraft:air.\n+        if (outputString[1].contains(\".\"))\n+        {\n+            try\n+            {\n+                Minecraft.getInstance().getResourceManager().getResource(new ResourceLocation(outputString[0], outputString[1]));\n+            }\n+            catch (IOException notFoundError)\n+            {\n+                Log.getLogger()\n+                  .info(\"Resource file for Minecraft:\" + iconParts[1] + \" not found for \" + this.branch + \"/\" + this.id + \" : \" + notFoundError.getLocalizedMessage());\n+                outputString[0] = \"minecraft\";\n+                outputString[1] = \"air\";\n+            }\n+        }\n+        return outputString[0] + \":\" + outputString[1] + \":\" + outputString[2];\n     }\n \n-    private String getParent(JsonObject researchJson)\n+    /**\n+     * Gets a string from a json safely, if present, a default string if present but malformed or empty, and returns an empty string otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the Name from.\n+     * @param propertyName        The name of the property to retrieve.\n+     * @param defaultRet          The fallback String if not present or if not valid.\n+     * @return                    The Research Name as a String.\n+     */\n+    private String getStringSafe(final JsonObject researchJson, final String propertyName, final String defaultRet)\n     {\n-        if (researchJson.has(RESEARCH_PARENT_PROP) && researchJson.get(RESEARCH_PARENT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_PARENT_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(propertyName))\n         {\n-            return researchJson.get(RESEARCH_PARENT_PROP).getAsString();\n+            if(researchJson.get(propertyName).isJsonPrimitive() && researchJson.get(propertyName).getAsJsonPrimitive().isString())\n+            {\n+                return researchJson.get(propertyName).getAsString();\n+            }\n+            else\n+            {\n+                return defaultRet;\n+            }\n         }\n         else\n         {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ5NzY1MQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540497651", "bodyText": "javadoc", "author": "someaddons", "createdAt": "2020-12-10T21:08:35Z", "path": "src/main/java/com/minecolonies/coremod/research/GlobalResearch.java", "diffHunk": "@@ -262,8 +401,239 @@ public void setParent(final String id)\n     }\n \n     @Override\n-    public IResearchEffect<?> getEffect()\n+    public List<IResearchEffect<?>> getEffects()\n+    {\n+        return effects;\n+    }\n+\n+    /**\n+     * Parse a Json object into a new GlobalResearch.\n+     *\n+     * @param researchJson the json representing the recipe\n+     * @return new instance of ResearchRecipe\n+     */\n+    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    {\n+        this.resourceLocation = resourceLocation;\n+\n+        this.id = getResearchId(researchJson, resourceLocation);\n+        this.name = getResearchName(researchJson);\n+        this.branch = getBranch(researchJson, resourceLocation);\n+        this.depth = getUniversityLevel(researchJson);\n+        this.parent = getParent(researchJson);\n+        this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n+        this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n+        this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n+        this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+\n+        parseRequirements(researchJson);\n+        parseEffects(researchJson, effectCategories);\n+    }\n+\n+    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n+            return \"\";\n+        }\n+    }\n+\n+    private String getResearchName(JsonObject researchJson)\n     {\n-        return effect;\n+        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+\n+    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parserrors\";\n+        }\n+    }\n+\n+    private int getUniversityLevel(JsonObject researchJson)", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\nindex 482b1287e6..c96ded62f1 100755\n--- a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n+++ b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n\n@@ -395,97 +569,197 @@ public class GlobalResearch implements IGlobalResearch\n     }\n \n     @Override\n-    public ImmutableList<String> getChilds()\n+    public List<String> getChildren()\n     {\n-        return ImmutableList.copyOf(this.childs);\n+        return this.children;\n     }\n \n     @Override\n     public List<IResearchEffect<?>> getEffects()\n     {\n-        return effects;\n+        return this.effects;\n     }\n \n+    @Override\n+    public String getIcon() {return this.icon;}\n+\n     /**\n      * Parse a Json object into a new GlobalResearch.\n      *\n-     * @param researchJson the json representing the recipe\n-     * @return new instance of ResearchRecipe\n+     * @param researchJson      the json representing the recipe\n+     * @param resourceLocation  the json's location.\n+     * @param effectCategories  a map of effect categories, by id.\n+     * @param validateIcons     if icons need to be validated.  This can only be performed on the client, and should only need to be done once.\n      */\n-    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    public GlobalResearch(@NotNull final JsonObject researchJson, final ResourceLocation resourceLocation, final Map<String, ResearchEffectCategory> effectCategories, final boolean validateIcons)\n     {\n-        this.resourceLocation = resourceLocation;\n-\n-        this.id = getResearchId(researchJson, resourceLocation);\n-        this.name = getResearchName(researchJson);\n+        this.id = resourceLocation.toString();\n+        final String autogenKey = \"com.\" + this.id.split(\":\")[0] + \".research.\" + this.id.split(\":\")[1].replaceAll(\"[ /:]\",\".\");\n+        this.name = getStringSafe(researchJson, RESEARCH_NAME_PROP, autogenKey + \".name\");\n+        this.subtitle = getStringSafe(researchJson, RESEARCH_SUBTITLE_PROP, autogenKey + \".subtitle\");\n         this.branch = getBranch(researchJson, resourceLocation);\n+        if (validateIcons && MineColonies.proxy.isClient())\n+        {\n+            this.icon = validateIcons(getStringSafe(researchJson, RESEARCH_ICON_PROP,\"\"));\n+        }\n+        else\n+        {\n+            this.icon = getStringSafe(researchJson, RESEARCH_ICON_PROP, \"\");\n+        }\n         this.depth = getUniversityLevel(researchJson);\n-        this.parent = getParent(researchJson);\n+        this.sortOrder = getSortOrder(researchJson);\n+        this.parent = getStringSafe(researchJson, RESEARCH_PARENT_PROP, \"\");\n         this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n         this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n         this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n         this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+        this.immutable = getBooleanSafe(researchJson, RESEARCH_NO_RESET_PROP);\n \n         parseRequirements(researchJson);\n         parseEffects(researchJson, effectCategories);\n     }\n \n-    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the branch for a research from a JSON object, if it exists and is valid, or \"parseerrors\" otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the ID from.\n+     * @param resourceLocation    The {@link ResourceLocation} of the json being parsed.\n+     * @return                    The Research Branch as a String.\n+     */\n+    private String getBranch(final JsonObject researchJson, final ResourceLocation resourceLocation)\n     {\n-        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n         {\n-            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n-            return \"\";\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parseerrors\";\n         }\n     }\n \n-    private String getResearchName(JsonObject researchJson)\n+    /**\n+     * Gets the required university level from a JSON object, if it exists and is valid, or returns 1 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getUniversityLevel(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            return \"\";\n+            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n+            return 1;\n         }\n     }\n \n-    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the sort order JSON object, if it exists and is valid, or returns 0 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getSortOrder(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_SORT_PROP) && researchJson.get(RESEARCH_SORT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_SORT_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+            return researchJson.get(RESEARCH_SORT_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n-            return \"parserrors\";\n+            return 0;\n         }\n     }\n \n-    private int getUniversityLevel(JsonObject researchJson)\n+    /**\n+     * Gets the optional icon location from a research json, if present.  If not available, or if requests a file or block that does not exist, returns an empty string.\n+     * @param icon                The unvalidated string representing an icon's resource location or texture file location.\n+     * @return                    The string, or an empty string if the texture does not exist.\n+     */\n+    private String validateIcons(final String icon)\n     {\n-        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+        final String[] iconParts = icon.split(\":\");\n+        final String[] outputString = new String[3];\n+        // Do preliminary validation here, as later uses will always be in UI space.\n+        if (iconParts.length > 3)\n         {\n-            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n+            Log.getLogger().info(\"Malformed icon property for \" + this.branch + \"/\" + this.id + \".  Icons may contain at most namespace:identifier:count.\");\n+            return \"\";\n+        }\n+\n+        if (iconParts.length == 3)\n+        {\n+            try\n+            {\n+                Integer.parseInt(iconParts[2]);\n+                outputString[2] = iconParts[2];\n+            }\n+            catch (NumberFormatException parseError)\n+            {\n+                Log.getLogger().info(\"Non-integer count assigned to icon of \" + this.branch + \"/\" + this.id + \" : \" + parseError.getLocalizedMessage());\n+                outputString[2] = \"1\";\n+            }\n         }\n         else\n         {\n-            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n-            return 1;\n+            outputString[2] = \"1\";\n         }\n+\n+        if (iconParts.length == 1)\n+        {\n+            outputString[0] = \"minecraft\";\n+            outputString[1] = iconParts[0];\n+        }\n+        else\n+        {\n+            outputString[0] = iconParts[0];\n+            outputString[1] = iconParts[1];\n+        }\n+\n+        // If looking for a texture file, check if the file exists here, both to better assist debugging, and to avoid exceptions in GUI thread.\n+        // For non-texture-file missing values, Forge will automatically replace with minecraft:air.\n+        if (outputString[1].contains(\".\"))\n+        {\n+            try\n+            {\n+                Minecraft.getInstance().getResourceManager().getResource(new ResourceLocation(outputString[0], outputString[1]));\n+            }\n+            catch (IOException notFoundError)\n+            {\n+                Log.getLogger()\n+                  .info(\"Resource file for Minecraft:\" + iconParts[1] + \" not found for \" + this.branch + \"/\" + this.id + \" : \" + notFoundError.getLocalizedMessage());\n+                outputString[0] = \"minecraft\";\n+                outputString[1] = \"air\";\n+            }\n+        }\n+        return outputString[0] + \":\" + outputString[1] + \":\" + outputString[2];\n     }\n \n-    private String getParent(JsonObject researchJson)\n+    /**\n+     * Gets a string from a json safely, if present, a default string if present but malformed or empty, and returns an empty string otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the Name from.\n+     * @param propertyName        The name of the property to retrieve.\n+     * @param defaultRet          The fallback String if not present or if not valid.\n+     * @return                    The Research Name as a String.\n+     */\n+    private String getStringSafe(final JsonObject researchJson, final String propertyName, final String defaultRet)\n     {\n-        if (researchJson.has(RESEARCH_PARENT_PROP) && researchJson.get(RESEARCH_PARENT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_PARENT_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(propertyName))\n         {\n-            return researchJson.get(RESEARCH_PARENT_PROP).getAsString();\n+            if(researchJson.get(propertyName).isJsonPrimitive() && researchJson.get(propertyName).getAsJsonPrimitive().isString())\n+            {\n+                return researchJson.get(propertyName).getAsString();\n+            }\n+            else\n+            {\n+                return defaultRet;\n+            }\n         }\n         else\n         {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ5Nzc0NQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540497745", "bodyText": "javadoc", "author": "someaddons", "createdAt": "2020-12-10T21:08:43Z", "path": "src/main/java/com/minecolonies/coremod/research/GlobalResearch.java", "diffHunk": "@@ -262,8 +401,239 @@ public void setParent(final String id)\n     }\n \n     @Override\n-    public IResearchEffect<?> getEffect()\n+    public List<IResearchEffect<?>> getEffects()\n+    {\n+        return effects;\n+    }\n+\n+    /**\n+     * Parse a Json object into a new GlobalResearch.\n+     *\n+     * @param researchJson the json representing the recipe\n+     * @return new instance of ResearchRecipe\n+     */\n+    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    {\n+        this.resourceLocation = resourceLocation;\n+\n+        this.id = getResearchId(researchJson, resourceLocation);\n+        this.name = getResearchName(researchJson);\n+        this.branch = getBranch(researchJson, resourceLocation);\n+        this.depth = getUniversityLevel(researchJson);\n+        this.parent = getParent(researchJson);\n+        this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n+        this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n+        this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n+        this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+\n+        parseRequirements(researchJson);\n+        parseEffects(researchJson, effectCategories);\n+    }\n+\n+    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n+            return \"\";\n+        }\n+    }\n+\n+    private String getResearchName(JsonObject researchJson)\n     {\n-        return effect;\n+        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+\n+    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parserrors\";\n+        }\n+    }\n+\n+    private int getUniversityLevel(JsonObject researchJson)\n+    {\n+        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+        {\n+            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n+        }\n+        else\n+        {\n+            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n+            return 1;\n+        }\n+    }\n+\n+    private String getParent(JsonObject researchJson)", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\nindex 482b1287e6..c96ded62f1 100755\n--- a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n+++ b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n\n@@ -395,97 +569,197 @@ public class GlobalResearch implements IGlobalResearch\n     }\n \n     @Override\n-    public ImmutableList<String> getChilds()\n+    public List<String> getChildren()\n     {\n-        return ImmutableList.copyOf(this.childs);\n+        return this.children;\n     }\n \n     @Override\n     public List<IResearchEffect<?>> getEffects()\n     {\n-        return effects;\n+        return this.effects;\n     }\n \n+    @Override\n+    public String getIcon() {return this.icon;}\n+\n     /**\n      * Parse a Json object into a new GlobalResearch.\n      *\n-     * @param researchJson the json representing the recipe\n-     * @return new instance of ResearchRecipe\n+     * @param researchJson      the json representing the recipe\n+     * @param resourceLocation  the json's location.\n+     * @param effectCategories  a map of effect categories, by id.\n+     * @param validateIcons     if icons need to be validated.  This can only be performed on the client, and should only need to be done once.\n      */\n-    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    public GlobalResearch(@NotNull final JsonObject researchJson, final ResourceLocation resourceLocation, final Map<String, ResearchEffectCategory> effectCategories, final boolean validateIcons)\n     {\n-        this.resourceLocation = resourceLocation;\n-\n-        this.id = getResearchId(researchJson, resourceLocation);\n-        this.name = getResearchName(researchJson);\n+        this.id = resourceLocation.toString();\n+        final String autogenKey = \"com.\" + this.id.split(\":\")[0] + \".research.\" + this.id.split(\":\")[1].replaceAll(\"[ /:]\",\".\");\n+        this.name = getStringSafe(researchJson, RESEARCH_NAME_PROP, autogenKey + \".name\");\n+        this.subtitle = getStringSafe(researchJson, RESEARCH_SUBTITLE_PROP, autogenKey + \".subtitle\");\n         this.branch = getBranch(researchJson, resourceLocation);\n+        if (validateIcons && MineColonies.proxy.isClient())\n+        {\n+            this.icon = validateIcons(getStringSafe(researchJson, RESEARCH_ICON_PROP,\"\"));\n+        }\n+        else\n+        {\n+            this.icon = getStringSafe(researchJson, RESEARCH_ICON_PROP, \"\");\n+        }\n         this.depth = getUniversityLevel(researchJson);\n-        this.parent = getParent(researchJson);\n+        this.sortOrder = getSortOrder(researchJson);\n+        this.parent = getStringSafe(researchJson, RESEARCH_PARENT_PROP, \"\");\n         this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n         this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n         this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n         this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+        this.immutable = getBooleanSafe(researchJson, RESEARCH_NO_RESET_PROP);\n \n         parseRequirements(researchJson);\n         parseEffects(researchJson, effectCategories);\n     }\n \n-    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the branch for a research from a JSON object, if it exists and is valid, or \"parseerrors\" otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the ID from.\n+     * @param resourceLocation    The {@link ResourceLocation} of the json being parsed.\n+     * @return                    The Research Branch as a String.\n+     */\n+    private String getBranch(final JsonObject researchJson, final ResourceLocation resourceLocation)\n     {\n-        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n         {\n-            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n-            return \"\";\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parseerrors\";\n         }\n     }\n \n-    private String getResearchName(JsonObject researchJson)\n+    /**\n+     * Gets the required university level from a JSON object, if it exists and is valid, or returns 1 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getUniversityLevel(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            return \"\";\n+            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n+            return 1;\n         }\n     }\n \n-    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the sort order JSON object, if it exists and is valid, or returns 0 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getSortOrder(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_SORT_PROP) && researchJson.get(RESEARCH_SORT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_SORT_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+            return researchJson.get(RESEARCH_SORT_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n-            return \"parserrors\";\n+            return 0;\n         }\n     }\n \n-    private int getUniversityLevel(JsonObject researchJson)\n+    /**\n+     * Gets the optional icon location from a research json, if present.  If not available, or if requests a file or block that does not exist, returns an empty string.\n+     * @param icon                The unvalidated string representing an icon's resource location or texture file location.\n+     * @return                    The string, or an empty string if the texture does not exist.\n+     */\n+    private String validateIcons(final String icon)\n     {\n-        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+        final String[] iconParts = icon.split(\":\");\n+        final String[] outputString = new String[3];\n+        // Do preliminary validation here, as later uses will always be in UI space.\n+        if (iconParts.length > 3)\n         {\n-            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n+            Log.getLogger().info(\"Malformed icon property for \" + this.branch + \"/\" + this.id + \".  Icons may contain at most namespace:identifier:count.\");\n+            return \"\";\n+        }\n+\n+        if (iconParts.length == 3)\n+        {\n+            try\n+            {\n+                Integer.parseInt(iconParts[2]);\n+                outputString[2] = iconParts[2];\n+            }\n+            catch (NumberFormatException parseError)\n+            {\n+                Log.getLogger().info(\"Non-integer count assigned to icon of \" + this.branch + \"/\" + this.id + \" : \" + parseError.getLocalizedMessage());\n+                outputString[2] = \"1\";\n+            }\n         }\n         else\n         {\n-            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n-            return 1;\n+            outputString[2] = \"1\";\n         }\n+\n+        if (iconParts.length == 1)\n+        {\n+            outputString[0] = \"minecraft\";\n+            outputString[1] = iconParts[0];\n+        }\n+        else\n+        {\n+            outputString[0] = iconParts[0];\n+            outputString[1] = iconParts[1];\n+        }\n+\n+        // If looking for a texture file, check if the file exists here, both to better assist debugging, and to avoid exceptions in GUI thread.\n+        // For non-texture-file missing values, Forge will automatically replace with minecraft:air.\n+        if (outputString[1].contains(\".\"))\n+        {\n+            try\n+            {\n+                Minecraft.getInstance().getResourceManager().getResource(new ResourceLocation(outputString[0], outputString[1]));\n+            }\n+            catch (IOException notFoundError)\n+            {\n+                Log.getLogger()\n+                  .info(\"Resource file for Minecraft:\" + iconParts[1] + \" not found for \" + this.branch + \"/\" + this.id + \" : \" + notFoundError.getLocalizedMessage());\n+                outputString[0] = \"minecraft\";\n+                outputString[1] = \"air\";\n+            }\n+        }\n+        return outputString[0] + \":\" + outputString[1] + \":\" + outputString[2];\n     }\n \n-    private String getParent(JsonObject researchJson)\n+    /**\n+     * Gets a string from a json safely, if present, a default string if present but malformed or empty, and returns an empty string otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the Name from.\n+     * @param propertyName        The name of the property to retrieve.\n+     * @param defaultRet          The fallback String if not present or if not valid.\n+     * @return                    The Research Name as a String.\n+     */\n+    private String getStringSafe(final JsonObject researchJson, final String propertyName, final String defaultRet)\n     {\n-        if (researchJson.has(RESEARCH_PARENT_PROP) && researchJson.get(RESEARCH_PARENT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_PARENT_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(propertyName))\n         {\n-            return researchJson.get(RESEARCH_PARENT_PROP).getAsString();\n+            if(researchJson.get(propertyName).isJsonPrimitive() && researchJson.get(propertyName).getAsJsonPrimitive().isString())\n+            {\n+                return researchJson.get(propertyName).getAsString();\n+            }\n+            else\n+            {\n+                return defaultRet;\n+            }\n         }\n         else\n         {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ5Nzg2MA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540497860", "bodyText": "javadoc", "author": "someaddons", "createdAt": "2020-12-10T21:08:55Z", "path": "src/main/java/com/minecolonies/coremod/research/GlobalResearch.java", "diffHunk": "@@ -262,8 +401,239 @@ public void setParent(final String id)\n     }\n \n     @Override\n-    public IResearchEffect<?> getEffect()\n+    public List<IResearchEffect<?>> getEffects()\n+    {\n+        return effects;\n+    }\n+\n+    /**\n+     * Parse a Json object into a new GlobalResearch.\n+     *\n+     * @param researchJson the json representing the recipe\n+     * @return new instance of ResearchRecipe\n+     */\n+    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    {\n+        this.resourceLocation = resourceLocation;\n+\n+        this.id = getResearchId(researchJson, resourceLocation);\n+        this.name = getResearchName(researchJson);\n+        this.branch = getBranch(researchJson, resourceLocation);\n+        this.depth = getUniversityLevel(researchJson);\n+        this.parent = getParent(researchJson);\n+        this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n+        this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n+        this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n+        this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+\n+        parseRequirements(researchJson);\n+        parseEffects(researchJson, effectCategories);\n+    }\n+\n+    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n+            return \"\";\n+        }\n+    }\n+\n+    private String getResearchName(JsonObject researchJson)\n     {\n-        return effect;\n+        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+\n+    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parserrors\";\n+        }\n+    }\n+\n+    private int getUniversityLevel(JsonObject researchJson)\n+    {\n+        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+        {\n+            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n+        }\n+        else\n+        {\n+            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n+            return 1;\n+        }\n+    }\n+\n+    private String getParent(JsonObject researchJson)\n+    {\n+        if (researchJson.has(RESEARCH_PARENT_PROP) && researchJson.get(RESEARCH_PARENT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_PARENT_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_PARENT_PROP).getAsString();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+\n+    private boolean getBooleanSafe(JsonObject researchJson, String property)", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\nindex 482b1287e6..c96ded62f1 100755\n--- a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n+++ b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n\n@@ -395,97 +569,197 @@ public class GlobalResearch implements IGlobalResearch\n     }\n \n     @Override\n-    public ImmutableList<String> getChilds()\n+    public List<String> getChildren()\n     {\n-        return ImmutableList.copyOf(this.childs);\n+        return this.children;\n     }\n \n     @Override\n     public List<IResearchEffect<?>> getEffects()\n     {\n-        return effects;\n+        return this.effects;\n     }\n \n+    @Override\n+    public String getIcon() {return this.icon;}\n+\n     /**\n      * Parse a Json object into a new GlobalResearch.\n      *\n-     * @param researchJson the json representing the recipe\n-     * @return new instance of ResearchRecipe\n+     * @param researchJson      the json representing the recipe\n+     * @param resourceLocation  the json's location.\n+     * @param effectCategories  a map of effect categories, by id.\n+     * @param validateIcons     if icons need to be validated.  This can only be performed on the client, and should only need to be done once.\n      */\n-    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    public GlobalResearch(@NotNull final JsonObject researchJson, final ResourceLocation resourceLocation, final Map<String, ResearchEffectCategory> effectCategories, final boolean validateIcons)\n     {\n-        this.resourceLocation = resourceLocation;\n-\n-        this.id = getResearchId(researchJson, resourceLocation);\n-        this.name = getResearchName(researchJson);\n+        this.id = resourceLocation.toString();\n+        final String autogenKey = \"com.\" + this.id.split(\":\")[0] + \".research.\" + this.id.split(\":\")[1].replaceAll(\"[ /:]\",\".\");\n+        this.name = getStringSafe(researchJson, RESEARCH_NAME_PROP, autogenKey + \".name\");\n+        this.subtitle = getStringSafe(researchJson, RESEARCH_SUBTITLE_PROP, autogenKey + \".subtitle\");\n         this.branch = getBranch(researchJson, resourceLocation);\n+        if (validateIcons && MineColonies.proxy.isClient())\n+        {\n+            this.icon = validateIcons(getStringSafe(researchJson, RESEARCH_ICON_PROP,\"\"));\n+        }\n+        else\n+        {\n+            this.icon = getStringSafe(researchJson, RESEARCH_ICON_PROP, \"\");\n+        }\n         this.depth = getUniversityLevel(researchJson);\n-        this.parent = getParent(researchJson);\n+        this.sortOrder = getSortOrder(researchJson);\n+        this.parent = getStringSafe(researchJson, RESEARCH_PARENT_PROP, \"\");\n         this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n         this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n         this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n         this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+        this.immutable = getBooleanSafe(researchJson, RESEARCH_NO_RESET_PROP);\n \n         parseRequirements(researchJson);\n         parseEffects(researchJson, effectCategories);\n     }\n \n-    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the branch for a research from a JSON object, if it exists and is valid, or \"parseerrors\" otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the ID from.\n+     * @param resourceLocation    The {@link ResourceLocation} of the json being parsed.\n+     * @return                    The Research Branch as a String.\n+     */\n+    private String getBranch(final JsonObject researchJson, final ResourceLocation resourceLocation)\n     {\n-        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n         {\n-            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n-            return \"\";\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parseerrors\";\n         }\n     }\n \n-    private String getResearchName(JsonObject researchJson)\n+    /**\n+     * Gets the required university level from a JSON object, if it exists and is valid, or returns 1 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getUniversityLevel(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            return \"\";\n+            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n+            return 1;\n         }\n     }\n \n-    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the sort order JSON object, if it exists and is valid, or returns 0 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getSortOrder(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_SORT_PROP) && researchJson.get(RESEARCH_SORT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_SORT_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+            return researchJson.get(RESEARCH_SORT_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n-            return \"parserrors\";\n+            return 0;\n         }\n     }\n \n-    private int getUniversityLevel(JsonObject researchJson)\n+    /**\n+     * Gets the optional icon location from a research json, if present.  If not available, or if requests a file or block that does not exist, returns an empty string.\n+     * @param icon                The unvalidated string representing an icon's resource location or texture file location.\n+     * @return                    The string, or an empty string if the texture does not exist.\n+     */\n+    private String validateIcons(final String icon)\n     {\n-        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+        final String[] iconParts = icon.split(\":\");\n+        final String[] outputString = new String[3];\n+        // Do preliminary validation here, as later uses will always be in UI space.\n+        if (iconParts.length > 3)\n         {\n-            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n+            Log.getLogger().info(\"Malformed icon property for \" + this.branch + \"/\" + this.id + \".  Icons may contain at most namespace:identifier:count.\");\n+            return \"\";\n+        }\n+\n+        if (iconParts.length == 3)\n+        {\n+            try\n+            {\n+                Integer.parseInt(iconParts[2]);\n+                outputString[2] = iconParts[2];\n+            }\n+            catch (NumberFormatException parseError)\n+            {\n+                Log.getLogger().info(\"Non-integer count assigned to icon of \" + this.branch + \"/\" + this.id + \" : \" + parseError.getLocalizedMessage());\n+                outputString[2] = \"1\";\n+            }\n         }\n         else\n         {\n-            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n-            return 1;\n+            outputString[2] = \"1\";\n         }\n+\n+        if (iconParts.length == 1)\n+        {\n+            outputString[0] = \"minecraft\";\n+            outputString[1] = iconParts[0];\n+        }\n+        else\n+        {\n+            outputString[0] = iconParts[0];\n+            outputString[1] = iconParts[1];\n+        }\n+\n+        // If looking for a texture file, check if the file exists here, both to better assist debugging, and to avoid exceptions in GUI thread.\n+        // For non-texture-file missing values, Forge will automatically replace with minecraft:air.\n+        if (outputString[1].contains(\".\"))\n+        {\n+            try\n+            {\n+                Minecraft.getInstance().getResourceManager().getResource(new ResourceLocation(outputString[0], outputString[1]));\n+            }\n+            catch (IOException notFoundError)\n+            {\n+                Log.getLogger()\n+                  .info(\"Resource file for Minecraft:\" + iconParts[1] + \" not found for \" + this.branch + \"/\" + this.id + \" : \" + notFoundError.getLocalizedMessage());\n+                outputString[0] = \"minecraft\";\n+                outputString[1] = \"air\";\n+            }\n+        }\n+        return outputString[0] + \":\" + outputString[1] + \":\" + outputString[2];\n     }\n \n-    private String getParent(JsonObject researchJson)\n+    /**\n+     * Gets a string from a json safely, if present, a default string if present but malformed or empty, and returns an empty string otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the Name from.\n+     * @param propertyName        The name of the property to retrieve.\n+     * @param defaultRet          The fallback String if not present or if not valid.\n+     * @return                    The Research Name as a String.\n+     */\n+    private String getStringSafe(final JsonObject researchJson, final String propertyName, final String defaultRet)\n     {\n-        if (researchJson.has(RESEARCH_PARENT_PROP) && researchJson.get(RESEARCH_PARENT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_PARENT_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(propertyName))\n         {\n-            return researchJson.get(RESEARCH_PARENT_PROP).getAsString();\n+            if(researchJson.get(propertyName).isJsonPrimitive() && researchJson.get(propertyName).getAsJsonPrimitive().isString())\n+            {\n+                return researchJson.get(propertyName).getAsString();\n+            }\n+            else\n+            {\n+                return defaultRet;\n+            }\n         }\n         else\n         {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ5ODQ5Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540498493", "bodyText": "javadoc", "author": "someaddons", "createdAt": "2020-12-10T21:10:01Z", "path": "src/main/java/com/minecolonies/coremod/research/GlobalResearch.java", "diffHunk": "@@ -262,8 +401,239 @@ public void setParent(final String id)\n     }\n \n     @Override\n-    public IResearchEffect<?> getEffect()\n+    public List<IResearchEffect<?>> getEffects()\n+    {\n+        return effects;\n+    }\n+\n+    /**\n+     * Parse a Json object into a new GlobalResearch.\n+     *\n+     * @param researchJson the json representing the recipe\n+     * @return new instance of ResearchRecipe\n+     */\n+    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    {\n+        this.resourceLocation = resourceLocation;\n+\n+        this.id = getResearchId(researchJson, resourceLocation);\n+        this.name = getResearchName(researchJson);\n+        this.branch = getBranch(researchJson, resourceLocation);\n+        this.depth = getUniversityLevel(researchJson);\n+        this.parent = getParent(researchJson);\n+        this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n+        this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n+        this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n+        this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+\n+        parseRequirements(researchJson);\n+        parseEffects(researchJson, effectCategories);\n+    }\n+\n+    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n+            return \"\";\n+        }\n+    }\n+\n+    private String getResearchName(JsonObject researchJson)\n     {\n-        return effect;\n+        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+\n+    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parserrors\";\n+        }\n+    }\n+\n+    private int getUniversityLevel(JsonObject researchJson)\n+    {\n+        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+        {\n+            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n+        }\n+        else\n+        {\n+            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n+            return 1;\n+        }\n+    }\n+\n+    private String getParent(JsonObject researchJson)\n+    {\n+        if (researchJson.has(RESEARCH_PARENT_PROP) && researchJson.get(RESEARCH_PARENT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_PARENT_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_PARENT_PROP).getAsString();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+\n+    private boolean getBooleanSafe(JsonObject researchJson, String property)\n+    {\n+        if (researchJson.has(property) && researchJson.get(property).isJsonPrimitive() && researchJson.get(property).getAsJsonPrimitive().isBoolean())\n+        {\n+            return researchJson.get(property).getAsBoolean();\n+        }\n+        else\n+        {\n+            return false;\n+        }\n+    }\n+\n+    private void parseRequirements(JsonObject researchJson)", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\nindex 482b1287e6..c96ded62f1 100755\n--- a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n+++ b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n\n@@ -395,97 +569,197 @@ public class GlobalResearch implements IGlobalResearch\n     }\n \n     @Override\n-    public ImmutableList<String> getChilds()\n+    public List<String> getChildren()\n     {\n-        return ImmutableList.copyOf(this.childs);\n+        return this.children;\n     }\n \n     @Override\n     public List<IResearchEffect<?>> getEffects()\n     {\n-        return effects;\n+        return this.effects;\n     }\n \n+    @Override\n+    public String getIcon() {return this.icon;}\n+\n     /**\n      * Parse a Json object into a new GlobalResearch.\n      *\n-     * @param researchJson the json representing the recipe\n-     * @return new instance of ResearchRecipe\n+     * @param researchJson      the json representing the recipe\n+     * @param resourceLocation  the json's location.\n+     * @param effectCategories  a map of effect categories, by id.\n+     * @param validateIcons     if icons need to be validated.  This can only be performed on the client, and should only need to be done once.\n      */\n-    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    public GlobalResearch(@NotNull final JsonObject researchJson, final ResourceLocation resourceLocation, final Map<String, ResearchEffectCategory> effectCategories, final boolean validateIcons)\n     {\n-        this.resourceLocation = resourceLocation;\n-\n-        this.id = getResearchId(researchJson, resourceLocation);\n-        this.name = getResearchName(researchJson);\n+        this.id = resourceLocation.toString();\n+        final String autogenKey = \"com.\" + this.id.split(\":\")[0] + \".research.\" + this.id.split(\":\")[1].replaceAll(\"[ /:]\",\".\");\n+        this.name = getStringSafe(researchJson, RESEARCH_NAME_PROP, autogenKey + \".name\");\n+        this.subtitle = getStringSafe(researchJson, RESEARCH_SUBTITLE_PROP, autogenKey + \".subtitle\");\n         this.branch = getBranch(researchJson, resourceLocation);\n+        if (validateIcons && MineColonies.proxy.isClient())\n+        {\n+            this.icon = validateIcons(getStringSafe(researchJson, RESEARCH_ICON_PROP,\"\"));\n+        }\n+        else\n+        {\n+            this.icon = getStringSafe(researchJson, RESEARCH_ICON_PROP, \"\");\n+        }\n         this.depth = getUniversityLevel(researchJson);\n-        this.parent = getParent(researchJson);\n+        this.sortOrder = getSortOrder(researchJson);\n+        this.parent = getStringSafe(researchJson, RESEARCH_PARENT_PROP, \"\");\n         this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n         this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n         this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n         this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+        this.immutable = getBooleanSafe(researchJson, RESEARCH_NO_RESET_PROP);\n \n         parseRequirements(researchJson);\n         parseEffects(researchJson, effectCategories);\n     }\n \n-    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the branch for a research from a JSON object, if it exists and is valid, or \"parseerrors\" otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the ID from.\n+     * @param resourceLocation    The {@link ResourceLocation} of the json being parsed.\n+     * @return                    The Research Branch as a String.\n+     */\n+    private String getBranch(final JsonObject researchJson, final ResourceLocation resourceLocation)\n     {\n-        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n         {\n-            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n-            return \"\";\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parseerrors\";\n         }\n     }\n \n-    private String getResearchName(JsonObject researchJson)\n+    /**\n+     * Gets the required university level from a JSON object, if it exists and is valid, or returns 1 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getUniversityLevel(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            return \"\";\n+            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n+            return 1;\n         }\n     }\n \n-    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the sort order JSON object, if it exists and is valid, or returns 0 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getSortOrder(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_SORT_PROP) && researchJson.get(RESEARCH_SORT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_SORT_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+            return researchJson.get(RESEARCH_SORT_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n-            return \"parserrors\";\n+            return 0;\n         }\n     }\n \n-    private int getUniversityLevel(JsonObject researchJson)\n+    /**\n+     * Gets the optional icon location from a research json, if present.  If not available, or if requests a file or block that does not exist, returns an empty string.\n+     * @param icon                The unvalidated string representing an icon's resource location or texture file location.\n+     * @return                    The string, or an empty string if the texture does not exist.\n+     */\n+    private String validateIcons(final String icon)\n     {\n-        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+        final String[] iconParts = icon.split(\":\");\n+        final String[] outputString = new String[3];\n+        // Do preliminary validation here, as later uses will always be in UI space.\n+        if (iconParts.length > 3)\n         {\n-            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n+            Log.getLogger().info(\"Malformed icon property for \" + this.branch + \"/\" + this.id + \".  Icons may contain at most namespace:identifier:count.\");\n+            return \"\";\n+        }\n+\n+        if (iconParts.length == 3)\n+        {\n+            try\n+            {\n+                Integer.parseInt(iconParts[2]);\n+                outputString[2] = iconParts[2];\n+            }\n+            catch (NumberFormatException parseError)\n+            {\n+                Log.getLogger().info(\"Non-integer count assigned to icon of \" + this.branch + \"/\" + this.id + \" : \" + parseError.getLocalizedMessage());\n+                outputString[2] = \"1\";\n+            }\n         }\n         else\n         {\n-            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n-            return 1;\n+            outputString[2] = \"1\";\n         }\n+\n+        if (iconParts.length == 1)\n+        {\n+            outputString[0] = \"minecraft\";\n+            outputString[1] = iconParts[0];\n+        }\n+        else\n+        {\n+            outputString[0] = iconParts[0];\n+            outputString[1] = iconParts[1];\n+        }\n+\n+        // If looking for a texture file, check if the file exists here, both to better assist debugging, and to avoid exceptions in GUI thread.\n+        // For non-texture-file missing values, Forge will automatically replace with minecraft:air.\n+        if (outputString[1].contains(\".\"))\n+        {\n+            try\n+            {\n+                Minecraft.getInstance().getResourceManager().getResource(new ResourceLocation(outputString[0], outputString[1]));\n+            }\n+            catch (IOException notFoundError)\n+            {\n+                Log.getLogger()\n+                  .info(\"Resource file for Minecraft:\" + iconParts[1] + \" not found for \" + this.branch + \"/\" + this.id + \" : \" + notFoundError.getLocalizedMessage());\n+                outputString[0] = \"minecraft\";\n+                outputString[1] = \"air\";\n+            }\n+        }\n+        return outputString[0] + \":\" + outputString[1] + \":\" + outputString[2];\n     }\n \n-    private String getParent(JsonObject researchJson)\n+    /**\n+     * Gets a string from a json safely, if present, a default string if present but malformed or empty, and returns an empty string otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the Name from.\n+     * @param propertyName        The name of the property to retrieve.\n+     * @param defaultRet          The fallback String if not present or if not valid.\n+     * @return                    The Research Name as a String.\n+     */\n+    private String getStringSafe(final JsonObject researchJson, final String propertyName, final String defaultRet)\n     {\n-        if (researchJson.has(RESEARCH_PARENT_PROP) && researchJson.get(RESEARCH_PARENT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_PARENT_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(propertyName))\n         {\n-            return researchJson.get(RESEARCH_PARENT_PROP).getAsString();\n+            if(researchJson.get(propertyName).isJsonPrimitive() && researchJson.get(propertyName).getAsJsonPrimitive().isString())\n+            {\n+                return researchJson.get(propertyName).getAsString();\n+            }\n+            else\n+            {\n+                return defaultRet;\n+            }\n         }\n         else\n         {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ5ODU4Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540498587", "bodyText": "javadoc", "author": "someaddons", "createdAt": "2020-12-10T21:10:12Z", "path": "src/main/java/com/minecolonies/coremod/research/GlobalResearch.java", "diffHunk": "@@ -262,8 +401,239 @@ public void setParent(final String id)\n     }\n \n     @Override\n-    public IResearchEffect<?> getEffect()\n+    public List<IResearchEffect<?>> getEffects()\n+    {\n+        return effects;\n+    }\n+\n+    /**\n+     * Parse a Json object into a new GlobalResearch.\n+     *\n+     * @param researchJson the json representing the recipe\n+     * @return new instance of ResearchRecipe\n+     */\n+    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    {\n+        this.resourceLocation = resourceLocation;\n+\n+        this.id = getResearchId(researchJson, resourceLocation);\n+        this.name = getResearchName(researchJson);\n+        this.branch = getBranch(researchJson, resourceLocation);\n+        this.depth = getUniversityLevel(researchJson);\n+        this.parent = getParent(researchJson);\n+        this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n+        this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n+        this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n+        this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+\n+        parseRequirements(researchJson);\n+        parseEffects(researchJson, effectCategories);\n+    }\n+\n+    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n+            return \"\";\n+        }\n+    }\n+\n+    private String getResearchName(JsonObject researchJson)\n     {\n-        return effect;\n+        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+\n+    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parserrors\";\n+        }\n+    }\n+\n+    private int getUniversityLevel(JsonObject researchJson)\n+    {\n+        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+        {\n+            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n+        }\n+        else\n+        {\n+            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n+            return 1;\n+        }\n+    }\n+\n+    private String getParent(JsonObject researchJson)\n+    {\n+        if (researchJson.has(RESEARCH_PARENT_PROP) && researchJson.get(RESEARCH_PARENT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_PARENT_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_PARENT_PROP).getAsString();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+\n+    private boolean getBooleanSafe(JsonObject researchJson, String property)\n+    {\n+        if (researchJson.has(property) && researchJson.get(property).isJsonPrimitive() && researchJson.get(property).getAsJsonPrimitive().isBoolean())\n+        {\n+            return researchJson.get(property).getAsBoolean();\n+        }\n+        else\n+        {\n+            return false;\n+        }\n+    }\n+\n+    private void parseRequirements(JsonObject researchJson)\n+    {\n+        if (researchJson.has(RESEARCH_REQUIREMENTS_PROP) && researchJson.get(RESEARCH_REQUIREMENTS_PROP).isJsonArray())\n+        {\n+            for (final JsonElement reqArrayElement : researchJson.get(RESEARCH_REQUIREMENTS_PROP).getAsJsonArray())\n+            {\n+                // ItemRequirements.  If no count, assumes 1x.\n+                if(reqArrayElement.isJsonObject() && reqArrayElement.getAsJsonObject().has(RESEARCH_ITEM_NAME_PROP) &&\n+                     reqArrayElement.getAsJsonObject().get(RESEARCH_ITEM_NAME_PROP).isJsonPrimitive() && reqArrayElement.getAsJsonObject().get(RESEARCH_ITEM_NAME_PROP).getAsJsonPrimitive().isString())\n+                {\n+                    final String[] itemName = reqArrayElement.getAsJsonObject().get(RESEARCH_ITEM_NAME_PROP).getAsString().split(\":\");\n+                    final Item item;\n+                    if  (itemName.length == 2)\n+                    {\n+                        item = ForgeRegistries.ITEMS.getValue(new ResourceLocation(itemName[0], itemName[1]));\n+                    }\n+                    else if (itemName.length == 1)\n+                    {\n+                        item = ForgeRegistries.ITEMS.getValue(new ResourceLocation(\"minecraft\", itemName[0]));\n+                    }\n+                    else\n+                    {\n+                        item = ForgeRegistries.ITEMS.getValue(new ResourceLocation(\"minecraft\", \"cobblestone\"));\n+                    }\n+                    final ItemStack itemStack = new ItemStack(item);\n+                    if(reqArrayElement.getAsJsonObject().has(RESEARCH_QUANTITY_PROP) && reqArrayElement.getAsJsonObject().get(RESEARCH_QUANTITY_PROP).isJsonPrimitive()\n+                         && reqArrayElement.getAsJsonObject().get(RESEARCH_QUANTITY_PROP).getAsJsonPrimitive().isNumber())\n+                    {\n+                        itemStack.setCount(reqArrayElement.getAsJsonObject().get(RESEARCH_QUANTITY_PROP).getAsNumber().intValue());\n+                    }\n+                    this.costList.add(new ItemStorage(itemStack, false));\n+                }\n+                // Building Requirements.  If no level, assume 1x.\n+                else if(reqArrayElement.isJsonObject() && reqArrayElement.getAsJsonObject().has(RESEARCH_REQUIRED_BUILDING_PROP) &&\n+                          reqArrayElement.getAsJsonObject().get(RESEARCH_REQUIRED_BUILDING_PROP).isJsonPrimitive() && reqArrayElement.getAsJsonObject().get(RESEARCH_REQUIRED_BUILDING_PROP).getAsJsonPrimitive().isString())\n+                {\n+                    final int level;\n+                    if(reqArrayElement.getAsJsonObject().has(RESEARCH_LEVEL_PROP) && reqArrayElement.getAsJsonObject().get(RESEARCH_LEVEL_PROP).isJsonPrimitive()\n+                         && reqArrayElement.getAsJsonObject().get(RESEARCH_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+                    {\n+                        level = reqArrayElement.getAsJsonObject().get(RESEARCH_LEVEL_PROP).getAsNumber().intValue();\n+                    }\n+                    else\n+                    {\n+                        level = 1;\n+                    }\n+                    BuildingResearchRequirement requirement = new BuildingResearchRequirement(level, reqArrayElement.getAsJsonObject().get(RESEARCH_REQUIRED_BUILDING_PROP).getAsString());\n+                    this.requirements.add(requirement);\n+                }\n+                // Research Requirements.  Only partially implemented.\n+                else if(reqArrayElement.isJsonObject() && reqArrayElement.getAsJsonObject().has(RESEARCH_REQUIRED_RESEARCH_PROP) &&\n+                          reqArrayElement.getAsJsonObject().get(RESEARCH_REQUIRED_RESEARCH_PROP).isJsonPrimitive() && reqArrayElement.getAsJsonObject().get(RESEARCH_REQUIRED_RESEARCH_PROP).getAsJsonPrimitive().isString())\n+                {\n+                    this.requirements.add(new ResearchResearchRequirement(reqArrayElement.getAsJsonObject().get(RESEARCH_REQUIRED_RESEARCH_PROP).getAsString(), this.name));\n+                }\n+                else\n+                {\n+                    Log.getLogger().warn(\"Invalid Research Requirement formatting for \" + this.branch + \"/\" + this.id);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void parseEffects(JsonObject researchJson, Map<String, ResearchEffectCategory> effectCategories)", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\nindex 482b1287e6..c96ded62f1 100755\n--- a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n+++ b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n\n@@ -395,97 +569,197 @@ public class GlobalResearch implements IGlobalResearch\n     }\n \n     @Override\n-    public ImmutableList<String> getChilds()\n+    public List<String> getChildren()\n     {\n-        return ImmutableList.copyOf(this.childs);\n+        return this.children;\n     }\n \n     @Override\n     public List<IResearchEffect<?>> getEffects()\n     {\n-        return effects;\n+        return this.effects;\n     }\n \n+    @Override\n+    public String getIcon() {return this.icon;}\n+\n     /**\n      * Parse a Json object into a new GlobalResearch.\n      *\n-     * @param researchJson the json representing the recipe\n-     * @return new instance of ResearchRecipe\n+     * @param researchJson      the json representing the recipe\n+     * @param resourceLocation  the json's location.\n+     * @param effectCategories  a map of effect categories, by id.\n+     * @param validateIcons     if icons need to be validated.  This can only be performed on the client, and should only need to be done once.\n      */\n-    public GlobalResearch(@NotNull final JsonObject researchJson, ResourceLocation resourceLocation, Map<String, ResearchEffectCategory> effectCategories)\n+    public GlobalResearch(@NotNull final JsonObject researchJson, final ResourceLocation resourceLocation, final Map<String, ResearchEffectCategory> effectCategories, final boolean validateIcons)\n     {\n-        this.resourceLocation = resourceLocation;\n-\n-        this.id = getResearchId(researchJson, resourceLocation);\n-        this.name = getResearchName(researchJson);\n+        this.id = resourceLocation.toString();\n+        final String autogenKey = \"com.\" + this.id.split(\":\")[0] + \".research.\" + this.id.split(\":\")[1].replaceAll(\"[ /:]\",\".\");\n+        this.name = getStringSafe(researchJson, RESEARCH_NAME_PROP, autogenKey + \".name\");\n+        this.subtitle = getStringSafe(researchJson, RESEARCH_SUBTITLE_PROP, autogenKey + \".subtitle\");\n         this.branch = getBranch(researchJson, resourceLocation);\n+        if (validateIcons && MineColonies.proxy.isClient())\n+        {\n+            this.icon = validateIcons(getStringSafe(researchJson, RESEARCH_ICON_PROP,\"\"));\n+        }\n+        else\n+        {\n+            this.icon = getStringSafe(researchJson, RESEARCH_ICON_PROP, \"\");\n+        }\n         this.depth = getUniversityLevel(researchJson);\n-        this.parent = getParent(researchJson);\n+        this.sortOrder = getSortOrder(researchJson);\n+        this.parent = getStringSafe(researchJson, RESEARCH_PARENT_PROP, \"\");\n         this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n         this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n         this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n         this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+        this.immutable = getBooleanSafe(researchJson, RESEARCH_NO_RESET_PROP);\n \n         parseRequirements(researchJson);\n         parseEffects(researchJson, effectCategories);\n     }\n \n-    private String getResearchId(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the branch for a research from a JSON object, if it exists and is valid, or \"parseerrors\" otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the ID from.\n+     * @param resourceLocation    The {@link ResourceLocation} of the json being parsed.\n+     * @return                    The Research Branch as a String.\n+     */\n+    private String getBranch(final JsonObject researchJson, final ResourceLocation resourceLocation)\n     {\n-        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n         {\n-            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n-            return \"\";\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parseerrors\";\n         }\n     }\n \n-    private String getResearchName(JsonObject researchJson)\n+    /**\n+     * Gets the required university level from a JSON object, if it exists and is valid, or returns 1 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getUniversityLevel(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            return \"\";\n+            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n+            return 1;\n         }\n     }\n \n-    private String getBranch(JsonObject researchJson, ResourceLocation resourceLocation)\n+    /**\n+     * Gets the sort order JSON object, if it exists and is valid, or returns 0 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getSortOrder(final JsonObject researchJson)\n     {\n-        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(RESEARCH_SORT_PROP) && researchJson.get(RESEARCH_SORT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_SORT_PROP).getAsJsonPrimitive().isNumber())\n         {\n-            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+            return researchJson.get(RESEARCH_SORT_PROP).getAsNumber().intValue();\n         }\n         else\n         {\n-            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n-            return \"parserrors\";\n+            return 0;\n         }\n     }\n \n-    private int getUniversityLevel(JsonObject researchJson)\n+    /**\n+     * Gets the optional icon location from a research json, if present.  If not available, or if requests a file or block that does not exist, returns an empty string.\n+     * @param icon                The unvalidated string representing an icon's resource location or texture file location.\n+     * @return                    The string, or an empty string if the texture does not exist.\n+     */\n+    private String validateIcons(final String icon)\n     {\n-        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+        final String[] iconParts = icon.split(\":\");\n+        final String[] outputString = new String[3];\n+        // Do preliminary validation here, as later uses will always be in UI space.\n+        if (iconParts.length > 3)\n         {\n-            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n+            Log.getLogger().info(\"Malformed icon property for \" + this.branch + \"/\" + this.id + \".  Icons may contain at most namespace:identifier:count.\");\n+            return \"\";\n+        }\n+\n+        if (iconParts.length == 3)\n+        {\n+            try\n+            {\n+                Integer.parseInt(iconParts[2]);\n+                outputString[2] = iconParts[2];\n+            }\n+            catch (NumberFormatException parseError)\n+            {\n+                Log.getLogger().info(\"Non-integer count assigned to icon of \" + this.branch + \"/\" + this.id + \" : \" + parseError.getLocalizedMessage());\n+                outputString[2] = \"1\";\n+            }\n         }\n         else\n         {\n-            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n-            return 1;\n+            outputString[2] = \"1\";\n         }\n+\n+        if (iconParts.length == 1)\n+        {\n+            outputString[0] = \"minecraft\";\n+            outputString[1] = iconParts[0];\n+        }\n+        else\n+        {\n+            outputString[0] = iconParts[0];\n+            outputString[1] = iconParts[1];\n+        }\n+\n+        // If looking for a texture file, check if the file exists here, both to better assist debugging, and to avoid exceptions in GUI thread.\n+        // For non-texture-file missing values, Forge will automatically replace with minecraft:air.\n+        if (outputString[1].contains(\".\"))\n+        {\n+            try\n+            {\n+                Minecraft.getInstance().getResourceManager().getResource(new ResourceLocation(outputString[0], outputString[1]));\n+            }\n+            catch (IOException notFoundError)\n+            {\n+                Log.getLogger()\n+                  .info(\"Resource file for Minecraft:\" + iconParts[1] + \" not found for \" + this.branch + \"/\" + this.id + \" : \" + notFoundError.getLocalizedMessage());\n+                outputString[0] = \"minecraft\";\n+                outputString[1] = \"air\";\n+            }\n+        }\n+        return outputString[0] + \":\" + outputString[1] + \":\" + outputString[2];\n     }\n \n-    private String getParent(JsonObject researchJson)\n+    /**\n+     * Gets a string from a json safely, if present, a default string if present but malformed or empty, and returns an empty string otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the Name from.\n+     * @param propertyName        The name of the property to retrieve.\n+     * @param defaultRet          The fallback String if not present or if not valid.\n+     * @return                    The Research Name as a String.\n+     */\n+    private String getStringSafe(final JsonObject researchJson, final String propertyName, final String defaultRet)\n     {\n-        if (researchJson.has(RESEARCH_PARENT_PROP) && researchJson.get(RESEARCH_PARENT_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_PARENT_PROP).getAsJsonPrimitive().isString())\n+        if (researchJson.has(propertyName))\n         {\n-            return researchJson.get(RESEARCH_PARENT_PROP).getAsString();\n+            if(researchJson.get(propertyName).isJsonPrimitive() && researchJson.get(propertyName).getAsJsonPrimitive().isString())\n+            {\n+                return researchJson.get(propertyName).getAsString();\n+            }\n+            else\n+            {\n+                return defaultRet;\n+            }\n         }\n         else\n         {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ5OTEwOQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540499109", "bodyText": "javadoc on all fields :)", "author": "someaddons", "createdAt": "2020-12-10T21:10:53Z", "path": "src/main/java/com/minecolonies/coremod/research/GlobalResearchTree.java", "diffHunk": "@@ -21,18 +30,37 @@\n public class GlobalResearchTree implements IGlobalResearchTree\n {\n     /**\n-     * The map containing all researches by ID.\n+     * The map containing all researches by ID and branch.\n      */\n     private final Map<String, Map<String, IGlobalResearch>> researchTree = new HashMap<>();\n \n+    private final Map<ResourceLocation, String> researchResourceLocations = new HashMap<>();", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/GlobalResearchTree.java b/src/main/java/com/minecolonies/coremod/research/GlobalResearchTree.java\nindex 8b9c6e02aa..2aaf38c2f1 100755\n--- a/src/main/java/com/minecolonies/coremod/research/GlobalResearchTree.java\n+++ b/src/main/java/com/minecolonies/coremod/research/GlobalResearchTree.java\n\n@@ -34,24 +35,33 @@ public class GlobalResearchTree implements IGlobalResearchTree\n      */\n     private final Map<String, Map<String, IGlobalResearch>> researchTree = new HashMap<>();\n \n-    private final Map<ResourceLocation, String> researchResourceLocations = new HashMap<>();\n-\n-    private final List<ResourceLocation> resettableResearch = new ArrayList<>();\n+    /**\n+     * The map matching branch IDs to their UI-presented names, or IDs otherwise.\n+     */\n+    private final Map<String, String> branchNames = new HashMap<>();\n \n-    private final List<IGlobalResearch> autostartResearch = new ArrayList<>();\n+    /**\n+     * The map matching branch IDs the base times, defaulting to 1.\n+     */\n+    private final Map<String, Double> branchTimes = new HashMap<>();\n \n-    private final Map<String, IResearchEffect> unlockBuildingEffect = new HashMap<>();\n+    /**\n+     * The list containing all resettable researches by ResourceLocation.\n+     */\n+    private final List<String> reloadableResearch = new ArrayList<>();\n \n-    private final Map<String, IResearchEffect> unlockAbilityEffect = new HashMap<>();\n+    /**\n+     * The list containing all autostart research.\n+     */\n+    private final HashSet<IGlobalResearch> autostartResearch = new HashSet<>();\n \n-    @Override\n-    public IGlobalResearch getResearch(final String branch, final String id)\n-    {\n-        return researchTree.get(branch).get(id);\n-    }\n+    /**\n+     * The map containing loaded Research Effect IDs.\n+     */\n+    private final HashSet<String> researchEffectsIds = new HashSet<>();\n \n     @Override\n-    public ResourceLocation getResearchResourceLocation(final String branch, final String id) {  return researchTree.get(branch).get(id).getResourceLocation(); }\n+    public IGlobalResearch getResearch(final String branch, final String id) { return researchTree.get(branch).get(id); }\n \n     @Override\n     public boolean hasResearch(final String branch, final String id)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwMzE4OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540503189", "bodyText": "maybe displayValue is better", "author": "someaddons", "createdAt": "2020-12-10T21:17:34Z", "path": "src/main/java/com/minecolonies/coremod/research/MultiplierModifierResearchEffect.java", "diffHunk": "@@ -15,16 +16,22 @@\n      */\n     private double effect;\n \n+    /**\n+     * The relative value of the effect, for display purposes.\n+     */\n+    private double relativeEffect;", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYyODc5OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540628799", "bodyText": "Right now, both are fed into the translationtexts, with relativeEffects simply the first argument and absolute effects the second. They only translation that displays absolute values for English is fleeingspeedaddition (which applies a potion effect, where absolute values make more sense).\nBut displayEffect is probably more logical of a separation.", "author": "gattsuru", "createdAt": "2020-12-11T01:45:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwMzE4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/MultiplierModifierResearchEffect.java b/src/main/java/com/minecolonies/coremod/research/MultiplierModifierResearchEffect.java\ndeleted file mode 100755\nindex e9f4d135b4..0000000000\n--- a/src/main/java/com/minecolonies/coremod/research/MultiplierModifierResearchEffect.java\n+++ /dev/null\n\n@@ -1,60 +0,0 @@\n-package com.minecolonies.coremod.research;\n-\n-import com.minecolonies.api.research.effects.AbstractResearchEffect;\n-import com.minecolonies.api.research.effects.IResearchEffect;\n-import com.minecolonies.api.util.constant.TranslationConstants;\n-import net.minecraft.util.text.TranslationTextComponent;\n-import org.jetbrains.annotations.NotNull;\n-\n-/**\n- * The modifier multiplication research effect, it returns a double modifier.\n- */\n-public class MultiplierModifierResearchEffect extends AbstractResearchEffect<Double>\n-{\n-    /**\n-     * The effect to apply.\n-     */\n-    private double effect;\n-\n-    /**\n-     * The relative value of the effect, for display purposes.\n-     */\n-    private double relativeEffect;\n-\n-    /**\n-     * The constructor to create a new modifier research effect.\n-     *\n-     * @param id     the id to unlock.\n-     * @param effect the effect.\n-     */\n-    public MultiplierModifierResearchEffect(final String id, final double effect, final double relativeEffect)\n-    {\n-        super(id);\n-        this.effect = effect;\n-        this.relativeEffect = relativeEffect;\n-    }\n-\n-    @Override\n-    public Double getEffect()\n-    {\n-        return this.effect;\n-    }\n-\n-    @Override\n-    public void setEffect(final Double effect)\n-    {\n-        this.effect = effect;\n-    }\n-\n-    @Override\n-    public TranslationTextComponent getDesc()\n-    {\n-        return new TranslationTextComponent(TranslationConstants.RESEARCH_EFFECTS + this.getId() + \".description\", Math.round(relativeEffect * 100), Math.round(effect * 100));\n-    }\n-\n-    @Override\n-    public boolean overrides(@NotNull final IResearchEffect<?> other)\n-    {\n-        return effect > ((MultiplierModifierResearchEffect) other).effect;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwMzMxNA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540503314", "bodyText": "javadoc in this class/above", "author": "someaddons", "createdAt": "2020-12-10T21:17:45Z", "path": "src/main/java/com/minecolonies/coremod/research/ResearchEffectCategory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package com.minecolonies.coremod.research;\n+\n+import com.minecolonies.api.util.constant.TranslationConstants;\n+import net.minecraft.util.text.TranslationTextComponent;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class ResearchEffectCategory", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/ResearchEffectCategory.java b/src/main/java/com/minecolonies/coremod/research/ResearchEffectCategory.java\nindex 9e837e7dc1..2aa5f0b37a 100644\n--- a/src/main/java/com/minecolonies/coremod/research/ResearchEffectCategory.java\n+++ b/src/main/java/com/minecolonies/coremod/research/ResearchEffectCategory.java\n\n@@ -1,11 +1,11 @@\n package com.minecolonies.coremod.research;\n \n-import com.minecolonies.api.util.constant.TranslationConstants;\n-import net.minecraft.util.text.TranslationTextComponent;\n-\n import java.util.ArrayList;\n import java.util.List;\n \n+/**\n+ * This class represents a Type of Research Effect, including its identifier and effect levels.\n+ */\n public class ResearchEffectCategory\n {\n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwNzUzNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540507535", "bodyText": "before we had the two different \"effects\" which were unlock yes/No or unlock with value. Now we can combine them as int as you kinda did here which makes me wonder if we actually need different \"effects\". As the way I see it its just a rich information return of the research, and not the actual effect of the research. In that case we wouldnt need effect lists at all/neither any of the current \"effect\" implementation", "author": "someaddons", "createdAt": "2020-12-10T21:24:55Z", "path": "src/main/java/com/minecolonies/coremod/research/UnlockAbilityResearchEffect.java", "diffHunk": "@@ -13,36 +14,36 @@\n     /**\n      * Whether the effect has been unlocked or not.\n      */\n-    private boolean unlocked;\n+    private int level;", "originalCommit": "1fd3ef00855bc49555a11acca10d891539dd68bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYzOTA2Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r540639066", "bodyText": "There's technically four, split between the Addition and Multiplication floats, and the UnlockAbility, UnlockBuilding booleans.  From a logical perspective they can definitely be merged into a single implementation; it's as much a matter from presentation and programming maintenance that it's a question.  Addition and Multiplication have different approaches to translation arguments due to different magnitudes of their most common values, for example.\nDefinitely can be reduced down if that simplifies matters for you all, though.", "author": "gattsuru", "createdAt": "2020-12-11T02:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwNzUzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/UnlockAbilityResearchEffect.java b/src/main/java/com/minecolonies/coremod/research/UnlockAbilityResearchEffect.java\ndeleted file mode 100755\nindex 26baec95be..0000000000\n--- a/src/main/java/com/minecolonies/coremod/research/UnlockAbilityResearchEffect.java\n+++ /dev/null\n\n@@ -1,54 +0,0 @@\n-package com.minecolonies.coremod.research;\n-\n-import com.minecolonies.api.research.effects.AbstractResearchEffect;\n-import com.minecolonies.api.research.effects.IResearchEffect;\n-import com.minecolonies.api.util.constant.TranslationConstants;\n-import net.minecraft.util.text.TranslationTextComponent;\n-import org.jetbrains.annotations.NotNull;\n-\n-/**\n- * The unlock ability research effect, it returns true if unlocked and else false.\n- */\n-public class UnlockAbilityResearchEffect extends AbstractResearchEffect<Boolean>\n-{\n-    /**\n-     * Whether the effect has been unlocked or not.\n-     */\n-    private int level;\n-\n-    /**\n-     * The constructor to create a new unlock research effect.\n-     *\n-     * @param id                  the id to unlock.\n-     * @param level               greater than zero if unlocked.\n-     */\n-    public UnlockAbilityResearchEffect(final String id, final int level)\n-    {\n-        super(id);\n-        this.level = level;\n-    }\n-\n-    @Override\n-    public Boolean getEffect()\n-    {\n-        return (this.level > 0);\n-    }\n-\n-    @Override\n-    public void setEffect(final Boolean effect)\n-    {\n-        this.level = (effect ? 1 : 0);\n-    }\n-\n-    @Override\n-    public TranslationTextComponent getDesc()\n-    {\n-        return new TranslationTextComponent(TranslationConstants.RESEARCH_EFFECTS + this.getId() + \".description\");\n-    }\n-\n-    @Override\n-    public boolean overrides(@NotNull final IResearchEffect<?> other)\n-    {\n-        return false;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3NDgwNg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548474806", "bodyText": "Probably good to remove this extra line here", "author": "Raycoms", "createdAt": "2020-12-24T09:57:37Z", "path": "src/api/java/com/minecolonies/api/MinecoloniesAPIProxy.java", "diffHunk": "@@ -143,6 +143,7 @@ public IGlobalResearchTree getGlobalResearchTree()\n         return apiInstance.getColonyEventRegistry();\n     }\n \n+", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/MinecoloniesAPIProxy.java b/src/api/java/com/minecolonies/api/MinecoloniesAPIProxy.java\nindex 03e5c08063..cdda2a96fb 100755\n--- a/src/api/java/com/minecolonies/api/MinecoloniesAPIProxy.java\n+++ b/src/api/java/com/minecolonies/api/MinecoloniesAPIProxy.java\n\n@@ -143,7 +143,6 @@ public final class MinecoloniesAPIProxy implements IMinecoloniesAPI\n         return apiInstance.getColonyEventRegistry();\n     }\n \n-\n     @Override\n     public IForgeRegistry<ColonyEventDescriptionTypeRegistryEntry> getColonyEventDescriptionRegistry()\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3NjM0Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548476346", "bodyText": "That's not the annotation we're using, we're using the Intellij ones", "author": "Raycoms", "createdAt": "2020-12-24T10:02:23Z", "path": "src/api/java/com/minecolonies/api/research/ILocalResearchTree.java", "diffHunk": "@@ -1,8 +1,10 @@\n package com.minecolonies.api.research;\n \n+import com.minecolonies.api.colony.IColony;\n import com.minecolonies.api.research.effects.IResearchEffectManager;\n import net.minecraft.nbt.CompoundNBT;\n \n+import javax.annotation.Nullable;", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java b/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java\nindex 0381da6369..4f9805a60b 100755\n--- a/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java\n+++ b/src/api/java/com/minecolonies/api/research/ILocalResearchTree.java\n\n@@ -2,9 +2,10 @@ package com.minecolonies.api.research;\n \n import com.minecolonies.api.colony.IColony;\n import com.minecolonies.api.research.effects.IResearchEffectManager;\n+import net.minecraft.entity.player.PlayerEntity;\n import net.minecraft.nbt.CompoundNBT;\n \n-import javax.annotation.Nullable;\n+import org.jetbrains.annotations.Nullable;\n import java.util.List;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3NjU1Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548476553", "bodyText": "let's make those doubles and not floats, floats should be reserved to rendering logic", "author": "Raycoms", "createdAt": "2020-12-24T10:03:06Z", "path": "src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java", "diffHunk": "@@ -17,10 +17,32 @@\n      */\n     <W extends IResearchEffect<?>> W getEffect(final String id, @NotNull final Class<W> type);\n \n+    /**\n+     * Get the research effect strength which is assigned to a particular string\n+     * or zero, if no matching effect is present.\n+     *\n+     * @param id   the id of the effect.\n+     * @return the strength of the effect, or zero if it isn't present.\n+     */\n+     float getEffectValue(final String id);", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java b/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\nindex 19ae2b9cac..1cbc003c21 100755\n--- a/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\n+++ b/src/api/java/com/minecolonies/api/research/effects/IResearchEffectManager.java\n\n@@ -24,7 +24,7 @@ public interface IResearchEffectManager\n      * @param id   the id of the effect.\n      * @return the strength of the effect, or zero if it isn't present.\n      */\n-     float getEffectValue(final String id);\n+     double getEffectValue(final String id);\n \n     /**\n      * Gets whether a research effect is enabled with a non-zero value.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3Njc3NA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548476774", "bodyText": "we can remove those, np", "author": "Raycoms", "createdAt": "2020-12-24T10:03:47Z", "path": "src/api/java/com/minecolonies/api/research/util/ResearchConstants.java", "diffHunk": "@@ -53,58 +57,93 @@\n     public static final int    LOCK_HEIGHT          = 17;\n     public static final int    OR_X_OFFSET          = 14;\n     public static final int    OR_Y_OFFSET          = 10;\n+    public static final int    OR_HEIGHT            = 16;\n+    public static final int    OR_WIDTH             = 16;\n+    public static final int    TIME_HEIGHT          = 5;\n+    public static final int    TIME_WIDTH           = 95;\n+\n+    public static final int    COLOR_TEXT_NEGATIVE  = Color.rgbaToInt(218, 10, 10, 255);\n+    public static final int    COLOR_TEXT_LABEL     = Color.rgbaToInt(218, 202, 171, 255);\n+    public static final int    COLOR_TEXT_LIGHT     = Color.rgbaToInt(60, 60, 60, 255);\n \n     /**\n-     * Research effects.\n+     * Research Effect Name strings, used for ResearchEffectManager and ResearchRegistry lookups.\n      */\n-    public static final String ARCHER_ARMOR     = \"Archer Armour\";\n-    public static final String MELEE_ARMOR      = \"Melee Armour\";\n-    public static final String ARMOR_DURABILITY = \"Armor Durability\";\n-    public static final String FLEEING_DAMAGE   = \"Fleeing Damage\";\n-    public static final String FLEEING_SPEED    = \"Fleeing Speed\";\n-    public static final String MELEE_DAMAGE     = \"Melee Damage\";\n-    public static final String ARCHER_DAMAGE    = \"Archer Damage\";\n-    public static final String RETREAT          = \"Retreat\";\n-    public static final String NONE             = \"None\";\n-    public static final String SHIELD_USAGE     = \"Shield Usage\";\n-    public static final String KNIGHT_TAUNT     = \"Knight taunt mobs\";\n-    public static final String DOUBLE_ARROWS    = \"Double Arrows\";\n-    public static final String ARROW_ITEMS      = \"Consume Arrows\";\n-    public static final String ARROW_PIERCE     = \"Piercing Arrows\";\n-    public static final String KNIGHT_WHIRLWIND = \"Whirldwind ability\";\n-    public static final String BLOCK_ATTACKS    = \"Block Attacks\";\n-    public static final String SLEEP_LESS       = \"Sleep Less\";\n-    public static final String WORK_LONGER      = \"Working day h\";\n-\n-    public static final String TEACHING = \"Teaching\";\n-    public static final String GROWTH   = \"Growth\";\n-    public static final String CAP      = \"Citizen-Cap\";\n-    public static final String RAILS    = \"Rails\";\n-    public static final String WALKING  = \"Walking\";\n-    public static final String LEVELING  = \"Leveling\";\n+    //Addition Multipliers\n+    public static final String ARCHER_DAMAGE                = \"archerdamageaddition\";\n+    public static final String CITIZEN_INV_SLOTS                    = \"citizeninvslotsaddition\";\n+    public static final String CITIZEN_CAP                  = \"citizencapaddition\";\n+    public static final String MECHANIC_ENHANCED_GATES      = \"enhancesgatedurabilityaddition\";\n+    public static final String FLEEING_SPEED                = \"fleeingspeedaddition\";\n+    public static final String SATLIMIT                     = \"healingsaturationlimitaddition\";\n+    public static final String HEALTH_BOOST                 = \"healthaddition\";\n+    public static final String MELEE_DAMAGE                 = \"meleedamageaddition\";\n+    public static final String WORK_LONGER                  = \"workingdayhaddition\";\n \n-    public static final String HEALTH       = \"Health\";\n-    public static final String REGENERATION = \"Regeneration\";\n-    public static final String SATLIMIT     = \"Healing Saturation Limit\";\n-    public static final String HAPPINESS    = \"Happiness\";\n-    public static final String SATURATION   = \"Saturation\";\n+    //Multiplier Modifiers\n+    public static final String ARCHER_ARMOR      = \"archerarmormultiplier\";\n+    public static final String ARMOR_DURABILITY  = \"armordurabilitymultiplier\";\n+    public static final String BLOCK_ATTACKS     = \"blockattacksmultiplier\";\n+    public static final String BLOCK_BREAK_SPEED = \"blockbreakspeedmultiplier\";\n+    public static final String BLOCK_PLACE_SPEED = \"blockplacespeedmultiplier\";\n+    public static final String DOUBLE_ARROWS     = \"doublearrowsmultiplier\";\n+    public static final String FARMING           = \"farmingmultiplier\";\n+    public static final String FLEEING_DAMAGE    = \"fleeingdamagemultiplier\";;\n+    public static final String GROWTH            = \"growthmultiplier\";\n+    public static final String HAPPINESS         = \"happinessmultiplier\";\n+    public static final String LEVELING          = \"levelingmultiplier\";\n+    public static final String MELEE_ARMOR       = \"meleearmormultiplier\";\n+    public static final String MINIMUM_STOCK     = \"minimumstockmultiplier\";\n+    public static final String MORE_ORES         = \"moreoresmultiplier\";\n+    public static final String RECIPES           = \"recipesmultiplier\";\n+    public static final String REGENERATION      = \"regenerationmultiplier\";\n+    public static final String SATURATION        = \"saturationmultiplier\";\n+    public static final String SLEEP_LESS        = \"sleeplessmultiplier\";\n+    public static final String TEACHING          = \"teachingmultiplier\";\n+    public static final String TOOL_DURABILITY   = \"tooldurabilitymultiplier\";\n+    public static final String WALKING           = \"walkingmultiplier\";\n \n-    public static final String FARMING           = \"Farming\";\n-    public static final String BLOCK_BREAK_SPEED = \"Block Break Speed\";\n-    public static final String MINIMUM_STOCK     = \"Minimum Stock\";\n-    public static final String RECIPES           = \"Recipes\";\n-    public static final String BLOCK_PLACE_SPEED = \"Block Place Speed\";\n-    public static final String MORE_ORES         = \"More Ores\";\n-    public static final String WORKING_IN_RAIN   = \"Working in Rain\";\n-    public static final String TOOL_DURABILITY   = \"Tool Durability\";\n-    public static final String INV_SLOTS         = \"Citizen Inv Slots\";\n+    //Unlock Ability modifiers.\n+    public static final String CRUSHING_11       = \"crushing11unlock\";\n+    public static final String ARCHER_USE_ARROWS = \"consumearrowsunlock\";\n+    public static final String KNIGHT_TAUNT      = \"knighttauntmobsunlock\";\n+    public static final String FIRE_RES          = \"minerfireresunlock\";\n+    public static final String ARROW_PIERCE      = \"piercingarrowsunlock\";\n+    public static final String PLANT_2           = \"plant2unlock\";\n+    public static final String RAILS             = \"railsunlock\";\n+    public static final String RETREAT           = \"retreatunlock\";\n+    public static final String SHIELD_USAGE      = \"shieldusageunlock\";\n+    public static final String KNIGHT_WHIRLWIND  = \"whirlwindabilityunlock\";\n+    public static final String WORKING_IN_RAIN   = \"workinginrainunlock\";\n \n-    public static final String PLANT_2     = \"Plant 2\";\n-    public static final String CRUSHING_11 = \"1:1 Crushing\";\n-    public static final String FIRE_RES    = \"Miner Fire Res\";\n+    /* // Recipe-only unlocks don't really need specific effects.  Leaving here in case we do want to add AbilityEffects to them.\n+    /public static final String END_KNOWLEDGE     = \"knowledgeoftheendunlock\";\n+    /public static final String MORE_SCROLLS      = \"morescrollsunlock\";\n+     */\n \n-    public static final String END_KNOWLEGE = \"Knowledge of The End\";\n-    public static final String MORE_SCROLLS = \"more scroll recipes\";\n+    //Unlock Building modifiers.\n+    /*public static final String COMPOSTER_RESEARCH      = \"blockhutcomposter\";\n+    public static final String FLORIST_RESEARCH        = \"blockhutflorist\";", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/research/util/ResearchConstants.java b/src/api/java/com/minecolonies/api/research/util/ResearchConstants.java\nindex 6c4813fc47..c25959fc97 100755\n--- a/src/api/java/com/minecolonies/api/research/util/ResearchConstants.java\n+++ b/src/api/java/com/minecolonies/api/research/util/ResearchConstants.java\n\n@@ -47,103 +63,76 @@ public final class ResearchConstants\n     public static final int    NAME_OFFSET          = 30;\n     public static final int    INITIAL_Y_OFFSET     = 10;\n     public static final int    TEXT_X_OFFSET        = 5;\n-    public static final int    ICON_X_OFFSET        = 4;\n+    public static final int    ICON_X_OFFSET        = 3;\n     public static final int    ICON_Y_OFFSET        = 4;\n-    public static final int    XPBAR_Y_OFFSET       = 30;\n-    public static final int    XPBAR_LENGTH         = 90;\n-    public static final int    TEXT_Y_OFFSET        = 10;\n+    public static final int    ICON_WIDTH           = 15;\n+    public static final int    ICON_HEIGHT          = 17;\n+    public static final int    TEXT_Y_OFFSET        = 6;\n     public static final int    DEFAULT_COST_SIZE    = 16;\n-    public static final int    LOCK_WIDTH           = 15;\n-    public static final int    LOCK_HEIGHT          = 17;\n+    public static final int    RESEARCH_ICON_WIDTH  = 30;\n+    public static final int    RESEARCH_ICON_HEIGHT = 32;\n     public static final int    OR_X_OFFSET          = 14;\n     public static final int    OR_Y_OFFSET          = 10;\n     public static final int    OR_HEIGHT            = 16;\n     public static final int    OR_WIDTH             = 16;\n-    public static final int    TIME_HEIGHT          = 5;\n+    public static final int    TIME_HEIGHT          = 12;\n     public static final int    TIME_WIDTH           = 95;\n \n+    public static final boolean DRAW_ICONS = false;\n+\n     public static final int    COLOR_TEXT_NEGATIVE  = Color.rgbaToInt(218, 10, 10, 255);\n     public static final int    COLOR_TEXT_LABEL     = Color.rgbaToInt(218, 202, 171, 255);\n-    public static final int    COLOR_TEXT_LIGHT     = Color.rgbaToInt(60, 60, 60, 255);\n+    public static final int    COLOR_TEXT_DARK      = Color.rgbaToInt(60, 60, 60, 255);\n \n     /**\n      * Research Effect Name strings, used for ResearchEffectManager and ResearchRegistry lookups.\n      */\n     //Addition Multipliers\n-    public static final String ARCHER_DAMAGE                = \"archerdamageaddition\";\n-    public static final String CITIZEN_INV_SLOTS                    = \"citizeninvslotsaddition\";\n-    public static final String CITIZEN_CAP                  = \"citizencapaddition\";\n-    public static final String MECHANIC_ENHANCED_GATES      = \"enhancesgatedurabilityaddition\";\n-    public static final String FLEEING_SPEED                = \"fleeingspeedaddition\";\n-    public static final String SATLIMIT                     = \"healingsaturationlimitaddition\";\n-    public static final String HEALTH_BOOST                 = \"healthaddition\";\n-    public static final String MELEE_DAMAGE                 = \"meleedamageaddition\";\n-    public static final String WORK_LONGER                  = \"workingdayhaddition\";\n+    public static final String ARCHER_DAMAGE                = \"minecolonies:effects/archerdamageaddition\";\n+    public static final String CITIZEN_INV_SLOTS            = \"minecolonies:effects/citizeninvslotsaddition\";\n+    public static final String CITIZEN_CAP                  = \"minecolonies:effects/citizencapaddition\";\n+    public static final String MECHANIC_ENHANCED_GATES      = \"minecolonies:effects/enhancesgatedurabilityaddition\";\n+    public static final String FLEEING_SPEED                = \"minecolonies:effects/fleeingspeedaddition\";\n+    public static final String SATLIMIT                     = \"minecolonies:effects/healingsaturationlimitaddition\";\n+    public static final String HEALTH_BOOST                 = \"minecolonies:effects/healthaddition\";\n+    public static final String MELEE_DAMAGE                 = \"minecolonies:effects/meleedamageaddition\";\n+    public static final String WORK_LONGER                  = \"minecolonies:effects/workingdayhaddition\";\n \n     //Multiplier Modifiers\n-    public static final String ARCHER_ARMOR      = \"archerarmormultiplier\";\n-    public static final String ARMOR_DURABILITY  = \"armordurabilitymultiplier\";\n-    public static final String BLOCK_ATTACKS     = \"blockattacksmultiplier\";\n-    public static final String BLOCK_BREAK_SPEED = \"blockbreakspeedmultiplier\";\n-    public static final String BLOCK_PLACE_SPEED = \"blockplacespeedmultiplier\";\n-    public static final String DOUBLE_ARROWS     = \"doublearrowsmultiplier\";\n-    public static final String FARMING           = \"farmingmultiplier\";\n-    public static final String FLEEING_DAMAGE    = \"fleeingdamagemultiplier\";;\n-    public static final String GROWTH            = \"growthmultiplier\";\n-    public static final String HAPPINESS         = \"happinessmultiplier\";\n-    public static final String LEVELING          = \"levelingmultiplier\";\n-    public static final String MELEE_ARMOR       = \"meleearmormultiplier\";\n-    public static final String MINIMUM_STOCK     = \"minimumstockmultiplier\";\n-    public static final String MORE_ORES         = \"moreoresmultiplier\";\n-    public static final String RECIPES           = \"recipesmultiplier\";\n-    public static final String REGENERATION      = \"regenerationmultiplier\";\n-    public static final String SATURATION        = \"saturationmultiplier\";\n-    public static final String SLEEP_LESS        = \"sleeplessmultiplier\";\n-    public static final String TEACHING          = \"teachingmultiplier\";\n-    public static final String TOOL_DURABILITY   = \"tooldurabilitymultiplier\";\n-    public static final String WALKING           = \"walkingmultiplier\";\n+    public static final String ARCHER_ARMOR      = \"minecolonies:effects/archerarmormultiplier\";\n+    public static final String ARMOR_DURABILITY  = \"minecolonies:effects/armordurabilitymultiplier\";\n+    public static final String BLOCK_ATTACKS     = \"minecolonies:effects/blockattacksmultiplier\";\n+    public static final String BLOCK_BREAK_SPEED = \"minecolonies:effects/blockbreakspeedmultiplier\";\n+    public static final String BLOCK_PLACE_SPEED = \"minecolonies:effects/blockplacespeedmultiplier\";\n+    public static final String DOUBLE_ARROWS     = \"minecolonies:effects/doublearrowsmultiplier\";\n+    public static final String FARMING           = \"minecolonies:effects/farmingmultiplier\";\n+    public static final String FLEEING_DAMAGE    = \"minecolonies:effects/fleeingdamagemultiplier\";\n+    public static final String GROWTH            = \"minecolonies:effects/growthmultiplier\";\n+    public static final String HAPPINESS         = \"minecolonies:effects/happinessmultiplier\";\n+    public static final String LEVELING          = \"minecolonies:effects/levelingmultiplier\";\n+    public static final String MELEE_ARMOR       = \"minecolonies:effects/meleearmormultiplier\";\n+    public static final String MINIMUM_STOCK     = \"minecolonies:effects/minimumstockmultiplier\";\n+    public static final String MORE_ORES         = \"minecolonies:effects/moreoresmultiplier\";\n+    public static final String RECIPES           = \"minecolonies:effects/recipesmultiplier\";\n+    public static final String REGENERATION      = \"minecolonies:effects/regenerationmultiplier\";\n+    public static final String SATURATION        = \"minecolonies:effects/saturationmultiplier\";\n+    public static final String SLEEP_LESS        = \"minecolonies:effects/sleeplessmultiplier\";\n+    public static final String TEACHING          = \"minecolonies:effects/teachingmultiplier\";\n+    public static final String TOOL_DURABILITY   = \"minecolonies:effects/tooldurabilitymultiplier\";\n+    public static final String WALKING           = \"minecolonies:effects/walkingmultiplier\";\n \n     //Unlock Ability modifiers.\n-    public static final String CRUSHING_11       = \"crushing11unlock\";\n-    public static final String ARCHER_USE_ARROWS = \"consumearrowsunlock\";\n-    public static final String KNIGHT_TAUNT      = \"knighttauntmobsunlock\";\n-    public static final String FIRE_RES          = \"minerfireresunlock\";\n-    public static final String ARROW_PIERCE      = \"piercingarrowsunlock\";\n-    public static final String PLANT_2           = \"plant2unlock\";\n-    public static final String RAILS             = \"railsunlock\";\n-    public static final String RETREAT           = \"retreatunlock\";\n-    public static final String SHIELD_USAGE      = \"shieldusageunlock\";\n-    public static final String KNIGHT_WHIRLWIND  = \"whirlwindabilityunlock\";\n-    public static final String WORKING_IN_RAIN   = \"workinginrainunlock\";\n-\n-    /* // Recipe-only unlocks don't really need specific effects.  Leaving here in case we do want to add AbilityEffects to them.\n-    /public static final String END_KNOWLEDGE     = \"knowledgeoftheendunlock\";\n-    /public static final String MORE_SCROLLS      = \"morescrollsunlock\";\n-     */\n-\n-    //Unlock Building modifiers.\n-    /*public static final String COMPOSTER_RESEARCH      = \"blockhutcomposter\";\n-    public static final String FLORIST_RESEARCH        = \"blockhutflorist\";\n-    public static final String DYER_RESEARCH           = \"blockhutdyer\";\n-    public static final String CONCRETE_MIXER_RESEARCH = \"blockhutconcretemixer\";\n-    public static final String PLANTATION_RESEARCH     = \"blockhutplantation\";\n-    public static final String SMELTERY_RESEARCH       = \"blockhutsmeltery\";\n-    public static final String STONESMELTERY_RESEARCH  = \"blockhutstonesmeltery\";\n-    public static final String CRUSHER_RESEARCH        = \"blockhutcrusher\";\n-    public static final String GLASSBLOWER_RESEARCH    = \"blockhutglassblower\";\n-    public static final String SAWMILL_RESEARCH        = \"blockhutsawmill\";\n-    public static final String SIFTER_RESEARCH         = \"blockhutsifter\";\n-    public static final String FLETCHER_RESEARCH       = \"blockhutfletcher\";\n-    public static final String BLACKSMITH_RESEARCH     = \"blockhutblacksmith\";\n-    public static final String STONEMASON_RESEARCH     = \"blockhutstonemason\";\n-    public static final String MECHANIC_RESEARCH       = \"blockhutmechanic\";\n-    public static final String SCHOOL_RESEARCH         = \"blockhutschool\";\n-    public static final String LIBRARY_RESEARCH        = \"blockhutlibrary\";\n-    public static final String HOSPITAL_RESEARCH       = \"blockhuthospital\";\n-    public static final String BARRACKS_RESEARCH       = \"blockhutbarracks\";\n-    public static final String COMBAT_ACADEMY_RESEARCH = \"blockhutcombatacademy\";\n-    public static final String ARCHERY_RESEARCH        = \"blockhutarchery\";\n-     */\n+    public static final String CRUSHING_11       = \"minecolonies:effects/crushing11unlock\";\n+    public static final String ARCHER_USE_ARROWS = \"minecolonies:effects/consumearrowsunlock\";\n+    public static final String KNIGHT_TAUNT      = \"minecolonies:effects/knighttauntmobsunlock\";\n+    public static final String FIRE_RES          = \"minecolonies:effects/minerfireresunlock\";\n+    public static final String ARROW_PIERCE      = \"minecolonies:effects/piercingarrowsunlock\";\n+    public static final String PLANT_2           = \"minecolonies:effects/plant2unlock\";\n+    public static final String RAILS             = \"minecolonies:effects/railsunlock\";\n+    public static final String RETREAT           = \"minecolonies:effects/retreatunlock\";\n+    public static final String SHIELD_USAGE      = \"minecolonies:effects/shieldusageunlock\";\n+    public static final String KNIGHT_WHIRLWIND  = \"minecolonies:effects/whirlwindabilityunlock\";\n+    public static final String WORKING_IN_RAIN   = \"minecolonies:effects/workinginrainunlock\";\n \n     /**\n      * Private constructor to hide implicit public one.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3NzUxNA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548477514", "bodyText": "Not 100% happy with all this. It's probably better to first loop over all and do a count of the inventory and if the count is fine we loop and remove. For both we have utils already. I know it's a bit less efficient but this is \"on button press\" logic that is executed not so often, so it should be fine", "author": "Raycoms", "createdAt": "2020-12-24T10:06:19Z", "path": "src/api/java/com/minecolonies/api/util/InventoryUtils.java", "diffHunk": "@@ -2156,12 +2156,58 @@ public static boolean tryRemoveStackFromItemHandler(final IItemHandler handler,\n         return false;\n     }\n \n+    /**\n+     * Tries to remove a group of stacks with its size from a given Itemhandler. Only removes stacks if every stack's full count is present.\n+     *\n+     * @param handler      the itemHandler.\n+     * @param input        the stack to remove.\n+     * @return true if removed the stack\n+     */\n+    public static boolean tryRemoveStackFromItemHandler(final IItemHandler handler, final List<ItemStorage> input)\n+    {\n+        List<ItemStack> removedItems = new ArrayList<>();\n+        for(final ItemStorage is : input)\n+        {\n+            int amount = is.getItemStack().getCount();\n+\n+            for (int i = 0; i < handler.getSlots(); i++)\n+            {\n+                if (ItemStackUtils.compareItemStacksIgnoreStackSize(handler.getStackInSlot(i), is.getItemStack(), !is.ignoreDamageValue(), !is.ignoreNBT()))\n+                {\n+                    amount = amount - handler.extractItem(i, amount, false).getCount();", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5Mjc1MQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548492751", "bodyText": "Wasn\u2019t sure on that myself. Want the non-List variant of the method changed as well?", "author": "gattsuru", "createdAt": "2020-12-24T10:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3NzUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5MzUwOA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548493508", "bodyText": "sure", "author": "Raycoms", "createdAt": "2020-12-24T11:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3NzUxNA=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/util/InventoryUtils.java b/src/api/java/com/minecolonies/api/util/InventoryUtils.java\nindex 24797476b8..e24c98d4a7 100755\n--- a/src/api/java/com/minecolonies/api/util/InventoryUtils.java\n+++ b/src/api/java/com/minecolonies/api/util/InventoryUtils.java\n\n@@ -2149,30 +2180,34 @@ public class InventoryUtils\n                 }\n             }\n         }\n-\n-        final ItemStack revertStack = input.copy();\n-        revertStack.setCount(input.getCount() - amount);\n-        addItemStackToItemHandler(handler, revertStack);\n+        // This should never happen.\n         return false;\n     }\n \n     /**\n-     * Tries to remove a group of stacks with its size from a given Itemhandler. Only removes stacks if every stack's full count is present.\n+     * Tries to remove a group of ItemStorages with its size from a given ItemHandler. Only removes stacks if every stack's full count is present.\n      *\n      * @param handler      the itemHandler.\n-     * @param input        the stack to remove.\n-     * @return true if removed the stack\n+     * @param input        the List of ItemStorage to remove.\n+     * @return true if removed the stacks\n      */\n-    public static boolean tryRemoveStackFromItemHandler(final IItemHandler handler, final List<ItemStorage> input)\n+    public static boolean tryRemoveStorageFromItemHandler(final IItemHandler handler, final List<ItemStorage> input)\n     {\n-        List<ItemStack> removedItems = new ArrayList<>();\n+        for(final ItemStorage is : input)\n+        {\n+            if(!hasItemStackInItemHandler(handler, is.getItemStack(), is.ignoreDamageValue(), is.ignoreNBT()))\n+            {\n+                return false;\n+            }\n+        }\n+\n         for(final ItemStorage is : input)\n         {\n             int amount = is.getItemStack().getCount();\n \n             for (int i = 0; i < handler.getSlots(); i++)\n             {\n-                if (ItemStackUtils.compareItemStacksIgnoreStackSize(handler.getStackInSlot(i), is.getItemStack(), !is.ignoreDamageValue(), !is.ignoreNBT()))\n+                if (ItemStackUtils.compareItemStacksIgnoreStackSize(handler.getStackInSlot(i), is.getItemStack()))\n                 {\n                     amount = amount - handler.extractItem(i, amount, false).getCount();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3ODAxMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548478011", "bodyText": "no return type", "author": "Raycoms", "createdAt": "2020-12-24T10:07:55Z", "path": "src/api/java/com/minecolonies/api/util/InventoryUtils.java", "diffHunk": "@@ -2156,12 +2156,58 @@ public static boolean tryRemoveStackFromItemHandler(final IItemHandler handler,\n         return false;\n     }\n \n+    /**\n+     * Tries to remove a group of stacks with its size from a given Itemhandler. Only removes stacks if every stack's full count is present.\n+     *\n+     * @param handler      the itemHandler.\n+     * @param input        the stack to remove.\n+     * @return true if removed the stack\n+     */\n+    public static boolean tryRemoveStackFromItemHandler(final IItemHandler handler, final List<ItemStorage> input)\n+    {\n+        List<ItemStack> removedItems = new ArrayList<>();\n+        for(final ItemStorage is : input)\n+        {\n+            int amount = is.getItemStack().getCount();\n+\n+            for (int i = 0; i < handler.getSlots(); i++)\n+            {\n+                if (ItemStackUtils.compareItemStacksIgnoreStackSize(handler.getStackInSlot(i), is.getItemStack(), !is.ignoreDamageValue(), !is.ignoreNBT()))\n+                {\n+                    amount = amount - handler.extractItem(i, amount, false).getCount();\n+\n+                    if (amount == 0)\n+                    {\n+                        break;\n+                    }\n+                }\n+            }\n+            if(amount == 0)\n+            {\n+                removedItems.add(is.getItemStack());\n+            }\n+            else\n+            {\n+                final ItemStack revertStack = is.getItemStack().copy();\n+                revertStack.setCount(is.getItemStack().getCount() - amount);\n+                addItemStackToItemHandler(handler, revertStack);\n+                for(final ItemStack returnItems : removedItems)\n+                {\n+                    addItemStackToItemHandler(handler, returnItems);\n+                }\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n     /**\n      * Force remove a stack with a certain amount from a given Itemhandler\n      *\n      * @param handler the itemHandler.\n      * @param input   the stack to remove.\n      * @param count   the amount to remove.\n+     * @return        true if the requested count was successfully removed.", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/api/java/com/minecolonies/api/util/InventoryUtils.java b/src/api/java/com/minecolonies/api/util/InventoryUtils.java\nindex 24797476b8..e24c98d4a7 100755\n--- a/src/api/java/com/minecolonies/api/util/InventoryUtils.java\n+++ b/src/api/java/com/minecolonies/api/util/InventoryUtils.java\n\n@@ -2149,30 +2180,34 @@ public class InventoryUtils\n                 }\n             }\n         }\n-\n-        final ItemStack revertStack = input.copy();\n-        revertStack.setCount(input.getCount() - amount);\n-        addItemStackToItemHandler(handler, revertStack);\n+        // This should never happen.\n         return false;\n     }\n \n     /**\n-     * Tries to remove a group of stacks with its size from a given Itemhandler. Only removes stacks if every stack's full count is present.\n+     * Tries to remove a group of ItemStorages with its size from a given ItemHandler. Only removes stacks if every stack's full count is present.\n      *\n      * @param handler      the itemHandler.\n-     * @param input        the stack to remove.\n-     * @return true if removed the stack\n+     * @param input        the List of ItemStorage to remove.\n+     * @return true if removed the stacks\n      */\n-    public static boolean tryRemoveStackFromItemHandler(final IItemHandler handler, final List<ItemStorage> input)\n+    public static boolean tryRemoveStorageFromItemHandler(final IItemHandler handler, final List<ItemStorage> input)\n     {\n-        List<ItemStack> removedItems = new ArrayList<>();\n+        for(final ItemStorage is : input)\n+        {\n+            if(!hasItemStackInItemHandler(handler, is.getItemStack(), is.ignoreDamageValue(), is.ignoreNBT()))\n+            {\n+                return false;\n+            }\n+        }\n+\n         for(final ItemStorage is : input)\n         {\n             int amount = is.getItemStack().getCount();\n \n             for (int i = 0; i < handler.getSlots(); i++)\n             {\n-                if (ItemStackUtils.compareItemStacksIgnoreStackSize(handler.getStackInSlot(i), is.getItemStack(), !is.ignoreDamageValue(), !is.ignoreNBT()))\n+                if (ItemStackUtils.compareItemStacksIgnoreStackSize(handler.getStackInSlot(i), is.getItemStack()))\n                 {\n                     amount = amount - handler.extractItem(i, amount, false).getCount();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3ODI3OA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548478278", "bodyText": "What, how were those two not here?", "author": "Raycoms", "createdAt": "2020-12-24T10:08:47Z", "path": "src/main/java/com/minecolonies/apiimp/initializer/ModBuildingsInitializer.java", "diffHunk": "@@ -33,6 +33,13 @@ public static void init(final RegistryEvent.Register<BuildingEntry> event)\n                                  .setRegistryName(new ResourceLocation(Constants.MOD_ID, ModBuildings.ARCHERY_ID))\n                                  .createBuildingEntry();\n \n+        ModBuildings.baker = new BuildingEntry.Builder()", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5MTk2Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548491963", "bodyText": "They\u2019re present as bakery and home, respectively.  This is kinda a hacky workaround, but too many places this code touches straddle between the code-side, desc, blockdesc, and user-side hard coded names.\nI\u2019m open to any smarter or more elegant solution; the duplicate entries just seemed the ones least likely to have a negative impact or confuse actual devs by renaming classes or screwing with internal static strings.", "author": "gattsuru", "createdAt": "2020-12-24T10:55:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3ODI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5MjY4Mg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548492682", "bodyText": "Ohh, we shouldn't have duplicate entries at all. I'd prefer renaming the original one then.", "author": "Raycoms", "createdAt": "2020-12-24T10:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3ODI3OA=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/apiimp/initializer/ModBuildingsInitializer.java b/src/main/java/com/minecolonies/apiimp/initializer/ModBuildingsInitializer.java\nindex 8b620b2bf6..f4efe349aa 100755\n--- a/src/main/java/com/minecolonies/apiimp/initializer/ModBuildingsInitializer.java\n+++ b/src/main/java/com/minecolonies/apiimp/initializer/ModBuildingsInitializer.java\n\n@@ -33,13 +33,6 @@ public final class ModBuildingsInitializer\n                                  .setRegistryName(new ResourceLocation(Constants.MOD_ID, ModBuildings.ARCHERY_ID))\n                                  .createBuildingEntry();\n \n-        ModBuildings.baker = new BuildingEntry.Builder()\n-                                .setBuildingBlock(ModBlocks.blockHutBaker)\n-                                .setBuildingProducer(BuildingBaker::new)\n-                                .setBuildingViewProducer(() -> BuildingBaker.View::new)\n-                                .setRegistryName(new ResourceLocation(Constants.MOD_ID, ModBuildings.BAKER_ID))\n-                                .createBuildingEntry();\n-\n         ModBuildings.bakery = new BuildingEntry.Builder()\n                                 .setBuildingBlock(ModBlocks.blockHutBaker)\n                                 .setBuildingProducer(BuildingBaker::new)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3ODQ3OA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548478478", "bodyText": "weird", "author": "Raycoms", "createdAt": "2020-12-24T10:09:22Z", "path": "src/main/java/com/minecolonies/coremod/blocks/huts/BlockHutChickenHerder.java", "diffHunk": "@@ -19,9 +19,7 @@ public BlockHutChickenHerder()\n     @NotNull\n     @Override\n     public String getName()\n-    {\n-        return \"blockhutchickenherder\";\n-    }\n+    { return \"blockhutchickenherder\"; }", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/blocks/huts/BlockHutChickenHerder.java b/src/main/java/com/minecolonies/coremod/blocks/huts/BlockHutChickenHerder.java\nindex 29a7fdd769..0aba20dfda 100755\n--- a/src/main/java/com/minecolonies/coremod/blocks/huts/BlockHutChickenHerder.java\n+++ b/src/main/java/com/minecolonies/coremod/blocks/huts/BlockHutChickenHerder.java\n\n@@ -19,7 +19,9 @@ public class BlockHutChickenHerder extends AbstractBlockHut<BlockHutChickenHerde\n     @NotNull\n     @Override\n     public String getName()\n-    { return \"blockhutchickenherder\"; }\n+    {\n+        return \"blockhutchickenherder\";\n+    }\n \n     @Override\n     public BuildingEntry getBuildingEntry()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3ODgwNw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548478807", "bodyText": "formatting", "author": "Raycoms", "createdAt": "2020-12-24T10:10:25Z", "path": "src/main/java/com/minecolonies/coremod/blocks/huts/BlockHutComposter.java", "diffHunk": "@@ -22,15 +21,5 @@ public String getName()\n     }\n \n     @Override\n-    public BuildingEntry getBuildingEntry()\n-    {\n-        return ModBuildings.composter;\n-    }\n-\n-    @Override\n-    @OnlyIn(Dist.CLIENT)\n-    public void checkResearch(final IColonyView colony)\n-    {\n-        checkResearch(colony, ResearchInitializer.COMPOSTER_RESEARCH);\n-    }\n+    public BuildingEntry getBuildingEntry() { return ModBuildings.composter; }", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/blocks/huts/BlockHutComposter.java b/src/main/java/com/minecolonies/coremod/blocks/huts/BlockHutComposter.java\nindex 890d1c7d2f..bc4a8ecf8c 100755\n--- a/src/main/java/com/minecolonies/coremod/blocks/huts/BlockHutComposter.java\n+++ b/src/main/java/com/minecolonies/coremod/blocks/huts/BlockHutComposter.java\n\n@@ -21,5 +17,8 @@ public class BlockHutComposter extends AbstractBlockHut<BlockHutComposter>\n     }\n \n     @Override\n-    public BuildingEntry getBuildingEntry() { return ModBuildings.composter; }\n+    public BuildingEntry getBuildingEntry()\n+    {\n+        return ModBuildings.composter;\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3OTUwNw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548479507", "bodyText": "return empty list here already?", "author": "Raycoms", "createdAt": "2020-12-24T10:12:57Z", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutUniversity.java", "diffHunk": "@@ -36,19 +44,105 @@ public WindowHutUniversity(final BuildingUniversity.View building)\n \n         final View view = this.findPaneOfTypeByID(BRANCH_VIEW_ID, View.class);\n         int offset = 0;\n-        for (final String branch : IGlobalResearchTree.getInstance().getBranches())\n+        // For now, sort research branches by name, as they may be loaded in any order.\n+        branches.addAll(IGlobalResearchTree.getInstance().getBranches());\n+        branches.sort(Comparator.comparing(String::toString, String.CASE_INSENSITIVE_ORDER));\n+        for (final String branch : branches)\n         {\n-            final ButtonImage button = new ButtonImage();\n-            button.setImage(new ResourceLocation(Constants.MOD_ID, MEDIUM_SIZED_BUTTON_RES));\n-            button.setLabel(branch);\n-            button.setSize(BUTTON_LENGTH, BUTTON_HEIGHT);\n-            button.setTextColor(SLIGHTLY_BLUE);\n-            button.setPosition(x + INITITAL_X_OFFSET, y + offset + INITITAL_Y_OFFSET);\n-            view.addChild(button);\n-            branches.add(branch);\n+            List<IFormattableTextComponent> requirements = getHidingRequirementDesc(branch);\n+            if(requirements.isEmpty())\n+            {\n+                final ButtonImage button = new ButtonImage();\n+                button.setImage(new ResourceLocation(Constants.MOD_ID, MEDIUM_SIZED_BUTTON_RES));\n+                button.setLabel(branch);\n+                button.setSize(BUTTON_LENGTH, BUTTON_HEIGHT);\n+                button.setTextColor(SLIGHTLY_BLUE);\n+                button.setPosition(x + INITITAL_X_OFFSET, y + offset + INITITAL_Y_OFFSET);\n+                view.addChild(button);\n \n-            offset += button.getHeight() + BUTTON_PADDING;\n+                offset += button.getHeight() + BUTTON_PADDING;\n+            }\n+            else\n+            {\n+                final Gradient gradient = new Gradient();\n+                gradient.setSize(BUTTON_LENGTH, BUTTON_HEIGHT);\n+                gradient.setPosition(x + INITITAL_X_OFFSET, y + offset + INITITAL_Y_OFFSET);\n+                gradient.setGradientStart(239, 230, 215, 255);\n+                gradient.setGradientEnd(239, 230, 215, 255);\n+                gradient.setHoverToolTip(requirements);\n+                view.addChild(gradient);\n+                final ButtonImage button = new ButtonImage();\n+                button.setImage(new ResourceLocation(Constants.MOD_ID, MEDIUM_SIZED_BUTTON_RES));\n+                button.setLabel(\"-----------\");\n+                button.setSize(BUTTON_LENGTH, BUTTON_HEIGHT);\n+                button.setTextColor(SLIGHTLY_BLUE);\n+                button.setPosition(x + INITITAL_X_OFFSET, y + offset + INITITAL_Y_OFFSET);\n+                view.addChild(button);\n+\n+                offset += button.getHeight() + BUTTON_PADDING;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets a list describing what requirements must be met to make at least one primary research for a branch visible.\n+     *\n+     * @param branch  The identifier for a branch.\n+     * @return An empty list if at least one primary research is visible, or a list of IFormattableTextComponents describing the dependencies for each hidden primary research.\n+     */\n+    public List<IFormattableTextComponent> getHidingRequirementDesc(final String branch)\n+    {\n+        final List<IFormattableTextComponent> requirements = new ArrayList<>();\n+        for(final String primary : IGlobalResearchTree.getInstance().getPrimaryResearch(branch))\n+        {\n+            if(!IGlobalResearchTree.getInstance().getResearch(branch, primary).isHidden()\n+                 || IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(IGlobalResearchTree.getInstance().getResearch(branch, primary).getResearchRequirement(), building.getColony()))\n+            {\n+                requirements.clear();\n+                break;\n+            }", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5ODE1NQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548498155", "bodyText": "Yes. The goal is to have the branch locked until one Research is visible. If any one is complete, we don\u2019t want to show a tooltip regarding the others, or require all of the primary research to be unlocked before you can start any of them.", "author": "gattsuru", "createdAt": "2020-12-24T11:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3OTUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5OTEwNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548499105", "bodyText": "I mean, instead of break and clear, we can just return Collections.emptyList(), no?", "author": "Raycoms", "createdAt": "2020-12-24T11:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3OTUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMzk0Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548503946", "bodyText": "Oh. Yeah, derp on my part.", "author": "gattsuru", "createdAt": "2020-12-24T11:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ3OTUwNw=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/client/gui/WindowHutUniversity.java b/src/main/java/com/minecolonies/coremod/client/gui/WindowHutUniversity.java\nindex 1ecb5bf670..26b8ae9d60 100755\n--- a/src/main/java/com/minecolonies/coremod/client/gui/WindowHutUniversity.java\n+++ b/src/main/java/com/minecolonies/coremod/client/gui/WindowHutUniversity.java\n\n@@ -54,7 +55,8 @@ public class WindowHutUniversity extends AbstractWindowWorkerBuilding<BuildingUn\n             {\n                 final ButtonImage button = new ButtonImage();\n                 button.setImage(new ResourceLocation(Constants.MOD_ID, MEDIUM_SIZED_BUTTON_RES));\n-                button.setLabel(branch);\n+                button.setLabel(IGlobalResearchTree.getInstance().getBranchName(branch));\n+                button.setID(branch);\n                 button.setSize(BUTTON_LENGTH, BUTTON_HEIGHT);\n                 button.setTextColor(SLIGHTLY_BLUE);\n                 button.setPosition(x + INITITAL_X_OFFSET, y + offset + INITITAL_Y_OFFSET);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4MjcyNA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548482724", "bodyText": "can also probably cleaned up", "author": "Raycoms", "createdAt": "2020-12-24T10:23:27Z", "path": "src/main/java/com/minecolonies/coremod/colony/ColonyManager.java", "diffHunk": "@@ -11,6 +11,7 @@\n import com.minecolonies.api.compatibility.ICompatibilityManager;\n import com.minecolonies.api.crafting.IRecipeManager;\n import com.minecolonies.api.items.ModTags;\n+import com.minecolonies.api.research.IGlobalResearchTree;\n import com.minecolonies.api.util.ItemStackUtils;", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/ColonyManager.java b/src/main/java/com/minecolonies/coremod/colony/ColonyManager.java\nindex bf161e7bd2..291792cbaf 100755\n--- a/src/main/java/com/minecolonies/coremod/colony/ColonyManager.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/ColonyManager.java\n\n@@ -11,7 +11,6 @@ import com.minecolonies.api.compatibility.CompatibilityManager;\n import com.minecolonies.api.compatibility.ICompatibilityManager;\n import com.minecolonies.api.crafting.IRecipeManager;\n import com.minecolonies.api.items.ModTags;\n-import com.minecolonies.api.research.IGlobalResearchTree;\n import com.minecolonies.api.util.ItemStackUtils;\n import com.minecolonies.api.util.Log;\n import com.minecolonies.apiimp.initializer.ModTagsInitializer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4MzMzMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548483331", "bodyText": "Can those also be cleaned up?", "author": "Raycoms", "createdAt": "2020-12-24T10:25:22Z", "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java", "diffHunk": "@@ -7,25 +7,33 @@\n import com.minecolonies.api.colony.buildings.IBuilding;\n import com.minecolonies.api.colony.buildings.ModBuildings;\n import com.minecolonies.api.colony.buildings.registry.BuildingEntry;\n+import com.minecolonies.api.colony.buildings.views.IBuildingView;\n import com.minecolonies.api.colony.buildings.workerbuildings.ITownHall;\n import com.minecolonies.api.colony.buildings.workerbuildings.ITownHallView;\n import com.minecolonies.api.colony.colonyEvents.descriptions.IColonyEventDescription;\n import com.minecolonies.api.colony.colonyEvents.registry.ColonyEventDescriptionTypeRegistryEntry;\n import com.minecolonies.api.colony.permissions.PermissionEvent;\n+import com.minecolonies.api.research.*;\n import com.minecolonies.api.util.Log;\n+import com.minecolonies.api.util.constant.TranslationConstants;\n import com.minecolonies.coremod.MineColonies;\n import com.minecolonies.coremod.client.gui.WindowTownHall;\n import com.minecolonies.coremod.colony.buildings.AbstractBuilding;\n import com.minecolonies.coremod.colony.buildings.views.AbstractBuildingView;\n \n+import com.minecolonies.coremod.research.BuildingResearchRequirement;\n+import com.minecolonies.coremod.research.ResearchResearchRequirement;\n+import net.minecraft.client.Minecraft;", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\nindex e481671a47..2a44d4ece1 100755\n--- a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingTownHall.java\n\n@@ -7,33 +7,24 @@ import com.minecolonies.api.colony.IColonyView;\n import com.minecolonies.api.colony.buildings.IBuilding;\n import com.minecolonies.api.colony.buildings.ModBuildings;\n import com.minecolonies.api.colony.buildings.registry.BuildingEntry;\n-import com.minecolonies.api.colony.buildings.views.IBuildingView;\n import com.minecolonies.api.colony.buildings.workerbuildings.ITownHall;\n import com.minecolonies.api.colony.buildings.workerbuildings.ITownHallView;\n import com.minecolonies.api.colony.colonyEvents.descriptions.IColonyEventDescription;\n import com.minecolonies.api.colony.colonyEvents.registry.ColonyEventDescriptionTypeRegistryEntry;\n import com.minecolonies.api.colony.permissions.PermissionEvent;\n-import com.minecolonies.api.research.*;\n import com.minecolonies.api.util.Log;\n-import com.minecolonies.api.util.constant.TranslationConstants;\n import com.minecolonies.coremod.MineColonies;\n import com.minecolonies.coremod.client.gui.WindowTownHall;\n import com.minecolonies.coremod.colony.buildings.AbstractBuilding;\n import com.minecolonies.coremod.colony.buildings.views.AbstractBuildingView;\n \n-import com.minecolonies.coremod.research.BuildingResearchRequirement;\n-import com.minecolonies.coremod.research.ResearchResearchRequirement;\n-import net.minecraft.client.Minecraft;\n-import net.minecraft.entity.player.PlayerEntity;\n import net.minecraft.network.PacketBuffer;\n import net.minecraft.util.ResourceLocation;\n import net.minecraft.util.math.BlockPos;\n-import net.minecraft.util.text.TranslationTextComponent;\n import org.jetbrains.annotations.NotNull;\n \n import java.util.*;\n \n-import static com.minecolonies.api.research.util.ResearchConstants.BASE_RESEARCH_TIME;\n import static com.minecolonies.api.util.constant.ColonyConstants.MAX_COLONY_EVENTS;\n import static com.minecolonies.api.util.constant.Constants.MOD_ID;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4MzY3MQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548483671", "bodyText": "We shouldn't use I18n.format, can't we just give it a TranslationTextComponent?", "author": "Raycoms", "createdAt": "2020-12-24T10:26:30Z", "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingUniversity.java", "diffHunk": "@@ -241,8 +244,7 @@ public void onSuccess(final ILocalResearch research)\n         }\n \n         LanguageHandler.sendPlayersMessage(colony.getMessagePlayerEntities(),\n-          RESEARCH_CONCLUDED + random.nextInt(3),\n-          IGlobalResearchTree.getInstance().getResearch(research.getBranch(), research.getId()).getDesc());\n+          RESEARCH_CONCLUDED + random.nextInt(3), I18n.format(IGlobalResearchTree.getInstance().getResearch(research.getBranch(), research.getId()).getDesc()));", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5NjQxMg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548496412", "bodyText": "I\u2019ll take another shot at doing it that way, if it\u2019s possible.  Was having a hell of a time with TranslationTextComponents not handling insert of a translated text into a %s, and instead doing an appended of translated text.", "author": "gattsuru", "createdAt": "2020-12-24T11:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4MzY3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5NzUwMA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548497500", "bodyText": "Because formatting on the server side, afaik, will only ever return english translations to people.\nYou could try to wrap a translationcomponent inside a string component, that might work if the other doesn't.", "author": "Raycoms", "createdAt": "2020-12-24T11:15:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4MzY3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc3ODgwMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548778801", "bodyText": "Looks like it's a part of the logic in https://github.com/ldtteam/Structurize/blob/version/1.16.3/src/main/java/com/ldtteam/structurize/util/LanguageHandler.java 's buildChatComponent to treat ITextComponents of any type as appends.  Probably easier to work around it for this case, ugly as the hack would be, than to revamp it there.", "author": "gattsuru", "createdAt": "2020-12-25T02:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4MzY3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5MjQxNw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548792417", "bodyText": "Yeah, SendPlayersMessage is painful with it's behavior on TranslationTextComponent.\nIf you look in AbstractBuildingWorker|ImproveRecipe you can see a similar chunk of code that is very simple and does the replacements the way you expect.", "author": "Mekle001", "createdAt": "2020-12-25T03:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4MzY3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingUniversity.java b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingUniversity.java\nindex 48fdc1c558..d006870b4b 100755\n--- a/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingUniversity.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingUniversity.java\n\n@@ -243,8 +243,14 @@ public class BuildingUniversity extends AbstractBuildingWorker\n             citizen.applyResearchEffects();\n         }\n \n-        LanguageHandler.sendPlayersMessage(colony.getMessagePlayerEntities(),\n-          RESEARCH_CONCLUDED + random.nextInt(3), I18n.format(IGlobalResearchTree.getInstance().getResearch(research.getBranch(), research.getId()).getDesc()));\n+        final TranslationTextComponent message = new TranslationTextComponent(RESEARCH_CONCLUDED + ThreadLocalRandom.current().nextInt(3),\n+          new TranslationTextComponent(IGlobalResearchTree.getInstance().getResearch(research.getBranch(), research.getId()).getName()));\n+\n+        for(PlayerEntity player : colony.getMessagePlayerEntities())\n+        {\n+            player.sendMessage(message, player.getUniqueID());\n+        }\n+        colony.getResearchManager().checkAutoStartResearch(colony);\n         this.markDirty();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4NDIzNw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548484237", "bodyText": "What is this todo for?", "author": "Raycoms", "createdAt": "2020-12-24T10:28:20Z", "path": "src/main/java/com/minecolonies/coremod/colony/managers/CitizenManager.java", "diffHunk": "@@ -463,16 +462,11 @@ public int getPotentialMaxCitizens()\n      */\n     private double maxCitizensFromResearch()\n     {\n-        double max = 25;\n-        final AdditionModifierResearchEffect effect = colony.getResearchManager().getResearchEffects().getEffect(CAP, AdditionModifierResearchEffect.class);\n-        if (effect != null)\n+        final double max = 25 + colony.getResearchManager().getResearchEffects().getEffectValue(CITIZEN_CAP);\n+        // TODO research data rework\n+        if (max >= MineColonies.getConfig().getServer().maxCitizenPerColony.get())", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4OTY5Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548489693", "bodyText": "No clue.  Was present before I started, and I don\u2019t think I finished it.  Presumably want to handle broader max citizen caps, but I don\u2019t have enough experience with big colonies to be comfortable changing that behavior", "author": "gattsuru", "createdAt": "2020-12-24T10:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4NDIzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5MTczNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548491735", "bodyText": "You can remove it then.", "author": "Raycoms", "createdAt": "2020-12-24T10:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4NDIzNw=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/managers/CitizenManager.java b/src/main/java/com/minecolonies/coremod/colony/managers/CitizenManager.java\nindex 175f34c777..36e442bc58 100755\n--- a/src/main/java/com/minecolonies/coremod/colony/managers/CitizenManager.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/managers/CitizenManager.java\n\n@@ -463,10 +463,9 @@ public class CitizenManager implements ICitizenManager\n     private double maxCitizensFromResearch()\n     {\n         final double max = 25 + colony.getResearchManager().getResearchEffects().getEffectValue(CITIZEN_CAP);\n-        // TODO research data rework\n         if (max >= MineColonies.getConfig().getServer().maxCitizenPerColony.get())\n         {\n-            return MineColonies.getConfig().getServer().maxCitizenPerColony.get() - 25;\n+            return MineColonies.getConfig().getServer().maxCitizenPerColony.get();\n         }\n         return max;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4NDc1OA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548484758", "bodyText": "I'm not fully sure I grasp the idea behind Auto start research. What are the use cases for it? Don't we need a university for this too?", "author": "Raycoms", "createdAt": "2020-12-24T10:29:57Z", "path": "src/main/java/com/minecolonies/coremod/colony/managers/ResearchManager.java", "diffHunk": "@@ -45,4 +80,123 @@ public IResearchEffectManager getResearchEffects()\n     {\n         return this.effects;\n     }\n+\n+    @Override\n+    public void onColonyTick(final IColony colony)\n+    {\n+        checkAutoStartResearch(colony);\n+        checkInprogressResearch(colony);\n+    }\n+\n+    /**\n+     * Checks if any autostart research has its prerequisites filled,\n+     * and if so, prompts the player for resources or begins research if no resources required.\n+     * @param colony       The colony where the research is being checked.\n+     */\n+    private void checkAutoStartResearch(final IColony colony)", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4OTA3OA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548489078", "bodyText": "I think Mekle001\u2019s central use case involved situations where the university itself was locked, such as wanting to make it unbuildable until after a Town Hall T1 was constructed. Without having access to the WindowResearchTree GUI, you\u2019d need some way to start it.\nQuest-focused modpacks can kinda handle things by removing the University hut block recipe and making it a quest reward, but that\u2019s vulnerable to problems (ie, losing it to lava).\nOr if a modpack just wants to make a very linear path through the huts, it would save walking to the Uni and back each time for 10-20 unlocks.\nThe other situation, and one more common for your use, would just be to notify on reveal of Hidden research.  If More Scrolls should only be visible after getting a T3 Enchanter, it makes sense to tell the player that the new research is there \u2014 but it may not be desirable to always do such notification.", "author": "gattsuru", "createdAt": "2020-12-24T10:45:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4NDc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5MzMzOQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548493339", "bodyText": "I get the notification part. But for that we don't need to auto start the research. We'd just need an event based approach and a \"on unlock message\" that may be defined for a research. This way no ticking is required.\nFor the \"lock/unlock\" things without a university I'd probably go the same way. Just an unlock event", "author": "Raycoms", "createdAt": "2020-12-24T10:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4NDc1OA=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/managers/ResearchManager.java b/src/main/java/com/minecolonies/coremod/colony/managers/ResearchManager.java\nindex 15cc44745c..6f36b81053 100755\n--- a/src/main/java/com/minecolonies/coremod/colony/managers/ResearchManager.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/managers/ResearchManager.java\n\n@@ -82,18 +80,7 @@ public class ResearchManager implements IResearchManager\n     }\n \n     @Override\n-    public void onColonyTick(final IColony colony)\n-    {\n-        checkAutoStartResearch(colony);\n-        checkInprogressResearch(colony);\n-    }\n-\n-    /**\n-     * Checks if any autostart research has its prerequisites filled,\n-     * and if so, prompts the player for resources or begins research if no resources required.\n-     * @param colony       The colony where the research is being checked.\n-     */\n-    private void checkAutoStartResearch(final IColony colony)\n+    public void checkAutoStartResearch(final IColony colony)\n     {\n         final List<IGlobalResearch> removes = new ArrayList<>();\n         for(IGlobalResearch research : autoStartResearch)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4NDk5Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548484997", "bodyText": "Why isn't this anymore in the place where the progress is incremented?", "author": "Raycoms", "createdAt": "2020-12-24T10:30:52Z", "path": "src/main/java/com/minecolonies/coremod/colony/managers/ResearchManager.java", "diffHunk": "@@ -45,4 +80,123 @@ public IResearchEffectManager getResearchEffects()\n     {\n         return this.effects;\n     }\n+\n+    @Override\n+    public void onColonyTick(final IColony colony)\n+    {\n+        checkAutoStartResearch(colony);\n+        checkInprogressResearch(colony);\n+    }\n+\n+    /**\n+     * Checks if any autostart research has its prerequisites filled,\n+     * and if so, prompts the player for resources or begins research if no resources required.\n+     * @param colony       The colony where the research is being checked.\n+     */\n+    private void checkAutoStartResearch(final IColony colony)\n+    {\n+        final List<IGlobalResearch> removes = new ArrayList<>();\n+        for(IGlobalResearch research : autoStartResearch)\n+        {\n+            if (!IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(research.getResearchRequirement(), colony))\n+            {\n+                continue;\n+            }\n+            Map<BlockPos, IBuilding> buildings = colony.getBuildingManager().getBuildings();\n+            int level = 0;\n+            for (Map.Entry<BlockPos, IBuilding> building : buildings.entrySet())\n+            {\n+                if (building.getValue().getBuildingRegistryEntry() == ModBuildings.university)\n+                {\n+                    if (building.getValue().getBuildingLevel() > level)\n+                    {\n+                        level = building.getValue().getBuildingLevel();\n+                    }\n+                }\n+            }\n+            if (level < research.getDepth())\n+            {\n+                continue;\n+            }\n+            boolean researchAlreadyRun = false;\n+            for (ILocalResearch progressResearch : colony.getResearchManager().getResearchTree().getResearchInProgress())\n+            {\n+                if(progressResearch.getId().equals(research.getId()))\n+                {\n+                    researchAlreadyRun = true;\n+                    break;\n+                }\n+            }\n+            // Don't want to spam people about in-progress or already-completed research.  Because these might change within a world,\n+            // we can't just save them or check against effects.\n+            if(researchAlreadyRun || colony.getResearchManager().getResearchTree().hasCompletedResearch(research.getId()))\n+            {\n+                removes.add(research);\n+                continue;\n+            }\n+\n+            // if research has item requirements, only notify player; we don't want to have items disappearing from inventories.\n+            if (!research.getCostList().isEmpty())\n+            {\n+                for (PlayerEntity player : colony.getMessagePlayerEntities())\n+                {\n+                    player.sendMessage(new TranslationTextComponent(TranslationConstants.RESEARCH_AVAILABLE, research.getDesc()), player.getUniqueID());\n+                }\n+            }\n+            // Otherwise, we can start the research without user intervention.\n+            else\n+            {\n+                boolean creativePlayer = false;\n+                tree.addResearch(research.getBranch(), new LocalResearch(research.getId(), research.getBranch(), research.getDepth()));\n+                for (PlayerEntity player : colony.getMessagePlayerEntities())\n+                {\n+                    player.sendMessage(new TranslationTextComponent(TranslationConstants.RESEARCH_AVAILABLE, research.getDesc()).\n+                                      append(new TranslationTextComponent(\"com.minecolonies.coremod.research.started\", new TranslationTextComponent(research.getDesc()))),\n+                      player.getUniqueID());\n+                    if (player.isCreative())\n+                    {\n+                        creativePlayer = true;\n+                    }\n+                }\n+                if (creativePlayer && MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n+                {\n+                    tree.getResearch(research.getBranch(), research.getId()).setProgress((int)(BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n+                }\n+            }\n+            //  If we've successfully done all those things, now we can remove the object from the list.\n+            //  This will reannounce on world reload, but that's probably ideal, in case someone missed the message once.\n+            removes.add(research);\n+        }\n+        autoStartResearch.removeAll(removes);\n+    }\n+\n+    /**\n+     * Checks if any started research has progress greater than or equal to the amount required for completion, and if so, pushes it into\n+     * finished status.\n+     * @param colony        The colony being checked for completed research, and to which research effects will be applied.\n+     */\n+    private void checkInprogressResearch(final IColony colony)", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/colony/managers/ResearchManager.java b/src/main/java/com/minecolonies/coremod/colony/managers/ResearchManager.java\nindex 15cc44745c..6f36b81053 100755\n--- a/src/main/java/com/minecolonies/coremod/colony/managers/ResearchManager.java\n+++ b/src/main/java/com/minecolonies/coremod/colony/managers/ResearchManager.java\n\n@@ -82,18 +80,7 @@ public class ResearchManager implements IResearchManager\n     }\n \n     @Override\n-    public void onColonyTick(final IColony colony)\n-    {\n-        checkAutoStartResearch(colony);\n-        checkInprogressResearch(colony);\n-    }\n-\n-    /**\n-     * Checks if any autostart research has its prerequisites filled,\n-     * and if so, prompts the player for resources or begins research if no resources required.\n-     * @param colony       The colony where the research is being checked.\n-     */\n-    private void checkAutoStartResearch(final IColony colony)\n+    public void checkAutoStartResearch(final IColony colony)\n     {\n         final List<IGlobalResearch> removes = new ArrayList<>();\n         for(IGlobalResearch research : autoStartResearch)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4NjQ1MQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548486451", "bodyText": "I've added a new sound handler thing for success and failure sounds, would make sense to integrate this here", "author": "Raycoms", "createdAt": "2020-12-24T10:35:50Z", "path": "src/main/java/com/minecolonies/coremod/network/messages/server/colony/building/university/TryResearchMessage.java", "diffHunk": "@@ -76,50 +96,132 @@ protected void onExecute(\n             return;\n         }\n \n+        final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, researchId);\n+        if(reset)\n+        {\n+            if(colony.getResearchManager().getResearchTree().getResearch(branch, researchId) != null)", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/network/messages/server/colony/building/university/TryResearchMessage.java b/src/main/java/com/minecolonies/coremod/network/messages/server/colony/building/university/TryResearchMessage.java\nindex ffafcbdea0..73f42c3675 100755\n--- a/src/main/java/com/minecolonies/coremod/network/messages/server/colony/building/university/TryResearchMessage.java\n+++ b/src/main/java/com/minecolonies/coremod/network/messages/server/colony/building/university/TryResearchMessage.java\n\n@@ -101,127 +82,16 @@ public class TryResearchMessage extends AbstractBuildingServerMessage<BuildingUn\n         {\n             if(colony.getResearchManager().getResearchTree().getResearch(branch, researchId) != null)\n             {\n-                attemptResetResearch(player, colony, research);\n-            }\n-        }\n-        else\n-        {\n-            attemptBeginResearch(player, colony, building, research);\n-        }\n-    }\n-\n-    /**\n-     * Attempt to begin a research.\n-     * @param player     the player making the request (and to apply costs toward)\n-     * @param colony     the colony doing the research\n-     * @param building   the university doing the research\n-     * @param research   the research.\n-     */\n-    private void attemptBeginResearch(final PlayerEntity player, final IColony colony, final BuildingUniversity building, final IGlobalResearch research)\n-    {\n-        if (colony.getResearchManager().getResearchTree().getResearch(branch, researchId) == null)\n-        {\n-            if (research.canResearch(building.getBuildingLevel() == building.getMaxBuildingLevel() ? Integer.MAX_VALUE : building.getBuildingLevel(),\n-              colony.getResearchManager().getResearchTree()) && research.hasEnoughResources(new InvWrapper(player.inventory)) || player.isCreative())\n-            {\n-                if (player.isCreative())\n-                {\n-                    research.startResearch(colony.getResearchManager().getResearchTree());\n-                    if (MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n-                    {\n-                        colony.getResearchManager()\n-                          .getResearchTree()\n-                          .getResearch(branch, research.getId())\n-                          .setProgress((int) (BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n-                    }\n-                    return;\n-                }\n-                else if (!research.getResearchRequirement().isEmpty())\n-                {\n-                    for (IResearchRequirement requirement : research.getResearchRequirement())\n-                    {\n-                        if (!requirement.isFulfilled(colony))\n-                        {\n-                            player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.requirementnotmet\"), player.getUniqueID());\n-                            return;\n-                        }\n-                    }\n-                    // Remove items from player\n-                    if (!InventoryUtils.tryRemoveStackFromItemHandler(new InvWrapper(player.inventory), research.getCostList()))\n-                    {\n-                        player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.costnotavailable\", new TranslationTextComponent(research.getDesc())),\n-                          player.getUniqueID());\n-                        return;\n-                    }\n-                }\n-                player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.started\", new TranslationTextComponent(research.getDesc())),\n-                  player.getUniqueID());\n-                research.startResearch(colony.getResearchManager().getResearchTree());\n+                colony.getResearchManager().getResearchTree().attemptResetResearch(player, colony, colony.getResearchManager().getResearchTree().getResearch(branch, researchId));\n             }\n         }\n         else\n         {\n-            if(player.isCreative())\n-            {\n-                if (MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n-                {\n-                    colony.getResearchManager()\n-                      .getResearchTree()\n-                      .getResearch(branch, research.getId())\n-                      .setProgress((int) (BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n-                }\n-            }\n-            else\n-            {\n-                player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.alreadystarted\"), player.getUniqueID());\n-            }\n-        }\n-        colony.markDirty();\n-    }\n-\n-    /**\n-     * Attempt to reset research for a colony.\n-     * @param player     the player making the request (and to apply costs toward)\n-     * @param colony     the colony to remove the research from.\n-     * @param research   the research.\n-     */\n-    private void attemptResetResearch(final PlayerEntity player, final IColony colony, final IGlobalResearch research)\n-    {\n-        // If in progress and get another request, cancel research, and remove it from the local tree.\n-        if(colony.getResearchManager().getResearchTree().getResearch(branch, researchId).getState() == ResearchState.IN_PROGRESS)\n-        {\n-            player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.stopped\", new TranslationTextComponent(research.getDesc())),\n-              player.getUniqueID());\n-            colony.getResearchManager().getResearchTree().cancelResearch(branch, researchId, null);\n-        }\n-        // If complete, it's a request to undo the research.\n-        else if (colony.getResearchManager().getResearchTree().getResearch(branch, researchId).getState() == ResearchState.FINISHED)\n-        {\n-            if(!player.isCreative())\n+            if((research.canResearch(building.getBuildingLevel() == building.getMaxBuildingLevel() ? Integer.MAX_VALUE : building.getBuildingLevel(), colony.getResearchManager().getResearchTree()))\n+                 || player.isCreative())\n             {\n-                final List<ItemStorage> costList = new ArrayList<>();\n-                for (final String cost : IGlobalResearchTree.getInstance().getResearchResetCosts())\n-                {\n-                    // Validated cost metrics during ResearchListener, so doesn't need to be redone here.\n-                    // Do, however, need to check against air, in case item type does not exist.\n-                    final String[] costParts = cost.split(\":\");\n-                    final Item costItem = ForgeRegistries.ITEMS.getValue(new ResourceLocation(costParts[0], costParts[1]));\n-                    if(!costItem.equals(Items.AIR))\n-                    {\n-                        costList.add(new ItemStorage(new ItemStack(costItem, Integer.parseInt(costParts[2])), false, true));\n-                    }\n-                }\n-                if (!InventoryUtils.tryRemoveStackFromItemHandler(new InvWrapper(player.inventory), costList))\n-                {\n-                    player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.costnotavailable\", new TranslationTextComponent(research.getDesc())),\n-                      player.getUniqueID());\n-                    return;\n-                }\n+                colony.getResearchManager().getResearchTree().attemptBeginResearch(player, colony, research);\n             }\n-            player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.undo\", new TranslationTextComponent(research.getDesc())),\n-              player.getUniqueID());\n-            colony.getResearchManager().getResearchTree().cancelResearch(branch, researchId, colony);\n         }\n-        colony.markDirty();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4NjcyMg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548486722", "bodyText": "I feel like this code should be in the ResearchManager or even in the ResearchTree", "author": "Raycoms", "createdAt": "2020-12-24T10:36:37Z", "path": "src/main/java/com/minecolonies/coremod/network/messages/server/colony/building/university/TryResearchMessage.java", "diffHunk": "@@ -76,50 +96,132 @@ protected void onExecute(\n             return;\n         }\n \n+        final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, researchId);\n+        if(reset)\n+        {\n+            if(colony.getResearchManager().getResearchTree().getResearch(branch, researchId) != null)\n+            {\n+                attemptResetResearch(player, colony, research);\n+            }\n+        }\n+        else\n+        {\n+            attemptBeginResearch(player, colony, building, research);\n+        }\n+    }\n+\n+    /**\n+     * Attempt to begin a research.\n+     * @param player     the player making the request (and to apply costs toward)\n+     * @param colony     the colony doing the research\n+     * @param building   the university doing the research\n+     * @param research   the research.\n+     */\n+    private void attemptBeginResearch(final PlayerEntity player, final IColony colony, final BuildingUniversity building, final IGlobalResearch research)\n+    {\n         if (colony.getResearchManager().getResearchTree().getResearch(branch, researchId) == null)\n         {\n-            final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, researchId);\n             if (research.canResearch(building.getBuildingLevel() == building.getMaxBuildingLevel() ? Integer.MAX_VALUE : building.getBuildingLevel(),\n               colony.getResearchManager().getResearchTree()) && research.hasEnoughResources(new InvWrapper(player.inventory)) || player.isCreative())\n             {\n                 if (player.isCreative())\n                 {\n-                    research.startResearch(player, colony.getResearchManager().getResearchTree());\n-                    colony.getResearchManager()\n-                      .getResearchTree()\n-                      .getResearch(branch, research.getId())\n-                      .setProgress((int) (BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n-                }\n-                else if (research.getResearchRequirement() != null && !research.getResearchRequirement().isFulfilled(colony))\n-                {\n-                    player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.requirementnotmet\"), player.getUniqueID());\n+                    research.startResearch(colony.getResearchManager().getResearchTree());\n+                    if (MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n+                    {\n+                        colony.getResearchManager()\n+                          .getResearchTree()\n+                          .getResearch(branch, research.getId())\n+                          .setProgress((int) (BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n+                    }\n                     return;\n                 }\n-                else\n+                else if (!research.getResearchRequirement().isEmpty())\n                 {\n-                    for (final ItemStorage cost : research.getCostList())\n+                    for (IResearchRequirement requirement : research.getResearchRequirement())\n                     {\n-                        InventoryUtils.removeStackFromItemHandler(new InvWrapper(player.inventory), cost.getItemStack(), cost.getAmount());\n+                        if (!requirement.isFulfilled(colony))\n+                        {\n+                            player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.requirementnotmet\"), player.getUniqueID());\n+                            return;\n+                        }\n+                    }\n+                    // Remove items from player\n+                    if (!InventoryUtils.tryRemoveStackFromItemHandler(new InvWrapper(player.inventory), research.getCostList()))\n+                    {\n+                        player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.costnotavailable\", new TranslationTextComponent(research.getDesc())),\n+                          player.getUniqueID());\n+                        return;\n                     }\n-\n-                    player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.started\", research.getDesc()), player.getUniqueID());\n-                    research.startResearch(player, colony.getResearchManager().getResearchTree());\n                 }\n-                colony.markDirty();\n-                // Remove items from player\n+                player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.started\", new TranslationTextComponent(research.getDesc())),\n+                  player.getUniqueID());\n+                research.startResearch(colony.getResearchManager().getResearchTree());\n             }\n         }\n         else\n         {\n-            if (player.isCreative() && colony.getResearchManager().getResearchTree().getResearch(branch, researchId).getState() == ResearchState.IN_PROGRESS)\n+            if(player.isCreative())\n             {\n-                final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, researchId);\n-                colony.getResearchManager().getResearchTree().getResearch(branch, research.getId()).setProgress((int) (BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n+                if (MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n+                {\n+                    colony.getResearchManager()\n+                      .getResearchTree()\n+                      .getResearch(branch, research.getId())\n+                      .setProgress((int) (BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n+                }\n             }\n             else\n             {\n                 player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.alreadystarted\"), player.getUniqueID());\n             }\n         }\n+        colony.markDirty();\n+    }\n+\n+    /**\n+     * Attempt to reset research for a colony.\n+     * @param player     the player making the request (and to apply costs toward)\n+     * @param colony     the colony to remove the research from.\n+     * @param research   the research.\n+     */\n+    private void attemptResetResearch(final PlayerEntity player, final IColony colony, final IGlobalResearch research)", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/network/messages/server/colony/building/university/TryResearchMessage.java b/src/main/java/com/minecolonies/coremod/network/messages/server/colony/building/university/TryResearchMessage.java\nindex ffafcbdea0..73f42c3675 100755\n--- a/src/main/java/com/minecolonies/coremod/network/messages/server/colony/building/university/TryResearchMessage.java\n+++ b/src/main/java/com/minecolonies/coremod/network/messages/server/colony/building/university/TryResearchMessage.java\n\n@@ -101,127 +82,16 @@ public class TryResearchMessage extends AbstractBuildingServerMessage<BuildingUn\n         {\n             if(colony.getResearchManager().getResearchTree().getResearch(branch, researchId) != null)\n             {\n-                attemptResetResearch(player, colony, research);\n-            }\n-        }\n-        else\n-        {\n-            attemptBeginResearch(player, colony, building, research);\n-        }\n-    }\n-\n-    /**\n-     * Attempt to begin a research.\n-     * @param player     the player making the request (and to apply costs toward)\n-     * @param colony     the colony doing the research\n-     * @param building   the university doing the research\n-     * @param research   the research.\n-     */\n-    private void attemptBeginResearch(final PlayerEntity player, final IColony colony, final BuildingUniversity building, final IGlobalResearch research)\n-    {\n-        if (colony.getResearchManager().getResearchTree().getResearch(branch, researchId) == null)\n-        {\n-            if (research.canResearch(building.getBuildingLevel() == building.getMaxBuildingLevel() ? Integer.MAX_VALUE : building.getBuildingLevel(),\n-              colony.getResearchManager().getResearchTree()) && research.hasEnoughResources(new InvWrapper(player.inventory)) || player.isCreative())\n-            {\n-                if (player.isCreative())\n-                {\n-                    research.startResearch(colony.getResearchManager().getResearchTree());\n-                    if (MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n-                    {\n-                        colony.getResearchManager()\n-                          .getResearchTree()\n-                          .getResearch(branch, research.getId())\n-                          .setProgress((int) (BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n-                    }\n-                    return;\n-                }\n-                else if (!research.getResearchRequirement().isEmpty())\n-                {\n-                    for (IResearchRequirement requirement : research.getResearchRequirement())\n-                    {\n-                        if (!requirement.isFulfilled(colony))\n-                        {\n-                            player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.requirementnotmet\"), player.getUniqueID());\n-                            return;\n-                        }\n-                    }\n-                    // Remove items from player\n-                    if (!InventoryUtils.tryRemoveStackFromItemHandler(new InvWrapper(player.inventory), research.getCostList()))\n-                    {\n-                        player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.costnotavailable\", new TranslationTextComponent(research.getDesc())),\n-                          player.getUniqueID());\n-                        return;\n-                    }\n-                }\n-                player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.started\", new TranslationTextComponent(research.getDesc())),\n-                  player.getUniqueID());\n-                research.startResearch(colony.getResearchManager().getResearchTree());\n+                colony.getResearchManager().getResearchTree().attemptResetResearch(player, colony, colony.getResearchManager().getResearchTree().getResearch(branch, researchId));\n             }\n         }\n         else\n         {\n-            if(player.isCreative())\n-            {\n-                if (MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n-                {\n-                    colony.getResearchManager()\n-                      .getResearchTree()\n-                      .getResearch(branch, research.getId())\n-                      .setProgress((int) (BASE_RESEARCH_TIME * Math.pow(2, research.getDepth() - 1)));\n-                }\n-            }\n-            else\n-            {\n-                player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.alreadystarted\"), player.getUniqueID());\n-            }\n-        }\n-        colony.markDirty();\n-    }\n-\n-    /**\n-     * Attempt to reset research for a colony.\n-     * @param player     the player making the request (and to apply costs toward)\n-     * @param colony     the colony to remove the research from.\n-     * @param research   the research.\n-     */\n-    private void attemptResetResearch(final PlayerEntity player, final IColony colony, final IGlobalResearch research)\n-    {\n-        // If in progress and get another request, cancel research, and remove it from the local tree.\n-        if(colony.getResearchManager().getResearchTree().getResearch(branch, researchId).getState() == ResearchState.IN_PROGRESS)\n-        {\n-            player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.stopped\", new TranslationTextComponent(research.getDesc())),\n-              player.getUniqueID());\n-            colony.getResearchManager().getResearchTree().cancelResearch(branch, researchId, null);\n-        }\n-        // If complete, it's a request to undo the research.\n-        else if (colony.getResearchManager().getResearchTree().getResearch(branch, researchId).getState() == ResearchState.FINISHED)\n-        {\n-            if(!player.isCreative())\n+            if((research.canResearch(building.getBuildingLevel() == building.getMaxBuildingLevel() ? Integer.MAX_VALUE : building.getBuildingLevel(), colony.getResearchManager().getResearchTree()))\n+                 || player.isCreative())\n             {\n-                final List<ItemStorage> costList = new ArrayList<>();\n-                for (final String cost : IGlobalResearchTree.getInstance().getResearchResetCosts())\n-                {\n-                    // Validated cost metrics during ResearchListener, so doesn't need to be redone here.\n-                    // Do, however, need to check against air, in case item type does not exist.\n-                    final String[] costParts = cost.split(\":\");\n-                    final Item costItem = ForgeRegistries.ITEMS.getValue(new ResourceLocation(costParts[0], costParts[1]));\n-                    if(!costItem.equals(Items.AIR))\n-                    {\n-                        costList.add(new ItemStorage(new ItemStack(costItem, Integer.parseInt(costParts[2])), false, true));\n-                    }\n-                }\n-                if (!InventoryUtils.tryRemoveStackFromItemHandler(new InvWrapper(player.inventory), costList))\n-                {\n-                    player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.costnotavailable\", new TranslationTextComponent(research.getDesc())),\n-                      player.getUniqueID());\n-                    return;\n-                }\n+                colony.getResearchManager().getResearchTree().attemptBeginResearch(player, colony, research);\n             }\n-            player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.undo\", new TranslationTextComponent(research.getDesc())),\n-              player.getUniqueID());\n-            colony.getResearchManager().getResearchTree().cancelResearch(branch, researchId, colony);\n         }\n-        colony.markDirty();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4Njk5NA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548486994", "bodyText": "newline", "author": "Raycoms", "createdAt": "2020-12-24T10:37:34Z", "path": "src/main/java/com/minecolonies/coremod/research/AlternateBuildingResearchRequirement.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package com.minecolonies.coremod.research;\n+\n+import com.minecolonies.api.colony.IColony;\n+import com.minecolonies.api.colony.IColonyView;\n+import com.minecolonies.api.colony.buildings.IBuilding;\n+import com.minecolonies.api.colony.buildings.views.IBuildingView;\n+import com.minecolonies.api.research.IResearchRequirement;\n+import net.minecraft.util.text.TranslationTextComponent;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * Requires one out of a list of buildings to be present.\n+ */\n+public class AlternateBuildingResearchRequirement implements IResearchRequirement\n+{\n+    /**\n+     * The list of buildings, by level.\n+     */\n+    final private Map<String, Integer> buildings = new HashMap<>();\n+\n+    /**\n+     * Create a building-based research requirement, that requires one of multiple buildings be constructed.\n+     *\n+     */\n+    public AlternateBuildingResearchRequirement add(String building, int level)\n+    {\n+        if(buildings.containsKey(building))\n+        {\n+            buildings.put(building, buildings.get(building) + level);\n+        }\n+        else\n+        {\n+            buildings.put(building, level);\n+        }\n+        return this;\n+    }\n+\n+\n+    /**\n+     * @return the building description\n+     */\n+    public Map<String, Integer> getBuildings()\n+    {\n+        return buildings;\n+    }\n+\n+    @Override\n+    public boolean isFulfilled(final IColony colony)\n+    {\n+        for(Map.Entry<String, Integer> requirement : buildings.entrySet())\n+        {\n+            int sum = 0;\n+            if(colony instanceof IColonyView)\n+            {\n+                for (final IBuildingView building : ((IColonyView) colony).getBuildings())\n+                {\n+                    if (building.getSchematicName().equals(requirement.getKey()))\n+                    {\n+                        sum += building.getBuildingLevel();\n+\n+                        if(sum >= requirement.getValue())\n+                        {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            else if(colony instanceof IColony)\n+            {\n+                for (final IBuilding building : colony.getBuildingManager().getBuildings().values())\n+                {\n+                    if (building.getSchematicName().equalsIgnoreCase(requirement.getKey()))\n+                    {\n+                        sum += building.getBuildingLevel();\n+\n+                        if (sum >= requirement.getValue())\n+                        {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public TranslationTextComponent getDesc()\n+    {\n+        final TranslationTextComponent requirementList = new TranslationTextComponent(\"\");\n+        final Iterator<Map.Entry<String, Integer>> iterator = buildings.entrySet().iterator();\n+        while(iterator.hasNext())\n+        {\n+            final Map.Entry<String, Integer> kvp = iterator.next();\n+            requirementList.append(new TranslationTextComponent(\"com.minecolonies.coremod.research.requirement.building.level\", new TranslationTextComponent(\"block.minecolonies.blockhut\" + kvp.getKey()), kvp.getValue()));\n+            if(iterator.hasNext())\n+            {\n+                requirementList.append(new TranslationTextComponent(\"com.minecolonies.coremod.research.requirement.building.or\"));\n+            }\n+        }\n+        return requirementList;\n+    }\n+}", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/AlternateBuildingResearchRequirement.java b/src/main/java/com/minecolonies/coremod/research/AlternateBuildingResearchRequirement.java\nindex ca3345d3af..d4c00df1ef 100644\n--- a/src/main/java/com/minecolonies/coremod/research/AlternateBuildingResearchRequirement.java\n+++ b/src/main/java/com/minecolonies/coremod/research/AlternateBuildingResearchRequirement.java\n\n@@ -5,6 +5,7 @@ import com.minecolonies.api.colony.IColonyView;\n import com.minecolonies.api.colony.buildings.IBuilding;\n import com.minecolonies.api.colony.buildings.views.IBuildingView;\n import com.minecolonies.api.research.IResearchRequirement;\n+import com.minecolonies.api.util.Log;\n import net.minecraft.util.text.TranslationTextComponent;\n \n import java.util.HashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4NzQxNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548487415", "bodyText": "Use the dist executor for this then", "author": "Raycoms", "createdAt": "2020-12-24T10:39:05Z", "path": "src/main/java/com/minecolonies/coremod/research/GlobalResearch.java", "diffHunk": "@@ -256,14 +438,396 @@ public void setParent(final String id)\n     }\n \n     @Override\n-    public ImmutableList<String> getChilds()\n+    public ImmutableList<String> getChildren()\n     {\n-        return ImmutableList.copyOf(this.childs);\n+        return ImmutableList.copyOf(this.children);\n     }\n \n     @Override\n-    public IResearchEffect<?> getEffect()\n+    public List<IResearchEffect> getEffects()\n+    {\n+        return this.effects;\n+    }\n+\n+    @Override\n+    public String getIcon() {return this.icon;}\n+\n+    /**\n+     * Parse a Json object into a new GlobalResearch.\n+     *\n+     * @param researchJson the json representing the recipe\n+     * @return new instance of ResearchRecipe\n+     */\n+    public GlobalResearch(@NotNull final JsonObject researchJson, final ResourceLocation resourceLocation, final Map<String, ResearchEffectCategory> effectCategories)\n     {\n-        return effect;\n+        this.resourceLocation = resourceLocation;\n+\n+        this.id = getResearchId(researchJson, resourceLocation);\n+        this.name = getResearchName(researchJson);\n+        this.branch = getBranch(researchJson, resourceLocation);\n+        //TODO: make getResearchIcon fire only for client-side.", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\nindex ca94d21bdd..c96ded62f1 100755\n--- a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n+++ b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n\n@@ -438,13 +569,13 @@ public class GlobalResearch implements IGlobalResearch\n     }\n \n     @Override\n-    public ImmutableList<String> getChildren()\n+    public List<String> getChildren()\n     {\n-        return ImmutableList.copyOf(this.children);\n+        return this.children;\n     }\n \n     @Override\n-    public List<IResearchEffect> getEffects()\n+    public List<IResearchEffect<?>> getEffects()\n     {\n         return this.effects;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4NzY3OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548487679", "bodyText": "This seems overly complex to just get a resource location?", "author": "Raycoms", "createdAt": "2020-12-24T10:39:58Z", "path": "src/main/java/com/minecolonies/coremod/research/GlobalResearch.java", "diffHunk": "@@ -256,14 +438,396 @@ public void setParent(final String id)\n     }\n \n     @Override\n-    public ImmutableList<String> getChilds()\n+    public ImmutableList<String> getChildren()\n     {\n-        return ImmutableList.copyOf(this.childs);\n+        return ImmutableList.copyOf(this.children);\n     }\n \n     @Override\n-    public IResearchEffect<?> getEffect()\n+    public List<IResearchEffect> getEffects()\n+    {\n+        return this.effects;\n+    }\n+\n+    @Override\n+    public String getIcon() {return this.icon;}\n+\n+    /**\n+     * Parse a Json object into a new GlobalResearch.\n+     *\n+     * @param researchJson the json representing the recipe\n+     * @return new instance of ResearchRecipe\n+     */\n+    public GlobalResearch(@NotNull final JsonObject researchJson, final ResourceLocation resourceLocation, final Map<String, ResearchEffectCategory> effectCategories)\n     {\n-        return effect;\n+        this.resourceLocation = resourceLocation;\n+\n+        this.id = getResearchId(researchJson, resourceLocation);\n+        this.name = getResearchName(researchJson);\n+        this.branch = getBranch(researchJson, resourceLocation);\n+        //TODO: make getResearchIcon fire only for client-side.\n+        // icons are only used in client, and may reference files that don't exist on server.\n+        // Performance impact is relatively low, but may leave erroneous log errors.\n+        this.icon = getResearchIcon(researchJson);\n+        this.depth = getUniversityLevel(researchJson);\n+        this.parent = getParent(researchJson);\n+        this.onlyChild = getBooleanSafe(researchJson, RESEARCH_EXCLUSIVE_CHILD_PROP);\n+        this.instant = getBooleanSafe(researchJson, RESEARCH_INSTANT_PROP);\n+        this.autostart = getBooleanSafe(researchJson, RESEARCH_AUTOSTART_PROP);\n+        this.hidden = getBooleanSafe(researchJson, RESEARCH_HIDDEN_PROP);\n+        this.immutable = getBooleanSafe(researchJson, RESEARCH_NO_RESET_PROP);\n+\n+        parseRequirements(researchJson);\n+        parseEffects(researchJson, effectCategories);\n+    }\n+\n+    /**\n+     * Gets the unique ID for a research from a JSON object, if it exists and is valid, or an empty string otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the ID from.\n+     * @param resourceLocation    The {@link ResourceLocation} of the json being parsed.\n+     * @return                    The ResearchID as a String.\n+     */\n+    private String getResearchId(final JsonObject researchJson, final ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_ID_PROP) && researchJson.get(RESEARCH_ID_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ID_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_ID_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research ID for\" + resourceLocation);\n+            return \"\";\n+        }\n+    }\n+\n+    /**\n+     * Gets the optional name for a research from a JSON object, if it exists and is valid, or an empty string otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the Name from.\n+     * @return                    The Research Name as a String.\n+     */\n+    private String getResearchName(final JsonObject researchJson)\n+    {\n+        if (researchJson.has(RESEARCH_NAME_PROP) && researchJson.get(RESEARCH_NAME_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_NAME_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_NAME_PROP).getAsString();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+\n+    /**\n+     * Gets the branch for a research from a JSON object, if it exists and is valid, or \"parseerrors\" otherwise.\n+     *\n+     * @param researchJson        A json object to retrieve the ID from.\n+     * @param resourceLocation    The {@link ResourceLocation} of the json being parsed.\n+     * @return                    The Research Branch as a String.\n+     */\n+    private String getBranch(final JsonObject researchJson, final ResourceLocation resourceLocation)\n+    {\n+        if (researchJson.has(RESEARCH_BRANCH_PROP) && researchJson.get(RESEARCH_BRANCH_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_BRANCH_PROP).getAsJsonPrimitive().isString())\n+        {\n+            return researchJson.get(RESEARCH_BRANCH_PROP).getAsString();\n+        }\n+        else\n+        {\n+            Log.getLogger().error(\"Error in Research Branch for\" + resourceLocation);\n+            return \"parseerrors\";\n+        }\n+    }\n+\n+    /**\n+     * Gets the required university level from a JSON object, if it exists and is valid, or returns 1 if not.\n+     *\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private int getUniversityLevel(final JsonObject researchJson)\n+    {\n+        if (researchJson.has(RESEARCH_UNIVERSITY_LEVEL_PROP) && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsJsonPrimitive().isNumber())\n+        {\n+            return researchJson.get(RESEARCH_UNIVERSITY_LEVEL_PROP).getAsNumber().intValue();\n+        }\n+        else\n+        {\n+            Log.getLogger().info(\"No declared university level for \" + this.branch + \"/\" + this.id );\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * Gets the optional icon location from a research json, if present.  If not available, or if requests a file or block that does not exist, returns an empty string.\n+     * @param researchJson        A json object to retrieve the requiredUniversityLevel from.\n+     * @return                    The required university level as an integer.\n+     */\n+    private String getResearchIcon(final JsonObject researchJson)\n+    {\n+        if (researchJson.has(RESEARCH_ICON_PROP) && researchJson.get(RESEARCH_ICON_PROP).isJsonPrimitive() && researchJson.get(RESEARCH_ICON_PROP).getAsJsonPrimitive().isString())\n+        {\n+            final String[] iconParts = researchJson.get(RESEARCH_ICON_PROP).getAsString().split(\":\");\n+            final String[] outputString = new String[3];\n+            // Do preliminary validation here, as later uses will always be in UI space.\n+            if(iconParts.length > 3)\n+            {\n+                Log.getLogger().info(\"Malformed icon property for \" + this.branch + \"/\" + this.id + \".  Icons may contain at most namespace:identifier:count.\");\n+                return \"\";\n+            }\n+\n+            if(iconParts.length == 3)", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwNTU5Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548505597", "bodyText": "Needs to handle and distinguish textures or items, with and without namespaces, and for items with or without counts, which may be entered by typo if users and not just developers.\nI can move the validation stuff elsewhere, but most of it is important: a bad texture location just spams the console each time it\u2019s called , but an unparsable number would just crash Minecraft entirely with an awful stack trace since it\u2019s going to GUI space.", "author": "gattsuru", "createdAt": "2020-12-24T11:46:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4NzY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwNjI0Mg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548506242", "bodyText": "ok", "author": "Raycoms", "createdAt": "2020-12-24T11:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4NzY3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\nindex ca94d21bdd..c96ded62f1 100755\n--- a/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n+++ b/src/main/java/com/minecolonies/coremod/research/GlobalResearch.java\n\n@@ -438,13 +569,13 @@ public class GlobalResearch implements IGlobalResearch\n     }\n \n     @Override\n-    public ImmutableList<String> getChildren()\n+    public List<String> getChildren()\n     {\n-        return ImmutableList.copyOf(this.children);\n+        return this.children;\n     }\n \n     @Override\n-    public List<IResearchEffect> getEffects()\n+    public List<IResearchEffect<?>> getEffects()\n     {\n         return this.effects;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4ODUyOA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548488528", "bodyText": "I still don't fully understand what and why it does this.", "author": "Raycoms", "createdAt": "2020-12-24T10:43:05Z", "path": "src/main/java/com/minecolonies/coremod/research/GlobalResearchTree.java", "diffHunk": "@@ -65,9 +139,63 @@ public void addResearch(final String branch, final IGlobalResearch research)\n         {\n             return Collections.emptyList();\n         }\n-        return researchTree.get(branch).values().stream().filter(research -> research.getParent().isEmpty()).map(IGlobalResearch::getId).collect(Collectors.toList());\n+        return researchTree.get(branch).values().stream().filter(research -> research.getParent().isEmpty())\n+                 .sorted(Comparator.comparing(IGlobalResearch::getResourceLocation))\n+                 .map(IGlobalResearch::getId).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public void reset()", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMTMyNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548501325", "bodyText": "Data packs are per-world, not per-Minecraft instance, while the Global Research Tree is per-Minecraft instance.  If someone logs into World A, which has several extra researches in its data pack, then into World B, which only has the defaults, the tree needs to be reset lest the client see the extra researches on a world that doesn\u2019t have them.\nThis gets worse for multiplayer.\nI don\u2019t think it\u2019s a common failure mode, but it would be especially frustrating to diagnose due to its specific nature.", "author": "gattsuru", "createdAt": "2020-12-24T11:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4ODUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMjUwMg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548502502", "bodyText": "Ahh, makes sense, okay", "author": "Raycoms", "createdAt": "2020-12-24T11:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4ODUyOA=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/GlobalResearchTree.java b/src/main/java/com/minecolonies/coremod/research/GlobalResearchTree.java\nindex b04cda5464..2aaf38c2f1 100755\n--- a/src/main/java/com/minecolonies/coremod/research/GlobalResearchTree.java\n+++ b/src/main/java/com/minecolonies/coremod/research/GlobalResearchTree.java\n\n@@ -140,32 +139,21 @@ public class GlobalResearchTree implements IGlobalResearchTree\n             return Collections.emptyList();\n         }\n         return researchTree.get(branch).values().stream().filter(research -> research.getParent().isEmpty())\n-                 .sorted(Comparator.comparing(IGlobalResearch::getResourceLocation))\n+                 .sorted(Comparator.comparing(IGlobalResearch::getId))\n                  .map(IGlobalResearch::getId).collect(Collectors.toList());\n     }\n \n     @Override\n     public void reset()\n     {\n-        for(ResourceLocation reset : resettableResearch)\n+        for(String reset : reloadableResearch)\n         {\n-            if(!researchResourceLocations.containsKey(reset))\n-            {\n-                continue;\n-            }\n             for(Map.Entry<String, Map<String, IGlobalResearch>> branch : researchTree.entrySet())\n             {\n-                if(branch.getValue().containsKey(researchResourceLocations.get(reset)));\n-                {\n-                    branch.getValue().remove(researchResourceLocations.get(reset));\n-                }\n-            }\n-            if(researchResourceLocations.containsKey(reset))\n-            {\n-                researchResourceLocations.remove(reset);\n+                branch.getValue().remove(reset);\n             }\n         }\n-        resettableResearch.clear();\n+        reloadableResearch.clear();\n         // Autostart is only accessible as a dynamically-assigned trait, so we can reset all of it.\n         autostartResearch.clear();\n         final Iterator<Map.Entry<String, Map<String, IGlobalResearch>>> iterator = researchTree.entrySet().iterator();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4OTMyNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548489325", "bodyText": "I don't think I want this to be configurable via the config file so easily. Either people play creative mode and get it instant, or wait 1h for a level 1 research.", "author": "Raycoms", "createdAt": "2020-12-24T10:45:54Z", "path": "src/main/java/com/minecolonies/coremod/research/LocalResearch.java", "diffHunk": "@@ -57,11 +59,14 @@ public boolean research(final IResearchEffectManager effects, final ILocalResear\n     {\n         if (state == ResearchState.IN_PROGRESS)\n         {\n-            progress++;\n+            progress += (1 * MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchSpeedMultiplier.get());\n             if (progress >= BASE_RESEARCH_TIME * Math.pow(2, depth - 1))", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5NDcwMg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548494702", "bodyText": "Largely trying to consider the modpack case, where there may be a whole ton of extra recipe-related use cases (and testing non-creative behavior).   Would making it a separate Json in the data pack avoid the \u2018every schmuck immediately configs to max\u2019 issue?", "author": "gattsuru", "createdAt": "2020-12-24T11:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4OTMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5NTkwOQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548495909", "bodyText": "Potentially we could have a setting per \"main branch\" on how long each research needs in the datapack.\nLike:\n\"combat\": \"1: (1h per level)\n\"civilian\": 2 (2h per level)\n\"technology\": 0.5 (30min per level)\nCould be a configuration, this way we can also display the exact time each of them needs in the top", "author": "Raycoms", "createdAt": "2020-12-24T11:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4OTMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5ODc1NA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548498754", "bodyText": "Prefer to keep the power-of-two approach in that case over defining levels individually?", "author": "gattsuru", "createdAt": "2020-12-24T11:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4OTMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5OTI3Mg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548499272", "bodyText": "I'd keep the power of two. If one day a pack maker actually wants to define this more fine grained, we can think about this.", "author": "Raycoms", "createdAt": "2020-12-24T11:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4OTMyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/LocalResearch.java b/src/main/java/com/minecolonies/coremod/research/LocalResearch.java\nindex 4d38dfe216..68c7ce6eed 100755\n--- a/src/main/java/com/minecolonies/coremod/research/LocalResearch.java\n+++ b/src/main/java/com/minecolonies/coremod/research/LocalResearch.java\n\n@@ -59,11 +58,11 @@ public class LocalResearch implements ILocalResearch\n     {\n         if (state == ResearchState.IN_PROGRESS)\n         {\n-            progress += (1 * MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchSpeedMultiplier.get());\n-            if (progress >= BASE_RESEARCH_TIME * Math.pow(2, depth - 1))\n+            progress++;\n+            if (progress >= BASE_RESEARCH_TIME * IGlobalResearchTree.getInstance().getBranchTime(branch) * Math.pow(2, depth - 1))\n             {\n                 state = ResearchState.FINISHED;\n-                for(final IResearchEffect effect : IGlobalResearchTree.getInstance().getResearch(this.branch, this.getId()).getEffects())\n+                for(final IResearchEffect<?> effect : IGlobalResearchTree.getInstance().getResearch(this.branch, this.getId()).getEffects())\n                 {\n                     effects.applyEffect(effect);\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4OTc0Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548489743", "bodyText": "I would only allow to reset research without concluded parents. This way players have to reset one by one.", "author": "Raycoms", "createdAt": "2020-12-24T10:47:16Z", "path": "src/main/java/com/minecolonies/coremod/research/LocalResearchTree.java", "diffHunk": "@@ -94,7 +129,68 @@ public boolean branchFinishedHighestLevel(final String branch)\n     @Override\n     public void finishResearch(final String id)\n     {\n-        inProgress.remove(id);\n+        inProgress.remove(id); isComplete.add(id);\n+    }\n+\n+    @Override\n+    public void cancelResearch(final String branch, final String id, final IColony colony)\n+    {\n+        checkAndResetDescendants(branch, Arrays.asList(id));", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/LocalResearchTree.java b/src/main/java/com/minecolonies/coremod/research/LocalResearchTree.java\nindex 4b3a67f16c..2ba3de4aef 100755\n--- a/src/main/java/com/minecolonies/coremod/research/LocalResearchTree.java\n+++ b/src/main/java/com/minecolonies/coremod/research/LocalResearchTree.java\n\n@@ -129,66 +124,176 @@ public class LocalResearchTree implements ILocalResearchTree\n     @Override\n     public void finishResearch(final String id)\n     {\n-        inProgress.remove(id); isComplete.add(id);\n+        inProgress.remove(id);\n+        isComplete.add(id);\n     }\n \n     @Override\n-    public void cancelResearch(final String branch, final String id, final IColony colony)\n+    public void attemptBeginResearch(final PlayerEntity player, final IColony colony, final IGlobalResearch research)\n     {\n-        checkAndResetDescendants(branch, Arrays.asList(id));\n-\n-        if(colony != null)\n+        if (colony.getResearchManager().getResearchTree().getResearch(research.getBranch(), research.getId()) == null)\n         {\n-            // There's no guarantee that undoing a research will only push its effects back one strength grade.\n-            // Instead, we have to apply every extant effect again.\n-            // Because effects may cross branches, must check all branches, not just the current one.\n-            colony.getResearchManager().getResearchEffects().clear();\n-            for (final Map.Entry<String, Map<String, ILocalResearch>> br : researchTree.entrySet())\n+            if (player.isCreative())\n+            {\n+                research.startResearch(colony.getResearchManager().getResearchTree());\n+                if (MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n+                {\n+                    colony.getResearchManager()\n+                      .getResearchTree()\n+                      .getResearch(research.getBranch(), research.getId())\n+                      .setProgress((int) (BASE_RESEARCH_TIME * IGlobalResearchTree.getInstance().getBranchTime(research.getBranch()) * Math.pow(2, research.getDepth() - 1)));\n+                }\n+                SoundUtils.playSuccessSound(player, player.getPosition());\n+                return;\n+            }\n+            if (research.hasEnoughResources(new InvWrapper(player.inventory)))\n             {\n-                for(final Map.Entry<String, ILocalResearch> research : br.getValue().entrySet())\n+                if (!research.getResearchRequirement().isEmpty())\n                 {\n-                    if(research.getValue().getState() == ResearchState.FINISHED)\n+                    for (IResearchRequirement requirement : research.getResearchRequirement())\n                     {\n-                        for(final IResearchEffect effect : IGlobalResearchTree.getInstance().getResearch(br.getKey(), research.getValue().getId()).getEffects())\n+                        if (!requirement.isFulfilled(colony))\n                         {\n-                            colony.getResearchManager().getResearchEffects().applyEffect(effect);\n+                            player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.requirementnotmet\"), player.getUniqueID());\n+                            SoundUtils.playErrorSound(player, player.getPosition());\n+                            return;\n                         }\n                     }\n                 }\n+                // Remove items from player\n+                if (!InventoryUtils.tryRemoveStorageFromItemHandler(new InvWrapper(player.inventory), research.getCostList()))\n+                {\n+                    player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.costnotavailable\", new TranslationTextComponent(research.getName())),\n+                      player.getUniqueID());\n+                    SoundUtils.playErrorSound(player, player.getPosition());\n+                    return;\n+                }\n+                player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.started\", new TranslationTextComponent(research.getName())),\n+                  player.getUniqueID());\n+                research.startResearch(colony.getResearchManager().getResearchTree());\n+                SoundUtils.playSuccessSound(player, player.getPosition());\n             }\n         }\n-\n+        else\n+        {\n+            if(player.isCreative())\n+            {\n+                if (MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get())\n+                {\n+                    colony.getResearchManager()\n+                      .getResearchTree()\n+                      .getResearch(research.getBranch(), research.getId())\n+                      .setProgress((int) (BASE_RESEARCH_TIME * IGlobalResearchTree.getInstance().getBranchTime(research.getBranch()) * Math.pow(2, research.getDepth() - 1)));\n+                }\n+            }\n+            else\n+            {\n+                player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.alreadystarted\"), player.getUniqueID());\n+                SoundUtils.playErrorSound(player, player.getPosition());\n+            }\n+        }\n+        colony.markDirty();\n     }\n \n-    /**\n-     *  Recursively checks descendant researches, and resets their status, if complete.\n-     * @param branch      branch from which to remove research.\n-     * @param ids          identifier of the specific research.\n-     */\n-    private void checkAndResetDescendants(final String branch, final List<String> ids)\n+    @Override\n+    public void attemptResetResearch(final PlayerEntity player, final IColony colony, final ILocalResearch research)\n     {\n-        for(String id : ids)\n+        // If in progress and get another request, cancel research, and remove it from the local tree.\n+        if(research.getState() == ResearchState.IN_PROGRESS)\n+        {\n+            player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.stopped\",\n+                new TranslationTextComponent(IGlobalResearchTree.getInstance().getResearch(research.getBranch(), research.getId()).getName())), player.getUniqueID());\n+            SoundUtils.playSuccessSound(player, player.getPosition());\n+            removeResearch(research.getBranch(), research.getId());\n+        }\n+        // If complete, it's a request to undo the research.\n+        else if (research.getState() == ResearchState.FINISHED)\n         {\n-            final ILocalResearch localResearch = getResearch(branch, id);\n-            if(localResearch == null)\n+            for(String childIds : IGlobalResearchTree.getInstance().getResearch(research.getBranch(), research.getId()).getChildren())\n             {\n-                continue;\n+                if(researchTree.get(research.getBranch()).get(childIds) != null)\n+                {\n+                    player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.undo.haschilds\"), player.getUniqueID());\n+                    SoundUtils.playErrorSound(player, player.getPosition());\n+                    return;\n+                }\n             }\n-            checkAndResetDescendants(branch, IGlobalResearchTree.getInstance().getResearch(branch, id).getChildren());\n \n-            researchTree.get(branch).remove(id);\n-            if(inProgress.containsKey(id))\n-            {\n-                inProgress.remove(id);\n-            }\n-            if(isComplete.contains(id))\n+            if(!player.isCreative())\n             {\n-                isComplete.remove(id);\n+                final List<ItemStorage> costList = new ArrayList<>();\n+                for (final String cost : IGlobalResearchTree.getInstance().getResearchResetCosts())\n+                {\n+                    // Validated cost metrics during ResearchListener, so doesn't need to be redone here.\n+                    // Do, however, need to check against air, in case item type does not exist.\n+                    final String[] costParts = cost.split(\":\");\n+                    final Item costItem = ForgeRegistries.ITEMS.getValue(new ResourceLocation(costParts[0], costParts[1]));\n+                    if(costItem != null && !costItem.equals(Items.AIR))\n+                    {\n+                        costList.add(new ItemStorage(new ItemStack(costItem, Integer.parseInt(costParts[2])), false, true));\n+                    }\n+                }\n+                if (!InventoryUtils.tryRemoveStorageFromItemHandler(new InvWrapper(player.inventory), costList))\n+                {\n+                    player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.costnotavailable\",\n+                        new TranslationTextComponent(IGlobalResearchTree.getInstance().getResearch(research.getBranch(), research.getId()).getName())), player.getUniqueID());\n+                    SoundUtils.playErrorSound(player, player.getPosition());\n+                    return;\n+                }\n             }\n-            if (IGlobalResearchTree.getInstance().getResearch(branch, id).getDepth() == MAX_DEPTH\n-                  && maxLevelResearchCompleted.contains(branch))\n+            player.sendMessage(new TranslationTextComponent(\"com.minecolonies.coremod.research.undo\",\n+              new TranslationTextComponent(IGlobalResearchTree.getInstance().getResearch(research.getBranch(), research.getId()).getName())), player.getUniqueID());\n+            SoundUtils.playSuccessSound(player, player.getPosition());\n+            removeResearch(research.getBranch(), research.getId());\n+            resetEffects(colony);\n+        }\n+        colony.markDirty();\n+    }\n+\n+    /**\n+     * Does the heavy lifting to remove research and, optionally, effects.\n+     * @param branch            The research branch id.\n+     * @param id                The research id.\n+     */\n+    private void removeResearch(final String branch, final String id)\n+    {\n+        if (!researchTree.get(branch).containsKey(id))\n+        {\n+            Log.getLogger().warn(\"Something went wrong: player attempted to reset research that does not exist or is not started\");\n+        }\n+        researchTree.get(branch).remove(id);\n+        inProgress.remove(id);\n+        isComplete.remove(id);\n+        if (IGlobalResearchTree.getInstance().getResearch(branch, id).getDepth() == MAX_DEPTH)\n+        {\n+            maxLevelResearchCompleted.remove(branch);\n+        }\n+    }\n+\n+    /**\n+     * Resets effects for a specific colony.\n+     * @param colony        The colony to reset research effects.\n+     */\n+    private void resetEffects(IColony colony)\n+    {\n+        if (colony != null)\n+        {\n+            // There's no guarantee that undoing a research will only push its effects back one strength grade.\n+            // Instead, we have to apply every extant effect again.\n+            // Because effects may cross branches, must check all branches, not just the current one.\n+            colony.getResearchManager().getResearchEffects().clear();\n+            for (final Map.Entry<String, Map<String, ILocalResearch>> br : researchTree.entrySet())\n             {\n-                maxLevelResearchCompleted.remove(branch);\n+                for (final Map.Entry<String, ILocalResearch> research : br.getValue().entrySet())\n+                {\n+                    if (research.getValue().getState() == ResearchState.FINISHED)\n+                    {\n+                        for (final IResearchEffect<?> effect : IGlobalResearchTree.getInstance().getResearch(br.getKey(), research.getValue().getId()).getEffects())\n+                        {\n+                            colony.getResearchManager().getResearchEffects().applyEffect(effect);\n+                        }\n+                    }\n+                }\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5MDIzMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r548490231", "bodyText": "double too", "author": "Raycoms", "createdAt": "2020-12-24T10:49:02Z", "path": "src/main/java/com/minecolonies/coremod/research/ResearchEffectManager.java", "diffHunk": "@@ -25,10 +27,35 @@\n         {\n             return (W) effect;\n         }\n-\n         return null;\n     }\n \n+    @Override\n+    public float getEffectValue(final String id)", "originalCommit": "e4248071b4dc8fa7f5fb2bf5f2586c650a04fc86", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/research/ResearchEffectManager.java b/src/main/java/com/minecolonies/coremod/research/ResearchEffectManager.java\nindex 94f36d74b9..43d955f5ca 100755\n--- a/src/main/java/com/minecolonies/coremod/research/ResearchEffectManager.java\n+++ b/src/main/java/com/minecolonies/coremod/research/ResearchEffectManager.java\n\n@@ -31,7 +29,7 @@ public class ResearchEffectManager implements IResearchEffectManager\n     }\n \n     @Override\n-    public float getEffectValue(final String id)\n+    public double getEffectValue(final String id)\n     {\n         if(effectMap.containsKey(id))\n         {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDU4Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549130586", "bodyText": "probably use else if\nand put research into else branch", "author": "Nightenom", "createdAt": "2020-12-27T16:11:10Z", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java", "diffHunk": "@@ -74,57 +99,94 @@ public WindowResearchTree(final String branch, final BuildingUniversity.View bui\n \n         final ZoomDragView view = findPaneOfTypeByID(DRAG_VIEW_ID, ZoomDragView.class);\n \n-        drawTree(0, 0, view, researchList, building.getColony().getResearchManager().getResearchTree(), true, false, 0);\n-\n-        for (int i = 1; i <= MAX_DEPTH; i++)\n-        {\n-            final Label timeLabel = new Label();\n-            timeLabel.setLabelText(Math.pow(2, i - 1) + \"h\");\n-            timeLabel.setPosition((i - 1) * (GRADIENT_WIDTH + X_SPACING) + GRADIENT_WIDTH / 2, TIMELABEL_Y_POSITION);\n-            timeLabel.setColor(Color.rgbaToInt(218, 202, 171, 255));\n-            view.addChild(timeLabel);\n-        }\n+        drawTreeBackground(view);\n+        drawTree(0, 0, view, researchList, false);\n     }\n \n-    /**\n-     *\n-     * @param researchRequirement requirement to start research\n-     * @return whether the requirement has been satisfied for research\n-     */\n-    private boolean isResearchFulfilled(final BuildingResearchRequirement researchRequirement)\n+    @Override\n+    public void onButtonClicked(@NotNull final Button button)\n     {\n-        List<IBuildingView> buildings = building.getColony().getBuildings();\n-        int levels = 0;\n-\n-        if (researchRequirement == null)\n+        super.onButtonClicked(button);\n+        if (button.getParent().getChildren().contains(undoButton))\n         {\n-            return true;\n+            button.getParent().removeChild(undoButton);\n         }\n-\n-        for (IBuildingView building : buildings)\n+        for(ItemIcon icon : undoCostIcons)\n         {\n-            if (building.getSchematicName().equals(researchRequirement.getBuilding()))\n+            if(button.getParent().getChildren().contains(icon))\n             {\n-                levels += building.getBuildingLevel();\n+                button.getParent().removeChild(icon);\n             }\n         }\n-\n-        return levels >= researchRequirement.getBuildingLevel();\n-    }\n-\n-    @Override\n-    public void onButtonClicked(@NotNull final Button button)\n-    {\n-        super.onButtonClicked(button);\n+        if(displacedButton != null && displacedHoverText != null)\n+        {\n+            displacedButton.setHoverToolTip(displacedHoverText);\n+        }\n+        if(button.getID().isEmpty())\n+        {\n+            return;\n+        }\n \n         final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, button.getID());\n-        if (research != null &&\n-              building.getBuildingLevel() > building.getColony().getResearchManager().getResearchTree().getResearchInProgress().size() &&\n-              (building.getBuildingLevel() >= research.getDepth() || building.getBuildingLevel() == building.getBuildingMaxLevel()) &&\n-              research.hasEnoughResources(new InvWrapper(Minecraft.getInstance().player.inventory)) || (research != null && mc.player.isCreative()))\n+        if (research != null && (building.getBuildingLevel() >= research.getDepth() || building.getBuildingLevel() == building.getBuildingMaxLevel()))\n         {\n-            Network.getNetwork().sendToServer(new TryResearchMessage(building, research.getId(), research.getBranch()));\n-            close();\n+            final ILocalResearch localResearch = building.getColony().getResearchManager().getResearchTree().getResearch(branch, research.getId());\n+            if (localResearch == null && building.getBuildingLevel() > building.getColony().getResearchManager().getResearchTree().getResearchInProgress().size()&&\n+                  (research.hasEnoughResources(new InvWrapper(Minecraft.getInstance().player.inventory)) || (mc.player.isCreative())))\n+            {\n+                // this side won't actually start research; it'll be overridden the next colony update from the server.\n+                // It will, however, update for the next WindowResearchTree if the colony update is slow to come back.\n+                research.startResearch(building.getColony().getResearchManager().getResearchTree());\n+                Network.getNetwork().sendToServer(new TryResearchMessage(building, research.getId(), research.getBranch(), false));\n+                close();\n+            }\n+            else if (localResearch != null)\n+            {\n+                if (localResearch.getState() == ResearchState.IN_PROGRESS)\n+                {\n+                    drawUndoProgressButton(button);\n+                }\n+                if (localResearch.getState() == ResearchState.FINISHED)\n+                {\n+                    if(hasMax && research.getDepth() == MAX_DEPTH && building.getBuildingLevel() == building.getBuildingMaxLevel() && !research.isImmutable())\n+                    {\n+                        drawUndoCompleteButton(button);\n+                    }\n+                    for(String childId : research.getChildren())\n+                    {\n+                        if(building.getColony().getResearchManager().getResearchTree().getResearch(branch, childId) != null\n+                          && building.getColony().getResearchManager().getResearchTree().getResearch(branch, childId).getState() != ResearchState.NOT_STARTED)\n+                        {\n+                            return;\n+                        }\n+                    }\n+                    String parentId = IGlobalResearchTree.getInstance().getResearch(branch, research.getId()).getParent();\n+                    while(!parentId.isEmpty())\n+                    {\n+                        if (IGlobalResearchTree.getInstance().getResearch(branch, parentId) != null\n+                              && IGlobalResearchTree.getInstance().getResearch(branch, parentId).hasOnlyChild())\n+                        {\n+                            drawUndoCompleteButton(button);\n+                            break;\n+                        }\n+                        parentId = IGlobalResearchTree.getInstance().getResearch(branch, parentId).getParent();\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (button.getID().contains(\"undo.\"))", "originalCommit": "85bf74e02a2059bdfec659503a04ecb4037bf91b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\nindex b72d8d6956..47f547278c 100755\n--- a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n+++ b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n\n@@ -99,44 +97,90 @@ public class WindowResearchTree extends AbstractWindowSkeleton\n \n         final ZoomDragView view = findPaneOfTypeByID(DRAG_VIEW_ID, ZoomDragView.class);\n \n-        drawTreeBackground(view);\n-        drawTree(0, 0, view, researchList, false);\n+        final int maxHeight = drawTree(0, 0, view, researchList, false);\n+        drawTreeBackground(view, maxHeight);\n     }\n \n     @Override\n     public void onButtonClicked(@NotNull final Button button)\n     {\n         super.onButtonClicked(button);\n+\n+        // drawUndoProgressButton and drawUndoCompleteButton replace a Research's normal tooltip\n+        // and adds a button and icon(s) representing the cost of resetting the research.\n+        // See their respective functions for details on the how.\n+        // These branches remove those buttons from the DragTreeView, if present, on pressing any button.\n+        // That should occur no matter what buttons are pressed, even disabled buttons, as a \"no, I don't want to\".\n+        // We'll do that even for branches that will close the WindowResearchTree for now,\n+        // since down the road we may want to be able to cancel or start multiple researches without\n+        // closing and reopening the WindowResearchTree.\n         if (button.getParent().getChildren().contains(undoButton))\n         {\n             button.getParent().removeChild(undoButton);\n         }\n-        for(ItemIcon icon : undoCostIcons)\n+        for (ItemIcon icon : undoCostIcons)\n         {\n-            if(button.getParent().getChildren().contains(icon))\n+            if (button.getParent().getChildren().contains(icon))\n             {\n                 button.getParent().removeChild(icon);\n             }\n         }\n-        if(displacedButton != null && displacedHoverText != null)\n+        if (displacedButton != null && displacedHoverText != null)\n         {\n             displacedButton.setHoverToolTip(displacedHoverText);\n         }\n-        if(button.getID().isEmpty())\n+\n+        // Check for an empty button Id.  These reflect disabled buttons normally\n+        // but a sufficiently malformed data pack may also have a blank research id,\n+        // and we don't want to try to try to parse that.\n+        // May eventually want a sound handler here, but SoundUtils.playErrorSound is a bit much.\n+        if (button.getID().isEmpty())\n         {\n-            return;\n+            // intentionally empty.\n         }\n-\n-        final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, button.getID());\n-        if (research != null && (building.getBuildingLevel() >= research.getDepth() || building.getBuildingLevel() == building.getBuildingMaxLevel()))\n+        // Undo just the selected research.\n+        else if (button.getID().contains(\"undo.\"))\n         {\n+            final ILocalResearch cancelResearch = building.getColony().getResearchManager().getResearchTree().getResearch(branch, button.getID().split(\"\\\\.\")[1]);\n+            if (cancelResearch != null)\n+            {\n+                // Can't rely on getting an updated research count after the cancellation in any predictable timeframe.\n+                // Instead, offset the UniversityWindow's count by -1 before the packet could be sent.\n+                if (cancelResearch.getState() == ResearchState.IN_PROGRESS)\n+                {\n+                    last.updateResearchCount(-1);\n+                }\n+                // Canceled research will eventually be removed from the local tree on synchronization from server,\n+                // But this can be long enough (~5 seconds) to cause confusion if the player reopens the WindowResearchTree.\n+                // Completely removing the research to null will allow players to unintentionally restart it.\n+                // While the server-side logic prevents this from taking items, it would be confusing.\n+                // Setting to NOT_STARTED means that it can't be sent, as only null research states\n+                // are eligible to send TryResearchMessages, and only IN_PROGRESS, or FINISHED\n+                // are eligible to drawUndo buttons.\n+                cancelResearch.setState(ResearchState.NOT_STARTED);\n+                Network.getNetwork().sendToServer(new TryResearchMessage(building, cancelResearch.getId(), cancelResearch.getBranch(), true));\n+                close();\n+            }\n+        }\n+        else if (IGlobalResearchTree.getInstance().getResearch(branch, button.getID()) != null\n+                   && (building.getBuildingLevel() >= IGlobalResearchTree.getInstance().getResearch(branch, button.getID()).getDepth()\n+                         || building.getBuildingLevel() == building.getBuildingMaxLevel()))\n+        {\n+            final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, button.getID());\n             final ILocalResearch localResearch = building.getColony().getResearchManager().getResearchTree().getResearch(branch, research.getId());\n-            if (localResearch == null && building.getBuildingLevel() > building.getColony().getResearchManager().getResearchTree().getResearchInProgress().size()&&\n+            if (localResearch == null && building.getBuildingLevel() > building.getColony().getResearchManager().getResearchTree().getResearchInProgress().size() &&\n                   (research.hasEnoughResources(new InvWrapper(Minecraft.getInstance().player.inventory)) || (mc.player.isCreative())))\n             {\n-                // this side won't actually start research; it'll be overridden the next colony update from the server.\n+                // This side won't actually start research; it'll be overridden the next colony update from the server.\n                 // It will, however, update for the next WindowResearchTree if the colony update is slow to come back.\n+                // Again, the server will prevent someone from paying items twice, but this avoids some confusion.\n                 research.startResearch(building.getColony().getResearchManager().getResearchTree());\n+                // don't need to offset count here, as the startResearch will pad it until the new Colony data comes in.\n+                last.updateResearchCount(0);\n+                if (research.getDepth() > building.getBuildingMaxLevel())\n+                {\n+                    hasMax = true;\n+                }\n                 Network.getNetwork().sendToServer(new TryResearchMessage(building, research.getId(), research.getBranch(), false));\n                 close();\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDYzNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549130635", "bodyText": "This sounds a bit weird handling to me", "author": "Nightenom", "createdAt": "2020-12-27T16:11:42Z", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java", "diffHunk": "@@ -74,57 +99,94 @@ public WindowResearchTree(final String branch, final BuildingUniversity.View bui\n \n         final ZoomDragView view = findPaneOfTypeByID(DRAG_VIEW_ID, ZoomDragView.class);\n \n-        drawTree(0, 0, view, researchList, building.getColony().getResearchManager().getResearchTree(), true, false, 0);\n-\n-        for (int i = 1; i <= MAX_DEPTH; i++)\n-        {\n-            final Label timeLabel = new Label();\n-            timeLabel.setLabelText(Math.pow(2, i - 1) + \"h\");\n-            timeLabel.setPosition((i - 1) * (GRADIENT_WIDTH + X_SPACING) + GRADIENT_WIDTH / 2, TIMELABEL_Y_POSITION);\n-            timeLabel.setColor(Color.rgbaToInt(218, 202, 171, 255));\n-            view.addChild(timeLabel);\n-        }\n+        drawTreeBackground(view);\n+        drawTree(0, 0, view, researchList, false);\n     }\n \n-    /**\n-     *\n-     * @param researchRequirement requirement to start research\n-     * @return whether the requirement has been satisfied for research\n-     */\n-    private boolean isResearchFulfilled(final BuildingResearchRequirement researchRequirement)\n+    @Override\n+    public void onButtonClicked(@NotNull final Button button)\n     {\n-        List<IBuildingView> buildings = building.getColony().getBuildings();\n-        int levels = 0;\n-\n-        if (researchRequirement == null)\n+        super.onButtonClicked(button);\n+        if (button.getParent().getChildren().contains(undoButton))\n         {\n-            return true;\n+            button.getParent().removeChild(undoButton);\n         }\n-\n-        for (IBuildingView building : buildings)\n+        for(ItemIcon icon : undoCostIcons)\n         {\n-            if (building.getSchematicName().equals(researchRequirement.getBuilding()))\n+            if(button.getParent().getChildren().contains(icon))\n             {\n-                levels += building.getBuildingLevel();\n+                button.getParent().removeChild(icon);\n             }\n         }\n-\n-        return levels >= researchRequirement.getBuildingLevel();\n-    }\n-\n-    @Override\n-    public void onButtonClicked(@NotNull final Button button)\n-    {\n-        super.onButtonClicked(button);\n+        if(displacedButton != null && displacedHoverText != null)\n+        {\n+            displacedButton.setHoverToolTip(displacedHoverText);\n+        }\n+        if(button.getID().isEmpty())\n+        {\n+            return;\n+        }\n \n         final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, button.getID());\n-        if (research != null &&\n-              building.getBuildingLevel() > building.getColony().getResearchManager().getResearchTree().getResearchInProgress().size() &&\n-              (building.getBuildingLevel() >= research.getDepth() || building.getBuildingLevel() == building.getBuildingMaxLevel()) &&\n-              research.hasEnoughResources(new InvWrapper(Minecraft.getInstance().player.inventory)) || (research != null && mc.player.isCreative()))\n+        if (research != null && (building.getBuildingLevel() >= research.getDepth() || building.getBuildingLevel() == building.getBuildingMaxLevel()))\n         {\n-            Network.getNetwork().sendToServer(new TryResearchMessage(building, research.getId(), research.getBranch()));\n-            close();\n+            final ILocalResearch localResearch = building.getColony().getResearchManager().getResearchTree().getResearch(branch, research.getId());\n+            if (localResearch == null && building.getBuildingLevel() > building.getColony().getResearchManager().getResearchTree().getResearchInProgress().size()&&\n+                  (research.hasEnoughResources(new InvWrapper(Minecraft.getInstance().player.inventory)) || (mc.player.isCreative())))\n+            {\n+                // this side won't actually start research; it'll be overridden the next colony update from the server.\n+                // It will, however, update for the next WindowResearchTree if the colony update is slow to come back.\n+                research.startResearch(building.getColony().getResearchManager().getResearchTree());\n+                Network.getNetwork().sendToServer(new TryResearchMessage(building, research.getId(), research.getBranch(), false));\n+                close();\n+            }\n+            else if (localResearch != null)\n+            {\n+                if (localResearch.getState() == ResearchState.IN_PROGRESS)\n+                {\n+                    drawUndoProgressButton(button);\n+                }\n+                if (localResearch.getState() == ResearchState.FINISHED)\n+                {\n+                    if(hasMax && research.getDepth() == MAX_DEPTH && building.getBuildingLevel() == building.getBuildingMaxLevel() && !research.isImmutable())\n+                    {\n+                        drawUndoCompleteButton(button);\n+                    }\n+                    for(String childId : research.getChildren())\n+                    {\n+                        if(building.getColony().getResearchManager().getResearchTree().getResearch(branch, childId) != null\n+                          && building.getColony().getResearchManager().getResearchTree().getResearch(branch, childId).getState() != ResearchState.NOT_STARTED)\n+                        {\n+                            return;\n+                        }\n+                    }\n+                    String parentId = IGlobalResearchTree.getInstance().getResearch(branch, research.getId()).getParent();\n+                    while(!parentId.isEmpty())\n+                    {\n+                        if (IGlobalResearchTree.getInstance().getResearch(branch, parentId) != null\n+                              && IGlobalResearchTree.getInstance().getResearch(branch, parentId).hasOnlyChild())\n+                        {\n+                            drawUndoCompleteButton(button);\n+                            break;\n+                        }\n+                        parentId = IGlobalResearchTree.getInstance().getResearch(branch, parentId).getParent();\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (button.getID().contains(\"undo.\"))\n+        {\n+            final ILocalResearch cancelResearch = building.getColony().getResearchManager().getResearchTree().getResearch(branch, button.getID().split(\"\\\\.\")[1]);\n+            if (cancelResearch != null)\n+            {\n+                // Canceled research will eventually be removed from the local tree on synchronization from server,\n+                // But this can be long enough to be confusing.  NOT_STARTED isn't the same thing,\n+                // but will render closely enough to prevent some confusion /or/ accidentally restarting.", "originalCommit": "85bf74e02a2059bdfec659503a04ecb4037bf91b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE0NDU3MA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549144570", "bodyText": "There's logic on the server side that prevents clients issuing bad requests from resulting in lost items, so I can get rid of it if we don't want munging of the localResearchTree between updates from the server.  It just seemed clearer a way to show the research as removed while waiting for the next colony.markDirty() result to come in -- I've seen ~5 seconds on a same-machine dedicated server, and I'm sure it could be longer.\nNOT_STARTED without nulling it prevents people from unintentionally trying to issue a begin research command, which may be part of why it's a bit hacky.", "author": "gattsuru", "createdAt": "2020-12-27T17:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDYzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\nindex b72d8d6956..47f547278c 100755\n--- a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n+++ b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n\n@@ -99,44 +97,90 @@ public class WindowResearchTree extends AbstractWindowSkeleton\n \n         final ZoomDragView view = findPaneOfTypeByID(DRAG_VIEW_ID, ZoomDragView.class);\n \n-        drawTreeBackground(view);\n-        drawTree(0, 0, view, researchList, false);\n+        final int maxHeight = drawTree(0, 0, view, researchList, false);\n+        drawTreeBackground(view, maxHeight);\n     }\n \n     @Override\n     public void onButtonClicked(@NotNull final Button button)\n     {\n         super.onButtonClicked(button);\n+\n+        // drawUndoProgressButton and drawUndoCompleteButton replace a Research's normal tooltip\n+        // and adds a button and icon(s) representing the cost of resetting the research.\n+        // See their respective functions for details on the how.\n+        // These branches remove those buttons from the DragTreeView, if present, on pressing any button.\n+        // That should occur no matter what buttons are pressed, even disabled buttons, as a \"no, I don't want to\".\n+        // We'll do that even for branches that will close the WindowResearchTree for now,\n+        // since down the road we may want to be able to cancel or start multiple researches without\n+        // closing and reopening the WindowResearchTree.\n         if (button.getParent().getChildren().contains(undoButton))\n         {\n             button.getParent().removeChild(undoButton);\n         }\n-        for(ItemIcon icon : undoCostIcons)\n+        for (ItemIcon icon : undoCostIcons)\n         {\n-            if(button.getParent().getChildren().contains(icon))\n+            if (button.getParent().getChildren().contains(icon))\n             {\n                 button.getParent().removeChild(icon);\n             }\n         }\n-        if(displacedButton != null && displacedHoverText != null)\n+        if (displacedButton != null && displacedHoverText != null)\n         {\n             displacedButton.setHoverToolTip(displacedHoverText);\n         }\n-        if(button.getID().isEmpty())\n+\n+        // Check for an empty button Id.  These reflect disabled buttons normally\n+        // but a sufficiently malformed data pack may also have a blank research id,\n+        // and we don't want to try to try to parse that.\n+        // May eventually want a sound handler here, but SoundUtils.playErrorSound is a bit much.\n+        if (button.getID().isEmpty())\n         {\n-            return;\n+            // intentionally empty.\n         }\n-\n-        final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, button.getID());\n-        if (research != null && (building.getBuildingLevel() >= research.getDepth() || building.getBuildingLevel() == building.getBuildingMaxLevel()))\n+        // Undo just the selected research.\n+        else if (button.getID().contains(\"undo.\"))\n         {\n+            final ILocalResearch cancelResearch = building.getColony().getResearchManager().getResearchTree().getResearch(branch, button.getID().split(\"\\\\.\")[1]);\n+            if (cancelResearch != null)\n+            {\n+                // Can't rely on getting an updated research count after the cancellation in any predictable timeframe.\n+                // Instead, offset the UniversityWindow's count by -1 before the packet could be sent.\n+                if (cancelResearch.getState() == ResearchState.IN_PROGRESS)\n+                {\n+                    last.updateResearchCount(-1);\n+                }\n+                // Canceled research will eventually be removed from the local tree on synchronization from server,\n+                // But this can be long enough (~5 seconds) to cause confusion if the player reopens the WindowResearchTree.\n+                // Completely removing the research to null will allow players to unintentionally restart it.\n+                // While the server-side logic prevents this from taking items, it would be confusing.\n+                // Setting to NOT_STARTED means that it can't be sent, as only null research states\n+                // are eligible to send TryResearchMessages, and only IN_PROGRESS, or FINISHED\n+                // are eligible to drawUndo buttons.\n+                cancelResearch.setState(ResearchState.NOT_STARTED);\n+                Network.getNetwork().sendToServer(new TryResearchMessage(building, cancelResearch.getId(), cancelResearch.getBranch(), true));\n+                close();\n+            }\n+        }\n+        else if (IGlobalResearchTree.getInstance().getResearch(branch, button.getID()) != null\n+                   && (building.getBuildingLevel() >= IGlobalResearchTree.getInstance().getResearch(branch, button.getID()).getDepth()\n+                         || building.getBuildingLevel() == building.getBuildingMaxLevel()))\n+        {\n+            final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, button.getID());\n             final ILocalResearch localResearch = building.getColony().getResearchManager().getResearchTree().getResearch(branch, research.getId());\n-            if (localResearch == null && building.getBuildingLevel() > building.getColony().getResearchManager().getResearchTree().getResearchInProgress().size()&&\n+            if (localResearch == null && building.getBuildingLevel() > building.getColony().getResearchManager().getResearchTree().getResearchInProgress().size() &&\n                   (research.hasEnoughResources(new InvWrapper(Minecraft.getInstance().player.inventory)) || (mc.player.isCreative())))\n             {\n-                // this side won't actually start research; it'll be overridden the next colony update from the server.\n+                // This side won't actually start research; it'll be overridden the next colony update from the server.\n                 // It will, however, update for the next WindowResearchTree if the colony update is slow to come back.\n+                // Again, the server will prevent someone from paying items twice, but this avoids some confusion.\n                 research.startResearch(building.getColony().getResearchManager().getResearchTree());\n+                // don't need to offset count here, as the startResearch will pad it until the new Colony data comes in.\n+                last.updateResearchCount(0);\n+                if (research.getDepth() > building.getBuildingMaxLevel())\n+                {\n+                    hasMax = true;\n+                }\n                 Network.getNetwork().sendToServer(new TryResearchMessage(building, research.getId(), research.getBranch(), false));\n                 close();\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMTI0OA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549131248", "bodyText": "not sure about this button handling, shouldn't this be in \"if undo pressed\" branch?\nand also the for cycle below in this if branch?", "author": "Nightenom", "createdAt": "2020-12-27T16:17:10Z", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java", "diffHunk": "@@ -74,57 +99,94 @@ public WindowResearchTree(final String branch, final BuildingUniversity.View bui\n \n         final ZoomDragView view = findPaneOfTypeByID(DRAG_VIEW_ID, ZoomDragView.class);\n \n-        drawTree(0, 0, view, researchList, building.getColony().getResearchManager().getResearchTree(), true, false, 0);\n-\n-        for (int i = 1; i <= MAX_DEPTH; i++)\n-        {\n-            final Label timeLabel = new Label();\n-            timeLabel.setLabelText(Math.pow(2, i - 1) + \"h\");\n-            timeLabel.setPosition((i - 1) * (GRADIENT_WIDTH + X_SPACING) + GRADIENT_WIDTH / 2, TIMELABEL_Y_POSITION);\n-            timeLabel.setColor(Color.rgbaToInt(218, 202, 171, 255));\n-            view.addChild(timeLabel);\n-        }\n+        drawTreeBackground(view);\n+        drawTree(0, 0, view, researchList, false);\n     }\n \n-    /**\n-     *\n-     * @param researchRequirement requirement to start research\n-     * @return whether the requirement has been satisfied for research\n-     */\n-    private boolean isResearchFulfilled(final BuildingResearchRequirement researchRequirement)\n+    @Override\n+    public void onButtonClicked(@NotNull final Button button)\n     {\n-        List<IBuildingView> buildings = building.getColony().getBuildings();\n-        int levels = 0;\n-\n-        if (researchRequirement == null)\n+        super.onButtonClicked(button);\n+        if (button.getParent().getChildren().contains(undoButton))", "originalCommit": "85bf74e02a2059bdfec659503a04ecb4037bf91b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzODkwMg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549138902", "bodyText": "These are a hacky way to handle removing the \"undo\" button, icon, and tooltips, and then replace the original contents of the tooltips they were taking the position of (bc multiple overlapping items with hovertext will render all of the hovertext in a mouse position), if any button other than the confirm-undo is pressed.  Because the positions are so malleable, it's hard to redraw individual Research Items without redrawing the entire branch, but I'm certainly open to different approaches.\nIt technically doesn't need to be done for logic paths where the research tree gets closed, but the performance cost of doing them is pretty low, and eventually we may want the ability to handle begin-research or cancel-research events without having to close the tree.", "author": "gattsuru", "createdAt": "2020-12-27T17:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMTI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE0NTI0Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549145243", "bodyText": "bc multiple overlapping items with hovertext will render all of the hovertext in a mouse position\n\nhow about making an issue and let someone actually fix it? :D\nbtw towards \"hacky ways\", sure use them, but make sure they work under every condition and comment them", "author": "Nightenom", "createdAt": "2020-12-27T17:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMTI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE0NjYxMw==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549146613", "bodyText": "Fair.  I could see cases where it'd be useful and intentional -- the ItemIcons render their tooltips over the research tooltips, for example, which I kinda like -- but should have brought it up in Structurize.\nDefinitely will implement better comments for the hacky bits here and elsewhere, rather than just the javadocs.", "author": "gattsuru", "createdAt": "2020-12-27T18:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMTI0OA=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\nindex b72d8d6956..47f547278c 100755\n--- a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n+++ b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n\n@@ -99,44 +97,90 @@ public class WindowResearchTree extends AbstractWindowSkeleton\n \n         final ZoomDragView view = findPaneOfTypeByID(DRAG_VIEW_ID, ZoomDragView.class);\n \n-        drawTreeBackground(view);\n-        drawTree(0, 0, view, researchList, false);\n+        final int maxHeight = drawTree(0, 0, view, researchList, false);\n+        drawTreeBackground(view, maxHeight);\n     }\n \n     @Override\n     public void onButtonClicked(@NotNull final Button button)\n     {\n         super.onButtonClicked(button);\n+\n+        // drawUndoProgressButton and drawUndoCompleteButton replace a Research's normal tooltip\n+        // and adds a button and icon(s) representing the cost of resetting the research.\n+        // See their respective functions for details on the how.\n+        // These branches remove those buttons from the DragTreeView, if present, on pressing any button.\n+        // That should occur no matter what buttons are pressed, even disabled buttons, as a \"no, I don't want to\".\n+        // We'll do that even for branches that will close the WindowResearchTree for now,\n+        // since down the road we may want to be able to cancel or start multiple researches without\n+        // closing and reopening the WindowResearchTree.\n         if (button.getParent().getChildren().contains(undoButton))\n         {\n             button.getParent().removeChild(undoButton);\n         }\n-        for(ItemIcon icon : undoCostIcons)\n+        for (ItemIcon icon : undoCostIcons)\n         {\n-            if(button.getParent().getChildren().contains(icon))\n+            if (button.getParent().getChildren().contains(icon))\n             {\n                 button.getParent().removeChild(icon);\n             }\n         }\n-        if(displacedButton != null && displacedHoverText != null)\n+        if (displacedButton != null && displacedHoverText != null)\n         {\n             displacedButton.setHoverToolTip(displacedHoverText);\n         }\n-        if(button.getID().isEmpty())\n+\n+        // Check for an empty button Id.  These reflect disabled buttons normally\n+        // but a sufficiently malformed data pack may also have a blank research id,\n+        // and we don't want to try to try to parse that.\n+        // May eventually want a sound handler here, but SoundUtils.playErrorSound is a bit much.\n+        if (button.getID().isEmpty())\n         {\n-            return;\n+            // intentionally empty.\n         }\n-\n-        final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, button.getID());\n-        if (research != null && (building.getBuildingLevel() >= research.getDepth() || building.getBuildingLevel() == building.getBuildingMaxLevel()))\n+        // Undo just the selected research.\n+        else if (button.getID().contains(\"undo.\"))\n         {\n+            final ILocalResearch cancelResearch = building.getColony().getResearchManager().getResearchTree().getResearch(branch, button.getID().split(\"\\\\.\")[1]);\n+            if (cancelResearch != null)\n+            {\n+                // Can't rely on getting an updated research count after the cancellation in any predictable timeframe.\n+                // Instead, offset the UniversityWindow's count by -1 before the packet could be sent.\n+                if (cancelResearch.getState() == ResearchState.IN_PROGRESS)\n+                {\n+                    last.updateResearchCount(-1);\n+                }\n+                // Canceled research will eventually be removed from the local tree on synchronization from server,\n+                // But this can be long enough (~5 seconds) to cause confusion if the player reopens the WindowResearchTree.\n+                // Completely removing the research to null will allow players to unintentionally restart it.\n+                // While the server-side logic prevents this from taking items, it would be confusing.\n+                // Setting to NOT_STARTED means that it can't be sent, as only null research states\n+                // are eligible to send TryResearchMessages, and only IN_PROGRESS, or FINISHED\n+                // are eligible to drawUndo buttons.\n+                cancelResearch.setState(ResearchState.NOT_STARTED);\n+                Network.getNetwork().sendToServer(new TryResearchMessage(building, cancelResearch.getId(), cancelResearch.getBranch(), true));\n+                close();\n+            }\n+        }\n+        else if (IGlobalResearchTree.getInstance().getResearch(branch, button.getID()) != null\n+                   && (building.getBuildingLevel() >= IGlobalResearchTree.getInstance().getResearch(branch, button.getID()).getDepth()\n+                         || building.getBuildingLevel() == building.getBuildingMaxLevel()))\n+        {\n+            final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, button.getID());\n             final ILocalResearch localResearch = building.getColony().getResearchManager().getResearchTree().getResearch(branch, research.getId());\n-            if (localResearch == null && building.getBuildingLevel() > building.getColony().getResearchManager().getResearchTree().getResearchInProgress().size()&&\n+            if (localResearch == null && building.getBuildingLevel() > building.getColony().getResearchManager().getResearchTree().getResearchInProgress().size() &&\n                   (research.hasEnoughResources(new InvWrapper(Minecraft.getInstance().player.inventory)) || (mc.player.isCreative())))\n             {\n-                // this side won't actually start research; it'll be overridden the next colony update from the server.\n+                // This side won't actually start research; it'll be overridden the next colony update from the server.\n                 // It will, however, update for the next WindowResearchTree if the colony update is slow to come back.\n+                // Again, the server will prevent someone from paying items twice, but this avoids some confusion.\n                 research.startResearch(building.getColony().getResearchManager().getResearchTree());\n+                // don't need to offset count here, as the startResearch will pad it until the new Colony data comes in.\n+                last.updateResearchCount(0);\n+                if (research.getDepth() > building.getBuildingMaxLevel())\n+                {\n+                    hasMax = true;\n+                }\n                 Network.getNetwork().sendToServer(new TryResearchMessage(building, research.getId(), research.getBranch(), false));\n                 close();\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMjkzOQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549132939", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        gradient.setPosition((6 - 1) * (GRADIENT_WIDTH + X_SPACING), 0);\n          \n          \n            \n                        gradient.setPosition((MAX_DEPTH - 1) * (GRADIENT_WIDTH + X_SPACING), 0);\n          \n      \n    \n    \n  \n\nonly if you are not gonna rewrite it", "author": "Nightenom", "createdAt": "2020-12-27T16:26:07Z", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java", "diffHunk": "@@ -137,299 +199,775 @@ public void onButtonClicked(@NotNull final Button button)\n     /**\n      * Draw the tree of research.\n      *\n-     * @param height           the start y offset.\n-     * @param depth            the current depth.\n-     * @param view             the view to append it to.\n-     * @param researchList     the list of research to go through.\n-     * @param tree             the local tree of the colony.\n-     * @param parentResearched if possibly can be researched.\n-     * @param abandoned        if abandoned child.\n-     * @param parentHeight     the height of the parent.\n+     * @param height                 the start y offset.\n+     * @param depth                  the current depth.\n+     * @param view                   the view to append it to.\n+     * @param researchList           the list of research to go through.\n+     * @param abandoned              if abandoned child.\n      * @return the next y offset.\n      */\n     public int drawTree(\n       final int height,\n       final int depth,\n       final ZoomDragView view,\n       final List<String> researchList,\n-      final ILocalResearchTree tree,\n-      final boolean parentResearched,\n-      final boolean abandoned,\n-      final int parentHeight)\n+      final boolean abandoned)\n     {\n         int nextHeight = height;\n         for (int i = 0; i < researchList.size(); i++)\n         {\n             final String researchLabel = researchList.get(i);\n-            int offsetX = (depth * (GRADIENT_WIDTH + X_SPACING));\n \n             final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, researchLabel);\n-            final ILocalResearch localResearch = tree.getResearch(branch, research.getId());\n-            final ResearchState state = localResearch == null ? ResearchState.NOT_STARTED : localResearch.getState();\n-            final IGlobalResearch parentResearch = IGlobalResearchTree.getInstance().getResearch(branch, research.getParent());\n+            if (research.isHidden() && !IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(research.getResearchRequirement(), this.building.getColony()))\n+            {\n+                continue;\n+            }\n+\n+            final int offsetX = (depth * (GRADIENT_WIDTH + X_SPACING));\n+            final int offsetY = (nextHeight + Math.min(i, 1)) * (GRADIENT_HEIGHT + Y_SPACING) + Y_SPACING + TIMELABEL_Y_POSITION;\n \n-            boolean trueAbandoned = abandoned;\n-            if (depth != 0 && abandoned == false && state == ResearchState.NOT_STARTED && parentResearch.hasResearchedChild(tree) && parentResearch.hasOnlyChild())\n+            final boolean trueAbandoned = drawResearchItem(view, offsetX, offsetY, research, abandoned);\n+\n+            if (!research.getParent().isEmpty())\n             {\n-                trueAbandoned = true;\n+                drawArrows(view, offsetX + INITIAL_X_OFFSET - X_SPACING, offsetY, researchList, research.getParent(), i, nextHeight, height);\n             }\n \n-            final Gradient gradient = new Gradient();\n-            gradient.setSize(GRADIENT_WIDTH, GRADIENT_HEIGHT);\n-            gradient.setPosition(offsetX + INITIAL_X_OFFSET, (nextHeight + Math.min(i, 1)) * (GRADIENT_HEIGHT + Y_SPACING) + Y_SPACING);\n-            if (state == ResearchState.IN_PROGRESS)\n+            if (!research.getChildren().isEmpty())\n             {\n-                gradient.setGradientStart(227, 249, 184, 255);\n-                gradient.setGradientEnd(227, 249, 184, 255);\n-                view.addChild(gradient);\n+                nextHeight =\n+                  drawTree(nextHeight + Math.min(i, 1), depth + 1, view, research.getChildren(), trueAbandoned);\n             }\n-            else if (trueAbandoned && state != ResearchState.FINISHED)\n+            else\n             {\n-                gradient.setGradientStart(191, 184, 172, 255);\n-                gradient.setGradientEnd(191, 184, 172, 255);\n-                view.addChild(gradient);\n+                nextHeight += Math.min(i, 1);\n             }\n-            else if (!parentResearched)\n+        }\n+\n+        return nextHeight;\n+    }\n+\n+    /**\n+     * Draw the background gradients and labels for the research tree.\n+     *\n+     * @param view the view to append it to.\n+     */\n+    private void drawTreeBackground(final ZoomDragView view)\n+    {\n+        for (int i = 1; i < MAX_DEPTH; i++)\n+        {\n+            if (building.getBuildingLevel() < i)\n             {\n-                gradient.setGradientStart(239, 230, 215, 255);\n-                gradient.setGradientEnd(239, 230, 215, 255);\n+                final Gradient gradient = new Gradient();\n+                gradient.setGradientStart(80, 80, 80, 70);\n+                gradient.setGradientEnd(60, 60, 60, 70);\n+                gradient.setSize(GRADIENT_WIDTH + X_SPACING, 1200);\n+                gradient.setPosition((i - 1) * (GRADIENT_WIDTH + X_SPACING), 0);\n                 view.addChild(gradient);\n             }\n-            else if (state != ResearchState.FINISHED)\n+        }\n+\n+        if (building.getBuildingLevel() < building.getBuildingMaxLevel() || hasMax)\n+        {\n+            final Gradient gradient = new Gradient();\n+            gradient.setGradientStart(80, 80, 80, 70);\n+            gradient.setGradientEnd(60, 60, 60, 70);\n+            gradient.setSize(GRADIENT_WIDTH + X_SPACING, 1200);\n+            gradient.setPosition((6 - 1) * (GRADIENT_WIDTH + X_SPACING), 0);", "originalCommit": "85bf74e02a2059bdfec659503a04ecb4037bf91b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\nindex b72d8d6956..47f547278c 100755\n--- a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n+++ b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n\n@@ -199,11 +229,11 @@ public class WindowResearchTree extends AbstractWindowSkeleton\n     /**\n      * Draw the tree of research.\n      *\n-     * @param height                 the start y offset.\n-     * @param depth                  the current depth.\n-     * @param view                   the view to append it to.\n-     * @param researchList           the list of research to go through.\n-     * @param abandoned              if abandoned child.\n+     * @param height       the start y offset.\n+     * @param depth        the current depth.\n+     * @param view         the view to append it to.\n+     * @param researchList the list of research to go through.\n+     * @param abandoned    if abandoned child.\n      * @return the next y offset.\n      */\n     public int drawTree(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMzIxMg==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549133212", "bodyText": "can you rewrite this method to one for loop?", "author": "Nightenom", "createdAt": "2020-12-27T16:28:21Z", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java", "diffHunk": "@@ -137,299 +199,775 @@ public void onButtonClicked(@NotNull final Button button)\n     /**\n      * Draw the tree of research.\n      *\n-     * @param height           the start y offset.\n-     * @param depth            the current depth.\n-     * @param view             the view to append it to.\n-     * @param researchList     the list of research to go through.\n-     * @param tree             the local tree of the colony.\n-     * @param parentResearched if possibly can be researched.\n-     * @param abandoned        if abandoned child.\n-     * @param parentHeight     the height of the parent.\n+     * @param height                 the start y offset.\n+     * @param depth                  the current depth.\n+     * @param view                   the view to append it to.\n+     * @param researchList           the list of research to go through.\n+     * @param abandoned              if abandoned child.\n      * @return the next y offset.\n      */\n     public int drawTree(\n       final int height,\n       final int depth,\n       final ZoomDragView view,\n       final List<String> researchList,\n-      final ILocalResearchTree tree,\n-      final boolean parentResearched,\n-      final boolean abandoned,\n-      final int parentHeight)\n+      final boolean abandoned)\n     {\n         int nextHeight = height;\n         for (int i = 0; i < researchList.size(); i++)\n         {\n             final String researchLabel = researchList.get(i);\n-            int offsetX = (depth * (GRADIENT_WIDTH + X_SPACING));\n \n             final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, researchLabel);\n-            final ILocalResearch localResearch = tree.getResearch(branch, research.getId());\n-            final ResearchState state = localResearch == null ? ResearchState.NOT_STARTED : localResearch.getState();\n-            final IGlobalResearch parentResearch = IGlobalResearchTree.getInstance().getResearch(branch, research.getParent());\n+            if (research.isHidden() && !IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(research.getResearchRequirement(), this.building.getColony()))\n+            {\n+                continue;\n+            }\n+\n+            final int offsetX = (depth * (GRADIENT_WIDTH + X_SPACING));\n+            final int offsetY = (nextHeight + Math.min(i, 1)) * (GRADIENT_HEIGHT + Y_SPACING) + Y_SPACING + TIMELABEL_Y_POSITION;\n \n-            boolean trueAbandoned = abandoned;\n-            if (depth != 0 && abandoned == false && state == ResearchState.NOT_STARTED && parentResearch.hasResearchedChild(tree) && parentResearch.hasOnlyChild())\n+            final boolean trueAbandoned = drawResearchItem(view, offsetX, offsetY, research, abandoned);\n+\n+            if (!research.getParent().isEmpty())\n             {\n-                trueAbandoned = true;\n+                drawArrows(view, offsetX + INITIAL_X_OFFSET - X_SPACING, offsetY, researchList, research.getParent(), i, nextHeight, height);\n             }\n \n-            final Gradient gradient = new Gradient();\n-            gradient.setSize(GRADIENT_WIDTH, GRADIENT_HEIGHT);\n-            gradient.setPosition(offsetX + INITIAL_X_OFFSET, (nextHeight + Math.min(i, 1)) * (GRADIENT_HEIGHT + Y_SPACING) + Y_SPACING);\n-            if (state == ResearchState.IN_PROGRESS)\n+            if (!research.getChildren().isEmpty())\n             {\n-                gradient.setGradientStart(227, 249, 184, 255);\n-                gradient.setGradientEnd(227, 249, 184, 255);\n-                view.addChild(gradient);\n+                nextHeight =\n+                  drawTree(nextHeight + Math.min(i, 1), depth + 1, view, research.getChildren(), trueAbandoned);\n             }\n-            else if (trueAbandoned && state != ResearchState.FINISHED)\n+            else\n             {\n-                gradient.setGradientStart(191, 184, 172, 255);\n-                gradient.setGradientEnd(191, 184, 172, 255);\n-                view.addChild(gradient);\n+                nextHeight += Math.min(i, 1);\n             }\n-            else if (!parentResearched)\n+        }\n+\n+        return nextHeight;\n+    }\n+\n+    /**\n+     * Draw the background gradients and labels for the research tree.\n+     *\n+     * @param view the view to append it to.\n+     */\n+    private void drawTreeBackground(final ZoomDragView view)", "originalCommit": "85bf74e02a2059bdfec659503a04ecb4037bf91b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzOTQzMA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549139430", "bodyText": "Good point.  Will do.", "author": "gattsuru", "createdAt": "2020-12-27T17:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMzIxMg=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\nindex b72d8d6956..47f547278c 100755\n--- a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n+++ b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n\n@@ -199,11 +229,11 @@ public class WindowResearchTree extends AbstractWindowSkeleton\n     /**\n      * Draw the tree of research.\n      *\n-     * @param height                 the start y offset.\n-     * @param depth                  the current depth.\n-     * @param view                   the view to append it to.\n-     * @param researchList           the list of research to go through.\n-     * @param abandoned              if abandoned child.\n+     * @param height       the start y offset.\n+     * @param depth        the current depth.\n+     * @param view         the view to append it to.\n+     * @param researchList the list of research to go through.\n+     * @param abandoned    if abandoned child.\n      * @return the next y offset.\n      */\n     public int drawTree(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzNDMyNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549134325", "bodyText": "please, try to remove Math.min(i, 1) from logic of this method", "author": "Nightenom", "createdAt": "2020-12-27T16:38:19Z", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java", "diffHunk": "@@ -137,299 +199,775 @@ public void onButtonClicked(@NotNull final Button button)\n     /**\n      * Draw the tree of research.\n      *\n-     * @param height           the start y offset.\n-     * @param depth            the current depth.\n-     * @param view             the view to append it to.\n-     * @param researchList     the list of research to go through.\n-     * @param tree             the local tree of the colony.\n-     * @param parentResearched if possibly can be researched.\n-     * @param abandoned        if abandoned child.\n-     * @param parentHeight     the height of the parent.\n+     * @param height                 the start y offset.\n+     * @param depth                  the current depth.\n+     * @param view                   the view to append it to.\n+     * @param researchList           the list of research to go through.\n+     * @param abandoned              if abandoned child.\n      * @return the next y offset.\n      */\n     public int drawTree(\n       final int height,\n       final int depth,\n       final ZoomDragView view,\n       final List<String> researchList,\n-      final ILocalResearchTree tree,\n-      final boolean parentResearched,\n-      final boolean abandoned,\n-      final int parentHeight)\n+      final boolean abandoned)\n     {\n         int nextHeight = height;\n         for (int i = 0; i < researchList.size(); i++)\n         {\n             final String researchLabel = researchList.get(i);\n-            int offsetX = (depth * (GRADIENT_WIDTH + X_SPACING));\n \n             final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, researchLabel);\n-            final ILocalResearch localResearch = tree.getResearch(branch, research.getId());\n-            final ResearchState state = localResearch == null ? ResearchState.NOT_STARTED : localResearch.getState();\n-            final IGlobalResearch parentResearch = IGlobalResearchTree.getInstance().getResearch(branch, research.getParent());\n+            if (research.isHidden() && !IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(research.getResearchRequirement(), this.building.getColony()))\n+            {\n+                continue;\n+            }\n+\n+            final int offsetX = (depth * (GRADIENT_WIDTH + X_SPACING));\n+            final int offsetY = (nextHeight + Math.min(i, 1)) * (GRADIENT_HEIGHT + Y_SPACING) + Y_SPACING + TIMELABEL_Y_POSITION;", "originalCommit": "85bf74e02a2059bdfec659503a04ecb4037bf91b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzOTE3OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549139179", "bodyText": "Ok.  Was in original variant, but wasn't if something to keep.", "author": "gattsuru", "createdAt": "2020-12-27T17:25:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzNDMyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\nindex b72d8d6956..47f547278c 100755\n--- a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n+++ b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n\n@@ -199,11 +229,11 @@ public class WindowResearchTree extends AbstractWindowSkeleton\n     /**\n      * Draw the tree of research.\n      *\n-     * @param height                 the start y offset.\n-     * @param depth                  the current depth.\n-     * @param view                   the view to append it to.\n-     * @param researchList           the list of research to go through.\n-     * @param abandoned              if abandoned child.\n+     * @param height       the start y offset.\n+     * @param depth        the current depth.\n+     * @param view         the view to append it to.\n+     * @param researchList the list of research to go through.\n+     * @param abandoned    if abandoned child.\n      * @return the next y offset.\n      */\n     public int drawTree(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzNDg5OA==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549134898", "bodyText": "shouldn't this be +=1?\nI'm not sure if nextHeight is count of rows or Y offset in pixels, but this code seems a bit of both to me", "author": "Nightenom", "createdAt": "2020-12-27T16:44:25Z", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java", "diffHunk": "@@ -137,299 +199,775 @@ public void onButtonClicked(@NotNull final Button button)\n     /**\n      * Draw the tree of research.\n      *\n-     * @param height           the start y offset.\n-     * @param depth            the current depth.\n-     * @param view             the view to append it to.\n-     * @param researchList     the list of research to go through.\n-     * @param tree             the local tree of the colony.\n-     * @param parentResearched if possibly can be researched.\n-     * @param abandoned        if abandoned child.\n-     * @param parentHeight     the height of the parent.\n+     * @param height                 the start y offset.\n+     * @param depth                  the current depth.\n+     * @param view                   the view to append it to.\n+     * @param researchList           the list of research to go through.\n+     * @param abandoned              if abandoned child.\n      * @return the next y offset.\n      */\n     public int drawTree(\n       final int height,\n       final int depth,\n       final ZoomDragView view,\n       final List<String> researchList,\n-      final ILocalResearchTree tree,\n-      final boolean parentResearched,\n-      final boolean abandoned,\n-      final int parentHeight)\n+      final boolean abandoned)\n     {\n         int nextHeight = height;\n         for (int i = 0; i < researchList.size(); i++)\n         {\n             final String researchLabel = researchList.get(i);\n-            int offsetX = (depth * (GRADIENT_WIDTH + X_SPACING));\n \n             final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, researchLabel);\n-            final ILocalResearch localResearch = tree.getResearch(branch, research.getId());\n-            final ResearchState state = localResearch == null ? ResearchState.NOT_STARTED : localResearch.getState();\n-            final IGlobalResearch parentResearch = IGlobalResearchTree.getInstance().getResearch(branch, research.getParent());\n+            if (research.isHidden() && !IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(research.getResearchRequirement(), this.building.getColony()))\n+            {\n+                continue;\n+            }\n+\n+            final int offsetX = (depth * (GRADIENT_WIDTH + X_SPACING));\n+            final int offsetY = (nextHeight + Math.min(i, 1)) * (GRADIENT_HEIGHT + Y_SPACING) + Y_SPACING + TIMELABEL_Y_POSITION;\n \n-            boolean trueAbandoned = abandoned;\n-            if (depth != 0 && abandoned == false && state == ResearchState.NOT_STARTED && parentResearch.hasResearchedChild(tree) && parentResearch.hasOnlyChild())\n+            final boolean trueAbandoned = drawResearchItem(view, offsetX, offsetY, research, abandoned);\n+\n+            if (!research.getParent().isEmpty())\n             {\n-                trueAbandoned = true;\n+                drawArrows(view, offsetX + INITIAL_X_OFFSET - X_SPACING, offsetY, researchList, research.getParent(), i, nextHeight, height);\n             }\n \n-            final Gradient gradient = new Gradient();\n-            gradient.setSize(GRADIENT_WIDTH, GRADIENT_HEIGHT);\n-            gradient.setPosition(offsetX + INITIAL_X_OFFSET, (nextHeight + Math.min(i, 1)) * (GRADIENT_HEIGHT + Y_SPACING) + Y_SPACING);\n-            if (state == ResearchState.IN_PROGRESS)\n+            if (!research.getChildren().isEmpty())\n             {\n-                gradient.setGradientStart(227, 249, 184, 255);\n-                gradient.setGradientEnd(227, 249, 184, 255);\n-                view.addChild(gradient);\n+                nextHeight =\n+                  drawTree(nextHeight + Math.min(i, 1), depth + 1, view, research.getChildren(), trueAbandoned);\n             }\n-            else if (trueAbandoned && state != ResearchState.FINISHED)\n+            else\n             {\n-                gradient.setGradientStart(191, 184, 172, 255);\n-                gradient.setGradientEnd(191, 184, 172, 255);\n-                view.addChild(gradient);\n+                nextHeight += Math.min(i, 1);", "originalCommit": "85bf74e02a2059bdfec659503a04ecb4037bf91b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\nindex b72d8d6956..47f547278c 100755\n--- a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n+++ b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n\n@@ -199,11 +229,11 @@ public class WindowResearchTree extends AbstractWindowSkeleton\n     /**\n      * Draw the tree of research.\n      *\n-     * @param height                 the start y offset.\n-     * @param depth                  the current depth.\n-     * @param view                   the view to append it to.\n-     * @param researchList           the list of research to go through.\n-     * @param abandoned              if abandoned child.\n+     * @param height       the start y offset.\n+     * @param depth        the current depth.\n+     * @param view         the view to append it to.\n+     * @param researchList the list of research to go through.\n+     * @param abandoned    if abandoned child.\n      * @return the next y offset.\n      */\n     public int drawTree(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzNTM3Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/6181#discussion_r549135376", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (research.getDepth() == 6 && hasMax)\n          \n          \n            \n                        if (research.getDepth() == MAX_DEPTH && hasMax)", "author": "Nightenom", "createdAt": "2020-12-27T16:48:38Z", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java", "diffHunk": "@@ -137,299 +199,775 @@ public void onButtonClicked(@NotNull final Button button)\n     /**\n      * Draw the tree of research.\n      *\n-     * @param height           the start y offset.\n-     * @param depth            the current depth.\n-     * @param view             the view to append it to.\n-     * @param researchList     the list of research to go through.\n-     * @param tree             the local tree of the colony.\n-     * @param parentResearched if possibly can be researched.\n-     * @param abandoned        if abandoned child.\n-     * @param parentHeight     the height of the parent.\n+     * @param height                 the start y offset.\n+     * @param depth                  the current depth.\n+     * @param view                   the view to append it to.\n+     * @param researchList           the list of research to go through.\n+     * @param abandoned              if abandoned child.\n      * @return the next y offset.\n      */\n     public int drawTree(\n       final int height,\n       final int depth,\n       final ZoomDragView view,\n       final List<String> researchList,\n-      final ILocalResearchTree tree,\n-      final boolean parentResearched,\n-      final boolean abandoned,\n-      final int parentHeight)\n+      final boolean abandoned)\n     {\n         int nextHeight = height;\n         for (int i = 0; i < researchList.size(); i++)\n         {\n             final String researchLabel = researchList.get(i);\n-            int offsetX = (depth * (GRADIENT_WIDTH + X_SPACING));\n \n             final IGlobalResearch research = IGlobalResearchTree.getInstance().getResearch(branch, researchLabel);\n-            final ILocalResearch localResearch = tree.getResearch(branch, research.getId());\n-            final ResearchState state = localResearch == null ? ResearchState.NOT_STARTED : localResearch.getState();\n-            final IGlobalResearch parentResearch = IGlobalResearchTree.getInstance().getResearch(branch, research.getParent());\n+            if (research.isHidden() && !IGlobalResearchTree.getInstance().isResearchRequirementsFulfilled(research.getResearchRequirement(), this.building.getColony()))\n+            {\n+                continue;\n+            }\n+\n+            final int offsetX = (depth * (GRADIENT_WIDTH + X_SPACING));\n+            final int offsetY = (nextHeight + Math.min(i, 1)) * (GRADIENT_HEIGHT + Y_SPACING) + Y_SPACING + TIMELABEL_Y_POSITION;\n \n-            boolean trueAbandoned = abandoned;\n-            if (depth != 0 && abandoned == false && state == ResearchState.NOT_STARTED && parentResearch.hasResearchedChild(tree) && parentResearch.hasOnlyChild())\n+            final boolean trueAbandoned = drawResearchItem(view, offsetX, offsetY, research, abandoned);\n+\n+            if (!research.getParent().isEmpty())\n             {\n-                trueAbandoned = true;\n+                drawArrows(view, offsetX + INITIAL_X_OFFSET - X_SPACING, offsetY, researchList, research.getParent(), i, nextHeight, height);\n             }\n \n-            final Gradient gradient = new Gradient();\n-            gradient.setSize(GRADIENT_WIDTH, GRADIENT_HEIGHT);\n-            gradient.setPosition(offsetX + INITIAL_X_OFFSET, (nextHeight + Math.min(i, 1)) * (GRADIENT_HEIGHT + Y_SPACING) + Y_SPACING);\n-            if (state == ResearchState.IN_PROGRESS)\n+            if (!research.getChildren().isEmpty())\n             {\n-                gradient.setGradientStart(227, 249, 184, 255);\n-                gradient.setGradientEnd(227, 249, 184, 255);\n-                view.addChild(gradient);\n+                nextHeight =\n+                  drawTree(nextHeight + Math.min(i, 1), depth + 1, view, research.getChildren(), trueAbandoned);\n             }\n-            else if (trueAbandoned && state != ResearchState.FINISHED)\n+            else\n             {\n-                gradient.setGradientStart(191, 184, 172, 255);\n-                gradient.setGradientEnd(191, 184, 172, 255);\n-                view.addChild(gradient);\n+                nextHeight += Math.min(i, 1);\n             }\n-            else if (!parentResearched)\n+        }\n+\n+        return nextHeight;\n+    }\n+\n+    /**\n+     * Draw the background gradients and labels for the research tree.\n+     *\n+     * @param view the view to append it to.\n+     */\n+    private void drawTreeBackground(final ZoomDragView view)\n+    {\n+        for (int i = 1; i < MAX_DEPTH; i++)\n+        {\n+            if (building.getBuildingLevel() < i)\n             {\n-                gradient.setGradientStart(239, 230, 215, 255);\n-                gradient.setGradientEnd(239, 230, 215, 255);\n+                final Gradient gradient = new Gradient();\n+                gradient.setGradientStart(80, 80, 80, 70);\n+                gradient.setGradientEnd(60, 60, 60, 70);\n+                gradient.setSize(GRADIENT_WIDTH + X_SPACING, 1200);\n+                gradient.setPosition((i - 1) * (GRADIENT_WIDTH + X_SPACING), 0);\n                 view.addChild(gradient);\n             }\n-            else if (state != ResearchState.FINISHED)\n+        }\n+\n+        if (building.getBuildingLevel() < building.getBuildingMaxLevel() || hasMax)\n+        {\n+            final Gradient gradient = new Gradient();\n+            gradient.setGradientStart(80, 80, 80, 70);\n+            gradient.setGradientEnd(60, 60, 60, 70);\n+            gradient.setSize(GRADIENT_WIDTH + X_SPACING, 1200);\n+            gradient.setPosition((6 - 1) * (GRADIENT_WIDTH + X_SPACING), 0);\n+            view.addChild(gradient);\n+        }\n+        for (int i = 1; i <= MAX_DEPTH; i++)\n+        {\n+            final Label timeLabel = new Label();\n+            timeLabel.setSize(TIME_WIDTH, TIME_HEIGHT);\n+            timeLabel.setLabelText(new TranslationTextComponent(\"com.minecolonies.coremod.gui.research.tier.header\",\n+              (i > building.getBuildingMaxLevel()) ? i : building.getBuildingMaxLevel(),\n+              (IGlobalResearchTree.getInstance().getBranchTime(branch) * Math.pow(2, i - 1))));\n+            timeLabel.setPosition((i - 1) * (GRADIENT_WIDTH + X_SPACING) + GRADIENT_WIDTH / 2 - TIME_WIDTH / 4, TIMELABEL_Y_POSITION);\n+            if (building.getBuildingLevel() < i && building.getBuildingLevel() != MAX_DEPTH - 1)\n+            {\n+                timeLabel.setColor(COLOR_TEXT_NEGATIVE, COLOR_TEXT_NEGATIVE);\n+            }\n+            else\n             {\n-                gradient.setGradientStart(102, 204, 255, 255);\n-                gradient.setGradientEnd(102, 204, 255, 255);\n-                view.addChild(gradient);\n+                timeLabel.setColor(COLOR_TEXT_LABEL, COLOR_TEXT_LABEL);\n             }\n+            view.addChild(timeLabel);\n+        }\n+    }\n+\n+    /**\n+     * Draw the entirety of an individual research item on a tree, including icons and tooltips.\n+     *\n+     * @param view                  the view to append it to.\n+     * @param offsetX               the horizontal offset of the left side of the research block.\n+     * @param offsetY               the vertical offset of the top side of the research block.\n+     * @param research              the global research characteristics to draw.\n+     * @param abandoned             the abandoned status of the parent of the research, if one is present.\n+     * @return abandoned status, true if the research is blocked in the local colony the completion of a sibling research, or an ancestor's sibling's research.\n+     */\n+    private boolean drawResearchItem(final ZoomDragView view, final int offsetX, final int offsetY, final IGlobalResearch research, boolean abandoned)\n+    {\n+        final ILocalResearchTree tree = building.getColony().getResearchManager().getResearchTree();\n+        final boolean parentResearched = tree.hasCompletedResearch(research.getParent());\n+        final IGlobalResearch parentResearch = IGlobalResearchTree.getInstance().getResearch(branch, research.getParent());\n+        final ResearchState state = tree.getResearch(branch, research.getId()) == null ? ResearchState.NOT_STARTED : tree.getResearch(branch, research.getId()).getState();\n \n-            final Box box = new Box();\n-            box.setColor(218, 202, 171);\n-            box.setSize(GRADIENT_WIDTH, GRADIENT_HEIGHT);\n-            box.setPosition(gradient.getX(), gradient.getY());\n-            view.addChild(box);\n+        if (research.getDepth() != 1 && state != ResearchState.FINISHED\n+              && parentResearch.hasResearchedChild(tree) && parentResearch.hasOnlyChild())\n+        {\n+            abandoned = true;\n+        }\n \n-            final Label nameLabel = new Label();\n-            nameLabel.setLabelText(research.getDesc());\n-            nameLabel.setPosition(offsetX + INITIAL_X_OFFSET + NAME_OFFSET, (nextHeight + Math.min(i, 1)) * (GRADIENT_HEIGHT + Y_SPACING) + Y_SPACING + INITIAL_Y_OFFSET);\n-            nameLabel.setColor(Color.rgbaToInt(160, 160, 160, 255));\n-            view.addChild(nameLabel);\n+        drawResearchBox(view, offsetX, offsetY, state, parentResearched, abandoned);\n+        if (state == ResearchState.IN_PROGRESS)\n+        {\n+            drawResearchProgress(view, offsetX, offsetY, research, tree.getResearch(branch, research.getId()).getDepth());\n+        }\n \n-            if (state == ResearchState.IN_PROGRESS)\n-            {\n-                //The player will reach the end of the research if he is in creative mode and the research was in progress\n-                if (mc.player.isCreative() && localResearch.getProgress() < BASE_RESEARCH_TIME * Math.pow(2, depth - 1))\n-                {\n-                    Network.getNetwork().sendToServer(new TryResearchMessage(building, research.getId(), research.getBranch()));\n-                }\n-                //Calculates how much percent of the next level has been completed.\n-                final double progressRatio = (localResearch.getProgress() + 1) / (Math.pow(2, localResearch.getDepth() - 1) * (double) BASE_RESEARCH_TIME) * 100;\n+        drawResearchLabels(view, offsetX, offsetY, research, parentResearched);\n+        drawResearchButton(view, offsetX, offsetY, research, state, parentResearched, abandoned);\n+        drawResearchIcons(view, offsetX, offsetY, research, state != ResearchState.NOT_STARTED, abandoned);\n \n-                @NotNull final Image xpBar = new Image();\n-                xpBar.setImage(Screen.GUI_ICONS_LOCATION, XP_BAR_ICON_COLUMN, XP_BAR_EMPTY_ROW, XP_BAR_WIDTH, XP_HEIGHT, false);\n-                xpBar.setPosition(offsetX + X_SPACING + TEXT_X_OFFSET, nameLabel.getY() + nameLabel.getHeight() + XPBAR_Y_OFFSET);\n+        return abandoned;\n+    }\n \n-                @NotNull final Image xpBar2 = new Image();\n-                xpBar2.setImage(Screen.GUI_ICONS_LOCATION, XP_BAR_ICON_COLUMN_END, XP_BAR_EMPTY_ROW, XP_BAR_ICON_COLUMN_END_WIDTH, XP_HEIGHT, false);\n-                xpBar2.setPosition(XPBAR_LENGTH + offsetX + X_SPACING + TEXT_X_OFFSET, nameLabel.getY() + nameLabel.getHeight() + XPBAR_Y_OFFSET);\n+    /**\n+     * Draw the container block of an individual research item on a tree.\n+     *\n+     * @param view             the view to append it to.\n+     * @param offsetX          the horizontal offset of the left side of the research block.\n+     * @param offsetY          the vertical offset of the top side of the research block.\n+     * @param state            the status of the selected research.\n+     * @param parentResearched if the parent\n+     * @param abandoned        the abandoned status of the research.\n+     */\n+    private void drawResearchBox(final ZoomDragView view, final int offsetX, final int offsetY, final ResearchState state, final boolean parentResearched, final boolean abandoned)\n+    {\n+        final Gradient gradient = new Gradient();\n+        gradient.setSize(GRADIENT_WIDTH, GRADIENT_HEIGHT);\n+        gradient.setPosition(offsetX + INITIAL_X_OFFSET, offsetY);\n+        if (state == ResearchState.IN_PROGRESS)\n+        {\n+            gradient.setGradientStart(227, 249, 184, 255);\n+            gradient.setGradientEnd(227, 249, 184, 255);\n+            view.addChild(gradient);\n+        }\n+        else if (abandoned && state != ResearchState.FINISHED)\n+        {\n+            gradient.setGradientStart(191, 184, 172, 255);\n+            gradient.setGradientEnd(191, 184, 172, 255);\n+            view.addChild(gradient);\n+        }\n+        else if (!parentResearched)\n+        {\n+            gradient.setGradientStart(80, 80, 80, 100);\n+            gradient.setGradientEnd(70, 70, 70, 100);\n+            view.addChild(gradient);\n+        }\n+        else if (state != ResearchState.FINISHED)\n+        {\n+            gradient.setGradientStart(102, 204, 255, 255);\n+            gradient.setGradientEnd(102, 204, 255, 255);\n+            view.addChild(gradient);\n+        }\n+        else if (state == ResearchState.FINISHED)\n+        {\n+            gradient.setGradientStart(102, 225, 80, 30);\n+            gradient.setGradientEnd(102, 225, 80, 30);\n+            view.addChild(gradient);\n+        }\n \n-                view.addChild(xpBar);\n-                view.addChild(xpBar2);\n+        final Box box = new Box();\n+        box.setColor(218, 202, 171);\n+        box.setSize(GRADIENT_WIDTH, GRADIENT_HEIGHT);\n+        box.setPosition(offsetX + INITIAL_X_OFFSET, offsetY);\n+        view.addChild(box);\n+    }\n \n-                if (progressRatio > 0)\n+    /**\n+     * Generates and attaches tooltips for a given research to input tipItem.\n+     *\n+     * @param tipItem  the Pane to apply the tooltip.\n+     * @param research the global research characteristics to draw.\n+     * @param state    the status of the selected research.\n+     */\n+    private void generateResearchTooltips(final Pane tipItem, final IGlobalResearch research, final ResearchState state)\n+    {\n+        final List<IFormattableTextComponent> hoverTexts = new ArrayList<>();\n+        hoverTexts.add(new TranslationTextComponent(research.getDesc()).setStyle(Style.EMPTY.setBold(true).setFormatting(TextFormatting.GOLD)));\n+        if(!research.getSubtitle().isEmpty())\n+        {\n+            hoverTexts.add(new TranslationTextComponent(research.getSubtitle()).setStyle(Style.EMPTY.setItalic(true).setFormatting(TextFormatting.GRAY)));\n+        }\n+        for (int txt = 0; txt < research.getEffects().size(); txt++)\n+        {\n+            hoverTexts.add(research.getEffects().get(txt).getDesc());\n+            if(!research.getEffects().get(txt).getSubtitle().isEmpty())\n+            {\n+                hoverTexts.add(new StringTextComponent(\"-\").append(new TranslationTextComponent(research.getEffects().get(txt).getSubtitle())));\n+            }\n+        }\n+        if (state != ResearchState.FINISHED)\n+        {\n+            for (int txt = 0; txt < research.getResearchRequirement().size(); txt++)\n+            {\n+                if(research.getResearchRequirement().get(txt).isFulfilled(this.building.getColony()))\n                 {\n-                    @NotNull final Image xpBarFull = new Image();\n-                    xpBarFull.setImage(Screen.GUI_ICONS_LOCATION, XP_BAR_ICON_COLUMN, XP_BAR_FULL_ROW, (int) progressRatio, XP_HEIGHT, false);\n-                    xpBarFull.setPosition(offsetX + X_SPACING + TEXT_X_OFFSET, nameLabel.getY() + nameLabel.getHeight() + XPBAR_Y_OFFSET);\n-                    view.addChild(xpBarFull);\n+                    hoverTexts.add(new TranslationTextComponent(\" - \").append(research.getResearchRequirement().get(txt).getDesc().setStyle(Style.EMPTY.setFormatting(TextFormatting.AQUA))));\n+                }\n+                else\n+                {\n+                    hoverTexts.add(new TranslationTextComponent(\" - \").append(research.getResearchRequirement().get(txt).getDesc().setStyle(Style.EMPTY.setFormatting(TextFormatting.RED))));\n                 }\n             }\n-            else if (research.getResearchRequirement() != null && state != ResearchState.FINISHED)\n+            if (research.getDepth() > building.getBuildingLevel() && building.getBuildingLevel() != building.getBuildingMaxLevel())\n             {\n-                final Label requirementLabel = new Label();\n-                requirementLabel.setLabelText(research.getResearchRequirement().getDesc().getString());\n-                requirementLabel.setPosition(offsetX + INITIAL_X_OFFSET + TEXT_X_OFFSET, nameLabel.getY() + nameLabel.getHeight() + INITIAL_Y_OFFSET);\n-                requirementLabel.setColor(Color.rgbaToInt(160, 160, 160, 255));\n-\n-                view.addChild(requirementLabel);\n+                hoverTexts.add(new TranslationTextComponent(\"com.minecolonies.coremod.research.requirement.university.level\", research.getDepth()));\n             }\n+            if (research.getDepth() == MAX_DEPTH)\n+            {\n+                if(hasMax)\n+                {\n+                    hoverTexts.add(new TranslationTextComponent(\"com.minecolonies.coremod.research.limit.onemaxperbranch\").setStyle(Style.EMPTY.setFormatting(TextFormatting.GOLD)));\n+                }\n+                else\n+                {\n+                    hoverTexts.add(new TranslationTextComponent(\"com.minecolonies.coremod.research.limit.onemaxperbranch\").setStyle(Style.EMPTY.setFormatting(TextFormatting.RED)));\n+                }\n+            }\n+        }\n+        if (research.isImmutable())\n+        {\n+            hoverTexts.add(new TranslationTextComponent(\"com.minecolonies.coremod.research.limit.immutable\").setStyle(Style.EMPTY.setFormatting(TextFormatting.RED)));\n+        }\n+        tipItem.setHoverToolTip(hoverTexts);\n+    }\n \n-            final Label effectLabel = new Label();\n-            effectLabel.setLabelText(research.getEffect().getDesc().getString());\n-            effectLabel.setPosition(offsetX + INITIAL_X_OFFSET + TEXT_X_OFFSET, nameLabel.getY() + nameLabel.getHeight() * 2 + INITIAL_Y_OFFSET + INITIAL_Y_OFFSET);\n-            effectLabel.setColor(Color.rgbaToInt(160, 160, 160, 255));\n+    /**\n+     * Draw the progress bar for a given research.\n+     *\n+     * @param view     the view to append it to.\n+     * @param offsetX  the horizontal offset of the left side of the research block.\n+     * @param offsetY  the vertical offset of the top side of the research block.\n+     * @param research the global research characteristics to draw.\n+     * @param progress the current research progress.\n+     */\n+    private void drawResearchProgress(final ZoomDragView view, final int offsetX, final int offsetY, final IGlobalResearch research, final int progress)\n+    {\n+        //The player will reach the end of the research if he is in creative mode, auto-completion is enabled, and the research was in progress\n+        if (mc.player.isCreative() && MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchCreativeCompletion.get()\n+              && progress < BASE_RESEARCH_TIME * IGlobalResearchTree.getInstance().getBranchTime(branch) * Math.pow(2, research.getDepth() - 1))\n+        {\n+            Network.getNetwork().sendToServer(new TryResearchMessage(building, research.getId(), research.getBranch(), false));\n+        }\n+\n+        //Calculates how much percent of the next level has been completed.\n+        final double progressRatio = (progress + 1) / (Math.pow(2, research.getDepth() - 1) * (double) BASE_RESEARCH_TIME * IGlobalResearchTree.getInstance().getBranchTime(branch)) * 100;\n+\n+        @NotNull final Image xpBar = new Image();\n+        xpBar.setImage(Screen.GUI_ICONS_LOCATION, XP_BAR_ICON_COLUMN, XP_BAR_EMPTY_ROW, XP_BAR_WIDTH, XP_HEIGHT, false);\n+        xpBar.setPosition(offsetX + X_SPACING - TEXT_X_OFFSET, offsetY + INITIAL_Y_OFFSET + +XPBAR_Y_OFFSET);\n+\n+        @NotNull final Image xpBar2 = new Image();\n+        xpBar2.setImage(Screen.GUI_ICONS_LOCATION, XP_BAR_ICON_COLUMN_END, XP_BAR_EMPTY_ROW, XP_BAR_ICON_COLUMN_END_WIDTH, XP_HEIGHT, false);\n+        xpBar2.setPosition(XPBAR_LENGTH + offsetX + X_SPACING - TEXT_X_OFFSET, offsetY + INITIAL_Y_OFFSET + XPBAR_Y_OFFSET);\n+\n+        view.addChild(xpBar);\n+        view.addChild(xpBar2);\n \n+        if (progressRatio > 0)\n+        {\n+            @NotNull final Image xpBarFull = new Image();\n+            xpBarFull.setImage(Screen.GUI_ICONS_LOCATION, XP_BAR_ICON_COLUMN, XP_BAR_FULL_ROW, (int) progressRatio, XP_HEIGHT, false);\n+            xpBarFull.setPosition(offsetX + X_SPACING - TEXT_X_OFFSET, offsetY + INITIAL_Y_OFFSET + XPBAR_Y_OFFSET);\n+            view.addChild(xpBarFull);\n+        }\n+    }\n+\n+    /**\n+     * Draw the labels for a given research\n+     *\n+     * @param view             the view to append it to.\n+     * @param offsetX          the horizontal offset of the left side of the research block.\n+     * @param offsetY          the vertical offset of the top side of the research block.\n+     * @param research         the global research characteristics to draw.\n+     * @param parentResearched if the parent research has been completed.\n+     */\n+    private void drawResearchLabels(final ZoomDragView view, final int offsetX, final int offsetY, final IGlobalResearch research, final boolean parentResearched)\n+    {\n+        final Label nameLabel = new Label();\n+        nameLabel.setSize(BUTTON_LENGTH, INITIAL_Y_OFFSET);\n+        nameLabel.setLabelText(new TranslationTextComponent(research.getDesc()));\n+        nameLabel.setPosition(offsetX + INITIAL_X_OFFSET + NAME_OFFSET, offsetY + (NAME_OFFSET / 2));\n+        if (parentResearched)\n+        {\n+            nameLabel.setColor(COLOR_TEXT_LABEL, COLOR_TEXT_LABEL);\n+        }\n+        else\n+        {\n+            nameLabel.setColor(COLOR_TEXT_LIGHT, COLOR_TEXT_LIGHT);\n+        }\n+        view.addChild(nameLabel);\n+\n+        if (MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchDebugLog.get() && !research.getEffects().isEmpty())\n+        {\n+            final TranslationTextComponent effectText = new TranslationTextComponent(\"\");\n+            for (int txt = 0; txt < research.getEffects().size(); txt++)\n+            {\n+                effectText.append(research.getEffects().get(txt).getDesc());\n+            }\n+            final Label effectLabel = new Label();\n+            effectLabel.setSize(BUTTON_LENGTH, INITIAL_Y_OFFSET);\n+            effectLabel.setPosition(offsetX + INITIAL_X_OFFSET + 2 * TEXT_X_OFFSET, offsetY + INITIAL_Y_OFFSET + nameLabel.getHeight() * 2 + INITIAL_Y_OFFSET + INITIAL_Y_OFFSET);\n+            effectLabel.setColor(COLOR_TEXT_LABEL, COLOR_TEXT_LABEL);\n+            effectLabel.setLabelText(effectText);\n             view.addChild(effectLabel);\n+        }\n+        if (MinecoloniesAPIProxy.getInstance().getConfig().getServer().researchDebugLog.get()\n+              && !research.getResearchRequirement().isEmpty())\n+        {\n+            final TranslationTextComponent requirementText = new TranslationTextComponent(\"\");\n+            for (int txt = 0; txt < research.getResearchRequirement().size(); txt++)\n+            {\n+                requirementText.append(research.getResearchRequirement().get(txt).getDesc());\n+            }\n+            final Label requirementLabel = new Label();\n+            requirementLabel.setSize(BUTTON_LENGTH, INITIAL_Y_OFFSET);\n+            requirementLabel.setPosition(offsetX + INITIAL_X_OFFSET + TEXT_X_OFFSET, offsetY + INITIAL_Y_OFFSET + INITIAL_Y_OFFSET);\n+            requirementLabel.setColor(COLOR_TEXT_LABEL);\n+            requirementLabel.setLabelText(requirementText);\n+            view.addChild(requirementLabel);\n+        }\n+    }\n+\n+    /**\n+     * Draw the buttons and button images for a given research.\n+     *\n+     * @param view              the view to append it to.\n+     * @param offsetX           the horizontal offset of the left side of the research block.\n+     * @param offsetY           the vertical offset of the top side of the research block.\n+     * @param research          the global research characteristics to draw.\n+     * @param state             the research state.\n+     * @param parentResearched  if the parent research has been completed.\n+     * @param abandoned         if the research or an ancestor research has a completed sibling preventing it from being studied.\n+     */\n+    private void drawResearchButton(final ZoomDragView view, final int offsetX, final int offsetY, final IGlobalResearch research,\n+                                    final ResearchState state, final boolean parentResearched, final boolean abandoned)\n+    {\n+        final Button button = new Button();\n+        button.setSize(GRADIENT_WIDTH, GRADIENT_HEIGHT);\n+        button.setPosition(offsetX + INITIAL_X_OFFSET, offsetY);\n+        if(!abandoned && parentResearched && (!hasMax || research.getDepth() != MAX_DEPTH || state != ResearchState.NOT_STARTED))\n+        {\n+            button.setID(research.getId());\n+        }\n+        view.addChild(button);\n+        generateResearchTooltips(button, research, state);\n+\n+        if ((mc.player.isCreative() && state != ResearchState.NOT_STARTED) || abandoned || !parentResearched)\n+        {\n+            return;\n+        }\n+\n+        final ButtonImage buttonImage = new ButtonImage();\n+        buttonImage.setImage(new ResourceLocation(Constants.MOD_ID, MEDIUM_SIZED_BUTTON_RES));\n+        buttonImage.setLabel(new TranslationTextComponent(\"com.minecolonies.coremod.research.research\"));\n+        buttonImage.setTextColor(Color.getByName(\"black\", 0));\n+        buttonImage.setSize(BUTTON_LENGTH, BUTTON_HEIGHT);\n+        buttonImage.setPosition(offsetX + INITIAL_X_OFFSET + TEXT_X_OFFSET,\n+          offsetY + GRADIENT_HEIGHT - INITIAL_Y_OFFSET);\n \n-            if (parentResearched && state == ResearchState.NOT_STARTED && !trueAbandoned)\n+        if (mc.player.isCreative())\n+        {\n+            if (research.getDepth() == 6 && hasMax)", "originalCommit": "85bf74e02a2059bdfec659503a04ecb4037bf91b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5716825a67c118a5795c87b1fef0d61959f1df60", "chunk": "diff --git a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\nindex b72d8d6956..47f547278c 100755\n--- a/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n+++ b/src/main/java/com/minecolonies/coremod/client/gui/WindowResearchTree.java\n\n@@ -199,11 +229,11 @@ public class WindowResearchTree extends AbstractWindowSkeleton\n     /**\n      * Draw the tree of research.\n      *\n-     * @param height                 the start y offset.\n-     * @param depth                  the current depth.\n-     * @param view                   the view to append it to.\n-     * @param researchList           the list of research to go through.\n-     * @param abandoned              if abandoned child.\n+     * @param height       the start y offset.\n+     * @param depth        the current depth.\n+     * @param view         the view to append it to.\n+     * @param researchList the list of research to go through.\n+     * @param abandoned    if abandoned child.\n      * @return the next y offset.\n      */\n     public int drawTree(\n"}}, {"oid": "6c287cdafae521babfd2416ee14d0adf68712c69", "url": "https://github.com/ldtteam/minecolonies/commit/6c287cdafae521babfd2416ee14d0adf68712c69", "message": "Commit of basic functionality for json-based research data packs, and related changes, as described in #6178.", "committedDate": "2021-01-28T16:29:08Z", "type": "commit"}, {"oid": "c101f90ef4f48853a05412b2c262d483a4f451b9", "url": "https://github.com/ldtteam/minecolonies/commit/c101f90ef4f48853a05412b2c262d483a4f451b9", "message": "Move ResearchEffectRegistry to handle multiple effects of the same type, cleanup of error during UnlockBuildingEffect construction.", "committedDate": "2021-01-28T16:29:08Z", "type": "commit"}, {"oid": "ee21e422148c8658d8fd02e432a0436f5ee39dac", "url": "https://github.com/ldtteam/minecolonies/commit/ee21e422148c8658d8fd02e432a0436f5ee39dac", "message": "Further updates for #6178.  Includes much stronger input sanitization for researches and research effects from jsons, switches the ResearchEffectRegistry to contain all versions of an effect, and handles updates of researches with unconventionally spelled ids or generically removed (or disabled) research from past file saves.\n\nAlso includes some configuration options to make for easier debugging.", "committedDate": "2021-01-28T16:32:11Z", "type": "commit"}, {"oid": "67adea9c9120d998e9c8bcab2cebec89b8f9b0d5", "url": "https://github.com/ldtteam/minecolonies/commit/67adea9c9120d998e9c8bcab2cebec89b8f9b0d5", "message": "Fixes a missed import, and also some translation key versus block name issues.", "committedDate": "2021-01-28T16:35:37Z", "type": "commit"}, {"oid": "c9ee3da157cd056de9784c3d0c2d3608c2c882c9", "url": "https://github.com/ldtteam/minecolonies/commit/c9ee3da157cd056de9784c3d0c2d3608c2c882c9", "message": "Transition from static assignment of Research to a datapack-based system, adds logging.\n\nAnd, finally, deletes the now-empty ResearchInitializer.java.", "committedDate": "2021-01-28T16:35:37Z", "type": "commit"}, {"oid": "8acb3f0ba2fc3aa04ccc1d92a0c5b99f1d89274f", "url": "https://github.com/ldtteam/minecolonies/commit/8acb3f0ba2fc3aa04ccc1d92a0c5b99f1d89274f", "message": "Apply suggestions from code review\r\n\r\nCorrected spellings and grammar formatting related to research.\n\nCo-authored-by: Alex Graham <30493222+ShadowProtocol@users.noreply.github.com>\nCo-authored-by: ravenbuilder934 <sabrinajamie@outlook.com>", "committedDate": "2021-01-28T16:35:37Z", "type": "commit"}, {"oid": "d04112aa1599950a412e14a98a562f475e315cbd", "url": "https://github.com/ldtteam/minecolonies/commit/d04112aa1599950a412e14a98a562f475e315cbd", "message": "Better transition to json-based research datapacks.  Implements recommendations from pull requests to json format.  Moves to translation-focused names and descriptions.  Separates effect data from research files.  Adds additional error-checking and sanitization.  Implements a few helper functions to swap between id-derived translationcontexts and user datapack-implemented \"name\" tags for users who can't or don't want to use the translation files.\n\nAdded additional support for handling NBT differences after a research is removed or its name changed.\n\nTried to get all the places that need translationtextcomponent wrappers were necessary for the updates.  Emphasis on tried.  Both in the \"missing some\" sense and the \"butchering it\".\n\nRemoved ResearchEffectRegistry and its interfaces.  Necessary components moved to either ResearchEffectCategory or to GlobalResearchTree.  Cleaned up and separated parsing functionality for improved debugging, added a config setting so it's not spamming people randomly.\n\nImplements relative upgrade values for effects, and uses them for most research UI displays.  These relative values are derived only during world load and only in comparison to lower levels.\n\nExpanded logging for Research and ResearchEffect parsing, and added a config option to prevent the logs from spamming people who aren't using the system.\n\nReduces BlockHut<building>'s individual implementation-dependent checkResearch traits to use a single method in AbstractBlockHut, as a first step to allow arbitrary locking or unlocking of buildings.  Some related cleanup of static variables.\n\nBegins parsing, but not implementation, of \"hidden\" and \"instant\" research.  Begins internal support for level-based unlocks, though still exposed to upgrade implementation as booleans.\n\nAdds some ResourceLocation-based indexing for Researches. Use IGlobalResearchTree.getResearchResourceLocation to access.  No accessors for ResourceLocation->research yet, but it is mapped internally to GlobalResearchTree and readily accessed from inside that.", "committedDate": "2021-01-28T16:41:09Z", "type": "commit"}, {"oid": "238464ca6aeaa9cdeac8c7ed6322323f9fc46620", "url": "https://github.com/ldtteam/minecolonies/commit/238464ca6aeaa9cdeac8c7ed6322323f9fc46620", "message": "Updates Building<Type> to use the same AbstractBuilding focus as BlockHut<Type> use the same AbstractBlockHut.\n\nChanges the Boolean effect checker in IResearchEffectManager to hasUnlockAbilityEffect and hasUnlockBuildingEffect for better clarity and to handle edge cases where someone tries to lock a recipe behind an id that matches a hutblock name.\n\nCleans up a wrong jdoc, improves translation text varargs for blockhut unlockable tooltips.", "committedDate": "2021-01-28T16:47:10Z", "type": "commit"}, {"oid": "49cb7c66ca0da94380186b34c8dc01c61223e492", "url": "https://github.com/ldtteam/minecolonies/commit/49cb7c66ca0da94380186b34c8dc01c61223e492", "message": "Less buggy fix to the CustomRecipe issue, and some improvements to efficiency on searches for research during that phase.  Also cleans up some no-longer-needed files.", "committedDate": "2021-01-28T16:53:20Z", "type": "commit"}, {"oid": "ebba426ffb747525fee497ff5173a028e22615f9", "url": "https://github.com/ldtteam/minecolonies/commit/ebba426ffb747525fee497ff5173a028e22615f9", "message": "Yet Another Typo Fix", "committedDate": "2021-01-28T16:53:20Z", "type": "commit"}, {"oid": "2a7fb8c0f4ad44662496964855c83f26a7f3f2b6", "url": "https://github.com/ldtteam/minecolonies/commit/2a7fb8c0f4ad44662496964855c83f26a7f3f2b6", "message": "Adds a sorting functionality to branches (by name) and primary research (by resource location), which should give better control over the appearance of the WindowResearchTree graph.  Current settings match pre-transition layout.\n\nImproves and debugs some of the .reset() behavior.", "committedDate": "2021-01-28T16:53:20Z", "type": "commit"}, {"oid": "cfea3a7e41346bb69951b274efa1f13c796daa28", "url": "https://github.com/ldtteam/minecolonies/commit/cfea3a7e41346bb69951b274efa1f13c796daa28", "message": "Implements the research \"instant\" and \"hidden\" tags, finishes implementation of non-parent Research ResearchRequirements.  \"hidden\" will make the research (and any child researches) invisible until all building or research requirements are complete.  \"instant\" will set progress to maximum when run from the University.\n\nMoves MoreScrolls back to slot 2/6 for its branch on WindowResearchTree, as otherwise it's too easy to miss right now.\n\nSome fixes from survival testing, translation and multiplayer.", "committedDate": "2021-01-28T17:02:19Z", "type": "commit"}, {"oid": "3b7453dcfc57eeea1391abf3125236b4280000e4", "url": "https://github.com/ldtteam/minecolonies/commit/3b7453dcfc57eeea1391abf3125236b4280000e4", "message": "Implements \"autostart\" tag, as well as some behaviors to help manage announcements for beginning \"autostart\" and uncovering of \"hidden\" research.  Improves sorting for WindowHutUniversity, and implements ability to hide (or at least lock) a full research branch by hiding all members, as well as tooltips to highlight how to unlock that branch.\n\nMoves isResearchRequirementsFulfilled to GlobalResearchTree, as it's likely to be used in more places down the road.\n\nAdds onTick override to Town Hall, currently only used to validate autostart research status.", "committedDate": "2021-01-28T17:04:32Z", "type": "commit"}, {"oid": "e6185fd36439c4806beefa8c54c4f072959d4bb5", "url": "https://github.com/ldtteam/minecolonies/commit/e6185fd36439c4806beefa8c54c4f072959d4bb5", "message": "Removes the various <Type>ResearchEffects in favor of a single GlobalResearchEffect based around floats.  Switches implementations to use getEffectValue (returns float value) and getEffectBoolean (> 0).\n\nAdds an onColonyTick to ResearchManager, registered to worldTickSlow.  Used to handle autostart research, and to better trigger completed research when no university workers are available.  Removes the previous version from BuildingTownHall.\n\nConverts multiple Booleans to booleans.\n\nChanges Research Effect Translation Text Component formatting: $1 is displayEffect, $2 is absoluteEffect, $3 is displayEffect in percent, $4 is absoluteEffect as a percent.  Implements Name as a tag for effects jsons.\n\nRemoves effectType as a tag for Research Effects.\n\nChanges EntityAIWorkTeacher to benefit from PrimarySkill before completion of MoreBooks research.  Changes Research Effect overrides to calculate based on absolute values (so -0.05 won't prevent -0.1 from applying) when applying effects to citizens, since healingsaturation at least was using negative values as strengths and it's a useful capability moving forward.  Changes HealingSaturationAddition application logic, since it was previously subtracting a negative and thus prevented 2x 'full' regeneration entirely after its unlocks.\n\nLots of javadocs, lots of final'd variables.  Removes some unused imports.\n\nGets rid of a redundant \"requires\" for locked research branches.\n\nFixes max colonist number to obey MaxCitizenPerColony setting in light of possible research expansions (or at least the lesser of CITIZEN_CAP research + 25 or 475, instead of previous 175).", "committedDate": "2021-01-28T17:11:11Z", "type": "commit"}, {"oid": "cc3ea666d18750da88a9d2229b1efa0146481753", "url": "https://github.com/ldtteam/minecolonies/commit/cc3ea666d18750da88a9d2229b1efa0146481753", "message": "Apply suggestions from code review\r\n\r\nCorrections to en_us language file, from ravenbuilder934.\n\nCo-authored-by: ravenbuilder934 <sabrinajamie@outlook.com>", "committedDate": "2021-01-28T17:13:10Z", "type": "commit"}, {"oid": "b1d1a62feb07df4dd0f30cca0c338366a472247c", "url": "https://github.com/ldtteam/minecolonies/commit/b1d1a62feb07df4dd0f30cca0c338366a472247c", "message": "Significant refactor of Research Tree displays, focusing around movement to tooltips and icons from labels, along with improved details on university level requirements.  Divides up a big method in WindowResearchTree.  Improves compatibility with https://github.com/ldtteam/Structurize/pull/239.\n\nAdds Research \"icon\" tags, and support for icons based on items or resourcelocation-based textures.  Assigns temporary icons for all existing research.  Implements world-load-time validation of icon to reduce risk of exceptions being thrown in GUI thread w/ misformed jsons or resource pack/data pack mismatch.  Needs to be divided into client / server at some point.  Some awful programmer art placeholders for some icons as proof of concepts.\n\nAdds and implements \"alternate-building\" research requirements tags.  These can coexist with normal building requirements, but only one of all \"alternate-building\"s for a given research will be needed.\n\nAdds ability to cancel research in progress, which sets the research into the ResearchState.CANCELED value.  This research can then be restarted without repaying the cost.  Some work toward doing the same to undo completed T6 or onlyChild research, though this is incomplete and disabled.\n\nSome code de-deplucation for ResearchRequirement.isFulfilled, and cleanup of a related error.  Fixes costs for Deep Pockets/Loaded/Heavily Loaded.  Fixes translation of building hut requirements to names.", "committedDate": "2021-01-28T17:17:02Z", "type": "commit"}, {"oid": "5b2f63d5e0bfc3bbc8473e4cf93cefc2cf578029", "url": "https://github.com/ldtteam/minecolonies/commit/5b2f63d5e0bfc3bbc8473e4cf93cefc2cf578029", "message": "Apply suggestions from code review\r\n\r\nCommit of grammar- and spelling-related recommendations from code review.\n\nCo-authored-by: ravenbuilder934 <sabrinajamie@outlook.com>", "committedDate": "2021-01-28T17:17:02Z", "type": "commit"}, {"oid": "f6582c39ac273d2247eba3a9ee8889529fb272cd", "url": "https://github.com/ldtteam/minecolonies/commit/f6582c39ac273d2247eba3a9ee8889529fb272cd", "message": "Implements no-reset Research tag, representing research that can not be reset.  This does not yet prevent ancestors from being reset, and the warning texture is just a redstone torch.  Does add a tooltip.\n\nReverts ResearchState.Canceled change.  Canceled research is removed from the local research tree, and restarting it will incur full costs.  Adds better handling for inconsistent client/server status.  Fixes a case where the client's colony.LocalResearchTree lists could grow unreasonably large.\n\nAdds reset research capabilities for completed T6 research.  Adds a cost to resetting research, consumed when the reset occurs.  Adds a config option to set that cost, and helper functions to validate it.\n\nAdds additional verification steps for research starts, to make sure players actually have all the items the server expects them to need, in case of mismatch.  May need to evaluate doing the same for other checks like onlyChild or parentResearched.\n\nFurther UI work in WindowResearchTree.  Tried to move longer translation outputs into multiple lines of text.  Removes early attempts at embedding splits into language file.\n\nAdds missing javadocs/finals.", "committedDate": "2021-01-28T17:17:02Z", "type": "commit"}, {"oid": "f05f75e00670385a1fa3cbb845cb8e103b607fd6", "url": "https://github.com/ldtteam/minecolonies/commit/f05f75e00670385a1fa3cbb845cb8e103b607fd6", "message": "Fixing a few last cases where the research gui would have wrong data is a player beats the colony update pack to the draw.\n\nActually includes the no-reset setting for Heavily Loaded.", "committedDate": "2021-01-28T17:17:02Z", "type": "commit"}, {"oid": "e10a102e7dcaa9abf8094e482d590c67ac881479", "url": "https://github.com/ldtteam/minecolonies/commit/e10a102e7dcaa9abf8094e482d590c67ac881479", "message": "Properly implements data serialization and deserialization for GlobalResearchTree, only sent when first connecting to a physical server, or when datapacks on a physical server are reloaded.  Apologies ahead of time for what I did to GlobalResearchFactory.\n\nAdds the \"branch-id\" and \"base-time\" tags, which can be used to set the (highly estimated!) expected time for a given research branch.  These files can also contain \"name\" tags which apply to the branch label text as translation text.  Removes the configuration setting to change research speed.\n\nAdds the \"subtitle\" tag to Researches and Research Effects.  This does need to be a fully-qualified translation key or the string intended to present to users, rather than auto-generated from id, since it's an optional tag.  Only a few items contain it for now.\n\nRemoves research-related colony ticking.  Add colony research building requirement checking events to AbstractEntityAIStructureWithWorkOrder's executeSpecificCompleteActions and moved the logic to handle such into ResearchManager. Moves as much of the logic as is practical from TryResearchMessage to LocalResearchTree.\n\nAdds sound effects to some research events and failures.\n\nSwitches ItemUtils.tryRemoveStackFromItemHandler and tryRemoveStorageFromItemHandler to check for item presence then remove, rather than previous spool/unspool-on-fail.\n\nLots of code cleanup: switches to doubles whenever floats were used, gets rid of unused imports, properly wildcards generics when correct, moves some Lists to HashSets, removes duplicates from building registry and adjusts properties to match.  Hopefully managed to keep newlines in line.  Fixes a lot of bad json formatting.", "committedDate": "2021-01-28T17:24:09Z", "type": "commit"}, {"oid": "03af164487473a1acb16b99d32e851b691232d44", "url": "https://github.com/ldtteam/minecolonies/commit/03af164487473a1acb16b99d32e851b691232d44", "message": "Slightly more elegant approach for NBT-based serialization and deserialization, reduces situations where cost or effect lists seem to get shuffled around.", "committedDate": "2021-01-28T17:24:09Z", "type": "commit"}, {"oid": "1f0b404d3523f8c113f4045bc492f41a1336c1ec", "url": "https://github.com/ldtteam/minecolonies/commit/1f0b404d3523f8c113f4045bc492f41a1336c1ec", "message": "Improves logic, comments, and clarity of WindowResearchTree.java.  Removes uses of a hard-coded 6, and reduces the usages of MAX_DEPTH when possible to use building.getMaxBuildingLevel instead.  There are still a handful of usages, but changing them involves either cracking open protection levels on UniversityBuilding or using a different hard-coded variable.\n\nReduces extraneous looping in drawTreeBackground, gets rid of Math.min calls in drawTree (and does some cleanup related to them).\n\nFixes some behavior related to the armordurabilitymultiplier and tooldurabilitymultiplier effects, as discussed with SomeAddons in the \"getting-started\" discord.  Clarifies translation text for them.  This is effectively a small nerf to Diamond Coated's line, and a significant buff to Diamond Skin's line.", "committedDate": "2021-01-28T17:26:21Z", "type": "commit"}, {"oid": "9b5fb23ce2073074eed97845fc9ce8d1afa23858", "url": "https://github.com/ldtteam/minecolonies/commit/9b5fb23ce2073074eed97845fc9ce8d1afa23858", "message": "Apply suggestions from code review\r\n\r\nSpelling, grammar, and correctness.\n\nCo-authored-by: ravenbuilder934 <sabrinajamie@outlook.com>", "committedDate": "2021-01-28T17:28:55Z", "type": "commit"}, {"oid": "f05da9dabdd756aa2cc61cbb7b9e2001971bdd1b", "url": "https://github.com/ldtteam/minecolonies/commit/f05da9dabdd756aa2cc61cbb7b9e2001971bdd1b", "message": "Implements sorting for researches with siblings, based on resource location.  Applies some style recommendations.  Adds a few subtitles.  Improves hovertext color for locked hutblocks.\n\nRemoves old tooltip from multiple-reset functionality.  Improves comments further.  Removes situation where multiple valid researches would have the same ResourceLocation.", "committedDate": "2021-01-28T17:31:01Z", "type": "commit"}, {"oid": "5a6191f51b895740dc07d51d6e442dab74cfcb32", "url": "https://github.com/ldtteam/minecolonies/commit/5a6191f51b895740dc07d51d6e442dab74cfcb32", "message": "Capitalization fixes.\r\n\r\nFixing capitalization and styles.\n\nCo-authored-by: ravenbuilder934 <sabrinajamie@outlook.com>", "committedDate": "2021-01-28T17:31:01Z", "type": "commit"}, {"oid": "8b45c681b94c7f68dcab58625a482a6c9190539f", "url": "https://github.com/ldtteam/minecolonies/commit/8b45c681b94c7f68dcab58625a482a6c9190539f", "message": "Serializing Research ResourceLocations\n\nAdds ResourceLocation.getPath to the serialization/deserialization process in GlobalResearchFactory.  Only impacts sorting of tree branches now, but may be relevant for other mods using the API side.", "committedDate": "2021-01-28T17:31:01Z", "type": "commit"}, {"oid": "c3a693f78f81be2b578a116c522e5dc0b5027b2d", "url": "https://github.com/ldtteam/minecolonies/commit/c3a693f78f81be2b578a116c522e5dc0b5027b2d", "message": "Changes requiredUniversityLevel json tag to researchLevel", "committedDate": "2021-01-28T17:35:03Z", "type": "commit"}, {"oid": "1b8af336403ffb3b32317849cfa9a4864778d1c0", "url": "https://github.com/ldtteam/minecolonies/commit/1b8af336403ffb3b32317849cfa9a4864778d1c0", "message": "Apply subtitles from code review\r\n\r\nAdding subtitles to additional research tooltips.\n\nCo-authored-by: ravenbuilder934 <sabrinajamie@outlook.com>", "committedDate": "2021-01-28T17:35:03Z", "type": "commit"}, {"oid": "5298d63fd4322146606088e381e390e418e768a8", "url": "https://github.com/ldtteam/minecolonies/commit/5298d63fd4322146606088e381e390e418e768a8", "message": "Update a constant field name\n\nMissed this in last commit.", "committedDate": "2021-01-28T17:35:03Z", "type": "commit"}, {"oid": "f48ea70e984e834b50137bdd74a46509e61b0f1f", "url": "https://github.com/ldtteam/minecolonies/commit/f48ea70e984e834b50137bdd74a46509e61b0f1f", "message": "Updates another constant field name\n\nBecause I missed a file in staging.", "committedDate": "2021-01-28T17:35:03Z", "type": "commit"}, {"oid": "bff432ea742391f4c5f1ee60f2fcd4b5c27083a4", "url": "https://github.com/ldtteam/minecolonies/commit/bff432ea742391f4c5f1ee60f2fcd4b5c27083a4", "message": "Functional commit to match ShadowProtocol's layout and style for WindowResearchTree.  Adds a display of in progress and max in-progress research to WindowHutUniversity.\n\nAdds a number of suggested subtitles.\n\nRemoves a few debug-related behaviors, improves Creative research behavior.", "committedDate": "2021-01-28T17:37:40Z", "type": "commit"}, {"oid": "23dbf57b9d3dcd3b8576e09b7827229e94d446d4", "url": "https://github.com/ldtteam/minecolonies/commit/23dbf57b9d3dcd3b8576e09b7827229e94d446d4", "message": "Implements ResearchTreeView changes, removes \"id\" properties.\n\nAdds textures and improved ResearchTreeView gui from ShadowProtocol.\nRemoves research and researcheffect \"id\" properties from json, and implements a new id based on resourcelocation. Removes the separate resourceLocation variable.\nImplements an improved compatlayer to load old format researches.\nImplements a \"sortOrder\" property for researches.\nChanges string separator on ResearchRequirement and ResearchEffect attributes from ':' to '`'.\nAdds a few subtitles from ShadowProtocol.\nAdds warehouses to the type of hutblocks that will have a tooltip show up if they're locked by research.\nSets research declaring an effect without a corresponding research effect file to act as a simple unlock.  This does mean that researches/effects/*unlock.json and researches/effects/blockhut*.json files are no longer necessary: I've left them included to act as templates for staged levels of unlocks later.", "committedDate": "2021-01-28T17:45:38Z", "type": "commit"}, {"oid": "45e580e55afb00c531c9a83404f61df283513a1b", "url": "https://github.com/ldtteam/minecolonies/commit/45e580e55afb00c531c9a83404f61df283513a1b", "message": "Rebase Cleanup\n\nCleanup of a rebase to HEAD.", "committedDate": "2021-01-28T18:24:55Z", "type": "commit"}, {"oid": "45e580e55afb00c531c9a83404f61df283513a1b", "url": "https://github.com/ldtteam/minecolonies/commit/45e580e55afb00c531c9a83404f61df283513a1b", "message": "Rebase Cleanup\n\nCleanup of a rebase to HEAD.", "committedDate": "2021-01-28T18:24:55Z", "type": "forcePushed"}, {"oid": "4727a94bc81831bc1fa5cd9bea0ab9f7e37ec21d", "url": "https://github.com/ldtteam/minecolonies/commit/4727a94bc81831bc1fa5cd9bea0ab9f7e37ec21d", "message": "Merge branch 'version/1.16.3' into version/1.16.3-research-datapack", "committedDate": "2021-01-28T18:31:22Z", "type": "commit"}]}