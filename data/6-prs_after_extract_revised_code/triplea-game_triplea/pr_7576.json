{"pr_number": 7576, "pr_title": "Convert standard battle steps", "pr_createdAt": "2020-09-08T22:00:35Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7576", "timeline": [{"oid": "1cd72b85200ec7e9de2890aad83a034332b1ffb4", "url": "https://github.com/triplea-game/triplea/commit/1cd72b85200ec7e9de2890aad83a034332b1ffb4", "message": "Convert standard battle steps", "committedDate": "2020-09-08T21:58:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1ODgwMw==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485258803", "bodyText": "If something should only be called from 'test', the @VisibleForTesting annotation can be used to test for that.\nHave you considered trying a different approach where instead of checking class type there is a property flag that can be retrieved from the executable object? That would look like some sort of flag stating \"I'm the standard attackers fire step\" (perhaps an enum).", "author": "DanVanAtta", "createdAt": "2020-09-08T23:58:36Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -108,16 +110,6 @@\n     private static final long serialVersionUID = 1369227461759133105L;\n   }\n \n-  /**\n-   * An action representing standard attacking fire.\n-   *\n-   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an", "originalCommit": "1cd72b85200ec7e9de2890aad83a034332b1ffb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2Nzc5Ng==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485267796", "bodyText": "This class has been deleted.  The tests that depend on the class types are slowly going away.  They are being replaced with the Order enums.", "author": "trevan", "createdAt": "2020-09-09T00:30:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1ODgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMxMTk2MQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485311961", "bodyText": "Gah, my mistake again, the 'night mode' in my browser made the deleted lines look like additions. I see now this is removed.", "author": "DanVanAtta", "createdAt": "2020-09-09T03:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1ODgwMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1OTk4NQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485259985", "bodyText": "nit, while the serialVersionUID do not need to be unique across classes, this might throw a few programmers and typically they are UUID's.\nI wonder if we're at the point for creating a helper to create an IExecutable for us? It really is just a BiConsumer` interface, eg:\nIExecutable {\n\n\n   static IExecutable newExecutable(BiConsumer<ExecutionStack, DelegateBridge> action) {\n\n      return new IExecutable() {\n\n          @Override\n          public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n            action.accept(stack, bridge);\n          }\n      }\n   }\n}\n\n\nThat would make the current code nicer. Though, I'm starting to think our biggest gains is by removing the IDelegateBridge from the interface if possible. IMO it's important that we are making such a future decoupling easier rather than more difficult.", "author": "DanVanAtta", "createdAt": "2020-09-09T00:02:21Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1553,15 +1547,15 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n       steps.add(offensiveFirstStrike);\n     }\n     // Attacker fire remaining units\n-    steps.add(\n-        new StandardAttackersFire() {\n-          private static final long serialVersionUID = 99994L;\n+    steps.add(offensiveStandard);\n+    new IExecutable() {\n+      private static final long serialVersionUID = 99994L;", "originalCommit": "1cd72b85200ec7e9de2890aad83a034332b1ffb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3MDkzNQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485270935", "bodyText": "I can't change this serial number.  It will break save games.\nAll of the apis that require the IDelegateBridge are being added to the BattleActions interface.  Once all of the steps have been converted, I plan to go through the apis and shrink them as much as possible.  I'd like to get to the point when all the api does is call something on IDelegateBridge.  At that point, we can look into moving BattleActions from MustFightBattle to IDelegateBridge or changing the IDelegateBridge api itself.", "author": "trevan", "createdAt": "2020-09-09T00:42:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1OTk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMxMTgyNg==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485311826", "bodyText": "Oh.. understood on the serial version ID.\nI'm thinking IDelegateBridge probably should not be related to MustFightBattle at all and the callers should do the coordination. between the two.", "author": "DanVanAtta", "createdAt": "2020-09-09T03:14:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1OTk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMxNTgwNQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485315805", "bodyText": "Yes, IDelegateBridge shouldn't be related to MustFightBattle.  I'm saying that the interface BattleActions might fit better on IDelegateBridge once all of the apis have been cleaned up.", "author": "trevan", "createdAt": "2020-09-09T03:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1OTk4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0cc534ac2cc7c0ab6be8d9b1aaa456654dac7dd0", "chunk": "diff --git a/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java b/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\nindex 673a3969b..e64b07812 100644\n--- a/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n+++ b/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n\n@@ -1553,7 +1553,7 @@ public class MustFightBattle extends DependentBattle\n \n       @Override\n       public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-        new OffensiveStandard(MustFightBattle.this, MustFightBattle.this).execute(stack, bridge);\n+        new OffensiveGeneral(MustFightBattle.this, MustFightBattle.this).execute(stack, bridge);\n       }\n     };\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MDIzMg==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485260232", "bodyText": "nit, can we use a different word than standard? I don't know it's well enough defined to have a lot of meaning. DefensiveRoll would perhaps be just as meaningful. standard raises the question, what is non-standard?", "author": "DanVanAtta", "createdAt": "2020-09-09T00:03:21Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1576,15 +1570,15 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n       }\n     };\n \n-    steps.add(\n-        new IExecutable() {\n-          private static final long serialVersionUID = 1560702114917865290L;\n+    steps.add(defensiveStandard);", "originalCommit": "1cd72b85200ec7e9de2890aad83a034332b1ffb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2OTk0MQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485269941", "bodyText": "All of the other steps refer to their \"type\": FirstStrike, AA, NavalBombardment, etc.  I agree that standard is probably not the best, but I don't think roll is even better.  I could do units but then it might be confusing since this isn't all of the defensive units, only the ones that haven't fired yet.  I've seen the code also refer to this group as regular.  I'm not sure what to call them.", "author": "trevan", "createdAt": "2020-09-09T00:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MDIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMxMTU3MQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485311571", "bodyText": "Perhaps simply then: 'defensive' without the qualifier?", "author": "DanVanAtta", "createdAt": "2020-09-09T03:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MDIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMxODAzOQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485318039", "bodyText": "The class names would be just \"Defensive\"?  That feels a little weird to me.\nI went through a few rule books and I noticed that \"general\" was used a few times.  So maybe defensiveGeneral/offensiveGeneral?  Or \"units\" since the rule books would say \"attacking units\", even though it had mentioned subs, etc beforehand.", "author": "trevan", "createdAt": "2020-09-09T03:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MDIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0MzQ5Mg==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485343492", "bodyText": "Interesting thoughts, as another suggestion:  DefensiveUnitsReturnFire?", "author": "DanVanAtta", "createdAt": "2020-09-09T05:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MDIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzOTA0Nw==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485939047", "bodyText": "I've renamed them to be DefensiveGeneral and OffensiveGeneral and they are in the new general package.", "author": "trevan", "createdAt": "2020-09-09T21:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MDIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4NzM2NA==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485987364", "bodyText": "I think I've a slight preference for the names \"OffensiveFire\" and \"DefensiveFire\". The qualified variants of that I think distinguish those, somewhat concerned that 'general' has the same issues as standard.\nNBD though.", "author": "DanVanAtta", "createdAt": "2020-09-10T00:07:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MDIzMg=="}], "type": "inlineReview", "revised_code": {"commit": "0cc534ac2cc7c0ab6be8d9b1aaa456654dac7dd0", "chunk": "diff --git a/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java b/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\nindex 673a3969b..e64b07812 100644\n--- a/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n+++ b/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n\n@@ -1576,7 +1576,7 @@ public class MustFightBattle extends DependentBattle\n \n       @Override\n       public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-        new DefensiveStandard(MustFightBattle.this, MustFightBattle.this).execute(stack, bridge);\n+        new DefensiveGeneral(MustFightBattle.this, MustFightBattle.this).execute(stack, bridge);\n       }\n     };\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MTA5Nw==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485261097", "bodyText": "Have you considered inlining these methods 'standardAttackersFire' and 'standardDefendersFire'? WDYT about that idea? Otherwise, can you clarify the motivation or benefit for having them?\nAs-is, from a casual perspective, we have a one-line method (the IExecutable) that uses none of the passed in args, which invokes a single use method that is itself a one-liner. Usually such patterns are candidates for inlining to reduce indirection. Perhaps I'm missing something (?)  (an answer to the above questions might point out what that is)", "author": "DanVanAtta", "createdAt": "2020-09-09T00:06:05Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1687,32 +1681,6 @@ private void checkForUnitsThatCanRollLeft(final IDelegateBridge bridge, final bo\n     }\n   }\n \n-  private void standardAttackersFire() {\n-    findTargetGroupsAndFire(", "originalCommit": "1cd72b85200ec7e9de2890aad83a034332b1ffb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2OTI2Mg==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485269262", "bodyText": "I'm confused.  I did inline this in the OffensiveStandard and DefensiveStandard class.  It looks like you might have gotten the deleted lines and the added lines backwards.", "author": "trevan", "createdAt": "2020-09-09T00:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MTA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMxMTMwNg==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485311306", "bodyText": "hah, true enough : )\nSorry about that.", "author": "DanVanAtta", "createdAt": "2020-09-09T03:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MTA5Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MjYwOQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485262609", "bodyText": "Side-note, it seems like this class knows quite a lot:\n\nhow to form step names (EG:  attacker.getName() + FIRE\nhow to extract step names (EG: steps.addAll(offensiveFirstStrike.getNames());)\nthe ordering of steps\nif to offer certain steps (evaluates retreat rules, eg: line 215 (if (RetreatChecks.canAttackerRetreat(...)\n\nAny thoughts about this long term and if we're heading in a direction to fix this?", "author": "DanVanAtta", "createdAt": "2020-09-09T00:11:41Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -185,20 +189,14 @@ public boolean isAmphibious() {\n       steps.addAll(offensiveFirstStrike.getNames());\n     }\n     steps.addAll(airAttackVsNonSubs.getNames());\n+    steps.addAll(offensiveStandard.getNames());\n \n-    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n-      steps.add(attacker.getName() + FIRE);", "originalCommit": "1cd72b85200ec7e9de2890aad83a034332b1ffb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2ODg4OA==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485268888", "bodyText": "Once all of the steps are converted, it will just create the steps, then order them, and then map them to their names.\nSee MustFightBattle#addFightStartSteps at \n  \n    \n      triplea/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n    \n    \n         Line 1051\n      in\n      1cd72b8\n    \n    \n    \n    \n\n        \n          \n           private void addFightStartSteps(final List<IExecutable> steps) { \n        \n    \n  \n\n for a rough example of what it would look like.", "author": "trevan", "createdAt": "2020-09-09T00:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MjYwOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2Mjg2Nw==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485262867", "bodyText": "Some elements have multiple steps, eg:  steps.addAll(submergeSubsVsOnlyAir.getNames());, can we use the same pattern here for attacker? EG: attacker.getNames()? This way we can avoid forming the 'fire & select casualties' here.", "author": "DanVanAtta", "createdAt": "2020-09-09T00:12:42Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -185,20 +189,14 @@ public boolean isAmphibious() {\n       steps.addAll(offensiveFirstStrike.getNames());\n     }\n     steps.addAll(airAttackVsNonSubs.getNames());\n+    steps.addAll(offensiveStandard.getNames());\n \n-    if (attackingUnits.stream().anyMatch(Matches.unitIsFirstStrike().negate())) {\n-      steps.add(attacker.getName() + FIRE);", "originalCommit": "1cd72b85200ec7e9de2890aad83a034332b1ffb4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MzQwOQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485263409", "bodyText": "Any thoughts if we can have something return this value to us?\nPerhaps we can create a module that calculates the next step and returns that as a value. IN such a case if we inject that we can then mock and control it, in which case the findTarggsGroupsAndFire parameters is not terribly interesting since it mostly comes from mocks, but ultimately testable. In turn, that module can be tested directly with a very functional style and few mocks and particularly no checking that a void method call was called with the right arguments. Thoughts?", "author": "DanVanAtta", "createdAt": "2020-09-09T00:14:41Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/standard/DefensiveStandardTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.standard;\n+\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitFirstStrike;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.List;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DefensiveStandardTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @Nested\n+  class GetNames {\n+    @Test\n+    void hasNamesIfStandardUnitAvailable() {\n+      final GameData gameData =\n+          givenGameData().withDefendingSuicideAndMunitionUnitsDoNotFire(false).build();\n+      final BattleState battleState =\n+          givenBattleStateBuilder()\n+              .defendingUnits(List.of(givenAnyUnit()))\n+              .gameData(gameData)\n+              .build();\n+      final DefensiveStandard defensiveStandard = new DefensiveStandard(battleState, battleActions);\n+      assertThat(defensiveStandard.getNames(), hasSize(2));\n+    }\n+\n+    @Test\n+    void hasNoNamesIfStandardUnitIsNotAvailable() {\n+      final GameData gameData =\n+          givenGameData().withDefendingSuicideAndMunitionUnitsDoNotFire(false).build();\n+      final BattleState battleState =\n+          givenBattleStateBuilder()\n+              .defendingUnits(List.of(givenUnitFirstStrike()))\n+              .gameData(gameData)\n+              .build();\n+      final DefensiveStandard defensiveStandard = new DefensiveStandard(battleState, battleActions);\n+      assertThat(defensiveStandard.getNames(), hasSize(0));\n+    }\n+  }\n+\n+  @Nested\n+  class FireAa {\n+    @Test\n+    void onlyFireStandardUnits() {\n+      final GameData gameData =\n+          givenGameData().withDefendingSuicideAndMunitionUnitsDoNotFire(false).build();\n+      final DefensiveStandard defensiveStandard =\n+          new DefensiveStandard(\n+              givenBattleStateBuilder().defendingAa(List.of()).gameData(gameData).build(),\n+              battleActions);\n+\n+      defensiveStandard.execute(executionStack, delegateBridge);\n+\n+      verify(battleActions)\n+          .findTargetGroupsAndFire(\n+              eq(MustFightBattle.ReturnFire.ALL),", "originalCommit": "1cd72b85200ec7e9de2890aad83a034332b1ffb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3MTMwNQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485271305", "bodyText": "I'm not sure what you are asking.", "author": "trevan", "createdAt": "2020-09-09T00:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MzQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMxMDk2OQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485310969", "bodyText": "I'll be direct:\n\nmocks are testing code smell\nverifying calls to void methods on mocks is an even bigger smell (you're verifying that a side-effect has occurred in very coupled manner).\n\nTo simplify and illustrate what we have:\nStrategyObject mockStrategy = mock(StrategyObject.class);\nClassUnderTest sut = new ClassUnderTest(mockStrategy);\n\nsut.voidCall(\"some arg\");\n\nverify(mockStrategy).sideEffect(eq(\"some computation\"));\n\nThe above I'd go as far to say is a testing anti-pattern:\n\nhighly coupled to implementation. Change the prod code, even if you just change API you use, you break the test. Not because the feature is broken, but because the implementation is changed.\nit bakes in the void method calls, which are side-effects into the code deeper and tests that we have side-effects invoked\nif you ever mock an object, one must in turn test that same mocked object (as a concrete, real object) with all of the expected parameters to assert it actually returns the stubbed responses. Otherwise who is to say that the actual object behaves that way, in which case the test is not testing anything. For example, if I mock a DB layer to return 5 results from a select, I need to take the real DB and assert that given that select I get 5 results. Otherwise if the real DB throws a syntax error or otherwise, and all I have done is mocked it, then I'll have a bug that the test papered-over and was not sufficient enough to test (so either use a real object or create another test to verify the behavior that was mocked in the orignal test).\n\nTo fix the above, one can often transform the object under test to be a function and then have the caller pass the result to the void method call. So in production code, our original example is this:\nnew ClassUnderTest(new StrategyObject()).voidCall(\"some arg\");\n\nInstead you can transform that into:\nvar result = ClassUnderTest().computeSomething(\"some arg\");\nnew StrategyObject().sideEffect(result);\n\nNow, you can test ClassUnderTest without mocks and you can still test StrategyObject just as you would have before.\nIf things are really coupled then a half step that helps is:\n\nClassUnderTest(new ArgTransformFunction(), new StrategyObject()  ).voidCall(\"some arg\");\n\n// where ArgTransformFunction = \"some arg\" -> \"some computation\"\n\nWith that latter the test for ClassUnderTest is completely with mocks. Which is good as all the variation is under your control and you can still test \"new ArgTransformFunction()\" and \"new StrategyObject()\" independently. In these cases you are roughly able to remove the verify invocations.\nNow, how difficult it would be to do such a transformation is a question. The arg conversion strategy can often be injected as a '@VisibleForTest' constructor and this way you move the interesting code under test to its own unit that you can test in isolation without mocks.\n\nBeyond the above, something I was thinking about, I'd recommend building some harness or characterization tests. I suspect tests that would help most in the restructuring would have setups like \"given a sub, and a v2 transport\", assert that the executable stack has \"first-strike attack and defender return fire\".", "author": "DanVanAtta", "createdAt": "2020-09-09T03:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MzQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMxNTMxMA==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485315310", "bodyText": "Understood.  I'll work on this once I've got all the battle steps converted.", "author": "trevan", "createdAt": "2020-09-09T03:28:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MzQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NDI4OQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485344289", "bodyText": "With respect to updating the unit test to be nicer, I can understand postponing that and I'm happy letting things evolve first. In the meantime, is there a reasonable way in which this test could fail? What type of programming errors are possible for that to happen? Have you considered deleting this test?\nMy 2 cents, such characterization tests are probably going to keep these updates much safer for you. You'll have a lot more confidence that you have not introduced any bugs and because you'll have test coverage you won't have to add unit tests at every step of the way. It's always risky doing the latter approach as it's hard to know if you are unit testing buggy code and thereby asserting defective behavior.", "author": "DanVanAtta", "createdAt": "2020-09-09T05:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MzQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NDc2OA==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485344768", "bodyText": "Phrased another way, what exactly are we testing here? Is this a valuable test? Will it be deleted the first time we try to any kind of refactoring and is a failure more likely to indicate that the code changed rather than is wrong?", "author": "DanVanAtta", "createdAt": "2020-09-09T05:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MzQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NTY5Mw==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485345693", "bodyText": "For example, there is another test with this:\n      verify(battleActions)\n          .findTargetGroupsAndFire(\n              eq(MustFightBattle.ReturnFire.ALL),\n              any(),\n              eq(false),\n              any(),\n              any(),\n              anyCollection(),\n              anyCollection(),\n              anyCollection(),\n              anyCollection());\n    }\n\nIf both of these fail, one would be left wondering \"why was this a valid assertion in the first place?\" Why was this test correct, and what was it testing? DisplayName on test and comments in the assertion and in verifications woud help with that.\nTests are great, but a double edged sword as they can become slow and a point of maintenance. When a test fails, the first questions are: \"what was this testing?\" and \"why was this test valid?\". If those questions take a lot of time to determine, and it's just one of a dozen tests to fix, then there is substantial cost to change code. Hence, it's very important that tests are overly verbose in what they are testing and why we expect them to be correct and pass. This way someone trying to fix the test can easily know if the test is still valid and what to look for if the test fails", "author": "DanVanAtta", "createdAt": "2020-09-09T05:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MzQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1NTgzOA==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485355838", "bodyText": "@trevan I'm still thinking about this example, I'm not necessarily convinced one way or another if it should remain or go.\nThe fact there are any matchers for most of the items we are testing is quite good to indicate which values we are really testing. A comment next to the 'false' perhaps could be most of what we need to make it clear why we expect that 'false' value to be there. Maybe ditto with the 'ReturnFire.ALL' enum.", "author": "DanVanAtta", "createdAt": "2020-09-09T05:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MzQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzODg1MQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485938851", "bodyText": "@DanVanAtta , I've just deleted the tests.  The really important part that needs to be tested is the matcher but I can't figure out how to match that.  I'll be refactoring the findTargetGroupsAndFire at some point in the future and then the tests will be better.", "author": "trevan", "createdAt": "2020-09-09T21:43:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MzQwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "3e5463ea338427bce74522c0bc45579454b8a7ef", "chunk": "diff --git a/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/standard/DefensiveStandardTest.java b/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/standard/DefensiveStandardTest.java\nindex 3ea108bc3..60088eb87 100644\n--- a/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/standard/DefensiveStandardTest.java\n+++ b/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/standard/DefensiveStandardTest.java\n\n@@ -5,18 +5,15 @@ import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.given\n import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitFirstStrike;\n import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.empty;\n import static org.hamcrest.Matchers.hasSize;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyCollection;\n-import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.Mockito.verify;\n+import static org.hamcrest.Matchers.is;\n \n import games.strategy.engine.data.GameData;\n import games.strategy.engine.delegate.IDelegateBridge;\n import games.strategy.triplea.delegate.ExecutionStack;\n import games.strategy.triplea.delegate.battle.BattleActions;\n import games.strategy.triplea.delegate.battle.BattleState;\n-import games.strategy.triplea.delegate.battle.MustFightBattle;\n import java.util.List;\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NjI4Nw==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485346287", "bodyText": "nit, there is a IsEmptyCollection.empty() matcher, often used with the is matcher:\nassertThat(offensiveStandard.getNames(), is(empty());\n\nHave you considered using the matcher? If the test fails that matcher will print the contents of the collection rather than reporting simply that the size was not zero.", "author": "DanVanAtta", "createdAt": "2020-09-09T05:26:41Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/standard/OffensiveStandardTest.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.standard;\n+\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitFirstStrike;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.List;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveStandardTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @Nested\n+  class GetNames {\n+    @Test\n+    void hasNamesIfStandardUnitAvailable() {\n+      final BattleState battleState =\n+          givenBattleStateBuilder().attackingUnits(List.of(givenAnyUnit())).build();\n+      final OffensiveStandard offensiveStandard = new OffensiveStandard(battleState, battleActions);\n+      assertThat(offensiveStandard.getNames(), hasSize(2));\n+    }\n+\n+    @Test\n+    void hasNoNamesIfStandardUnitIsNotAvailable() {\n+      final BattleState battleState =\n+          givenBattleStateBuilder().attackingUnits(List.of(givenUnitFirstStrike())).build();\n+      final OffensiveStandard offensiveStandard = new OffensiveStandard(battleState, battleActions);\n+      assertThat(offensiveStandard.getNames(), hasSize(0));", "originalCommit": "1cd72b85200ec7e9de2890aad83a034332b1ffb4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e5463ea338427bce74522c0bc45579454b8a7ef", "chunk": "diff --git a/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/standard/OffensiveStandardTest.java b/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/standard/OffensiveStandardTest.java\nindex a992e1a5a..b2ca2e855 100644\n--- a/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/standard/OffensiveStandardTest.java\n+++ b/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/standard/OffensiveStandardTest.java\n\n@@ -4,7 +4,9 @@ import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattle\n import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitFirstStrike;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.empty;\n import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyCollection;\n import static org.mockito.ArgumentMatchers.eq;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NjUwOQ==", "url": "https://github.com/triplea-game/triplea/pull/7576#discussion_r485346509", "bodyText": "Good to see a lot of custom mocking removed \ud83d\udc4d", "author": "DanVanAtta", "createdAt": "2020-09-09T05:27:29Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -325,53 +316,4 @@ void retreatDoesNotHappenWhenCanNotSubmergeAndNoRetreatTerritories() {\n \n     verify(battleActions, never()).queryRetreat(anyBoolean(), any(), any(), any());\n   }\n-\n-  public static class MockGameData {", "originalCommit": "1cd72b85200ec7e9de2890aad83a034332b1ffb4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "3e5463ea338427bce74522c0bc45579454b8a7ef", "url": "https://github.com/triplea-game/triplea/commit/3e5463ea338427bce74522c0bc45579454b8a7ef", "message": "Clean up tests", "committedDate": "2020-09-09T21:37:15Z", "type": "commit"}, {"oid": "0cc534ac2cc7c0ab6be8d9b1aaa456654dac7dd0", "url": "https://github.com/triplea-game/triplea/commit/0cc534ac2cc7c0ab6be8d9b1aaa456654dac7dd0", "message": "Rename standard -> general", "committedDate": "2020-09-09T21:45:20Z", "type": "commit"}, {"oid": "0cc534ac2cc7c0ab6be8d9b1aaa456654dac7dd0", "url": "https://github.com/triplea-game/triplea/commit/0cc534ac2cc7c0ab6be8d9b1aaa456654dac7dd0", "message": "Rename standard -> general", "committedDate": "2020-09-09T21:45:20Z", "type": "forcePushed"}]}