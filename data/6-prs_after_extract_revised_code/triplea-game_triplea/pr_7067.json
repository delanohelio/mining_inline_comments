{"pr_number": 7067, "pr_title": "Add tests for UnitImageFactory#getBaseImageName", "pr_createdAt": "2020-07-08T00:17:28Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7067", "timeline": [{"oid": "2fdd81769394d5f06b63dcb0ff9baf7ec0635567", "url": "https://github.com/triplea-game/triplea/commit/2fdd81769394d5f06b63dcb0ff9baf7ec0635567", "message": "Add tests for UnitImageFactory#getBaseImageName", "committedDate": "2020-07-08T00:14:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE1MDY5Ng==", "url": "https://github.com/triplea-game/triplea/pull/7067#discussion_r453150696", "bodyText": "nit, it's a bit more conventional to do test set up and assertions as separate steps. EG:\ngiven  // establish state\n\nwhen   // do the action under state\n\nthen   // assert return value has expected value\n          // assert expected post-state\n\nThe pattern is \"arrange act assert\" (AAA): https://medium.com/@pjbgf/title-testing-code-ocd-and-the-aaa-pattern-df453975ab80\nSo in this case, having the 'assert' and the 'given' split would perhaps be more canonical.", "author": "DanVanAtta", "createdAt": "2020-07-11T03:49:37Z", "path": "game-core/src/test/java/games/strategy/triplea/image/UnitImageFactoryTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+package games.strategy.triplea.image;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.TechnologyFrontier;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class UnitImageFactoryTest {\n+  @Mock GameData gameData;\n+\n+  @Nested\n+  class GetBaseImageName {\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      final TechnologyFrontier technologyFrontier = new TechnologyFrontier(\"Tech\", gameData);\n+      when(gameData.getTechnologyFrontier()).thenReturn(technologyFrontier);\n+      lenient().when(gameData.getDiceSides()).thenReturn(6);\n+      final GameProperties gameProperties = new GameProperties(gameData);\n+      lenient().when(gameData.getProperties()).thenReturn(gameProperties);\n+    }\n+\n+    @Test\n+    void basicUnitType() throws MutableProperty.InvalidValueException {\n+      givenUnitTypeAndTechnologyAssertThatImageHasSuffix(List.of(), List.of(), \"\");", "originalCommit": "2fdd81769394d5f06b63dcb0ff9baf7ec0635567", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE1MDkwNA==", "url": "https://github.com/triplea-game/triplea/pull/7067#discussion_r453150904", "bodyText": "Any thoughts to extract '_hit' (and other magic suffixes) to a constant?\nIf we were to use a constant, and we were for example to change the suffix or otherwise, then the tests would automatically be updated. Keeping test maintenance and coupling to production code low is a good thing. One can get into a case where small changes results in many test changes (while having tests is better than none,  keeping them maintainable helps avoid at least that secondary trap).", "author": "DanVanAtta", "createdAt": "2020-07-11T03:51:48Z", "path": "game-core/src/test/java/games/strategy/triplea/image/UnitImageFactoryTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+package games.strategy.triplea.image;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.TechnologyFrontier;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class UnitImageFactoryTest {\n+  @Mock GameData gameData;\n+\n+  @Nested\n+  class GetBaseImageName {\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      final TechnologyFrontier technologyFrontier = new TechnologyFrontier(\"Tech\", gameData);\n+      when(gameData.getTechnologyFrontier()).thenReturn(technologyFrontier);\n+      lenient().when(gameData.getDiceSides()).thenReturn(6);\n+      final GameProperties gameProperties = new GameProperties(gameData);\n+      lenient().when(gameData.getProperties()).thenReturn(gameProperties);\n+    }\n+\n+    @Test\n+    void basicUnitType() throws MutableProperty.InvalidValueException {\n+      givenUnitTypeAndTechnologyAssertThatImageHasSuffix(List.of(), List.of(), \"\");\n+    }\n+\n+    @Test\n+    void basicDamagedUnitType() throws MutableProperty.InvalidValueException {\n+      givenUnitTypeAndTechnologyAssertThatImageHasName(\n+          \"infantry\", List.of(), List.of(), true, false, \"infantry_hit\");", "originalCommit": "2fdd81769394d5f06b63dcb0ff9baf7ec0635567", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE1MTYzNA==", "url": "https://github.com/triplea-game/triplea/pull/7067#discussion_r453151634", "bodyText": "Boolean parameters can be difficult to understand. Overloaded methods or a parameter object can help clarify this.\nFor example, with a parameter object, we could have something like:\n\n\ngivenTestSetup(SetupParameters.builder()\n       .unitTypeName(\"infantry\")\n        .unitAttachmentProperties(List.of())\n        .techAttachmentProperties(List.of())\n        .damaged(false)\n        .disabled(true))\n   .build());\n\nfinal String imageName =\n          UnitImageFactory.getBaseImageName(unitType, player, damaged, disabled);\n\nassertThat(imageName, is(\"infantry_disabled\");\n\nThe above refactor of course does not work since we need direct parameters.. This indicates a production code change to accept a parameter object is perhaps all we need and then the testing becomes drastically simplified.\nTo get there, you can create a method overload that accepts the parameter object and then invokes the original method. Then you can invoke the method overload from test. Once you have the test in place, it's a question of migrating the rest of the production code to use the better API.\nEG:\nfinal String imageName =\n          UnitImageFactory.getBaseImageName(  ImageNameParameters.builder()\n                .unitTypeName(\"infantry\")\n                .unitAttachmentProperties(List.of())\n                .techAttachmentProperties(List.of())\n                .damaged(false)\n                .disabled(true))\n   .build());\n\nassertThat(imageName, is(\"infantry_disabled\");\n\nFrom here, test parameterization could help and the API's would be straight forward. EG:\n@ParameterizedTest\n@MethodSource\nvoid verifyBaseImageName(ImageNameParameters. parameters, String expectedName) {\nfinal String imageName =\nUnitImageFactory.getBaseImageName(parameters);\n assertThat(imageName, is(expectedName);\n\n}\n\n\nThoughts @trevan ?", "author": "DanVanAtta", "createdAt": "2020-07-11T04:00:45Z", "path": "game-core/src/test/java/games/strategy/triplea/image/UnitImageFactoryTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+package games.strategy.triplea.image;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.TechnologyFrontier;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class UnitImageFactoryTest {\n+  @Mock GameData gameData;\n+\n+  @Nested\n+  class GetBaseImageName {\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      final TechnologyFrontier technologyFrontier = new TechnologyFrontier(\"Tech\", gameData);\n+      when(gameData.getTechnologyFrontier()).thenReturn(technologyFrontier);\n+      lenient().when(gameData.getDiceSides()).thenReturn(6);\n+      final GameProperties gameProperties = new GameProperties(gameData);\n+      lenient().when(gameData.getProperties()).thenReturn(gameProperties);\n+    }\n+\n+    @Test\n+    void basicUnitType() throws MutableProperty.InvalidValueException {\n+      givenUnitTypeAndTechnologyAssertThatImageHasSuffix(List.of(), List.of(), \"\");\n+    }\n+\n+    @Test\n+    void basicDamagedUnitType() throws MutableProperty.InvalidValueException {\n+      givenUnitTypeAndTechnologyAssertThatImageHasName(\n+          \"infantry\", List.of(), List.of(), true, false, \"infantry_hit\");\n+    }\n+\n+    @Test\n+    void basicDisabledUnitType() throws MutableProperty.InvalidValueException {\n+      givenUnitTypeAndTechnologyAssertThatImageHasName(\n+          \"infantry\", List.of(), List.of(), false, true, \"infantry_disabled\");", "originalCommit": "2fdd81769394d5f06b63dcb0ff9baf7ec0635567", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}