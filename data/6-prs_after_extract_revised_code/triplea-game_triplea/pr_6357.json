{"pr_number": 6357, "pr_title": "Inline fields in BattleCalculator", "pr_createdAt": "2020-04-30T08:36:47Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6357", "timeline": [{"oid": "b232263950718f78d7254c9ad232f7a0144988af", "url": "https://github.com/triplea-game/triplea/commit/b232263950718f78d7254c9ad232f7a0144988af", "message": "Inline fields", "committedDate": "2020-04-30T08:25:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg0OTI4NQ==", "url": "https://github.com/triplea-game/triplea/pull/6357#discussion_r417849285", "bodyText": "Once you inline this method you realize that this return statement leads to undefined behaviour.\nIt either results in an exception because the GameData has not been set properly, or it makes the calculator code run on old data without any exceptions, but with potentially bad results", "author": "RoiEXLab", "createdAt": "2020-04-30T08:40:00Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/BattleCalculator.java", "diffHunk": "@@ -16,69 +16,27 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import javax.annotation.Nonnull;\n import lombok.Setter;\n \n class BattleCalculator implements IBattleCalculator {\n   @Nonnull private final GameData gameData;\n-  private GamePlayer attacker = null;\n-  private GamePlayer defender = null;\n-  private Territory location = null;\n-  private Collection<Unit> attackingUnits = new ArrayList<>();\n-  private Collection<Unit> defendingUnits = new ArrayList<>();\n-  private Collection<Unit> bombardingUnits = new ArrayList<>();\n-  private Collection<TerritoryEffect> territoryEffects = new ArrayList<>();\n   @Setter private boolean keepOneAttackingLandUnit = false;\n   @Setter private boolean amphibious = false;\n   @Setter private int retreatAfterRound = -1;\n   @Setter private int retreatAfterXUnitsLeft = -1;\n-  private boolean retreatWhenOnlyAirLeft = false;\n   @Setter private String attackerOrderOfLosses = null;\n   @Setter private String defenderOrderOfLosses = null;\n   private volatile boolean cancelled = false;\n-  private volatile boolean isRunning = false;\n+  private final AtomicBoolean isRunning = new AtomicBoolean(false);\n \n   BattleCalculator(final GameData data, final boolean dataHasAlreadyBeenCloned) {\n     gameData =\n         Preconditions.checkNotNull(\n             dataHasAlreadyBeenCloned ? data : GameDataUtils.cloneGameData(data, false));\n   }\n \n-  /** Calculates odds using the stored game data. */\n-  private void setCalculateData(\n-      final GamePlayer attacker,\n-      final GamePlayer defender,\n-      final Territory location,\n-      final Collection<Unit> attacking,\n-      final Collection<Unit> defending,\n-      final Collection<Unit> bombarding,\n-      final Collection<TerritoryEffect> territoryEffects,\n-      final boolean retreatWhenOnlyAirLeft)\n-      throws IllegalStateException {\n-    if (isRunning) {\n-      return;\n-    }", "originalCommit": "b232263950718f78d7254c9ad232f7a0144988af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg0OTU5MQ==", "url": "https://github.com/triplea-game/triplea/pull/6357#discussion_r417849591", "bodyText": "This is my replacement for the isRunning check I mentioned", "author": "RoiEXLab", "createdAt": "2020-04-30T08:40:36Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/BattleCalculator.java", "diffHunk": "@@ -90,69 +48,82 @@ public AggregateResults calculate(\n       final Collection<TerritoryEffect> territoryEffects,\n       final boolean retreatWhenOnlyAirLeft,\n       final int runCount) {\n-    setCalculateData(\n-        attacker,\n-        defender,\n-        location,\n-        attacking,\n-        defending,\n-        bombarding,\n-        territoryEffects,\n-        retreatWhenOnlyAirLeft);\n-    return calculate(runCount);\n-  }\n-\n-  private AggregateResults calculate(final int count) {\n-    isRunning = true;\n-    final long start = System.currentTimeMillis();\n-    final AggregateResults aggregateResults = new AggregateResults(count);\n-    final BattleTracker battleTracker = new BattleTracker();\n-    // CasualtySortingCaching can cause issues if there is more than 1 one battle being calculated\n-    // at the same time (like if the AI and a human are both using the calc)\n-    // TODO: first, see how much it actually speeds stuff up by, and if it does make a difference\n-    // then convert it to a per-thread, per-calc caching\n-    final List<Unit> attackerOrderOfLosses =\n-        OrderOfLossesInputPanel.getUnitListByOrderOfLoss(\n-            this.attackerOrderOfLosses, attackingUnits, gameData);\n-    final List<Unit> defenderOrderOfLosses =\n-        OrderOfLossesInputPanel.getUnitListByOrderOfLoss(\n-            this.defenderOrderOfLosses, defendingUnits, gameData);\n-    for (int i = 0; i < count && !cancelled; i++) {\n-      final CompositeChange allChanges = new CompositeChange();\n-      final DummyDelegateBridge bridge1 =\n-          new DummyDelegateBridge(\n-              attacker,\n-              gameData,\n-              allChanges,\n-              attackerOrderOfLosses,\n-              defenderOrderOfLosses,\n-              keepOneAttackingLandUnit,\n-              retreatAfterRound,\n-              retreatAfterXUnitsLeft,\n-              retreatWhenOnlyAirLeft);\n-      final GameDelegateBridge bridge = new GameDelegateBridge(bridge1);\n-      final MustFightBattle battle =\n-          new MustFightBattle(location, attacker, gameData, battleTracker);\n-      battle.setHeadless(true);\n-      battle.setUnits(\n-          defendingUnits,\n-          attackingUnits,\n-          bombardingUnits,\n-          (amphibious ? attackingUnits : new ArrayList<>()),\n-          defender,\n-          territoryEffects);\n-      bridge1.setBattle(battle);\n-      battle.fight(bridge);\n-      aggregateResults.addResult(new BattleResults(battle, gameData));\n-      // restore the game to its original state\n-      gameData.performChange(allChanges.invert());\n-      battleTracker.clear();\n-      battleTracker.clearBattleRecords();\n+    Preconditions.checkState(\n+        !isRunning.getAndSet(true), \"Can't calculate while operation is still running!\");", "originalCommit": "b232263950718f78d7254c9ad232f7a0144988af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}