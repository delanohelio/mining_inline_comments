{"pr_number": 7088, "pr_title": "Headless: Ignore duplicate game entries", "pr_createdAt": "2020-07-10T01:15:20Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7088", "timeline": [{"oid": "ad8165410ef5c493bf2b5eabb1526215263a93b1", "url": "https://github.com/triplea-game/triplea/commit/ad8165410ef5c493bf2b5eabb1526215263a93b1", "message": "Headless: Ignore duplicate game entries\n\nIf we see a duplicate game entry, instead of a bot server crashing,\nthis will update will log the duplicate game entry and ignore it.\n\nMitigates problem: https://github.com/triplea-game/triplea/issues/7005\n\nThe fix is as follows;\n Instead of creating a `Map` directly from a stream, we instantiate the `Map` first and then do a `forEach` to add games. If we see any duplicates then we log them and do not add them to the map.", "committedDate": "2020-07-10T01:15:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyOTI2MA==", "url": "https://github.com/triplea-game/triplea/pull/7088#discussion_r452829260", "bodyText": "While I don't think I can make a qualified decision if this kind of duplicate handling is the best approach to this, I want to point out that there's an overload of the Collectors#toUnmodifianleMap method that accepts a merge function:\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)\nThe default implementation seems to be this one:\nhttps://github.com/openjdk/jdk/blob/0a38584c10c1b0d971271f47934e4003bde7d986/src/java.base/share/classes/java/util/stream/Collectors.java#L148-L159\nWhich throws exactly the exception we are experiencing.\nBy providing this custom function we can keep the functional style + we maintain the unmodifiable map, which is no longer defensively copied or wrapped somehow for thread safety (the reason why unmodifiability would be an important thing to keep)", "author": "RoiEXLab", "createdAt": "2020-07-10T13:03:39Z", "path": "game-core/src/main/java/org/triplea/game/server/AvailableGames.java", "diffHunk": "@@ -36,13 +35,23 @@\n   private final Map<String, URI> availableGames;\n \n   AvailableGames() {\n-    availableGames =\n-        FileUtils.listFiles(ClientFileSystemHelper.getUserMapsFolder())\n-            .parallelStream()\n-            .map(AvailableGames::getGames)\n-            .map(Map::entrySet)\n-            .flatMap(Collection::stream)\n-            .collect(Collectors.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    availableGames = new HashMap<>();\n+    FileUtils.listFiles(ClientFileSystemHelper.getUserMapsFolder())\n+        .parallelStream()\n+        .map(AvailableGames::getGames)\n+        .map(Map::entrySet)\n+        .flatMap(Collection::stream)\n+        .forEach(\n+            gameEntry -> {\n+              if (!availableGames.containsKey(gameEntry.getKey())) {\n+                availableGames.put(gameEntry.getKey(), gameEntry.getValue());\n+              } else {\n+                log.warning(\n+                    String.format(\n+                        \"DUPLICATE GAME ENTRY! Ignoring game entry: %s, \" + \"existing value is: %s\",\n+                        gameEntry, availableGames.get(gameEntry.getKey())));\n+              }\n+            });", "originalCommit": "ad8165410ef5c493bf2b5eabb1526215263a93b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE1MDMyMw==", "url": "https://github.com/triplea-game/triplea/pull/7088#discussion_r453150323", "bodyText": "The merge function looks really attractive. I just gave it a try, but it looks like we won't have access to the 'key' in conflict.\nThe merge function essentially allows (oldValue, newValue) -> deconflictedValue. While we can figure out the conflicting game name based on the URI alone, it certainly is more direct if we can log the game key that has the duplicate value.", "author": "DanVanAtta", "createdAt": "2020-07-11T03:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyOTI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIyMzM2OA==", "url": "https://github.com/triplea-game/triplea/pull/7088#discussion_r453223368", "bodyText": "Ah, that's something I didn't think of. Unfortunate.\nEven though this PR is already merged I have some concerns.\nThis is a parallel Stream, so we could end up running into concurrency issues because the now unsynchronized map doesn't have a wrapper for this kind of protection.\nAlso somewhere down the line we give this exact map away without any sort of write protection, which might introduce weird bugs if we modify it somewhere by accident.\nI was able to come up with 4 potential solutions to this:\n\nJust wrap it in a Collections.synchronizedMap package and return an unmodifiable collection wrapper int the API (I forgot where this was, but I removed it in my PR), the easiest solution but might hurt parallel performance and adds unecessary abstraction.\nDo it in 2 steps. We could use the streams and everything to put all of the entry objects in an unmodifiable List and use a normal for-each loop to fill a map, and all we store is the unmodifiable wrapper to this map. Easy solution, but still not optimal use of streams IMO.\nSame as 2. but instead of using for-each we use the same collector as before and iterate over all elements until we find the correct key in case we find a conflicting value. Still weird, but works as well.\nProvide a custom collector. Instead of using the default Collectors#toUnmodifiableMap we could provide our own \"implementation\". The Collector interface offers some handy static functions for this.\nThis would add some complexity:\n\nCollector.of(\n  HashMap::new,\n  (map, entry) -> {\n    // Alternative approach would be to use Map#containsKey\n    if (map.put(entry.getKey(), entry.getValue()) != null) {\n      log.log(Level.INFO, \"Duplicate key: \" + entry.getKey());\n    }\n  },\n  (map1, map2) -> {\n    for (final var entry : m2.entrySet()) {\n      // Variant two, as described earlier\n      if (map1.containsKey(entry.getKey())) {\n        log.log(Level.INFO, \"Duplicate key: \" + entry.getKey());\n      }\n      map1.put(entry.getKey(), entry.getValue())\n    }\n    return m1;\n  },\n  Collections::unmodifiableMap,\n  // Optional but for the sake of completeness\n  Collector.Characteristics.UNORDERED);\nThe only thing I don't like about approach 4 is that it duplicates the detection logic, but this could be solved by extracting it to a private static helper method, so it would look like this:\nCollector.of(\n  HashMap::new,\n  (map, entry) -> putAndWarn(map, entry.getKey(), entry.getValue()),\n  (map1, map2) -> {\n    for (final var entry : map2.entrySet()) {\n      putAndWarn(map1, entry.getKey(), entry.getValue());\n    }\n    return map1;\n  },\n  Collections::unmodifiableMap,\n  // Optional but for the sake of completeness\n  Collector.Characteristics.UNORDERED);\nWhat do you think? I leaning towards option 4 simply because I think it's the most consistent way to do it.", "author": "RoiEXLab", "createdAt": "2020-07-11T18:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyOTI2MA=="}], "type": "inlineReview", "revised_code": null}]}