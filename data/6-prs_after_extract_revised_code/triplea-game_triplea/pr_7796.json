{"pr_number": 7796, "pr_title": "Move the LandParatrooper and MarkNoMovement logic to their steps", "pr_createdAt": "2020-09-27T14:21:52Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7796", "timeline": [{"oid": "85bbd63e069f66b9e22e95324d7a0d0b906c6773", "url": "https://github.com/triplea-game/triplea/commit/85bbd63e069f66b9e22e95324d7a0d0b906c6773", "message": "Move the LandParatrooper and MarkNoMovement logic to their steps", "committedDate": "2020-09-27T14:21:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU3ODM4Nw==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r495578387", "bodyText": "There's now 3 methods dealing with dependents (getDependentUnits, removeDependentUnits, and getTransportDependents).  I'm looking into if I can simplify the api around dependent units.  I expect getTransportDependents and getDependentUnits can be combined somehow.  I also think that they might be combined with filterUnits by adding a new status TRANSPORTING.  But that will be a different PR.", "author": "trevan", "createdAt": "2020-09-27T14:24:33Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -102,6 +102,8 @@ public boolean isFirstRound() {\n \n   Collection<Unit> getDependentUnits(Collection<Unit> units);\n \n+  void removeDependentUnits(Collection<Unit> units);", "originalCommit": "85bbd63e069f66b9e22e95324d7a0d0b906c6773", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5NzM0OQ==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r495597349", "bodyText": "The change object is the interesting thing, right? The structure and data of the change object we do expect to be in a certain way, that defines correctness? For example, if it were null, I think this test might still pass.\nA captor could be used to grab the change object and then verify it. We are then pretty tied to implementation and we have another code smell where the code could change, still be correct, and the tests are breaking because they were testing implementation and not behavior.\nSo, captor is an option, another option is to have the execute method return the change object. In that case the test code would get a reference to it directly. IF we are limited by compatibility concerns (we might not be), but if we are, then the existing code could be converted to a facade and invokes a method that is visible to testing that does return a change object.\nWDYT?", "author": "DanVanAtta", "createdAt": "2020-09-27T17:47:54Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/MarkNoMovementLeftTest.java", "diffHunk": "@@ -22,24 +35,84 @@\n   @Mock BattleActions battleActions;\n \n   @Test\n-  void runsOnFirstRound() {\n-    final BattleState battleState = givenBattleStateBuilder().battleRound(1).build();\n+  void doesNotRunOnFirstRoundAndHeadless() {\n+    final BattleState battleState = givenBattleStateBuilder().battleRound(1).headless(true).build();\n     final MarkNoMovementLeft markNoMovementLeft =\n         new MarkNoMovementLeft(battleState, battleActions);\n \n     markNoMovementLeft.execute(executionStack, delegateBridge);\n \n-    verify(battleActions).markNoMovementLeft(eq(delegateBridge));\n+    verify(delegateBridge, never()).addChange(any());\n   }\n \n   @Test\n   void doesNotRunOnSecondRound() {\n-    final BattleState battleState = givenBattleStateBuilder().battleRound(2).build();\n+    final BattleState battleState =\n+        givenBattleStateBuilder().battleRound(2).headless(false).build();\n     final MarkNoMovementLeft markNoMovementLeft =\n         new MarkNoMovementLeft(battleState, battleActions);\n \n     markNoMovementLeft.execute(executionStack, delegateBridge);\n \n-    verify(battleActions, never()).markNoMovementLeft(eq(delegateBridge));\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  void nonAirWithMovementLeftAreMarkedAsMoved() {\n+    final BattleState battleState =\n+        givenBattleStateBuilder()\n+            .battleRound(1)\n+            .headless(false)\n+            .attackingUnits(List.of(givenNonAirUnitWithMovementLeft(BigDecimal.ONE)))\n+            .build();\n+    final MarkNoMovementLeft markNoMovementLeft =\n+        new MarkNoMovementLeft(battleState, battleActions);\n+\n+    markNoMovementLeft.execute(executionStack, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());", "originalCommit": "85bbd63e069f66b9e22e95324d7a0d0b906c6773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwMDUyOA==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r495600528", "bodyText": "I changed the code to use any(Change.class).  That prevents null.\nAs for actually verifying the change object, I think that might get really tied to the implementation.  This particular change object is a CompositeChange with multiple ObjectPropertyChange changes in it.  So the test would have to check that it is a CompositeChange and then grab the inner changes, cast them to ObjectPropertyChange, and then verify that they are setting the correct property (ALREADY_MOVED) and that the new value and the old value (which currently have no getters) are what is expected.  Is there already a change matcher somewhere in the code base that would do this?\nAnother idea is to just compare the toString result of the change object.  Then the code would be something like:\n    verify(delegateBridge).addChange(argThat(hasToString(\"CompositeChange <[Property change, unit:null owned by null property:alreadyMoved newValue:1 oldValue:0]>\")));", "author": "trevan", "createdAt": "2020-09-27T18:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5NzM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MzYzMg==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r495643632", "bodyText": "Indeed, it sounds like the check is if the expected property and perhaps expected value are present anywhere in the change object. A matcher would be pretty slick since you could do an iterative search through the change object. 'toString' is a bit brittle as you rely on the the toString method, but it would work too. IMO the matcher is probably the more robust way to go. AFAIK there is no such matcher.", "author": "DanVanAtta", "createdAt": "2020-09-28T01:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5NzM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI4MzYwMg==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r496283602", "bodyText": "I've made a custom matcher for ObjectPropertyChange and CompositeChange.  As more Change objects are used, the matcher can be expanded.", "author": "trevan", "createdAt": "2020-09-28T23:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5NzM0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "3cfd4f1e1bf9491e223367bee9ddfb2a5728b5b5", "chunk": "diff --git a/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/MarkNoMovementLeftTest.java b/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/MarkNoMovementLeftTest.java\nindex 4e0814ae8..d974d5d94 100644\n--- a/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/MarkNoMovementLeftTest.java\n+++ b/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/MarkNoMovementLeftTest.java\n\n@@ -70,7 +71,7 @@ class MarkNoMovementLeftTest {\n \n     markNoMovementLeft.execute(executionStack, delegateBridge);\n \n-    verify(delegateBridge).addChange(any());\n+    verify(delegateBridge).addChange(any(Change.class));\n   }\n \n   private Unit givenNonAirUnitWithMovementLeft(final BigDecimal movement) {\n"}}, {"oid": "3cfd4f1e1bf9491e223367bee9ddfb2a5728b5b5", "url": "https://github.com/triplea-game/triplea/commit/3cfd4f1e1bf9491e223367bee9ddfb2a5728b5b5", "message": "Ensure a change object is passed", "committedDate": "2020-09-27T18:11:40Z", "type": "commit"}, {"oid": "a5ffe08306e499d4e3a5788b335e1507ae27ae5f", "url": "https://github.com/triplea-game/triplea/commit/a5ffe08306e499d4e3a5788b335e1507ae27ae5f", "message": "Custom hamcrest matcher for changes", "committedDate": "2020-09-28T23:06:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwMTU5NA==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r496301594", "bodyText": "nit, would you mind extracting 'altreadyMoved' to a constant? Is that possible? The idea there being the test will automatically update with the constant and it makes it clear as well where that value is coming from for any maintainers that are potentially looking at a failing test.\nSecond nit, by convention tests use static imports for most everything matcher related (I don't always like that one, but it is a relatively consistent convention)", "author": "DanVanAtta", "createdAt": "2020-09-29T00:07:34Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/MarkNoMovementLeftTest.java", "diffHunk": "@@ -71,7 +73,12 @@ void nonAirWithMovementLeftAreMarkedAsMoved() {\n \n     markNoMovementLeft.execute(executionStack, delegateBridge);\n \n-    verify(delegateBridge).addChange(any(Change.class));\n+    verify(delegateBridge)\n+        .addChange(\n+            argThat(\n+                CompositeChangeMatcher.compositeChangeContains(\n+                    ObjectPropertyChangeMatcher.propertyChange(\n+                        \"alreadyMoved\", BigDecimal.ONE, BigDecimal.ZERO))));", "originalCommit": "a5ffe08306e499d4e3a5788b335e1507ae27ae5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed42400061a7b4e714a3d9a6ff23790c75ba0be3", "chunk": "diff --git a/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/MarkNoMovementLeftTest.java b/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/MarkNoMovementLeftTest.java\nindex 5a8a3b058..237d8fdef 100644\n--- a/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/MarkNoMovementLeftTest.java\n+++ b/game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/MarkNoMovementLeftTest.java\n\n@@ -76,9 +76,8 @@ class MarkNoMovementLeftTest {\n     verify(delegateBridge)\n         .addChange(\n             argThat(\n-                CompositeChangeMatcher.compositeChangeContains(\n-                    ObjectPropertyChangeMatcher.propertyChange(\n-                        \"alreadyMoved\", BigDecimal.ONE, BigDecimal.ZERO))));\n+                compositeChangeContains(\n+                    propertyChange(Unit.ALREADY_MOVED, BigDecimal.ONE, BigDecimal.ZERO))));\n   }\n \n   private Unit givenNonAirUnitWithMovementLeft(final BigDecimal movement) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwMTkzNg==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r496301936", "bodyText": "Any nullity concerns here?\nWhat if the new value or old value were null, and we were matching for a null value?", "author": "DanVanAtta", "createdAt": "2020-09-29T00:08:44Z", "path": "game-core/src/test/java/games/strategy/engine/data/changefactory/ObjectPropertyChangeMatcher.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package games.strategy.engine.data.changefactory;\n+\n+import games.strategy.engine.data.ChangeMatcher;\n+import lombok.AllArgsConstructor;\n+import org.hamcrest.Description;\n+\n+@AllArgsConstructor\n+public class ObjectPropertyChangeMatcher extends ChangeMatcher<ObjectPropertyChange> {\n+\n+  private final String property;\n+\n+  private final Object newValue;\n+\n+  private final Object oldValue;\n+\n+  @Override\n+  protected boolean matchesSafely(final ObjectPropertyChange item) {\n+    return item.getProperty().equals(property)\n+        && item.getNewValue().equals(newValue)", "originalCommit": "a5ffe08306e499d4e3a5788b335e1507ae27ae5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed42400061a7b4e714a3d9a6ff23790c75ba0be3", "chunk": "diff --git a/game-core/src/test/java/games/strategy/engine/data/changefactory/ObjectPropertyChangeMatcher.java b/game-core/src/test/java/games/strategy/engine/data/changefactory/ObjectPropertyChangeMatcher.java\nindex a66b49ec4..98206e8c7 100644\n--- a/game-core/src/test/java/games/strategy/engine/data/changefactory/ObjectPropertyChangeMatcher.java\n+++ b/game-core/src/test/java/games/strategy/engine/data/changefactory/ObjectPropertyChangeMatcher.java\n\n@@ -1,11 +1,19 @@\n package games.strategy.engine.data.changefactory;\n \n+import static org.hamcrest.Matchers.equalTo;\n+\n+import games.strategy.engine.data.Change;\n import games.strategy.engine.data.ChangeMatcher;\n import lombok.AllArgsConstructor;\n import org.hamcrest.Description;\n \n+/**\n+ * Matches {@link ObjectPropertyChange} objects with the requested property, newValue, and oldValue\n+ *\n+ * <p>Example usage: assertThat(change, propertyChange(property, newValue, oldValue));\n+ */\n @AllArgsConstructor\n-public class ObjectPropertyChangeMatcher extends ChangeMatcher<ObjectPropertyChange> {\n+public class ObjectPropertyChangeMatcher extends ChangeMatcher<Change> {\n \n   private final String property;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwMzA5Mg==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r496303092", "bodyText": "When we get checkstyle upgraded to 8.3x, type javadocs will I think become required again. Probably best to try and add them proactively so we don't have to do as much to migrate.\nBeyond checkstyle, a javadoc here with some example usages I think would be really helpful. Some sample code on how to use this would make it really easy if someone were want to pick this up, they could copy/paste it and modify it to fit their needs.", "author": "DanVanAtta", "createdAt": "2020-09-29T00:12:55Z", "path": "game-core/src/test/java/games/strategy/engine/data/CompositeChangeMatcher.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package games.strategy.engine.data;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+\n+@AllArgsConstructor\n+public class CompositeChangeMatcher extends ChangeMatcher<CompositeChange> {", "originalCommit": "a5ffe08306e499d4e3a5788b335e1507ae27ae5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed42400061a7b4e714a3d9a6ff23790c75ba0be3", "chunk": "diff --git a/game-core/src/test/java/games/strategy/engine/data/CompositeChangeMatcher.java b/game-core/src/test/java/games/strategy/engine/data/CompositeChangeMatcher.java\nindex 975a4bc28..24958e2be 100644\n--- a/game-core/src/test/java/games/strategy/engine/data/CompositeChangeMatcher.java\n+++ b/game-core/src/test/java/games/strategy/engine/data/CompositeChangeMatcher.java\n\n@@ -6,6 +6,15 @@ import lombok.AllArgsConstructor;\n import org.hamcrest.Description;\n import org.hamcrest.Matcher;\n \n+/**\n+ * Matches all changes of a {@link CompositeChange} object\n+ *\n+ * <p>Each of the changes are matched against the requested matchers in the same order and will fail\n+ * if the changes are not the same size or in the same order.\n+ *\n+ * <p>Example usage: assertThat(change, compositeChangeContains(propertyChange(property, newValue,\n+ * oldValue)));\n+ */\n @AllArgsConstructor\n public class CompositeChangeMatcher extends ChangeMatcher<CompositeChange> {\n \n"}}, {"oid": "ed42400061a7b4e714a3d9a6ff23790c75ba0be3", "url": "https://github.com/triplea-game/triplea/commit/ed42400061a7b4e714a3d9a6ff23790c75ba0be3", "message": "Add some documentation, handle null case, use the constant", "committedDate": "2020-09-29T01:26:05Z", "type": "commit"}, {"oid": "b779405821202df2b47af8e273e113b27a6880e1", "url": "https://github.com/triplea-game/triplea/commit/b779405821202df2b47af8e273e113b27a6880e1", "message": "Add @param javadoc", "committedDate": "2020-09-29T02:22:56Z", "type": "commit"}]}