{"pr_number": 6551, "pr_title": "Initial unittests for MustFightBattle#getBattleExecutables", "pr_createdAt": "2020-05-31T22:10:35Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6551", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4OTkzNg==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r432989936", "bodyText": "The FireNavalBombardment step adds more items to the stack.  I'd like to test that the items were either added or not added but the stack is not visible for testing nor is the deque inside of the stack.\nI could either:\n\nmake the stack and its deque visible to testing\nchange the step code to use the stack that is currently passed in to each of the steps instead of the instance version of the stack\n\nI prefer the later because then I can mock it but the former has less change to the code.", "author": "trevan", "createdAt": "2020-05-31T22:14:53Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -0,0 +1,378 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.british;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n+import static games.strategy.triplea.delegate.MockDelegateBridge.newDelegateBridge;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.isA;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.RelationshipTracker;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitCollection;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.display.IDisplay;\n+import games.strategy.engine.history.DelegateHistoryWriter;\n+import games.strategy.engine.player.Player;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.IExecutable;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import junit.framework.AssertionFailedError;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.sound.ISound;\n+\n+@ExtendWith(MockitoExtension.class)\n+class MustFightBattleExecutablesTest {\n+\n+  @Mock GameData mockGameData;\n+  @Mock GameProperties mockGameProperties;\n+  @Mock BattleTracker mockBattleTracker;\n+\n+  @Mock Territory mockBattleSite;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+\n+  @Mock Unit unit1;\n+  @Mock UnitType mockUnit1Type;\n+  @Mock UnitAttachment mockUnit1Attachment;\n+\n+  @Mock Unit unit2;\n+  @Mock UnitType mockUnit2Type;\n+  @Mock UnitAttachment mockUnit2Attachment;\n+\n+  enum BattleTerrain {\n+    WATER,\n+    LAND\n+  }\n+\n+  private MustFightBattle newBattle(final BattleTerrain terrain) {\n+    when(mockGameData.getProperties()).thenReturn(mockGameProperties);\n+\n+    final UnitCollection mockUnitCollection = mock(UnitCollection.class);\n+    when(mockBattleSite.getUnitCollection()).thenReturn(mockUnitCollection);\n+\n+    if (terrain == WATER) {\n+      when(mockBattleSite.isWater()).thenReturn(true);\n+      final IntegerMap<GamePlayer> players = new IntegerMap<>();\n+      players.add(defender, 1);\n+      players.add(attacker, 1);\n+      when(mockUnitCollection.getPlayerUnitCounts()).thenReturn(players);\n+      when(mockGameProperties.get(SEA_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    } else {\n+      when(mockBattleSite.getOwner()).thenReturn(defender);\n+      when(mockGameProperties.get(LAND_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    }\n+\n+    final RelationshipTracker mockRelationshipTracker = mock(RelationshipTracker.class);\n+    when(mockGameData.getRelationshipTracker()).thenReturn(mockRelationshipTracker);\n+    when(mockRelationshipTracker.isAtWar(attacker, defender)).thenReturn(true);\n+\n+    return new MustFightBattle(mockBattleSite, attacker, mockGameData, mockBattleTracker);\n+  }\n+\n+  private void assertStepIsMissing(final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    final AssertionFailedError missingClassException = assertThrows(\n+        AssertionFailedError.class,\n+        () -> getIndex(execs, stepClass),\n+        stepClass.getName() + \" should not be in the steps\"\n+    );\n+\n+    assertThat(missingClassException.toString(), containsString(\"No instance:\"));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Offensive/Defensive AA step is not added if no AA offensive/defensive units\")\n+  void aaStepsNotAdded() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertStepIsMissing(execs, MustFightBattle.FireOffensiveAaGuns.class);\n+    assertStepIsMissing(execs, MustFightBattle.FireDefensiveAaGuns.class);\n+    assertStepIsMissing(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Offensive AA step is added if has AA offensive units\")\n+  void aaOffensiveStepAdded() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(mockGameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+    when(unit1.getType()).thenReturn(mockUnit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(mockGameData);\n+    when(mockUnit1Type.getAttachment(anyString())).thenReturn(mockUnit1Attachment);\n+    when(mockUnit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(mockUnit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(mockUnit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(mockUnit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(mockUnit1Attachment.getTargetsAa(mockGameData)).thenReturn(Set.of(mockUnit2Type));\n+    when(mockUnit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(mockUnit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(mockUnit2Type.getAttachment(anyString())).thenReturn(mockUnit2Attachment);\n+\n+    battle.setUnits(\n+        List.of(unit2),\n+        List.of(unit1),\n+        List.of(),\n+        List.of(),\n+        defender,\n+        List.of()\n+    );\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class), is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireOffensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class), is(1));\n+\n+    assertStepIsMissing(execs, MustFightBattle.FireDefensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Defensive AA step is added if has AA defensive units\")\n+  void aaDefensiveStepAdded() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(mockGameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+    when(unit2.getType()).thenReturn(mockUnit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(mockGameData);\n+    when(mockUnit2Type.getAttachment(anyString())).thenReturn(mockUnit2Attachment);\n+    when(mockUnit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(mockUnit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(mockUnit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(mockUnit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(mockUnit2Attachment.getTargetsAa(mockGameData)).thenReturn(Set.of(mockUnit1Type));\n+    when(mockUnit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit1.getType()).thenReturn(mockUnit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(mockUnit1Type.getAttachment(anyString())).thenReturn(mockUnit1Attachment);\n+\n+    battle.setUnits(\n+        List.of(unit2),\n+        List.of(unit1),\n+        List.of(),\n+        List.of(),\n+        defender,\n+        List.of()\n+    );\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class), is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class), is(1));\n+\n+    assertStepIsMissing(execs, MustFightBattle.FireOffensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Offensive/Defensive AA step is added if has both AA offensive and defensive units\")\n+  void aaOffensiveAndDefensiveStepAdded() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(mockGameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    // Unit1 is an AA attacker that can target Unit2\n+    when(unit1.getType()).thenReturn(mockUnit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(mockGameData);\n+    when(mockUnit1Type.getAttachment(anyString())).thenReturn(mockUnit1Attachment);\n+    when(mockUnit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(mockUnit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(mockUnit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(mockUnit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(mockUnit1Attachment.getTargetsAa(mockGameData)).thenReturn(Set.of(mockUnit2Type));\n+    when(mockUnit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    // Unit2 is an AA defender that can target Unit1\n+    when(unit2.getType()).thenReturn(mockUnit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(mockGameData);\n+    when(mockUnit2Type.getAttachment(anyString())).thenReturn(mockUnit2Attachment);\n+    when(mockUnit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(mockUnit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(mockUnit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(mockUnit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(mockUnit2Attachment.getTargetsAa(mockGameData)).thenReturn(Set.of(mockUnit1Type));\n+    when(mockUnit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    battle.setUnits(\n+        List.of(unit2),\n+        List.of(unit1),\n+        List.of(),\n+        List.of(),\n+        defender,\n+        List.of()\n+    );\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class), is(0));\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class), is(1));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireOffensiveAaGuns and FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class), is(2));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added on first round\")\n+  void bombardStepAddedOnFirstRound() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(\n+        List.of(),\n+        List.of(),\n+        List.of(),\n+        List.of(),\n+        defender,\n+        List.of()\n+    );\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireNavalBombardment should be added for first round\",\n+        getIndex(execs, MustFightBattle.FireNavalBombardment.class), is(0));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is not added on subsequent rounds\")\n+  void bombardStepNotAddedOnSubsequentRound() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(\n+        List.of(),\n+        List.of(),\n+        List.of(),\n+        List.of(),\n+        defender,\n+        List.of()\n+    );\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertStepIsMissing(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added but no bombardment happens if bombard units are empty\")\n+  void bombardStepAddedButNoBombardUnits() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(\n+        List.of(),\n+        List.of(),\n+        List.of(),\n+        List.of(),\n+        defender,\n+        List.of()\n+    );\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    doAnswer(\n+        invocation -> {\n+          final Change change = invocation.getArgument(0);\n+          mockGameData.performChange(change);\n+          return null;\n+        })\n+        .when(delegateBridge)\n+        .addChange(any());\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(mockGameData, times(1)).performChange(ChangeFactory.EMPTY_CHANGE);\n+    // TODO: Somehow get the stack and check that no new execs were added to it.", "originalCommit": "629b1d7302026695b4ab2771152fae01aee331ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5NDMzNg==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r432994336", "bodyText": "Have you considered extracting the creation of the battle stack?\nIf you had an object that is injected via constructor injection, you could mock it. Then you'd only need to test that you called the method and it would return an arbitrary list of battle execution steps. Then in turn you could test the usage of that class that creates the battle step stack and assert the stack has the right size and right contents in the right conditions.\nIt's always a bit of a code smell when you have to test via:\nwhen(...).thenReturn(...)\n\ndoVoidMethodCall(..)\n\nverify(object).someMethod(..);\n\nThe above is testing for side-effects, it can usually be re-arranged with a strategy object that returns a behavior or a value.\nIn other words, have you considered making the stack and its deque be the output of another class, a strategy class? You could then inject & mock that strategy class and then test the stack more directly.", "author": "DanVanAtta", "createdAt": "2020-05-31T23:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4OTkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5NDk1Mw==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r432994953", "bodyText": "I have thought of that.  I'm just trying to do that in pieces.  I want to first get unittests in so that as I make the changes, I don't break something accidentally.", "author": "trevan", "createdAt": "2020-05-31T23:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4OTkzNg=="}], "type": "inlineReview", "revised_code": {"commit": "f11ec5a4da6b2f5fda06e5e81356447935aa83ea", "chunk": "diff --git a/game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java b/game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java\nindex 2b7e781dd..691e9b8dd 100644\n--- a/game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java\n+++ b/game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java\n\n@@ -1,21 +1,30 @@\n package games.strategy.triplea.delegate.battle;\n \n import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.engine.data.Unit.SUBMERGED;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.IGNORE_TRANSPORT_IN_MOVEMENT;\n import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.RETREATING_UNITS_REMAIN_IN_PLACE;\n import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n-import static games.strategy.triplea.delegate.GameDataTestUtil.british;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.Constants.WW2V3;\n import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n-import static games.strategy.triplea.delegate.MockDelegateBridge.newDelegateBridge;\n import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n import static org.hamcrest.Matchers.is;\n-import static org.hamcrest.Matchers.isA;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.mock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5MDEyNA==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r432990124", "bodyText": "I tried using MockDelegateBridge#newDelegateBridge but the strict stubbing check in Mockito makes it not usable.  Mockito complains if a stub was added that wasn't used and newDelegateBridge adds a lot of stubs that these individual tests don't use.\nI could make turn on the lenient mode but I worry about those repercussions.  Ideas on how to simplify the mock setups?", "author": "trevan", "createdAt": "2020-05-31T22:17:27Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -0,0 +1,378 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.british;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n+import static games.strategy.triplea.delegate.MockDelegateBridge.newDelegateBridge;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.isA;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.RelationshipTracker;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitCollection;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.display.IDisplay;\n+import games.strategy.engine.history.DelegateHistoryWriter;\n+import games.strategy.engine.player.Player;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.IExecutable;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import junit.framework.AssertionFailedError;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.sound.ISound;\n+\n+@ExtendWith(MockitoExtension.class)\n+class MustFightBattleExecutablesTest {\n+\n+  @Mock GameData mockGameData;\n+  @Mock GameProperties mockGameProperties;\n+  @Mock BattleTracker mockBattleTracker;\n+\n+  @Mock Territory mockBattleSite;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+\n+  @Mock Unit unit1;\n+  @Mock UnitType mockUnit1Type;\n+  @Mock UnitAttachment mockUnit1Attachment;\n+\n+  @Mock Unit unit2;\n+  @Mock UnitType mockUnit2Type;\n+  @Mock UnitAttachment mockUnit2Attachment;\n+\n+  enum BattleTerrain {\n+    WATER,\n+    LAND\n+  }\n+\n+  private MustFightBattle newBattle(final BattleTerrain terrain) {\n+    when(mockGameData.getProperties()).thenReturn(mockGameProperties);\n+\n+    final UnitCollection mockUnitCollection = mock(UnitCollection.class);\n+    when(mockBattleSite.getUnitCollection()).thenReturn(mockUnitCollection);\n+\n+    if (terrain == WATER) {\n+      when(mockBattleSite.isWater()).thenReturn(true);\n+      final IntegerMap<GamePlayer> players = new IntegerMap<>();\n+      players.add(defender, 1);\n+      players.add(attacker, 1);\n+      when(mockUnitCollection.getPlayerUnitCounts()).thenReturn(players);\n+      when(mockGameProperties.get(SEA_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    } else {\n+      when(mockBattleSite.getOwner()).thenReturn(defender);\n+      when(mockGameProperties.get(LAND_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    }\n+\n+    final RelationshipTracker mockRelationshipTracker = mock(RelationshipTracker.class);\n+    when(mockGameData.getRelationshipTracker()).thenReturn(mockRelationshipTracker);\n+    when(mockRelationshipTracker.isAtWar(attacker, defender)).thenReturn(true);\n+\n+    return new MustFightBattle(mockBattleSite, attacker, mockGameData, mockBattleTracker);\n+  }\n+\n+  private void assertStepIsMissing(final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    final AssertionFailedError missingClassException = assertThrows(\n+        AssertionFailedError.class,\n+        () -> getIndex(execs, stepClass),\n+        stepClass.getName() + \" should not be in the steps\"\n+    );\n+\n+    assertThat(missingClassException.toString(), containsString(\"No instance:\"));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Offensive/Defensive AA step is not added if no AA offensive/defensive units\")\n+  void aaStepsNotAdded() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertStepIsMissing(execs, MustFightBattle.FireOffensiveAaGuns.class);\n+    assertStepIsMissing(execs, MustFightBattle.FireDefensiveAaGuns.class);\n+    assertStepIsMissing(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Offensive AA step is added if has AA offensive units\")\n+  void aaOffensiveStepAdded() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(mockGameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+    when(unit1.getType()).thenReturn(mockUnit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(mockGameData);\n+    when(mockUnit1Type.getAttachment(anyString())).thenReturn(mockUnit1Attachment);\n+    when(mockUnit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(mockUnit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(mockUnit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(mockUnit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(mockUnit1Attachment.getTargetsAa(mockGameData)).thenReturn(Set.of(mockUnit2Type));\n+    when(mockUnit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(mockUnit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(mockUnit2Type.getAttachment(anyString())).thenReturn(mockUnit2Attachment);\n+\n+    battle.setUnits(\n+        List.of(unit2),\n+        List.of(unit1),\n+        List.of(),\n+        List.of(),\n+        defender,\n+        List.of()\n+    );\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class), is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireOffensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class), is(1));\n+\n+    assertStepIsMissing(execs, MustFightBattle.FireDefensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Defensive AA step is added if has AA defensive units\")\n+  void aaDefensiveStepAdded() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(mockGameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+    when(unit2.getType()).thenReturn(mockUnit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(mockGameData);\n+    when(mockUnit2Type.getAttachment(anyString())).thenReturn(mockUnit2Attachment);\n+    when(mockUnit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(mockUnit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(mockUnit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(mockUnit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(mockUnit2Attachment.getTargetsAa(mockGameData)).thenReturn(Set.of(mockUnit1Type));\n+    when(mockUnit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit1.getType()).thenReturn(mockUnit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(mockUnit1Type.getAttachment(anyString())).thenReturn(mockUnit1Attachment);\n+\n+    battle.setUnits(\n+        List.of(unit2),\n+        List.of(unit1),\n+        List.of(),\n+        List.of(),\n+        defender,\n+        List.of()\n+    );\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class), is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class), is(1));\n+\n+    assertStepIsMissing(execs, MustFightBattle.FireOffensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Offensive/Defensive AA step is added if has both AA offensive and defensive units\")\n+  void aaOffensiveAndDefensiveStepAdded() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(mockGameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    // Unit1 is an AA attacker that can target Unit2\n+    when(unit1.getType()).thenReturn(mockUnit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(mockGameData);\n+    when(mockUnit1Type.getAttachment(anyString())).thenReturn(mockUnit1Attachment);\n+    when(mockUnit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(mockUnit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(mockUnit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(mockUnit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(mockUnit1Attachment.getTargetsAa(mockGameData)).thenReturn(Set.of(mockUnit2Type));\n+    when(mockUnit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    // Unit2 is an AA defender that can target Unit1\n+    when(unit2.getType()).thenReturn(mockUnit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(mockGameData);\n+    when(mockUnit2Type.getAttachment(anyString())).thenReturn(mockUnit2Attachment);\n+    when(mockUnit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(mockUnit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(mockUnit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(mockUnit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(mockUnit2Attachment.getTargetsAa(mockGameData)).thenReturn(Set.of(mockUnit1Type));\n+    when(mockUnit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    battle.setUnits(\n+        List.of(unit2),\n+        List.of(unit1),\n+        List.of(),\n+        List.of(),\n+        defender,\n+        List.of()\n+    );\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class), is(0));\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class), is(1));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireOffensiveAaGuns and FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class), is(2));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added on first round\")\n+  void bombardStepAddedOnFirstRound() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(\n+        List.of(),\n+        List.of(),\n+        List.of(),\n+        List.of(),\n+        defender,\n+        List.of()\n+    );\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireNavalBombardment should be added for first round\",\n+        getIndex(execs, MustFightBattle.FireNavalBombardment.class), is(0));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is not added on subsequent rounds\")\n+  void bombardStepNotAddedOnSubsequentRound() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(\n+        List.of(),\n+        List.of(),\n+        List.of(),\n+        List.of(),\n+        defender,\n+        List.of()\n+    );\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertStepIsMissing(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added but no bombardment happens if bombard units are empty\")\n+  void bombardStepAddedButNoBombardUnits() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(\n+        List.of(),\n+        List.of(),\n+        List.of(),\n+        List.of(),\n+        defender,\n+        List.of()\n+    );\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    doAnswer(\n+        invocation -> {\n+          final Change change = invocation.getArgument(0);\n+          mockGameData.performChange(change);\n+          return null;\n+        })\n+        .when(delegateBridge)\n+        .addChange(any());\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(mockGameData, times(1)).performChange(ChangeFactory.EMPTY_CHANGE);\n+    // TODO: Somehow get the stack and check that no new execs were added to it.\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added and bombardment happens if bombard units exist\")\n+  void bombardStepAddedAndBombardHappens() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    when(unit1.getType()).thenReturn(mockUnit1Type);\n+    when(unit1.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit1).getPropertyOrThrow(ALREADY_MOVED);\n+    when(mockUnit1Type.getAttachment(anyString())).thenReturn(mockUnit1Attachment);\n+\n+    when(unit2.getType()).thenReturn(mockUnit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(mockUnit2Type.getAttachment(anyString())).thenReturn(mockUnit2Attachment);\n+\n+    battle.setUnits(\n+        List.of(unit2),\n+        List.of(),\n+        List.of(unit1),\n+        List.of(),\n+        defender,\n+        List.of()\n+    );\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);", "originalCommit": "629b1d7302026695b4ab2771152fae01aee331ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5NjYzMg==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r432996632", "bodyText": "I think in part the issue is with the code that is being tested. It is doing too much, nearly everything, so we are left stubbing too many items and testing via verify and asserting side effects.\nAn approach to explore, extract functionality from a top level into strategy objects. The strategy objects are then ideally nearly functional and require very few mocks to tests. The high level then contains most of the control-flow logic, easily mocked, and you mainly just need to assert interactions between objects at that level.\nFor example, if another object, a strategy object, were to compute the bombard steps, then you would not need to test for it here as that computation would be mocked. You'd only need to test that the mock object is invoked in the right conditions.", "author": "DanVanAtta", "createdAt": "2020-05-31T23:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5MDEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5NzMxNw==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r432997317", "bodyText": "So would you say it is fine to go with the current approach (complex mock setups) to ensure everything is tested?  And then as the code is reconstructed with helper functions, classes, etc, the mocks can get simplified.  I'd be fine with doing that.\nI don't want to try and extract the functionality at this point because it is scattered all over the place.", "author": "trevan", "createdAt": "2020-05-31T23:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5MDEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NzM3MA==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436297370", "bodyText": "It's a chicken-and-egg problem. The code was not written with tests in mind, it is hardly testable, to make it testable, it needs to be re-written, to re-write it - it needs tests first.\nA technique for working with this kind of code is to apply high level characterization and integration tests to test large modules. Re-write the inner ones carefully piece by piece and add unit tests to them. Combine with some manual testing and rinse-wash-repeat until it's all well decomposed. That can be a difficult process as the original code can have cyclical dependencies, poor modularity (or no modularity at all), etc..", "author": "DanVanAtta", "createdAt": "2020-06-06T20:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5MDEyNA=="}], "type": "inlineReview", "revised_code": {"commit": "f11ec5a4da6b2f5fda06e5e81356447935aa83ea", "chunk": "diff --git a/game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java b/game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java\nindex 2b7e781dd..691e9b8dd 100644\n--- a/game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java\n+++ b/game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java\n\n@@ -1,21 +1,30 @@\n package games.strategy.triplea.delegate.battle;\n \n import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.engine.data.Unit.SUBMERGED;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.IGNORE_TRANSPORT_IN_MOVEMENT;\n import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.RETREATING_UNITS_REMAIN_IN_PLACE;\n import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n-import static games.strategy.triplea.delegate.GameDataTestUtil.british;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.Constants.WW2V3;\n import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n-import static games.strategy.triplea.delegate.MockDelegateBridge.newDelegateBridge;\n import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n import static org.hamcrest.Matchers.is;\n-import static org.hamcrest.Matchers.isA;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.mock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5Mzc1Mw==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r432993753", "bodyText": "Marker interfaces/classes are usually an anti-pattern. Are each of these steps associated with a specific battle step string?\nIt seems like this is perhaps more fitting to an enum. EG:\n@AllArgsConstructor\nenum BattleStepPhase {\n  FIRE_OFFENSIVE_AA_GUNS(\"Fire Offensive AA\"),\n  :\n  :\n  ;\n\n  @Getter\n  private final String label;\n}\n\nAt that point the battle step list can become a list of BattleStepPhase and then just convert it to a list of strings at time of display, eg:\n  battleStepPhases.stream()\n     .map(BattleStepPhase::getLabel)\n     .collect(Collectors.toList());\n\nWith a list of BattleStepPhase, you can query that the list has the expected enum element.\nTo tie it in with the executable, a helper object probably would be needed and you would have a list of those instead. EG:\n@Value\n@Builder\nclass BattleStep {\n   BattleStepPhase battleStepPhase;\n   Runnable executable;\n}\n\nThen you'd have List<BattleStep>, and you could query which battle phase it is, get the label from that, and have a reference to the actions to be run. WDYT?", "author": "DanVanAtta", "createdAt": "2020-05-31T23:07:41Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -69,6 +69,256 @@\n     PARTIAL_AMPHIB\n   }\n \n+  /**\n+   * An action representing attacking aa guns firing during a battle.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public static abstract class FireOffensiveAaGuns implements IExecutable {", "originalCommit": "629b1d7302026695b4ab2771152fae01aee331ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5NTI5Ng==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r432995296", "bodyText": "This is basically what I have in mind.  But you keep saying do small PRs :)\nIt isn't quite an enum.  The order of steps is dynamic depending on the units and depending on the state of the battle.  And a \"step\" can have zero or more \"step strings\".  Also a \"step string\" might be shown but the \"step\" actually won't run because of changes to the units during the course of the battle.\nThis PR is just go get started with unittests in the code base and to work out any issues around those unittests.  I don't want to make any structural changes at this point for fear of breaking something without realizing it.", "author": "trevan", "createdAt": "2020-05-31T23:28:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5Mzc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NzY4Mg==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436297682", "bodyText": "Understood, there is a trade-off.\nThese classes being present only for tests is not ideal:\n  public abstract static class AttackerRetreatPlanes implements IExecutable {\n    private static final long serialVersionUID = 6828071620685651390L;\n  }\n\nI can understand that being an intermediary step for lack of better solutions without going into deeper changes. I wonder though if the unit tests are going to be re-written just as well if you break up the code. If when re-writing the prod code you also have to re-write the tests, then it's still a re-write nonetheless. Unit tests written after-the-fact can suffer from verifying (or testing) that a bug exists! IE: the code could be incorrect, and there can be a test that asserts the code functions as-is, bugs included.\nIf you break up the battle steps to their own classes, they will lose that abstract class and then the test will break because it's asserting for the wrong abstract class.", "author": "DanVanAtta", "createdAt": "2020-06-06T20:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5Mzc1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "8928184c172cbdb4f31b072428fbec274cb7988d", "chunk": "diff --git a/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java b/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\nindex 4348f1cdc..87ab1e4ce 100644\n--- a/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n+++ b/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n\n@@ -75,7 +78,7 @@ public class MustFightBattle extends DependentBattle implements BattleStepString\n    * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n    * action of this type.\n    */\n-  public static abstract class FireOffensiveAaGuns implements IExecutable {\n+  public abstract static class FireOffensiveAaGuns implements IExecutable {\n     private static final long serialVersionUID = 7266708569436973099L;\n   }\n \n"}}, {"oid": "8928184c172cbdb4f31b072428fbec274cb7988d", "url": "https://github.com/triplea-game/triplea/commit/8928184c172cbdb4f31b072428fbec274cb7988d", "message": "Give all MustFightBattle's steps a unique class for testing\n\nAdd some initial tests to show the classes being used", "committedDate": "2020-06-01T19:20:50Z", "type": "commit"}, {"oid": "4247826e52451342a11368f446da29f8a17b4322", "url": "https://github.com/triplea-game/triplea/commit/4247826e52451342a11368f446da29f8a17b4322", "message": "Rework the mocks in BattleStepsTest for sharing with MustFightBattleExecutablesTest", "committedDate": "2020-06-01T19:20:50Z", "type": "commit"}, {"oid": "f11ec5a4da6b2f5fda06e5e81356447935aa83ea", "url": "https://github.com/triplea-game/triplea/commit/f11ec5a4da6b2f5fda06e5e81356447935aa83ea", "message": "More unittests", "committedDate": "2020-06-01T19:20:50Z", "type": "commit"}, {"oid": "ec6e8d086aa2939158f38c3f3d9f386057aa083e", "url": "https://github.com/triplea-game/triplea/commit/ec6e8d086aa2939158f38c3f3d9f386057aa083e", "message": "Reorder tests to make BattleSteps", "committedDate": "2020-06-02T01:41:57Z", "type": "commit"}, {"oid": "fbdaaceb6bfb04c77fa497528a0005de2eb0e945", "url": "https://github.com/triplea-game/triplea/commit/fbdaaceb6bfb04c77fa497528a0005de2eb0e945", "message": "Group similar tests in BattleStepsTest and make helper functions public to share", "committedDate": "2020-06-03T06:31:20Z", "type": "commit"}, {"oid": "db44b2462ce32ff3581d6fc2fbdfcd44ffd40f73", "url": "https://github.com/triplea-game/triplea/commit/db44b2462ce32ff3581d6fc2fbdfcd44ffd40f73", "message": "Add submerge before battle, undefended transports, and first strike order tests", "committedDate": "2020-06-03T06:32:38Z", "type": "commit"}, {"oid": "0d3f99b81459d6eccfe91002ffc538056b708e9c", "url": "https://github.com/triplea-game/triplea/commit/0d3f99b81459d6eccfe91002ffc538056b708e9c", "message": "Test submerge vs air step", "committedDate": "2020-06-03T14:59:40Z", "type": "commit"}, {"oid": "ee30520dd938525d3f876e335a143be977f98f63", "url": "https://github.com/triplea-game/triplea/commit/ee30520dd938525d3f876e335a143be977f98f63", "message": "Fix spotless and checkstyle issues", "committedDate": "2020-06-03T20:17:31Z", "type": "commit"}, {"oid": "15747adf69786ba230d4a73b85db340ecb6351ba", "url": "https://github.com/triplea-game/triplea/commit/15747adf69786ba230d4a73b85db340ecb6351ba", "message": "Merge remote-tracking branch 'upstream/master' into step-executables-unittest", "committedDate": "2020-06-03T20:19:26Z", "type": "commit"}, {"oid": "15747adf69786ba230d4a73b85db340ecb6351ba", "url": "https://github.com/triplea-game/triplea/commit/15747adf69786ba230d4a73b85db340ecb6351ba", "message": "Merge remote-tracking branch 'upstream/master' into step-executables-unittest", "committedDate": "2020-06-03T20:19:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzMDUyOQ==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r434830529", "bodyText": "TODO found", "author": "codeclimate", "createdAt": "2020-06-03T20:20:59Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1127,6 +1379,8 @@ private void fireNavalBombardment(final IDelegateBridge bridge) {\n                 attacker, battleSite, gameData));\n     // bombarding units can't move after bombarding\n     if (!headless) {\n+      // TODO: StepRefactor: Why is a change always added even if there are no units?", "originalCommit": "15747adf69786ba230d4a73b85db340ecb6351ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Nzc1OA==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436297758", "bodyText": "We've had some disucssions on TODO. I can provide links if desired. Our net conclusion is that TODOs wind up being confusing and are often never done. It's perhaps better to keep a personal backlog for such questions rather than inject them into the code where it's still only really useful for the author anyways (in which case just having a personal backlog is just-as-well).", "author": "DanVanAtta", "createdAt": "2020-06-06T20:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzMDUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Nzg4OQ==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436297889", "bodyText": "No follow-up required.", "author": "DanVanAtta", "createdAt": "2020-06-06T20:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzMDUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5OTgxNg==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436299816", "bodyText": "I had found the entry in the wiki at https://github.com/triplea-game/triplea/wiki/Java-Code-Conventions#todo-comments-attach-a-tracking-token-5249.  I used \"StepRefactor\" is my 'grep token'.", "author": "trevan", "createdAt": "2020-06-06T20:53:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzMDUyOQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "52a6b3841ac0d9f9ddb144af1b01660b635281bd", "url": "https://github.com/triplea-game/triplea/commit/52a6b3841ac0d9f9ddb144af1b01660b635281bd", "message": "Mark the test as integration as it is testing a piece that should be isolated but isn't yet", "committedDate": "2020-06-03T20:30:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MDAxMA==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436240010", "bodyText": "I marked this @Integration because I didn't want to put these tests in the original MustFightBattleTest.java file.  The checks complained about having a test class that isn't connected to a non-test class unless I put @Integration on it.  I can move the tests to the other file if this is a problem.\nOnce I've refactored steps, these tests will be moved to the individual step test file so it is just temporary.", "author": "trevan", "createdAt": "2020-06-06T05:24:59Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -0,0 +1,1671 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.IGNORE_TRANSPORT_IN_MOVEMENT;\n+import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.RETREATING_UNITS_REMAIN_IN_PLACE;\n+import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.Constants.WW2V3;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitAirTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.newUnitAndAttachment;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.RelationshipTracker;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitCollection;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.IExecutable;\n+import java.math.BigDecimal;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Set;\n+import junit.framework.AssertionFailedError;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.sound.ISound;\n+import org.triplea.test.common.Integration;\n+import org.triplea.util.Tuple;\n+\n+@ExtendWith(MockitoExtension.class)\n+@Integration", "originalCommit": "52a6b3841ac0d9f9ddb144af1b01660b635281bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5ODMzNQ==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436298335", "bodyText": "@SuppressWarnings(\"UnmatchedTest\") Should do the trick directly", "author": "DanVanAtta", "createdAt": "2020-06-06T20:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MDAxMA=="}], "type": "inlineReview", "revised_code": {"commit": "e05eee386dfee4b28a417bebd0978c6dfcdf3600", "chunk": "diff --git a/game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java b/game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java\nindex 4a7f9b140..755f510c6 100644\n--- a/game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java\n+++ b/game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java\n\n@@ -69,11 +69,10 @@ import org.mockito.Mock;\n import org.mockito.junit.jupiter.MockitoExtension;\n import org.triplea.java.collections.IntegerMap;\n import org.triplea.sound.ISound;\n-import org.triplea.test.common.Integration;\n import org.triplea.util.Tuple;\n \n @ExtendWith(MockitoExtension.class)\n-@Integration\n+@SuppressWarnings(\"UnmatchedTest\")\n class MustFightBattleExecutablesTest {\n \n   @Mock GameData gameData;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5ODA1Ng==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436298056", "bodyText": "If we later convert the battle steps to be something else, modules with injected functionality and step strings, we will need to remove these abstract classes. At the very least we will want to remove them so we avoid prod-code that is here only to support tests (a code smell).\nIs there argument for not updating IExecutable to return a step-name enum value? This way if you have a list of IExecutable, you could call a IExecutable#getStepName method and check to see if it is an expected value, eg: IExecutable.getStepName() == BattleStepName.STANDARD_ATTACKERS_FIRE.\nIf you then restructure the steps to be individual classes and then compose them together to get the full battle sequence, I suspect any unit test checking the ordering of the steps would remain intact. WDYT?", "author": "DanVanAtta", "createdAt": "2020-06-06T20:23:24Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -72,6 +72,256 @@\n     PARTIAL_AMPHIB\n   }\n \n+  /**\n+   * An action representing attacking aa guns firing during a battle.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class FireOffensiveAaGuns implements IExecutable {\n+    private static final long serialVersionUID = 7266708569436973099L;\n+  }\n+\n+  /**\n+   * An action representing defending aa guns firing during a battle.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class FireDefensiveAaGuns implements IExecutable {\n+    private static final long serialVersionUID = 2124868665883519949L;\n+  }\n+\n+  /**\n+   * An action representing clearing damaged units during the aa round.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class ClearAaWaitingToDieAndDamagedChangesInto implements IExecutable {\n+    private static final long serialVersionUID = -3223166334485741752L;\n+  }\n+\n+  /**\n+   * An action representing removing non combatants.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class RemoveNonCombatants implements IExecutable {\n+    private static final long serialVersionUID = 4463743274796560494L;\n+  }\n+\n+  /**\n+   * An action representing naval bombardment during a battle.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class FireNavalBombardment implements IExecutable {\n+    private static final long serialVersionUID = -4807027908694648211L;\n+  }\n+\n+  /**\n+   * An action representing removing non combatants after naval bombardment.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class RemoveNonCombatantsAfterNavalBombardment implements IExecutable {\n+    private static final long serialVersionUID = -1015756641864182626L;\n+  }\n+\n+  /**\n+   * An action representing landing paratroopers.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class LandParatroopers implements IExecutable {\n+    private static final long serialVersionUID = 5936225914851941086L;\n+  }\n+\n+  /**\n+   * An action representing marking no movement left.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class MarkNoMovementLeft implements IExecutable {\n+    private static final long serialVersionUID = 1482181126769007815L;\n+  }\n+\n+  /**\n+   * An action representing attacker subs retreating before battle.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class AttackerRetreatSubsBeforeBattle implements IExecutable {\n+    private static final long serialVersionUID = 2178507532676286044L;\n+  }\n+\n+  /**\n+   * An action representing definding subs retreating before battle.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class DefenderRetreatSubsBeforeBattle implements IExecutable {\n+    private static final long serialVersionUID = -2081450648695833869L;\n+  }\n+\n+  /**\n+   * An action representing removing undefended transports.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class RemoveUndefendedTransports implements IExecutable {\n+    private static final long serialVersionUID = 1369227461759133105L;\n+  }\n+\n+  /**\n+   * An action representing submerging subs vs only air.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class SubmergeSubsVsOnlyAir implements IExecutable {\n+    private static final long serialVersionUID = -2588373599526477215L;\n+  }\n+\n+  /**\n+   * An action representing removing first strike suicide units.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class RemoveFirstStrikeSuicideUnits implements IExecutable {\n+    private static final long serialVersionUID = 994041503171919922L;\n+  }\n+\n+  /**\n+   * An action representing standard attacking fire.\n+   *\n+   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n+   * action of this type.\n+   */\n+  public abstract static class StandardAttackersFire implements IExecutable {", "originalCommit": "52a6b3841ac0d9f9ddb144af1b01660b635281bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5OTcwNw==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436299707", "bodyText": "This naming of IExecutables was there originally for the sub first strike instances.  It is used by the RevisedTest and has been around since 2009.  I was just following that mechanism.\nAs for changing IExecutables, I don't like that idea.  They are used in a lot of places (battles, movements).  A grep shows 48 new IExecutable and another 7 places that implement IExecutable (ignoring the ones in MustFightBattle).  I'd have to edit a lot of places and I only need the step names in a few of the places.  So I'd either have to come up with a bunch of names for all of the places or put a placeholder in for the places that the tests don't care about.\nI've pushed a change that deleted many of these test classes because they weren't being used for tests.  That leaves 12 of them, with two of them being around since 2009.", "author": "trevan", "createdAt": "2020-06-06T20:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5ODA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3c2cee92b016362a6954f6013e4e27656d1130cd", "chunk": "diff --git a/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java b/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\nindex d20eeb0bf..72d78aca1 100644\n--- a/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n+++ b/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n\n@@ -102,16 +102,6 @@ public class MustFightBattle extends DependentBattle implements BattleStepString\n     private static final long serialVersionUID = -3223166334485741752L;\n   }\n \n-  /**\n-   * An action representing removing non combatants.\n-   *\n-   * <p>NOTE: This type exists solely for tests to interrogate the execution stack looking for an\n-   * action of this type.\n-   */\n-  public abstract static class RemoveNonCombatants implements IExecutable {\n-    private static final long serialVersionUID = 4463743274796560494L;\n-  }\n-\n   /**\n    * An action representing naval bombardment during a battle.\n    *\n"}}, {"oid": "3c2cee92b016362a6954f6013e4e27656d1130cd", "url": "https://github.com/triplea-game/triplea/commit/3c2cee92b016362a6954f6013e4e27656d1130cd", "message": "Remove unnecessary IExecutable subclasses", "committedDate": "2020-06-06T20:43:45Z", "type": "commit"}, {"oid": "e05eee386dfee4b28a417bebd0978c6dfcdf3600", "url": "https://github.com/triplea-game/triplea/commit/e05eee386dfee4b28a417bebd0978c6dfcdf3600", "message": "Don't make it an integration test.  Just suppress the warning", "committedDate": "2020-06-06T20:47:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwMTE2Ng==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436301166", "bodyText": "nit, we use 'depth-first-method-ordering'. I'm not sure if it's always the cleanest for tests. The ordering essentially is that methods should be defined as soon after first usage as possible. IE:\n@Test\nvoid foo() {\n  helper1();\n  helper2();\n  // stuff\n}\n\nvoid helper1() { ... }\n\nvoid helper2() { ... }\n\n@Test\nvoid foo2() {\n   helper1();\n   helper2();\n  :\n  :\n}", "author": "DanVanAtta", "createdAt": "2020-06-06T21:14:47Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -0,0 +1,1670 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.IGNORE_TRANSPORT_IN_MOVEMENT;\n+import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.RETREATING_UNITS_REMAIN_IN_PLACE;\n+import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.Constants.WW2V3;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitAirTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.newUnitAndAttachment;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.RelationshipTracker;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitCollection;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.IExecutable;\n+import java.math.BigDecimal;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Set;\n+import junit.framework.AssertionFailedError;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.sound.ISound;\n+import org.triplea.util.Tuple;\n+\n+@ExtendWith(MockitoExtension.class)\n+@SuppressWarnings(\"UnmatchedTest\")\n+class MustFightBattleExecutablesTest {\n+\n+  @Mock GameData gameData;\n+  @Mock GameProperties gameProperties;\n+  @Mock BattleTracker battleTracker;\n+\n+  @Mock Territory battleSite;\n+  @Mock Territory retreatSite;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+\n+  @Mock Unit unit1;\n+  @Mock UnitType unit1Type;\n+  @Mock UnitAttachment unit1Attachment;\n+\n+  @Mock Unit unit2;\n+  @Mock UnitType unit2Type;\n+  @Mock UnitAttachment unit2Attachment;\n+\n+  enum BattleTerrain {\n+    WATER,\n+    LAND\n+  }\n+\n+  private MustFightBattle newBattle(final BattleTerrain terrain) {\n+    when(gameData.getProperties()).thenReturn(gameProperties);\n+\n+    final UnitCollection mockUnitCollection = mock(UnitCollection.class);\n+    when(battleSite.getUnitCollection()).thenReturn(mockUnitCollection);\n+\n+    if (terrain == WATER) {\n+      when(battleSite.isWater()).thenReturn(true);\n+      final IntegerMap<GamePlayer> players = new IntegerMap<>();\n+      players.add(defender, 1);\n+      players.add(attacker, 1);\n+      when(mockUnitCollection.getPlayerUnitCounts()).thenReturn(players);\n+      when(gameProperties.get(SEA_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    } else {\n+      when(battleSite.getOwner()).thenReturn(defender);\n+      when(gameProperties.get(LAND_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    }\n+\n+    final RelationshipTracker mockRelationshipTracker = mock(RelationshipTracker.class);\n+    when(gameData.getRelationshipTracker()).thenReturn(mockRelationshipTracker);\n+    lenient().when(mockRelationshipTracker.isAtWar(attacker, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, attacker)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, attacker)).thenReturn(false);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, defender)).thenReturn(false);\n+\n+    return new MustFightBattle(battleSite, attacker, gameData, battleTracker);\n+  }\n+\n+  private void assertThatStepIsMissing(", "originalCommit": "e05eee386dfee4b28a417bebd0978c6dfcdf3600", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwMTQ5Mg==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436301492", "bodyText": "We're trying to kill Tuple, please avoid it's usage. Typically we recommend to just use a value object instead. Lombok makes this pretty easy. EG:\n@Value\nclass MustFightBattleWithExecutable {\n  private MustFightBattle mustFightBattle;\n  private IExecutable executable;\n}\n\nSecond, the usage is quite hard to follow, ie:\n  givenFirstStrikeBattleSetup(true, true, true, true, true),\n\nDo you have any object to extracting the parameters to a value object?\nEG:\ngivenBattleSetup(BattleSetupParameters.builder()\n   .firstStrike(true)\n   .attackerHasDestroyer(true)\n   .defenderHasDestroyer(true)\n   .ww2v2Rules(true)\n   .build());\n\nOne nice benefit here is that any booleans that are false can be omitted and you can use the default 'false' value for them.", "author": "DanVanAtta", "createdAt": "2020-06-06T21:20:18Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -0,0 +1,1670 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.IGNORE_TRANSPORT_IN_MOVEMENT;\n+import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.RETREATING_UNITS_REMAIN_IN_PLACE;\n+import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.Constants.WW2V3;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitAirTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.newUnitAndAttachment;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.RelationshipTracker;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitCollection;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.IExecutable;\n+import java.math.BigDecimal;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Set;\n+import junit.framework.AssertionFailedError;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.sound.ISound;\n+import org.triplea.util.Tuple;\n+\n+@ExtendWith(MockitoExtension.class)\n+@SuppressWarnings(\"UnmatchedTest\")\n+class MustFightBattleExecutablesTest {\n+\n+  @Mock GameData gameData;\n+  @Mock GameProperties gameProperties;\n+  @Mock BattleTracker battleTracker;\n+\n+  @Mock Territory battleSite;\n+  @Mock Territory retreatSite;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+\n+  @Mock Unit unit1;\n+  @Mock UnitType unit1Type;\n+  @Mock UnitAttachment unit1Attachment;\n+\n+  @Mock Unit unit2;\n+  @Mock UnitType unit2Type;\n+  @Mock UnitAttachment unit2Attachment;\n+\n+  enum BattleTerrain {\n+    WATER,\n+    LAND\n+  }\n+\n+  private MustFightBattle newBattle(final BattleTerrain terrain) {\n+    when(gameData.getProperties()).thenReturn(gameProperties);\n+\n+    final UnitCollection mockUnitCollection = mock(UnitCollection.class);\n+    when(battleSite.getUnitCollection()).thenReturn(mockUnitCollection);\n+\n+    if (terrain == WATER) {\n+      when(battleSite.isWater()).thenReturn(true);\n+      final IntegerMap<GamePlayer> players = new IntegerMap<>();\n+      players.add(defender, 1);\n+      players.add(attacker, 1);\n+      when(mockUnitCollection.getPlayerUnitCounts()).thenReturn(players);\n+      when(gameProperties.get(SEA_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    } else {\n+      when(battleSite.getOwner()).thenReturn(defender);\n+      when(gameProperties.get(LAND_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    }\n+\n+    final RelationshipTracker mockRelationshipTracker = mock(RelationshipTracker.class);\n+    when(gameData.getRelationshipTracker()).thenReturn(mockRelationshipTracker);\n+    lenient().when(mockRelationshipTracker.isAtWar(attacker, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, attacker)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, attacker)).thenReturn(false);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, defender)).thenReturn(false);\n+\n+    return new MustFightBattle(battleSite, attacker, gameData, battleTracker);\n+  }\n+\n+  private void assertThatStepIsMissing(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    final AssertionFailedError missingClassException =\n+        assertThrows(\n+            AssertionFailedError.class,\n+            () -> getIndex(execs, stepClass),\n+            stepClass.getName() + \" should not be in the steps\");\n+\n+    assertThat(missingClassException.toString(), containsString(\"No instance:\"));\n+  }\n+\n+  private void assertThatStepExists(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    assertThat(\n+        stepClass.getName() + \" is missing from the steps\",\n+        getIndex(execs, stepClass),\n+        greaterThanOrEqualTo(0));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on first run\")\n+  void bombardOnFirstRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on subsequent run\")\n+  void bombardOnSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added but no bombardment happens if bombard units are empty\")\n+  void bombardStepAddedButNoBombardUnits() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(ChangeFactory.EMPTY_CHANGE);\n+    verify(battle, never())\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added and bombardment happens if bombard units exist\")\n+  void bombardStepAddedAndBombardHappens() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    final Unit unit1 = mock(Unit.class);\n+    when(unit1.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit1).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    final Unit unit2 = givenUnit();\n+    when(unit2.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(unit2), List.of(), List.of(unit1), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    when(delegateBridge.getSoundChannelBroadcaster()).thenReturn(mock(ISound.class));\n+    doNothing()\n+        .when(battle)\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(argThat((Change change) -> !change.isEmpty()));\n+    verify(battle).fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify paratrooper battle steps on first run\")\n+  void paratrooperStepAddedOnFirstRound() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on first run\")\n+  void paratroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of(unit1)).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with no AirTransport tech on first run\")\n+  void noAirTransportTech() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on subsequent run\")\n+  void paratroopersSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with empty paratroopers on first run\")\n+  void emptyParatroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of()).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive Aa\")\n+  void offensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireOffensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireDefensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with defensive Aa\")\n+  void defensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireOffensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive and defensive Aa\")\n+  void offensiveAndDefensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    // Unit1 is an AA attacker that can target Unit2\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    // Unit2 is an AA defender that can target Unit1\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the second step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(1));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after \"\n+            + \"FireOffensiveAaGuns and FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(2));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void attackingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void attackingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(List.of(destroyer), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void attackingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"but has defenseless transports\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndDefenselessTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit transport = givenUnitTransport();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has defenseless transports that are not restricted\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndUnRestrTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    // it won't even check if the unit is a transport\n+    final Unit transport = givenUnit();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has no defenseless transports\")\n+  void attackingSubsCanRetreatIfBeforeBattleAndSubmersibleAndRetreatAndNoDefenselessTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify attacking canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void attackerSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void attackingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify attacking firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void attackingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(RETREATING_UNITS_REMAIN_IN_PLACE, false)).thenReturn(false);\n+    when(gameProperties.get(IGNORE_TRANSPORT_IN_MOVEMENT, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V3, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void defendingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void defendingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit canEvadeUnit = givenUnit();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(\n+        List.of(canEvadeUnit), List.of(destroyer), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void defendingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify defending canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void defenderSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void defendingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify defending firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void defendingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are removed if TRANSPORT_CASUALTIES_RESTRICTED is true\")\n+  void transportsAreRemovedIfTransportCasualtiesRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are not removed if TRANSPORT_CASUALTIES_RESTRICTED is false\")\n+  void transportsAreNotRemovedIfTransportCasualtiesUnRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted attacking transports are removed if casualities are restricted\")\n+  void unescortedAttackingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(1);\n+    when(attachment2.getAttack(attacker)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has retreat territories\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButHasRetreat() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(retreatSite)).when(battle).getAttackerRetreatTerritories();\n+    // doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted defending transports are removed if casualities are restricted\")\n+  void unescortedDefendingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(defender)).thenReturn(1);\n+    when(attachment2.getAttack(defender)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit), List.of(unit2), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(true));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(defender);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getMovement(defender)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker>defender>standard\")\n+  void firstStrikeOrderAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, true, true, true, true),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.DEFENDER,\n+            FirstStrikeBattleStep.STANDARD));\n+  }\n+\n+  private Tuple<MustFightBattle, List<IExecutable>> givenFirstStrikeBattleSetup(", "originalCommit": "e05eee386dfee4b28a417bebd0978c6dfcdf3600", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwMTU4OA==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436301588", "bodyText": "Which cases invoke this lenient and which other ones do not? Is the lenient a sign that we could use multiple setup methods? I'm curious about this as lenient mocks can be a testing smell, perhaps an overly generic test scaffolding.", "author": "DanVanAtta", "createdAt": "2020-06-06T21:21:27Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -0,0 +1,1670 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.IGNORE_TRANSPORT_IN_MOVEMENT;\n+import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.RETREATING_UNITS_REMAIN_IN_PLACE;\n+import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.Constants.WW2V3;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitAirTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.newUnitAndAttachment;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.RelationshipTracker;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitCollection;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.IExecutable;\n+import java.math.BigDecimal;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Set;\n+import junit.framework.AssertionFailedError;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.sound.ISound;\n+import org.triplea.util.Tuple;\n+\n+@ExtendWith(MockitoExtension.class)\n+@SuppressWarnings(\"UnmatchedTest\")\n+class MustFightBattleExecutablesTest {\n+\n+  @Mock GameData gameData;\n+  @Mock GameProperties gameProperties;\n+  @Mock BattleTracker battleTracker;\n+\n+  @Mock Territory battleSite;\n+  @Mock Territory retreatSite;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+\n+  @Mock Unit unit1;\n+  @Mock UnitType unit1Type;\n+  @Mock UnitAttachment unit1Attachment;\n+\n+  @Mock Unit unit2;\n+  @Mock UnitType unit2Type;\n+  @Mock UnitAttachment unit2Attachment;\n+\n+  enum BattleTerrain {\n+    WATER,\n+    LAND\n+  }\n+\n+  private MustFightBattle newBattle(final BattleTerrain terrain) {\n+    when(gameData.getProperties()).thenReturn(gameProperties);\n+\n+    final UnitCollection mockUnitCollection = mock(UnitCollection.class);\n+    when(battleSite.getUnitCollection()).thenReturn(mockUnitCollection);\n+\n+    if (terrain == WATER) {\n+      when(battleSite.isWater()).thenReturn(true);\n+      final IntegerMap<GamePlayer> players = new IntegerMap<>();\n+      players.add(defender, 1);\n+      players.add(attacker, 1);\n+      when(mockUnitCollection.getPlayerUnitCounts()).thenReturn(players);\n+      when(gameProperties.get(SEA_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    } else {\n+      when(battleSite.getOwner()).thenReturn(defender);\n+      when(gameProperties.get(LAND_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    }\n+\n+    final RelationshipTracker mockRelationshipTracker = mock(RelationshipTracker.class);\n+    when(gameData.getRelationshipTracker()).thenReturn(mockRelationshipTracker);\n+    lenient().when(mockRelationshipTracker.isAtWar(attacker, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, attacker)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, attacker)).thenReturn(false);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, defender)).thenReturn(false);\n+\n+    return new MustFightBattle(battleSite, attacker, gameData, battleTracker);\n+  }\n+\n+  private void assertThatStepIsMissing(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    final AssertionFailedError missingClassException =\n+        assertThrows(\n+            AssertionFailedError.class,\n+            () -> getIndex(execs, stepClass),\n+            stepClass.getName() + \" should not be in the steps\");\n+\n+    assertThat(missingClassException.toString(), containsString(\"No instance:\"));\n+  }\n+\n+  private void assertThatStepExists(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    assertThat(\n+        stepClass.getName() + \" is missing from the steps\",\n+        getIndex(execs, stepClass),\n+        greaterThanOrEqualTo(0));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on first run\")\n+  void bombardOnFirstRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on subsequent run\")\n+  void bombardOnSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added but no bombardment happens if bombard units are empty\")\n+  void bombardStepAddedButNoBombardUnits() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(ChangeFactory.EMPTY_CHANGE);\n+    verify(battle, never())\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added and bombardment happens if bombard units exist\")\n+  void bombardStepAddedAndBombardHappens() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    final Unit unit1 = mock(Unit.class);\n+    when(unit1.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit1).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    final Unit unit2 = givenUnit();\n+    when(unit2.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(unit2), List.of(), List.of(unit1), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    when(delegateBridge.getSoundChannelBroadcaster()).thenReturn(mock(ISound.class));\n+    doNothing()\n+        .when(battle)\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(argThat((Change change) -> !change.isEmpty()));\n+    verify(battle).fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify paratrooper battle steps on first run\")\n+  void paratrooperStepAddedOnFirstRound() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on first run\")\n+  void paratroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of(unit1)).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with no AirTransport tech on first run\")\n+  void noAirTransportTech() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on subsequent run\")\n+  void paratroopersSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with empty paratroopers on first run\")\n+  void emptyParatroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of()).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive Aa\")\n+  void offensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireOffensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireDefensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with defensive Aa\")\n+  void defensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireOffensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive and defensive Aa\")\n+  void offensiveAndDefensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    // Unit1 is an AA attacker that can target Unit2\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    // Unit2 is an AA defender that can target Unit1\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the second step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(1));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after \"\n+            + \"FireOffensiveAaGuns and FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(2));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void attackingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void attackingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(List.of(destroyer), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void attackingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"but has defenseless transports\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndDefenselessTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit transport = givenUnitTransport();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has defenseless transports that are not restricted\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndUnRestrTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    // it won't even check if the unit is a transport\n+    final Unit transport = givenUnit();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has no defenseless transports\")\n+  void attackingSubsCanRetreatIfBeforeBattleAndSubmersibleAndRetreatAndNoDefenselessTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify attacking canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void attackerSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void attackingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify attacking firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void attackingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(RETREATING_UNITS_REMAIN_IN_PLACE, false)).thenReturn(false);\n+    when(gameProperties.get(IGNORE_TRANSPORT_IN_MOVEMENT, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V3, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void defendingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void defendingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit canEvadeUnit = givenUnit();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(\n+        List.of(canEvadeUnit), List.of(destroyer), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void defendingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify defending canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void defenderSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void defendingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify defending firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void defendingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are removed if TRANSPORT_CASUALTIES_RESTRICTED is true\")\n+  void transportsAreRemovedIfTransportCasualtiesRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are not removed if TRANSPORT_CASUALTIES_RESTRICTED is false\")\n+  void transportsAreNotRemovedIfTransportCasualtiesUnRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted attacking transports are removed if casualities are restricted\")\n+  void unescortedAttackingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(1);\n+    when(attachment2.getAttack(attacker)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has retreat territories\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButHasRetreat() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(retreatSite)).when(battle).getAttackerRetreatTerritories();\n+    // doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted defending transports are removed if casualities are restricted\")\n+  void unescortedDefendingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(defender)).thenReturn(1);\n+    when(attachment2.getAttack(defender)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit), List.of(unit2), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(true));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(defender);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getMovement(defender)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker>defender>standard\")\n+  void firstStrikeOrderAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, true, true, true, true),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.DEFENDER,\n+            FirstStrikeBattleStep.STANDARD));\n+  }\n+\n+  private Tuple<MustFightBattle, List<IExecutable>> givenFirstStrikeBattleSetup(\n+      final boolean attackerDestroyer,\n+      final boolean defenderDestroyer,\n+      final boolean ww2v2,\n+      final boolean defendingSubsSneakAttack,\n+      final boolean ignoreDefendingSubsSneakAttack) {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    lenient().doNothing().when(battle).firstStrikeAttackersFire(any());", "originalCommit": "e05eee386dfee4b28a417bebd0978c6dfcdf3600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwODI4OA==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436308288", "bodyText": "The cases where attacker == true in assertThatFirstStrikeReturnFireIs will call the firstStrikeAttackersFire and when attacker == false it will call firstStrikeDefendersFire", "author": "trevan", "createdAt": "2020-06-06T23:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwMTU4OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwMTY0Ng==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436301646", "bodyText": "The IExecutable comes from a battle, do we really need the tuple? Could we just get the second value by calling battle.getBattleExecutables(true) directly?", "author": "DanVanAtta", "createdAt": "2020-06-06T21:22:19Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -0,0 +1,1670 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.IGNORE_TRANSPORT_IN_MOVEMENT;\n+import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.RETREATING_UNITS_REMAIN_IN_PLACE;\n+import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.Constants.WW2V3;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitAirTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.newUnitAndAttachment;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.RelationshipTracker;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitCollection;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.IExecutable;\n+import java.math.BigDecimal;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Set;\n+import junit.framework.AssertionFailedError;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.sound.ISound;\n+import org.triplea.util.Tuple;\n+\n+@ExtendWith(MockitoExtension.class)\n+@SuppressWarnings(\"UnmatchedTest\")\n+class MustFightBattleExecutablesTest {\n+\n+  @Mock GameData gameData;\n+  @Mock GameProperties gameProperties;\n+  @Mock BattleTracker battleTracker;\n+\n+  @Mock Territory battleSite;\n+  @Mock Territory retreatSite;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+\n+  @Mock Unit unit1;\n+  @Mock UnitType unit1Type;\n+  @Mock UnitAttachment unit1Attachment;\n+\n+  @Mock Unit unit2;\n+  @Mock UnitType unit2Type;\n+  @Mock UnitAttachment unit2Attachment;\n+\n+  enum BattleTerrain {\n+    WATER,\n+    LAND\n+  }\n+\n+  private MustFightBattle newBattle(final BattleTerrain terrain) {\n+    when(gameData.getProperties()).thenReturn(gameProperties);\n+\n+    final UnitCollection mockUnitCollection = mock(UnitCollection.class);\n+    when(battleSite.getUnitCollection()).thenReturn(mockUnitCollection);\n+\n+    if (terrain == WATER) {\n+      when(battleSite.isWater()).thenReturn(true);\n+      final IntegerMap<GamePlayer> players = new IntegerMap<>();\n+      players.add(defender, 1);\n+      players.add(attacker, 1);\n+      when(mockUnitCollection.getPlayerUnitCounts()).thenReturn(players);\n+      when(gameProperties.get(SEA_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    } else {\n+      when(battleSite.getOwner()).thenReturn(defender);\n+      when(gameProperties.get(LAND_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    }\n+\n+    final RelationshipTracker mockRelationshipTracker = mock(RelationshipTracker.class);\n+    when(gameData.getRelationshipTracker()).thenReturn(mockRelationshipTracker);\n+    lenient().when(mockRelationshipTracker.isAtWar(attacker, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, attacker)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, attacker)).thenReturn(false);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, defender)).thenReturn(false);\n+\n+    return new MustFightBattle(battleSite, attacker, gameData, battleTracker);\n+  }\n+\n+  private void assertThatStepIsMissing(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    final AssertionFailedError missingClassException =\n+        assertThrows(\n+            AssertionFailedError.class,\n+            () -> getIndex(execs, stepClass),\n+            stepClass.getName() + \" should not be in the steps\");\n+\n+    assertThat(missingClassException.toString(), containsString(\"No instance:\"));\n+  }\n+\n+  private void assertThatStepExists(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    assertThat(\n+        stepClass.getName() + \" is missing from the steps\",\n+        getIndex(execs, stepClass),\n+        greaterThanOrEqualTo(0));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on first run\")\n+  void bombardOnFirstRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on subsequent run\")\n+  void bombardOnSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added but no bombardment happens if bombard units are empty\")\n+  void bombardStepAddedButNoBombardUnits() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(ChangeFactory.EMPTY_CHANGE);\n+    verify(battle, never())\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added and bombardment happens if bombard units exist\")\n+  void bombardStepAddedAndBombardHappens() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    final Unit unit1 = mock(Unit.class);\n+    when(unit1.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit1).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    final Unit unit2 = givenUnit();\n+    when(unit2.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(unit2), List.of(), List.of(unit1), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    when(delegateBridge.getSoundChannelBroadcaster()).thenReturn(mock(ISound.class));\n+    doNothing()\n+        .when(battle)\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(argThat((Change change) -> !change.isEmpty()));\n+    verify(battle).fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify paratrooper battle steps on first run\")\n+  void paratrooperStepAddedOnFirstRound() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on first run\")\n+  void paratroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of(unit1)).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with no AirTransport tech on first run\")\n+  void noAirTransportTech() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on subsequent run\")\n+  void paratroopersSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with empty paratroopers on first run\")\n+  void emptyParatroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of()).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive Aa\")\n+  void offensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireOffensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireDefensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with defensive Aa\")\n+  void defensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireOffensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive and defensive Aa\")\n+  void offensiveAndDefensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    // Unit1 is an AA attacker that can target Unit2\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    // Unit2 is an AA defender that can target Unit1\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the second step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(1));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after \"\n+            + \"FireOffensiveAaGuns and FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(2));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void attackingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void attackingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(List.of(destroyer), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void attackingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"but has defenseless transports\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndDefenselessTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit transport = givenUnitTransport();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has defenseless transports that are not restricted\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndUnRestrTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    // it won't even check if the unit is a transport\n+    final Unit transport = givenUnit();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has no defenseless transports\")\n+  void attackingSubsCanRetreatIfBeforeBattleAndSubmersibleAndRetreatAndNoDefenselessTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify attacking canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void attackerSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void attackingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify attacking firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void attackingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(RETREATING_UNITS_REMAIN_IN_PLACE, false)).thenReturn(false);\n+    when(gameProperties.get(IGNORE_TRANSPORT_IN_MOVEMENT, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V3, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void defendingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void defendingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit canEvadeUnit = givenUnit();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(\n+        List.of(canEvadeUnit), List.of(destroyer), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void defendingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify defending canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void defenderSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void defendingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify defending firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void defendingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are removed if TRANSPORT_CASUALTIES_RESTRICTED is true\")\n+  void transportsAreRemovedIfTransportCasualtiesRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are not removed if TRANSPORT_CASUALTIES_RESTRICTED is false\")\n+  void transportsAreNotRemovedIfTransportCasualtiesUnRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted attacking transports are removed if casualities are restricted\")\n+  void unescortedAttackingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(1);\n+    when(attachment2.getAttack(attacker)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has retreat territories\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButHasRetreat() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(retreatSite)).when(battle).getAttackerRetreatTerritories();\n+    // doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted defending transports are removed if casualities are restricted\")\n+  void unescortedDefendingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(defender)).thenReturn(1);\n+    when(attachment2.getAttack(defender)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit), List.of(unit2), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(true));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(defender);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getMovement(defender)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker>defender>standard\")\n+  void firstStrikeOrderAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, true, true, true, true),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.DEFENDER,\n+            FirstStrikeBattleStep.STANDARD));\n+  }\n+\n+  private Tuple<MustFightBattle, List<IExecutable>> givenFirstStrikeBattleSetup(\n+      final boolean attackerDestroyer,\n+      final boolean defenderDestroyer,\n+      final boolean ww2v2,\n+      final boolean defendingSubsSneakAttack,\n+      final boolean ignoreDefendingSubsSneakAttack) {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    lenient().doNothing().when(battle).firstStrikeAttackersFire(any());\n+    lenient().doNothing().when(battle).firstStrikeDefendersFire(any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(ww2v2);\n+    if (!ignoreDefendingSubsSneakAttack) {\n+      when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false))\n+          .thenReturn(defendingSubsSneakAttack);\n+    }\n+\n+    final Unit attackerUnit = attackerDestroyer ? givenUnitDestroyer() : givenUnit();\n+    final Unit defenderUnit = defenderDestroyer ? givenUnitDestroyer() : givenUnit();\n+\n+    battle.setUnits(\n+        List.of(defenderUnit), List.of(attackerUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);", "originalCommit": "e05eee386dfee4b28a417bebd0978c6dfcdf3600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwODE0NA==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436308144", "bodyText": "I don't remember why I had the tuple.  The tests were once a bit different so I probably had a reason and then after refactoring them, the reason disappeared but I still had the tuple legacy.  It can be simplified.", "author": "trevan", "createdAt": "2020-06-06T23:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwMTY0Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwMTcwOA==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436301708", "bodyText": "nit, something to watch for, if you can mark a method as static, please do so. Only ask for this to convey more information, static coupling is bad, while marking methods as static conveys useful information.", "author": "DanVanAtta", "createdAt": "2020-06-06T21:23:18Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -0,0 +1,1670 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.IGNORE_TRANSPORT_IN_MOVEMENT;\n+import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.RETREATING_UNITS_REMAIN_IN_PLACE;\n+import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.Constants.WW2V3;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitAirTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.newUnitAndAttachment;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.RelationshipTracker;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitCollection;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.IExecutable;\n+import java.math.BigDecimal;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Set;\n+import junit.framework.AssertionFailedError;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.sound.ISound;\n+import org.triplea.util.Tuple;\n+\n+@ExtendWith(MockitoExtension.class)\n+@SuppressWarnings(\"UnmatchedTest\")\n+class MustFightBattleExecutablesTest {\n+\n+  @Mock GameData gameData;\n+  @Mock GameProperties gameProperties;\n+  @Mock BattleTracker battleTracker;\n+\n+  @Mock Territory battleSite;\n+  @Mock Territory retreatSite;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+\n+  @Mock Unit unit1;\n+  @Mock UnitType unit1Type;\n+  @Mock UnitAttachment unit1Attachment;\n+\n+  @Mock Unit unit2;\n+  @Mock UnitType unit2Type;\n+  @Mock UnitAttachment unit2Attachment;\n+\n+  enum BattleTerrain {\n+    WATER,\n+    LAND\n+  }\n+\n+  private MustFightBattle newBattle(final BattleTerrain terrain) {\n+    when(gameData.getProperties()).thenReturn(gameProperties);\n+\n+    final UnitCollection mockUnitCollection = mock(UnitCollection.class);\n+    when(battleSite.getUnitCollection()).thenReturn(mockUnitCollection);\n+\n+    if (terrain == WATER) {\n+      when(battleSite.isWater()).thenReturn(true);\n+      final IntegerMap<GamePlayer> players = new IntegerMap<>();\n+      players.add(defender, 1);\n+      players.add(attacker, 1);\n+      when(mockUnitCollection.getPlayerUnitCounts()).thenReturn(players);\n+      when(gameProperties.get(SEA_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    } else {\n+      when(battleSite.getOwner()).thenReturn(defender);\n+      when(gameProperties.get(LAND_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    }\n+\n+    final RelationshipTracker mockRelationshipTracker = mock(RelationshipTracker.class);\n+    when(gameData.getRelationshipTracker()).thenReturn(mockRelationshipTracker);\n+    lenient().when(mockRelationshipTracker.isAtWar(attacker, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, attacker)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, attacker)).thenReturn(false);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, defender)).thenReturn(false);\n+\n+    return new MustFightBattle(battleSite, attacker, gameData, battleTracker);\n+  }\n+\n+  private void assertThatStepIsMissing(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    final AssertionFailedError missingClassException =\n+        assertThrows(\n+            AssertionFailedError.class,\n+            () -> getIndex(execs, stepClass),\n+            stepClass.getName() + \" should not be in the steps\");\n+\n+    assertThat(missingClassException.toString(), containsString(\"No instance:\"));\n+  }\n+\n+  private void assertThatStepExists(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    assertThat(\n+        stepClass.getName() + \" is missing from the steps\",\n+        getIndex(execs, stepClass),\n+        greaterThanOrEqualTo(0));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on first run\")\n+  void bombardOnFirstRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on subsequent run\")\n+  void bombardOnSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added but no bombardment happens if bombard units are empty\")\n+  void bombardStepAddedButNoBombardUnits() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(ChangeFactory.EMPTY_CHANGE);\n+    verify(battle, never())\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added and bombardment happens if bombard units exist\")\n+  void bombardStepAddedAndBombardHappens() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    final Unit unit1 = mock(Unit.class);\n+    when(unit1.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit1).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    final Unit unit2 = givenUnit();\n+    when(unit2.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(unit2), List.of(), List.of(unit1), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    when(delegateBridge.getSoundChannelBroadcaster()).thenReturn(mock(ISound.class));\n+    doNothing()\n+        .when(battle)\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(argThat((Change change) -> !change.isEmpty()));\n+    verify(battle).fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify paratrooper battle steps on first run\")\n+  void paratrooperStepAddedOnFirstRound() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on first run\")\n+  void paratroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of(unit1)).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with no AirTransport tech on first run\")\n+  void noAirTransportTech() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on subsequent run\")\n+  void paratroopersSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with empty paratroopers on first run\")\n+  void emptyParatroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of()).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive Aa\")\n+  void offensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireOffensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireDefensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with defensive Aa\")\n+  void defensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireOffensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive and defensive Aa\")\n+  void offensiveAndDefensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    // Unit1 is an AA attacker that can target Unit2\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    // Unit2 is an AA defender that can target Unit1\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the second step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(1));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after \"\n+            + \"FireOffensiveAaGuns and FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(2));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void attackingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void attackingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(List.of(destroyer), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void attackingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"but has defenseless transports\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndDefenselessTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit transport = givenUnitTransport();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has defenseless transports that are not restricted\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndUnRestrTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    // it won't even check if the unit is a transport\n+    final Unit transport = givenUnit();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has no defenseless transports\")\n+  void attackingSubsCanRetreatIfBeforeBattleAndSubmersibleAndRetreatAndNoDefenselessTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify attacking canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void attackerSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void attackingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify attacking firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void attackingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(RETREATING_UNITS_REMAIN_IN_PLACE, false)).thenReturn(false);\n+    when(gameProperties.get(IGNORE_TRANSPORT_IN_MOVEMENT, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V3, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void defendingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void defendingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit canEvadeUnit = givenUnit();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(\n+        List.of(canEvadeUnit), List.of(destroyer), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void defendingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify defending canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void defenderSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void defendingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify defending firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void defendingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are removed if TRANSPORT_CASUALTIES_RESTRICTED is true\")\n+  void transportsAreRemovedIfTransportCasualtiesRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are not removed if TRANSPORT_CASUALTIES_RESTRICTED is false\")\n+  void transportsAreNotRemovedIfTransportCasualtiesUnRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted attacking transports are removed if casualities are restricted\")\n+  void unescortedAttackingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(1);\n+    when(attachment2.getAttack(attacker)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has retreat territories\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButHasRetreat() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(retreatSite)).when(battle).getAttackerRetreatTerritories();\n+    // doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted defending transports are removed if casualities are restricted\")\n+  void unescortedDefendingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(defender)).thenReturn(1);\n+    when(attachment2.getAttack(defender)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit), List.of(unit2), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(true));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(defender);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getMovement(defender)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker>defender>standard\")\n+  void firstStrikeOrderAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, true, true, true, true),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.DEFENDER,\n+            FirstStrikeBattleStep.STANDARD));\n+  }\n+\n+  private Tuple<MustFightBattle, List<IExecutable>> givenFirstStrikeBattleSetup(\n+      final boolean attackerDestroyer,\n+      final boolean defenderDestroyer,\n+      final boolean ww2v2,\n+      final boolean defendingSubsSneakAttack,\n+      final boolean ignoreDefendingSubsSneakAttack) {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    lenient().doNothing().when(battle).firstStrikeAttackersFire(any());\n+    lenient().doNothing().when(battle).firstStrikeDefendersFire(any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(ww2v2);\n+    if (!ignoreDefendingSubsSneakAttack) {\n+      when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false))\n+          .thenReturn(defendingSubsSneakAttack);\n+    }\n+\n+    final Unit attackerUnit = attackerDestroyer ? givenUnitDestroyer() : givenUnit();\n+    final Unit defenderUnit = defenderDestroyer ? givenUnitDestroyer() : givenUnit();\n+\n+    battle.setUnits(\n+        List.of(defenderUnit), List.of(attackerUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    return Tuple.of(battle, execs);\n+  }\n+\n+  private enum FirstStrikeBattleStep {\n+    ATTACKER,\n+    DEFENDER,\n+    STANDARD,\n+  }\n+\n+  private void assertThatFirstStrikeStepOrder(", "originalCommit": "e05eee386dfee4b28a417bebd0978c6dfcdf3600", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwMjA1Nw==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436302057", "bodyText": "A few nits here:\n\n\nThe boolean parameter is a bit hard to grok. Specifically \"is attacker = true\" is not necessarily clear until you look at the implementation in detail.\n\n\nWe are not really asserting anything in this method. I initially wondered if a matcher could replace this method, but instead we are doing a mockito verify.\n\n\nWhat do you think of renaming to \"verify\" instead of \"assert\" as the method prefix?\nI'd also suggest the boolean parameter be removed simply by creating additional methods that can be called directly to then call the underlying method, ie:\n  private void verifyAttackersFireWithFirstStrike(\n      final Tuple<MustFightBattle, List<IExecutable>> battleTuple,\n      final MustFightBattle.ReturnFire returnFire) {\n\n    verifyThatFirstStrikeReturnFireIs(battleTuple, returnFire, true);\n  }\n\nWDYT? Is there a cleaner way to get rid of the boolean parameter from the test cases?", "author": "DanVanAtta", "createdAt": "2020-06-06T21:29:22Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -0,0 +1,1670 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.IGNORE_TRANSPORT_IN_MOVEMENT;\n+import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.RETREATING_UNITS_REMAIN_IN_PLACE;\n+import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.Constants.WW2V3;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitAirTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.newUnitAndAttachment;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.RelationshipTracker;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitCollection;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.IExecutable;\n+import java.math.BigDecimal;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Set;\n+import junit.framework.AssertionFailedError;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.sound.ISound;\n+import org.triplea.util.Tuple;\n+\n+@ExtendWith(MockitoExtension.class)\n+@SuppressWarnings(\"UnmatchedTest\")\n+class MustFightBattleExecutablesTest {\n+\n+  @Mock GameData gameData;\n+  @Mock GameProperties gameProperties;\n+  @Mock BattleTracker battleTracker;\n+\n+  @Mock Territory battleSite;\n+  @Mock Territory retreatSite;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+\n+  @Mock Unit unit1;\n+  @Mock UnitType unit1Type;\n+  @Mock UnitAttachment unit1Attachment;\n+\n+  @Mock Unit unit2;\n+  @Mock UnitType unit2Type;\n+  @Mock UnitAttachment unit2Attachment;\n+\n+  enum BattleTerrain {\n+    WATER,\n+    LAND\n+  }\n+\n+  private MustFightBattle newBattle(final BattleTerrain terrain) {\n+    when(gameData.getProperties()).thenReturn(gameProperties);\n+\n+    final UnitCollection mockUnitCollection = mock(UnitCollection.class);\n+    when(battleSite.getUnitCollection()).thenReturn(mockUnitCollection);\n+\n+    if (terrain == WATER) {\n+      when(battleSite.isWater()).thenReturn(true);\n+      final IntegerMap<GamePlayer> players = new IntegerMap<>();\n+      players.add(defender, 1);\n+      players.add(attacker, 1);\n+      when(mockUnitCollection.getPlayerUnitCounts()).thenReturn(players);\n+      when(gameProperties.get(SEA_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    } else {\n+      when(battleSite.getOwner()).thenReturn(defender);\n+      when(gameProperties.get(LAND_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    }\n+\n+    final RelationshipTracker mockRelationshipTracker = mock(RelationshipTracker.class);\n+    when(gameData.getRelationshipTracker()).thenReturn(mockRelationshipTracker);\n+    lenient().when(mockRelationshipTracker.isAtWar(attacker, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, attacker)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, attacker)).thenReturn(false);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, defender)).thenReturn(false);\n+\n+    return new MustFightBattle(battleSite, attacker, gameData, battleTracker);\n+  }\n+\n+  private void assertThatStepIsMissing(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    final AssertionFailedError missingClassException =\n+        assertThrows(\n+            AssertionFailedError.class,\n+            () -> getIndex(execs, stepClass),\n+            stepClass.getName() + \" should not be in the steps\");\n+\n+    assertThat(missingClassException.toString(), containsString(\"No instance:\"));\n+  }\n+\n+  private void assertThatStepExists(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    assertThat(\n+        stepClass.getName() + \" is missing from the steps\",\n+        getIndex(execs, stepClass),\n+        greaterThanOrEqualTo(0));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on first run\")\n+  void bombardOnFirstRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on subsequent run\")\n+  void bombardOnSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added but no bombardment happens if bombard units are empty\")\n+  void bombardStepAddedButNoBombardUnits() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(ChangeFactory.EMPTY_CHANGE);\n+    verify(battle, never())\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added and bombardment happens if bombard units exist\")\n+  void bombardStepAddedAndBombardHappens() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    final Unit unit1 = mock(Unit.class);\n+    when(unit1.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit1).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    final Unit unit2 = givenUnit();\n+    when(unit2.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(unit2), List.of(), List.of(unit1), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    when(delegateBridge.getSoundChannelBroadcaster()).thenReturn(mock(ISound.class));\n+    doNothing()\n+        .when(battle)\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(argThat((Change change) -> !change.isEmpty()));\n+    verify(battle).fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify paratrooper battle steps on first run\")\n+  void paratrooperStepAddedOnFirstRound() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on first run\")\n+  void paratroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of(unit1)).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with no AirTransport tech on first run\")\n+  void noAirTransportTech() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on subsequent run\")\n+  void paratroopersSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with empty paratroopers on first run\")\n+  void emptyParatroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of()).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive Aa\")\n+  void offensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireOffensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireDefensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with defensive Aa\")\n+  void defensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireOffensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive and defensive Aa\")\n+  void offensiveAndDefensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    // Unit1 is an AA attacker that can target Unit2\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    // Unit2 is an AA defender that can target Unit1\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the second step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(1));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after \"\n+            + \"FireOffensiveAaGuns and FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(2));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void attackingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void attackingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(List.of(destroyer), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void attackingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"but has defenseless transports\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndDefenselessTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit transport = givenUnitTransport();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has defenseless transports that are not restricted\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndUnRestrTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    // it won't even check if the unit is a transport\n+    final Unit transport = givenUnit();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has no defenseless transports\")\n+  void attackingSubsCanRetreatIfBeforeBattleAndSubmersibleAndRetreatAndNoDefenselessTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify attacking canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void attackerSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void attackingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify attacking firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void attackingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(RETREATING_UNITS_REMAIN_IN_PLACE, false)).thenReturn(false);\n+    when(gameProperties.get(IGNORE_TRANSPORT_IN_MOVEMENT, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V3, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void defendingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void defendingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit canEvadeUnit = givenUnit();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(\n+        List.of(canEvadeUnit), List.of(destroyer), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void defendingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify defending canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void defenderSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void defendingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify defending firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void defendingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are removed if TRANSPORT_CASUALTIES_RESTRICTED is true\")\n+  void transportsAreRemovedIfTransportCasualtiesRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are not removed if TRANSPORT_CASUALTIES_RESTRICTED is false\")\n+  void transportsAreNotRemovedIfTransportCasualtiesUnRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted attacking transports are removed if casualities are restricted\")\n+  void unescortedAttackingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(1);\n+    when(attachment2.getAttack(attacker)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has retreat territories\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButHasRetreat() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(retreatSite)).when(battle).getAttackerRetreatTerritories();\n+    // doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted defending transports are removed if casualities are restricted\")\n+  void unescortedDefendingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(defender)).thenReturn(1);\n+    when(attachment2.getAttack(defender)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit), List.of(unit2), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(true));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(defender);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getMovement(defender)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker>defender>standard\")\n+  void firstStrikeOrderAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, true, true, true, true),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.DEFENDER,\n+            FirstStrikeBattleStep.STANDARD));\n+  }\n+\n+  private Tuple<MustFightBattle, List<IExecutable>> givenFirstStrikeBattleSetup(\n+      final boolean attackerDestroyer,\n+      final boolean defenderDestroyer,\n+      final boolean ww2v2,\n+      final boolean defendingSubsSneakAttack,\n+      final boolean ignoreDefendingSubsSneakAttack) {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    lenient().doNothing().when(battle).firstStrikeAttackersFire(any());\n+    lenient().doNothing().when(battle).firstStrikeDefendersFire(any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(ww2v2);\n+    if (!ignoreDefendingSubsSneakAttack) {\n+      when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false))\n+          .thenReturn(defendingSubsSneakAttack);\n+    }\n+\n+    final Unit attackerUnit = attackerDestroyer ? givenUnitDestroyer() : givenUnit();\n+    final Unit defenderUnit = defenderDestroyer ? givenUnitDestroyer() : givenUnit();\n+\n+    battle.setUnits(\n+        List.of(defenderUnit), List.of(attackerUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    return Tuple.of(battle, execs);\n+  }\n+\n+  private enum FirstStrikeBattleStep {\n+    ATTACKER,\n+    DEFENDER,\n+    STANDARD,\n+  }\n+\n+  private void assertThatFirstStrikeStepOrder(\n+      final Tuple<MustFightBattle, List<IExecutable>> battleTuple,\n+      final List<FirstStrikeBattleStep> stepOrder) {\n+    final List<IExecutable> execs = battleTuple.getSecond();\n+\n+    final EnumMap<FirstStrikeBattleStep, Integer> indices =\n+        new EnumMap<>(FirstStrikeBattleStep.class);\n+\n+    indices.put(\n+        FirstStrikeBattleStep.ATTACKER,\n+        getIndex(execs, MustFightBattle.FirstStrikeAttackersFire.class));\n+    indices.put(\n+        FirstStrikeBattleStep.DEFENDER,\n+        getIndex(execs, MustFightBattle.FirstStrikeDefendersFire.class));\n+    indices.put(\n+        FirstStrikeBattleStep.STANDARD,\n+        getIndex(execs, MustFightBattle.StandardAttackersFire.class));\n+\n+    assertThat(indices.get(stepOrder.get(0)), lessThan(indices.get(stepOrder.get(1))));\n+    assertThat(indices.get(stepOrder.get(1)), lessThan(indices.get(stepOrder.get(2))));\n+  }\n+\n+  private void assertThatFirstStrikeReturnFireIs(", "originalCommit": "e05eee386dfee4b28a417bebd0978c6dfcdf3600", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwMjI2OQ==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436302269", "bodyText": "Good use of the display name, though the test method name I think maybe became a bit too formulaic.\nFor example: SneakAttackTrueFalse does not really mean that much. I'd recommend looking at the method names and trying to state things more directly.  IE: The morpheus principle of naming, \"Stop trying to hit me and hit me!\"\nSuggestion:\nww2v2DefenderHasReturnFireAllWhenBothAttackerAndDefenderHaveDestroyers()", "author": "DanVanAtta", "createdAt": "2020-06-06T21:33:08Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -0,0 +1,1670 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.IGNORE_TRANSPORT_IN_MOVEMENT;\n+import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.RETREATING_UNITS_REMAIN_IN_PLACE;\n+import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.Constants.WW2V3;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitAirTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.newUnitAndAttachment;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.RelationshipTracker;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitCollection;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.IExecutable;\n+import java.math.BigDecimal;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Set;\n+import junit.framework.AssertionFailedError;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.sound.ISound;\n+import org.triplea.util.Tuple;\n+\n+@ExtendWith(MockitoExtension.class)\n+@SuppressWarnings(\"UnmatchedTest\")\n+class MustFightBattleExecutablesTest {\n+\n+  @Mock GameData gameData;\n+  @Mock GameProperties gameProperties;\n+  @Mock BattleTracker battleTracker;\n+\n+  @Mock Territory battleSite;\n+  @Mock Territory retreatSite;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+\n+  @Mock Unit unit1;\n+  @Mock UnitType unit1Type;\n+  @Mock UnitAttachment unit1Attachment;\n+\n+  @Mock Unit unit2;\n+  @Mock UnitType unit2Type;\n+  @Mock UnitAttachment unit2Attachment;\n+\n+  enum BattleTerrain {\n+    WATER,\n+    LAND\n+  }\n+\n+  private MustFightBattle newBattle(final BattleTerrain terrain) {\n+    when(gameData.getProperties()).thenReturn(gameProperties);\n+\n+    final UnitCollection mockUnitCollection = mock(UnitCollection.class);\n+    when(battleSite.getUnitCollection()).thenReturn(mockUnitCollection);\n+\n+    if (terrain == WATER) {\n+      when(battleSite.isWater()).thenReturn(true);\n+      final IntegerMap<GamePlayer> players = new IntegerMap<>();\n+      players.add(defender, 1);\n+      players.add(attacker, 1);\n+      when(mockUnitCollection.getPlayerUnitCounts()).thenReturn(players);\n+      when(gameProperties.get(SEA_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    } else {\n+      when(battleSite.getOwner()).thenReturn(defender);\n+      when(gameProperties.get(LAND_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    }\n+\n+    final RelationshipTracker mockRelationshipTracker = mock(RelationshipTracker.class);\n+    when(gameData.getRelationshipTracker()).thenReturn(mockRelationshipTracker);\n+    lenient().when(mockRelationshipTracker.isAtWar(attacker, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, attacker)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, attacker)).thenReturn(false);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, defender)).thenReturn(false);\n+\n+    return new MustFightBattle(battleSite, attacker, gameData, battleTracker);\n+  }\n+\n+  private void assertThatStepIsMissing(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    final AssertionFailedError missingClassException =\n+        assertThrows(\n+            AssertionFailedError.class,\n+            () -> getIndex(execs, stepClass),\n+            stepClass.getName() + \" should not be in the steps\");\n+\n+    assertThat(missingClassException.toString(), containsString(\"No instance:\"));\n+  }\n+\n+  private void assertThatStepExists(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    assertThat(\n+        stepClass.getName() + \" is missing from the steps\",\n+        getIndex(execs, stepClass),\n+        greaterThanOrEqualTo(0));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on first run\")\n+  void bombardOnFirstRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on subsequent run\")\n+  void bombardOnSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added but no bombardment happens if bombard units are empty\")\n+  void bombardStepAddedButNoBombardUnits() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(ChangeFactory.EMPTY_CHANGE);\n+    verify(battle, never())\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added and bombardment happens if bombard units exist\")\n+  void bombardStepAddedAndBombardHappens() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    final Unit unit1 = mock(Unit.class);\n+    when(unit1.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit1).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    final Unit unit2 = givenUnit();\n+    when(unit2.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(unit2), List.of(), List.of(unit1), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    when(delegateBridge.getSoundChannelBroadcaster()).thenReturn(mock(ISound.class));\n+    doNothing()\n+        .when(battle)\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(argThat((Change change) -> !change.isEmpty()));\n+    verify(battle).fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify paratrooper battle steps on first run\")\n+  void paratrooperStepAddedOnFirstRound() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on first run\")\n+  void paratroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of(unit1)).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with no AirTransport tech on first run\")\n+  void noAirTransportTech() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on subsequent run\")\n+  void paratroopersSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with empty paratroopers on first run\")\n+  void emptyParatroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of()).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive Aa\")\n+  void offensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireOffensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireDefensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with defensive Aa\")\n+  void defensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireOffensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive and defensive Aa\")\n+  void offensiveAndDefensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    // Unit1 is an AA attacker that can target Unit2\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    // Unit2 is an AA defender that can target Unit1\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the second step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(1));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after \"\n+            + \"FireOffensiveAaGuns and FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(2));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void attackingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void attackingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(List.of(destroyer), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void attackingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"but has defenseless transports\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndDefenselessTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit transport = givenUnitTransport();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has defenseless transports that are not restricted\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndUnRestrTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    // it won't even check if the unit is a transport\n+    final Unit transport = givenUnit();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has no defenseless transports\")\n+  void attackingSubsCanRetreatIfBeforeBattleAndSubmersibleAndRetreatAndNoDefenselessTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify attacking canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void attackerSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void attackingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify attacking firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void attackingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(RETREATING_UNITS_REMAIN_IN_PLACE, false)).thenReturn(false);\n+    when(gameProperties.get(IGNORE_TRANSPORT_IN_MOVEMENT, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V3, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void defendingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void defendingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit canEvadeUnit = givenUnit();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(\n+        List.of(canEvadeUnit), List.of(destroyer), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void defendingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify defending canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void defenderSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void defendingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify defending firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void defendingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are removed if TRANSPORT_CASUALTIES_RESTRICTED is true\")\n+  void transportsAreRemovedIfTransportCasualtiesRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are not removed if TRANSPORT_CASUALTIES_RESTRICTED is false\")\n+  void transportsAreNotRemovedIfTransportCasualtiesUnRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted attacking transports are removed if casualities are restricted\")\n+  void unescortedAttackingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(1);\n+    when(attachment2.getAttack(attacker)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has retreat territories\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButHasRetreat() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(retreatSite)).when(battle).getAttackerRetreatTerritories();\n+    // doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted defending transports are removed if casualities are restricted\")\n+  void unescortedDefendingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(defender)).thenReturn(1);\n+    when(attachment2.getAttack(defender)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit), List.of(unit2), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(true));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(defender);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getMovement(defender)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker>defender>standard\")\n+  void firstStrikeOrderAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, true, true, true, true),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.DEFENDER,\n+            FirstStrikeBattleStep.STANDARD));\n+  }\n+\n+  private Tuple<MustFightBattle, List<IExecutable>> givenFirstStrikeBattleSetup(\n+      final boolean attackerDestroyer,\n+      final boolean defenderDestroyer,\n+      final boolean ww2v2,\n+      final boolean defendingSubsSneakAttack,\n+      final boolean ignoreDefendingSubsSneakAttack) {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    lenient().doNothing().when(battle).firstStrikeAttackersFire(any());\n+    lenient().doNothing().when(battle).firstStrikeDefendersFire(any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(ww2v2);\n+    if (!ignoreDefendingSubsSneakAttack) {\n+      when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false))\n+          .thenReturn(defendingSubsSneakAttack);\n+    }\n+\n+    final Unit attackerUnit = attackerDestroyer ? givenUnitDestroyer() : givenUnit();\n+    final Unit defenderUnit = defenderDestroyer ? givenUnitDestroyer() : givenUnit();\n+\n+    battle.setUnits(\n+        List.of(defenderUnit), List.of(attackerUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    return Tuple.of(battle, execs);\n+  }\n+\n+  private enum FirstStrikeBattleStep {\n+    ATTACKER,\n+    DEFENDER,\n+    STANDARD,\n+  }\n+\n+  private void assertThatFirstStrikeStepOrder(\n+      final Tuple<MustFightBattle, List<IExecutable>> battleTuple,\n+      final List<FirstStrikeBattleStep> stepOrder) {\n+    final List<IExecutable> execs = battleTuple.getSecond();\n+\n+    final EnumMap<FirstStrikeBattleStep, Integer> indices =\n+        new EnumMap<>(FirstStrikeBattleStep.class);\n+\n+    indices.put(\n+        FirstStrikeBattleStep.ATTACKER,\n+        getIndex(execs, MustFightBattle.FirstStrikeAttackersFire.class));\n+    indices.put(\n+        FirstStrikeBattleStep.DEFENDER,\n+        getIndex(execs, MustFightBattle.FirstStrikeDefendersFire.class));\n+    indices.put(\n+        FirstStrikeBattleStep.STANDARD,\n+        getIndex(execs, MustFightBattle.StandardAttackersFire.class));\n+\n+    assertThat(indices.get(stepOrder.get(0)), lessThan(indices.get(stepOrder.get(1))));\n+    assertThat(indices.get(stepOrder.get(1)), lessThan(indices.get(stepOrder.get(2))));\n+  }\n+\n+  private void assertThatFirstStrikeReturnFireIs(\n+      final Tuple<MustFightBattle, List<IExecutable>> battleTuple,\n+      final MustFightBattle.ReturnFire returnFire,\n+      final boolean attacker) {\n+    final MustFightBattle battle = battleTuple.getFirst();\n+    final List<IExecutable> execs = battleTuple.getSecond();\n+    final int index =\n+        getIndex(\n+            execs,\n+            attacker\n+                ? MustFightBattle.FirstStrikeAttackersFire.class\n+                : MustFightBattle.FirstStrikeDefendersFire.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    if (attacker) {\n+      verify(battle).firstStrikeAttackersFire(returnFire);\n+    } else {\n+      verify(battle).firstStrikeDefendersFire(returnFire);\n+    }\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker has return fire all\")\n+  void firstStrikeAttackerReturnFireAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, true, true, true, true),\n+        MustFightBattle.ReturnFire.ALL,\n+        true);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then defender has return fire all\")\n+  void firstStrikeDefenderReturnFireAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {", "originalCommit": "e05eee386dfee4b28a417bebd0978c6dfcdf3600", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwMjQwMw==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436302403", "bodyText": "nit, if the value of and DEFENDING_SUBS_SNEAK_ATTACK is either, you can probably just omit it from the display name. I think it would only be important if this test were parameterized and you actually test both the DEFENDING_SUBS_SNEAK_ATTACK == true and DEFENDING_SUBS_SNEAK_ATTACK == false cases.\nHave you considered actually parameterizing this test to verify both of those cases? EG:\n@ParameterizedTest\n@ValueSource(booleans = { true, false })\nvoid testMethodName(boolean defendingSubsSneakAttack) {\n  // ....\n}\n\nIf the test is parameterized, there is some auto-generation of test case names, check how they read in your IDE output and perhaps the display name can be shortened.", "author": "DanVanAtta", "createdAt": "2020-06-06T21:35:35Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -0,0 +1,1670 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.IGNORE_TRANSPORT_IN_MOVEMENT;\n+import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.RETREATING_UNITS_REMAIN_IN_PLACE;\n+import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.Constants.WW2V3;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitAirTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.newUnitAndAttachment;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.RelationshipTracker;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitCollection;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.IExecutable;\n+import java.math.BigDecimal;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Set;\n+import junit.framework.AssertionFailedError;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.sound.ISound;\n+import org.triplea.util.Tuple;\n+\n+@ExtendWith(MockitoExtension.class)\n+@SuppressWarnings(\"UnmatchedTest\")\n+class MustFightBattleExecutablesTest {\n+\n+  @Mock GameData gameData;\n+  @Mock GameProperties gameProperties;\n+  @Mock BattleTracker battleTracker;\n+\n+  @Mock Territory battleSite;\n+  @Mock Territory retreatSite;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+\n+  @Mock Unit unit1;\n+  @Mock UnitType unit1Type;\n+  @Mock UnitAttachment unit1Attachment;\n+\n+  @Mock Unit unit2;\n+  @Mock UnitType unit2Type;\n+  @Mock UnitAttachment unit2Attachment;\n+\n+  enum BattleTerrain {\n+    WATER,\n+    LAND\n+  }\n+\n+  private MustFightBattle newBattle(final BattleTerrain terrain) {\n+    when(gameData.getProperties()).thenReturn(gameProperties);\n+\n+    final UnitCollection mockUnitCollection = mock(UnitCollection.class);\n+    when(battleSite.getUnitCollection()).thenReturn(mockUnitCollection);\n+\n+    if (terrain == WATER) {\n+      when(battleSite.isWater()).thenReturn(true);\n+      final IntegerMap<GamePlayer> players = new IntegerMap<>();\n+      players.add(defender, 1);\n+      players.add(attacker, 1);\n+      when(mockUnitCollection.getPlayerUnitCounts()).thenReturn(players);\n+      when(gameProperties.get(SEA_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    } else {\n+      when(battleSite.getOwner()).thenReturn(defender);\n+      when(gameProperties.get(LAND_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    }\n+\n+    final RelationshipTracker mockRelationshipTracker = mock(RelationshipTracker.class);\n+    when(gameData.getRelationshipTracker()).thenReturn(mockRelationshipTracker);\n+    lenient().when(mockRelationshipTracker.isAtWar(attacker, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, attacker)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, attacker)).thenReturn(false);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, defender)).thenReturn(false);\n+\n+    return new MustFightBattle(battleSite, attacker, gameData, battleTracker);\n+  }\n+\n+  private void assertThatStepIsMissing(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    final AssertionFailedError missingClassException =\n+        assertThrows(\n+            AssertionFailedError.class,\n+            () -> getIndex(execs, stepClass),\n+            stepClass.getName() + \" should not be in the steps\");\n+\n+    assertThat(missingClassException.toString(), containsString(\"No instance:\"));\n+  }\n+\n+  private void assertThatStepExists(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    assertThat(\n+        stepClass.getName() + \" is missing from the steps\",\n+        getIndex(execs, stepClass),\n+        greaterThanOrEqualTo(0));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on first run\")\n+  void bombardOnFirstRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on subsequent run\")\n+  void bombardOnSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added but no bombardment happens if bombard units are empty\")\n+  void bombardStepAddedButNoBombardUnits() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(ChangeFactory.EMPTY_CHANGE);\n+    verify(battle, never())\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added and bombardment happens if bombard units exist\")\n+  void bombardStepAddedAndBombardHappens() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    final Unit unit1 = mock(Unit.class);\n+    when(unit1.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit1).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    final Unit unit2 = givenUnit();\n+    when(unit2.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(unit2), List.of(), List.of(unit1), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    when(delegateBridge.getSoundChannelBroadcaster()).thenReturn(mock(ISound.class));\n+    doNothing()\n+        .when(battle)\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(argThat((Change change) -> !change.isEmpty()));\n+    verify(battle).fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify paratrooper battle steps on first run\")\n+  void paratrooperStepAddedOnFirstRound() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on first run\")\n+  void paratroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of(unit1)).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with no AirTransport tech on first run\")\n+  void noAirTransportTech() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on subsequent run\")\n+  void paratroopersSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with empty paratroopers on first run\")\n+  void emptyParatroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of()).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive Aa\")\n+  void offensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireOffensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireDefensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with defensive Aa\")\n+  void defensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireOffensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive and defensive Aa\")\n+  void offensiveAndDefensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    // Unit1 is an AA attacker that can target Unit2\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    // Unit2 is an AA defender that can target Unit1\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the second step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(1));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after \"\n+            + \"FireOffensiveAaGuns and FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(2));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void attackingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void attackingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(List.of(destroyer), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void attackingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"but has defenseless transports\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndDefenselessTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit transport = givenUnitTransport();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has defenseless transports that are not restricted\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndUnRestrTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    // it won't even check if the unit is a transport\n+    final Unit transport = givenUnit();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has no defenseless transports\")\n+  void attackingSubsCanRetreatIfBeforeBattleAndSubmersibleAndRetreatAndNoDefenselessTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify attacking canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void attackerSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void attackingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify attacking firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void attackingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(RETREATING_UNITS_REMAIN_IN_PLACE, false)).thenReturn(false);\n+    when(gameProperties.get(IGNORE_TRANSPORT_IN_MOVEMENT, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V3, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void defendingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void defendingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit canEvadeUnit = givenUnit();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(\n+        List.of(canEvadeUnit), List.of(destroyer), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void defendingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify defending canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void defenderSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void defendingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify defending firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void defendingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are removed if TRANSPORT_CASUALTIES_RESTRICTED is true\")\n+  void transportsAreRemovedIfTransportCasualtiesRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are not removed if TRANSPORT_CASUALTIES_RESTRICTED is false\")\n+  void transportsAreNotRemovedIfTransportCasualtiesUnRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted attacking transports are removed if casualities are restricted\")\n+  void unescortedAttackingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(1);\n+    when(attachment2.getAttack(attacker)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has retreat territories\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButHasRetreat() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(retreatSite)).when(battle).getAttackerRetreatTerritories();\n+    // doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted defending transports are removed if casualities are restricted\")\n+  void unescortedDefendingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(defender)).thenReturn(1);\n+    when(attachment2.getAttack(defender)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit), List.of(unit2), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(true));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(defender);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getMovement(defender)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker>defender>standard\")\n+  void firstStrikeOrderAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, true, true, true, true),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.DEFENDER,\n+            FirstStrikeBattleStep.STANDARD));\n+  }\n+\n+  private Tuple<MustFightBattle, List<IExecutable>> givenFirstStrikeBattleSetup(\n+      final boolean attackerDestroyer,\n+      final boolean defenderDestroyer,\n+      final boolean ww2v2,\n+      final boolean defendingSubsSneakAttack,\n+      final boolean ignoreDefendingSubsSneakAttack) {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    lenient().doNothing().when(battle).firstStrikeAttackersFire(any());\n+    lenient().doNothing().when(battle).firstStrikeDefendersFire(any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(ww2v2);\n+    if (!ignoreDefendingSubsSneakAttack) {\n+      when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false))\n+          .thenReturn(defendingSubsSneakAttack);\n+    }\n+\n+    final Unit attackerUnit = attackerDestroyer ? givenUnitDestroyer() : givenUnit();\n+    final Unit defenderUnit = defenderDestroyer ? givenUnitDestroyer() : givenUnit();\n+\n+    battle.setUnits(\n+        List.of(defenderUnit), List.of(attackerUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    return Tuple.of(battle, execs);\n+  }\n+\n+  private enum FirstStrikeBattleStep {\n+    ATTACKER,\n+    DEFENDER,\n+    STANDARD,\n+  }\n+\n+  private void assertThatFirstStrikeStepOrder(\n+      final Tuple<MustFightBattle, List<IExecutable>> battleTuple,\n+      final List<FirstStrikeBattleStep> stepOrder) {\n+    final List<IExecutable> execs = battleTuple.getSecond();\n+\n+    final EnumMap<FirstStrikeBattleStep, Integer> indices =\n+        new EnumMap<>(FirstStrikeBattleStep.class);\n+\n+    indices.put(\n+        FirstStrikeBattleStep.ATTACKER,\n+        getIndex(execs, MustFightBattle.FirstStrikeAttackersFire.class));\n+    indices.put(\n+        FirstStrikeBattleStep.DEFENDER,\n+        getIndex(execs, MustFightBattle.FirstStrikeDefendersFire.class));\n+    indices.put(\n+        FirstStrikeBattleStep.STANDARD,\n+        getIndex(execs, MustFightBattle.StandardAttackersFire.class));\n+\n+    assertThat(indices.get(stepOrder.get(0)), lessThan(indices.get(stepOrder.get(1))));\n+    assertThat(indices.get(stepOrder.get(1)), lessThan(indices.get(stepOrder.get(2))));\n+  }\n+\n+  private void assertThatFirstStrikeReturnFireIs(\n+      final Tuple<MustFightBattle, List<IExecutable>> battleTuple,\n+      final MustFightBattle.ReturnFire returnFire,\n+      final boolean attacker) {\n+    final MustFightBattle battle = battleTuple.getFirst();\n+    final List<IExecutable> execs = battleTuple.getSecond();\n+    final int index =\n+        getIndex(\n+            execs,\n+            attacker\n+                ? MustFightBattle.FirstStrikeAttackersFire.class\n+                : MustFightBattle.FirstStrikeDefendersFire.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    if (attacker) {\n+      verify(battle).firstStrikeAttackersFire(returnFire);\n+    } else {\n+      verify(battle).firstStrikeDefendersFire(returnFire);\n+    }\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker has return fire all\")\n+  void firstStrikeAttackerReturnFireAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, true, true, true, true),\n+        MustFightBattle.ReturnFire.ALL,\n+        true);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then defender has return fire all\")\n+  void firstStrikeDefenderReturnFireAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, true, true, true, true),\n+        MustFightBattle.ReturnFire.ALL,\n+        false);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is true, then attacker>standard>defender\")\n+  void firstStrikeOrderAttHasDestroyerDefHasDestroyerWW2v2FalseSneakAttackTrue() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, true, false, true, false),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.STANDARD,\n+            FirstStrikeBattleStep.DEFENDER));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is true, then attacker has return fire all\")\n+  void firstStrikeAttackerReturnFireAttHasDestroyerDefHasDestroyerWW2v2FalseSneakAttackTrue() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, true, false, true, false),\n+        MustFightBattle.ReturnFire.ALL,\n+        true);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is true, then defender has return fire all\")\n+  void firstStrikeDefenderReturnFireAttHasDestroyerDefHasDestroyerWW2v2FalseSneakAttackTrue() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, true, false, true, false),\n+        MustFightBattle.ReturnFire.ALL,\n+        false);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is false, then attacker>standard>defender\")\n+  void firstStrikeOrderAttHasDestroyerDefHasDestroyerWW2v2FalseSneakAttackFalse() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, true, false, false, false),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.STANDARD,\n+            FirstStrikeBattleStep.DEFENDER));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is false, then attacker has return fire all\")\n+  void firstStrikeAttackerReturnFireAttHasDestroyerDefHasDestroyerWW2v2FalseSneakAttackFalse() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, true, false, false, false),\n+        MustFightBattle.ReturnFire.ALL,\n+        true);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is false, then defender has return fire all\")\n+  void firstStrikeDefenderReturnFireAttHasDestroyerDefHasDestroyerWW2v2FalseSneakAttackFalse() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, true, false, false, false),\n+        MustFightBattle.ReturnFire.ALL,\n+        false);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has no destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker>defender>standard\")\n+  void firstStrikeOrderAttHasDestroyerDefNoDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, false, true, true, true),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.DEFENDER,\n+            FirstStrikeBattleStep.STANDARD));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has no destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker has return fire subs\")\n+  void firstStrikeAttackerReturnFireAttHasDestroyerDefNoDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, false, true, true, true),\n+        MustFightBattle.ReturnFire.SUBS,\n+        true);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has no destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then defender has return fire all\")\n+  void firstStrikeDefenderReturnFireAttHasDestroyerDefNoDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, false, true, true, true),\n+        MustFightBattle.ReturnFire.ALL,\n+        false);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has no destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is true, then attacker>standard>defender\")\n+  void firstStrikeOrderAttHasDestroyerDefNoDestroyerWW2v2FalseSneakAttackTrue() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, false, false, true, false),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.STANDARD,\n+            FirstStrikeBattleStep.DEFENDER));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has no destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is true, then attacker has return fire none\")\n+  void firstStrikeAttackerReturnFireAttHasDestroyerDefNoDestroyerWW2v2FalseSneakAttackTrue() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, false, false, true, false),\n+        MustFightBattle.ReturnFire.NONE,\n+        true);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has no destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is true, then defender has return fire all\")\n+  void firstStrikeDefenderReturnFireAttHasDestroyerDefNoDestroyerWW2v2FalseSneakAttackTrue() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, false, false, true, false),\n+        MustFightBattle.ReturnFire.ALL,\n+        false);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has no destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is false, then attacker>standard>defender\")\n+  void firstStrikeOrderAttHasDestroyerDefNoDestroyerWW2v2FalseSneakAttackFalse() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, false, false, false, false),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.STANDARD,\n+            FirstStrikeBattleStep.DEFENDER));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has no destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is false, then attacker has return fire none\")\n+  void firstStrikeAttackerReturnFireAttHasDestroyerDefNoDestroyerWW2v2FalseSneakAttackFalse() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, false, false, false, false),\n+        MustFightBattle.ReturnFire.NONE,\n+        true);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has no destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is false, then defender has return fire all\")\n+  void firstStrikeDefenderReturnFireAttHasDestroyerDefNoDestroyerWW2v2FalseSneakAttackFalse() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, false, false, false, false),\n+        MustFightBattle.ReturnFire.ALL,\n+        false);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has no destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker>defender>standard\")", "originalCommit": "e05eee386dfee4b28a417bebd0978c6dfcdf3600", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwMjgzMQ==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436302831", "bodyText": "CONSIDER THIS COMMENT FIRST!\nAfter reading through most of the tests, the pattern of testing I think has become more clear. Have you considered parameterizing the whole thing?\nIf you had a value object for the battle setup, then it should become pretty easy!\nExample:\n@ParameterizedTest\n@MethodSource\nvoid verifyFirstStrikeBattleScenarios( \n     BattleSetupParameters setup, MustFightBattle returnFire, boolean attackersExpectedToHaveFirstStrike) {\n\n   verifyFirstStrikebattle(\n        setup,  returnFire,  attackersExpectedToHaveFirstStrike);\n}\n\n\nstatic List<Arguments> verifyFirstStrikeBattleScenarios() {\n  return List.of(\n     Arguments.of(BattleSetupParameters.builder()....build(), MustFightBattle.ReturnFire.ALL, false),\n     :\n     :\n     );\n}", "author": "DanVanAtta", "createdAt": "2020-06-06T21:41:04Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -0,0 +1,1670 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static games.strategy.engine.data.Unit.ALREADY_MOVED;\n+import static games.strategy.triplea.Constants.DEFENDING_SUBS_SNEAK_ATTACK;\n+import static games.strategy.triplea.Constants.IGNORE_TRANSPORT_IN_MOVEMENT;\n+import static games.strategy.triplea.Constants.LAND_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.RETREATING_UNITS_REMAIN_IN_PLACE;\n+import static games.strategy.triplea.Constants.SEA_BATTLE_ROUNDS;\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.SUB_RETREAT_BEFORE_BATTLE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.WW2V2;\n+import static games.strategy.triplea.Constants.WW2V3;\n+import static games.strategy.triplea.delegate.GameDataTestUtil.getIndex;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.LAND;\n+import static games.strategy.triplea.delegate.battle.MustFightBattleExecutablesTest.BattleTerrain.WATER;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitAirTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.newUnitAndAttachment;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.RelationshipTracker;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitCollection;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.IExecutable;\n+import java.math.BigDecimal;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Set;\n+import junit.framework.AssertionFailedError;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.sound.ISound;\n+import org.triplea.util.Tuple;\n+\n+@ExtendWith(MockitoExtension.class)\n+@SuppressWarnings(\"UnmatchedTest\")\n+class MustFightBattleExecutablesTest {\n+\n+  @Mock GameData gameData;\n+  @Mock GameProperties gameProperties;\n+  @Mock BattleTracker battleTracker;\n+\n+  @Mock Territory battleSite;\n+  @Mock Territory retreatSite;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+\n+  @Mock Unit unit1;\n+  @Mock UnitType unit1Type;\n+  @Mock UnitAttachment unit1Attachment;\n+\n+  @Mock Unit unit2;\n+  @Mock UnitType unit2Type;\n+  @Mock UnitAttachment unit2Attachment;\n+\n+  enum BattleTerrain {\n+    WATER,\n+    LAND\n+  }\n+\n+  private MustFightBattle newBattle(final BattleTerrain terrain) {\n+    when(gameData.getProperties()).thenReturn(gameProperties);\n+\n+    final UnitCollection mockUnitCollection = mock(UnitCollection.class);\n+    when(battleSite.getUnitCollection()).thenReturn(mockUnitCollection);\n+\n+    if (terrain == WATER) {\n+      when(battleSite.isWater()).thenReturn(true);\n+      final IntegerMap<GamePlayer> players = new IntegerMap<>();\n+      players.add(defender, 1);\n+      players.add(attacker, 1);\n+      when(mockUnitCollection.getPlayerUnitCounts()).thenReturn(players);\n+      when(gameProperties.get(SEA_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    } else {\n+      when(battleSite.getOwner()).thenReturn(defender);\n+      when(gameProperties.get(LAND_BATTLE_ROUNDS, -1)).thenReturn(100);\n+    }\n+\n+    final RelationshipTracker mockRelationshipTracker = mock(RelationshipTracker.class);\n+    when(gameData.getRelationshipTracker()).thenReturn(mockRelationshipTracker);\n+    lenient().when(mockRelationshipTracker.isAtWar(attacker, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, attacker)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, defender)).thenReturn(true);\n+    lenient().when(mockRelationshipTracker.isAllied(defender, attacker)).thenReturn(false);\n+    lenient().when(mockRelationshipTracker.isAllied(attacker, defender)).thenReturn(false);\n+\n+    return new MustFightBattle(battleSite, attacker, gameData, battleTracker);\n+  }\n+\n+  private void assertThatStepIsMissing(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    final AssertionFailedError missingClassException =\n+        assertThrows(\n+            AssertionFailedError.class,\n+            () -> getIndex(execs, stepClass),\n+            stepClass.getName() + \" should not be in the steps\");\n+\n+    assertThat(missingClassException.toString(), containsString(\"No instance:\"));\n+  }\n+\n+  private void assertThatStepExists(\n+      final List<IExecutable> execs, final Class<? extends IExecutable> stepClass) {\n+    assertThat(\n+        stepClass.getName() + \" is missing from the steps\",\n+        getIndex(execs, stepClass),\n+        greaterThanOrEqualTo(0));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on first run\")\n+  void bombardOnFirstRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with bombard on subsequent run\")\n+  void bombardOnSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireNavalBombardment.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added but no bombardment happens if bombard units are empty\")\n+  void bombardStepAddedButNoBombardUnits() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(ChangeFactory.EMPTY_CHANGE);\n+    verify(battle, never())\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify Bombard step is added and bombardment happens if bombard units exist\")\n+  void bombardStepAddedAndBombardHappens() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+\n+    final Unit unit1 = mock(Unit.class);\n+    when(unit1.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit1).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    final Unit unit2 = givenUnit();\n+    when(unit2.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(unit2), List.of(), List.of(unit1), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.FireNavalBombardment.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    when(delegateBridge.getSoundChannelBroadcaster()).thenReturn(mock(ISound.class));\n+    doNothing()\n+        .when(battle)\n+        .fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(argThat((Change change) -> !change.isEmpty()));\n+    verify(battle).fire(anyString(), any(), any(), any(), any(), anyBoolean(), any(), anyString());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify paratrooper battle steps on first run\")\n+  void paratrooperStepAddedOnFirstRound() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on first run\")\n+  void paratroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of(unit1)).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with no AirTransport tech on first run\")\n+  void noAirTransportTech() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with paratroopers on subsequent run\")\n+  void paratroopersSubsequentRun() {\n+    final MustFightBattle battle = newBattle(LAND);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(false);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.LandParatroopers.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with empty paratroopers on first run\")\n+  void emptyParatroopersFirstRun() {\n+    final MustFightBattle battle = spy(newBattle(LAND));\n+    final TechAttachment techAttachment = mock(TechAttachment.class);\n+    when(attacker.getAttachment(Constants.TECH_ATTACHMENT_NAME)).thenReturn(techAttachment);\n+    when(attacker.getTechAttachment()).thenReturn(techAttachment);\n+    when(techAttachment.getParatroopers()).thenReturn(true);\n+\n+    final Unit unit1 = givenUnit();\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    final Unit unit3 = givenUnitAirTransport();\n+    when(unit3.getOwner()).thenReturn(attacker);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit1, unit3));\n+    doReturn(List.of()).when(battle).getDependentUnits(any());\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.LandParatroopers.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive Aa\")\n+  void offensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireOffensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireDefensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with defensive Aa\")\n+  void defensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(1));\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.FireOffensiveAaGuns.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify basic land battle with offensive and defensive Aa\")\n+  void offensiveAndDefensiveAaFire() {\n+    final MustFightBattle battle = newBattle(LAND);\n+    when(gameData.getRelationshipTracker().isAtWar(defender, attacker)).thenReturn(true);\n+\n+    // Unit1 is an AA attacker that can target Unit2\n+    when(unit1.getType()).thenReturn(unit1Type);\n+    when(unit1.getOwner()).thenReturn(attacker);\n+    when(unit1.getData()).thenReturn(gameData);\n+    when(unit1Type.getAttachment(anyString())).thenReturn(unit1Attachment);\n+    when(unit1Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit1Attachment.getOffensiveAttackAa(attacker)).thenReturn(1);\n+    when(unit1Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit1Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit1Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit2Type));\n+    when(unit1Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    // Unit2 is an AA defender that can target Unit1\n+    when(unit2.getType()).thenReturn(unit2Type);\n+    when(unit2.getOwner()).thenReturn(defender);\n+    when(unit2.getData()).thenReturn(gameData);\n+    when(unit2Type.getAttachment(anyString())).thenReturn(unit2Attachment);\n+    when(unit2Attachment.getTypeAa()).thenReturn(\"AntiAirGun\");\n+    when(unit2Attachment.getAttackAa(defender)).thenReturn(1);\n+    when(unit2Attachment.getMaxAaAttacks()).thenReturn(1);\n+    when(unit2Attachment.getMaxRoundsAa()).thenReturn(-1);\n+    when(unit2Attachment.getTargetsAa(gameData)).thenReturn(Set.of(unit1Type));\n+    when(unit2Attachment.getIsAaForCombatOnly()).thenReturn(true);\n+\n+    battle.setUnits(List.of(unit2), List.of(unit1), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThat(\n+        \"FireOffensiveAaGuns should be the first step\",\n+        getIndex(execs, MustFightBattle.FireOffensiveAaGuns.class),\n+        is(0));\n+\n+    assertThat(\n+        \"FireDefensiveAaGuns should be the second step\",\n+        getIndex(execs, MustFightBattle.FireDefensiveAaGuns.class),\n+        is(1));\n+\n+    assertThat(\n+        \"ClearAaWaitingToDieAndDamagedChangesInto is after \"\n+            + \"FireOffensiveAaGuns and FireDefensiveAaGuns\",\n+        getIndex(execs, MustFightBattle.ClearAaWaitingToDieAndDamagedChangesInto.class),\n+        is(2));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void attackingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void attackingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(List.of(destroyer), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void attackingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"but has defenseless transports\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndDefenselessTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Unit transport = givenUnitTransport();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has defenseless transports that are not restricted\")\n+  void attackingSubsCanNotRetreatIfBeforeBattleAndSubmersibleAndTerritoriesAndUnRestrTransp() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit unit = givenUnitCanEvade();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    // it won't even check if the unit is a transport\n+    final Unit transport = givenUnit();\n+\n+    battle.setUnits(List.of(transport), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, retreat exists, \"\n+          + \"has no defenseless transports\")\n+  void attackingSubsCanRetreatIfBeforeBattleAndSubmersibleAndRetreatAndNoDefenselessTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(battleSite)).when(battle).getAttackerRetreatTerritories();\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify attacking canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void attackerSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void attackingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify attacking firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void attackingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(RETREATING_UNITS_REMAIN_IN_PLACE, false)).thenReturn(false);\n+    when(gameProperties.get(IGNORE_TRANSPORT_IN_MOVEMENT, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V3, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(canEvadeUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.AttackerRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE, no destroyers, and retreat territory\")\n+  void defendingSubsRetreatIfNoDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of(battleSite)).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE and destroyers\")\n+  void defendingSubsNotRetreatIfDestroyersAndCanRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit canEvadeUnit = givenUnit();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    final Unit destroyer = givenUnitDestroyer();\n+\n+    battle.setUnits(\n+        List.of(canEvadeUnit), List.of(destroyer), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE is true, SUBMERSIBLE_SUBS is false, and no retreat\")\n+  void defendingSubsCanNotRetreatIfRetreatBeforeBattleAndSubmersibleAndNoRetreatTerritories() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(false);\n+\n+    // it doesn't even check if the unit can evade\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify defending canEvade units can retreat if SUB_RETREAT_BEFORE_BATTLE\")\n+  void defenderSubsRetreatBeforeBattleIsAdded() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending canEvade units can not retreat if SUB_RETREAT_BEFORE_BATTLE is false\")\n+  void defendingSubsRetreatIfCanNotRetreatBeforeBattle() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+  }\n+\n+  @Test\n+  // firstStrike is actually not checked, unlike in BattleSteps\n+  @DisplayName(\n+      \"Verify defending firstStrike submerge before battle if \"\n+          + \"SUB_RETREAT_BEFORE_BATTLE and SUBMERSIBLE_SUBS are true and no destroyers\")\n+  void defendingFirstStrikeSubmergeBeforeBattleIfSubmersibleSubsAndRetreatBeforeBattle() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doNothing().when(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+    doReturn(List.of()).when(battle).getEmptyOrFriendlySeaNeighbors(any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(false);\n+    when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false)).thenReturn(false);\n+    when(gameProperties.get(SUBMERSIBLE_SUBS, false)).thenReturn(true);\n+\n+    final Unit canEvadeUnit = givenUnitCanEvade();\n+    when(canEvadeUnit.getOwner()).thenReturn(defender);\n+\n+    battle.setUnits(List.of(canEvadeUnit), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.DefenderRetreatSubsBeforeBattle.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(battle).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are removed if TRANSPORT_CASUALTIES_RESTRICTED is true\")\n+  void transportsAreRemovedIfTransportCasualtiesRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepExists(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify transports are not removed if TRANSPORT_CASUALTIES_RESTRICTED is false\")\n+  void transportsAreNotRemovedIfTransportCasualtiesUnRestricted() {\n+    final MustFightBattle battle = newBattle(WATER);\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(true);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+\n+    battle.setUnits(List.of(), List.of(), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    assertThatStepIsMissing(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted attacking transports are removed if casualities are restricted\")\n+  void unescortedAttackingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(1);\n+    when(attachment2.getAttack(attacker)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has retreat territories\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButHasRetreat() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of(retreatSite)).when(battle).getAttackerRetreatTerritories();\n+    // doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnit();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    battle.setUnits(List.of(), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(attacker);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify attacking transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void attackingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(attacker)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify unescorted defending transports are removed if casualities are restricted\")\n+  void unescortedDefendingTransportsAreRemovedWhenCasualtiesAreRestricted() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    doNothing().when(battle).remove(any(), any(), any(), any());\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getTransportCapacity()).thenReturn(-1);\n+    when(attachment2.getMovement(defender)).thenReturn(1);\n+    when(attachment2.getAttack(defender)).thenReturn(1);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+    when(unit2.getMovementLeft()).thenReturn(BigDecimal.ZERO);\n+    final MutableProperty<Boolean> alreadyMovedProperty = MutableProperty.ofReadOnly(() -> true);\n+    doReturn(alreadyMovedProperty).when(unit2).getPropertyOrThrow(ALREADY_MOVED);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit), List.of(unit2), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());\n+    verify(battle).remove(any(), any(), any(), eq(true));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but has no transports\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoTransports() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Unit unit = givenUnitDestroyer();\n+    when(unit.getOwner()).thenReturn(defender);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"Verify defending transports are not removed if \"\n+          + \"TRANSPORT_CASUALTIES_RESTRICTED is true but no defenders\")\n+  void defendingTransportsAreNotRemovedIfTransportCasualtiesRestrictedButNoDefenders() {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    doReturn(List.of()).when(battle).getAttackerRetreatTerritories();\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    final Unit unit = unitAndAttachment.getFirst();\n+    when(unit.getOwner()).thenReturn(defender);\n+    final UnitAttachment attachment1 = unitAndAttachment.getSecond();\n+    when(attachment1.getIsCombatTransport()).thenReturn(false);\n+    when(attachment1.getTransportCapacity()).thenReturn(2);\n+    when(attachment1.getIsSea()).thenReturn(true);\n+\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment2 = newUnitAndAttachment();\n+    final Unit unit2 = unitAndAttachment2.getFirst();\n+    when(unit2.getOwner()).thenReturn(attacker);\n+    final UnitAttachment attachment2 = unitAndAttachment2.getSecond();\n+    when(attachment2.getMovement(defender)).thenReturn(0);\n+    when(attachment2.getIsSea()).thenReturn(true);\n+\n+    when(battleSite.getUnits()).thenReturn(List.of(unit, unit2));\n+\n+    battle.setUnits(List.of(unit2), List.of(unit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    final int index = getIndex(execs, MustFightBattle.RemoveUndefendedTransports.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    verify(delegateBridge, never()).addChange(any());\n+    verify(battle, never()).remove(any(), any(), any(), eq(false));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker>defender>standard\")\n+  void firstStrikeOrderAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, true, true, true, true),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.DEFENDER,\n+            FirstStrikeBattleStep.STANDARD));\n+  }\n+\n+  private Tuple<MustFightBattle, List<IExecutable>> givenFirstStrikeBattleSetup(\n+      final boolean attackerDestroyer,\n+      final boolean defenderDestroyer,\n+      final boolean ww2v2,\n+      final boolean defendingSubsSneakAttack,\n+      final boolean ignoreDefendingSubsSneakAttack) {\n+    final MustFightBattle battle = spy(newBattle(WATER));\n+    lenient().doNothing().when(battle).firstStrikeAttackersFire(any());\n+    lenient().doNothing().when(battle).firstStrikeDefendersFire(any());\n+\n+    when(gameProperties.get(SUB_RETREAT_BEFORE_BATTLE, false)).thenReturn(false);\n+    when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(false);\n+    when(gameProperties.get(WW2V2, false)).thenReturn(ww2v2);\n+    if (!ignoreDefendingSubsSneakAttack) {\n+      when(gameProperties.get(DEFENDING_SUBS_SNEAK_ATTACK, false))\n+          .thenReturn(defendingSubsSneakAttack);\n+    }\n+\n+    final Unit attackerUnit = attackerDestroyer ? givenUnitDestroyer() : givenUnit();\n+    final Unit defenderUnit = defenderDestroyer ? givenUnitDestroyer() : givenUnit();\n+\n+    battle.setUnits(\n+        List.of(defenderUnit), List.of(attackerUnit), List.of(), List.of(), defender, List.of());\n+    final List<IExecutable> execs = battle.getBattleExecutables(true);\n+\n+    return Tuple.of(battle, execs);\n+  }\n+\n+  private enum FirstStrikeBattleStep {\n+    ATTACKER,\n+    DEFENDER,\n+    STANDARD,\n+  }\n+\n+  private void assertThatFirstStrikeStepOrder(\n+      final Tuple<MustFightBattle, List<IExecutable>> battleTuple,\n+      final List<FirstStrikeBattleStep> stepOrder) {\n+    final List<IExecutable> execs = battleTuple.getSecond();\n+\n+    final EnumMap<FirstStrikeBattleStep, Integer> indices =\n+        new EnumMap<>(FirstStrikeBattleStep.class);\n+\n+    indices.put(\n+        FirstStrikeBattleStep.ATTACKER,\n+        getIndex(execs, MustFightBattle.FirstStrikeAttackersFire.class));\n+    indices.put(\n+        FirstStrikeBattleStep.DEFENDER,\n+        getIndex(execs, MustFightBattle.FirstStrikeDefendersFire.class));\n+    indices.put(\n+        FirstStrikeBattleStep.STANDARD,\n+        getIndex(execs, MustFightBattle.StandardAttackersFire.class));\n+\n+    assertThat(indices.get(stepOrder.get(0)), lessThan(indices.get(stepOrder.get(1))));\n+    assertThat(indices.get(stepOrder.get(1)), lessThan(indices.get(stepOrder.get(2))));\n+  }\n+\n+  private void assertThatFirstStrikeReturnFireIs(\n+      final Tuple<MustFightBattle, List<IExecutable>> battleTuple,\n+      final MustFightBattle.ReturnFire returnFire,\n+      final boolean attacker) {\n+    final MustFightBattle battle = battleTuple.getFirst();\n+    final List<IExecutable> execs = battleTuple.getSecond();\n+    final int index =\n+        getIndex(\n+            execs,\n+            attacker\n+                ? MustFightBattle.FirstStrikeAttackersFire.class\n+                : MustFightBattle.FirstStrikeDefendersFire.class);\n+    final IExecutable step = execs.get(index);\n+\n+    final IDelegateBridge delegateBridge = mock(IDelegateBridge.class);\n+    step.execute(null, delegateBridge);\n+\n+    if (attacker) {\n+      verify(battle).firstStrikeAttackersFire(returnFire);\n+    } else {\n+      verify(battle).firstStrikeDefendersFire(returnFire);\n+    }\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then attacker has return fire all\")\n+  void firstStrikeAttackerReturnFireAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, true, true, true, true),\n+        MustFightBattle.ReturnFire.ALL,\n+        true);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is true, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is either, then defender has return fire all\")\n+  void firstStrikeDefenderReturnFireAttHasDestroyerDefHasDestroyerWW2v2TrueSneakAttackTrueFalse() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, true, true, true, true),\n+        MustFightBattle.ReturnFire.ALL,\n+        false);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is true, then attacker>standard>defender\")\n+  void firstStrikeOrderAttHasDestroyerDefHasDestroyerWW2v2FalseSneakAttackTrue() {\n+    assertThatFirstStrikeStepOrder(\n+        givenFirstStrikeBattleSetup(true, true, false, true, false),\n+        List.of(\n+            FirstStrikeBattleStep.ATTACKER,\n+            FirstStrikeBattleStep.STANDARD,\n+            FirstStrikeBattleStep.DEFENDER));\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is true, then attacker has return fire all\")\n+  void firstStrikeAttackerReturnFireAttHasDestroyerDefHasDestroyerWW2v2FalseSneakAttackTrue() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, true, false, true, false),\n+        MustFightBattle.ReturnFire.ALL,\n+        true);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is true, then defender has return fire all\")\n+  void firstStrikeDefenderReturnFireAttHasDestroyerDefHasDestroyerWW2v2FalseSneakAttackTrue() {\n+    assertThatFirstStrikeReturnFireIs(\n+        givenFirstStrikeBattleSetup(true, true, false, true, false),\n+        MustFightBattle.ReturnFire.ALL,\n+        false);\n+  }\n+\n+  @Test\n+  @DisplayName(\n+      \"When attacker has a destroyer, defender has a destroyer, WW2v2 is false, \"\n+          + \"and DEFENDING_SUBS_SNEAK_ATTACK is false, then attacker>standard>defender\")\n+  void firstStrikeOrderAttHasDestroyerDefHasDestroyerWW2v2FalseSneakAttackFalse() {\n+    assertThatFirstStrikeStepOrder(", "originalCommit": "e05eee386dfee4b28a417bebd0978c6dfcdf3600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwNzk0NQ==", "url": "https://github.com/triplea-game/triplea/pull/6551#discussion_r436307945", "bodyText": "Yes, I had thought of parameterizing it.  I'll do that next time.", "author": "trevan", "createdAt": "2020-06-06T23:16:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwMjgzMQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "912f61a96b418b8ee7faa63d8166b8497c2e10e9", "url": "https://github.com/triplea-game/triplea/commit/912f61a96b418b8ee7faa63d8166b8497c2e10e9", "message": "Merge remote-tracking branch 'origin/master' into step-executables-unittest", "committedDate": "2020-06-06T22:28:21Z", "type": "commit"}]}