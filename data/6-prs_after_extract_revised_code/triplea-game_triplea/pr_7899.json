{"pr_number": 7899, "pr_title": "Allow AA to target all infrastructure", "pr_createdAt": "2020-10-14T04:28:08Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7899", "timeline": [{"oid": "9d2ff72fb8a64d8cb19c53650c61d129650c2a41", "url": "https://github.com/triplea-game/triplea/commit/9d2ff72fb8a64d8cb19c53650c61d129650c2a41", "message": "Allow all units in battle that can be hit by AA fire", "committedDate": "2020-10-13T15:23:04Z", "type": "commit"}, {"oid": "5747723e726b1081db12e1e9db84f190f77810f6", "url": "https://github.com/triplea-game/triplea/commit/5747723e726b1081db12e1e9db84f190f77810f6", "message": "Add unittests", "committedDate": "2020-10-14T04:18:44Z", "type": "commit"}, {"oid": "c1e928071561ad5b53e39733401deefdf13e63f2", "url": "https://github.com/triplea-game/triplea/commit/c1e928071561ad5b53e39733401deefdf13e63f2", "message": "Remove unnecessary qualified name", "committedDate": "2020-10-14T04:38:13Z", "type": "commit"}, {"oid": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b", "url": "https://github.com/triplea-game/triplea/commit/1da61fa850c1819a6db666d7e0a04fa0b6f5f18b", "message": "Remove test on excluding infrastructure since it isn't excluded anymore", "committedDate": "2020-10-16T17:45:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NDEyOA==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506974128", "bodyText": "Typo: unitTypeCanByHitByAaFire -> \"BeHitBy..\"", "author": "DanVanAtta", "createdAt": "2020-10-17T19:08:58Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/Matches.java", "diffHunk": "@@ -652,6 +652,23 @@ private Matches() {}\n     };\n   }\n \n+  /** Checks if the unit type can be hit with AA fire by one of the firingUnits */\n+  private static Predicate<UnitType> unitTypeCanByHitByAaFire(", "originalCommit": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "38e507bdee66ec5a40e61269bc8b6f905e85f1f4", "chunk": "diff --git a/game-core/src/main/java/games/strategy/triplea/delegate/Matches.java b/game-core/src/main/java/games/strategy/triplea/delegate/Matches.java\nindex 99274044f..df6ed45cb 100644\n--- a/game-core/src/main/java/games/strategy/triplea/delegate/Matches.java\n+++ b/game-core/src/main/java/games/strategy/triplea/delegate/Matches.java\n\n@@ -653,7 +653,7 @@ public final class Matches {\n   }\n \n   /** Checks if the unit type can be hit with AA fire by one of the firingUnits */\n-  private static Predicate<UnitType> unitTypeCanByHitByAaFire(\n+  private static Predicate<UnitType> unitTypeCanBeHitByAaFire(\n       final Collection<UnitType> firingUnits, final GameData gameData, final int battleRound) {\n     // make sure the aa firing units are valid for combat and during this round\n     final Collection<UnitType> aaFiringUnits =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NDQ0Ng==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506974446", "bodyText": "WDYT to pass the data from GameData to this method rather than passing GameData to it?\nGameData has a problem where it's passed everywhere and used by everything. That makes decoupling quite difficult, for example, testing involving with a game data almost always means doing a full blown integration test and loading an XML (which is extremely limiting as we may want to test perhaps 12 permutations of one element of game data for just one set of tests).\nAnyways, the less dependencies we can have on game data for now-  the better.", "author": "DanVanAtta", "createdAt": "2020-10-17T19:11:42Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/Matches.java", "diffHunk": "@@ -652,6 +652,23 @@ private Matches() {}\n     };\n   }\n \n+  /** Checks if the unit type can be hit with AA fire by one of the firingUnits */\n+  private static Predicate<UnitType> unitTypeCanByHitByAaFire(\n+      final Collection<UnitType> firingUnits, final GameData gameData, final int battleRound) {", "originalCommit": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI3MDQyNQ==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r507270425", "bodyText": "That would require changing UnitAttachment#getTargetsAa since this method just passes gameData to that method.  So for this PR, I don't think that is ok.", "author": "trevan", "createdAt": "2020-10-19T00:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NDQ0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "38e507bdee66ec5a40e61269bc8b6f905e85f1f4", "chunk": "diff --git a/game-core/src/main/java/games/strategy/triplea/delegate/Matches.java b/game-core/src/main/java/games/strategy/triplea/delegate/Matches.java\nindex 99274044f..df6ed45cb 100644\n--- a/game-core/src/main/java/games/strategy/triplea/delegate/Matches.java\n+++ b/game-core/src/main/java/games/strategy/triplea/delegate/Matches.java\n\n@@ -653,7 +653,7 @@ public final class Matches {\n   }\n \n   /** Checks if the unit type can be hit with AA fire by one of the firingUnits */\n-  private static Predicate<UnitType> unitTypeCanByHitByAaFire(\n+  private static Predicate<UnitType> unitTypeCanBeHitByAaFire(\n       final Collection<UnitType> firingUnits, final GameData gameData, final int battleRound) {\n     // make sure the aa firing units are valid for combat and during this round\n     final Collection<UnitType> aaFiringUnits =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NDY2MQ==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506974661", "bodyText": "Intermediate variables can perhaps help reduce the commentary. For example:\nvar isAaThatCanFireThisRound = unitType -> unitTypeIsAaForCombatOnly().and(unitTypeIsAaThatCanFireOnRound(battleRound);\n\nWDYT of using that technique to avoid the inline commentary? I think that is only needed for the more complex conditions, the simpler ones, the code might be able to just speak for itself.", "author": "DanVanAtta", "createdAt": "2020-10-17T19:13:48Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/Matches.java", "diffHunk": "@@ -2313,14 +2342,18 @@ private Matches() {}\n       final GamePlayer player,\n       final int battleRound,\n       final boolean includeAttackersThatCanNotMove,\n-      final boolean doNotIncludeBombardingSeaUnits) {\n+      final boolean doNotIncludeBombardingSeaUnits,\n+      final Collection<UnitType> firingUnits) {\n \n-    // Filter out anything like factories, or units that have no combat ability AND cannot be taken\n-    // casualty\n     final PredicateBuilder<UnitType> canBeInBattleBuilder =\n+        // remove infrastructure units\n         PredicateBuilder.of(unitTypeIsInfrastructure().negate())\n+            // unless it can support or fight\n             .or(unitTypeIsSupporterOrHasCombatAbility(attack, player))", "originalCommit": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NDgxOQ==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506974819", "bodyText": "For a long series of statements, having one comment to describe the general outcome and what is generally happening can be a good thing. Make it easier for a reader to know what to expect and makes it easier to see how each statement fits in to the overall outcome. Commenting each line though is more questionable and can speak to inarticulate code (which can be fixed by improving naming, intermediate variables, private helper methods, re-organizing methods).", "author": "DanVanAtta", "createdAt": "2020-10-17T19:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NDY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI3MTI0OQ==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r507271249", "bodyText": "I personally don't see the intermediate variables as being helpful in explaining what is happening.  I'll just move all the comments to above the definition of the canBeInBattleBuilder variable.", "author": "trevan", "createdAt": "2020-10-19T00:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NDY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQ4MDQ3NA==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r507480474", "bodyText": "Fair enough. When it comes to \"what is the code doing\" commentary, reducing that can help avoid coupling (meaning the code can be changed and the comments do not become out of date) and sometimes such commentary is being used as a bandaid for inexpressive code. There is a right balance though, some \"what is the code doing\"  commentary can really help set expectations of what a person is about to read and makes it easier to understand (easier to understand => faster to read => quicker to modify => and more comprehensive leads to fewer bugs)", "author": "DanVanAtta", "createdAt": "2020-10-19T05:42:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NDY2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "38e507bdee66ec5a40e61269bc8b6f905e85f1f4", "chunk": "diff --git a/game-core/src/main/java/games/strategy/triplea/delegate/Matches.java b/game-core/src/main/java/games/strategy/triplea/delegate/Matches.java\nindex 99274044f..df6ed45cb 100644\n--- a/game-core/src/main/java/games/strategy/triplea/delegate/Matches.java\n+++ b/game-core/src/main/java/games/strategy/triplea/delegate/Matches.java\n\n@@ -2345,15 +2345,14 @@ public final class Matches {\n       final boolean doNotIncludeBombardingSeaUnits,\n       final Collection<UnitType> firingUnits) {\n \n+    // remove infrastructure units unless it can support or fight\n+    // or it is AA that can fire this round\n+    // or it can be shot at by AA\n     final PredicateBuilder<UnitType> canBeInBattleBuilder =\n-        // remove infrastructure units\n         PredicateBuilder.of(unitTypeIsInfrastructure().negate())\n-            // unless it can support or fight\n             .or(unitTypeIsSupporterOrHasCombatAbility(attack, player))\n-            // or it is AA that can fire this round\n             .or(unitTypeIsAaForCombatOnly().and(unitTypeIsAaThatCanFireOnRound(battleRound)))\n-            // or it can be shot at by AA\n-            .or(unitTypeCanByHitByAaFire(firingUnits, player.getData(), battleRound));\n+            .or(unitTypeCanBeHitByAaFire(firingUnits, player.getData(), battleRound));\n \n     if (attack) {\n       if (!includeAttackersThatCanNotMove) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTA2Mw==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506975063", "bodyText": "side-note, not for thsi PR - this API could use work. From the looks of it, most of the parameters are not used. From a caller perspective, it's kind meaningless of an API call, the 'trues', 'falses', redundant call to isLand() are certainly minor problems.\nI comment on this as we should be careful to avoid making such problems worse when we can, but here I think the horse has already left the barn.", "author": "DanVanAtta", "createdAt": "2020-10-17T19:18:35Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/BattleCalculatorPanel.java", "diffHunk": "@@ -1336,7 +1336,8 @@ private void setAttackingUnits(final List<Unit> initialUnits) {\n         getAttacker(),\n         CollectionUtils.getMatches(\n             units,\n-            Matches.unitCanBeInBattle(true, isLand(), 1, hasMaxRounds(isLand(), data), false)),\n+            Matches.unitCanBeInBattle(\n+                true, isLand(), 1, hasMaxRounds(isLand(), data), false, List.of())),", "originalCommit": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTMwNg==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506975306", "bodyText": "givenGameData() is not as descriptive as one would hope. What is given about this game data? Can we say or require anything to be true about this game data? Though, I suspect the instantiation of any game data is something of a hack for game data being very difficult to mock (God class code-smell, we use it everywhere for everything.\nI'd recommend renaming this method to givenAnyGameData() perhaps to indicate that we require nothing other than an instantiated game data, otherwise any requirements of the data would either be specified as parameters or baked into the game data name. For example, givenGameDataWithUnits(...)", "author": "DanVanAtta", "createdAt": "2020-10-17T19:21:09Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/MatchesTest.java", "diffHunk": "@@ -254,4 +266,179 @@ void shouldNotMatchWhenSeaTerritoryIsUnownedAndDoesNotHaveTerritoryAttachment()\n       assertThat(newMatch(), notMatches(seaTerritory));\n     }\n   }\n+\n+  @Nested\n+  @ExtendWith(MockitoExtension.class)\n+  final class UnitCanBeInBattle {\n+\n+    @Mock GamePlayer player;\n+    GameData gameData;\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      gameData = givenGameData().build();", "originalCommit": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTUyMg==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506975522", "bodyText": "Looking at this further, perhaps calling it givenMockGameData().\nThough, ideally we would not need the object and any data from the game data would individually be passed to this class. In other words, game data is acting as a tuple with other objects. Rather than passing the tuple and grabbing the objects from the tuple, instead we can pass the individual objects from the tuple to where they are needed.", "author": "DanVanAtta", "createdAt": "2020-10-17T19:24:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI3MjQ3Ng==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r507272476", "bodyText": "I guess mockGameDataBuilder() would be a better name for it since that is what it does.  It creates a mock of GameData with some basic setup and then allows you to add functionality using a fluent syntax.  It isn't quite a \"builder\".\nI don't think the rename should be part of this PR, though.  It is used in quite a few of my unittests now.  It is how I create mocked GameData objects.", "author": "trevan", "createdAt": "2020-10-19T00:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTMwNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTczNw==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506975737", "bodyText": "Does this method need the other mocked elements of gameData, or do we mostly only need for the dice sides?\nI'd recommend to try and fully mock objects within the test method where reasonable, at least within a test so the test is more self contained. For example if another test required slightly different mocking of a game data, we'd suddenly have a conflict between that test and any other that depended on the mock.\nMore fundamentally it probably is better to break up the data needed from game data, use only that data, then you can pass those data objects as test parameters. For example, rather than passing a game data to get dice sides to another method, instead pass the dice sides value directly.", "author": "DanVanAtta", "createdAt": "2020-10-17T19:26:14Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/MatchesTest.java", "diffHunk": "@@ -254,4 +266,179 @@ void shouldNotMatchWhenSeaTerritoryIsUnownedAndDoesNotHaveTerritoryAttachment()\n       assertThat(newMatch(), notMatches(seaTerritory));\n     }\n   }\n+\n+  @Nested\n+  @ExtendWith(MockitoExtension.class)\n+  final class UnitCanBeInBattle {\n+\n+    @Mock GamePlayer player;\n+    GameData gameData;\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      gameData = givenGameData().build();\n+    }\n+\n+    @Test\n+    void infrastructureShouldNormallyNotBeInBattle() {\n+      when(gameData.getDiceSides()).thenReturn(6);", "originalCommit": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI3NTQ1NA==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r507275454", "bodyText": "To run, the test needs other aspects of gameData.  That's because Matches#unitTypeCanBeInBattle will call Matches#unitTypeIsSupporterOrHasCombatAbility which in turn calls UnitAttachment#getAttack which will then call TechAbilityAttachment#getAttackBonus with the gameData that is on the UnitAttachment.  And it is this gameData that it will then look for tech abilities as well as check the dice sides.", "author": "trevan", "createdAt": "2020-10-19T00:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQ4MTUwMg==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r507481502", "bodyText": "Okay, I think we are then already started down a path where we have a 'god mock' of a 'god class'. Let's watch out for this going forward. I think the thing for us to do more of us avoid passing game data and instead pass the data that is needed instead. For example, if units did not have a reference to game data, it would be far easier to instantiate them and use in testing.", "author": "DanVanAtta", "createdAt": "2020-10-19T05:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc5MTI4NA==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r507791284", "bodyText": "I did a quick test where I removed the extend in Unit so that it doesn't have a GameData.  There were not as many compile errors as I would expect.\nDo you have a problem with giving Unit a reference to the GameProperties?  That is what most of the errors are related to.", "author": "trevan", "createdAt": "2020-10-19T14:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5ODY2NA==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r507898664", "bodyText": "That is on the right path. Where I'd like to get is that we have one object called a \"MapData\" or something like that, that is just the data parsed from a map. \"MapData\" would then be an initial state. A \"GameData\" would be the final state of the game. A \"GameData\" would be a \"MapData\" plus N changes, if a game is new, the number of changes is zero and \"GameData\" and \"MapData\" would be equivalent.\nWith that, we need to think a bit about how the core data model is going to be structured.\nIn the short term, removing GameData reference for GameProperties sounds like the right path.\nThough, does that work for serialization? IIRC the game data reference is to mark/enable the object for serialization into save games.", "author": "DanVanAtta", "createdAt": "2020-10-19T16:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTczNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTg1NA==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506975854", "bodyText": "A parameter object I think would help a lot here, this parameter list is not very meaningful:\ntrue, true, 1, false, List.of()\nI wonder a bit as well why the parameter list is not Matches.unitTypeCanBeInBattleForRound( < UnitType > , <battleRound:Int> )", "author": "DanVanAtta", "createdAt": "2020-10-17T19:27:58Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/MatchesTest.java", "diffHunk": "@@ -254,4 +266,179 @@ void shouldNotMatchWhenSeaTerritoryIsUnownedAndDoesNotHaveTerritoryAttachment()\n       assertThat(newMatch(), notMatches(seaTerritory));\n     }\n   }\n+\n+  @Nested\n+  @ExtendWith(MockitoExtension.class)\n+  final class UnitCanBeInBattle {\n+\n+    @Mock GamePlayer player;\n+    GameData gameData;\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      gameData = givenGameData().build();\n+    }\n+\n+    @Test\n+    void infrastructureShouldNormallyNotBeInBattle() {\n+      when(gameData.getDiceSides()).thenReturn(6);\n+      final UnitType unitType = new UnitType(\"infrastructure\", gameData);\n+      final UnitAttachment unitAttachment =\n+          new UnitAttachment(\"infrastructure\", unitType, gameData);\n+      unitAttachment.setIsInfrastructure(true);\n+      unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+      final Unit unit = unitType.create(1, player, true).get(0);\n+\n+      assertThat(\n+          \"An infrastructure unit normally can not be in battle\",\n+          Matches.unitCanBeInBattle(true, true, 1, false, List.of()).test(unit),", "originalCommit": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI3NjUyMQ==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r507276521", "bodyText": "Agreed.  Matches.unitCanBeInBattle is a complicated matcher that is used in a lot of places.  You'll notice there are 4 overloaded versions of it with different number of parameters.  I first thought about trying to isolate just what I want but it changed too many things that I wasn't sure of.", "author": "trevan", "createdAt": "2020-10-19T00:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTg1NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTk1Ng==", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506975956", "bodyText": "The assert comments are good and pretty reasonable setup  \ud83d\udc4d", "author": "DanVanAtta", "createdAt": "2020-10-17T19:29:32Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/MatchesTest.java", "diffHunk": "@@ -254,4 +266,179 @@ void shouldNotMatchWhenSeaTerritoryIsUnownedAndDoesNotHaveTerritoryAttachment()\n       assertThat(newMatch(), notMatches(seaTerritory));\n     }\n   }\n+\n+  @Nested\n+  @ExtendWith(MockitoExtension.class)\n+  final class UnitCanBeInBattle {\n+\n+    @Mock GamePlayer player;\n+    GameData gameData;\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      gameData = givenGameData().build();\n+    }\n+\n+    @Test\n+    void infrastructureShouldNormallyNotBeInBattle() {\n+      when(gameData.getDiceSides()).thenReturn(6);\n+      final UnitType unitType = new UnitType(\"infrastructure\", gameData);\n+      final UnitAttachment unitAttachment =\n+          new UnitAttachment(\"infrastructure\", unitType, gameData);\n+      unitAttachment.setIsInfrastructure(true);\n+      unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+      final Unit unit = unitType.create(1, player, true).get(0);\n+\n+      assertThat(\n+          \"An infrastructure unit normally can not be in battle\",\n+          Matches.unitCanBeInBattle(true, true, 1, false, List.of()).test(unit),\n+          is(false));\n+    }\n+\n+    @Test\n+    void infrastructureWithAttackCanBeInBattleWhenAttacking() {\n+      when(gameData.getDiceSides()).thenReturn(6);\n+      final UnitType unitType = new UnitType(\"infrastructure\", gameData);\n+      final UnitAttachment unitAttachment =\n+          new UnitAttachment(\"infrastructure\", unitType, gameData);\n+      unitAttachment.setIsInfrastructure(true);\n+      unitAttachment.setAttack(1);\n+      unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+      final Unit unit = unitType.create(1, player, true).get(0);\n+\n+      assertThat(\n+          \"An infrastructure unit with attack can be in battle when it is attacking\",\n+          Matches.unitCanBeInBattle(true, true, 1, false, List.of()).test(unit),\n+          is(true));\n+    }\n+\n+    @Test\n+    void infrastructureWithAttackCanNotBeInBattleWhenDefending() {\n+      when(gameData.getDiceSides()).thenReturn(6);\n+      final UnitType unitType = new UnitType(\"infrastructure\", gameData);\n+      final UnitAttachment unitAttachment =\n+          new UnitAttachment(\"infrastructure\", unitType, gameData);\n+      unitAttachment.setIsInfrastructure(true);\n+      unitAttachment.setAttack(1);\n+      unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+      final Unit unit = unitType.create(1, player, true).get(0);\n+\n+      assertThat(\n+          \"An infrastructure unit with attack can not be in battle when it is attacking\",\n+          Matches.unitCanBeInBattle(false, true, 1, false, List.of()).test(unit),\n+          is(false));\n+    }\n+\n+    @Test\n+    void infrastructureWithDefenseCanBeInBattleWhenDefending() {\n+      when(gameData.getDiceSides()).thenReturn(6);\n+      final UnitType unitType = new UnitType(\"infrastructure\", gameData);\n+      final UnitAttachment unitAttachment =\n+          new UnitAttachment(\"infrastructure\", unitType, gameData);\n+      unitAttachment.setIsInfrastructure(true);\n+      unitAttachment.setDefense(1);\n+      unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+      final Unit unit = unitType.create(1, player, true).get(0);\n+\n+      assertThat(\n+          \"An infrastructure unit with defense can be in battle when it is defending\",\n+          Matches.unitCanBeInBattle(false, true, 1, false, List.of()).test(unit),\n+          is(true));\n+    }\n+\n+    @Test\n+    void infrastructureWithDefenseCanNotBeInBattleWhenAttacking() {\n+      when(gameData.getDiceSides()).thenReturn(6);\n+      final UnitType unitType = new UnitType(\"infrastructure\", gameData);\n+      final UnitAttachment unitAttachment =\n+          new UnitAttachment(\"infrastructure\", unitType, gameData);\n+      unitAttachment.setIsInfrastructure(true);\n+      unitAttachment.setDefense(1);\n+      unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+      final Unit unit = unitType.create(1, player, true).get(0);\n+\n+      assertThat(\n+          \"An infrastructure unit with defense can not be in battle when it is attacking\",", "originalCommit": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "38e507bdee66ec5a40e61269bc8b6f905e85f1f4", "url": "https://github.com/triplea-game/triplea/commit/38e507bdee66ec5a40e61269bc8b6f905e85f1f4", "message": "Fix mispelling of unitTypeCanBeHitByAaFire and condense comments", "committedDate": "2020-10-19T00:24:31Z", "type": "commit"}]}