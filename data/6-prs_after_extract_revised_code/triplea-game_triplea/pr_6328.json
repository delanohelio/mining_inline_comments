{"pr_number": 6328, "pr_title": "Simplify ConcurrentBattleCalculator code", "pr_createdAt": "2020-04-25T13:04:17Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6328", "timeline": [{"oid": "7ba8f68d6fb922fc607cd441ab3f669a7fafb563", "url": "https://github.com/triplea-game/triplea/commit/7ba8f68d6fb922fc607cd441ab3f669a7fafb563", "message": "Simplify concurrent battle calculator", "committedDate": "2020-04-17T16:27:45Z", "type": "commit"}, {"oid": "e6acab186bed8a7828e62f6f8cafd3e38f4d3bf3", "url": "https://github.com/triplea-game/triplea/commit/e6acab186bed8a7828e62f6f8cafd3e38f4d3bf3", "message": "Fix run count", "committedDate": "2020-04-17T16:39:19Z", "type": "commit"}, {"oid": "374a7a62c8aa74e30b839887b23e0154dd9ab1db", "url": "https://github.com/triplea-game/triplea/commit/374a7a62c8aa74e30b839887b23e0154dd9ab1db", "message": "Fix time counter", "committedDate": "2020-04-17T16:41:32Z", "type": "commit"}, {"oid": "130676e8f6813cfa6635eddfcd10a84c541c3e00", "url": "https://github.com/triplea-game/triplea/commit/130676e8f6813cfa6635eddfcd10a84c541c3e00", "message": "Implement cancel ability", "committedDate": "2020-04-17T18:15:48Z", "type": "commit"}, {"oid": "daa29f5cc1496a14599f1d98e41d78ded1b1d4ba", "url": "https://github.com/triplea-game/triplea/commit/daa29f5cc1496a14599f1d98e41d78ded1b1d4ba", "message": "Properly revert changes", "committedDate": "2020-04-17T18:25:39Z", "type": "commit"}, {"oid": "0127f7963505e063ccd90c75778b3a152fb4a103", "url": "https://github.com/triplea-game/triplea/commit/0127f7963505e063ccd90c75778b3a152fb4a103", "message": "Simplify interface structure", "committedDate": "2020-04-17T18:27:57Z", "type": "commit"}, {"oid": "8c9975e579106d1ab99e627c1e0887409d1bf25e", "url": "https://github.com/triplea-game/triplea/commit/8c9975e579106d1ab99e627c1e0887409d1bf25e", "message": "Formatting", "committedDate": "2020-04-17T18:28:12Z", "type": "commit"}, {"oid": "cc82a1dfb5fcc6c357aae74f6648ae07b1faa083", "url": "https://github.com/triplea-game/triplea/commit/cc82a1dfb5fcc6c357aae74f6648ae07b1faa083", "message": "Synchronize calls properly\n\nThis commit makes ConcurrentBattleCalculator ThreadSafe again", "committedDate": "2020-04-25T11:22:43Z", "type": "commit"}, {"oid": "65d05c996e3bb5f9df7ffa923c16b0939f3f94be", "url": "https://github.com/triplea-game/triplea/commit/65d05c996e3bb5f9df7ffa923c16b0939f3f94be", "message": "Extract method calls to dedicated helper methods", "committedDate": "2020-04-25T11:29:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA1OTI5Mg==", "url": "https://github.com/triplea-game/triplea/pull/6328#discussion_r415059292", "bodyText": "Method createBattleCalcWorker has 28 lines of code (exceeds 25 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T13:05:30Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java", "diffHunk": "@@ -70,393 +65,181 @@ public ConcurrentBattleCalculator(final String threadNamePrefix) {\n             MAX_THREADS,\n             new ThreadFactoryBuilder()\n                 .setDaemon(true)\n-                .setNameFormat(threadNamePrefix + \" ConcurrentOddsCalculator Worker-%d\")\n+                .setNameFormat(threadNamePrefix + \" ConcurrentBattleCalculator Worker-%d\")\n                 .build());\n     this.dataLoadedAction = dataLoadedAction;\n   }\n \n   @Override\n   public void setGameData(final GameData data) {\n-    // increment so that a new calc doesn't take place (since they all wait on this latch)\n-    latchSetData.increment();\n-    // cancel any current setting of data\n-    cancelCurrentOperation.decrementAndGet();\n-    // cancel any existing calcing (it won't stop immediately, just quicker)\n-    cancel();\n-    synchronized (mutexSetGameData) {\n-      try {\n-        // since setting data takes place on a different thread, this is our token. wait on it since\n-        latchWorkerThreadsCreation.await();\n-        // we could have exited the synchronized block already.\n-      } catch (final InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-      cancel();\n-      isDataSet = false;\n-      isCalcSet = false;\n-      if (data == null || isShutDown) {\n-        workers.clear();\n-        cancelCurrentOperation.incrementAndGet();\n-        // allow calcing and other stuff to go ahead\n-        latchSetData.countDown();\n-      } else {\n-        cancelCurrentOperation.incrementAndGet();\n-        // increment our token, so that we can set the data in a different thread and return from\n-        // this one\n-        latchWorkerThreadsCreation.increment();\n-        executor.execute(() -> createWorkers(data));\n-      }\n+    synchronized (mutex) {\n+      bytes = data == null ? new byte[0] : GameDataUtils.serializeGameDataWithoutHistory(data);\n+      dataLoadedAction.run();\n     }\n   }\n \n   @Override\n   public int getThreadCount() {\n-    return currentThreads;\n-  }\n-\n-  // use both time and memory left to determine how many copies to make\n-  private static int getThreadsToUse(\n-      final long timeToCopyInMillis, final long memoryUsedBeforeCopy) {\n-    if (timeToCopyInMillis > 20000 || MAX_THREADS == 1) {\n-      // just use 1 thread if we took more than 20 seconds to copy\n-      return 1;\n-    }\n-    final Runtime runtime = Runtime.getRuntime();\n-    final long usedMemoryAfterCopy = runtime.totalMemory() - runtime.freeMemory();\n-    // we cannot predict how the gc works\n-    final long memoryLeftBeforeMax =\n-        runtime.maxMemory() - Math.max(usedMemoryAfterCopy, memoryUsedBeforeCopy);\n-    // make sure it is a decent size\n-    final long memoryUsedByCopy = Math.max(100000, (usedMemoryAfterCopy - memoryUsedBeforeCopy));\n-    // regardless of how stupid the gc is we leave some memory left over just in case\n-    final int numberOfTimesWeCanCopyMax =\n-        Math.max(1, (int) Math.min(Integer.MAX_VALUE, (memoryLeftBeforeMax / memoryUsedByCopy)));\n-\n-    if (timeToCopyInMillis > 3000) {\n-      // use half the number of threads available if we took more than 3 seconds to copy\n-      return Math.min(numberOfTimesWeCanCopyMax, Math.max(1, (MAX_THREADS / 2)));\n-    }\n-    // use all threads\n-    return Math.min(numberOfTimesWeCanCopyMax, MAX_THREADS);\n-  }\n-\n-  private void createWorkers(final GameData data) {\n-    workers.clear();\n-    if (data != null && cancelCurrentOperation.get() >= 0) {\n-      // see how long 1 copy takes (some games can get REALLY big)\n-      final long startTime = System.currentTimeMillis();\n-      final long startMemory =\n-          Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n-      final GameData newData;\n-      try {\n-        // make first copy, then release lock on it so game can continue (ie: we don't want to lock\n-        // on it while we copy\n-        // it 16 times, when once is enough) don't let the data change while we make the first copy\n-        data.acquireWriteLock();\n-        newData = GameDataUtils.cloneGameDataWithoutHistory(data, false);\n-      } finally {\n-        data.releaseWriteLock();\n-      }\n-      currentThreads = getThreadsToUse((System.currentTimeMillis() - startTime), startMemory);\n-      try {\n-        // make sure all workers are using the same data\n-        newData.acquireReadLock();\n-        int i = 0;\n-        // we are already in 1 executor thread, so we have MAX_THREADS-1 threads left to use\n-        if (currentThreads <= 2 || MAX_THREADS <= 2) {\n-          // if 2 or fewer threads, do not multi-thread the copying (we have already copied it once\n-          // above, so at most\n-          // only 1 more copy to make)\n-          while (cancelCurrentOperation.get() >= 0 && i < currentThreads) {\n-            // the last one will use our already copied data from above, without copying it again\n-            workers.add(new BattleCalculator(newData, (currentThreads == ++i)));\n-          }\n-        } else { // multi-thread our copying, cus why the heck not (it increases the speed of\n-          // copying by about double)\n-          final CountDownLatch workerLatch = new CountDownLatch(currentThreads - 1);\n-          while (i < (currentThreads - 1)) {\n-            ++i;\n-            executor.execute(\n-                () -> {\n-                  if (cancelCurrentOperation.get() >= 0) {\n-                    workers.add(new BattleCalculator(newData, false));\n-                  }\n-                  workerLatch.countDown();\n-                });\n-          }\n-          // the last one will use our already copied data from above, without copying it again\n-          workers.add(new BattleCalculator(newData, true));\n-          Interruptibles.await(workerLatch);\n-        }\n-      } finally {\n-        newData.releaseReadLock();\n-      }\n-    }\n-    if (cancelCurrentOperation.get() < 0 || data == null) {\n-      // we could have cancelled while setting data, so clear the workers again if so\n-      workers.clear();\n-      isDataSet = false;\n-    } else {\n-      // should make sure that all workers have their game data set before we can call calculate and\n-      // other things\n-      isDataSet = true;\n-      dataLoadedAction.run();\n-    }\n-    // allow setting new data to take place if it is waiting on us\n-    latchWorkerThreadsCreation.countDown();\n-    // allow calcing and other stuff to go ahead\n-    latchSetData.countDown();\n+    return MAX_THREADS;\n   }\n \n   @Override\n   public void shutdown() {\n     isShutDown = true;\n-    cancelCurrentOperation.set(Integer.MIN_VALUE / 2);\n     cancel();\n     executor.shutdown();\n   }\n \n-  private void awaitLatch() {\n-    try {\n-      // there is a small chance calculate or setCalculateData or something could be called in\n-      // between calls to\n-      // setGameData\n-      latchSetData.await();\n-    } catch (final InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-    }\n-  }\n-\n+  /**\n+   * Concurrently calculates odds using the OddsCalculatorWorker. It uses Executor to process the\n+   * results. Then waits for all the future results and combines them together.\n+   */\n   @Override\n-  public void setCalculateData(\n+  public AggregateResults calculate(\n       final GamePlayer attacker,\n       final GamePlayer defender,\n       final Territory location,\n       final Collection<Unit> attacking,\n       final Collection<Unit> defending,\n       final Collection<Unit> bombarding,\n       final Collection<TerritoryEffect> territoryEffects,\n-      final int initialRunCount) {\n-    synchronized (mutexCalcIsRunning) {\n-      awaitLatch();\n-      isCalcSet = false;\n-      int runCount = initialRunCount;\n-      final int workerNum = workers.size();\n-      final int workerRunCount = Math.max(1, (runCount / Math.max(1, workerNum)));\n-      for (final BattleCalculator worker : workers) {\n-        if (!isDataSet || isShutDown) {\n-          // we could have attempted to set a new game data, while the old one was still being set,\n-          // causing it to abort\n-          // with null data\n-          return;\n-        }\n-        worker.setCalculateData(\n-            attacker,\n-            defender,\n-            location,\n-            attacking,\n-            defending,\n-            bombarding,\n-            territoryEffects,\n-            (runCount <= 0 ? 0 : workerRunCount));\n-        runCount -= workerRunCount;\n-      }\n-      if (!isDataSet || isShutDown || workerNum <= 0) {\n-        return;\n-      }\n-      isCalcSet = true;\n-    }\n-  }\n-\n-  /**\n-   * Concurrently calculates odds using the OddsCalculatorWorker. It uses Executor to process the\n-   * results. Then waits for all the future results and combines them together.\n-   */\n-  @Override\n-  public AggregateResults calculate() throws IllegalStateException {\n-    synchronized (mutexCalcIsRunning) {\n-      awaitLatch();\n-      final long start = System.currentTimeMillis();\n-      // Create worker thread pool and start all workers\n-      int totalRunCount = 0;\n-      final List<Future<AggregateResults>> list = new ArrayList<>();\n-      for (final BattleCalculator worker : workers) {\n-        if (!getIsReady()) {\n-          // we could have attempted to set a new game data, while the old one was still being set,\n-          // causing it to abort\n-          // with null data\n-          return new AggregateResults(0);\n-        }\n-        if (!worker.getIsReady()) {\n-          throw new IllegalStateException(\"Called calculate before setting calculate data!\");\n-        }\n-        if (worker.getRunCount() > 0) {\n-          totalRunCount += worker.getRunCount();\n-          final Future<AggregateResults> workerResult = executor.submit(worker);\n-          list.add(workerResult);\n-        }\n-      }\n-      // Wait for all worker futures to complete and combine results\n-      final AggregateResults results = new AggregateResults(totalRunCount);\n-      final Set<InterruptedException> interruptExceptions = new HashSet<>();\n-      final Map<String, Set<ExecutionException>> executionExceptions = new HashMap<>();\n-      for (final Future<AggregateResults> future : list) {\n-        try {\n-          final AggregateResults result = future.get();\n-          results.addResults(result.getResults());\n-        } catch (final InterruptedException e) {\n-          Thread.currentThread().interrupt();\n-          interruptExceptions.add(e);\n-        } catch (final ExecutionException e) {\n-          final String cause = e.getCause().getLocalizedMessage();\n-          Set<ExecutionException> exceptions = executionExceptions.get(cause);\n-          if (exceptions == null) {\n-            exceptions = new HashSet<>();\n-          }\n-          exceptions.add(e);\n-          executionExceptions.put(cause, exceptions);\n-        }\n-      }\n-      // we don't want to scare the user with 8+ errors all for the same thing\n-      if (!interruptExceptions.isEmpty()) {\n-        log.log(\n-            Level.SEVERE,\n-            interruptExceptions.size() + \" Battle results workers interrupted\",\n-            interruptExceptions.iterator().next());\n-      }\n-      if (!executionExceptions.isEmpty()) {\n-        Exception e = null;\n-        for (final Set<ExecutionException> entry : executionExceptions.values()) {\n-          if (!entry.isEmpty()) {\n-            e = entry.iterator().next();\n-            log.log(\n-                Level.SEVERE,\n-                entry.size() + \" Battle results workers aborted by exception\",\n-                e.getCause());\n-          }\n-        }\n-        if (e != null) {\n-          throw new IllegalStateException(e.getCause());\n-        }\n-      }\n-      results.setTime(System.currentTimeMillis() - start);\n-      return results;\n-    }\n-  }\n-\n-  @Override\n-  public AggregateResults setCalculateDataAndCalculate(\n+      final int runCount)\n+      throws IllegalStateException {\n+    Preconditions.checkState(!isShutDown, \"ConcurrentBattleCalculator is already shut down\");\n+    Preconditions.checkState(bytes.length != 0, \"Data has not been set yet.\");\n+    final long start = System.currentTimeMillis();\n+    final List<Future<AggregateResults>> results = new ArrayList<>();\n+    final int runsPerWorker = runCount / MAX_THREADS;\n+    synchronized (mutex) {\n+      int remainingRuns = runCount;\n+      while (remainingRuns > 0) {\n+        final int individualRemaining = Math.min(remainingRuns, runsPerWorker);\n+        remainingRuns -= runsPerWorker;\n+        results.add(\n+            createBattleCalcWorker(\n+                attacker,\n+                defender,\n+                location,\n+                attacking,\n+                defending,\n+                bombarding,\n+                territoryEffects,\n+                individualRemaining));\n+      }\n+    }\n+    final AggregateResults result = aggregateResults(results, runsPerWorker);\n+    result.setTime(System.currentTimeMillis() - start);\n+    return result;\n+  }\n+\n+  private Future<AggregateResults> createBattleCalcWorker(", "originalCommit": "65d05c996e3bb5f9df7ffa923c16b0939f3f94be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e9468eaa1ed476b459b5adf6ce851de8ebe4519", "chunk": "diff --git a/game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java b/game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java\nindex 1d58b7eacd..38416594f6 100644\n--- a/game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java\n+++ b/game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java\n\n@@ -141,7 +141,7 @@ public class ConcurrentBattleCalculator implements IBattleCalculator {\n       final Collection<Unit> bombarding,\n       final Collection<TerritoryEffect> territoryEffects,\n       final int runs) {\n-    BattleCalculator calculator = new BattleCalculator();\n+    final BattleCalculator calculator = new BattleCalculator();\n     calculator.setKeepOneAttackingLandUnit(keepOneAttackingLandUnit);\n     calculator.setAmphibious(amphibious);\n     calculator.setRetreatAfterRound(retreatAfterRound);\n"}}, {"oid": "1e9468eaa1ed476b459b5adf6ce851de8ebe4519", "url": "https://github.com/triplea-game/triplea/commit/1e9468eaa1ed476b459b5adf6ce851de8ebe4519", "message": "Add final keywords", "committedDate": "2020-04-25T13:25:01Z", "type": "commit"}, {"oid": "a85fc5ec23fb5c03a6559cda1b5518b2a678c3c6", "url": "https://github.com/triplea-game/triplea/commit/a85fc5ec23fb5c03a6559cda1b5518b2a678c3c6", "message": "Ensure MAX_THREAD amount is respected", "committedDate": "2020-04-25T13:42:24Z", "type": "commit"}, {"oid": "4784f9ca997ea9998e2dc6cad171a21eaeadf956", "url": "https://github.com/triplea-game/triplea/commit/4784f9ca997ea9998e2dc6cad171a21eaeadf956", "message": "Remove unused annotation", "committedDate": "2020-04-25T13:43:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExNTM3MQ==", "url": "https://github.com/triplea-game/triplea/pull/6328#discussion_r415115371", "bodyText": "This is an interesting way to reduce the game data serialization size. I've been thinking we'll want to eventually have a param object for calculations that has a copy of just the data it needs. In the meantime this is interesting to move us in that direction.", "author": "DanVanAtta", "createdAt": "2020-04-25T18:19:33Z", "path": "game-core/src/main/java/games/strategy/engine/framework/GameDataUtils.java", "diffHunk": "@@ -28,6 +28,20 @@ public static GameData cloneGameDataWithoutHistory(\n     return dataCopy;\n   }\n \n+  public static byte[] serializeGameDataWithoutHistory(final GameData data) {", "originalCommit": "4784f9ca997ea9998e2dc6cad171a21eaeadf956", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExODk0MA==", "url": "https://github.com/triplea-game/triplea/pull/6328#discussion_r415118940", "bodyText": "In an ideal world this \"copy\" process would be super cheap to do, so that we don't have to roll back changes manually after each simulation run, but could just create a new copy instead.\nThe benefit of this intermediate solution is that there's absolutely no locking involved once we have the byte array.\nThis way all threads can create their own instance of the GameData independent of each other.", "author": "RoiEXLab", "createdAt": "2020-04-25T18:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExNTM3MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExNjkzNw==", "url": "https://github.com/triplea-game/triplea/pull/6328#discussion_r415116937", "bodyText": "side-note, it seems questionable to return MAX_THREADs and to also use that same constant in this class. It looks like this 'get' is only used for display purposes. When multi-threading of the battle calc was brand new, made more sense. Now I'm more thinking it's an implementation detail that the calc is multi-threaded and we don't really need to tell the user that (it's not important to them, only that the calc completes quickly and accurately).  CC: @ron-murhammer\nIn that case, if we remove that, we could remove this interface method and implementation.", "author": "DanVanAtta", "createdAt": "2020-04-25T18:28:35Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java", "diffHunk": "@@ -70,393 +64,182 @@ public ConcurrentBattleCalculator(final String threadNamePrefix) {\n             MAX_THREADS,\n             new ThreadFactoryBuilder()\n                 .setDaemon(true)\n-                .setNameFormat(threadNamePrefix + \" ConcurrentOddsCalculator Worker-%d\")\n+                .setNameFormat(threadNamePrefix + \" ConcurrentBattleCalculator Worker-%d\")\n                 .build());\n     this.dataLoadedAction = dataLoadedAction;\n   }\n \n   @Override\n   public void setGameData(final GameData data) {\n-    // increment so that a new calc doesn't take place (since they all wait on this latch)\n-    latchSetData.increment();\n-    // cancel any current setting of data\n-    cancelCurrentOperation.decrementAndGet();\n-    // cancel any existing calcing (it won't stop immediately, just quicker)\n-    cancel();\n-    synchronized (mutexSetGameData) {\n-      try {\n-        // since setting data takes place on a different thread, this is our token. wait on it since\n-        latchWorkerThreadsCreation.await();\n-        // we could have exited the synchronized block already.\n-      } catch (final InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-      cancel();\n-      isDataSet = false;\n-      isCalcSet = false;\n-      if (data == null || isShutDown) {\n-        workers.clear();\n-        cancelCurrentOperation.incrementAndGet();\n-        // allow calcing and other stuff to go ahead\n-        latchSetData.countDown();\n-      } else {\n-        cancelCurrentOperation.incrementAndGet();\n-        // increment our token, so that we can set the data in a different thread and return from\n-        // this one\n-        latchWorkerThreadsCreation.increment();\n-        executor.execute(() -> createWorkers(data));\n-      }\n+    synchronized (mutex) {\n+      bytes = data == null ? new byte[0] : GameDataUtils.serializeGameDataWithoutHistory(data);\n+      dataLoadedAction.run();\n     }\n   }\n \n   @Override\n   public int getThreadCount() {\n-    return currentThreads;\n-  }\n-\n-  // use both time and memory left to determine how many copies to make\n-  private static int getThreadsToUse(\n-      final long timeToCopyInMillis, final long memoryUsedBeforeCopy) {\n-    if (timeToCopyInMillis > 20000 || MAX_THREADS == 1) {\n-      // just use 1 thread if we took more than 20 seconds to copy\n-      return 1;\n-    }\n-    final Runtime runtime = Runtime.getRuntime();\n-    final long usedMemoryAfterCopy = runtime.totalMemory() - runtime.freeMemory();\n-    // we cannot predict how the gc works\n-    final long memoryLeftBeforeMax =\n-        runtime.maxMemory() - Math.max(usedMemoryAfterCopy, memoryUsedBeforeCopy);\n-    // make sure it is a decent size\n-    final long memoryUsedByCopy = Math.max(100000, (usedMemoryAfterCopy - memoryUsedBeforeCopy));\n-    // regardless of how stupid the gc is we leave some memory left over just in case\n-    final int numberOfTimesWeCanCopyMax =\n-        Math.max(1, (int) Math.min(Integer.MAX_VALUE, (memoryLeftBeforeMax / memoryUsedByCopy)));\n-\n-    if (timeToCopyInMillis > 3000) {\n-      // use half the number of threads available if we took more than 3 seconds to copy\n-      return Math.min(numberOfTimesWeCanCopyMax, Math.max(1, (MAX_THREADS / 2)));\n-    }\n-    // use all threads\n-    return Math.min(numberOfTimesWeCanCopyMax, MAX_THREADS);\n-  }\n-\n-  private void createWorkers(final GameData data) {\n-    workers.clear();\n-    if (data != null && cancelCurrentOperation.get() >= 0) {\n-      // see how long 1 copy takes (some games can get REALLY big)\n-      final long startTime = System.currentTimeMillis();\n-      final long startMemory =\n-          Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n-      final GameData newData;\n-      try {\n-        // make first copy, then release lock on it so game can continue (ie: we don't want to lock\n-        // on it while we copy\n-        // it 16 times, when once is enough) don't let the data change while we make the first copy\n-        data.acquireWriteLock();\n-        newData = GameDataUtils.cloneGameDataWithoutHistory(data, false);\n-      } finally {\n-        data.releaseWriteLock();\n-      }\n-      currentThreads = getThreadsToUse((System.currentTimeMillis() - startTime), startMemory);\n-      try {\n-        // make sure all workers are using the same data\n-        newData.acquireReadLock();\n-        int i = 0;\n-        // we are already in 1 executor thread, so we have MAX_THREADS-1 threads left to use\n-        if (currentThreads <= 2 || MAX_THREADS <= 2) {\n-          // if 2 or fewer threads, do not multi-thread the copying (we have already copied it once\n-          // above, so at most\n-          // only 1 more copy to make)\n-          while (cancelCurrentOperation.get() >= 0 && i < currentThreads) {\n-            // the last one will use our already copied data from above, without copying it again\n-            workers.add(new BattleCalculator(newData, (currentThreads == ++i)));\n-          }\n-        } else { // multi-thread our copying, cus why the heck not (it increases the speed of\n-          // copying by about double)\n-          final CountDownLatch workerLatch = new CountDownLatch(currentThreads - 1);\n-          while (i < (currentThreads - 1)) {\n-            ++i;\n-            executor.execute(\n-                () -> {\n-                  if (cancelCurrentOperation.get() >= 0) {\n-                    workers.add(new BattleCalculator(newData, false));\n-                  }\n-                  workerLatch.countDown();\n-                });\n-          }\n-          // the last one will use our already copied data from above, without copying it again\n-          workers.add(new BattleCalculator(newData, true));\n-          Interruptibles.await(workerLatch);\n-        }\n-      } finally {\n-        newData.releaseReadLock();\n-      }\n-    }\n-    if (cancelCurrentOperation.get() < 0 || data == null) {\n-      // we could have cancelled while setting data, so clear the workers again if so\n-      workers.clear();\n-      isDataSet = false;\n-    } else {\n-      // should make sure that all workers have their game data set before we can call calculate and\n-      // other things\n-      isDataSet = true;\n-      dataLoadedAction.run();\n-    }\n-    // allow setting new data to take place if it is waiting on us\n-    latchWorkerThreadsCreation.countDown();\n-    // allow calcing and other stuff to go ahead\n-    latchSetData.countDown();\n+    return MAX_THREADS;", "originalCommit": "4784f9ca997ea9998e2dc6cad171a21eaeadf956", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTEyMDgxOQ==", "url": "https://github.com/triplea-game/triplea/pull/6328#discussion_r415120819", "bodyText": "Good Point. It sounds like something #6329 should include, so I'd rather make a change there and merge this PR as-is.\nThis count is currently used for the loading screen where it says \"Calculating Odds (X Threads)\" or something similar. I think displaying the thread count is a good explanation/excuse for the high CPU usage the \"BattleCalculator\" uses. (My Laptop has \"only\" 4 cores, so it's definitely noticeable that everything gets slower once the simulation runs).\nThat's why I wonder: Do you think it's a reasonable solution to create a class that provides the amount of available threads and make the UI \"assume\" that the actual implementation is using the same amount of cores?", "author": "RoiEXLab", "createdAt": "2020-04-25T18:50:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExNjkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTEyMzI2OA==", "url": "https://github.com/triplea-game/triplea/pull/6328#discussion_r415123268", "bodyText": "In some sense we're already relying on java to actually use 4 different threads for our battlecalc (there's no guarantee the threads will all be run side by side at the same time)", "author": "RoiEXLab", "createdAt": "2020-04-25T19:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExNjkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE0NTI3Ng==", "url": "https://github.com/triplea-game/triplea/pull/6328#discussion_r415145276", "bodyText": "Personally, the \"X threads\" is interesting, but IMO more for devs. A good percentage of users will not know what a thread even is.", "author": "DanVanAtta", "createdAt": "2020-04-25T21:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExNjkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE0NTQyMw==", "url": "https://github.com/triplea-game/triplea/pull/6328#discussion_r415145423", "bodyText": "Good Point. It sounds like something #6329 should include, so I'd rather make a change there and merge this PR as-is.\n\nIndeed, to be explicit, any comment I prefix with \"side-note\" is really just a general comment; My general intent is the item is something that should not be addressed in this PR, but is worth a mention maybe and a follow-up.", "author": "DanVanAtta", "createdAt": "2020-04-25T21:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExNjkzNw=="}], "type": "inlineReview", "revised_code": null}]}