{"pr_number": 1152, "pr_title": "HIVE-23730: TezCompiler tracking the original TS key columnName", "pr_createdAt": "2020-06-19T13:26:07Z", "pr_url": "https://github.com/apache/hive/pull/1152", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3MTM5NQ==", "url": "https://github.com/apache/hive/pull/1152#discussion_r443271395", "bodyText": "Can you check if this can already be done by any of the utility methods in OperatorUtils? If it is not, can we move it to that class with rest of utility methods in case it is useful in the future?", "author": "jcamachor", "createdAt": "2020-06-22T00:16:58Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java", "diffHunk": "@@ -1566,13 +1569,38 @@ private void removeSemijoinsParallelToMapJoin(OptimizeTezProcContext procCtx)\n \n       List<ExprNodeDesc> keyDesc = selectedMJOp.getConf().getKeys().get(posBigTable);\n       ExprNodeColumnDesc keyCol = (ExprNodeColumnDesc) keyDesc.get(0);\n-\n-      tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n-          keyCol.getColumn(), selectedMJOpRatio);\n+      String realTSColName = getOriginalTSColName(selectedMJOp, keyCol.getColumn());\n+      if (realTSColName != null) {\n+        tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n+                realTSColName, selectedMJOpRatio);\n+      } else {\n+        LOG.warn(\"ProbeDecode could not find TSColName for ColKey {} with MJ Schema {} \", keyCol, selectedMJOp.getSchema());\n+      }\n     }\n     return tsProbeDecodeCtx;\n   }\n \n+  private static String getOriginalTSColName(MapJoinOperator mjOp, String internalCoName) {", "originalCommit": "bd7e3a0dbad207cda42580e29e52565f4e3b537c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3OTQ2MA==", "url": "https://github.com/apache/hive/pull/1152#discussion_r443479460", "bodyText": "Utility method is now moved to operatorUtils", "author": "pgaref", "createdAt": "2020-06-22T10:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3MTM5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "fadae3e5eb5ce638c19f92626111cb5a5bae17bc", "chunk": "diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java\nindex 2e8c2977bc..f3ff485cc0 100644\n--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java\n+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java\n\n@@ -1569,38 +1569,18 @@ private void removeSemijoinsParallelToMapJoin(OptimizeTezProcContext procCtx)\n \n       List<ExprNodeDesc> keyDesc = selectedMJOp.getConf().getKeys().get(posBigTable);\n       ExprNodeColumnDesc keyCol = (ExprNodeColumnDesc) keyDesc.get(0);\n-      String realTSColName = getOriginalTSColName(selectedMJOp, keyCol.getColumn());\n+      String realTSColName = OperatorUtils.findTableColNameOf(selectedMJOp, keyCol.getColumn());\n       if (realTSColName != null) {\n         tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n                 realTSColName, selectedMJOpRatio);\n-      } else {\n-        LOG.warn(\"ProbeDecode could not find TSColName for ColKey {} with MJ Schema {} \", keyCol, selectedMJOp.getSchema());\n+      } else if (inTestMode){\n+        throw new RuntimeException(\"ProbeDecode could not find TSColName for ColKey: \" + keyCol + \" with MJ Schema: \" +\n+                selectedMJOp.getSchema());\n       }\n     }\n     return tsProbeDecodeCtx;\n   }\n \n-  private static String getOriginalTSColName(MapJoinOperator mjOp, String internalCoName) {\n-    // Look for internalCoName alias in current OR Parent RowSchemas\n-    Stack<Operator<?>> parentOps = new Stack<>();\n-    ColumnInfo keyColInfo = null;\n-    parentOps.add(mjOp);\n-    while (!parentOps.isEmpty()) {\n-      Operator<?> currentOp = parentOps.pop();\n-      if (currentOp instanceof ReduceSinkOperator) {\n-        // Dont want to follow that parent path\n-       continue;\n-      }\n-      keyColInfo = currentOp.getSchema().getColumnInfo(internalCoName);\n-      if (keyColInfo != null) {\n-        // Get original colName alias (or fallback to internal colName)\n-        return keyColInfo.getAlias() != null ? keyColInfo.getAlias() : keyColInfo.getInternalName();\n-      }\n-      parentOps.addAll(currentOp.getParentOperators());\n-    }\n-    return null;\n-  }\n-\n   // Return the ratio of: (distinct) JOIN_probe_key_column_rows / (distinct) JOIN_TS_target_column_rows\n   private static double getProbeDecodeNDVRatio(TableScanOperator tsOp, MapJoinOperator mjOp) {\n     long mjKeyCardinality = mjOp.getStatistics().getNumRows();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3MjQzMw==", "url": "https://github.com/apache/hive/pull/1152#discussion_r443272433", "bodyText": "You could throw an error only if you are running in test mode:\nif (conf.getBoolVar(ConfVars.HIVE_IN_TEST)) {\n...\n\nWhile I am not a huge fan of interleaving a check like this within the production code, it may help you identify any issues, gaps, or regressions in the future.\nIf you do not want to do that, an alternative is uploading a patch throwing an error instead of printing the warning to get a complete test run, then create follow-up issues if there are any. It will not help you with regressions in the future, but you will be able to identify any existing issue.", "author": "jcamachor", "createdAt": "2020-06-22T00:27:55Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java", "diffHunk": "@@ -1566,13 +1569,38 @@ private void removeSemijoinsParallelToMapJoin(OptimizeTezProcContext procCtx)\n \n       List<ExprNodeDesc> keyDesc = selectedMJOp.getConf().getKeys().get(posBigTable);\n       ExprNodeColumnDesc keyCol = (ExprNodeColumnDesc) keyDesc.get(0);\n-\n-      tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n-          keyCol.getColumn(), selectedMJOpRatio);\n+      String realTSColName = getOriginalTSColName(selectedMJOp, keyCol.getColumn());\n+      if (realTSColName != null) {\n+        tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n+                realTSColName, selectedMJOpRatio);\n+      } else {\n+        LOG.warn(\"ProbeDecode could not find TSColName for ColKey {} with MJ Schema {} \", keyCol, selectedMJOp.getSchema());", "originalCommit": "bd7e3a0dbad207cda42580e29e52565f4e3b537c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4MjAzNg==", "url": "https://github.com/apache/hive/pull/1152#discussion_r443482036", "bodyText": "Hey @jcamachor , thanks for the comments!\nThe HIVE_IN_TEST trick could work as long we enable probedecode optimisation by default right? (currently if off)\nJust enabled the optimisation for this PR (throwing an exception instead of warn) to identify any existing issues.", "author": "pgaref", "createdAt": "2020-06-22T11:05:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3MjQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxNzI1MQ==", "url": "https://github.com/apache/hive/pull/1152#discussion_r443617251", "bodyText": "Qtest results here:\nhttp://ci.hive.apache.org/blue/organizations/jenkins/hive-precommit/detail/PR-1152/4/tests/\nSeems that for for existing MJ ops the probedecode optimisation works fine (properly finds original TS col alias as well). Not sure if we want to enable probe by default however. Thoughts? cc @ashutoshc", "author": "pgaref", "createdAt": "2020-06-22T14:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3MjQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk3MDI0Nw==", "url": "https://github.com/apache/hive/pull/1152#discussion_r443970247", "bodyText": "Cool! I think we should enable it by default indeed.", "author": "jcamachor", "createdAt": "2020-06-23T05:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3MjQzMw=="}], "type": "inlineReview", "revised_code": {"commit": "fadae3e5eb5ce638c19f92626111cb5a5bae17bc", "chunk": "diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java\nindex 2e8c2977bc..f3ff485cc0 100644\n--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java\n+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java\n\n@@ -1569,38 +1569,18 @@ private void removeSemijoinsParallelToMapJoin(OptimizeTezProcContext procCtx)\n \n       List<ExprNodeDesc> keyDesc = selectedMJOp.getConf().getKeys().get(posBigTable);\n       ExprNodeColumnDesc keyCol = (ExprNodeColumnDesc) keyDesc.get(0);\n-      String realTSColName = getOriginalTSColName(selectedMJOp, keyCol.getColumn());\n+      String realTSColName = OperatorUtils.findTableColNameOf(selectedMJOp, keyCol.getColumn());\n       if (realTSColName != null) {\n         tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n                 realTSColName, selectedMJOpRatio);\n-      } else {\n-        LOG.warn(\"ProbeDecode could not find TSColName for ColKey {} with MJ Schema {} \", keyCol, selectedMJOp.getSchema());\n+      } else if (inTestMode){\n+        throw new RuntimeException(\"ProbeDecode could not find TSColName for ColKey: \" + keyCol + \" with MJ Schema: \" +\n+                selectedMJOp.getSchema());\n       }\n     }\n     return tsProbeDecodeCtx;\n   }\n \n-  private static String getOriginalTSColName(MapJoinOperator mjOp, String internalCoName) {\n-    // Look for internalCoName alias in current OR Parent RowSchemas\n-    Stack<Operator<?>> parentOps = new Stack<>();\n-    ColumnInfo keyColInfo = null;\n-    parentOps.add(mjOp);\n-    while (!parentOps.isEmpty()) {\n-      Operator<?> currentOp = parentOps.pop();\n-      if (currentOp instanceof ReduceSinkOperator) {\n-        // Dont want to follow that parent path\n-       continue;\n-      }\n-      keyColInfo = currentOp.getSchema().getColumnInfo(internalCoName);\n-      if (keyColInfo != null) {\n-        // Get original colName alias (or fallback to internal colName)\n-        return keyColInfo.getAlias() != null ? keyColInfo.getAlias() : keyColInfo.getInternalName();\n-      }\n-      parentOps.addAll(currentOp.getParentOperators());\n-    }\n-    return null;\n-  }\n-\n   // Return the ratio of: (distinct) JOIN_probe_key_column_rows / (distinct) JOIN_TS_target_column_rows\n   private static double getProbeDecodeNDVRatio(TableScanOperator tsOp, MapJoinOperator mjOp) {\n     long mjKeyCardinality = mjOp.getStatistics().getNumRows();\n"}}, {"oid": "fadae3e5eb5ce638c19f92626111cb5a5bae17bc", "url": "https://github.com/apache/hive/commit/fadae3e5eb5ce638c19f92626111cb5a5bae17bc", "message": "hybridgrace hashjoin FIX\n\nChange-Id: I523aefff8bdeb1e2f91b82686dcd625a8f8cc7d2", "committedDate": "2020-06-23T20:11:51Z", "type": "forcePushed"}, {"oid": "7ec2787d20bb844da1930626ac4662fc62e9279f", "url": "https://github.com/apache/hive/commit/7ec2787d20bb844da1930626ac4662fc62e9279f", "message": "hybridgrace hashjoin FIX\n\nChange-Id: I523aefff8bdeb1e2f91b82686dcd625a8f8cc7d2", "committedDate": "2020-06-24T14:12:31Z", "type": "forcePushed"}, {"oid": "7783279ff2200311054c14ee91080adda9d30f67", "url": "https://github.com/apache/hive/commit/7783279ff2200311054c14ee91080adda9d30f67", "message": "HIVE-23730: TezCompiler tracking the original TS key columnName used for MJ probedecode\n\nChange-Id: Ia1f42f36bb6ea7108628d99f306d3c74398dca6b", "committedDate": "2020-06-25T13:19:55Z", "type": "commit"}, {"oid": "9c6d629cf8c0d6f9e173ea63ccb5fa0a05d8dbc1", "url": "https://github.com/apache/hive/commit/9c6d629cf8c0d6f9e173ea63ccb5fa0a05d8dbc1", "message": "TezCompiler using RowSchema instead for original TS colname mapping\n\nChange-Id: I23536ec54839e600e886fc7ab7a23e11ffc3acc2", "committedDate": "2020-06-25T13:19:55Z", "type": "commit"}, {"oid": "3ff5e773bb3d601656e12612a053529737c88d9e", "url": "https://github.com/apache/hive/commit/3ff5e773bb3d601656e12612a053529737c88d9e", "message": "Moving helper method finding TS colnmae to OperatorUtils.\nEnabling probedecode and throw exceptions to discover more issues/regressions\n\nChange-Id: Ib705ed06e2bd7fb4cf80f97e63d7ed5ba820e8d1", "committedDate": "2020-06-25T13:19:55Z", "type": "commit"}, {"oid": "259a66ccd8ec8eec524b00eba763e52e890e1e5c", "url": "https://github.com/apache/hive/commit/259a66ccd8ec8eec524b00eba763e52e890e1e5c", "message": "Enabling probedecode by default and Updating query out\n\nChange-Id: I31f131621f32c1a04e637fc13bb6698b27b00309", "committedDate": "2020-06-25T13:19:56Z", "type": "commit"}, {"oid": "fed5f9e36e01c6b87a40909be3cc49bf56d44db9", "url": "https://github.com/apache/hive/commit/fed5f9e36e01c6b87a40909be3cc49bf56d44db9", "message": "Reverting hybrid_grace hashjoin out\n\nChange-Id: I4402f7030bf860eb7735efc4eea7292bc5e75bfc", "committedDate": "2020-06-25T13:19:56Z", "type": "commit"}, {"oid": "1eeb57a96c97fe201fc771eec353128ae724f931", "url": "https://github.com/apache/hive/commit/1eeb57a96c97fe201fc771eec353128ae724f931", "message": "hybridgrace hashjoin FIX\n\nChange-Id: I523aefff8bdeb1e2f91b82686dcd625a8f8cc7d2", "committedDate": "2020-06-25T13:19:56Z", "type": "commit"}, {"oid": "99286d4609f0531045ecc74e482ff345c971fc76", "url": "https://github.com/apache/hive/commit/99286d4609f0531045ecc74e482ff345c971fc76", "message": "Fixing hybridgrace_hashjoin for LLAP\n\nChange-Id: I8a045cd3b0833357de21210dc2488057fbcbb585", "committedDate": "2020-06-25T13:19:56Z", "type": "commit"}, {"oid": "99286d4609f0531045ecc74e482ff345c971fc76", "url": "https://github.com/apache/hive/commit/99286d4609f0531045ecc74e482ff345c971fc76", "message": "Fixing hybridgrace_hashjoin for LLAP\n\nChange-Id: I8a045cd3b0833357de21210dc2488057fbcbb585", "committedDate": "2020-06-25T13:19:56Z", "type": "forcePushed"}, {"oid": "d6125f1e59fe37c693e6ea3266f81d9e3938c765", "url": "https://github.com/apache/hive/commit/d6125f1e59fe37c693e6ea3266f81d9e3938c765", "message": "Extend OpUtils findTableColNameOf method to look for column mappings in operator columnExpressions\n\nChange-Id: I9535b75ba2140d33ad2168204c34e8673650cbde", "committedDate": "2020-07-02T12:51:33Z", "type": "commit"}]}