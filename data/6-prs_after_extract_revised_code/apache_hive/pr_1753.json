{"pr_number": 1753, "pr_title": "HIVE-24503 : Optimize vector row serde by avoiding type check at run time.", "pr_createdAt": "2020-12-08T11:38:12Z", "pr_url": "https://github.com/apache/hive/pull/1753", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNjEyMQ==", "url": "https://github.com/apache/hive/pull/1753#discussion_r538916121", "bodyText": "Can be removed.", "author": "rbalamohan", "createdAt": "2020-12-09T00:40:35Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java", "diffHunk": "@@ -61,27 +61,16 @@\n   private Field root;\n \n   private static class Field {\n-    Field[] children;\n-\n-    boolean isPrimitive;\n-    Category category;\n-    PrimitiveCategory primitiveCategory;\n-    TypeInfo typeInfo;\n-\n-    int count;\n-\n-    ObjectInspector objectInspector;\n-    int outputColumnNum;\n-\n+    Field[] children = null;\n+    boolean isPrimitive = false;\n+    Category category = null;\n+    PrimitiveCategory primitiveCategory = null;\n+    TypeInfo typeInfo = null;\n+    int count = 0;\n+    ObjectInspector objectInspector = null;\n+    int outputColumnNum = -1;\n+    VectorSerializeWriter writer = null;\n     Field() {", "originalCommit": "9960d4926e3cbef75919903a094a82b4ed2ea02c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "chunk": "diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\nindex bc66d99444..f02fe50957 100644\n--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\n+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\n\n@@ -70,8 +70,6 @@\n     ObjectInspector objectInspector = null;\n     int outputColumnNum = -1;\n     VectorSerializeWriter writer = null;\n-    Field() {\n-    }\n   }\n \n   private VectorExtractRow vectorExtractRow;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzQ2OQ==", "url": "https://github.com/apache/hive/pull/1753#discussion_r538917469", "bodyText": "Why VectorDeserializerRow needs be passed here again? (\"this\" references in other places as well). If you remove \"static\" class declaration in VectorBatchDeserializer children, you may not need to pass this.  And the patch would become lot lesser changes?", "author": "rbalamohan", "createdAt": "2020-12-09T00:43:52Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorDeserializeRow.java", "diffHunk": "@@ -933,12 +1207,20 @@ private void storeUnionRowColumn(ColumnVector colVector,\n     unionColVector.isNull[batchIndex] = false;\n     unionColVector.tags[batchIndex] = tag;\n \n-    storeComplexFieldRowColumn(\n+    deserializer.storeComplexFieldRowColumn(\n         colVectorFields[tag],\n         unionHelper.getFields()[tag],\n         batchIndex,\n         canRetainByteRef);\n-    deserializeRead.finishComplexVariableFieldsType();\n+    deserializer.deserializeRead.finishComplexVariableFieldsType();\n+  }\n+\n+  abstract static class VectorBatchDeserializer {\n+    abstract void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+                            VectorDeserializeRow deserializer) throws IOException;", "originalCommit": "9960d4926e3cbef75919903a094a82b4ed2ea02c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "chunk": "diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorDeserializeRow.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorDeserializeRow.java\nindex 0f3c983ce1..e20c078b75 100644\n--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorDeserializeRow.java\n+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorDeserializeRow.java\n\n@@ -1207,20 +1188,19 @@ private static void storeUnionRowColumn(ColumnVector colVector,\n     unionColVector.isNull[batchIndex] = false;\n     unionColVector.tags[batchIndex] = tag;\n \n-    deserializer.storeComplexFieldRowColumn(\n+    storeComplexFieldRowColumn(\n         colVectorFields[tag],\n         unionHelper.getFields()[tag],\n         batchIndex,\n         canRetainByteRef);\n-    deserializer.deserializeRead.finishComplexVariableFieldsType();\n+    deserializeRead.finishComplexVariableFieldsType();\n   }\n \n   abstract static class VectorBatchDeserializer {\n-    abstract void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n-                            VectorDeserializeRow deserializer) throws IOException;\n+    abstract void store(ColumnVector colVector, Field field, int batchIndex,\n+                        boolean canRetainByteRef) throws IOException;\n \n-    abstract Object convert(ColumnVector batch, int batchIndex,\n-                        Field field, VectorDeserializeRow deserializer) throws IOException;\n+    abstract Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException;\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzg0MA==", "url": "https://github.com/apache/hive/pull/1753#discussion_r538917840", "bodyText": "Same as earlier. VectorSerializeRow need not be passed here. Patch may need lesser changes if you remove static declaration on children.", "author": "rbalamohan", "createdAt": "2020-12-09T00:44:42Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java", "diffHunk": "@@ -274,44 +315,25 @@ private void serializeWrite(\n       return;\n     }\n     isAllNulls = false;\n+    field.writer.serialize(colVector, field, adjustedBatchIndex, this);\n+  }\n \n-    if (field.isPrimitive) {\n-      serializePrimitiveWrite(colVector, field, adjustedBatchIndex);\n-      return;\n-    }\n-    final Category category = field.category;\n-    switch (category) {\n-    case LIST:\n-      serializeListWrite(\n-          (ListColumnVector) colVector,\n-          field,\n-          adjustedBatchIndex);\n-      break;\n-    case MAP:\n-      serializeMapWrite(\n-          (MapColumnVector) colVector,\n-          field,\n-          adjustedBatchIndex);\n-      break;\n-    case STRUCT:\n-      serializeStructWrite(\n-          (StructColumnVector) colVector,\n-          field,\n-          adjustedBatchIndex);\n-      break;\n-    case UNION:\n-      serializeUnionWrite(\n-          (UnionColumnVector) colVector,\n-          field,\n-          adjustedBatchIndex);\n-      break;\n-    default:\n-      throw new RuntimeException(\"Unexpected category \" + category);\n+  abstract static class VectorSerializeWriter {\n+    abstract void serialize(Object colVector, Field field, int adjustedBatchIndex,\n+                            VectorSerializeRow serializeRow) throws IOException;", "originalCommit": "9960d4926e3cbef75919903a094a82b4ed2ea02c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "chunk": "diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\nindex bc66d99444..f02fe50957 100644\n--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\n+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\n\n@@ -315,25 +313,22 @@ private void serializeWrite(\n       return;\n     }\n     isAllNulls = false;\n-    field.writer.serialize(colVector, field, adjustedBatchIndex, this);\n+    field.writer.serialize(colVector, field, adjustedBatchIndex);\n   }\n \n   abstract static class VectorSerializeWriter {\n-    abstract void serialize(Object colVector, Field field, int adjustedBatchIndex,\n-                            VectorSerializeRow serializeRow) throws IOException;\n+    abstract void serialize(Object colVector, Field field, int adjustedBatchIndex) throws IOException;\n   }\n \n-  static class VectorSerializeUnionWriter extends VectorSerializeWriter {\n+  class VectorSerializeUnionWriter extends VectorSerializeWriter {\n     @Override\n-    void serialize(Object colInfo, Field field, int adjustedBatchIndex,\n-                   VectorSerializeRow serializeRow) throws IOException {\n-      serializeUnionWrite((UnionColumnVector)colInfo, field, adjustedBatchIndex, serializeRow);\n+    void serialize(Object colInfo, Field field, int adjustedBatchIndex) throws IOException {\n+      serializeUnionWrite((UnionColumnVector)colInfo, field, adjustedBatchIndex);\n     }\n   }\n \n-  private static void serializeUnionWrite(\n-      UnionColumnVector colVector, Field field, int adjustedBatchIndex,\n-      VectorSerializeRow serializeRow) throws IOException {\n+  private void serializeUnionWrite(\n+      UnionColumnVector colVector, Field field, int adjustedBatchIndex) throws IOException {\n \n     UnionTypeInfo typeInfo = (UnionTypeInfo) field.typeInfo;\n     UnionObjectInspector objectInspector = (UnionObjectInspector) field.objectInspector;\n"}}, {"oid": "1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "url": "https://github.com/apache/hive/commit/1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "message": "HIVE-24503 : Optimize vector row serde by avoiding type check at run time", "committedDate": "2020-12-09T09:12:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzOTk2OQ==", "url": "https://github.com/apache/hive/pull/1753#discussion_r540839969", "bodyText": "Nit: would be cleaner if serializeStructWrite method is be part of the VectorSerializeStructWriter class", "author": "pgaref", "createdAt": "2020-12-11T10:18:06Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java", "diffHunk": "@@ -328,6 +345,13 @@ private void serializeUnionWrite(\n     serializeWrite.finishUnion();\n   }\n \n+  class VectorSerializeStructWriter extends VectorSerializeWriter {\n+    @Override\n+    void serialize(Object colInfo, Field field, int adjustedBatchIndex) throws IOException {\n+      serializeStructWrite((StructColumnVector)colInfo, field, adjustedBatchIndex);\n+    }\n+  }\n+\n   private void serializeStructWrite(", "originalCommit": "1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1ODg5Ng==", "url": "https://github.com/apache/hive/pull/1753#discussion_r542158896", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-12-14T07:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzOTk2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "fe42b2893c06c5a79b6ed83ba8526b92a620e904", "chunk": "diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\nindex f02fe50957..bc66d99444 100644\n--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\n+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\n\n@@ -337,23 +342,25 @@ private void serializeUnionWrite(\n     final ColumnVector fieldColumnVector = colVector.fields[tag];\n     final Field childField = field.children[tag];\n \n-    serializeWrite.beginUnion(tag);\n-    serializeWrite(\n+    serializeRow.serializeWrite.beginUnion(tag);\n+    serializeRow.serializeWrite(\n         fieldColumnVector,\n         childField,\n         adjustedBatchIndex);\n-    serializeWrite.finishUnion();\n+    serializeRow.serializeWrite.finishUnion();\n   }\n \n-  class VectorSerializeStructWriter extends VectorSerializeWriter {\n+  static class VectorSerializeStructWriter extends VectorSerializeWriter {\n     @Override\n-    void serialize(Object colInfo, Field field, int adjustedBatchIndex) throws IOException {\n-      serializeStructWrite((StructColumnVector)colInfo, field, adjustedBatchIndex);\n+    void serialize(Object colInfo, Field field, int adjustedBatchIndex,\n+                   VectorSerializeRow serializeRow) throws IOException {\n+      serializeStructWrite((StructColumnVector)colInfo, field, adjustedBatchIndex, serializeRow);\n     }\n   }\n \n-  private void serializeStructWrite(\n-      StructColumnVector colVector, Field field, int adjustedBatchIndex) throws IOException {\n+  private static void serializeStructWrite(\n+      StructColumnVector colVector, Field field, int adjustedBatchIndex,\n+      VectorSerializeRow serializeRow) throws IOException {\n \n     StructTypeInfo typeInfo = (StructTypeInfo) field.typeInfo;\n     StructObjectInspector objectInspector = (StructObjectInspector) field.objectInspector;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MDE4Mw==", "url": "https://github.com/apache/hive/pull/1753#discussion_r540840183", "bodyText": "Nit: serializeMapWrite part of VectorSerializeMapWriter class?", "author": "pgaref", "createdAt": "2020-12-11T10:18:30Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java", "diffHunk": "@@ -355,6 +379,13 @@ private void serializeStructWrite(\n     serializeWrite.finishStruct();\n   }\n \n+  class VectorSerializeMapWriter extends VectorSerializeWriter {\n+    @Override\n+    void serialize(Object colInfo, Field field, int adjustedBatchIndex) throws IOException {\n+      serializeMapWrite((MapColumnVector)colInfo, field, adjustedBatchIndex);\n+    }\n+  }\n+\n   private void serializeMapWrite(", "originalCommit": "1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1ODkzNg==", "url": "https://github.com/apache/hive/pull/1753#discussion_r542158936", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-12-14T07:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MDE4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "fe42b2893c06c5a79b6ed83ba8526b92a620e904", "chunk": "diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\nindex f02fe50957..bc66d99444 100644\n--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\n+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\n\n@@ -363,31 +370,33 @@ private void serializeStructWrite(\n     final List<? extends StructField> structFields = objectInspector.getAllStructFieldRefs();\n     final int size = field.count;\n \n-    final List list = (List) vectorExtractRow.extractRowColumn(\n+    final List list = (List) serializeRow.vectorExtractRow.extractRowColumn(\n         colVector, typeInfo, objectInspector, adjustedBatchIndex);\n \n-    serializeWrite.beginStruct(list);\n+    serializeRow.serializeWrite.beginStruct(list);\n     for (int i = 0; i < size; i++) {\n       if (i > 0) {\n-        serializeWrite.separateStruct();\n+        serializeRow.serializeWrite.separateStruct();\n       }\n-      serializeWrite(\n+      serializeRow.serializeWrite(\n           fieldColumnVectors[i],\n           children[i],\n           adjustedBatchIndex);\n     }\n-    serializeWrite.finishStruct();\n+    serializeRow.serializeWrite.finishStruct();\n   }\n \n-  class VectorSerializeMapWriter extends VectorSerializeWriter {\n+  static class VectorSerializeMapWriter extends VectorSerializeWriter {\n     @Override\n-    void serialize(Object colInfo, Field field, int adjustedBatchIndex) throws IOException {\n-      serializeMapWrite((MapColumnVector)colInfo, field, adjustedBatchIndex);\n+    void serialize(Object colInfo, Field field, int adjustedBatchIndex,\n+                   VectorSerializeRow serializeRow) throws IOException {\n+      serializeMapWrite((MapColumnVector)colInfo, field, adjustedBatchIndex, serializeRow);\n     }\n   }\n \n-  private void serializeMapWrite(\n-      MapColumnVector colVector, Field field, int adjustedBatchIndex) throws IOException {\n+  private static void serializeMapWrite(\n+      MapColumnVector colVector, Field field, int adjustedBatchIndex,\n+      VectorSerializeRow serializeRow) throws IOException {\n \n     MapTypeInfo typeInfo = (MapTypeInfo) field.typeInfo;\n     MapObjectInspector objectInspector = (MapObjectInspector) field.objectInspector;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MDM3Mw==", "url": "https://github.com/apache/hive/pull/1753#discussion_r540840373", "bodyText": "Nit: serializeListWrite part of VectorSerializeListWriter?", "author": "pgaref", "createdAt": "2020-12-11T10:18:47Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java", "diffHunk": "@@ -383,6 +414,13 @@ private void serializeMapWrite(\n     serializeWrite.finishMap();\n   }\n \n+  class VectorSerializeListWriter extends VectorSerializeWriter {\n+    @Override\n+    void serialize(Object colInfo, Field field, int adjustedBatchIndex) throws IOException {\n+      serializeListWrite((ListColumnVector)colInfo, field, adjustedBatchIndex);\n+    }\n+  }\n+\n   private void serializeListWrite(", "originalCommit": "1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1OTAxNg==", "url": "https://github.com/apache/hive/pull/1753#discussion_r542159016", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-12-14T07:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MDM3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "fe42b2893c06c5a79b6ed83ba8526b92a620e904", "chunk": "diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\nindex f02fe50957..bc66d99444 100644\n--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\n+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java\n\n@@ -399,30 +408,32 @@ private void serializeMapWrite(\n     final int offset = (int) colVector.offsets[adjustedBatchIndex];\n     final int size = (int) colVector.lengths[adjustedBatchIndex];\n \n-    final Map map = (Map) vectorExtractRow.extractRowColumn(\n+    final Map map = (Map) serializeRow.vectorExtractRow.extractRowColumn(\n         colVector, typeInfo, objectInspector, adjustedBatchIndex);\n \n-    serializeWrite.beginMap(map);\n+    serializeRow.serializeWrite.beginMap(map);\n     for (int i = 0; i < size; i++) {\n       if (i > 0) {\n-        serializeWrite.separateKeyValuePair();\n+        serializeRow.serializeWrite.separateKeyValuePair();\n       }\n-      serializeWrite(keyColumnVector, keyField, offset + i);\n-      serializeWrite.separateKey();\n-      serializeWrite(valueColumnVector, valueField, offset + i);\n+      serializeRow.serializeWrite(keyColumnVector, keyField, offset + i);\n+      serializeRow.serializeWrite.separateKey();\n+      serializeRow.serializeWrite(valueColumnVector, valueField, offset + i);\n     }\n-    serializeWrite.finishMap();\n+    serializeRow.serializeWrite.finishMap();\n   }\n \n-  class VectorSerializeListWriter extends VectorSerializeWriter {\n+  static class VectorSerializeListWriter extends VectorSerializeWriter {\n     @Override\n-    void serialize(Object colInfo, Field field, int adjustedBatchIndex) throws IOException {\n-      serializeListWrite((ListColumnVector)colInfo, field, adjustedBatchIndex);\n+    void serialize(Object colInfo, Field field, int adjustedBatchIndex,\n+                   VectorSerializeRow serializeRow) throws IOException {\n+      serializeListWrite((ListColumnVector)colInfo, field, adjustedBatchIndex, serializeRow);\n     }\n   }\n \n-  private void serializeListWrite(\n-      ListColumnVector colVector, Field field, int adjustedBatchIndex) throws IOException {\n+  private static void serializeListWrite(\n+      ListColumnVector colVector, Field field, int adjustedBatchIndex,\n+      VectorSerializeRow serializeRow) throws IOException {\n \n     final ListTypeInfo typeInfo = (ListTypeInfo) field.typeInfo;\n     final ListObjectInspector objectInspector = (ListObjectInspector) field.objectInspector;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MzE3OQ==", "url": "https://github.com/apache/hive/pull/1753#discussion_r540843179", "bodyText": "Looks like VectorVarcharDeserializer and VectorCharDeserializer share the same store method -- so maybe make them inherit from a common base class and only Override convert method?", "author": "pgaref", "createdAt": "2020-12-11T10:23:36Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorDeserializeRow.java", "diffHunk": "@@ -564,173 +621,337 @@ public void init() throws HiveException {\n     init(0);\n   }\n \n-  private void storePrimitiveRowColumn(ColumnVector colVector, Field field,\n-      int batchIndex, boolean canRetainByteRef) throws IOException {\n-\n-    switch (field.getPrimitiveCategory()) {\n-    case VOID:\n+  class VectorVoidDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       VectorizedBatchUtil.setNullColIsNullValue(colVector, batchIndex);\n-      return;\n-    case BOOLEAN:\n-      ((LongColumnVector) colVector).vector[batchIndex] = (deserializeRead.currentBoolean ? 1 : 0);\n-      break;\n-    case BYTE:\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertVoid();\n+    }\n+  }\n+\n+  class VectorBooleanDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n+      ((LongColumnVector) colVector).vector[batchIndex] =\n+              (deserializeRead.currentBoolean ? 1 : 0);\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertBoolean(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorByteDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentByte;\n-      break;\n-    case SHORT:\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertByte(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorShortDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentShort;\n-      break;\n-    case INT:\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertShort(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorIntDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentInt;\n-      break;\n-    case LONG:\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertInt(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorLongDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentLong;\n-      break;\n-    case TIMESTAMP:\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertLong(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorTimestampDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((TimestampColumnVector) colVector).set(\n-          batchIndex, deserializeRead.currentTimestampWritable.getTimestamp().toSqlTimestamp());\n-      break;\n-    case DATE:\n-      ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentDateWritable.getDays();\n-      break;\n-    case FLOAT:\n+              batchIndex, deserializeRead.currentTimestampWritable.getTimestamp().toSqlTimestamp());\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertTimestamp(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorDateDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n+      ((LongColumnVector) colVector).vector[batchIndex] =\n+              deserializeRead.currentDateWritable.getDays();\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertDate(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorFloatDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((DoubleColumnVector) colVector).vector[batchIndex] = deserializeRead.currentFloat;\n-      break;\n-    case DOUBLE:\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertFloat(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorDoubleDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((DoubleColumnVector) colVector).vector[batchIndex] = deserializeRead.currentDouble;\n-      break;\n-    case BINARY:\n-    case STRING:\n-      {\n-        final BytesColumnVector bytesColVec = ((BytesColumnVector) colVector);\n-        if (deserializeRead.currentExternalBufferNeeded) {\n-          bytesColVec.ensureValPreallocated(deserializeRead.currentExternalBufferNeededLen);\n-          deserializeRead.copyToExternalBuffer(\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertDouble(field.getConversionWritable());\n+    }\n+  }\n+\n+  private void storeString(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+          throws IOException {\n+    final BytesColumnVector bytesColVec = ((BytesColumnVector) colVector);\n+    if (deserializeRead.currentExternalBufferNeeded) {\n+      bytesColVec.ensureValPreallocated(deserializeRead.currentExternalBufferNeededLen);\n+      deserializeRead.copyToExternalBuffer(\n               bytesColVec.getValPreallocatedBytes(), bytesColVec.getValPreallocatedStart());\n-          bytesColVec.setValPreallocated(\n+      bytesColVec.setValPreallocated(\n               batchIndex,\n               deserializeRead.currentExternalBufferNeededLen);\n-        } else if (canRetainByteRef && inputBytes == deserializeRead.currentBytes) {\n-          bytesColVec.setRef(\n+    } else if (canRetainByteRef && inputBytes == deserializeRead.currentBytes) {\n+      bytesColVec.setRef(\n               batchIndex,\n               deserializeRead.currentBytes,\n               deserializeRead.currentBytesStart,\n               deserializeRead.currentBytesLength);\n-        } else {\n-          bytesColVec.setVal(\n+    } else {\n+      bytesColVec.setVal(\n               batchIndex,\n               deserializeRead.currentBytes,\n               deserializeRead.currentBytesStart,\n               deserializeRead.currentBytesLength);\n-        }\n-      }\n-      break;\n-    case VARCHAR:\n-      {\n-        // Use the basic STRING bytes read to get access, then use our optimal truncate/trim method\n-        // that does not use Java String objects.\n-        final BytesColumnVector bytesColVec = ((BytesColumnVector) colVector);\n-        if (deserializeRead.currentExternalBufferNeeded) {\n-          // Write directly into our BytesColumnVector value buffer.\n-          bytesColVec.ensureValPreallocated(deserializeRead.currentExternalBufferNeededLen);\n-          final byte[] convertBuffer = bytesColVec.getValPreallocatedBytes();\n-          final int convertBufferStart = bytesColVec.getValPreallocatedStart();\n-          deserializeRead.copyToExternalBuffer(\n-              convertBuffer,\n-              convertBufferStart);\n-          bytesColVec.setValPreallocated(\n-              batchIndex,\n-              StringExpr.truncate(\n-                  convertBuffer,\n-                  convertBufferStart,\n-                  deserializeRead.currentExternalBufferNeededLen,\n-                  field.getMaxLength()));\n-        } else if (canRetainByteRef && inputBytes == deserializeRead.currentBytes) {\n-          bytesColVec.setRef(\n-              batchIndex,\n-              deserializeRead.currentBytes,\n-              deserializeRead.currentBytesStart,\n-              StringExpr.truncate(\n-                  deserializeRead.currentBytes,\n-                  deserializeRead.currentBytesStart,\n-                  deserializeRead.currentBytesLength,\n-                  field.getMaxLength()));\n-        } else {\n-          bytesColVec.setVal(\n-              batchIndex,\n-              deserializeRead.currentBytes,\n-              deserializeRead.currentBytesStart,\n-              StringExpr.truncate(\n-                  deserializeRead.currentBytes,\n-                  deserializeRead.currentBytesStart,\n-                  deserializeRead.currentBytesLength,\n-                  field.getMaxLength()));\n-        }\n+    }\n+  }\n+\n+  class VectorBinaryDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n+      storeString(colVector, field, batchIndex, canRetainByteRef);\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertBinary(field.getConversionWritable(), batchIndex);\n+    }\n+  }\n+\n+  class VectorStringDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n+      storeString(colVector, field, batchIndex, canRetainByteRef);\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertString(field.getConversionWritable(), batchIndex);\n+    }\n+  }\n+\n+  class VectorVarcharDeserializer extends VectorBatchDeserializer {", "originalCommit": "1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1OTQ0OQ==", "url": "https://github.com/apache/hive/pull/1753#discussion_r542159449", "bodyText": "char uses StringExpr.rightTrimAndTruncate and var char uses StringExpr.truncate(", "author": "maheshk114", "createdAt": "2020-12-14T07:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MzE3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "fe42b2893c06c5a79b6ed83ba8526b92a620e904", "chunk": "diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorDeserializeRow.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorDeserializeRow.java\nindex e20c078b75..0f3c983ce1 100644\n--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorDeserializeRow.java\n+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorDeserializeRow.java\n\n@@ -621,202 +621,215 @@ public void init() throws HiveException {\n     init(0);\n   }\n \n-  class VectorVoidDeserializer extends VectorBatchDeserializer {\n+  static class VectorVoidDeserializer extends VectorBatchDeserializer {\n     @Override\n-    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n-            throws IOException {\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+               VectorDeserializeRow deserializer) throws IOException {\n       VectorizedBatchUtil.setNullColIsNullValue(colVector, batchIndex);\n     }\n \n     @Override\n-    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+    Object convert(ColumnVector batch, int batchIndex,\n+                   Field field, VectorDeserializeRow deserializer) throws IOException {\n       return convertVoid();\n     }\n   }\n \n-  class VectorBooleanDeserializer extends VectorBatchDeserializer {\n+  static class VectorBooleanDeserializer extends VectorBatchDeserializer {\n     @Override\n-    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n-            throws IOException {\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+               VectorDeserializeRow deserializer) throws IOException {\n       ((LongColumnVector) colVector).vector[batchIndex] =\n-              (deserializeRead.currentBoolean ? 1 : 0);\n+              (deserializer.deserializeRead.currentBoolean ? 1 : 0);\n     }\n \n     @Override\n-    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n-      return convertBoolean(field.getConversionWritable());\n+    Object convert(ColumnVector batch, int batchIndex,\n+                   Field field, VectorDeserializeRow deserializer) throws IOException {\n+      return convertBoolean(field.getConversionWritable(), deserializer);\n     }\n   }\n \n-  class VectorByteDeserializer extends VectorBatchDeserializer {\n+  static class VectorByteDeserializer extends VectorBatchDeserializer {\n     @Override\n-    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n-            throws IOException {\n-      ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentByte;\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+               VectorDeserializeRow deserializer) throws IOException {\n+      ((LongColumnVector) colVector).vector[batchIndex] = deserializer.deserializeRead.currentByte;\n     }\n \n     @Override\n-    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n-      return convertByte(field.getConversionWritable());\n+    Object convert(ColumnVector batch, int batchIndex,\n+                   Field field, VectorDeserializeRow deserializer) throws IOException {\n+      return convertByte(field.getConversionWritable(), deserializer);\n     }\n   }\n \n-  class VectorShortDeserializer extends VectorBatchDeserializer {\n+  static class VectorShortDeserializer extends VectorBatchDeserializer {\n     @Override\n-    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n-            throws IOException {\n-      ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentShort;\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+               VectorDeserializeRow deserializer) throws IOException {\n+      ((LongColumnVector) colVector).vector[batchIndex] = deserializer.deserializeRead.currentShort;\n     }\n \n     @Override\n-    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n-      return convertShort(field.getConversionWritable());\n+    Object convert(ColumnVector batch, int batchIndex,\n+                   Field field, VectorDeserializeRow deserializer) throws IOException {\n+      return convertShort(field.getConversionWritable(), deserializer);\n     }\n   }\n \n-  class VectorIntDeserializer extends VectorBatchDeserializer {\n+  static class VectorIntDeserializer extends VectorBatchDeserializer {\n     @Override\n-    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n-            throws IOException {\n-      ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentInt;\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+               VectorDeserializeRow deserializer) throws IOException {\n+      ((LongColumnVector) colVector).vector[batchIndex] = deserializer.deserializeRead.currentInt;\n     }\n \n     @Override\n-    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n-      return convertInt(field.getConversionWritable());\n+    Object convert(ColumnVector batch, int batchIndex,\n+                   Field field, VectorDeserializeRow deserializer) throws IOException {\n+      return convertInt(field.getConversionWritable(), deserializer);\n     }\n   }\n \n-  class VectorLongDeserializer extends VectorBatchDeserializer {\n+  static class VectorLongDeserializer extends VectorBatchDeserializer {\n     @Override\n-    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n-            throws IOException {\n-      ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentLong;\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+               VectorDeserializeRow deserializer) throws IOException {\n+      ((LongColumnVector) colVector).vector[batchIndex] = deserializer.deserializeRead.currentLong;\n     }\n \n     @Override\n-    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n-      return convertLong(field.getConversionWritable());\n+    Object convert(ColumnVector batch, int batchIndex,\n+                   Field field, VectorDeserializeRow deserializer) throws IOException {\n+      return convertLong(field.getConversionWritable(), deserializer);\n     }\n   }\n \n-  class VectorTimestampDeserializer extends VectorBatchDeserializer {\n+  static class VectorTimestampDeserializer extends VectorBatchDeserializer {\n     @Override\n-    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n-            throws IOException {\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+               VectorDeserializeRow deserializer) throws IOException {\n       ((TimestampColumnVector) colVector).set(\n-              batchIndex, deserializeRead.currentTimestampWritable.getTimestamp().toSqlTimestamp());\n+              batchIndex, deserializer.deserializeRead.currentTimestampWritable.getTimestamp().toSqlTimestamp());\n     }\n \n     @Override\n-    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n-      return convertTimestamp(field.getConversionWritable());\n+    Object convert(ColumnVector batch, int batchIndex,\n+                   Field field, VectorDeserializeRow deserializer) throws IOException {\n+      return convertTimestamp(field.getConversionWritable(), deserializer);\n     }\n   }\n \n-  class VectorDateDeserializer extends VectorBatchDeserializer {\n+  static class VectorDateDeserializer extends VectorBatchDeserializer {\n     @Override\n-    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n-            throws IOException {\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+               VectorDeserializeRow deserializer) throws IOException {\n       ((LongColumnVector) colVector).vector[batchIndex] =\n-              deserializeRead.currentDateWritable.getDays();\n+              deserializer.deserializeRead.currentDateWritable.getDays();\n     }\n \n     @Override\n-    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n-      return convertDate(field.getConversionWritable());\n+    Object convert(ColumnVector batch, int batchIndex,\n+                   Field field, VectorDeserializeRow deserializer) throws IOException {\n+      return convertDate(field.getConversionWritable(), deserializer);\n     }\n   }\n \n-  class VectorFloatDeserializer extends VectorBatchDeserializer {\n+  static class VectorFloatDeserializer extends VectorBatchDeserializer {\n     @Override\n-    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n-            throws IOException {\n-      ((DoubleColumnVector) colVector).vector[batchIndex] = deserializeRead.currentFloat;\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+               VectorDeserializeRow deserializer) throws IOException {\n+      ((DoubleColumnVector) colVector).vector[batchIndex] = deserializer.deserializeRead.currentFloat;\n     }\n \n     @Override\n-    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n-      return convertFloat(field.getConversionWritable());\n+    Object convert(ColumnVector batch, int batchIndex,\n+                   Field field, VectorDeserializeRow deserializer) throws IOException {\n+      return convertFloat(field.getConversionWritable(), deserializer);\n     }\n   }\n \n-  class VectorDoubleDeserializer extends VectorBatchDeserializer {\n+  static class VectorDoubleDeserializer extends VectorBatchDeserializer {\n     @Override\n-    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n-            throws IOException {\n-      ((DoubleColumnVector) colVector).vector[batchIndex] = deserializeRead.currentDouble;\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+               VectorDeserializeRow deserializer) throws IOException {\n+      ((DoubleColumnVector) colVector).vector[batchIndex] = deserializer.deserializeRead.currentDouble;\n     }\n \n     @Override\n-    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n-      return convertDouble(field.getConversionWritable());\n+    Object convert(ColumnVector batch, int batchIndex,\n+                   Field field, VectorDeserializeRow deserializer) throws IOException {\n+      return convertDouble(field.getConversionWritable(), deserializer);\n     }\n   }\n \n-  private void storeString(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n-          throws IOException {\n+  private static void storeString(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+                                  VectorDeserializeRow deserializer) throws IOException {\n     final BytesColumnVector bytesColVec = ((BytesColumnVector) colVector);\n-    if (deserializeRead.currentExternalBufferNeeded) {\n-      bytesColVec.ensureValPreallocated(deserializeRead.currentExternalBufferNeededLen);\n-      deserializeRead.copyToExternalBuffer(\n+    if (deserializer.deserializeRead.currentExternalBufferNeeded) {\n+      bytesColVec.ensureValPreallocated(deserializer.deserializeRead.currentExternalBufferNeededLen);\n+      deserializer.deserializeRead.copyToExternalBuffer(\n               bytesColVec.getValPreallocatedBytes(), bytesColVec.getValPreallocatedStart());\n       bytesColVec.setValPreallocated(\n               batchIndex,\n-              deserializeRead.currentExternalBufferNeededLen);\n-    } else if (canRetainByteRef && inputBytes == deserializeRead.currentBytes) {\n+              deserializer.deserializeRead.currentExternalBufferNeededLen);\n+    } else if (canRetainByteRef && deserializer.inputBytes == deserializer.deserializeRead.currentBytes) {\n       bytesColVec.setRef(\n               batchIndex,\n-              deserializeRead.currentBytes,\n-              deserializeRead.currentBytesStart,\n-              deserializeRead.currentBytesLength);\n+              deserializer.deserializeRead.currentBytes,\n+              deserializer.deserializeRead.currentBytesStart,\n+              deserializer.deserializeRead.currentBytesLength);\n     } else {\n       bytesColVec.setVal(\n               batchIndex,\n-              deserializeRead.currentBytes,\n-              deserializeRead.currentBytesStart,\n-              deserializeRead.currentBytesLength);\n+              deserializer.deserializeRead.currentBytes,\n+              deserializer.deserializeRead.currentBytesStart,\n+              deserializer.deserializeRead.currentBytesLength);\n     }\n   }\n \n-  class VectorBinaryDeserializer extends VectorBatchDeserializer {\n+  static class VectorBinaryDeserializer extends VectorBatchDeserializer {\n     @Override\n-    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n-            throws IOException {\n-      storeString(colVector, field, batchIndex, canRetainByteRef);\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+               VectorDeserializeRow deserializer) throws IOException {\n+      storeString(colVector, field, batchIndex, canRetainByteRef, deserializer);\n     }\n \n     @Override\n-    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n-      return convertBinary(field.getConversionWritable(), batchIndex);\n+    Object convert(ColumnVector batch, int batchIndex,\n+                   Field field, VectorDeserializeRow deserializer) throws IOException {\n+      return convertBinary(field.getConversionWritable(), deserializer, batchIndex);\n     }\n   }\n \n-  class VectorStringDeserializer extends VectorBatchDeserializer {\n+  static class VectorStringDeserializer extends VectorBatchDeserializer {\n     @Override\n-    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n-            throws IOException {\n-      storeString(colVector, field, batchIndex, canRetainByteRef);\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+               VectorDeserializeRow deserializer) throws IOException {\n+      storeString(colVector, field, batchIndex, canRetainByteRef, deserializer);\n     }\n \n     @Override\n-    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n-      return convertString(field.getConversionWritable(), batchIndex);\n+    Object convert(ColumnVector batch, int batchIndex,\n+                   Field field, VectorDeserializeRow deserializer) throws IOException {\n+      return convertString(field.getConversionWritable(), deserializer, batchIndex);\n     }\n   }\n \n-  class VectorVarcharDeserializer extends VectorBatchDeserializer {\n+  static class VectorVarcharDeserializer extends VectorBatchDeserializer {\n     @Override\n-    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef) throws IOException {\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+               VectorDeserializeRow deserializer) throws IOException {\n       // Use the basic STRING bytes read to get access, then use our optimal truncate/trim method\n       // that does not use Java String objects.\n       final BytesColumnVector bytesColVec = ((BytesColumnVector) colVector);\n-      if (deserializeRead.currentExternalBufferNeeded) {\n+      if (deserializer.deserializeRead.currentExternalBufferNeeded) {\n         // Write directly into our BytesColumnVector value buffer.\n-        bytesColVec.ensureValPreallocated(deserializeRead.currentExternalBufferNeededLen);\n+        bytesColVec.ensureValPreallocated(deserializer.deserializeRead.currentExternalBufferNeededLen);\n         final byte[] convertBuffer = bytesColVec.getValPreallocatedBytes();\n         final int convertBufferStart = bytesColVec.getValPreallocatedStart();\n-        deserializeRead.copyToExternalBuffer(\n+        deserializer.deserializeRead.copyToExternalBuffer(\n                 convertBuffer,\n                 convertBufferStart);\n         bytesColVec.setValPreallocated(\n"}}, {"oid": "fe42b2893c06c5a79b6ed83ba8526b92a620e904", "url": "https://github.com/apache/hive/commit/fe42b2893c06c5a79b6ed83ba8526b92a620e904", "message": "HIVE-24503 : Optimize vector row serde by avoiding type check at run time", "committedDate": "2020-12-14T12:12:02Z", "type": "commit"}, {"oid": "7783b36cbc7d94f2c2e672262b31ea3a31a880d7", "url": "https://github.com/apache/hive/commit/7783b36cbc7d94f2c2e672262b31ea3a31a880d7", "message": "HIVE-24503 : Optimize vector row serde by avoiding type check at run time", "committedDate": "2020-12-14T12:12:02Z", "type": "commit"}, {"oid": "dc743c71d06119d946d77f8391a20f9322344fca", "url": "https://github.com/apache/hive/commit/dc743c71d06119d946d77f8391a20f9322344fca", "message": "HIVE-24503 : Optimize vector row serde by avoiding type check at run time : review commnet fix", "committedDate": "2020-12-14T12:12:02Z", "type": "commit"}, {"oid": "dc743c71d06119d946d77f8391a20f9322344fca", "url": "https://github.com/apache/hive/commit/dc743c71d06119d946d77f8391a20f9322344fca", "message": "HIVE-24503 : Optimize vector row serde by avoiding type check at run time : review commnet fix", "committedDate": "2020-12-14T12:12:02Z", "type": "forcePushed"}]}