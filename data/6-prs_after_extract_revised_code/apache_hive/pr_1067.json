{"pr_number": 1067, "pr_title": "HIVE-23627: Review of GroupByOperator", "pr_createdAt": "2020-06-05T16:54:21Z", "pr_url": "https://github.com/apache/hive/pull/1067", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MDM4MQ==", "url": "https://github.com/apache/hive/pull/1067#discussion_r436050381", "bodyText": "We were skipping string garbage for this, I think we can switch to the {} format", "author": "t3rmin4t0r", "createdAt": "2020-06-05T17:06:03Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java", "diffHunk": "@@ -990,24 +955,17 @@ private void flushHashTable(boolean complete) throws HiveException {\n     // changed in the future\n \n     if (complete) {\n-      Iterator<Map.Entry<KeyWrapper, AggregationBuffer[]>> iter = hashAggregations\n-          .entrySet().iterator();\n-      while (iter.hasNext()) {\n-        Map.Entry<KeyWrapper, AggregationBuffer[]> m = iter.next();\n-        forward(m.getKey().getKeyArray(), m.getValue());\n+      for (Map.Entry<KeyWrapper, AggregationBuffer[]> entry : hashAggregations.entrySet()) {\n+        forward(entry.getKey().getKeyArray(), entry.getValue());\n       }\n-      hashAggregations.clear();\n       hashAggregations = null;\n-      if (LOG.isInfoEnabled()) {\n-        LOG.info(\"Hash Table completed flushed\");\n-      }\n+      LOG.info(\"Hash Table completed flushed\");\n       return;\n     }\n \n     int oldSize = hashAggregations.size();\n-    if (LOG.isInfoEnabled()) {\n-      LOG.info(\"Hash Tbl flush: #hash table = \" + oldSize);\n-    }\n+    LOG.info(\"Hash Tbl flush: #hash table = \" + oldSize);", "originalCommit": "6b31fea4b6c319066e952d6bc5057ff14bcfb6b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MTgzMQ==", "url": "https://github.com/apache/hive/pull/1067#discussion_r436051831", "bodyText": "Thanks @t3rmin4t0r for the review!  I'm not sure the value of that.  Are there many instances where organizations are running with something higher than INFO?  If it's expected to run at INFO, better to just concat and print the message than to have to do the actions of parsing the string, looking for the anchor {}, replacing it, etc. etc.  I am happy to do it just for consistency, but from performance, better to simply concat and print.", "author": "belugabehr", "createdAt": "2020-06-05T17:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MDM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3MjY2OQ==", "url": "https://github.com/apache/hive/pull/1067#discussion_r436072669", "bodyText": "The problem is string concatenation does a lot of work without knowing if it is needed or not -- {} format does not!\nhttp://slf4j.org/faq.html#logging_performance", "author": "pgaref", "createdAt": "2020-06-05T17:49:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MDM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5Mjk3OQ==", "url": "https://github.com/apache/hive/pull/1067#discussion_r436092979", "bodyText": "Thanks for chiming in @pgaref\nI love that you're passionate about using the parameters.  I usually like to do this, but it's 50-50 on who likes to see it and who not.  My point is that using parameters:\n\ncan significantly boost logging performance for disabled logging statement.\n\nThe problem is that it adds overhead when there are enabled logging statements.  For an INFO level logging, it's almost certainly enabled in a production environment so using the anchor ({}) just adds needless overhead.\nThink about it, what is faster?\npublic static void main(String[] args) {\n   info1(\"foo: \", \"bar\");\n   info2(\"foo: {}\", \"bar\");\n}\n\nvoid info1(String s, String param) {\n  System.out.println(s.concat(param));\n}\n\nvoid info2(String s, String param) {\n   int index = s.lastIndexOf(\"{\");\n   if (index < 0) {\n     System.out.println(s);\n   } else {\n      if (s.lastIndexOf{\"}\") == (index + 1) {\n         String firstHalf= s.subString(0, index);\n         String secondHalf = s.subString(index + 2) s.length());\n        System.out.println(firstHalf + param + secondHalf);\n    } else {\n        System.out.println(s);\n    }\n}\n\nClearly the second option is going to be slower.  Info1 generates a string certainly, and Info2 does not.  However, if the application is almost always going to be running at the INFO level, it doesn't really make a lot of sense to have to always go down Info2.\nThat said, there is certainly value in having consistency (always using parameters), and I think messages are easier to read when formatted this way than when they are all piecemeal with the \"+\" signs, but if you want to understand the raw performance, then what is currently there is preferable in an environment where the log level is set to a minimum of INFO (which almost every environment I've worked on is).", "author": "belugabehr", "createdAt": "2020-06-05T18:25:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MDM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTA3MA==", "url": "https://github.com/apache/hive/pull/1067#discussion_r436099070", "bodyText": "(see below for more)", "author": "belugabehr", "createdAt": "2020-06-05T18:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MDM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMzMzNA==", "url": "https://github.com/apache/hive/pull/1067#discussion_r436123334", "bodyText": "Hey @belugabehr -- thanks for the detailed comment!\nTbh I was under the impression that the flush size message above was on debug mode -- we are on the same page on this!\nThere are several places in the project were we check if (LOG.isDebugEnabled()) before doing the logging, however, this is completely redundant (if we have less than 3 arguments as you pointed out correctly below).\nFor Log.info mode, as you said, it is more like a matter of consistency.", "author": "pgaref", "createdAt": "2020-06-05T19:32:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MDM4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d36ba0a64ce1a0e6421e725313dff37fd582af64", "chunk": "diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java\nindex c4e532ab20..ea50d9dc10 100644\n--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java\n+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java\n\n@@ -964,7 +964,7 @@ private void flushHashTable(boolean complete) throws HiveException {\n     }\n \n     int oldSize = hashAggregations.size();\n-    LOG.info(\"Hash Tbl flush: #hash table = \" + oldSize);\n+    LOG.info(\"Hash Tbl flush: #hash table = {}\", oldSize);\n \n     Iterator<Map.Entry<KeyWrapper, AggregationBuffer[]>> iter = hashAggregations\n         .entrySet().iterator();\n"}}, {"oid": "d36ba0a64ce1a0e6421e725313dff37fd582af64", "url": "https://github.com/apache/hive/commit/d36ba0a64ce1a0e6421e725313dff37fd582af64", "message": "Use SLF4J parameterized logging", "committedDate": "2020-06-05T19:15:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5OTE0Ng==", "url": "https://github.com/apache/hive/pull/1067#discussion_r436199146", "bodyText": "I assume that LinkedHashSet was chosen in order to retain the order of the elements and avoid calling contains on a List.\nHowever, I have the impression that we can avoid the call to List#contains rather easy since the way we populate the list is controlled.\nMoreover, I think that the order of inserting the elements does not really matter since what we are storing inside is a pointer to an aggregate and when it is used it is used with indirection. The same pointer that we are putting in this list we are putting also to the nonDistinctKeyAggrs and distinctKeyAggrs inside the sets, so it is another indicator that retaining the order is useless.\nSo instead of using the LinkedHashSet some other alternatives would be to  would be to keep the ArrayList with a small refactoring to avoid List#contains or use a plain HashSet.", "author": "zabetak", "createdAt": "2020-06-05T22:57:30Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java", "diffHunk": "@@ -90,13 +91,11 @@\n   // so aggregationIsDistinct is a boolean array instead of a single number.\n   private transient boolean[] aggregationIsDistinct;\n   // Map from integer tag to distinct aggrs\n-  private transient Map<Integer, Set<Integer>> distinctKeyAggrs =\n-    new HashMap<Integer, Set<Integer>>();\n+  private transient Map<Integer, Set<Integer>> distinctKeyAggrs = new HashMap<>();\n   // Map from integer tag to non-distinct aggrs with key parameters.\n-  private transient Map<Integer, Set<Integer>> nonDistinctKeyAggrs =\n-    new HashMap<Integer, Set<Integer>>();\n+  private transient Map<Integer, Set<Integer>> nonDistinctKeyAggrs = new HashMap<>();\n   // List of non-distinct aggrs.\n-  private transient List<Integer> nonDistinctAggrs = new ArrayList<Integer>();\n+  private transient Set<Integer> nonDistinctAggrs = new LinkedHashSet<>();", "originalCommit": "d36ba0a64ce1a0e6421e725313dff37fd582af64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExOTI5MQ==", "url": "https://github.com/apache/hive/pull/1067#discussion_r438119291", "bodyText": "@zabetak Yes.  You are 100% correct about your assumptions about my motivations. Bravo.\nI will change to HashSet and let anyone else take a crack at more refactoring.", "author": "belugabehr", "createdAt": "2020-06-10T13:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5OTE0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f0110b0c3c61d3a7220c1bcc7e8831713750ba82", "chunk": "diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java\nindex ea50d9dc10..fed027738b 100644\n--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java\n+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java\n\n@@ -95,7 +94,7 @@\n   // Map from integer tag to non-distinct aggrs with key parameters.\n   private transient Map<Integer, Set<Integer>> nonDistinctKeyAggrs = new HashMap<>();\n   // List of non-distinct aggrs.\n-  private transient Set<Integer> nonDistinctAggrs = new LinkedHashSet<>();\n+  private transient Set<Integer> nonDistinctAggrs = new HashSet<>();\n   // Union expr for distinct keys\n   private transient ExprNodeEvaluator unionExprEval;\n \n"}}, {"oid": "1d02077ab4d8919ff8555e5af69fd528f791e757", "url": "https://github.com/apache/hive/commit/1d02077ab4d8919ff8555e5af69fd528f791e757", "message": "HIVE-23627: Review of GroupByOperator", "committedDate": "2020-06-10T13:26:46Z", "type": "commit"}, {"oid": "630a119efc5583f4b2e246939de246166e60bfff", "url": "https://github.com/apache/hive/commit/630a119efc5583f4b2e246939de246166e60bfff", "message": "Use SLF4J parameterized logging", "committedDate": "2020-06-10T13:26:46Z", "type": "commit"}, {"oid": "f0110b0c3c61d3a7220c1bcc7e8831713750ba82", "url": "https://github.com/apache/hive/commit/f0110b0c3c61d3a7220c1bcc7e8831713750ba82", "message": "Use HashSet instead of LinkedHashSet", "committedDate": "2020-06-10T13:29:52Z", "type": "commit"}, {"oid": "f0110b0c3c61d3a7220c1bcc7e8831713750ba82", "url": "https://github.com/apache/hive/commit/f0110b0c3c61d3a7220c1bcc7e8831713750ba82", "message": "Use HashSet instead of LinkedHashSet", "committedDate": "2020-06-10T13:29:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM3MzQ4Ng==", "url": "https://github.com/apache/hive/pull/1067#discussion_r441373486", "bodyText": "nit: missing space", "author": "pvary", "createdAt": "2020-06-17T08:29:17Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java", "diffHunk": "@@ -899,12 +873,8 @@ private boolean shouldBeFlushed(KeyWrapper newKeys) {\n       // Assuming the used memory is equally divided among all executors.\n       usedMemory = isLlap ? usedMemory / numExecutors : usedMemory;\n       rate = (float) usedMemory / (float) maxMemory;\n-      if(rate > memoryThreshold){\n-        if (isTez && numEntriesHashTable == 0) {\n-          return false;\n-        } else {\n-          return true;\n-        }\n+      if (rate > memoryThreshold){", "originalCommit": "f0110b0c3c61d3a7220c1bcc7e8831713750ba82", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe31437f5d61bd57a23577761ebe4ced67b9d837", "chunk": "diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java\nindex fed027738b..01de9df7be 100644\n--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java\n+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java\n\n@@ -873,7 +873,7 @@ private boolean shouldBeFlushed(KeyWrapper newKeys) {\n       // Assuming the used memory is equally divided among all executors.\n       usedMemory = isLlap ? usedMemory / numExecutors : usedMemory;\n       rate = (float) usedMemory / (float) maxMemory;\n-      if (rate > memoryThreshold){\n+      if (rate > memoryThreshold) {\n         return (!isTez || numEntriesHashTable != 0);\n       }\n       for (Integer pos : keyPositionsSize) {\n"}}, {"oid": "fe31437f5d61bd57a23577761ebe4ced67b9d837", "url": "https://github.com/apache/hive/commit/fe31437f5d61bd57a23577761ebe4ced67b9d837", "message": "Fix checksyle issue", "committedDate": "2020-06-17T13:36:02Z", "type": "commit"}]}