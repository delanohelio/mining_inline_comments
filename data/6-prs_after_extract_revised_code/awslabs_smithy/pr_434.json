{"pr_number": 434, "pr_title": "Rewrite grammar and parser", "pr_createdAt": "2020-05-12T17:28:01Z", "pr_url": "https://github.com/awslabs/smithy/pull/434", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NDE0NA==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r423974144", "bodyText": "This is inconsistent with the production list documentation in this PR.", "author": "kstich", "createdAt": "2020-05-12T19:17:46Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlTextParser.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.loader;\n+\n+/**\n+ * Parses IDL text and text blocks.\n+ */\n+final class IdlTextParser {\n+\n+    private IdlTextParser() {}\n+\n+    // node_text = shape_id / quoted_text / text_block", "originalCommit": "8b411a4b22bb6a57c0da174155fa4c5cda1ae2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NzUxMw==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424097513", "bodyText": "Good catch! This revealed several other issues that I fixed an added tests for, mostly around the difference between object keys and node_values. It wasn't implemented correctly in trait values in particular.", "author": "mtdowling", "createdAt": "2020-05-12T23:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NDE0NA=="}], "type": "inlineReview", "revised_code": {"commit": "2752061a913913f089fe97bffbbb23f0551b357e", "chunk": "diff --git a/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlTextParser.java b/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlTextParser.java\nindex 0cba39672..1e05d9105 100644\n--- a/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlTextParser.java\n+++ b/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlTextParser.java\n\n@@ -22,37 +22,19 @@ final class IdlTextParser {\n \n     private IdlTextParser() {}\n \n-    // node_text = shape_id / quoted_text / text_block\n-    static String parseNodeText(IdlModelParser parser) {\n-        if (parser.charPeek() != '\"') {\n-            return IdlShapeIdParser.parseShapeId(parser);\n-        }\n-\n-        parser.skip();\n-        if (parser.charPeek() == '\"') { // \"\"\n-            parser.skip();\n-            if (parser.charPeek() == '\"') { // \"\"\"\n-                parser.skip();\n-                return parseQuotedText(parser, true);\n-            } else {\n-                return \"\"; // \"\"\n-            }\n-        } else { // \"\n-            return parseQuotedText(parser, false);\n-        }\n-    }\n-\n+    // quoted_text = DQUOTE *quoted_char DQUOTE\n     static String parseQuotedString(IdlModelParser parser) {\n         parser.expect('\"');\n         if (parser.charPeek() == '\"') { // open and closed string.\n             parser.skip();\n             return \"\"; // \"\"\n         } else { // \"\n-            return parseQuotedText(parser, false);\n+            return parseQuotedTextAndTextBlock(parser, false);\n         }\n     }\n \n-    private static String parseQuotedText(IdlModelParser parser, boolean triple) {\n+    // Parses both quoted_text and text_block\n+    static String parseQuotedTextAndTextBlock(IdlModelParser parser, boolean triple) {\n         int start = parser.position();\n \n         while (!parser.eof()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4ODk3NQ==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r423988975", "bodyText": "Perf: any benefit to having this be a method reference instead of a lambda?", "author": "kstich", "createdAt": "2020-05-12T19:43:30Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlShapeIdParser.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.loader;\n+\n+/**\n+ * Parses IDL shape IDs.\n+ */\n+final class IdlShapeIdParser {\n+\n+    private IdlShapeIdParser() {}\n+\n+    static String parseShapeId(IdlModelParser parser) {\n+        int start = parser.position();\n+        consumeShapeId(parser);\n+        return parser.sliceFrom(start);\n+    }\n+\n+    static String parseIdentifier(IdlModelParser parser) {\n+        int start = parser.position();\n+        consumeIdentifier(parser);\n+        return parser.sliceFrom(start);\n+    }\n+\n+    // identifier = (ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n+    static void consumeIdentifier(IdlModelParser parser) {\n+        // (ALPHA / \"_\")\n+        if (!isIdentifierStart(parser.charPeek())) {\n+            throw parser.syntax(\"Expected a valid identifier character, but found '\"\n+                                + parser.peekSingleCharForMessage() + '\\'');\n+        }\n+\n+        // *(ALPHA / DIGIT / \"_\")\n+        parser.consumeUntilNoLongerMatches(c -> isIdentifierStart(c) || isDigit(c));", "originalCommit": "8b411a4b22bb6a57c0da174155fa4c5cda1ae2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0MzM3Ng==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424043376", "bodyText": "Probably not since the capture doesn't use any external variables, but I went ahead and made it a static method", "author": "mtdowling", "createdAt": "2020-05-12T21:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4ODk3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2752061a913913f089fe97bffbbb23f0551b357e", "chunk": "diff --git a/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlShapeIdParser.java b/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlShapeIdParser.java\nindex b2f957b8b..a2f470246 100644\n--- a/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlShapeIdParser.java\n+++ b/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlShapeIdParser.java\n\n@@ -43,7 +43,11 @@ final class IdlShapeIdParser {\n         }\n \n         // *(ALPHA / DIGIT / \"_\")\n-        parser.consumeUntilNoLongerMatches(c -> isIdentifierStart(c) || isDigit(c));\n+        parser.consumeUntilNoLongerMatches(IdlShapeIdParser::isValidIdentifierCharacter);\n+    }\n+\n+    private static boolean isValidIdentifierCharacter(char c) {\n+        return isIdentifierStart(c) || isDigit(c);\n     }\n \n     static String parseNamespace(IdlModelParser parser) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMzY1NQ==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424023655", "bodyText": "Use clearPendingDocs for safety.", "author": "kstich", "createdAt": "2020-05-12T20:47:43Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java", "diffHunk": "@@ -0,0 +1,897 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.loader;\n+\n+import static java.lang.String.format;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.FromSourceLocation;\n+import software.amazon.smithy.model.SourceLocation;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.shapes.AbstractShapeBuilder;\n+import software.amazon.smithy.model.shapes.BigDecimalShape;\n+import software.amazon.smithy.model.shapes.BigIntegerShape;\n+import software.amazon.smithy.model.shapes.BlobShape;\n+import software.amazon.smithy.model.shapes.BooleanShape;\n+import software.amazon.smithy.model.shapes.ByteShape;\n+import software.amazon.smithy.model.shapes.CollectionShape;\n+import software.amazon.smithy.model.shapes.DocumentShape;\n+import software.amazon.smithy.model.shapes.DoubleShape;\n+import software.amazon.smithy.model.shapes.FloatShape;\n+import software.amazon.smithy.model.shapes.IntegerShape;\n+import software.amazon.smithy.model.shapes.ListShape;\n+import software.amazon.smithy.model.shapes.LongShape;\n+import software.amazon.smithy.model.shapes.MapShape;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.OperationShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.ServiceShape;\n+import software.amazon.smithy.model.shapes.SetShape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeType;\n+import software.amazon.smithy.model.shapes.ShortShape;\n+import software.amazon.smithy.model.shapes.StringShape;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.TimestampShape;\n+import software.amazon.smithy.model.shapes.UnionShape;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.validation.Severity;\n+import software.amazon.smithy.model.validation.ValidationEvent;\n+import software.amazon.smithy.model.validation.ValidationUtils;\n+import software.amazon.smithy.model.validation.Validator;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+final class IdlModelParser {\n+\n+    private static final String PUT_KEY = \"put\";\n+    private static final String CREATE_KEY = \"create\";\n+    private static final String READ_KEY = \"read\";\n+    private static final String UPDATE_KEY = \"update\";\n+    private static final String DELETE_KEY = \"delete\";\n+    private static final String LIST_KEY = \"list\";\n+    private static final String RESOURCES_KEY = \"resources\";\n+    private static final String OPERATIONS_KEY = \"operations\";\n+    private static final String COLLECTION_OPERATIONS_KEY = \"collectionOperations\";\n+    private static final String IDENTIFIERS_KEY = \"identifiers\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String TYPE_KEY = \"type\";\n+\n+    static final Collection<String> RESOURCE_PROPERTY_NAMES = ListUtils.of(\n+            TYPE_KEY, CREATE_KEY, READ_KEY, UPDATE_KEY, DELETE_KEY, LIST_KEY,\n+            IDENTIFIERS_KEY, RESOURCES_KEY, OPERATIONS_KEY, PUT_KEY, COLLECTION_OPERATIONS_KEY);\n+    static final List<String> SERVICE_PROPERTY_NAMES = ListUtils.of(\n+            TYPE_KEY, VERSION_KEY, OPERATIONS_KEY, RESOURCES_KEY);\n+    private static final Collection<String> OPERATION_PROPERTY_NAMES = ListUtils.of(\"input\", \"output\", \"errors\");\n+    private static final Set<String> SHAPE_TYPES = new HashSet<>();\n+\n+    static {\n+        for (ShapeType type : ShapeType.values()) {\n+            if (type != ShapeType.MEMBER) {\n+                SHAPE_TYPES.add(type.toString());\n+            }\n+        }\n+    }\n+\n+    private final String filename;\n+    private final String model;\n+    private final LoaderVisitor visitor;\n+    private final int length;\n+    private int position = 0;\n+    private int line = 1;\n+    private int column = 1;\n+    private String namespace;\n+    private String definedVersion;\n+    private TraitEntry pendingDocumentationComment;\n+\n+    /** Map of shape aliases to their targets. */\n+    private final Map<String, ShapeId> useShapes = new HashMap<>();\n+\n+    // A pending trait that also doesn't yet have a resolved trait shape ID.\n+    static final class TraitEntry {\n+        final String traitName;\n+        final Node value;\n+        final boolean isAnnotation;\n+\n+        TraitEntry(String traitName, Node value, boolean isAnnotation) {\n+            this.traitName = traitName;\n+            this.value = value;\n+            this.isAnnotation = isAnnotation;\n+        }\n+    }\n+\n+    IdlModelParser(String filename, String model, LoaderVisitor visitor) {\n+        this.filename = filename;\n+        this.visitor = visitor;\n+        this.model = model;\n+        this.length = model.length();\n+    }\n+\n+    void parse() {\n+        ws();\n+        parseControlSection();\n+        parseMetadataSection();\n+        parseShapeSection();\n+    }\n+\n+    private void parseControlSection() {\n+        while (charPeek() == '$') {\n+            skip(); // Skip \"$\".\n+            ws();\n+            String key = IdlNodeParser.parseNodeObjectKey(this);\n+            ws();\n+            expect(':');\n+            ws();\n+            Node value = IdlNodeParser.parseNode(this);\n+            br();\n+            ws();\n+\n+            if (key.equals(\"version\")) {\n+                onVersion(value);\n+            } else {\n+                visitor.onError(ValidationEvent.builder()\n+                        .eventId(Validator.MODEL_ERROR)\n+                        .sourceLocation(value)\n+                        .severity(Severity.WARNING)\n+                        .message(format(\"Unknown control statement `%s` with value `%s\", key, Node.printJson(value)))\n+                        .build());\n+            }\n+        }\n+    }\n+\n+    private void onVersion(Node value) {\n+        if (!value.isStringNode()) {\n+            value.expectStringNode(\"The $version control statement must have a string value, but found \"\n+                                   + Node.printJson(value));\n+        }\n+\n+        String parsedVersion = value.expectStringNode().getValue();\n+\n+        if (definedVersion != null) {\n+            throw syntax(\"Cannot define multiple versions in the same file\");\n+        }\n+\n+        if (!visitor.isVersionSupported(parsedVersion)) {\n+            throw syntax(\"Unsupported Smithy version number: \" + parsedVersion);\n+        }\n+\n+        definedVersion = parsedVersion;\n+    }\n+\n+    private void parseMetadataSection() {\n+        while (charPeek() == 'm') {\n+            expect('m');\n+            expect('e');\n+            expect('t');\n+            expect('a');\n+            expect('d');\n+            expect('a');\n+            expect('t');\n+            expect('a');\n+            ws();\n+            String key = IdlNodeParser.parseNodeObjectKey(this);\n+            ws();\n+            expect('=');\n+            ws();\n+            visitor.onMetadata(key, IdlNodeParser.parseNode(this));\n+            br();\n+            ws();\n+        }\n+    }\n+\n+    private void parseShapeSection() {\n+        if (charPeek() == 'n') {\n+            expect('n');\n+            expect('a');\n+            expect('m');\n+            expect('e');\n+            expect('s');\n+            expect('p');\n+            expect('a');\n+            expect('c');\n+            expect('e');\n+            ws();\n+            namespace = IdlShapeIdParser.parseNamespace(this);\n+            br();\n+            // Clear out any erroneous documentation comments.\n+            pendingDocumentationComment = null;\n+            ws();\n+            parseUseSection();\n+            parseShapeStatements();\n+        } else if (!eof()) {\n+            if (!IdlShapeIdParser.isIdentifierStart(charPeek())) {\n+                throw syntax(\"Expected a namespace definition, but found unexpected syntax\");\n+            } else {\n+                throw syntax(\"A namespace must be defined before a use statement or shapes\");\n+            }\n+        }\n+    }\n+\n+    private void parseUseSection() {\n+        while (charPeek() == 'u' && charPeek(1) == 's') {\n+            expect('u');\n+            expect('s');\n+            expect('e');\n+            ws();\n+\n+            int start = position;\n+            IdlShapeIdParser.consumeNamespace(this);\n+            expect('#');\n+            IdlShapeIdParser.consumeIdentifier(this);\n+            String lexeme = sliceFrom(start);\n+            br();\n+            // Clear out any erroneous documentation comments.\n+            pendingDocumentationComment = null;", "originalCommit": "6533f90c1a3cfdddffd2f21e7e5017db650c8989", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2752061a913913f089fe97bffbbb23f0551b357e", "chunk": "diff --git a/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java b/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java\nindex b7d1b2a16..50fe57ecb 100644\n--- a/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java\n+++ b/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java\n\n@@ -144,15 +144,19 @@ final class IdlModelParser {\n \n     private void parseControlSection() {\n         while (charPeek() == '$') {\n-            skip(); // Skip \"$\".\n+            expect('$');\n             ws();\n             String key = IdlNodeParser.parseNodeObjectKey(this);\n             ws();\n             expect(':');\n             ws();\n+\n+            // Validation here for better error location.\n+            if (key.equals(\"version\") && definedVersion != null) {\n+                throw syntax(\"Cannot define multiple versions in the same file\");\n+            }\n+\n             Node value = IdlNodeParser.parseNode(this);\n-            br();\n-            ws();\n \n             if (key.equals(\"version\")) {\n                 onVersion(value);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMzcxNg==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424023716", "bodyText": "Use clearPendingDocs for safety.", "author": "kstich", "createdAt": "2020-05-12T20:47:48Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java", "diffHunk": "@@ -0,0 +1,897 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.loader;\n+\n+import static java.lang.String.format;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.FromSourceLocation;\n+import software.amazon.smithy.model.SourceLocation;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.shapes.AbstractShapeBuilder;\n+import software.amazon.smithy.model.shapes.BigDecimalShape;\n+import software.amazon.smithy.model.shapes.BigIntegerShape;\n+import software.amazon.smithy.model.shapes.BlobShape;\n+import software.amazon.smithy.model.shapes.BooleanShape;\n+import software.amazon.smithy.model.shapes.ByteShape;\n+import software.amazon.smithy.model.shapes.CollectionShape;\n+import software.amazon.smithy.model.shapes.DocumentShape;\n+import software.amazon.smithy.model.shapes.DoubleShape;\n+import software.amazon.smithy.model.shapes.FloatShape;\n+import software.amazon.smithy.model.shapes.IntegerShape;\n+import software.amazon.smithy.model.shapes.ListShape;\n+import software.amazon.smithy.model.shapes.LongShape;\n+import software.amazon.smithy.model.shapes.MapShape;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.OperationShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.ServiceShape;\n+import software.amazon.smithy.model.shapes.SetShape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeType;\n+import software.amazon.smithy.model.shapes.ShortShape;\n+import software.amazon.smithy.model.shapes.StringShape;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.TimestampShape;\n+import software.amazon.smithy.model.shapes.UnionShape;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.validation.Severity;\n+import software.amazon.smithy.model.validation.ValidationEvent;\n+import software.amazon.smithy.model.validation.ValidationUtils;\n+import software.amazon.smithy.model.validation.Validator;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+final class IdlModelParser {\n+\n+    private static final String PUT_KEY = \"put\";\n+    private static final String CREATE_KEY = \"create\";\n+    private static final String READ_KEY = \"read\";\n+    private static final String UPDATE_KEY = \"update\";\n+    private static final String DELETE_KEY = \"delete\";\n+    private static final String LIST_KEY = \"list\";\n+    private static final String RESOURCES_KEY = \"resources\";\n+    private static final String OPERATIONS_KEY = \"operations\";\n+    private static final String COLLECTION_OPERATIONS_KEY = \"collectionOperations\";\n+    private static final String IDENTIFIERS_KEY = \"identifiers\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String TYPE_KEY = \"type\";\n+\n+    static final Collection<String> RESOURCE_PROPERTY_NAMES = ListUtils.of(\n+            TYPE_KEY, CREATE_KEY, READ_KEY, UPDATE_KEY, DELETE_KEY, LIST_KEY,\n+            IDENTIFIERS_KEY, RESOURCES_KEY, OPERATIONS_KEY, PUT_KEY, COLLECTION_OPERATIONS_KEY);\n+    static final List<String> SERVICE_PROPERTY_NAMES = ListUtils.of(\n+            TYPE_KEY, VERSION_KEY, OPERATIONS_KEY, RESOURCES_KEY);\n+    private static final Collection<String> OPERATION_PROPERTY_NAMES = ListUtils.of(\"input\", \"output\", \"errors\");\n+    private static final Set<String> SHAPE_TYPES = new HashSet<>();\n+\n+    static {\n+        for (ShapeType type : ShapeType.values()) {\n+            if (type != ShapeType.MEMBER) {\n+                SHAPE_TYPES.add(type.toString());\n+            }\n+        }\n+    }\n+\n+    private final String filename;\n+    private final String model;\n+    private final LoaderVisitor visitor;\n+    private final int length;\n+    private int position = 0;\n+    private int line = 1;\n+    private int column = 1;\n+    private String namespace;\n+    private String definedVersion;\n+    private TraitEntry pendingDocumentationComment;\n+\n+    /** Map of shape aliases to their targets. */\n+    private final Map<String, ShapeId> useShapes = new HashMap<>();\n+\n+    // A pending trait that also doesn't yet have a resolved trait shape ID.\n+    static final class TraitEntry {\n+        final String traitName;\n+        final Node value;\n+        final boolean isAnnotation;\n+\n+        TraitEntry(String traitName, Node value, boolean isAnnotation) {\n+            this.traitName = traitName;\n+            this.value = value;\n+            this.isAnnotation = isAnnotation;\n+        }\n+    }\n+\n+    IdlModelParser(String filename, String model, LoaderVisitor visitor) {\n+        this.filename = filename;\n+        this.visitor = visitor;\n+        this.model = model;\n+        this.length = model.length();\n+    }\n+\n+    void parse() {\n+        ws();\n+        parseControlSection();\n+        parseMetadataSection();\n+        parseShapeSection();\n+    }\n+\n+    private void parseControlSection() {\n+        while (charPeek() == '$') {\n+            skip(); // Skip \"$\".\n+            ws();\n+            String key = IdlNodeParser.parseNodeObjectKey(this);\n+            ws();\n+            expect(':');\n+            ws();\n+            Node value = IdlNodeParser.parseNode(this);\n+            br();\n+            ws();\n+\n+            if (key.equals(\"version\")) {\n+                onVersion(value);\n+            } else {\n+                visitor.onError(ValidationEvent.builder()\n+                        .eventId(Validator.MODEL_ERROR)\n+                        .sourceLocation(value)\n+                        .severity(Severity.WARNING)\n+                        .message(format(\"Unknown control statement `%s` with value `%s\", key, Node.printJson(value)))\n+                        .build());\n+            }\n+        }\n+    }\n+\n+    private void onVersion(Node value) {\n+        if (!value.isStringNode()) {\n+            value.expectStringNode(\"The $version control statement must have a string value, but found \"\n+                                   + Node.printJson(value));\n+        }\n+\n+        String parsedVersion = value.expectStringNode().getValue();\n+\n+        if (definedVersion != null) {\n+            throw syntax(\"Cannot define multiple versions in the same file\");\n+        }\n+\n+        if (!visitor.isVersionSupported(parsedVersion)) {\n+            throw syntax(\"Unsupported Smithy version number: \" + parsedVersion);\n+        }\n+\n+        definedVersion = parsedVersion;\n+    }\n+\n+    private void parseMetadataSection() {\n+        while (charPeek() == 'm') {\n+            expect('m');\n+            expect('e');\n+            expect('t');\n+            expect('a');\n+            expect('d');\n+            expect('a');\n+            expect('t');\n+            expect('a');\n+            ws();\n+            String key = IdlNodeParser.parseNodeObjectKey(this);\n+            ws();\n+            expect('=');\n+            ws();\n+            visitor.onMetadata(key, IdlNodeParser.parseNode(this));\n+            br();\n+            ws();\n+        }\n+    }\n+\n+    private void parseShapeSection() {\n+        if (charPeek() == 'n') {\n+            expect('n');\n+            expect('a');\n+            expect('m');\n+            expect('e');\n+            expect('s');\n+            expect('p');\n+            expect('a');\n+            expect('c');\n+            expect('e');\n+            ws();\n+            namespace = IdlShapeIdParser.parseNamespace(this);\n+            br();\n+            // Clear out any erroneous documentation comments.\n+            pendingDocumentationComment = null;", "originalCommit": "6533f90c1a3cfdddffd2f21e7e5017db650c8989", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2752061a913913f089fe97bffbbb23f0551b357e", "chunk": "diff --git a/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java b/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java\nindex b7d1b2a16..50fe57ecb 100644\n--- a/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java\n+++ b/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java\n\n@@ -144,15 +144,19 @@ final class IdlModelParser {\n \n     private void parseControlSection() {\n         while (charPeek() == '$') {\n-            skip(); // Skip \"$\".\n+            expect('$');\n             ws();\n             String key = IdlNodeParser.parseNodeObjectKey(this);\n             ws();\n             expect(':');\n             ws();\n+\n+            // Validation here for better error location.\n+            if (key.equals(\"version\") && definedVersion != null) {\n+                throw syntax(\"Cannot define multiple versions in the same file\");\n+            }\n+\n             Node value = IdlNodeParser.parseNode(this);\n-            br();\n-            ws();\n \n             if (key.equals(\"version\")) {\n                 onVersion(value);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNTEwNw==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424025107", "bodyText": "There's inconsistency here in ordering of calls to parseMembers vs visitor.onShape(), is there significance that's not documented or is it just happenstance?", "author": "kstich", "createdAt": "2020-05-12T20:50:20Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java", "diffHunk": "@@ -0,0 +1,897 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.loader;\n+\n+import static java.lang.String.format;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.FromSourceLocation;\n+import software.amazon.smithy.model.SourceLocation;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.shapes.AbstractShapeBuilder;\n+import software.amazon.smithy.model.shapes.BigDecimalShape;\n+import software.amazon.smithy.model.shapes.BigIntegerShape;\n+import software.amazon.smithy.model.shapes.BlobShape;\n+import software.amazon.smithy.model.shapes.BooleanShape;\n+import software.amazon.smithy.model.shapes.ByteShape;\n+import software.amazon.smithy.model.shapes.CollectionShape;\n+import software.amazon.smithy.model.shapes.DocumentShape;\n+import software.amazon.smithy.model.shapes.DoubleShape;\n+import software.amazon.smithy.model.shapes.FloatShape;\n+import software.amazon.smithy.model.shapes.IntegerShape;\n+import software.amazon.smithy.model.shapes.ListShape;\n+import software.amazon.smithy.model.shapes.LongShape;\n+import software.amazon.smithy.model.shapes.MapShape;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.OperationShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.ServiceShape;\n+import software.amazon.smithy.model.shapes.SetShape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeType;\n+import software.amazon.smithy.model.shapes.ShortShape;\n+import software.amazon.smithy.model.shapes.StringShape;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.TimestampShape;\n+import software.amazon.smithy.model.shapes.UnionShape;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.validation.Severity;\n+import software.amazon.smithy.model.validation.ValidationEvent;\n+import software.amazon.smithy.model.validation.ValidationUtils;\n+import software.amazon.smithy.model.validation.Validator;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+final class IdlModelParser {\n+\n+    private static final String PUT_KEY = \"put\";\n+    private static final String CREATE_KEY = \"create\";\n+    private static final String READ_KEY = \"read\";\n+    private static final String UPDATE_KEY = \"update\";\n+    private static final String DELETE_KEY = \"delete\";\n+    private static final String LIST_KEY = \"list\";\n+    private static final String RESOURCES_KEY = \"resources\";\n+    private static final String OPERATIONS_KEY = \"operations\";\n+    private static final String COLLECTION_OPERATIONS_KEY = \"collectionOperations\";\n+    private static final String IDENTIFIERS_KEY = \"identifiers\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String TYPE_KEY = \"type\";\n+\n+    static final Collection<String> RESOURCE_PROPERTY_NAMES = ListUtils.of(\n+            TYPE_KEY, CREATE_KEY, READ_KEY, UPDATE_KEY, DELETE_KEY, LIST_KEY,\n+            IDENTIFIERS_KEY, RESOURCES_KEY, OPERATIONS_KEY, PUT_KEY, COLLECTION_OPERATIONS_KEY);\n+    static final List<String> SERVICE_PROPERTY_NAMES = ListUtils.of(\n+            TYPE_KEY, VERSION_KEY, OPERATIONS_KEY, RESOURCES_KEY);\n+    private static final Collection<String> OPERATION_PROPERTY_NAMES = ListUtils.of(\"input\", \"output\", \"errors\");\n+    private static final Set<String> SHAPE_TYPES = new HashSet<>();\n+\n+    static {\n+        for (ShapeType type : ShapeType.values()) {\n+            if (type != ShapeType.MEMBER) {\n+                SHAPE_TYPES.add(type.toString());\n+            }\n+        }\n+    }\n+\n+    private final String filename;\n+    private final String model;\n+    private final LoaderVisitor visitor;\n+    private final int length;\n+    private int position = 0;\n+    private int line = 1;\n+    private int column = 1;\n+    private String namespace;\n+    private String definedVersion;\n+    private TraitEntry pendingDocumentationComment;\n+\n+    /** Map of shape aliases to their targets. */\n+    private final Map<String, ShapeId> useShapes = new HashMap<>();\n+\n+    // A pending trait that also doesn't yet have a resolved trait shape ID.\n+    static final class TraitEntry {\n+        final String traitName;\n+        final Node value;\n+        final boolean isAnnotation;\n+\n+        TraitEntry(String traitName, Node value, boolean isAnnotation) {\n+            this.traitName = traitName;\n+            this.value = value;\n+            this.isAnnotation = isAnnotation;\n+        }\n+    }\n+\n+    IdlModelParser(String filename, String model, LoaderVisitor visitor) {\n+        this.filename = filename;\n+        this.visitor = visitor;\n+        this.model = model;\n+        this.length = model.length();\n+    }\n+\n+    void parse() {\n+        ws();\n+        parseControlSection();\n+        parseMetadataSection();\n+        parseShapeSection();\n+    }\n+\n+    private void parseControlSection() {\n+        while (charPeek() == '$') {\n+            skip(); // Skip \"$\".\n+            ws();\n+            String key = IdlNodeParser.parseNodeObjectKey(this);\n+            ws();\n+            expect(':');\n+            ws();\n+            Node value = IdlNodeParser.parseNode(this);\n+            br();\n+            ws();\n+\n+            if (key.equals(\"version\")) {\n+                onVersion(value);\n+            } else {\n+                visitor.onError(ValidationEvent.builder()\n+                        .eventId(Validator.MODEL_ERROR)\n+                        .sourceLocation(value)\n+                        .severity(Severity.WARNING)\n+                        .message(format(\"Unknown control statement `%s` with value `%s\", key, Node.printJson(value)))\n+                        .build());\n+            }\n+        }\n+    }\n+\n+    private void onVersion(Node value) {\n+        if (!value.isStringNode()) {\n+            value.expectStringNode(\"The $version control statement must have a string value, but found \"\n+                                   + Node.printJson(value));\n+        }\n+\n+        String parsedVersion = value.expectStringNode().getValue();\n+\n+        if (definedVersion != null) {\n+            throw syntax(\"Cannot define multiple versions in the same file\");\n+        }\n+\n+        if (!visitor.isVersionSupported(parsedVersion)) {\n+            throw syntax(\"Unsupported Smithy version number: \" + parsedVersion);\n+        }\n+\n+        definedVersion = parsedVersion;\n+    }\n+\n+    private void parseMetadataSection() {\n+        while (charPeek() == 'm') {\n+            expect('m');\n+            expect('e');\n+            expect('t');\n+            expect('a');\n+            expect('d');\n+            expect('a');\n+            expect('t');\n+            expect('a');\n+            ws();\n+            String key = IdlNodeParser.parseNodeObjectKey(this);\n+            ws();\n+            expect('=');\n+            ws();\n+            visitor.onMetadata(key, IdlNodeParser.parseNode(this));\n+            br();\n+            ws();\n+        }\n+    }\n+\n+    private void parseShapeSection() {\n+        if (charPeek() == 'n') {\n+            expect('n');\n+            expect('a');\n+            expect('m');\n+            expect('e');\n+            expect('s');\n+            expect('p');\n+            expect('a');\n+            expect('c');\n+            expect('e');\n+            ws();\n+            namespace = IdlShapeIdParser.parseNamespace(this);\n+            br();\n+            // Clear out any erroneous documentation comments.\n+            pendingDocumentationComment = null;\n+            ws();\n+            parseUseSection();\n+            parseShapeStatements();\n+        } else if (!eof()) {\n+            if (!IdlShapeIdParser.isIdentifierStart(charPeek())) {\n+                throw syntax(\"Expected a namespace definition, but found unexpected syntax\");\n+            } else {\n+                throw syntax(\"A namespace must be defined before a use statement or shapes\");\n+            }\n+        }\n+    }\n+\n+    private void parseUseSection() {\n+        while (charPeek() == 'u' && charPeek(1) == 's') {\n+            expect('u');\n+            expect('s');\n+            expect('e');\n+            ws();\n+\n+            int start = position;\n+            IdlShapeIdParser.consumeNamespace(this);\n+            expect('#');\n+            IdlShapeIdParser.consumeIdentifier(this);\n+            String lexeme = sliceFrom(start);\n+            br();\n+            // Clear out any erroneous documentation comments.\n+            pendingDocumentationComment = null;\n+            ws();\n+\n+            ShapeId target = ShapeId.from(lexeme);\n+            ShapeId previous = useShapes.put(target.getName(), target);\n+            if (previous != null) {\n+                throw syntax(String.format(\"Cannot use name `%s` because it conflicts with `%s`\",\n+                                           target, previous));\n+            }\n+        }\n+    }\n+\n+    private void parseShapeStatements() {\n+        while (!eof()) {\n+            ws();\n+            if (charPeek() == 'a') {\n+                parseApplyStatement();\n+            } else {\n+                boolean docsOnly = pendingDocumentationComment != null;\n+                List<TraitEntry> traits = parseDocsAndTraits();\n+                if (parseShapeDefinition(traits, docsOnly)) {\n+                    parseShape(traits);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void clearPendingDocs() {\n+        pendingDocumentationComment = null;\n+    }\n+\n+    private boolean parseShapeDefinition(List<TraitEntry> traits, boolean docsOnly) {\n+        if (eof()) {\n+            return !traits.isEmpty() && !docsOnly;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private List<TraitEntry> parseDocsAndTraits() {\n+        // Grab the pending docs, if present, and clear its state.\n+        TraitEntry docComment = pendingDocumentationComment;\n+        clearPendingDocs();\n+\n+        // Parse traits, if any.\n+        ws();\n+        List<TraitEntry> traits = IdlTraitParser.parseTraits(this);\n+        if (docComment != null) {\n+            traits.add(docComment);\n+        }\n+        ws();\n+\n+        return traits;\n+    }\n+\n+    private void parseShape(List<TraitEntry> traits) {\n+        SourceLocation location = currentLocation();\n+\n+        // Do a check here to give better parsing error messages.\n+        String shapeType = IdlShapeIdParser.parseIdentifier(this);\n+        if (!SHAPE_TYPES.contains(shapeType)) {\n+            switch (shapeType) {\n+                case \"use\":\n+                    throw syntax(\"A use statement must come before any shape definition\");\n+                case \"namespace\":\n+                    throw syntax(\"Only a single namespace can be declared per/file\");\n+                case \"metadata\":\n+                    throw syntax(\"Metadata statements must appear before a namespace statement\");\n+                default:\n+                    throw syntax(\"Unexpected shape type: \" + shapeType);\n+            }\n+        }\n+\n+        ws();\n+        ShapeId id = parseShapeName();\n+\n+        switch (shapeType) {\n+            case \"service\":\n+                parseServiceStatement(id, location);\n+                break;\n+            case \"resource\":\n+                parseResourceStatement(id, location);\n+                break;\n+            case \"operation\":\n+                parseOperationStatement(id, location);\n+                break;\n+            case \"structure\":\n+                parseStructuredShape(id, location, StructureShape.builder());\n+                break;\n+            case \"union\":\n+                parseStructuredShape(id, location, UnionShape.builder());\n+                break;\n+            case \"list\":\n+                parseCollection(id, location, ListShape.builder());\n+                break;\n+            case \"set\":\n+                parseCollection(id, location, SetShape.builder());\n+                break;\n+            case \"map\":\n+                parseMapStatement(id, location);\n+                break;\n+            case \"boolean\":\n+                parseSimpleShape(id, location, BooleanShape.builder());\n+                break;\n+            case \"string\":\n+                parseSimpleShape(id, location, StringShape.builder());\n+                break;\n+            case \"blob\":\n+                parseSimpleShape(id, location, BlobShape.builder());\n+                break;\n+            case \"byte\":\n+                parseSimpleShape(id, location, ByteShape.builder());\n+                break;\n+            case \"short\":\n+                parseSimpleShape(id, location, ShortShape.builder());\n+                break;\n+            case \"integer\":\n+                parseSimpleShape(id, location, IntegerShape.builder());\n+                break;\n+            case \"long\":\n+                parseSimpleShape(id, location, LongShape.builder());\n+                break;\n+            case \"float\":\n+                parseSimpleShape(id, location, FloatShape.builder());\n+                break;\n+            case \"document\":\n+                parseSimpleShape(id, location, DocumentShape.builder());\n+                break;\n+            case \"double\":\n+                parseSimpleShape(id, location, DoubleShape.builder());\n+                break;\n+            case \"bigInteger\":\n+                parseSimpleShape(id, location, BigIntegerShape.builder());\n+                break;\n+            case \"bigDecimal\":\n+                parseSimpleShape(id, location, BigDecimalShape.builder());\n+                break;\n+            case \"timestamp\":\n+                parseSimpleShape(id, location, TimestampShape.builder());\n+                break;\n+            default:\n+                // Unreachable.\n+                throw syntax(\"Unexpected shape type: \" + shapeType);\n+        }\n+\n+        addTraits(id, traits);\n+        clearPendingDocs();\n+        br();\n+    }\n+\n+    private ShapeId parseShapeName() {\n+        String name = IdlShapeIdParser.parseIdentifier(this);\n+\n+        if (useShapes.containsKey(name)) {\n+            throw syntax(String.format(\n+                    \"shape name `%s` conflicts with imported shape `%s`\", name, useShapes.get(name)));\n+        }\n+\n+        return ShapeId.fromRelative(namespace, name);\n+    }\n+\n+    private void parseSimpleShape(ShapeId id, SourceLocation location, AbstractShapeBuilder builder) {\n+        visitor.onShape(builder.source(location).id(id));\n+    }\n+\n+    private void parseCollection(ShapeId id, SourceLocation location, CollectionShape.Builder builder) {\n+        ws();\n+        builder.id(id).source(location);\n+        parseMembers(id, SetUtils.of(\"member\"));\n+        visitor.onShape(builder.id(id));\n+    }\n+\n+    private void parseMembers(ShapeId id, Set<String> requiredMembers) {\n+        Set<String> remaining = requiredMembers.isEmpty()\n+                ? requiredMembers\n+                : new HashSet<>(requiredMembers);\n+        ws();\n+        expect('{');\n+        // Don't keep any previous state of captured doc comments when\n+        // parsing members.\n+        clearPendingDocs();\n+        ws();\n+\n+        if (charPeek() != '}') {\n+            // Remove the parsed member from the remaining set to detect\n+            // when duplicates are found, or when members are missing.\n+            remaining.remove(parseMember(id, remaining));\n+            while (!eof()) {\n+                ws();\n+                if (charPeek() == ',') {\n+                    expect(',');\n+                    // A comma clears out any previously captured documentation\n+                    // comments that may have been found when parsing the member.\n+                    clearPendingDocs();\n+                    ws();\n+                    if (charPeek() == '}') {\n+                        // Trailing comma: \",\" \"}\"\n+                        break;\n+                    }\n+\n+                    // Special casing to detect invalid members early on, even\n+                    // after draining all the valid members. This keeps builders\n+                    // from raising confusing errors about invalid members.\n+                    if (remaining.isEmpty() && !requiredMembers.isEmpty()) {\n+                        parseMember(id, requiredMembers);\n+                    } else {\n+                        remaining.remove(parseMember(id, remaining));\n+                    }\n+                } else {\n+                    // Assume '}'; break to enforce.\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (!remaining.isEmpty()) {\n+            throw syntax(\"Missing required members of shape `\" + id + \"`: [\"\n+                         + ValidationUtils.tickedList(remaining) + ']');\n+        }\n+\n+        expect('}');\n+    }\n+\n+    private String parseMember(ShapeId parent, Set<String> requiredMembers) {\n+        // Parse optional member traits.\n+        List<TraitEntry> memberTraits = parseDocsAndTraits();\n+        SourceLocation memberLocation = currentLocation();\n+        String memberName = IdlShapeIdParser.parseIdentifier(this);\n+\n+        // Only enforce \"allowedMembers\" if it isn't empty.\n+        if (!requiredMembers.isEmpty() && !requiredMembers.contains(memberName)) {\n+            throw syntax(\"Unexpected member of \" + parent + \": '\" + memberName + '\\'');\n+        }\n+\n+        ws();\n+        expect(':');\n+        ws();\n+        ShapeId memberId = parent.withMember(memberName);\n+        MemberShape.Builder memberBuilder = MemberShape.builder().id(memberId).source(memberLocation);\n+        SourceLocation targetLocation = currentLocation();\n+        String target = IdlShapeIdParser.parseShapeId(this);\n+        visitor.onShape(memberBuilder);\n+        onShapeTarget(target, targetLocation, memberBuilder::target);\n+        addTraits(memberId, memberTraits);\n+\n+        return memberName;\n+    }\n+\n+    private void parseMapStatement(ShapeId id, SourceLocation location) {\n+        parseMembers(id, SetUtils.of(\"key\", \"value\"));\n+        visitor.onShape(MapShape.builder().id(id).source(location));\n+    }\n+\n+    private void parseStructuredShape(ShapeId id, SourceLocation location, AbstractShapeBuilder builder) {\n+        visitor.onShape(builder.id(id).source(location));", "originalCommit": "6533f90c1a3cfdddffd2f21e7e5017db650c8989", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0ODc1Mw==", "url": "https://github.com/awslabs/smithy/pull/434#discussion_r424048753", "bodyText": "Parsing members of list/set/map before registering the shape with the LoaderVisitor ensures that the shape is only registered if it as all of its required members. Otherwise, the LoaderVisitor gives a cryptic message with no context about how a \"member\" wasn't set on a builder. I added a comment to say this in code.\nAs for structures:\n// Register the structure/union with the loader before parsing members.\n// This will detect shape conflicts with other types (like an operation)\n// and still give useful error messages. Trying to parse members first\n// would otherwise result in cryptic error messages like:\n// \"Member `foo.baz#Foo$Baz` cannot be added to software.amazon.smithy.model.shapes.OperationShape$Builder\"", "author": "mtdowling", "createdAt": "2020-05-12T21:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNTEwNw=="}], "type": "inlineReview", "revised_code": {"commit": "2752061a913913f089fe97bffbbb23f0551b357e", "chunk": "diff --git a/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java b/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java\nindex b7d1b2a16..50fe57ecb 100644\n--- a/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java\n+++ b/smithy-model/src/main/java/software/amazon/smithy/model/loader/IdlModelParser.java\n\n@@ -144,15 +144,19 @@ final class IdlModelParser {\n \n     private void parseControlSection() {\n         while (charPeek() == '$') {\n-            skip(); // Skip \"$\".\n+            expect('$');\n             ws();\n             String key = IdlNodeParser.parseNodeObjectKey(this);\n             ws();\n             expect(':');\n             ws();\n+\n+            // Validation here for better error location.\n+            if (key.equals(\"version\") && definedVersion != null) {\n+                throw syntax(\"Cannot define multiple versions in the same file\");\n+            }\n+\n             Node value = IdlNodeParser.parseNode(this);\n-            br();\n-            ws();\n \n             if (key.equals(\"version\")) {\n                 onVersion(value);\n"}}, {"oid": "2752061a913913f089fe97bffbbb23f0551b357e", "url": "https://github.com/awslabs/smithy/commit/2752061a913913f089fe97bffbbb23f0551b357e", "message": "Rewrite grammar and parser\n\nThis commit is a complete rewrite of the Smithy IDL parser and grammar.\nIt is intended to clear up the intention of how the IDL works in\npractice by making the grammar embed things like how control statements\ncome before metadata, which come before namespace, etc.. It also\nclarifies how different node_value locations have different semantics\n(e.g., keys in objects are not resolved against keywords like\ntrue and do not perform relative shape ID resolution nor do they support\ntext blocks). Many other fixes have been made to the grammar too,\nincluding specifying where whitespace is allowed and where line breaks\nare required. This makes the grammar more verbose but also more accurate\nand in line with what was already implemented.\n\nWith these changes, control statement keyus, metadata keys, and object keys\nmust now be quoted if they contain \".\", \"#\", or \"$\". In practice, the\nmodel parser already enforced these constraints in some places.", "committedDate": "2020-05-12T23:51:36Z", "type": "forcePushed"}, {"oid": "e6836f863718c72e09a1f5be3e4a02df4e5df272", "url": "https://github.com/awslabs/smithy/commit/e6836f863718c72e09a1f5be3e4a02df4e5df272", "message": "Rewrite grammar and parser\n\nThis commit is a complete rewrite of the Smithy IDL parser and grammar.\nIt is intended to clear up the intention of how the IDL works in\npractice by making the grammar embed things like how control statements\ncome before metadata, which come before namespace, etc.. It also\nclarifies how different node_value locations have different semantics\n(e.g., keys in objects are not resolved against keywords like\ntrue and do not perform relative shape ID resolution nor do they support\ntext blocks). Many other fixes have been made to the grammar too,\nincluding specifying where whitespace is allowed and where line breaks\nare required. This makes the grammar more verbose but also more accurate\nand in line with what was already implemented.\n\nWith these changes, control statement keyus, metadata keys, and object keys\nmust now be quoted if they contain \".\", \"#\", or \"$\". In practice, the\nmodel parser already enforced these constraints in some places.", "committedDate": "2020-05-12T23:55:26Z", "type": "forcePushed"}, {"oid": "bec25c81b5763409c240aa83d015b34376bdf347", "url": "https://github.com/awslabs/smithy/commit/bec25c81b5763409c240aa83d015b34376bdf347", "message": "Rewrite grammar and parser\n\nThis commit is a complete rewrite of the Smithy IDL parser and grammar.\nIt is intended to clear up the intention of how the IDL works in\npractice by making the grammar embed things like how control statements\ncome before metadata, which come before namespace, etc.. It also\nclarifies how different node_value locations have different semantics\n(e.g., keys in objects are not resolved against keywords like\ntrue and do not perform relative shape ID resolution nor do they support\ntext blocks). Many other fixes have been made to the grammar too,\nincluding specifying where whitespace is allowed and where line breaks\nare required. This makes the grammar more verbose but also more accurate\nand in line with what was already implemented.\n\nWith these changes, control statement keyus, metadata keys, and object keys\nmust now be quoted if they contain \".\", \"#\", or \"$\". In practice, the\nmodel parser already enforced these constraints in some places.", "committedDate": "2020-05-13T00:03:43Z", "type": "forcePushed"}, {"oid": "1e2a417c522932ba346edbe0f94c459d95bdeeaf", "url": "https://github.com/awslabs/smithy/commit/1e2a417c522932ba346edbe0f94c459d95bdeeaf", "message": "Rewrite grammar and parser\n\nThis commit is a complete rewrite of the Smithy IDL parser and grammar.\nIt is intended to clear up the intention of how the IDL works in\npractice by making the grammar embed things like how control statements\ncome before metadata, which come before namespace, etc.. It also\nclarifies how different node_value locations have different semantics\n(e.g., keys in objects are not resolved against keywords like\ntrue and do not perform relative shape ID resolution nor do they support\ntext blocks). Many other fixes have been made to the grammar too,\nincluding specifying where whitespace is allowed and where line breaks\nare required. This makes the grammar more verbose but also more accurate\nand in line with what was already implemented.\n\nWith these changes, control statement keyus, metadata keys, and object keys\nmust now be quoted if they contain \".\", \"#\", or \"$\". In practice, the\nmodel parser already enforced these constraints in some places.", "committedDate": "2020-05-13T17:39:15Z", "type": "commit"}, {"oid": "1e2a417c522932ba346edbe0f94c459d95bdeeaf", "url": "https://github.com/awslabs/smithy/commit/1e2a417c522932ba346edbe0f94c459d95bdeeaf", "message": "Rewrite grammar and parser\n\nThis commit is a complete rewrite of the Smithy IDL parser and grammar.\nIt is intended to clear up the intention of how the IDL works in\npractice by making the grammar embed things like how control statements\ncome before metadata, which come before namespace, etc.. It also\nclarifies how different node_value locations have different semantics\n(e.g., keys in objects are not resolved against keywords like\ntrue and do not perform relative shape ID resolution nor do they support\ntext blocks). Many other fixes have been made to the grammar too,\nincluding specifying where whitespace is allowed and where line breaks\nare required. This makes the grammar more verbose but also more accurate\nand in line with what was already implemented.\n\nWith these changes, control statement keyus, metadata keys, and object keys\nmust now be quoted if they contain \".\", \"#\", or \"$\". In practice, the\nmodel parser already enforced these constraints in some places.", "committedDate": "2020-05-13T17:39:15Z", "type": "forcePushed"}]}