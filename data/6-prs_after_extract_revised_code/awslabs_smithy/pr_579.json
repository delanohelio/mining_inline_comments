{"pr_number": 579, "pr_title": "Add aws.cloudformation traits", "pr_createdAt": "2020-09-28T23:08:21Z", "pr_url": "https://github.com/awslabs/smithy/pull/579", "timeline": [{"oid": "dc5a8a75efaa99e6558699ab17909e7530b0da83", "url": "https://github.com/awslabs/smithy/commit/dc5a8a75efaa99e6558699ab17909e7530b0da83", "message": "Add aws.cloudformation traits\n\nThis commit adds several traits in the aws.cloudformation namespace,\ncontained in a new smithy-aws-cloudformation-traits package. These\ntraits indicate CloudFormation resources and the additional metadata\nabout their properties. A ResourceIndex is also included to make using\nthis information more accessible and to handle derived property\nmutabilities.", "committedDate": "2020-09-28T23:13:08Z", "type": "forcePushed"}, {"oid": "ba0156755e01e2b53becf2539f4624825a95b2b7", "url": "https://github.com/awslabs/smithy/commit/ba0156755e01e2b53becf2539f4624825a95b2b7", "message": "Add aws.cloudformation traits\n\nThis commit adds several traits in the aws.cloudformation namespace,\ncontained in a new smithy-aws-cloudformation-traits package. These\ntraits indicate CloudFormation resources and the additional metadata\nabout their properties. A ResourceIndex is also included to make using\nthis information more accessible and to handle derived property\nmutabilities.", "committedDate": "2020-10-16T23:26:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg5NDQzOA==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r508894438", "bodyText": "Can this be private? I don't think we'd want this kind of defaulting exposed outside the trait implementation.\nIt might help with clarity here too by renaming this to shapeName.", "author": "mtdowling", "createdAt": "2020-10-20T23:15:41Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceTrait.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.traits.AbstractTrait;\n+import software.amazon.smithy.model.traits.AbstractTraitBuilder;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.ToSmithyBuilder;\n+\n+/**\n+ * Indicates that a Smithy resource is a CloudFormation resource.\n+ */\n+public final class ResourceTrait extends AbstractTrait implements ToSmithyBuilder<ResourceTrait> {\n+    public static final ShapeId ID = ShapeId.from(\"aws.cloudformation#resource\");\n+    private static final String NAME = \"name\";\n+    private static final String ADDITIONAL_SCHEMAS = \"additionalSchemas\";\n+    private static final List<String> PROPERTIES = ListUtils.of(NAME, ADDITIONAL_SCHEMAS);\n+\n+    private final String defaultName;\n+    private final String name;\n+    private final List<ShapeId> additionalSchemas;\n+\n+    private ResourceTrait(Builder builder) {\n+        super(ID, builder.getSourceLocation());\n+        defaultName = builder.defaultName;\n+        name = builder.name;\n+        additionalSchemas = ListUtils.copyOf(builder.additionalSchemas);\n+    }\n+\n+    /**\n+     * Get the AWS CloudFormation resource name.\n+     *\n+     * @return Returns the name.\n+     */\n+    public String getName() {\n+        return name == null ? defaultName : name;\n+    }\n+\n+    /**\n+     * Get the Smithy structure shape Ids for additional schema properties.\n+     *\n+     * @return Returns the additional schema shape Ids.\n+     */\n+    public List<ShapeId> getAdditionalSchemas() {\n+        return additionalSchemas;\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    protected Node createNode() {\n+        ObjectNode node = Node.objectNode();\n+        if (name != null) {\n+            node = node.withMember(NAME, name);\n+        }\n+        if (!additionalSchemas.isEmpty()) {\n+            ArrayNode schemas = additionalSchemas.stream()\n+                    .map(ShapeId::toString)\n+                    .map(Node::from)\n+                    .collect(ArrayNode.collect());\n+            node = node.withMember(\"additionalSchemas\", schemas);\n+        }\n+        return node;\n+    }\n+\n+    @Override\n+    public SmithyBuilder<ResourceTrait> toBuilder() {\n+        return builder().name(name).additionalSchemas(additionalSchemas);\n+    }\n+\n+    public static final class Provider extends AbstractTrait.Provider {\n+        public Provider() {\n+            super(ID);\n+        }\n+\n+        @Override\n+        public Trait createTrait(ShapeId target, Node value) {\n+            Builder builder = builder().sourceLocation(value);\n+            ObjectNode objectNode = value.expectObjectNode();\n+            // Use a hidden defaultName property so we don't write out the\n+            // Shape's name when defaulting.\n+            builder.defaultName(target.getName());\n+            objectNode.getStringMember(NAME).ifPresent(node -> builder.name(node.getValue()));\n+            // Convert this ArrayNode of StringNodes to a List of ShapeId\n+            objectNode.getArrayMember(ADDITIONAL_SCHEMAS)\n+                    .map(array -> array.getElementsAs(n -> ShapeId.from(n.expectStringNode().getValue())))\n+                    .ifPresent(builder::additionalSchemas);\n+            return builder.build();\n+        }\n+    }\n+\n+    public static final class Builder extends AbstractTraitBuilder<ResourceTrait, Builder> {\n+        private String defaultName;\n+        private String name;\n+        private final List<ShapeId> additionalSchemas = new ArrayList<>();\n+\n+        private Builder() {}\n+\n+        @Override\n+        public ResourceTrait build() {\n+            return new ResourceTrait(this);\n+        }\n+\n+        public Builder defaultName(String defaultName) {", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceTrait.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CloudFormationResourceTrait.java\nsimilarity index 60%\nrename from smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceTrait.java\nrename to smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CloudFormationResourceTrait.java\nindex 3c2d2584d..745755d83 100644\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceTrait.java\n+++ b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CloudFormationResourceTrait.java\n\n@@ -17,9 +17,9 @@ package software.amazon.smithy.aws.cloudformation.traits;\n \n import java.util.ArrayList;\n import java.util.List;\n-import software.amazon.smithy.model.node.ArrayNode;\n+import java.util.Optional;\n import software.amazon.smithy.model.node.Node;\n-import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.NodeMapper;\n import software.amazon.smithy.model.shapes.ShapeId;\n import software.amazon.smithy.model.traits.AbstractTrait;\n import software.amazon.smithy.model.traits.AbstractTraitBuilder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg5NDYxMQ==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r508894611", "bodyText": "Why the need for a defaultName?", "author": "mtdowling", "createdAt": "2020-10-20T23:16:11Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceTrait.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.traits.AbstractTrait;\n+import software.amazon.smithy.model.traits.AbstractTraitBuilder;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.ToSmithyBuilder;\n+\n+/**\n+ * Indicates that a Smithy resource is a CloudFormation resource.\n+ */\n+public final class ResourceTrait extends AbstractTrait implements ToSmithyBuilder<ResourceTrait> {\n+    public static final ShapeId ID = ShapeId.from(\"aws.cloudformation#resource\");\n+    private static final String NAME = \"name\";\n+    private static final String ADDITIONAL_SCHEMAS = \"additionalSchemas\";\n+    private static final List<String> PROPERTIES = ListUtils.of(NAME, ADDITIONAL_SCHEMAS);\n+\n+    private final String defaultName;\n+    private final String name;\n+    private final List<ShapeId> additionalSchemas;\n+\n+    private ResourceTrait(Builder builder) {\n+        super(ID, builder.getSourceLocation());\n+        defaultName = builder.defaultName;\n+        name = builder.name;\n+        additionalSchemas = ListUtils.copyOf(builder.additionalSchemas);\n+    }\n+\n+    /**\n+     * Get the AWS CloudFormation resource name.\n+     *\n+     * @return Returns the name.\n+     */\n+    public String getName() {\n+        return name == null ? defaultName : name;", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceTrait.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CloudFormationResourceTrait.java\nsimilarity index 60%\nrename from smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceTrait.java\nrename to smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CloudFormationResourceTrait.java\nindex 3c2d2584d..745755d83 100644\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceTrait.java\n+++ b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CloudFormationResourceTrait.java\n\n@@ -17,9 +17,9 @@ package software.amazon.smithy.aws.cloudformation.traits;\n \n import java.util.ArrayList;\n import java.util.List;\n-import software.amazon.smithy.model.node.ArrayNode;\n+import java.util.Optional;\n import software.amazon.smithy.model.node.Node;\n-import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.NodeMapper;\n import software.amazon.smithy.model.shapes.ShapeId;\n import software.amazon.smithy.model.traits.AbstractTrait;\n import software.amazon.smithy.model.traits.AbstractTraitBuilder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg5NTgyNQ==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r508895825", "bodyText": "This is unused. There should be a \"warnIfAdditionalProperties\" check in the provider.", "author": "mtdowling", "createdAt": "2020-10-20T23:19:48Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceTrait.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.traits.AbstractTrait;\n+import software.amazon.smithy.model.traits.AbstractTraitBuilder;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.ToSmithyBuilder;\n+\n+/**\n+ * Indicates that a Smithy resource is a CloudFormation resource.\n+ */\n+public final class ResourceTrait extends AbstractTrait implements ToSmithyBuilder<ResourceTrait> {\n+    public static final ShapeId ID = ShapeId.from(\"aws.cloudformation#resource\");\n+    private static final String NAME = \"name\";\n+    private static final String ADDITIONAL_SCHEMAS = \"additionalSchemas\";\n+    private static final List<String> PROPERTIES = ListUtils.of(NAME, ADDITIONAL_SCHEMAS);", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1MzU5MA==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r513553590", "bodyText": "Removed this instead, as it's handled in model loading now.", "author": "kstich", "createdAt": "2020-10-28T15:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg5NTgyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceTrait.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CloudFormationResourceTrait.java\nsimilarity index 60%\nrename from smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceTrait.java\nrename to smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CloudFormationResourceTrait.java\nindex 3c2d2584d..745755d83 100644\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceTrait.java\n+++ b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CloudFormationResourceTrait.java\n\n@@ -17,9 +17,9 @@ package software.amazon.smithy.aws.cloudformation.traits;\n \n import java.util.ArrayList;\n import java.util.List;\n-import software.amazon.smithy.model.node.ArrayNode;\n+import java.util.Optional;\n import software.amazon.smithy.model.node.Node;\n-import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.NodeMapper;\n import software.amazon.smithy.model.shapes.ShapeId;\n import software.amazon.smithy.model.traits.AbstractTrait;\n import software.amazon.smithy.model.traits.AbstractTraitBuilder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg5NjY5Mw==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r508896693", "bodyText": "This should point to the mutability trait by passing it in as the second argument", "author": "mtdowling", "createdAt": "2020-10-20T23:22:22Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/MutabilityTraitValidator.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.validation.AbstractValidator;\n+import software.amazon.smithy.model.validation.ValidationEvent;\n+\n+/**\n+ * Validates that members marked as having write-only mutability are not also\n+ * marked as additional identifiers for their CloudFormation resource.\n+ */\n+public final class MutabilityTraitValidator extends AbstractValidator {\n+    @Override\n+    public List<ValidationEvent> validate(Model model) {\n+        List<ValidationEvent> events = new ArrayList<>();\n+\n+        for (Shape shape : model.getShapesWithTrait(MutabilityTrait.class)) {\n+            MutabilityTrait trait = shape.expectTrait(MutabilityTrait.class);\n+            // Additional identifiers must be able to be read, so write and\n+            // create mutabilities cannot overlap.\n+            if (shape.hasTrait(AdditionalIdentifierTrait.ID) && (trait.isWrite() || trait.isCreate())) {\n+                events.add(error(shape, \"Member with the mutability value of \\\"write-only\\\" is also marked \"", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/MutabilityTraitValidator.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/MutabilityTraitValidator.java\nindex c16fb5553..b3e6d2e37 100644\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/MutabilityTraitValidator.java\n+++ b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/MutabilityTraitValidator.java\n\n@@ -36,8 +36,8 @@ public final class MutabilityTraitValidator extends AbstractValidator {\n             // Additional identifiers must be able to be read, so write and\n             // create mutabilities cannot overlap.\n             if (shape.hasTrait(AdditionalIdentifierTrait.ID) && (trait.isWrite() || trait.isCreate())) {\n-                events.add(error(shape, \"Member with the mutability value of \\\"write-only\\\" is also marked \"\n-                        + \"as an additional identifier\"));\n+                events.add(error(shape, trait, String.format(\"Member with the mutability value of \\\"%s\\\" \"\n+                        + \"is also marked as an additional identifier\", trait.getValue())));\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwMzI3OA==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r508903278", "bodyText": "Is this logic necessary anywhere else? Does it need to be in an index?", "author": "mtdowling", "createdAt": "2020-10-20T23:43:24Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyValidator.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.OperationIndex;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.validation.AbstractValidator;\n+import software.amazon.smithy.model.validation.ValidationEvent;\n+\n+/**\n+ * Validates that derived CloudFormation properties all have the same target.\n+ */\n+public final class ResourcePropertyValidator extends AbstractValidator {\n+\n+    @Override\n+    public List<ValidationEvent> validate(Model model) {\n+        List<ValidationEvent> events = new ArrayList<>();\n+\n+        OperationIndex operationIndex = OperationIndex.of(model);\n+        model.shapes(ResourceShape.class)\n+                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n+                .map(pair -> validateResourceProperties(model, operationIndex, pair.getLeft(), pair.getRight()))\n+                .forEach(events::addAll);\n+\n+        return events;\n+    }\n+\n+    private List<ValidationEvent> validateResourceProperties(\n+            Model model,\n+            OperationIndex operationIndex,\n+            ResourceShape resource,\n+            ResourceTrait trait\n+    ) {\n+        List<ValidationEvent> events = new ArrayList<>();\n+\n+        Map<String, Set<ShapeId>> resourceProperties = getResourceProperties(model, operationIndex, resource, trait);\n+        for (Map.Entry<String, Set<ShapeId>> property : resourceProperties.entrySet()) {\n+            if (property.getValue().size() > 1) {\n+                events.add(error(resource, String.format(\"The %s property of the %s CloudFormation resource targets \"\n+                        + \"multiple shapes: %s. This should be resolved in the model or one of the members should be \"\n+                        + \"excluded from the conversion.\", trait.getName(), property.getKey(), property.getValue())));\n+            }\n+        }\n+\n+        return events;\n+    }\n+\n+    private Map<String, Set<ShapeId>> getResourceProperties(\n+            Model model,\n+            OperationIndex operationIndex,\n+            ResourceShape resource,\n+            ResourceTrait trait\n+    ) {\n+        Map<String, Set<ShapeId>> resourceProperties = new HashMap<>();\n+\n+        // Use the read lifecycle's input to collect the additional identifiers\n+        // and its output to collect readable properties.\n+        resource.getRead().ifPresent(operationId -> {", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyValidator.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyValidator.java\ndeleted file mode 100644\nindex b3c0c4275..000000000\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyValidator.java\n+++ /dev/null\n\n@@ -1,131 +0,0 @@\n-/*\n- * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.smithy.aws.cloudformation.traits;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.TreeSet;\n-import software.amazon.smithy.model.Model;\n-import software.amazon.smithy.model.knowledge.OperationIndex;\n-import software.amazon.smithy.model.shapes.MemberShape;\n-import software.amazon.smithy.model.shapes.ResourceShape;\n-import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.model.shapes.StructureShape;\n-import software.amazon.smithy.model.traits.Trait;\n-import software.amazon.smithy.model.validation.AbstractValidator;\n-import software.amazon.smithy.model.validation.ValidationEvent;\n-\n-/**\n- * Validates that derived CloudFormation properties all have the same target.\n- */\n-public final class ResourcePropertyValidator extends AbstractValidator {\n-\n-    @Override\n-    public List<ValidationEvent> validate(Model model) {\n-        List<ValidationEvent> events = new ArrayList<>();\n-\n-        OperationIndex operationIndex = OperationIndex.of(model);\n-        model.shapes(ResourceShape.class)\n-                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n-                .map(pair -> validateResourceProperties(model, operationIndex, pair.getLeft(), pair.getRight()))\n-                .forEach(events::addAll);\n-\n-        return events;\n-    }\n-\n-    private List<ValidationEvent> validateResourceProperties(\n-            Model model,\n-            OperationIndex operationIndex,\n-            ResourceShape resource,\n-            ResourceTrait trait\n-    ) {\n-        List<ValidationEvent> events = new ArrayList<>();\n-\n-        Map<String, Set<ShapeId>> resourceProperties = getResourceProperties(model, operationIndex, resource, trait);\n-        for (Map.Entry<String, Set<ShapeId>> property : resourceProperties.entrySet()) {\n-            if (property.getValue().size() > 1) {\n-                events.add(error(resource, String.format(\"The %s property of the %s CloudFormation resource targets \"\n-                        + \"multiple shapes: %s. This should be resolved in the model or one of the members should be \"\n-                        + \"excluded from the conversion.\", trait.getName(), property.getKey(), property.getValue())));\n-            }\n-        }\n-\n-        return events;\n-    }\n-\n-    private Map<String, Set<ShapeId>> getResourceProperties(\n-            Model model,\n-            OperationIndex operationIndex,\n-            ResourceShape resource,\n-            ResourceTrait trait\n-    ) {\n-        Map<String, Set<ShapeId>> resourceProperties = new HashMap<>();\n-\n-        // Use the read lifecycle's input to collect the additional identifiers\n-        // and its output to collect readable properties.\n-        resource.getRead().ifPresent(operationId -> {\n-            operationIndex.getOutput(operationId).ifPresent(output ->\n-                    computeResourceProperties(resourceProperties, output));\n-        });\n-\n-        // Use the put lifecycle's input to collect put-able properties.\n-        resource.getPut().ifPresent(operationId -> {\n-            operationIndex.getInput(operationId).ifPresent(input ->\n-                    computeResourceProperties(resourceProperties, input));\n-        });\n-\n-        // Use the create lifecycle's input to collect creatable properties.\n-        resource.getCreate().ifPresent(operationId -> {\n-            operationIndex.getInput(operationId).ifPresent(input ->\n-                    computeResourceProperties(resourceProperties, input));\n-        });\n-\n-        // Use the update lifecycle's input to collect writeable properties.\n-        resource.getUpdate().ifPresent(operationId -> {\n-            operationIndex.getInput(operationId).ifPresent(input ->\n-                    computeResourceProperties(resourceProperties, input));\n-        });\n-\n-        // Apply any members found through the trait's additionalSchemas property.\n-        for (ShapeId additionalSchema : trait.getAdditionalSchemas()) {\n-            StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);\n-            computeResourceProperties(resourceProperties, shape);\n-        }\n-\n-        return resourceProperties;\n-    }\n-\n-    private void computeResourceProperties(Map<String, Set<ShapeId>> resourceProperties, StructureShape shape) {\n-        for (Map.Entry<String, MemberShape> memberEntry : shape.getAllMembers().entrySet()) {\n-            MemberShape memberShape = memberEntry.getValue();\n-\n-            // Skip explicitly excluded property definitions.\n-            if (memberShape.hasTrait(ExcludePropertyTrait.ID)) {\n-                continue;\n-            }\n-\n-            // Use the correct property name.\n-            String propertyName = memberShape.getTrait(PropertyNameTrait.class)\n-                    .map(PropertyNameTrait::getValue)\n-                    .orElse(memberEntry.getKey());\n-            resourceProperties.computeIfAbsent(propertyName, name -> new TreeSet<>())\n-                    .add(memberShape.getTarget());\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwNTQ0Ng==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r508905446", "bodyText": "Note this will blow up model loading. We don't have a wrapped try/catch for each validator, but maybe we should so you can do stuff like this?", "author": "mtdowling", "createdAt": "2020-10-20T23:50:07Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyValidator.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.OperationIndex;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.validation.AbstractValidator;\n+import software.amazon.smithy.model.validation.ValidationEvent;\n+\n+/**\n+ * Validates that derived CloudFormation properties all have the same target.\n+ */\n+public final class ResourcePropertyValidator extends AbstractValidator {\n+\n+    @Override\n+    public List<ValidationEvent> validate(Model model) {\n+        List<ValidationEvent> events = new ArrayList<>();\n+\n+        OperationIndex operationIndex = OperationIndex.of(model);\n+        model.shapes(ResourceShape.class)\n+                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n+                .map(pair -> validateResourceProperties(model, operationIndex, pair.getLeft(), pair.getRight()))\n+                .forEach(events::addAll);\n+\n+        return events;\n+    }\n+\n+    private List<ValidationEvent> validateResourceProperties(\n+            Model model,\n+            OperationIndex operationIndex,\n+            ResourceShape resource,\n+            ResourceTrait trait\n+    ) {\n+        List<ValidationEvent> events = new ArrayList<>();\n+\n+        Map<String, Set<ShapeId>> resourceProperties = getResourceProperties(model, operationIndex, resource, trait);\n+        for (Map.Entry<String, Set<ShapeId>> property : resourceProperties.entrySet()) {\n+            if (property.getValue().size() > 1) {\n+                events.add(error(resource, String.format(\"The %s property of the %s CloudFormation resource targets \"\n+                        + \"multiple shapes: %s. This should be resolved in the model or one of the members should be \"\n+                        + \"excluded from the conversion.\", trait.getName(), property.getKey(), property.getValue())));\n+            }\n+        }\n+\n+        return events;\n+    }\n+\n+    private Map<String, Set<ShapeId>> getResourceProperties(\n+            Model model,\n+            OperationIndex operationIndex,\n+            ResourceShape resource,\n+            ResourceTrait trait\n+    ) {\n+        Map<String, Set<ShapeId>> resourceProperties = new HashMap<>();\n+\n+        // Use the read lifecycle's input to collect the additional identifiers\n+        // and its output to collect readable properties.\n+        resource.getRead().ifPresent(operationId -> {\n+            operationIndex.getOutput(operationId).ifPresent(output ->\n+                    computeResourceProperties(resourceProperties, output));\n+        });\n+\n+        // Use the put lifecycle's input to collect put-able properties.\n+        resource.getPut().ifPresent(operationId -> {\n+            operationIndex.getInput(operationId).ifPresent(input ->\n+                    computeResourceProperties(resourceProperties, input));\n+        });\n+\n+        // Use the create lifecycle's input to collect creatable properties.\n+        resource.getCreate().ifPresent(operationId -> {\n+            operationIndex.getInput(operationId).ifPresent(input ->\n+                    computeResourceProperties(resourceProperties, input));\n+        });\n+\n+        // Use the update lifecycle's input to collect writeable properties.\n+        resource.getUpdate().ifPresent(operationId -> {\n+            operationIndex.getInput(operationId).ifPresent(input ->\n+                    computeResourceProperties(resourceProperties, input));\n+        });\n+\n+        // Apply any members found through the trait's additionalSchemas property.\n+        for (ShapeId additionalSchema : trait.getAdditionalSchemas()) {\n+            StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1MjQ5OQ==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r513552499", "bodyText": "This now gracefully handles these shapes potentially not existing, as the @idRef trait should fail its validation if they're missing.", "author": "kstich", "createdAt": "2020-10-28T15:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwNTQ0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyValidator.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyValidator.java\ndeleted file mode 100644\nindex b3c0c4275..000000000\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyValidator.java\n+++ /dev/null\n\n@@ -1,131 +0,0 @@\n-/*\n- * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.smithy.aws.cloudformation.traits;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.TreeSet;\n-import software.amazon.smithy.model.Model;\n-import software.amazon.smithy.model.knowledge.OperationIndex;\n-import software.amazon.smithy.model.shapes.MemberShape;\n-import software.amazon.smithy.model.shapes.ResourceShape;\n-import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.model.shapes.StructureShape;\n-import software.amazon.smithy.model.traits.Trait;\n-import software.amazon.smithy.model.validation.AbstractValidator;\n-import software.amazon.smithy.model.validation.ValidationEvent;\n-\n-/**\n- * Validates that derived CloudFormation properties all have the same target.\n- */\n-public final class ResourcePropertyValidator extends AbstractValidator {\n-\n-    @Override\n-    public List<ValidationEvent> validate(Model model) {\n-        List<ValidationEvent> events = new ArrayList<>();\n-\n-        OperationIndex operationIndex = OperationIndex.of(model);\n-        model.shapes(ResourceShape.class)\n-                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n-                .map(pair -> validateResourceProperties(model, operationIndex, pair.getLeft(), pair.getRight()))\n-                .forEach(events::addAll);\n-\n-        return events;\n-    }\n-\n-    private List<ValidationEvent> validateResourceProperties(\n-            Model model,\n-            OperationIndex operationIndex,\n-            ResourceShape resource,\n-            ResourceTrait trait\n-    ) {\n-        List<ValidationEvent> events = new ArrayList<>();\n-\n-        Map<String, Set<ShapeId>> resourceProperties = getResourceProperties(model, operationIndex, resource, trait);\n-        for (Map.Entry<String, Set<ShapeId>> property : resourceProperties.entrySet()) {\n-            if (property.getValue().size() > 1) {\n-                events.add(error(resource, String.format(\"The %s property of the %s CloudFormation resource targets \"\n-                        + \"multiple shapes: %s. This should be resolved in the model or one of the members should be \"\n-                        + \"excluded from the conversion.\", trait.getName(), property.getKey(), property.getValue())));\n-            }\n-        }\n-\n-        return events;\n-    }\n-\n-    private Map<String, Set<ShapeId>> getResourceProperties(\n-            Model model,\n-            OperationIndex operationIndex,\n-            ResourceShape resource,\n-            ResourceTrait trait\n-    ) {\n-        Map<String, Set<ShapeId>> resourceProperties = new HashMap<>();\n-\n-        // Use the read lifecycle's input to collect the additional identifiers\n-        // and its output to collect readable properties.\n-        resource.getRead().ifPresent(operationId -> {\n-            operationIndex.getOutput(operationId).ifPresent(output ->\n-                    computeResourceProperties(resourceProperties, output));\n-        });\n-\n-        // Use the put lifecycle's input to collect put-able properties.\n-        resource.getPut().ifPresent(operationId -> {\n-            operationIndex.getInput(operationId).ifPresent(input ->\n-                    computeResourceProperties(resourceProperties, input));\n-        });\n-\n-        // Use the create lifecycle's input to collect creatable properties.\n-        resource.getCreate().ifPresent(operationId -> {\n-            operationIndex.getInput(operationId).ifPresent(input ->\n-                    computeResourceProperties(resourceProperties, input));\n-        });\n-\n-        // Use the update lifecycle's input to collect writeable properties.\n-        resource.getUpdate().ifPresent(operationId -> {\n-            operationIndex.getInput(operationId).ifPresent(input ->\n-                    computeResourceProperties(resourceProperties, input));\n-        });\n-\n-        // Apply any members found through the trait's additionalSchemas property.\n-        for (ShapeId additionalSchema : trait.getAdditionalSchemas()) {\n-            StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);\n-            computeResourceProperties(resourceProperties, shape);\n-        }\n-\n-        return resourceProperties;\n-    }\n-\n-    private void computeResourceProperties(Map<String, Set<ShapeId>> resourceProperties, StructureShape shape) {\n-        for (Map.Entry<String, MemberShape> memberEntry : shape.getAllMembers().entrySet()) {\n-            MemberShape memberShape = memberEntry.getValue();\n-\n-            // Skip explicitly excluded property definitions.\n-            if (memberShape.hasTrait(ExcludePropertyTrait.ID)) {\n-                continue;\n-            }\n-\n-            // Use the correct property name.\n-            String propertyName = memberShape.getTrait(PropertyNameTrait.class)\n-                    .map(PropertyNameTrait::getValue)\n-                    .orElse(memberEntry.getKey());\n-            resourceProperties.computeIfAbsent(propertyName, name -> new TreeSet<>())\n-                    .add(memberShape.getTarget());\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwNzA3Mg==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r508907072", "bodyText": "We normally do SmithyBuilder.requiredState I think", "author": "mtdowling", "createdAt": "2020-10-20T23:55:04Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyDefinition.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import software.amazon.smithy.aws.cloudformation.traits.ResourceIndex.Mutability;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.utils.SetUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.ToSmithyBuilder;\n+\n+/**\n+ * Contains extracted resource property information.\n+ */\n+public final class ResourcePropertyDefinition implements ToSmithyBuilder<ResourcePropertyDefinition> {\n+    private final ShapeId shapeId;\n+    private final Set<Mutability> mutabilities;\n+    private final boolean hasExplicitMutability;\n+\n+    private ResourcePropertyDefinition(Builder builder) {\n+        shapeId = Objects.requireNonNull(builder.shapeId);", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyDefinition.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResourceProperty.java\nsimilarity index 69%\nrename from smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyDefinition.java\nrename to smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResourceProperty.java\nindex 96b895c67..4341295d3 100644\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyDefinition.java\n+++ b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResourceProperty.java\n\n@@ -16,9 +16,9 @@\n package software.amazon.smithy.aws.cloudformation.traits;\n \n import java.util.HashSet;\n-import java.util.Objects;\n import java.util.Set;\n-import software.amazon.smithy.aws.cloudformation.traits.ResourceIndex.Mutability;\n+import java.util.TreeSet;\n+import software.amazon.smithy.aws.cloudformation.traits.CfnResourceIndex.Mutability;\n import software.amazon.smithy.model.shapes.ShapeId;\n import software.amazon.smithy.utils.SetUtils;\n import software.amazon.smithy.utils.SmithyBuilder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwNzE2Nw==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r508907167", "bodyText": "Does order matter?", "author": "mtdowling", "createdAt": "2020-10-20T23:55:24Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyDefinition.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import software.amazon.smithy.aws.cloudformation.traits.ResourceIndex.Mutability;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.utils.SetUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.ToSmithyBuilder;\n+\n+/**\n+ * Contains extracted resource property information.\n+ */\n+public final class ResourcePropertyDefinition implements ToSmithyBuilder<ResourcePropertyDefinition> {\n+    private final ShapeId shapeId;\n+    private final Set<Mutability> mutabilities;\n+    private final boolean hasExplicitMutability;\n+\n+    private ResourcePropertyDefinition(Builder builder) {\n+        shapeId = Objects.requireNonNull(builder.shapeId);\n+        mutabilities = SetUtils.copyOf(builder.mutabilities);\n+        hasExplicitMutability = builder.hasExplicitMutability;\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Gets the shape ID used to represent this property.\n+     *\n+     * @return Returns the shape ID.\n+     */\n+    public ShapeId getShapeId() {\n+        return shapeId;\n+    }\n+\n+    /**\n+     * Returns true if the property's mutability was configured explicitly\n+     * by the use of a trait instead of derived through its lifecycle\n+     * bindings within a resource.\n+     *\n+     * @return Returns true if the mutability is explicitly defined by a trait.\n+     *\n+     * @see MutabilityTrait\n+     */\n+    public boolean hasExplicitMutability() {\n+        return hasExplicitMutability;\n+    }\n+\n+    /**\n+     * Gets all of the CloudFormation-specific property mutability options\n+     * associated with this resource property.\n+     *\n+     * @return Returns the mutabilities.\n+     */\n+    public Set<Mutability> getMutabilities() {\n+        return mutabilities;\n+    }\n+\n+    @Override\n+    public Builder toBuilder() {\n+        return builder()\n+                .shapeId(shapeId)\n+                .mutabilities(mutabilities);\n+    }\n+\n+    public static final class Builder implements SmithyBuilder<ResourcePropertyDefinition> {\n+        private ShapeId shapeId;\n+        private Set<Mutability> mutabilities = new HashSet<>();", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNTAzOA==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r511025038", "bodyText": "No, the set is only checked for containment of the various Mutability entries.", "author": "kstich", "createdAt": "2020-10-23T17:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwNzE2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyDefinition.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResourceProperty.java\nsimilarity index 69%\nrename from smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyDefinition.java\nrename to smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResourceProperty.java\nindex 96b895c67..4341295d3 100644\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourcePropertyDefinition.java\n+++ b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResourceProperty.java\n\n@@ -16,9 +16,9 @@\n package software.amazon.smithy.aws.cloudformation.traits;\n \n import java.util.HashSet;\n-import java.util.Objects;\n import java.util.Set;\n-import software.amazon.smithy.aws.cloudformation.traits.ResourceIndex.Mutability;\n+import java.util.TreeSet;\n+import software.amazon.smithy.aws.cloudformation.traits.CfnResourceIndex.Mutability;\n import software.amazon.smithy.model.shapes.ShapeId;\n import software.amazon.smithy.utils.SetUtils;\n import software.amazon.smithy.utils.SmithyBuilder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwODU0Mw==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r508908543", "bodyText": "These are the names as they appear in CF? Or what?", "author": "mtdowling", "createdAt": "2020-10-20T23:56:41Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n+import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n+import software.amazon.smithy.model.knowledge.OperationIndex;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeVisitor;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.ToShapeId;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.MapUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+\n+/**\n+ * Index of resources to their CloudFormation identifiers\n+ * and properties.\n+ *\n+ * <p>This index performs no validation that the identifiers\n+ * and reference valid shapes.\n+ */\n+public final class ResourceIndex implements KnowledgeIndex {\n+\n+    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n+            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n+\n+    private final Model model;\n+    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n+    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n+    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n+    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n+\n+    /**\n+     * CloudFormation-specific property mutability options.", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\ndeleted file mode 100644\nindex a50e1e958..000000000\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\n+++ /dev/null\n\n@@ -1,479 +0,0 @@\n-/*\n- * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.smithy.aws.cloudformation.traits;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import software.amazon.smithy.model.Model;\n-import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n-import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n-import software.amazon.smithy.model.knowledge.OperationIndex;\n-import software.amazon.smithy.model.shapes.MemberShape;\n-import software.amazon.smithy.model.shapes.ResourceShape;\n-import software.amazon.smithy.model.shapes.Shape;\n-import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.model.shapes.ShapeVisitor;\n-import software.amazon.smithy.model.shapes.StructureShape;\n-import software.amazon.smithy.model.shapes.ToShapeId;\n-import software.amazon.smithy.model.traits.Trait;\n-import software.amazon.smithy.utils.ListUtils;\n-import software.amazon.smithy.utils.MapUtils;\n-import software.amazon.smithy.utils.SetUtils;\n-\n-/**\n- * Index of resources to their CloudFormation identifiers\n- * and properties.\n- *\n- * <p>This index performs no validation that the identifiers\n- * and reference valid shapes.\n- */\n-public final class ResourceIndex implements KnowledgeIndex {\n-\n-    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n-            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n-\n-    private final Model model;\n-    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n-    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n-    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n-    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n-\n-    /**\n-     * CloudFormation-specific property mutability options.\n-     */\n-    public enum Mutability {\n-        CREATE,\n-        READ,\n-        WRITE\n-    }\n-\n-    public ResourceIndex(Model model) {\n-        this.model = model;\n-\n-        OperationIndex operationIndex = OperationIndex.of(model);\n-        model.shapes(ResourceShape.class)\n-                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n-                .forEach(pair -> {\n-                    ResourceShape resource = pair.getLeft();\n-                    ShapeId resourceId = resource.getId();\n-\n-                    // Start with the explicit resource identifiers.\n-                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));\n-                    setIdentifierMutabilities(resource);\n-\n-                    // Use the read lifecycle's input to collect the additional identifiers\n-                    // and its output to collect readable properties.\n-                    resource.getRead().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            addAdditionalIdentifiers(resource, computeResourceAdditionalIdentifiers(input));\n-                        });\n-                        operationIndex.getOutput(operationId).ifPresent(output -> {\n-                            updatePropertyMutabilities(resourceId, operationId, output,\n-                                    SetUtils.of(Mutability.READ), this::addReadMutability);\n-                        });\n-                    });\n-\n-                    // Use the put lifecycle's input to collect put-able properties.\n-                    resource.getPut().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE, Mutability.WRITE), this::addPutMutability);\n-                        });\n-                    });\n-\n-                    // Use the create lifecycle's input to collect creatable properties.\n-                    resource.getCreate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE), this::addCreateMutability);\n-                        });\n-                    });\n-\n-                    // Use the update lifecycle's input to collect writeable properties.\n-                    resource.getUpdate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.WRITE), this::addWriteMutability);\n-                        });\n-                    });\n-\n-                    // Apply any members found through the trait's additionalSchemas property.\n-                    for (ShapeId additionalSchema : pair.getRight().getAdditionalSchemas()) {\n-                        StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);\n-                        updatePropertyMutabilities(resourceId, null, shape,\n-                                SetUtils.of(), Function.identity());\n-                    }\n-                });\n-    }\n-\n-    public static ResourceIndex of(Model model) {\n-        return model.getKnowledge(ResourceIndex.class, ResourceIndex::new);\n-    }\n-\n-    /**\n-     * Get all members of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns all members that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Map<String, ResourcePropertyDefinition> getProperties(ToShapeId resource) {\n-        return resourcePropertyMutabilities.getOrDefault(resource.toShapeId(), MapUtils.of())\n-                .entrySet().stream()\n-                .filter(entry -> !getExcludedProperties(resource).contains(entry.getValue().getShapeId()))\n-                .collect(MapUtils.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n-    }\n-\n-    /**\n-     * Gets the specified member of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource\n-     * @param propertyName Name of the property to retrieve\n-     * @return The property definition.\n-     */\n-    public Optional<ResourcePropertyDefinition> getProperty(ToShapeId resource, String propertyName) {\n-        return Optional.ofNullable(getProperties(resource).get(propertyName));\n-    }\n-\n-    /**\n-     * Get create-specifiable-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified only during resource creation and\n-     * can be returned in a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns create-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getCreateOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.contains(Mutability.CREATE) && !mutabilities.contains(Mutability.WRITE);\n-        });\n-    }\n-\n-    /**\n-     * Get read-only members of the CloudFormation resource.\n-     *\n-     * These properties can be returned by a `read` or `list` request,\n-     * but cannot be set by the user.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns read-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getReadOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.size() == 1 && mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    /**\n-     * Get write-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified by the user, but cannot be\n-     * returned by a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns write-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getWriteOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            // Create and non-read properties need to be set as createOnly and writeOnly.\n-            if (mutabilities.size() == 1 && mutabilities.contains(Mutability.CREATE)) {\n-                return true;\n-            }\n-\n-            // Otherwise, create and update, or update only become writeOnly.\n-            return mutabilities.contains(Mutability.WRITE) && !mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    private Set<String> getConstrainedProperties(\n-            ToShapeId resource,\n-            Predicate<ResourcePropertyDefinition> constraint\n-    ) {\n-        return getProperties(resource)\n-                .entrySet()\n-                .stream()\n-                .filter(property -> constraint.test(property.getValue()))\n-                .map(Map.Entry::getKey)\n-                .collect(Collectors.toSet());\n-    }\n-\n-    /**\n-     * Get members that have been explicitly excluded from the CloudFormation\n-     * resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns members that have been excluded from a CloudFormation\n-     *   resource.\n-     */\n-    public Set<ShapeId> getExcludedProperties(ToShapeId resource) {\n-        return resourceExcludedProperties.getOrDefault(resource.toShapeId(), SetUtils.of());\n-    }\n-\n-    /**\n-     * Gets a set of member shape ids that represent the primary way\n-     * to identify a CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns the identifier set primarily used to access a\n-     *   CloudFormation resource.\n-     */\n-    public Set<String> getPrimaryIdentifiers(ToShapeId resource) {\n-        return resourcePrimaryIdentifiers.get(resource.toShapeId());\n-    }\n-\n-    /**\n-     * Get a list of sets of member shape ids, each set can be used to identify\n-     * the CloudFormation resource in addition to its primary identifier(s).\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns identifier sets used to access a CloudFormation resource.\n-     */\n-    public List<Set<String>> getAdditionalIdentifiers(ToShapeId resource) {\n-        return resourceAdditionalIdentifiers.getOrDefault(resource.toShapeId(), ListUtils.of());\n-    }\n-\n-    private void setIdentifierMutabilities(ResourceShape resource) {\n-        Set<Mutability> mutability = getDefaultIdentifierMutabilities(resource);\n-\n-        ShapeId resourceId = resource.getId();\n-\n-        resource.getIdentifiers().forEach((name, shape) -> {\n-            setResourceProperty(resourceId, name, ResourcePropertyDefinition.builder()\n-                    .hasExplicitMutability(true)\n-                    .mutabilities(mutability)\n-                    .shapeId(shape)\n-                    .build());\n-        });\n-    }\n-\n-    private void setResourceProperty(ShapeId resourceId, String name, ResourcePropertyDefinition property) {\n-        Map<String, ResourcePropertyDefinition> resourceProperties =\n-                resourcePropertyMutabilities.getOrDefault(resourceId, new HashMap<>());\n-        resourceProperties.put(name, property);\n-        resourcePropertyMutabilities.put(resourceId, resourceProperties);\n-    }\n-\n-    private Set<Mutability> getDefaultIdentifierMutabilities(ResourceShape resource) {\n-        // If we have a put operation, the identifier will be specified\n-        // on creation. Otherwise, it's read only.\n-        if (resource.getPut().isPresent()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        }\n-\n-        return SetUtils.of(Mutability.READ);\n-    }\n-\n-    private List<Map<String, ShapeId>> computeResourceAdditionalIdentifiers(StructureShape readInput) {\n-        List<Map<String, ShapeId>> identifiers = new ArrayList<>();\n-        for (MemberShape member : readInput.members()) {\n-            if (!member.hasTrait(AdditionalIdentifierTrait.class)) {\n-                continue;\n-            }\n-\n-            identifiers.add(MapUtils.of(member.getMemberName(), member.getId()));\n-        }\n-        return identifiers;\n-    }\n-\n-    private void addAdditionalIdentifiers(ResourceShape resource, List<Map<String, ShapeId>> addedIdentifiers) {\n-        if (addedIdentifiers.isEmpty()) {\n-            return;\n-        }\n-        ShapeId resourceId = resource.getId();\n-\n-        List<Set<String>> newIdentifierNames = new ArrayList<>();\n-        // Make sure we have properties entries for the additional identifiers.\n-        for (Map<String, ShapeId> addedIdentifier : addedIdentifiers) {\n-            for (Map.Entry<String, ShapeId> idEntry : addedIdentifier.entrySet()) {\n-                setResourceProperty(resourceId, idEntry.getKey(), ResourcePropertyDefinition.builder()\n-                        .mutabilities(SetUtils.of(Mutability.READ))\n-                        .shapeId(idEntry.getValue())\n-                        .build());\n-            }\n-            newIdentifierNames.add(addedIdentifier.keySet());\n-        }\n-\n-        List<Set<String>> currentIdentifiers =\n-                resourceAdditionalIdentifiers.getOrDefault(resourceId, new ArrayList<>());\n-        currentIdentifiers.addAll(newIdentifierNames);\n-        resourceAdditionalIdentifiers.put(resourceId, currentIdentifiers);\n-    }\n-\n-    private void updatePropertyMutabilities(\n-            ShapeId resourceId,\n-            ShapeId operationId,\n-            StructureShape propertyContainer,\n-            Set<Mutability> defaultMutabilities,\n-            Function<Set<Mutability>, Set<Mutability>> updater\n-    ) {\n-        addExcludedProperties(resourceId, propertyContainer);\n-\n-        for (MemberShape member : propertyContainer.members()) {\n-            // We've explicitly set identifier mutability based on how the\n-            // resource instance comes about, so only handle non-identifiers.\n-            if (operationMemberIsIdentifier(resourceId, operationId, member)) {\n-                continue;\n-            }\n-\n-            String memberName = member.getMemberName();\n-            ResourcePropertyDefinition memberProperty = getProperties(resourceId).get(memberName);\n-            Set<Mutability> explicitMutability = getExplicitMutability(member, memberProperty);\n-\n-            if (memberProperty != null) {\n-                // Validate that members with the same name target the same shape.\n-                model.getShape(memberProperty.getShapeId())\n-                        .flatMap(Shape::asMemberShape)\n-                        .filter(shape -> !member.getTarget().equals(shape.getTarget()))\n-                        .ifPresent(shape -> {\n-                            throw new RuntimeException(String.format(\"The derived CloudFormation resource \"\n-                                    + \"property for %s is composed of members that target different shapes: %s and %s\",\n-                                    memberName, member.getTarget(), shape.getTarget()));\n-                        });\n-\n-                // Apply updates to the mutability of the property.\n-                if (!memberProperty.hasExplicitMutability()) {\n-                    memberProperty = memberProperty.toBuilder()\n-                            .mutabilities(updater.apply(memberProperty.getMutabilities()))\n-                            .build();\n-                }\n-            } else {\n-                // Set the correct mutability for this new property.\n-                Set<Mutability> mutabilities = !explicitMutability.isEmpty()\n-                        ? explicitMutability\n-                        : defaultMutabilities;\n-                memberProperty = ResourcePropertyDefinition.builder()\n-                        .shapeId(member.getId())\n-                        .mutabilities(mutabilities)\n-                        .hasExplicitMutability(!explicitMutability.isEmpty())\n-                        .build();\n-            }\n-\n-            setResourceProperty(resourceId, memberName, memberProperty);\n-        }\n-    }\n-\n-    private void addExcludedProperties(ShapeId resourceId, StructureShape propertyContainer) {\n-        Set<ShapeId> currentExcludedProperties =\n-                resourceExcludedProperties.getOrDefault(resourceId, new HashSet<>());\n-        currentExcludedProperties.addAll(propertyContainer.accept(new ExcludedPropertiesVisitor()));\n-        resourceExcludedProperties.put(resourceId, currentExcludedProperties);\n-    }\n-\n-    private boolean operationMemberIsIdentifier(ShapeId resourceId, ShapeId operationId, MemberShape member) {\n-        // The operationId will be null in the case of additionalSchemas, so\n-        // we shouldn't worry if these are bound to operation identifiers.\n-        if (operationId == null) {\n-            return false;\n-        }\n-\n-        IdentifierBindingIndex index = IdentifierBindingIndex.of(model);\n-        Map<String, String> bindings = index.getOperationBindings(resourceId, operationId);\n-        String memberName = member.getMemberName();\n-        // Check for literal identifier bindings.\n-        for (String bindingMemberName : bindings.values()) {\n-            if (memberName.equals(bindingMemberName)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private Set<Mutability> getExplicitMutability(\n-            MemberShape member,\n-            ResourcePropertyDefinition memberProperty\n-    ) {\n-        if (memberProperty != null && memberProperty.hasExplicitMutability()) {\n-            return memberProperty.getMutabilities();\n-        }\n-\n-        Optional<MutabilityTrait> traitOptional = member.getMemberTrait(model, MutabilityTrait.class);\n-        if (!traitOptional.isPresent()) {\n-            return SetUtils.of();\n-        }\n-\n-        MutabilityTrait trait = traitOptional.get();\n-        if (trait.isFullyMutable()) {\n-            return FULLY_MUTABLE;\n-        } else if (trait.isCreateAndRead()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        } else if (trait.isCreate()) {\n-            return SetUtils.of(Mutability.CREATE);\n-        } else if (trait.isRead()) {\n-            return SetUtils.of(Mutability.READ);\n-        } else if (trait.isWrite()) {\n-            return SetUtils.of(Mutability.WRITE);\n-        }\n-        return SetUtils.of();\n-    }\n-\n-    private Set<Mutability> addReadMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.READ);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addCreateMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.CREATE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addWriteMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.WRITE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addPutMutability(Set<Mutability> mutabilities) {\n-        return addWriteMutability(addCreateMutability(mutabilities));\n-    }\n-\n-    private final class ExcludedPropertiesVisitor extends ShapeVisitor.Default<Set<ShapeId>> {\n-        @Override\n-        protected Set<ShapeId> getDefault(Shape shape) {\n-            return SetUtils.of();\n-        }\n-\n-        @Override\n-        public Set<ShapeId> structureShape(StructureShape shape) {\n-            Set<ShapeId> excludedShapes = new HashSet<>();\n-            for (MemberShape member : shape.members()) {\n-                if (member.hasTrait(ExcludePropertyTrait.ID)) {\n-                    excludedShapes.add(member.getId());\n-                } else {\n-                    excludedShapes.addAll(model.expectShape(member.getTarget()).accept(this));\n-                }\n-            }\n-            return excludedShapes;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwOTUwNQ==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r508909505", "bodyText": "Ideally this is a weak reference if you really need to hold onto the model", "author": "mtdowling", "createdAt": "2020-10-20T23:57:21Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n+import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n+import software.amazon.smithy.model.knowledge.OperationIndex;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeVisitor;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.ToShapeId;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.MapUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+\n+/**\n+ * Index of resources to their CloudFormation identifiers\n+ * and properties.\n+ *\n+ * <p>This index performs no validation that the identifiers\n+ * and reference valid shapes.\n+ */\n+public final class ResourceIndex implements KnowledgeIndex {\n+\n+    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n+            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n+\n+    private final Model model;", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\ndeleted file mode 100644\nindex a50e1e958..000000000\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\n+++ /dev/null\n\n@@ -1,479 +0,0 @@\n-/*\n- * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.smithy.aws.cloudformation.traits;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import software.amazon.smithy.model.Model;\n-import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n-import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n-import software.amazon.smithy.model.knowledge.OperationIndex;\n-import software.amazon.smithy.model.shapes.MemberShape;\n-import software.amazon.smithy.model.shapes.ResourceShape;\n-import software.amazon.smithy.model.shapes.Shape;\n-import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.model.shapes.ShapeVisitor;\n-import software.amazon.smithy.model.shapes.StructureShape;\n-import software.amazon.smithy.model.shapes.ToShapeId;\n-import software.amazon.smithy.model.traits.Trait;\n-import software.amazon.smithy.utils.ListUtils;\n-import software.amazon.smithy.utils.MapUtils;\n-import software.amazon.smithy.utils.SetUtils;\n-\n-/**\n- * Index of resources to their CloudFormation identifiers\n- * and properties.\n- *\n- * <p>This index performs no validation that the identifiers\n- * and reference valid shapes.\n- */\n-public final class ResourceIndex implements KnowledgeIndex {\n-\n-    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n-            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n-\n-    private final Model model;\n-    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n-    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n-    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n-    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n-\n-    /**\n-     * CloudFormation-specific property mutability options.\n-     */\n-    public enum Mutability {\n-        CREATE,\n-        READ,\n-        WRITE\n-    }\n-\n-    public ResourceIndex(Model model) {\n-        this.model = model;\n-\n-        OperationIndex operationIndex = OperationIndex.of(model);\n-        model.shapes(ResourceShape.class)\n-                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n-                .forEach(pair -> {\n-                    ResourceShape resource = pair.getLeft();\n-                    ShapeId resourceId = resource.getId();\n-\n-                    // Start with the explicit resource identifiers.\n-                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));\n-                    setIdentifierMutabilities(resource);\n-\n-                    // Use the read lifecycle's input to collect the additional identifiers\n-                    // and its output to collect readable properties.\n-                    resource.getRead().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            addAdditionalIdentifiers(resource, computeResourceAdditionalIdentifiers(input));\n-                        });\n-                        operationIndex.getOutput(operationId).ifPresent(output -> {\n-                            updatePropertyMutabilities(resourceId, operationId, output,\n-                                    SetUtils.of(Mutability.READ), this::addReadMutability);\n-                        });\n-                    });\n-\n-                    // Use the put lifecycle's input to collect put-able properties.\n-                    resource.getPut().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE, Mutability.WRITE), this::addPutMutability);\n-                        });\n-                    });\n-\n-                    // Use the create lifecycle's input to collect creatable properties.\n-                    resource.getCreate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE), this::addCreateMutability);\n-                        });\n-                    });\n-\n-                    // Use the update lifecycle's input to collect writeable properties.\n-                    resource.getUpdate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.WRITE), this::addWriteMutability);\n-                        });\n-                    });\n-\n-                    // Apply any members found through the trait's additionalSchemas property.\n-                    for (ShapeId additionalSchema : pair.getRight().getAdditionalSchemas()) {\n-                        StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);\n-                        updatePropertyMutabilities(resourceId, null, shape,\n-                                SetUtils.of(), Function.identity());\n-                    }\n-                });\n-    }\n-\n-    public static ResourceIndex of(Model model) {\n-        return model.getKnowledge(ResourceIndex.class, ResourceIndex::new);\n-    }\n-\n-    /**\n-     * Get all members of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns all members that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Map<String, ResourcePropertyDefinition> getProperties(ToShapeId resource) {\n-        return resourcePropertyMutabilities.getOrDefault(resource.toShapeId(), MapUtils.of())\n-                .entrySet().stream()\n-                .filter(entry -> !getExcludedProperties(resource).contains(entry.getValue().getShapeId()))\n-                .collect(MapUtils.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n-    }\n-\n-    /**\n-     * Gets the specified member of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource\n-     * @param propertyName Name of the property to retrieve\n-     * @return The property definition.\n-     */\n-    public Optional<ResourcePropertyDefinition> getProperty(ToShapeId resource, String propertyName) {\n-        return Optional.ofNullable(getProperties(resource).get(propertyName));\n-    }\n-\n-    /**\n-     * Get create-specifiable-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified only during resource creation and\n-     * can be returned in a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns create-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getCreateOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.contains(Mutability.CREATE) && !mutabilities.contains(Mutability.WRITE);\n-        });\n-    }\n-\n-    /**\n-     * Get read-only members of the CloudFormation resource.\n-     *\n-     * These properties can be returned by a `read` or `list` request,\n-     * but cannot be set by the user.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns read-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getReadOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.size() == 1 && mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    /**\n-     * Get write-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified by the user, but cannot be\n-     * returned by a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns write-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getWriteOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            // Create and non-read properties need to be set as createOnly and writeOnly.\n-            if (mutabilities.size() == 1 && mutabilities.contains(Mutability.CREATE)) {\n-                return true;\n-            }\n-\n-            // Otherwise, create and update, or update only become writeOnly.\n-            return mutabilities.contains(Mutability.WRITE) && !mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    private Set<String> getConstrainedProperties(\n-            ToShapeId resource,\n-            Predicate<ResourcePropertyDefinition> constraint\n-    ) {\n-        return getProperties(resource)\n-                .entrySet()\n-                .stream()\n-                .filter(property -> constraint.test(property.getValue()))\n-                .map(Map.Entry::getKey)\n-                .collect(Collectors.toSet());\n-    }\n-\n-    /**\n-     * Get members that have been explicitly excluded from the CloudFormation\n-     * resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns members that have been excluded from a CloudFormation\n-     *   resource.\n-     */\n-    public Set<ShapeId> getExcludedProperties(ToShapeId resource) {\n-        return resourceExcludedProperties.getOrDefault(resource.toShapeId(), SetUtils.of());\n-    }\n-\n-    /**\n-     * Gets a set of member shape ids that represent the primary way\n-     * to identify a CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns the identifier set primarily used to access a\n-     *   CloudFormation resource.\n-     */\n-    public Set<String> getPrimaryIdentifiers(ToShapeId resource) {\n-        return resourcePrimaryIdentifiers.get(resource.toShapeId());\n-    }\n-\n-    /**\n-     * Get a list of sets of member shape ids, each set can be used to identify\n-     * the CloudFormation resource in addition to its primary identifier(s).\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns identifier sets used to access a CloudFormation resource.\n-     */\n-    public List<Set<String>> getAdditionalIdentifiers(ToShapeId resource) {\n-        return resourceAdditionalIdentifiers.getOrDefault(resource.toShapeId(), ListUtils.of());\n-    }\n-\n-    private void setIdentifierMutabilities(ResourceShape resource) {\n-        Set<Mutability> mutability = getDefaultIdentifierMutabilities(resource);\n-\n-        ShapeId resourceId = resource.getId();\n-\n-        resource.getIdentifiers().forEach((name, shape) -> {\n-            setResourceProperty(resourceId, name, ResourcePropertyDefinition.builder()\n-                    .hasExplicitMutability(true)\n-                    .mutabilities(mutability)\n-                    .shapeId(shape)\n-                    .build());\n-        });\n-    }\n-\n-    private void setResourceProperty(ShapeId resourceId, String name, ResourcePropertyDefinition property) {\n-        Map<String, ResourcePropertyDefinition> resourceProperties =\n-                resourcePropertyMutabilities.getOrDefault(resourceId, new HashMap<>());\n-        resourceProperties.put(name, property);\n-        resourcePropertyMutabilities.put(resourceId, resourceProperties);\n-    }\n-\n-    private Set<Mutability> getDefaultIdentifierMutabilities(ResourceShape resource) {\n-        // If we have a put operation, the identifier will be specified\n-        // on creation. Otherwise, it's read only.\n-        if (resource.getPut().isPresent()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        }\n-\n-        return SetUtils.of(Mutability.READ);\n-    }\n-\n-    private List<Map<String, ShapeId>> computeResourceAdditionalIdentifiers(StructureShape readInput) {\n-        List<Map<String, ShapeId>> identifiers = new ArrayList<>();\n-        for (MemberShape member : readInput.members()) {\n-            if (!member.hasTrait(AdditionalIdentifierTrait.class)) {\n-                continue;\n-            }\n-\n-            identifiers.add(MapUtils.of(member.getMemberName(), member.getId()));\n-        }\n-        return identifiers;\n-    }\n-\n-    private void addAdditionalIdentifiers(ResourceShape resource, List<Map<String, ShapeId>> addedIdentifiers) {\n-        if (addedIdentifiers.isEmpty()) {\n-            return;\n-        }\n-        ShapeId resourceId = resource.getId();\n-\n-        List<Set<String>> newIdentifierNames = new ArrayList<>();\n-        // Make sure we have properties entries for the additional identifiers.\n-        for (Map<String, ShapeId> addedIdentifier : addedIdentifiers) {\n-            for (Map.Entry<String, ShapeId> idEntry : addedIdentifier.entrySet()) {\n-                setResourceProperty(resourceId, idEntry.getKey(), ResourcePropertyDefinition.builder()\n-                        .mutabilities(SetUtils.of(Mutability.READ))\n-                        .shapeId(idEntry.getValue())\n-                        .build());\n-            }\n-            newIdentifierNames.add(addedIdentifier.keySet());\n-        }\n-\n-        List<Set<String>> currentIdentifiers =\n-                resourceAdditionalIdentifiers.getOrDefault(resourceId, new ArrayList<>());\n-        currentIdentifiers.addAll(newIdentifierNames);\n-        resourceAdditionalIdentifiers.put(resourceId, currentIdentifiers);\n-    }\n-\n-    private void updatePropertyMutabilities(\n-            ShapeId resourceId,\n-            ShapeId operationId,\n-            StructureShape propertyContainer,\n-            Set<Mutability> defaultMutabilities,\n-            Function<Set<Mutability>, Set<Mutability>> updater\n-    ) {\n-        addExcludedProperties(resourceId, propertyContainer);\n-\n-        for (MemberShape member : propertyContainer.members()) {\n-            // We've explicitly set identifier mutability based on how the\n-            // resource instance comes about, so only handle non-identifiers.\n-            if (operationMemberIsIdentifier(resourceId, operationId, member)) {\n-                continue;\n-            }\n-\n-            String memberName = member.getMemberName();\n-            ResourcePropertyDefinition memberProperty = getProperties(resourceId).get(memberName);\n-            Set<Mutability> explicitMutability = getExplicitMutability(member, memberProperty);\n-\n-            if (memberProperty != null) {\n-                // Validate that members with the same name target the same shape.\n-                model.getShape(memberProperty.getShapeId())\n-                        .flatMap(Shape::asMemberShape)\n-                        .filter(shape -> !member.getTarget().equals(shape.getTarget()))\n-                        .ifPresent(shape -> {\n-                            throw new RuntimeException(String.format(\"The derived CloudFormation resource \"\n-                                    + \"property for %s is composed of members that target different shapes: %s and %s\",\n-                                    memberName, member.getTarget(), shape.getTarget()));\n-                        });\n-\n-                // Apply updates to the mutability of the property.\n-                if (!memberProperty.hasExplicitMutability()) {\n-                    memberProperty = memberProperty.toBuilder()\n-                            .mutabilities(updater.apply(memberProperty.getMutabilities()))\n-                            .build();\n-                }\n-            } else {\n-                // Set the correct mutability for this new property.\n-                Set<Mutability> mutabilities = !explicitMutability.isEmpty()\n-                        ? explicitMutability\n-                        : defaultMutabilities;\n-                memberProperty = ResourcePropertyDefinition.builder()\n-                        .shapeId(member.getId())\n-                        .mutabilities(mutabilities)\n-                        .hasExplicitMutability(!explicitMutability.isEmpty())\n-                        .build();\n-            }\n-\n-            setResourceProperty(resourceId, memberName, memberProperty);\n-        }\n-    }\n-\n-    private void addExcludedProperties(ShapeId resourceId, StructureShape propertyContainer) {\n-        Set<ShapeId> currentExcludedProperties =\n-                resourceExcludedProperties.getOrDefault(resourceId, new HashSet<>());\n-        currentExcludedProperties.addAll(propertyContainer.accept(new ExcludedPropertiesVisitor()));\n-        resourceExcludedProperties.put(resourceId, currentExcludedProperties);\n-    }\n-\n-    private boolean operationMemberIsIdentifier(ShapeId resourceId, ShapeId operationId, MemberShape member) {\n-        // The operationId will be null in the case of additionalSchemas, so\n-        // we shouldn't worry if these are bound to operation identifiers.\n-        if (operationId == null) {\n-            return false;\n-        }\n-\n-        IdentifierBindingIndex index = IdentifierBindingIndex.of(model);\n-        Map<String, String> bindings = index.getOperationBindings(resourceId, operationId);\n-        String memberName = member.getMemberName();\n-        // Check for literal identifier bindings.\n-        for (String bindingMemberName : bindings.values()) {\n-            if (memberName.equals(bindingMemberName)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private Set<Mutability> getExplicitMutability(\n-            MemberShape member,\n-            ResourcePropertyDefinition memberProperty\n-    ) {\n-        if (memberProperty != null && memberProperty.hasExplicitMutability()) {\n-            return memberProperty.getMutabilities();\n-        }\n-\n-        Optional<MutabilityTrait> traitOptional = member.getMemberTrait(model, MutabilityTrait.class);\n-        if (!traitOptional.isPresent()) {\n-            return SetUtils.of();\n-        }\n-\n-        MutabilityTrait trait = traitOptional.get();\n-        if (trait.isFullyMutable()) {\n-            return FULLY_MUTABLE;\n-        } else if (trait.isCreateAndRead()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        } else if (trait.isCreate()) {\n-            return SetUtils.of(Mutability.CREATE);\n-        } else if (trait.isRead()) {\n-            return SetUtils.of(Mutability.READ);\n-        } else if (trait.isWrite()) {\n-            return SetUtils.of(Mutability.WRITE);\n-        }\n-        return SetUtils.of();\n-    }\n-\n-    private Set<Mutability> addReadMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.READ);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addCreateMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.CREATE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addWriteMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.WRITE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addPutMutability(Set<Mutability> mutabilities) {\n-        return addWriteMutability(addCreateMutability(mutabilities));\n-    }\n-\n-    private final class ExcludedPropertiesVisitor extends ShapeVisitor.Default<Set<ShapeId>> {\n-        @Override\n-        protected Set<ShapeId> getDefault(Shape shape) {\n-            return SetUtils.of();\n-        }\n-\n-        @Override\n-        public Set<ShapeId> structureShape(StructureShape shape) {\n-            Set<ShapeId> excludedShapes = new HashSet<>();\n-            for (MemberShape member : shape.members()) {\n-                if (member.hasTrait(ExcludePropertyTrait.ID)) {\n-                    excludedShapes.add(member.getId());\n-                } else {\n-                    excludedShapes.addAll(model.expectShape(member.getTarget()).accept(this));\n-                }\n-            }\n-            return excludedShapes;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxMDUxMg==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r508910512", "bodyText": "Does this actually need a SetUtils.copyOf here?", "author": "mtdowling", "createdAt": "2020-10-20T23:58:57Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n+import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n+import software.amazon.smithy.model.knowledge.OperationIndex;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeVisitor;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.ToShapeId;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.MapUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+\n+/**\n+ * Index of resources to their CloudFormation identifiers\n+ * and properties.\n+ *\n+ * <p>This index performs no validation that the identifiers\n+ * and reference valid shapes.\n+ */\n+public final class ResourceIndex implements KnowledgeIndex {\n+\n+    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n+            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n+\n+    private final Model model;\n+    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n+    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n+    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n+    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n+\n+    /**\n+     * CloudFormation-specific property mutability options.\n+     */\n+    public enum Mutability {\n+        CREATE,\n+        READ,\n+        WRITE\n+    }\n+\n+    public ResourceIndex(Model model) {\n+        this.model = model;\n+\n+        OperationIndex operationIndex = OperationIndex.of(model);\n+        model.shapes(ResourceShape.class)\n+                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n+                .forEach(pair -> {\n+                    ResourceShape resource = pair.getLeft();\n+                    ShapeId resourceId = resource.getId();\n+\n+                    // Start with the explicit resource identifiers.\n+                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\ndeleted file mode 100644\nindex a50e1e958..000000000\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\n+++ /dev/null\n\n@@ -1,479 +0,0 @@\n-/*\n- * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.smithy.aws.cloudformation.traits;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import software.amazon.smithy.model.Model;\n-import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n-import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n-import software.amazon.smithy.model.knowledge.OperationIndex;\n-import software.amazon.smithy.model.shapes.MemberShape;\n-import software.amazon.smithy.model.shapes.ResourceShape;\n-import software.amazon.smithy.model.shapes.Shape;\n-import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.model.shapes.ShapeVisitor;\n-import software.amazon.smithy.model.shapes.StructureShape;\n-import software.amazon.smithy.model.shapes.ToShapeId;\n-import software.amazon.smithy.model.traits.Trait;\n-import software.amazon.smithy.utils.ListUtils;\n-import software.amazon.smithy.utils.MapUtils;\n-import software.amazon.smithy.utils.SetUtils;\n-\n-/**\n- * Index of resources to their CloudFormation identifiers\n- * and properties.\n- *\n- * <p>This index performs no validation that the identifiers\n- * and reference valid shapes.\n- */\n-public final class ResourceIndex implements KnowledgeIndex {\n-\n-    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n-            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n-\n-    private final Model model;\n-    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n-    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n-    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n-    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n-\n-    /**\n-     * CloudFormation-specific property mutability options.\n-     */\n-    public enum Mutability {\n-        CREATE,\n-        READ,\n-        WRITE\n-    }\n-\n-    public ResourceIndex(Model model) {\n-        this.model = model;\n-\n-        OperationIndex operationIndex = OperationIndex.of(model);\n-        model.shapes(ResourceShape.class)\n-                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n-                .forEach(pair -> {\n-                    ResourceShape resource = pair.getLeft();\n-                    ShapeId resourceId = resource.getId();\n-\n-                    // Start with the explicit resource identifiers.\n-                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));\n-                    setIdentifierMutabilities(resource);\n-\n-                    // Use the read lifecycle's input to collect the additional identifiers\n-                    // and its output to collect readable properties.\n-                    resource.getRead().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            addAdditionalIdentifiers(resource, computeResourceAdditionalIdentifiers(input));\n-                        });\n-                        operationIndex.getOutput(operationId).ifPresent(output -> {\n-                            updatePropertyMutabilities(resourceId, operationId, output,\n-                                    SetUtils.of(Mutability.READ), this::addReadMutability);\n-                        });\n-                    });\n-\n-                    // Use the put lifecycle's input to collect put-able properties.\n-                    resource.getPut().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE, Mutability.WRITE), this::addPutMutability);\n-                        });\n-                    });\n-\n-                    // Use the create lifecycle's input to collect creatable properties.\n-                    resource.getCreate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE), this::addCreateMutability);\n-                        });\n-                    });\n-\n-                    // Use the update lifecycle's input to collect writeable properties.\n-                    resource.getUpdate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.WRITE), this::addWriteMutability);\n-                        });\n-                    });\n-\n-                    // Apply any members found through the trait's additionalSchemas property.\n-                    for (ShapeId additionalSchema : pair.getRight().getAdditionalSchemas()) {\n-                        StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);\n-                        updatePropertyMutabilities(resourceId, null, shape,\n-                                SetUtils.of(), Function.identity());\n-                    }\n-                });\n-    }\n-\n-    public static ResourceIndex of(Model model) {\n-        return model.getKnowledge(ResourceIndex.class, ResourceIndex::new);\n-    }\n-\n-    /**\n-     * Get all members of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns all members that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Map<String, ResourcePropertyDefinition> getProperties(ToShapeId resource) {\n-        return resourcePropertyMutabilities.getOrDefault(resource.toShapeId(), MapUtils.of())\n-                .entrySet().stream()\n-                .filter(entry -> !getExcludedProperties(resource).contains(entry.getValue().getShapeId()))\n-                .collect(MapUtils.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n-    }\n-\n-    /**\n-     * Gets the specified member of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource\n-     * @param propertyName Name of the property to retrieve\n-     * @return The property definition.\n-     */\n-    public Optional<ResourcePropertyDefinition> getProperty(ToShapeId resource, String propertyName) {\n-        return Optional.ofNullable(getProperties(resource).get(propertyName));\n-    }\n-\n-    /**\n-     * Get create-specifiable-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified only during resource creation and\n-     * can be returned in a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns create-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getCreateOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.contains(Mutability.CREATE) && !mutabilities.contains(Mutability.WRITE);\n-        });\n-    }\n-\n-    /**\n-     * Get read-only members of the CloudFormation resource.\n-     *\n-     * These properties can be returned by a `read` or `list` request,\n-     * but cannot be set by the user.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns read-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getReadOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.size() == 1 && mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    /**\n-     * Get write-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified by the user, but cannot be\n-     * returned by a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns write-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getWriteOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            // Create and non-read properties need to be set as createOnly and writeOnly.\n-            if (mutabilities.size() == 1 && mutabilities.contains(Mutability.CREATE)) {\n-                return true;\n-            }\n-\n-            // Otherwise, create and update, or update only become writeOnly.\n-            return mutabilities.contains(Mutability.WRITE) && !mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    private Set<String> getConstrainedProperties(\n-            ToShapeId resource,\n-            Predicate<ResourcePropertyDefinition> constraint\n-    ) {\n-        return getProperties(resource)\n-                .entrySet()\n-                .stream()\n-                .filter(property -> constraint.test(property.getValue()))\n-                .map(Map.Entry::getKey)\n-                .collect(Collectors.toSet());\n-    }\n-\n-    /**\n-     * Get members that have been explicitly excluded from the CloudFormation\n-     * resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns members that have been excluded from a CloudFormation\n-     *   resource.\n-     */\n-    public Set<ShapeId> getExcludedProperties(ToShapeId resource) {\n-        return resourceExcludedProperties.getOrDefault(resource.toShapeId(), SetUtils.of());\n-    }\n-\n-    /**\n-     * Gets a set of member shape ids that represent the primary way\n-     * to identify a CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns the identifier set primarily used to access a\n-     *   CloudFormation resource.\n-     */\n-    public Set<String> getPrimaryIdentifiers(ToShapeId resource) {\n-        return resourcePrimaryIdentifiers.get(resource.toShapeId());\n-    }\n-\n-    /**\n-     * Get a list of sets of member shape ids, each set can be used to identify\n-     * the CloudFormation resource in addition to its primary identifier(s).\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns identifier sets used to access a CloudFormation resource.\n-     */\n-    public List<Set<String>> getAdditionalIdentifiers(ToShapeId resource) {\n-        return resourceAdditionalIdentifiers.getOrDefault(resource.toShapeId(), ListUtils.of());\n-    }\n-\n-    private void setIdentifierMutabilities(ResourceShape resource) {\n-        Set<Mutability> mutability = getDefaultIdentifierMutabilities(resource);\n-\n-        ShapeId resourceId = resource.getId();\n-\n-        resource.getIdentifiers().forEach((name, shape) -> {\n-            setResourceProperty(resourceId, name, ResourcePropertyDefinition.builder()\n-                    .hasExplicitMutability(true)\n-                    .mutabilities(mutability)\n-                    .shapeId(shape)\n-                    .build());\n-        });\n-    }\n-\n-    private void setResourceProperty(ShapeId resourceId, String name, ResourcePropertyDefinition property) {\n-        Map<String, ResourcePropertyDefinition> resourceProperties =\n-                resourcePropertyMutabilities.getOrDefault(resourceId, new HashMap<>());\n-        resourceProperties.put(name, property);\n-        resourcePropertyMutabilities.put(resourceId, resourceProperties);\n-    }\n-\n-    private Set<Mutability> getDefaultIdentifierMutabilities(ResourceShape resource) {\n-        // If we have a put operation, the identifier will be specified\n-        // on creation. Otherwise, it's read only.\n-        if (resource.getPut().isPresent()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        }\n-\n-        return SetUtils.of(Mutability.READ);\n-    }\n-\n-    private List<Map<String, ShapeId>> computeResourceAdditionalIdentifiers(StructureShape readInput) {\n-        List<Map<String, ShapeId>> identifiers = new ArrayList<>();\n-        for (MemberShape member : readInput.members()) {\n-            if (!member.hasTrait(AdditionalIdentifierTrait.class)) {\n-                continue;\n-            }\n-\n-            identifiers.add(MapUtils.of(member.getMemberName(), member.getId()));\n-        }\n-        return identifiers;\n-    }\n-\n-    private void addAdditionalIdentifiers(ResourceShape resource, List<Map<String, ShapeId>> addedIdentifiers) {\n-        if (addedIdentifiers.isEmpty()) {\n-            return;\n-        }\n-        ShapeId resourceId = resource.getId();\n-\n-        List<Set<String>> newIdentifierNames = new ArrayList<>();\n-        // Make sure we have properties entries for the additional identifiers.\n-        for (Map<String, ShapeId> addedIdentifier : addedIdentifiers) {\n-            for (Map.Entry<String, ShapeId> idEntry : addedIdentifier.entrySet()) {\n-                setResourceProperty(resourceId, idEntry.getKey(), ResourcePropertyDefinition.builder()\n-                        .mutabilities(SetUtils.of(Mutability.READ))\n-                        .shapeId(idEntry.getValue())\n-                        .build());\n-            }\n-            newIdentifierNames.add(addedIdentifier.keySet());\n-        }\n-\n-        List<Set<String>> currentIdentifiers =\n-                resourceAdditionalIdentifiers.getOrDefault(resourceId, new ArrayList<>());\n-        currentIdentifiers.addAll(newIdentifierNames);\n-        resourceAdditionalIdentifiers.put(resourceId, currentIdentifiers);\n-    }\n-\n-    private void updatePropertyMutabilities(\n-            ShapeId resourceId,\n-            ShapeId operationId,\n-            StructureShape propertyContainer,\n-            Set<Mutability> defaultMutabilities,\n-            Function<Set<Mutability>, Set<Mutability>> updater\n-    ) {\n-        addExcludedProperties(resourceId, propertyContainer);\n-\n-        for (MemberShape member : propertyContainer.members()) {\n-            // We've explicitly set identifier mutability based on how the\n-            // resource instance comes about, so only handle non-identifiers.\n-            if (operationMemberIsIdentifier(resourceId, operationId, member)) {\n-                continue;\n-            }\n-\n-            String memberName = member.getMemberName();\n-            ResourcePropertyDefinition memberProperty = getProperties(resourceId).get(memberName);\n-            Set<Mutability> explicitMutability = getExplicitMutability(member, memberProperty);\n-\n-            if (memberProperty != null) {\n-                // Validate that members with the same name target the same shape.\n-                model.getShape(memberProperty.getShapeId())\n-                        .flatMap(Shape::asMemberShape)\n-                        .filter(shape -> !member.getTarget().equals(shape.getTarget()))\n-                        .ifPresent(shape -> {\n-                            throw new RuntimeException(String.format(\"The derived CloudFormation resource \"\n-                                    + \"property for %s is composed of members that target different shapes: %s and %s\",\n-                                    memberName, member.getTarget(), shape.getTarget()));\n-                        });\n-\n-                // Apply updates to the mutability of the property.\n-                if (!memberProperty.hasExplicitMutability()) {\n-                    memberProperty = memberProperty.toBuilder()\n-                            .mutabilities(updater.apply(memberProperty.getMutabilities()))\n-                            .build();\n-                }\n-            } else {\n-                // Set the correct mutability for this new property.\n-                Set<Mutability> mutabilities = !explicitMutability.isEmpty()\n-                        ? explicitMutability\n-                        : defaultMutabilities;\n-                memberProperty = ResourcePropertyDefinition.builder()\n-                        .shapeId(member.getId())\n-                        .mutabilities(mutabilities)\n-                        .hasExplicitMutability(!explicitMutability.isEmpty())\n-                        .build();\n-            }\n-\n-            setResourceProperty(resourceId, memberName, memberProperty);\n-        }\n-    }\n-\n-    private void addExcludedProperties(ShapeId resourceId, StructureShape propertyContainer) {\n-        Set<ShapeId> currentExcludedProperties =\n-                resourceExcludedProperties.getOrDefault(resourceId, new HashSet<>());\n-        currentExcludedProperties.addAll(propertyContainer.accept(new ExcludedPropertiesVisitor()));\n-        resourceExcludedProperties.put(resourceId, currentExcludedProperties);\n-    }\n-\n-    private boolean operationMemberIsIdentifier(ShapeId resourceId, ShapeId operationId, MemberShape member) {\n-        // The operationId will be null in the case of additionalSchemas, so\n-        // we shouldn't worry if these are bound to operation identifiers.\n-        if (operationId == null) {\n-            return false;\n-        }\n-\n-        IdentifierBindingIndex index = IdentifierBindingIndex.of(model);\n-        Map<String, String> bindings = index.getOperationBindings(resourceId, operationId);\n-        String memberName = member.getMemberName();\n-        // Check for literal identifier bindings.\n-        for (String bindingMemberName : bindings.values()) {\n-            if (memberName.equals(bindingMemberName)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private Set<Mutability> getExplicitMutability(\n-            MemberShape member,\n-            ResourcePropertyDefinition memberProperty\n-    ) {\n-        if (memberProperty != null && memberProperty.hasExplicitMutability()) {\n-            return memberProperty.getMutabilities();\n-        }\n-\n-        Optional<MutabilityTrait> traitOptional = member.getMemberTrait(model, MutabilityTrait.class);\n-        if (!traitOptional.isPresent()) {\n-            return SetUtils.of();\n-        }\n-\n-        MutabilityTrait trait = traitOptional.get();\n-        if (trait.isFullyMutable()) {\n-            return FULLY_MUTABLE;\n-        } else if (trait.isCreateAndRead()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        } else if (trait.isCreate()) {\n-            return SetUtils.of(Mutability.CREATE);\n-        } else if (trait.isRead()) {\n-            return SetUtils.of(Mutability.READ);\n-        } else if (trait.isWrite()) {\n-            return SetUtils.of(Mutability.WRITE);\n-        }\n-        return SetUtils.of();\n-    }\n-\n-    private Set<Mutability> addReadMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.READ);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addCreateMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.CREATE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addWriteMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.WRITE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addPutMutability(Set<Mutability> mutabilities) {\n-        return addWriteMutability(addCreateMutability(mutabilities));\n-    }\n-\n-    private final class ExcludedPropertiesVisitor extends ShapeVisitor.Default<Set<ShapeId>> {\n-        @Override\n-        protected Set<ShapeId> getDefault(Shape shape) {\n-            return SetUtils.of();\n-        }\n-\n-        @Override\n-        public Set<ShapeId> structureShape(StructureShape shape) {\n-            Set<ShapeId> excludedShapes = new HashSet<>();\n-            for (MemberShape member : shape.members()) {\n-                if (member.hasTrait(ExcludePropertyTrait.ID)) {\n-                    excludedShapes.add(member.getId());\n-                } else {\n-                    excludedShapes.addAll(model.expectShape(member.getTarget()).accept(this));\n-                }\n-            }\n-            return excludedShapes;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxMTAyNg==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r508911026", "bodyText": "Members? Looks like it returns ResourcePropertyDefinitions. Maybe there's a better, or just more specific, term that can be used here?", "author": "mtdowling", "createdAt": "2020-10-21T00:00:21Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n+import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n+import software.amazon.smithy.model.knowledge.OperationIndex;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeVisitor;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.ToShapeId;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.MapUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+\n+/**\n+ * Index of resources to their CloudFormation identifiers\n+ * and properties.\n+ *\n+ * <p>This index performs no validation that the identifiers\n+ * and reference valid shapes.\n+ */\n+public final class ResourceIndex implements KnowledgeIndex {\n+\n+    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n+            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n+\n+    private final Model model;\n+    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n+    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n+    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n+    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n+\n+    /**\n+     * CloudFormation-specific property mutability options.\n+     */\n+    public enum Mutability {\n+        CREATE,\n+        READ,\n+        WRITE\n+    }\n+\n+    public ResourceIndex(Model model) {\n+        this.model = model;\n+\n+        OperationIndex operationIndex = OperationIndex.of(model);\n+        model.shapes(ResourceShape.class)\n+                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n+                .forEach(pair -> {\n+                    ResourceShape resource = pair.getLeft();\n+                    ShapeId resourceId = resource.getId();\n+\n+                    // Start with the explicit resource identifiers.\n+                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));\n+                    setIdentifierMutabilities(resource);\n+\n+                    // Use the read lifecycle's input to collect the additional identifiers\n+                    // and its output to collect readable properties.\n+                    resource.getRead().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            addAdditionalIdentifiers(resource, computeResourceAdditionalIdentifiers(input));\n+                        });\n+                        operationIndex.getOutput(operationId).ifPresent(output -> {\n+                            updatePropertyMutabilities(resourceId, operationId, output,\n+                                    SetUtils.of(Mutability.READ), this::addReadMutability);\n+                        });\n+                    });\n+\n+                    // Use the put lifecycle's input to collect put-able properties.\n+                    resource.getPut().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            updatePropertyMutabilities(resourceId, operationId, input,\n+                                    SetUtils.of(Mutability.CREATE, Mutability.WRITE), this::addPutMutability);\n+                        });\n+                    });\n+\n+                    // Use the create lifecycle's input to collect creatable properties.\n+                    resource.getCreate().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            updatePropertyMutabilities(resourceId, operationId, input,\n+                                    SetUtils.of(Mutability.CREATE), this::addCreateMutability);\n+                        });\n+                    });\n+\n+                    // Use the update lifecycle's input to collect writeable properties.\n+                    resource.getUpdate().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            updatePropertyMutabilities(resourceId, operationId, input,\n+                                    SetUtils.of(Mutability.WRITE), this::addWriteMutability);\n+                        });\n+                    });\n+\n+                    // Apply any members found through the trait's additionalSchemas property.\n+                    for (ShapeId additionalSchema : pair.getRight().getAdditionalSchemas()) {\n+                        StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);\n+                        updatePropertyMutabilities(resourceId, null, shape,\n+                                SetUtils.of(), Function.identity());\n+                    }\n+                });\n+    }\n+\n+    public static ResourceIndex of(Model model) {\n+        return model.getKnowledge(ResourceIndex.class, ResourceIndex::new);\n+    }\n+\n+    /**\n+     * Get all members of the CloudFormation resource.", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\ndeleted file mode 100644\nindex a50e1e958..000000000\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\n+++ /dev/null\n\n@@ -1,479 +0,0 @@\n-/*\n- * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.smithy.aws.cloudformation.traits;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import software.amazon.smithy.model.Model;\n-import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n-import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n-import software.amazon.smithy.model.knowledge.OperationIndex;\n-import software.amazon.smithy.model.shapes.MemberShape;\n-import software.amazon.smithy.model.shapes.ResourceShape;\n-import software.amazon.smithy.model.shapes.Shape;\n-import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.model.shapes.ShapeVisitor;\n-import software.amazon.smithy.model.shapes.StructureShape;\n-import software.amazon.smithy.model.shapes.ToShapeId;\n-import software.amazon.smithy.model.traits.Trait;\n-import software.amazon.smithy.utils.ListUtils;\n-import software.amazon.smithy.utils.MapUtils;\n-import software.amazon.smithy.utils.SetUtils;\n-\n-/**\n- * Index of resources to their CloudFormation identifiers\n- * and properties.\n- *\n- * <p>This index performs no validation that the identifiers\n- * and reference valid shapes.\n- */\n-public final class ResourceIndex implements KnowledgeIndex {\n-\n-    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n-            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n-\n-    private final Model model;\n-    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n-    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n-    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n-    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n-\n-    /**\n-     * CloudFormation-specific property mutability options.\n-     */\n-    public enum Mutability {\n-        CREATE,\n-        READ,\n-        WRITE\n-    }\n-\n-    public ResourceIndex(Model model) {\n-        this.model = model;\n-\n-        OperationIndex operationIndex = OperationIndex.of(model);\n-        model.shapes(ResourceShape.class)\n-                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n-                .forEach(pair -> {\n-                    ResourceShape resource = pair.getLeft();\n-                    ShapeId resourceId = resource.getId();\n-\n-                    // Start with the explicit resource identifiers.\n-                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));\n-                    setIdentifierMutabilities(resource);\n-\n-                    // Use the read lifecycle's input to collect the additional identifiers\n-                    // and its output to collect readable properties.\n-                    resource.getRead().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            addAdditionalIdentifiers(resource, computeResourceAdditionalIdentifiers(input));\n-                        });\n-                        operationIndex.getOutput(operationId).ifPresent(output -> {\n-                            updatePropertyMutabilities(resourceId, operationId, output,\n-                                    SetUtils.of(Mutability.READ), this::addReadMutability);\n-                        });\n-                    });\n-\n-                    // Use the put lifecycle's input to collect put-able properties.\n-                    resource.getPut().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE, Mutability.WRITE), this::addPutMutability);\n-                        });\n-                    });\n-\n-                    // Use the create lifecycle's input to collect creatable properties.\n-                    resource.getCreate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE), this::addCreateMutability);\n-                        });\n-                    });\n-\n-                    // Use the update lifecycle's input to collect writeable properties.\n-                    resource.getUpdate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.WRITE), this::addWriteMutability);\n-                        });\n-                    });\n-\n-                    // Apply any members found through the trait's additionalSchemas property.\n-                    for (ShapeId additionalSchema : pair.getRight().getAdditionalSchemas()) {\n-                        StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);\n-                        updatePropertyMutabilities(resourceId, null, shape,\n-                                SetUtils.of(), Function.identity());\n-                    }\n-                });\n-    }\n-\n-    public static ResourceIndex of(Model model) {\n-        return model.getKnowledge(ResourceIndex.class, ResourceIndex::new);\n-    }\n-\n-    /**\n-     * Get all members of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns all members that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Map<String, ResourcePropertyDefinition> getProperties(ToShapeId resource) {\n-        return resourcePropertyMutabilities.getOrDefault(resource.toShapeId(), MapUtils.of())\n-                .entrySet().stream()\n-                .filter(entry -> !getExcludedProperties(resource).contains(entry.getValue().getShapeId()))\n-                .collect(MapUtils.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n-    }\n-\n-    /**\n-     * Gets the specified member of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource\n-     * @param propertyName Name of the property to retrieve\n-     * @return The property definition.\n-     */\n-    public Optional<ResourcePropertyDefinition> getProperty(ToShapeId resource, String propertyName) {\n-        return Optional.ofNullable(getProperties(resource).get(propertyName));\n-    }\n-\n-    /**\n-     * Get create-specifiable-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified only during resource creation and\n-     * can be returned in a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns create-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getCreateOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.contains(Mutability.CREATE) && !mutabilities.contains(Mutability.WRITE);\n-        });\n-    }\n-\n-    /**\n-     * Get read-only members of the CloudFormation resource.\n-     *\n-     * These properties can be returned by a `read` or `list` request,\n-     * but cannot be set by the user.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns read-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getReadOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.size() == 1 && mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    /**\n-     * Get write-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified by the user, but cannot be\n-     * returned by a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns write-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getWriteOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            // Create and non-read properties need to be set as createOnly and writeOnly.\n-            if (mutabilities.size() == 1 && mutabilities.contains(Mutability.CREATE)) {\n-                return true;\n-            }\n-\n-            // Otherwise, create and update, or update only become writeOnly.\n-            return mutabilities.contains(Mutability.WRITE) && !mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    private Set<String> getConstrainedProperties(\n-            ToShapeId resource,\n-            Predicate<ResourcePropertyDefinition> constraint\n-    ) {\n-        return getProperties(resource)\n-                .entrySet()\n-                .stream()\n-                .filter(property -> constraint.test(property.getValue()))\n-                .map(Map.Entry::getKey)\n-                .collect(Collectors.toSet());\n-    }\n-\n-    /**\n-     * Get members that have been explicitly excluded from the CloudFormation\n-     * resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns members that have been excluded from a CloudFormation\n-     *   resource.\n-     */\n-    public Set<ShapeId> getExcludedProperties(ToShapeId resource) {\n-        return resourceExcludedProperties.getOrDefault(resource.toShapeId(), SetUtils.of());\n-    }\n-\n-    /**\n-     * Gets a set of member shape ids that represent the primary way\n-     * to identify a CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns the identifier set primarily used to access a\n-     *   CloudFormation resource.\n-     */\n-    public Set<String> getPrimaryIdentifiers(ToShapeId resource) {\n-        return resourcePrimaryIdentifiers.get(resource.toShapeId());\n-    }\n-\n-    /**\n-     * Get a list of sets of member shape ids, each set can be used to identify\n-     * the CloudFormation resource in addition to its primary identifier(s).\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns identifier sets used to access a CloudFormation resource.\n-     */\n-    public List<Set<String>> getAdditionalIdentifiers(ToShapeId resource) {\n-        return resourceAdditionalIdentifiers.getOrDefault(resource.toShapeId(), ListUtils.of());\n-    }\n-\n-    private void setIdentifierMutabilities(ResourceShape resource) {\n-        Set<Mutability> mutability = getDefaultIdentifierMutabilities(resource);\n-\n-        ShapeId resourceId = resource.getId();\n-\n-        resource.getIdentifiers().forEach((name, shape) -> {\n-            setResourceProperty(resourceId, name, ResourcePropertyDefinition.builder()\n-                    .hasExplicitMutability(true)\n-                    .mutabilities(mutability)\n-                    .shapeId(shape)\n-                    .build());\n-        });\n-    }\n-\n-    private void setResourceProperty(ShapeId resourceId, String name, ResourcePropertyDefinition property) {\n-        Map<String, ResourcePropertyDefinition> resourceProperties =\n-                resourcePropertyMutabilities.getOrDefault(resourceId, new HashMap<>());\n-        resourceProperties.put(name, property);\n-        resourcePropertyMutabilities.put(resourceId, resourceProperties);\n-    }\n-\n-    private Set<Mutability> getDefaultIdentifierMutabilities(ResourceShape resource) {\n-        // If we have a put operation, the identifier will be specified\n-        // on creation. Otherwise, it's read only.\n-        if (resource.getPut().isPresent()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        }\n-\n-        return SetUtils.of(Mutability.READ);\n-    }\n-\n-    private List<Map<String, ShapeId>> computeResourceAdditionalIdentifiers(StructureShape readInput) {\n-        List<Map<String, ShapeId>> identifiers = new ArrayList<>();\n-        for (MemberShape member : readInput.members()) {\n-            if (!member.hasTrait(AdditionalIdentifierTrait.class)) {\n-                continue;\n-            }\n-\n-            identifiers.add(MapUtils.of(member.getMemberName(), member.getId()));\n-        }\n-        return identifiers;\n-    }\n-\n-    private void addAdditionalIdentifiers(ResourceShape resource, List<Map<String, ShapeId>> addedIdentifiers) {\n-        if (addedIdentifiers.isEmpty()) {\n-            return;\n-        }\n-        ShapeId resourceId = resource.getId();\n-\n-        List<Set<String>> newIdentifierNames = new ArrayList<>();\n-        // Make sure we have properties entries for the additional identifiers.\n-        for (Map<String, ShapeId> addedIdentifier : addedIdentifiers) {\n-            for (Map.Entry<String, ShapeId> idEntry : addedIdentifier.entrySet()) {\n-                setResourceProperty(resourceId, idEntry.getKey(), ResourcePropertyDefinition.builder()\n-                        .mutabilities(SetUtils.of(Mutability.READ))\n-                        .shapeId(idEntry.getValue())\n-                        .build());\n-            }\n-            newIdentifierNames.add(addedIdentifier.keySet());\n-        }\n-\n-        List<Set<String>> currentIdentifiers =\n-                resourceAdditionalIdentifiers.getOrDefault(resourceId, new ArrayList<>());\n-        currentIdentifiers.addAll(newIdentifierNames);\n-        resourceAdditionalIdentifiers.put(resourceId, currentIdentifiers);\n-    }\n-\n-    private void updatePropertyMutabilities(\n-            ShapeId resourceId,\n-            ShapeId operationId,\n-            StructureShape propertyContainer,\n-            Set<Mutability> defaultMutabilities,\n-            Function<Set<Mutability>, Set<Mutability>> updater\n-    ) {\n-        addExcludedProperties(resourceId, propertyContainer);\n-\n-        for (MemberShape member : propertyContainer.members()) {\n-            // We've explicitly set identifier mutability based on how the\n-            // resource instance comes about, so only handle non-identifiers.\n-            if (operationMemberIsIdentifier(resourceId, operationId, member)) {\n-                continue;\n-            }\n-\n-            String memberName = member.getMemberName();\n-            ResourcePropertyDefinition memberProperty = getProperties(resourceId).get(memberName);\n-            Set<Mutability> explicitMutability = getExplicitMutability(member, memberProperty);\n-\n-            if (memberProperty != null) {\n-                // Validate that members with the same name target the same shape.\n-                model.getShape(memberProperty.getShapeId())\n-                        .flatMap(Shape::asMemberShape)\n-                        .filter(shape -> !member.getTarget().equals(shape.getTarget()))\n-                        .ifPresent(shape -> {\n-                            throw new RuntimeException(String.format(\"The derived CloudFormation resource \"\n-                                    + \"property for %s is composed of members that target different shapes: %s and %s\",\n-                                    memberName, member.getTarget(), shape.getTarget()));\n-                        });\n-\n-                // Apply updates to the mutability of the property.\n-                if (!memberProperty.hasExplicitMutability()) {\n-                    memberProperty = memberProperty.toBuilder()\n-                            .mutabilities(updater.apply(memberProperty.getMutabilities()))\n-                            .build();\n-                }\n-            } else {\n-                // Set the correct mutability for this new property.\n-                Set<Mutability> mutabilities = !explicitMutability.isEmpty()\n-                        ? explicitMutability\n-                        : defaultMutabilities;\n-                memberProperty = ResourcePropertyDefinition.builder()\n-                        .shapeId(member.getId())\n-                        .mutabilities(mutabilities)\n-                        .hasExplicitMutability(!explicitMutability.isEmpty())\n-                        .build();\n-            }\n-\n-            setResourceProperty(resourceId, memberName, memberProperty);\n-        }\n-    }\n-\n-    private void addExcludedProperties(ShapeId resourceId, StructureShape propertyContainer) {\n-        Set<ShapeId> currentExcludedProperties =\n-                resourceExcludedProperties.getOrDefault(resourceId, new HashSet<>());\n-        currentExcludedProperties.addAll(propertyContainer.accept(new ExcludedPropertiesVisitor()));\n-        resourceExcludedProperties.put(resourceId, currentExcludedProperties);\n-    }\n-\n-    private boolean operationMemberIsIdentifier(ShapeId resourceId, ShapeId operationId, MemberShape member) {\n-        // The operationId will be null in the case of additionalSchemas, so\n-        // we shouldn't worry if these are bound to operation identifiers.\n-        if (operationId == null) {\n-            return false;\n-        }\n-\n-        IdentifierBindingIndex index = IdentifierBindingIndex.of(model);\n-        Map<String, String> bindings = index.getOperationBindings(resourceId, operationId);\n-        String memberName = member.getMemberName();\n-        // Check for literal identifier bindings.\n-        for (String bindingMemberName : bindings.values()) {\n-            if (memberName.equals(bindingMemberName)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private Set<Mutability> getExplicitMutability(\n-            MemberShape member,\n-            ResourcePropertyDefinition memberProperty\n-    ) {\n-        if (memberProperty != null && memberProperty.hasExplicitMutability()) {\n-            return memberProperty.getMutabilities();\n-        }\n-\n-        Optional<MutabilityTrait> traitOptional = member.getMemberTrait(model, MutabilityTrait.class);\n-        if (!traitOptional.isPresent()) {\n-            return SetUtils.of();\n-        }\n-\n-        MutabilityTrait trait = traitOptional.get();\n-        if (trait.isFullyMutable()) {\n-            return FULLY_MUTABLE;\n-        } else if (trait.isCreateAndRead()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        } else if (trait.isCreate()) {\n-            return SetUtils.of(Mutability.CREATE);\n-        } else if (trait.isRead()) {\n-            return SetUtils.of(Mutability.READ);\n-        } else if (trait.isWrite()) {\n-            return SetUtils.of(Mutability.WRITE);\n-        }\n-        return SetUtils.of();\n-    }\n-\n-    private Set<Mutability> addReadMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.READ);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addCreateMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.CREATE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addWriteMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.WRITE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addPutMutability(Set<Mutability> mutabilities) {\n-        return addWriteMutability(addCreateMutability(mutabilities));\n-    }\n-\n-    private final class ExcludedPropertiesVisitor extends ShapeVisitor.Default<Set<ShapeId>> {\n-        @Override\n-        protected Set<ShapeId> getDefault(Shape shape) {\n-            return SetUtils.of();\n-        }\n-\n-        @Override\n-        public Set<ShapeId> structureShape(StructureShape shape) {\n-            Set<ShapeId> excludedShapes = new HashSet<>();\n-            for (MemberShape member : shape.members()) {\n-                if (member.hasTrait(ExcludePropertyTrait.ID)) {\n-                    excludedShapes.add(member.getId());\n-                } else {\n-                    excludedShapes.addAll(model.expectShape(member.getTarget()).accept(this));\n-                }\n-            }\n-            return excludedShapes;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQyNDY3OA==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r509424678", "bodyText": "Not sure if it's possible to coherently refactor this in the way I'm thinking, but this code seems similar to the code used to validate properties too. I wonder if there's a way to create more of an abstraction for resolving properties and mutability using a more OO approach that separately encapsulates resolving properties (can be used in the validation stuff and probably feed into mutability resolution), mutability (replacing lots of stuff in this index), targets, etc.", "author": "mtdowling", "createdAt": "2020-10-21T16:20:45Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n+import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n+import software.amazon.smithy.model.knowledge.OperationIndex;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeVisitor;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.ToShapeId;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.MapUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+\n+/**\n+ * Index of resources to their CloudFormation identifiers\n+ * and properties.\n+ *\n+ * <p>This index performs no validation that the identifiers\n+ * and reference valid shapes.\n+ */\n+public final class ResourceIndex implements KnowledgeIndex {\n+\n+    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n+            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n+\n+    private final Model model;\n+    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n+    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n+    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n+    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n+\n+    /**\n+     * CloudFormation-specific property mutability options.\n+     */\n+    public enum Mutability {\n+        CREATE,\n+        READ,\n+        WRITE\n+    }\n+\n+    public ResourceIndex(Model model) {\n+        this.model = model;\n+\n+        OperationIndex operationIndex = OperationIndex.of(model);\n+        model.shapes(ResourceShape.class)\n+                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n+                .forEach(pair -> {\n+                    ResourceShape resource = pair.getLeft();\n+                    ShapeId resourceId = resource.getId();\n+\n+                    // Start with the explicit resource identifiers.\n+                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));\n+                    setIdentifierMutabilities(resource);\n+\n+                    // Use the read lifecycle's input to collect the additional identifiers\n+                    // and its output to collect readable properties.\n+                    resource.getRead().ifPresent(operationId -> {", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1MTI0OQ==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r513551249", "bodyText": "I took a smaller approach to refactoring this that handles removing the similar code and handles the potential edge cases safely.", "author": "kstich", "createdAt": "2020-10-28T15:44:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQyNDY3OA=="}], "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\ndeleted file mode 100644\nindex a50e1e958..000000000\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\n+++ /dev/null\n\n@@ -1,479 +0,0 @@\n-/*\n- * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.smithy.aws.cloudformation.traits;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import software.amazon.smithy.model.Model;\n-import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n-import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n-import software.amazon.smithy.model.knowledge.OperationIndex;\n-import software.amazon.smithy.model.shapes.MemberShape;\n-import software.amazon.smithy.model.shapes.ResourceShape;\n-import software.amazon.smithy.model.shapes.Shape;\n-import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.model.shapes.ShapeVisitor;\n-import software.amazon.smithy.model.shapes.StructureShape;\n-import software.amazon.smithy.model.shapes.ToShapeId;\n-import software.amazon.smithy.model.traits.Trait;\n-import software.amazon.smithy.utils.ListUtils;\n-import software.amazon.smithy.utils.MapUtils;\n-import software.amazon.smithy.utils.SetUtils;\n-\n-/**\n- * Index of resources to their CloudFormation identifiers\n- * and properties.\n- *\n- * <p>This index performs no validation that the identifiers\n- * and reference valid shapes.\n- */\n-public final class ResourceIndex implements KnowledgeIndex {\n-\n-    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n-            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n-\n-    private final Model model;\n-    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n-    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n-    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n-    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n-\n-    /**\n-     * CloudFormation-specific property mutability options.\n-     */\n-    public enum Mutability {\n-        CREATE,\n-        READ,\n-        WRITE\n-    }\n-\n-    public ResourceIndex(Model model) {\n-        this.model = model;\n-\n-        OperationIndex operationIndex = OperationIndex.of(model);\n-        model.shapes(ResourceShape.class)\n-                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n-                .forEach(pair -> {\n-                    ResourceShape resource = pair.getLeft();\n-                    ShapeId resourceId = resource.getId();\n-\n-                    // Start with the explicit resource identifiers.\n-                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));\n-                    setIdentifierMutabilities(resource);\n-\n-                    // Use the read lifecycle's input to collect the additional identifiers\n-                    // and its output to collect readable properties.\n-                    resource.getRead().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            addAdditionalIdentifiers(resource, computeResourceAdditionalIdentifiers(input));\n-                        });\n-                        operationIndex.getOutput(operationId).ifPresent(output -> {\n-                            updatePropertyMutabilities(resourceId, operationId, output,\n-                                    SetUtils.of(Mutability.READ), this::addReadMutability);\n-                        });\n-                    });\n-\n-                    // Use the put lifecycle's input to collect put-able properties.\n-                    resource.getPut().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE, Mutability.WRITE), this::addPutMutability);\n-                        });\n-                    });\n-\n-                    // Use the create lifecycle's input to collect creatable properties.\n-                    resource.getCreate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE), this::addCreateMutability);\n-                        });\n-                    });\n-\n-                    // Use the update lifecycle's input to collect writeable properties.\n-                    resource.getUpdate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.WRITE), this::addWriteMutability);\n-                        });\n-                    });\n-\n-                    // Apply any members found through the trait's additionalSchemas property.\n-                    for (ShapeId additionalSchema : pair.getRight().getAdditionalSchemas()) {\n-                        StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);\n-                        updatePropertyMutabilities(resourceId, null, shape,\n-                                SetUtils.of(), Function.identity());\n-                    }\n-                });\n-    }\n-\n-    public static ResourceIndex of(Model model) {\n-        return model.getKnowledge(ResourceIndex.class, ResourceIndex::new);\n-    }\n-\n-    /**\n-     * Get all members of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns all members that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Map<String, ResourcePropertyDefinition> getProperties(ToShapeId resource) {\n-        return resourcePropertyMutabilities.getOrDefault(resource.toShapeId(), MapUtils.of())\n-                .entrySet().stream()\n-                .filter(entry -> !getExcludedProperties(resource).contains(entry.getValue().getShapeId()))\n-                .collect(MapUtils.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n-    }\n-\n-    /**\n-     * Gets the specified member of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource\n-     * @param propertyName Name of the property to retrieve\n-     * @return The property definition.\n-     */\n-    public Optional<ResourcePropertyDefinition> getProperty(ToShapeId resource, String propertyName) {\n-        return Optional.ofNullable(getProperties(resource).get(propertyName));\n-    }\n-\n-    /**\n-     * Get create-specifiable-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified only during resource creation and\n-     * can be returned in a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns create-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getCreateOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.contains(Mutability.CREATE) && !mutabilities.contains(Mutability.WRITE);\n-        });\n-    }\n-\n-    /**\n-     * Get read-only members of the CloudFormation resource.\n-     *\n-     * These properties can be returned by a `read` or `list` request,\n-     * but cannot be set by the user.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns read-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getReadOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.size() == 1 && mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    /**\n-     * Get write-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified by the user, but cannot be\n-     * returned by a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns write-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getWriteOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            // Create and non-read properties need to be set as createOnly and writeOnly.\n-            if (mutabilities.size() == 1 && mutabilities.contains(Mutability.CREATE)) {\n-                return true;\n-            }\n-\n-            // Otherwise, create and update, or update only become writeOnly.\n-            return mutabilities.contains(Mutability.WRITE) && !mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    private Set<String> getConstrainedProperties(\n-            ToShapeId resource,\n-            Predicate<ResourcePropertyDefinition> constraint\n-    ) {\n-        return getProperties(resource)\n-                .entrySet()\n-                .stream()\n-                .filter(property -> constraint.test(property.getValue()))\n-                .map(Map.Entry::getKey)\n-                .collect(Collectors.toSet());\n-    }\n-\n-    /**\n-     * Get members that have been explicitly excluded from the CloudFormation\n-     * resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns members that have been excluded from a CloudFormation\n-     *   resource.\n-     */\n-    public Set<ShapeId> getExcludedProperties(ToShapeId resource) {\n-        return resourceExcludedProperties.getOrDefault(resource.toShapeId(), SetUtils.of());\n-    }\n-\n-    /**\n-     * Gets a set of member shape ids that represent the primary way\n-     * to identify a CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns the identifier set primarily used to access a\n-     *   CloudFormation resource.\n-     */\n-    public Set<String> getPrimaryIdentifiers(ToShapeId resource) {\n-        return resourcePrimaryIdentifiers.get(resource.toShapeId());\n-    }\n-\n-    /**\n-     * Get a list of sets of member shape ids, each set can be used to identify\n-     * the CloudFormation resource in addition to its primary identifier(s).\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns identifier sets used to access a CloudFormation resource.\n-     */\n-    public List<Set<String>> getAdditionalIdentifiers(ToShapeId resource) {\n-        return resourceAdditionalIdentifiers.getOrDefault(resource.toShapeId(), ListUtils.of());\n-    }\n-\n-    private void setIdentifierMutabilities(ResourceShape resource) {\n-        Set<Mutability> mutability = getDefaultIdentifierMutabilities(resource);\n-\n-        ShapeId resourceId = resource.getId();\n-\n-        resource.getIdentifiers().forEach((name, shape) -> {\n-            setResourceProperty(resourceId, name, ResourcePropertyDefinition.builder()\n-                    .hasExplicitMutability(true)\n-                    .mutabilities(mutability)\n-                    .shapeId(shape)\n-                    .build());\n-        });\n-    }\n-\n-    private void setResourceProperty(ShapeId resourceId, String name, ResourcePropertyDefinition property) {\n-        Map<String, ResourcePropertyDefinition> resourceProperties =\n-                resourcePropertyMutabilities.getOrDefault(resourceId, new HashMap<>());\n-        resourceProperties.put(name, property);\n-        resourcePropertyMutabilities.put(resourceId, resourceProperties);\n-    }\n-\n-    private Set<Mutability> getDefaultIdentifierMutabilities(ResourceShape resource) {\n-        // If we have a put operation, the identifier will be specified\n-        // on creation. Otherwise, it's read only.\n-        if (resource.getPut().isPresent()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        }\n-\n-        return SetUtils.of(Mutability.READ);\n-    }\n-\n-    private List<Map<String, ShapeId>> computeResourceAdditionalIdentifiers(StructureShape readInput) {\n-        List<Map<String, ShapeId>> identifiers = new ArrayList<>();\n-        for (MemberShape member : readInput.members()) {\n-            if (!member.hasTrait(AdditionalIdentifierTrait.class)) {\n-                continue;\n-            }\n-\n-            identifiers.add(MapUtils.of(member.getMemberName(), member.getId()));\n-        }\n-        return identifiers;\n-    }\n-\n-    private void addAdditionalIdentifiers(ResourceShape resource, List<Map<String, ShapeId>> addedIdentifiers) {\n-        if (addedIdentifiers.isEmpty()) {\n-            return;\n-        }\n-        ShapeId resourceId = resource.getId();\n-\n-        List<Set<String>> newIdentifierNames = new ArrayList<>();\n-        // Make sure we have properties entries for the additional identifiers.\n-        for (Map<String, ShapeId> addedIdentifier : addedIdentifiers) {\n-            for (Map.Entry<String, ShapeId> idEntry : addedIdentifier.entrySet()) {\n-                setResourceProperty(resourceId, idEntry.getKey(), ResourcePropertyDefinition.builder()\n-                        .mutabilities(SetUtils.of(Mutability.READ))\n-                        .shapeId(idEntry.getValue())\n-                        .build());\n-            }\n-            newIdentifierNames.add(addedIdentifier.keySet());\n-        }\n-\n-        List<Set<String>> currentIdentifiers =\n-                resourceAdditionalIdentifiers.getOrDefault(resourceId, new ArrayList<>());\n-        currentIdentifiers.addAll(newIdentifierNames);\n-        resourceAdditionalIdentifiers.put(resourceId, currentIdentifiers);\n-    }\n-\n-    private void updatePropertyMutabilities(\n-            ShapeId resourceId,\n-            ShapeId operationId,\n-            StructureShape propertyContainer,\n-            Set<Mutability> defaultMutabilities,\n-            Function<Set<Mutability>, Set<Mutability>> updater\n-    ) {\n-        addExcludedProperties(resourceId, propertyContainer);\n-\n-        for (MemberShape member : propertyContainer.members()) {\n-            // We've explicitly set identifier mutability based on how the\n-            // resource instance comes about, so only handle non-identifiers.\n-            if (operationMemberIsIdentifier(resourceId, operationId, member)) {\n-                continue;\n-            }\n-\n-            String memberName = member.getMemberName();\n-            ResourcePropertyDefinition memberProperty = getProperties(resourceId).get(memberName);\n-            Set<Mutability> explicitMutability = getExplicitMutability(member, memberProperty);\n-\n-            if (memberProperty != null) {\n-                // Validate that members with the same name target the same shape.\n-                model.getShape(memberProperty.getShapeId())\n-                        .flatMap(Shape::asMemberShape)\n-                        .filter(shape -> !member.getTarget().equals(shape.getTarget()))\n-                        .ifPresent(shape -> {\n-                            throw new RuntimeException(String.format(\"The derived CloudFormation resource \"\n-                                    + \"property for %s is composed of members that target different shapes: %s and %s\",\n-                                    memberName, member.getTarget(), shape.getTarget()));\n-                        });\n-\n-                // Apply updates to the mutability of the property.\n-                if (!memberProperty.hasExplicitMutability()) {\n-                    memberProperty = memberProperty.toBuilder()\n-                            .mutabilities(updater.apply(memberProperty.getMutabilities()))\n-                            .build();\n-                }\n-            } else {\n-                // Set the correct mutability for this new property.\n-                Set<Mutability> mutabilities = !explicitMutability.isEmpty()\n-                        ? explicitMutability\n-                        : defaultMutabilities;\n-                memberProperty = ResourcePropertyDefinition.builder()\n-                        .shapeId(member.getId())\n-                        .mutabilities(mutabilities)\n-                        .hasExplicitMutability(!explicitMutability.isEmpty())\n-                        .build();\n-            }\n-\n-            setResourceProperty(resourceId, memberName, memberProperty);\n-        }\n-    }\n-\n-    private void addExcludedProperties(ShapeId resourceId, StructureShape propertyContainer) {\n-        Set<ShapeId> currentExcludedProperties =\n-                resourceExcludedProperties.getOrDefault(resourceId, new HashSet<>());\n-        currentExcludedProperties.addAll(propertyContainer.accept(new ExcludedPropertiesVisitor()));\n-        resourceExcludedProperties.put(resourceId, currentExcludedProperties);\n-    }\n-\n-    private boolean operationMemberIsIdentifier(ShapeId resourceId, ShapeId operationId, MemberShape member) {\n-        // The operationId will be null in the case of additionalSchemas, so\n-        // we shouldn't worry if these are bound to operation identifiers.\n-        if (operationId == null) {\n-            return false;\n-        }\n-\n-        IdentifierBindingIndex index = IdentifierBindingIndex.of(model);\n-        Map<String, String> bindings = index.getOperationBindings(resourceId, operationId);\n-        String memberName = member.getMemberName();\n-        // Check for literal identifier bindings.\n-        for (String bindingMemberName : bindings.values()) {\n-            if (memberName.equals(bindingMemberName)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private Set<Mutability> getExplicitMutability(\n-            MemberShape member,\n-            ResourcePropertyDefinition memberProperty\n-    ) {\n-        if (memberProperty != null && memberProperty.hasExplicitMutability()) {\n-            return memberProperty.getMutabilities();\n-        }\n-\n-        Optional<MutabilityTrait> traitOptional = member.getMemberTrait(model, MutabilityTrait.class);\n-        if (!traitOptional.isPresent()) {\n-            return SetUtils.of();\n-        }\n-\n-        MutabilityTrait trait = traitOptional.get();\n-        if (trait.isFullyMutable()) {\n-            return FULLY_MUTABLE;\n-        } else if (trait.isCreateAndRead()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        } else if (trait.isCreate()) {\n-            return SetUtils.of(Mutability.CREATE);\n-        } else if (trait.isRead()) {\n-            return SetUtils.of(Mutability.READ);\n-        } else if (trait.isWrite()) {\n-            return SetUtils.of(Mutability.WRITE);\n-        }\n-        return SetUtils.of();\n-    }\n-\n-    private Set<Mutability> addReadMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.READ);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addCreateMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.CREATE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addWriteMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.WRITE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addPutMutability(Set<Mutability> mutabilities) {\n-        return addWriteMutability(addCreateMutability(mutabilities));\n-    }\n-\n-    private final class ExcludedPropertiesVisitor extends ShapeVisitor.Default<Set<ShapeId>> {\n-        @Override\n-        protected Set<ShapeId> getDefault(Shape shape) {\n-            return SetUtils.of();\n-        }\n-\n-        @Override\n-        public Set<ShapeId> structureShape(StructureShape shape) {\n-            Set<ShapeId> excludedShapes = new HashSet<>();\n-            for (MemberShape member : shape.members()) {\n-                if (member.hasTrait(ExcludePropertyTrait.ID)) {\n-                    excludedShapes.add(member.getId());\n-                } else {\n-                    excludedShapes.addAll(model.expectShape(member.getTarget()).accept(this));\n-                }\n-            }\n-            return excludedShapes;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQyNTU5Nw==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r509425597", "bodyText": "Ah, so we do automatically infer the mutability characteristics of properties based on which lifecycle the property is associated with.", "author": "mtdowling", "createdAt": "2020-10-21T16:22:08Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n+import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n+import software.amazon.smithy.model.knowledge.OperationIndex;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeVisitor;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.ToShapeId;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.MapUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+\n+/**\n+ * Index of resources to their CloudFormation identifiers\n+ * and properties.\n+ *\n+ * <p>This index performs no validation that the identifiers\n+ * and reference valid shapes.\n+ */\n+public final class ResourceIndex implements KnowledgeIndex {\n+\n+    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n+            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n+\n+    private final Model model;\n+    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n+    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n+    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n+    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n+\n+    /**\n+     * CloudFormation-specific property mutability options.\n+     */\n+    public enum Mutability {\n+        CREATE,\n+        READ,\n+        WRITE\n+    }\n+\n+    public ResourceIndex(Model model) {\n+        this.model = model;\n+\n+        OperationIndex operationIndex = OperationIndex.of(model);\n+        model.shapes(ResourceShape.class)\n+                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n+                .forEach(pair -> {\n+                    ResourceShape resource = pair.getLeft();\n+                    ShapeId resourceId = resource.getId();\n+\n+                    // Start with the explicit resource identifiers.\n+                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));\n+                    setIdentifierMutabilities(resource);\n+\n+                    // Use the read lifecycle's input to collect the additional identifiers\n+                    // and its output to collect readable properties.\n+                    resource.getRead().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            addAdditionalIdentifiers(resource, computeResourceAdditionalIdentifiers(input));\n+                        });\n+                        operationIndex.getOutput(operationId).ifPresent(output -> {\n+                            updatePropertyMutabilities(resourceId, operationId, output,\n+                                    SetUtils.of(Mutability.READ), this::addReadMutability);\n+                        });\n+                    });\n+\n+                    // Use the put lifecycle's input to collect put-able properties.\n+                    resource.getPut().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            updatePropertyMutabilities(resourceId, operationId, input,\n+                                    SetUtils.of(Mutability.CREATE, Mutability.WRITE), this::addPutMutability);", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\ndeleted file mode 100644\nindex a50e1e958..000000000\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\n+++ /dev/null\n\n@@ -1,479 +0,0 @@\n-/*\n- * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.smithy.aws.cloudformation.traits;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import software.amazon.smithy.model.Model;\n-import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n-import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n-import software.amazon.smithy.model.knowledge.OperationIndex;\n-import software.amazon.smithy.model.shapes.MemberShape;\n-import software.amazon.smithy.model.shapes.ResourceShape;\n-import software.amazon.smithy.model.shapes.Shape;\n-import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.model.shapes.ShapeVisitor;\n-import software.amazon.smithy.model.shapes.StructureShape;\n-import software.amazon.smithy.model.shapes.ToShapeId;\n-import software.amazon.smithy.model.traits.Trait;\n-import software.amazon.smithy.utils.ListUtils;\n-import software.amazon.smithy.utils.MapUtils;\n-import software.amazon.smithy.utils.SetUtils;\n-\n-/**\n- * Index of resources to their CloudFormation identifiers\n- * and properties.\n- *\n- * <p>This index performs no validation that the identifiers\n- * and reference valid shapes.\n- */\n-public final class ResourceIndex implements KnowledgeIndex {\n-\n-    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n-            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n-\n-    private final Model model;\n-    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n-    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n-    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n-    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n-\n-    /**\n-     * CloudFormation-specific property mutability options.\n-     */\n-    public enum Mutability {\n-        CREATE,\n-        READ,\n-        WRITE\n-    }\n-\n-    public ResourceIndex(Model model) {\n-        this.model = model;\n-\n-        OperationIndex operationIndex = OperationIndex.of(model);\n-        model.shapes(ResourceShape.class)\n-                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n-                .forEach(pair -> {\n-                    ResourceShape resource = pair.getLeft();\n-                    ShapeId resourceId = resource.getId();\n-\n-                    // Start with the explicit resource identifiers.\n-                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));\n-                    setIdentifierMutabilities(resource);\n-\n-                    // Use the read lifecycle's input to collect the additional identifiers\n-                    // and its output to collect readable properties.\n-                    resource.getRead().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            addAdditionalIdentifiers(resource, computeResourceAdditionalIdentifiers(input));\n-                        });\n-                        operationIndex.getOutput(operationId).ifPresent(output -> {\n-                            updatePropertyMutabilities(resourceId, operationId, output,\n-                                    SetUtils.of(Mutability.READ), this::addReadMutability);\n-                        });\n-                    });\n-\n-                    // Use the put lifecycle's input to collect put-able properties.\n-                    resource.getPut().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE, Mutability.WRITE), this::addPutMutability);\n-                        });\n-                    });\n-\n-                    // Use the create lifecycle's input to collect creatable properties.\n-                    resource.getCreate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE), this::addCreateMutability);\n-                        });\n-                    });\n-\n-                    // Use the update lifecycle's input to collect writeable properties.\n-                    resource.getUpdate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.WRITE), this::addWriteMutability);\n-                        });\n-                    });\n-\n-                    // Apply any members found through the trait's additionalSchemas property.\n-                    for (ShapeId additionalSchema : pair.getRight().getAdditionalSchemas()) {\n-                        StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);\n-                        updatePropertyMutabilities(resourceId, null, shape,\n-                                SetUtils.of(), Function.identity());\n-                    }\n-                });\n-    }\n-\n-    public static ResourceIndex of(Model model) {\n-        return model.getKnowledge(ResourceIndex.class, ResourceIndex::new);\n-    }\n-\n-    /**\n-     * Get all members of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns all members that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Map<String, ResourcePropertyDefinition> getProperties(ToShapeId resource) {\n-        return resourcePropertyMutabilities.getOrDefault(resource.toShapeId(), MapUtils.of())\n-                .entrySet().stream()\n-                .filter(entry -> !getExcludedProperties(resource).contains(entry.getValue().getShapeId()))\n-                .collect(MapUtils.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n-    }\n-\n-    /**\n-     * Gets the specified member of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource\n-     * @param propertyName Name of the property to retrieve\n-     * @return The property definition.\n-     */\n-    public Optional<ResourcePropertyDefinition> getProperty(ToShapeId resource, String propertyName) {\n-        return Optional.ofNullable(getProperties(resource).get(propertyName));\n-    }\n-\n-    /**\n-     * Get create-specifiable-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified only during resource creation and\n-     * can be returned in a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns create-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getCreateOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.contains(Mutability.CREATE) && !mutabilities.contains(Mutability.WRITE);\n-        });\n-    }\n-\n-    /**\n-     * Get read-only members of the CloudFormation resource.\n-     *\n-     * These properties can be returned by a `read` or `list` request,\n-     * but cannot be set by the user.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns read-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getReadOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.size() == 1 && mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    /**\n-     * Get write-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified by the user, but cannot be\n-     * returned by a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns write-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getWriteOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            // Create and non-read properties need to be set as createOnly and writeOnly.\n-            if (mutabilities.size() == 1 && mutabilities.contains(Mutability.CREATE)) {\n-                return true;\n-            }\n-\n-            // Otherwise, create and update, or update only become writeOnly.\n-            return mutabilities.contains(Mutability.WRITE) && !mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    private Set<String> getConstrainedProperties(\n-            ToShapeId resource,\n-            Predicate<ResourcePropertyDefinition> constraint\n-    ) {\n-        return getProperties(resource)\n-                .entrySet()\n-                .stream()\n-                .filter(property -> constraint.test(property.getValue()))\n-                .map(Map.Entry::getKey)\n-                .collect(Collectors.toSet());\n-    }\n-\n-    /**\n-     * Get members that have been explicitly excluded from the CloudFormation\n-     * resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns members that have been excluded from a CloudFormation\n-     *   resource.\n-     */\n-    public Set<ShapeId> getExcludedProperties(ToShapeId resource) {\n-        return resourceExcludedProperties.getOrDefault(resource.toShapeId(), SetUtils.of());\n-    }\n-\n-    /**\n-     * Gets a set of member shape ids that represent the primary way\n-     * to identify a CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns the identifier set primarily used to access a\n-     *   CloudFormation resource.\n-     */\n-    public Set<String> getPrimaryIdentifiers(ToShapeId resource) {\n-        return resourcePrimaryIdentifiers.get(resource.toShapeId());\n-    }\n-\n-    /**\n-     * Get a list of sets of member shape ids, each set can be used to identify\n-     * the CloudFormation resource in addition to its primary identifier(s).\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns identifier sets used to access a CloudFormation resource.\n-     */\n-    public List<Set<String>> getAdditionalIdentifiers(ToShapeId resource) {\n-        return resourceAdditionalIdentifiers.getOrDefault(resource.toShapeId(), ListUtils.of());\n-    }\n-\n-    private void setIdentifierMutabilities(ResourceShape resource) {\n-        Set<Mutability> mutability = getDefaultIdentifierMutabilities(resource);\n-\n-        ShapeId resourceId = resource.getId();\n-\n-        resource.getIdentifiers().forEach((name, shape) -> {\n-            setResourceProperty(resourceId, name, ResourcePropertyDefinition.builder()\n-                    .hasExplicitMutability(true)\n-                    .mutabilities(mutability)\n-                    .shapeId(shape)\n-                    .build());\n-        });\n-    }\n-\n-    private void setResourceProperty(ShapeId resourceId, String name, ResourcePropertyDefinition property) {\n-        Map<String, ResourcePropertyDefinition> resourceProperties =\n-                resourcePropertyMutabilities.getOrDefault(resourceId, new HashMap<>());\n-        resourceProperties.put(name, property);\n-        resourcePropertyMutabilities.put(resourceId, resourceProperties);\n-    }\n-\n-    private Set<Mutability> getDefaultIdentifierMutabilities(ResourceShape resource) {\n-        // If we have a put operation, the identifier will be specified\n-        // on creation. Otherwise, it's read only.\n-        if (resource.getPut().isPresent()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        }\n-\n-        return SetUtils.of(Mutability.READ);\n-    }\n-\n-    private List<Map<String, ShapeId>> computeResourceAdditionalIdentifiers(StructureShape readInput) {\n-        List<Map<String, ShapeId>> identifiers = new ArrayList<>();\n-        for (MemberShape member : readInput.members()) {\n-            if (!member.hasTrait(AdditionalIdentifierTrait.class)) {\n-                continue;\n-            }\n-\n-            identifiers.add(MapUtils.of(member.getMemberName(), member.getId()));\n-        }\n-        return identifiers;\n-    }\n-\n-    private void addAdditionalIdentifiers(ResourceShape resource, List<Map<String, ShapeId>> addedIdentifiers) {\n-        if (addedIdentifiers.isEmpty()) {\n-            return;\n-        }\n-        ShapeId resourceId = resource.getId();\n-\n-        List<Set<String>> newIdentifierNames = new ArrayList<>();\n-        // Make sure we have properties entries for the additional identifiers.\n-        for (Map<String, ShapeId> addedIdentifier : addedIdentifiers) {\n-            for (Map.Entry<String, ShapeId> idEntry : addedIdentifier.entrySet()) {\n-                setResourceProperty(resourceId, idEntry.getKey(), ResourcePropertyDefinition.builder()\n-                        .mutabilities(SetUtils.of(Mutability.READ))\n-                        .shapeId(idEntry.getValue())\n-                        .build());\n-            }\n-            newIdentifierNames.add(addedIdentifier.keySet());\n-        }\n-\n-        List<Set<String>> currentIdentifiers =\n-                resourceAdditionalIdentifiers.getOrDefault(resourceId, new ArrayList<>());\n-        currentIdentifiers.addAll(newIdentifierNames);\n-        resourceAdditionalIdentifiers.put(resourceId, currentIdentifiers);\n-    }\n-\n-    private void updatePropertyMutabilities(\n-            ShapeId resourceId,\n-            ShapeId operationId,\n-            StructureShape propertyContainer,\n-            Set<Mutability> defaultMutabilities,\n-            Function<Set<Mutability>, Set<Mutability>> updater\n-    ) {\n-        addExcludedProperties(resourceId, propertyContainer);\n-\n-        for (MemberShape member : propertyContainer.members()) {\n-            // We've explicitly set identifier mutability based on how the\n-            // resource instance comes about, so only handle non-identifiers.\n-            if (operationMemberIsIdentifier(resourceId, operationId, member)) {\n-                continue;\n-            }\n-\n-            String memberName = member.getMemberName();\n-            ResourcePropertyDefinition memberProperty = getProperties(resourceId).get(memberName);\n-            Set<Mutability> explicitMutability = getExplicitMutability(member, memberProperty);\n-\n-            if (memberProperty != null) {\n-                // Validate that members with the same name target the same shape.\n-                model.getShape(memberProperty.getShapeId())\n-                        .flatMap(Shape::asMemberShape)\n-                        .filter(shape -> !member.getTarget().equals(shape.getTarget()))\n-                        .ifPresent(shape -> {\n-                            throw new RuntimeException(String.format(\"The derived CloudFormation resource \"\n-                                    + \"property for %s is composed of members that target different shapes: %s and %s\",\n-                                    memberName, member.getTarget(), shape.getTarget()));\n-                        });\n-\n-                // Apply updates to the mutability of the property.\n-                if (!memberProperty.hasExplicitMutability()) {\n-                    memberProperty = memberProperty.toBuilder()\n-                            .mutabilities(updater.apply(memberProperty.getMutabilities()))\n-                            .build();\n-                }\n-            } else {\n-                // Set the correct mutability for this new property.\n-                Set<Mutability> mutabilities = !explicitMutability.isEmpty()\n-                        ? explicitMutability\n-                        : defaultMutabilities;\n-                memberProperty = ResourcePropertyDefinition.builder()\n-                        .shapeId(member.getId())\n-                        .mutabilities(mutabilities)\n-                        .hasExplicitMutability(!explicitMutability.isEmpty())\n-                        .build();\n-            }\n-\n-            setResourceProperty(resourceId, memberName, memberProperty);\n-        }\n-    }\n-\n-    private void addExcludedProperties(ShapeId resourceId, StructureShape propertyContainer) {\n-        Set<ShapeId> currentExcludedProperties =\n-                resourceExcludedProperties.getOrDefault(resourceId, new HashSet<>());\n-        currentExcludedProperties.addAll(propertyContainer.accept(new ExcludedPropertiesVisitor()));\n-        resourceExcludedProperties.put(resourceId, currentExcludedProperties);\n-    }\n-\n-    private boolean operationMemberIsIdentifier(ShapeId resourceId, ShapeId operationId, MemberShape member) {\n-        // The operationId will be null in the case of additionalSchemas, so\n-        // we shouldn't worry if these are bound to operation identifiers.\n-        if (operationId == null) {\n-            return false;\n-        }\n-\n-        IdentifierBindingIndex index = IdentifierBindingIndex.of(model);\n-        Map<String, String> bindings = index.getOperationBindings(resourceId, operationId);\n-        String memberName = member.getMemberName();\n-        // Check for literal identifier bindings.\n-        for (String bindingMemberName : bindings.values()) {\n-            if (memberName.equals(bindingMemberName)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private Set<Mutability> getExplicitMutability(\n-            MemberShape member,\n-            ResourcePropertyDefinition memberProperty\n-    ) {\n-        if (memberProperty != null && memberProperty.hasExplicitMutability()) {\n-            return memberProperty.getMutabilities();\n-        }\n-\n-        Optional<MutabilityTrait> traitOptional = member.getMemberTrait(model, MutabilityTrait.class);\n-        if (!traitOptional.isPresent()) {\n-            return SetUtils.of();\n-        }\n-\n-        MutabilityTrait trait = traitOptional.get();\n-        if (trait.isFullyMutable()) {\n-            return FULLY_MUTABLE;\n-        } else if (trait.isCreateAndRead()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        } else if (trait.isCreate()) {\n-            return SetUtils.of(Mutability.CREATE);\n-        } else if (trait.isRead()) {\n-            return SetUtils.of(Mutability.READ);\n-        } else if (trait.isWrite()) {\n-            return SetUtils.of(Mutability.WRITE);\n-        }\n-        return SetUtils.of();\n-    }\n-\n-    private Set<Mutability> addReadMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.READ);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addCreateMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.CREATE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addWriteMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.WRITE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addPutMutability(Set<Mutability> mutabilities) {\n-        return addWriteMutability(addCreateMutability(mutabilities));\n-    }\n-\n-    private final class ExcludedPropertiesVisitor extends ShapeVisitor.Default<Set<ShapeId>> {\n-        @Override\n-        protected Set<ShapeId> getDefault(Shape shape) {\n-            return SetUtils.of();\n-        }\n-\n-        @Override\n-        public Set<ShapeId> structureShape(StructureShape shape) {\n-            Set<ShapeId> excludedShapes = new HashSet<>();\n-            for (MemberShape member : shape.members()) {\n-                if (member.hasTrait(ExcludePropertyTrait.ID)) {\n-                    excludedShapes.add(member.getId());\n-                } else {\n-                    excludedShapes.addAll(model.expectShape(member.getTarget()).accept(this));\n-                }\n-            }\n-            return excludedShapes;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQyNzMxMw==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r509427313", "bodyText": "Nit: these are javadoc comments and need stuff like {@code read} instead of markdown backticks.", "author": "mtdowling", "createdAt": "2020-10-21T16:24:41Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n+import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n+import software.amazon.smithy.model.knowledge.OperationIndex;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeVisitor;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.ToShapeId;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.MapUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+\n+/**\n+ * Index of resources to their CloudFormation identifiers\n+ * and properties.\n+ *\n+ * <p>This index performs no validation that the identifiers\n+ * and reference valid shapes.\n+ */\n+public final class ResourceIndex implements KnowledgeIndex {\n+\n+    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n+            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n+\n+    private final Model model;\n+    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n+    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n+    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n+    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n+\n+    /**\n+     * CloudFormation-specific property mutability options.\n+     */\n+    public enum Mutability {\n+        CREATE,\n+        READ,\n+        WRITE\n+    }\n+\n+    public ResourceIndex(Model model) {\n+        this.model = model;\n+\n+        OperationIndex operationIndex = OperationIndex.of(model);\n+        model.shapes(ResourceShape.class)\n+                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n+                .forEach(pair -> {\n+                    ResourceShape resource = pair.getLeft();\n+                    ShapeId resourceId = resource.getId();\n+\n+                    // Start with the explicit resource identifiers.\n+                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));\n+                    setIdentifierMutabilities(resource);\n+\n+                    // Use the read lifecycle's input to collect the additional identifiers\n+                    // and its output to collect readable properties.\n+                    resource.getRead().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            addAdditionalIdentifiers(resource, computeResourceAdditionalIdentifiers(input));\n+                        });\n+                        operationIndex.getOutput(operationId).ifPresent(output -> {\n+                            updatePropertyMutabilities(resourceId, operationId, output,\n+                                    SetUtils.of(Mutability.READ), this::addReadMutability);\n+                        });\n+                    });\n+\n+                    // Use the put lifecycle's input to collect put-able properties.\n+                    resource.getPut().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            updatePropertyMutabilities(resourceId, operationId, input,\n+                                    SetUtils.of(Mutability.CREATE, Mutability.WRITE), this::addPutMutability);\n+                        });\n+                    });\n+\n+                    // Use the create lifecycle's input to collect creatable properties.\n+                    resource.getCreate().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            updatePropertyMutabilities(resourceId, operationId, input,\n+                                    SetUtils.of(Mutability.CREATE), this::addCreateMutability);\n+                        });\n+                    });\n+\n+                    // Use the update lifecycle's input to collect writeable properties.\n+                    resource.getUpdate().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            updatePropertyMutabilities(resourceId, operationId, input,\n+                                    SetUtils.of(Mutability.WRITE), this::addWriteMutability);\n+                        });\n+                    });\n+\n+                    // Apply any members found through the trait's additionalSchemas property.\n+                    for (ShapeId additionalSchema : pair.getRight().getAdditionalSchemas()) {\n+                        StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);\n+                        updatePropertyMutabilities(resourceId, null, shape,\n+                                SetUtils.of(), Function.identity());\n+                    }\n+                });\n+    }\n+\n+    public static ResourceIndex of(Model model) {\n+        return model.getKnowledge(ResourceIndex.class, ResourceIndex::new);\n+    }\n+\n+    /**\n+     * Get all members of the CloudFormation resource.\n+     *\n+     * @param resource ShapeID of a resource.\n+     * @return Returns all members that map to CloudFormation resource\n+     *   properties.\n+     */\n+    public Map<String, ResourcePropertyDefinition> getProperties(ToShapeId resource) {\n+        return resourcePropertyMutabilities.getOrDefault(resource.toShapeId(), MapUtils.of())\n+                .entrySet().stream()\n+                .filter(entry -> !getExcludedProperties(resource).contains(entry.getValue().getShapeId()))\n+                .collect(MapUtils.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    /**\n+     * Gets the specified member of the CloudFormation resource.\n+     *\n+     * @param resource ShapeID of a resource\n+     * @param propertyName Name of the property to retrieve\n+     * @return The property definition.\n+     */\n+    public Optional<ResourcePropertyDefinition> getProperty(ToShapeId resource, String propertyName) {\n+        return Optional.ofNullable(getProperties(resource).get(propertyName));\n+    }\n+\n+    /**\n+     * Get create-specifiable-only members of the CloudFormation resource.\n+     *\n+     * These properties can be specified only during resource creation and\n+     * can be returned in a `read` or `list` request.\n+     *\n+     * @param resource ShapeID of a resource.\n+     * @return Returns create-only member names that map to CloudFormation resource\n+     *   properties.\n+     */\n+    public Set<String> getCreateOnlyProperties(ToShapeId resource) {\n+        return getConstrainedProperties(resource, definition -> {\n+            Set<Mutability> mutabilities = definition.getMutabilities();\n+            return mutabilities.contains(Mutability.CREATE) && !mutabilities.contains(Mutability.WRITE);\n+        });\n+    }\n+\n+    /**\n+     * Get read-only members of the CloudFormation resource.\n+     *\n+     * These properties can be returned by a `read` or `list` request,", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\ndeleted file mode 100644\nindex a50e1e958..000000000\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\n+++ /dev/null\n\n@@ -1,479 +0,0 @@\n-/*\n- * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.smithy.aws.cloudformation.traits;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import software.amazon.smithy.model.Model;\n-import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n-import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n-import software.amazon.smithy.model.knowledge.OperationIndex;\n-import software.amazon.smithy.model.shapes.MemberShape;\n-import software.amazon.smithy.model.shapes.ResourceShape;\n-import software.amazon.smithy.model.shapes.Shape;\n-import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.model.shapes.ShapeVisitor;\n-import software.amazon.smithy.model.shapes.StructureShape;\n-import software.amazon.smithy.model.shapes.ToShapeId;\n-import software.amazon.smithy.model.traits.Trait;\n-import software.amazon.smithy.utils.ListUtils;\n-import software.amazon.smithy.utils.MapUtils;\n-import software.amazon.smithy.utils.SetUtils;\n-\n-/**\n- * Index of resources to their CloudFormation identifiers\n- * and properties.\n- *\n- * <p>This index performs no validation that the identifiers\n- * and reference valid shapes.\n- */\n-public final class ResourceIndex implements KnowledgeIndex {\n-\n-    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n-            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n-\n-    private final Model model;\n-    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n-    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n-    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n-    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n-\n-    /**\n-     * CloudFormation-specific property mutability options.\n-     */\n-    public enum Mutability {\n-        CREATE,\n-        READ,\n-        WRITE\n-    }\n-\n-    public ResourceIndex(Model model) {\n-        this.model = model;\n-\n-        OperationIndex operationIndex = OperationIndex.of(model);\n-        model.shapes(ResourceShape.class)\n-                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n-                .forEach(pair -> {\n-                    ResourceShape resource = pair.getLeft();\n-                    ShapeId resourceId = resource.getId();\n-\n-                    // Start with the explicit resource identifiers.\n-                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));\n-                    setIdentifierMutabilities(resource);\n-\n-                    // Use the read lifecycle's input to collect the additional identifiers\n-                    // and its output to collect readable properties.\n-                    resource.getRead().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            addAdditionalIdentifiers(resource, computeResourceAdditionalIdentifiers(input));\n-                        });\n-                        operationIndex.getOutput(operationId).ifPresent(output -> {\n-                            updatePropertyMutabilities(resourceId, operationId, output,\n-                                    SetUtils.of(Mutability.READ), this::addReadMutability);\n-                        });\n-                    });\n-\n-                    // Use the put lifecycle's input to collect put-able properties.\n-                    resource.getPut().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE, Mutability.WRITE), this::addPutMutability);\n-                        });\n-                    });\n-\n-                    // Use the create lifecycle's input to collect creatable properties.\n-                    resource.getCreate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE), this::addCreateMutability);\n-                        });\n-                    });\n-\n-                    // Use the update lifecycle's input to collect writeable properties.\n-                    resource.getUpdate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.WRITE), this::addWriteMutability);\n-                        });\n-                    });\n-\n-                    // Apply any members found through the trait's additionalSchemas property.\n-                    for (ShapeId additionalSchema : pair.getRight().getAdditionalSchemas()) {\n-                        StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);\n-                        updatePropertyMutabilities(resourceId, null, shape,\n-                                SetUtils.of(), Function.identity());\n-                    }\n-                });\n-    }\n-\n-    public static ResourceIndex of(Model model) {\n-        return model.getKnowledge(ResourceIndex.class, ResourceIndex::new);\n-    }\n-\n-    /**\n-     * Get all members of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns all members that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Map<String, ResourcePropertyDefinition> getProperties(ToShapeId resource) {\n-        return resourcePropertyMutabilities.getOrDefault(resource.toShapeId(), MapUtils.of())\n-                .entrySet().stream()\n-                .filter(entry -> !getExcludedProperties(resource).contains(entry.getValue().getShapeId()))\n-                .collect(MapUtils.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n-    }\n-\n-    /**\n-     * Gets the specified member of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource\n-     * @param propertyName Name of the property to retrieve\n-     * @return The property definition.\n-     */\n-    public Optional<ResourcePropertyDefinition> getProperty(ToShapeId resource, String propertyName) {\n-        return Optional.ofNullable(getProperties(resource).get(propertyName));\n-    }\n-\n-    /**\n-     * Get create-specifiable-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified only during resource creation and\n-     * can be returned in a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns create-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getCreateOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.contains(Mutability.CREATE) && !mutabilities.contains(Mutability.WRITE);\n-        });\n-    }\n-\n-    /**\n-     * Get read-only members of the CloudFormation resource.\n-     *\n-     * These properties can be returned by a `read` or `list` request,\n-     * but cannot be set by the user.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns read-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getReadOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.size() == 1 && mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    /**\n-     * Get write-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified by the user, but cannot be\n-     * returned by a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns write-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getWriteOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            // Create and non-read properties need to be set as createOnly and writeOnly.\n-            if (mutabilities.size() == 1 && mutabilities.contains(Mutability.CREATE)) {\n-                return true;\n-            }\n-\n-            // Otherwise, create and update, or update only become writeOnly.\n-            return mutabilities.contains(Mutability.WRITE) && !mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    private Set<String> getConstrainedProperties(\n-            ToShapeId resource,\n-            Predicate<ResourcePropertyDefinition> constraint\n-    ) {\n-        return getProperties(resource)\n-                .entrySet()\n-                .stream()\n-                .filter(property -> constraint.test(property.getValue()))\n-                .map(Map.Entry::getKey)\n-                .collect(Collectors.toSet());\n-    }\n-\n-    /**\n-     * Get members that have been explicitly excluded from the CloudFormation\n-     * resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns members that have been excluded from a CloudFormation\n-     *   resource.\n-     */\n-    public Set<ShapeId> getExcludedProperties(ToShapeId resource) {\n-        return resourceExcludedProperties.getOrDefault(resource.toShapeId(), SetUtils.of());\n-    }\n-\n-    /**\n-     * Gets a set of member shape ids that represent the primary way\n-     * to identify a CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns the identifier set primarily used to access a\n-     *   CloudFormation resource.\n-     */\n-    public Set<String> getPrimaryIdentifiers(ToShapeId resource) {\n-        return resourcePrimaryIdentifiers.get(resource.toShapeId());\n-    }\n-\n-    /**\n-     * Get a list of sets of member shape ids, each set can be used to identify\n-     * the CloudFormation resource in addition to its primary identifier(s).\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns identifier sets used to access a CloudFormation resource.\n-     */\n-    public List<Set<String>> getAdditionalIdentifiers(ToShapeId resource) {\n-        return resourceAdditionalIdentifiers.getOrDefault(resource.toShapeId(), ListUtils.of());\n-    }\n-\n-    private void setIdentifierMutabilities(ResourceShape resource) {\n-        Set<Mutability> mutability = getDefaultIdentifierMutabilities(resource);\n-\n-        ShapeId resourceId = resource.getId();\n-\n-        resource.getIdentifiers().forEach((name, shape) -> {\n-            setResourceProperty(resourceId, name, ResourcePropertyDefinition.builder()\n-                    .hasExplicitMutability(true)\n-                    .mutabilities(mutability)\n-                    .shapeId(shape)\n-                    .build());\n-        });\n-    }\n-\n-    private void setResourceProperty(ShapeId resourceId, String name, ResourcePropertyDefinition property) {\n-        Map<String, ResourcePropertyDefinition> resourceProperties =\n-                resourcePropertyMutabilities.getOrDefault(resourceId, new HashMap<>());\n-        resourceProperties.put(name, property);\n-        resourcePropertyMutabilities.put(resourceId, resourceProperties);\n-    }\n-\n-    private Set<Mutability> getDefaultIdentifierMutabilities(ResourceShape resource) {\n-        // If we have a put operation, the identifier will be specified\n-        // on creation. Otherwise, it's read only.\n-        if (resource.getPut().isPresent()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        }\n-\n-        return SetUtils.of(Mutability.READ);\n-    }\n-\n-    private List<Map<String, ShapeId>> computeResourceAdditionalIdentifiers(StructureShape readInput) {\n-        List<Map<String, ShapeId>> identifiers = new ArrayList<>();\n-        for (MemberShape member : readInput.members()) {\n-            if (!member.hasTrait(AdditionalIdentifierTrait.class)) {\n-                continue;\n-            }\n-\n-            identifiers.add(MapUtils.of(member.getMemberName(), member.getId()));\n-        }\n-        return identifiers;\n-    }\n-\n-    private void addAdditionalIdentifiers(ResourceShape resource, List<Map<String, ShapeId>> addedIdentifiers) {\n-        if (addedIdentifiers.isEmpty()) {\n-            return;\n-        }\n-        ShapeId resourceId = resource.getId();\n-\n-        List<Set<String>> newIdentifierNames = new ArrayList<>();\n-        // Make sure we have properties entries for the additional identifiers.\n-        for (Map<String, ShapeId> addedIdentifier : addedIdentifiers) {\n-            for (Map.Entry<String, ShapeId> idEntry : addedIdentifier.entrySet()) {\n-                setResourceProperty(resourceId, idEntry.getKey(), ResourcePropertyDefinition.builder()\n-                        .mutabilities(SetUtils.of(Mutability.READ))\n-                        .shapeId(idEntry.getValue())\n-                        .build());\n-            }\n-            newIdentifierNames.add(addedIdentifier.keySet());\n-        }\n-\n-        List<Set<String>> currentIdentifiers =\n-                resourceAdditionalIdentifiers.getOrDefault(resourceId, new ArrayList<>());\n-        currentIdentifiers.addAll(newIdentifierNames);\n-        resourceAdditionalIdentifiers.put(resourceId, currentIdentifiers);\n-    }\n-\n-    private void updatePropertyMutabilities(\n-            ShapeId resourceId,\n-            ShapeId operationId,\n-            StructureShape propertyContainer,\n-            Set<Mutability> defaultMutabilities,\n-            Function<Set<Mutability>, Set<Mutability>> updater\n-    ) {\n-        addExcludedProperties(resourceId, propertyContainer);\n-\n-        for (MemberShape member : propertyContainer.members()) {\n-            // We've explicitly set identifier mutability based on how the\n-            // resource instance comes about, so only handle non-identifiers.\n-            if (operationMemberIsIdentifier(resourceId, operationId, member)) {\n-                continue;\n-            }\n-\n-            String memberName = member.getMemberName();\n-            ResourcePropertyDefinition memberProperty = getProperties(resourceId).get(memberName);\n-            Set<Mutability> explicitMutability = getExplicitMutability(member, memberProperty);\n-\n-            if (memberProperty != null) {\n-                // Validate that members with the same name target the same shape.\n-                model.getShape(memberProperty.getShapeId())\n-                        .flatMap(Shape::asMemberShape)\n-                        .filter(shape -> !member.getTarget().equals(shape.getTarget()))\n-                        .ifPresent(shape -> {\n-                            throw new RuntimeException(String.format(\"The derived CloudFormation resource \"\n-                                    + \"property for %s is composed of members that target different shapes: %s and %s\",\n-                                    memberName, member.getTarget(), shape.getTarget()));\n-                        });\n-\n-                // Apply updates to the mutability of the property.\n-                if (!memberProperty.hasExplicitMutability()) {\n-                    memberProperty = memberProperty.toBuilder()\n-                            .mutabilities(updater.apply(memberProperty.getMutabilities()))\n-                            .build();\n-                }\n-            } else {\n-                // Set the correct mutability for this new property.\n-                Set<Mutability> mutabilities = !explicitMutability.isEmpty()\n-                        ? explicitMutability\n-                        : defaultMutabilities;\n-                memberProperty = ResourcePropertyDefinition.builder()\n-                        .shapeId(member.getId())\n-                        .mutabilities(mutabilities)\n-                        .hasExplicitMutability(!explicitMutability.isEmpty())\n-                        .build();\n-            }\n-\n-            setResourceProperty(resourceId, memberName, memberProperty);\n-        }\n-    }\n-\n-    private void addExcludedProperties(ShapeId resourceId, StructureShape propertyContainer) {\n-        Set<ShapeId> currentExcludedProperties =\n-                resourceExcludedProperties.getOrDefault(resourceId, new HashSet<>());\n-        currentExcludedProperties.addAll(propertyContainer.accept(new ExcludedPropertiesVisitor()));\n-        resourceExcludedProperties.put(resourceId, currentExcludedProperties);\n-    }\n-\n-    private boolean operationMemberIsIdentifier(ShapeId resourceId, ShapeId operationId, MemberShape member) {\n-        // The operationId will be null in the case of additionalSchemas, so\n-        // we shouldn't worry if these are bound to operation identifiers.\n-        if (operationId == null) {\n-            return false;\n-        }\n-\n-        IdentifierBindingIndex index = IdentifierBindingIndex.of(model);\n-        Map<String, String> bindings = index.getOperationBindings(resourceId, operationId);\n-        String memberName = member.getMemberName();\n-        // Check for literal identifier bindings.\n-        for (String bindingMemberName : bindings.values()) {\n-            if (memberName.equals(bindingMemberName)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private Set<Mutability> getExplicitMutability(\n-            MemberShape member,\n-            ResourcePropertyDefinition memberProperty\n-    ) {\n-        if (memberProperty != null && memberProperty.hasExplicitMutability()) {\n-            return memberProperty.getMutabilities();\n-        }\n-\n-        Optional<MutabilityTrait> traitOptional = member.getMemberTrait(model, MutabilityTrait.class);\n-        if (!traitOptional.isPresent()) {\n-            return SetUtils.of();\n-        }\n-\n-        MutabilityTrait trait = traitOptional.get();\n-        if (trait.isFullyMutable()) {\n-            return FULLY_MUTABLE;\n-        } else if (trait.isCreateAndRead()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        } else if (trait.isCreate()) {\n-            return SetUtils.of(Mutability.CREATE);\n-        } else if (trait.isRead()) {\n-            return SetUtils.of(Mutability.READ);\n-        } else if (trait.isWrite()) {\n-            return SetUtils.of(Mutability.WRITE);\n-        }\n-        return SetUtils.of();\n-    }\n-\n-    private Set<Mutability> addReadMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.READ);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addCreateMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.CREATE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addWriteMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.WRITE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addPutMutability(Set<Mutability> mutabilities) {\n-        return addWriteMutability(addCreateMutability(mutabilities));\n-    }\n-\n-    private final class ExcludedPropertiesVisitor extends ShapeVisitor.Default<Set<ShapeId>> {\n-        @Override\n-        protected Set<ShapeId> getDefault(Shape shape) {\n-            return SetUtils.of();\n-        }\n-\n-        @Override\n-        public Set<ShapeId> structureShape(StructureShape shape) {\n-            Set<ShapeId> excludedShapes = new HashSet<>();\n-            for (MemberShape member : shape.members()) {\n-                if (member.hasTrait(ExcludePropertyTrait.ID)) {\n-                    excludedShapes.add(member.getId());\n-                } else {\n-                    excludedShapes.addAll(model.expectShape(member.getTarget()).accept(this));\n-                }\n-            }\n-            return excludedShapes;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQyODMyMw==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r509428323", "bodyText": "I wonder if a lot of these methods can be moved to something like a CfResource type instead of kept on the index? That type would contain mutability, properties, exclusions, etc... Seems like that would greatly reduce the size of this index and give the definition more purpose IMO.", "author": "mtdowling", "createdAt": "2020-10-21T16:26:06Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n+import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n+import software.amazon.smithy.model.knowledge.OperationIndex;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.ResourceShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.ShapeVisitor;\n+import software.amazon.smithy.model.shapes.StructureShape;\n+import software.amazon.smithy.model.shapes.ToShapeId;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.MapUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+\n+/**\n+ * Index of resources to their CloudFormation identifiers\n+ * and properties.\n+ *\n+ * <p>This index performs no validation that the identifiers\n+ * and reference valid shapes.\n+ */\n+public final class ResourceIndex implements KnowledgeIndex {\n+\n+    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n+            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n+\n+    private final Model model;\n+    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n+    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n+    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n+    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n+\n+    /**\n+     * CloudFormation-specific property mutability options.\n+     */\n+    public enum Mutability {\n+        CREATE,\n+        READ,\n+        WRITE\n+    }\n+\n+    public ResourceIndex(Model model) {\n+        this.model = model;\n+\n+        OperationIndex operationIndex = OperationIndex.of(model);\n+        model.shapes(ResourceShape.class)\n+                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n+                .forEach(pair -> {\n+                    ResourceShape resource = pair.getLeft();\n+                    ShapeId resourceId = resource.getId();\n+\n+                    // Start with the explicit resource identifiers.\n+                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));\n+                    setIdentifierMutabilities(resource);\n+\n+                    // Use the read lifecycle's input to collect the additional identifiers\n+                    // and its output to collect readable properties.\n+                    resource.getRead().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            addAdditionalIdentifiers(resource, computeResourceAdditionalIdentifiers(input));\n+                        });\n+                        operationIndex.getOutput(operationId).ifPresent(output -> {\n+                            updatePropertyMutabilities(resourceId, operationId, output,\n+                                    SetUtils.of(Mutability.READ), this::addReadMutability);\n+                        });\n+                    });\n+\n+                    // Use the put lifecycle's input to collect put-able properties.\n+                    resource.getPut().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            updatePropertyMutabilities(resourceId, operationId, input,\n+                                    SetUtils.of(Mutability.CREATE, Mutability.WRITE), this::addPutMutability);\n+                        });\n+                    });\n+\n+                    // Use the create lifecycle's input to collect creatable properties.\n+                    resource.getCreate().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            updatePropertyMutabilities(resourceId, operationId, input,\n+                                    SetUtils.of(Mutability.CREATE), this::addCreateMutability);\n+                        });\n+                    });\n+\n+                    // Use the update lifecycle's input to collect writeable properties.\n+                    resource.getUpdate().ifPresent(operationId -> {\n+                        operationIndex.getInput(operationId).ifPresent(input -> {\n+                            updatePropertyMutabilities(resourceId, operationId, input,\n+                                    SetUtils.of(Mutability.WRITE), this::addWriteMutability);\n+                        });\n+                    });\n+\n+                    // Apply any members found through the trait's additionalSchemas property.\n+                    for (ShapeId additionalSchema : pair.getRight().getAdditionalSchemas()) {\n+                        StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);\n+                        updatePropertyMutabilities(resourceId, null, shape,\n+                                SetUtils.of(), Function.identity());\n+                    }\n+                });\n+    }\n+\n+    public static ResourceIndex of(Model model) {\n+        return model.getKnowledge(ResourceIndex.class, ResourceIndex::new);\n+    }\n+\n+    /**\n+     * Get all members of the CloudFormation resource.\n+     *\n+     * @param resource ShapeID of a resource.\n+     * @return Returns all members that map to CloudFormation resource\n+     *   properties.\n+     */\n+    public Map<String, ResourcePropertyDefinition> getProperties(ToShapeId resource) {\n+        return resourcePropertyMutabilities.getOrDefault(resource.toShapeId(), MapUtils.of())\n+                .entrySet().stream()\n+                .filter(entry -> !getExcludedProperties(resource).contains(entry.getValue().getShapeId()))\n+                .collect(MapUtils.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    /**\n+     * Gets the specified member of the CloudFormation resource.\n+     *\n+     * @param resource ShapeID of a resource\n+     * @param propertyName Name of the property to retrieve\n+     * @return The property definition.\n+     */\n+    public Optional<ResourcePropertyDefinition> getProperty(ToShapeId resource, String propertyName) {\n+        return Optional.ofNullable(getProperties(resource).get(propertyName));\n+    }\n+\n+    /**\n+     * Get create-specifiable-only members of the CloudFormation resource.\n+     *\n+     * These properties can be specified only during resource creation and\n+     * can be returned in a `read` or `list` request.\n+     *\n+     * @param resource ShapeID of a resource.\n+     * @return Returns create-only member names that map to CloudFormation resource\n+     *   properties.\n+     */\n+    public Set<String> getCreateOnlyProperties(ToShapeId resource) {\n+        return getConstrainedProperties(resource, definition -> {\n+            Set<Mutability> mutabilities = definition.getMutabilities();\n+            return mutabilities.contains(Mutability.CREATE) && !mutabilities.contains(Mutability.WRITE);\n+        });\n+    }\n+\n+    /**\n+     * Get read-only members of the CloudFormation resource.\n+     *\n+     * These properties can be returned by a `read` or `list` request,\n+     * but cannot be set by the user.\n+     *\n+     * @param resource ShapeID of a resource.\n+     * @return Returns read-only member names that map to CloudFormation resource\n+     *   properties.\n+     */\n+    public Set<String> getReadOnlyProperties(ToShapeId resource) {\n+        return getConstrainedProperties(resource, definition -> {\n+            Set<Mutability> mutabilities = definition.getMutabilities();\n+            return mutabilities.size() == 1 && mutabilities.contains(Mutability.READ);\n+        });\n+    }\n+\n+    /**\n+     * Get write-only members of the CloudFormation resource.\n+     *\n+     * These properties can be specified by the user, but cannot be\n+     * returned by a `read` or `list` request.\n+     *\n+     * @param resource ShapeID of a resource.\n+     * @return Returns write-only member names that map to CloudFormation resource\n+     *   properties.\n+     */\n+    public Set<String> getWriteOnlyProperties(ToShapeId resource) {", "originalCommit": "ba0156755e01e2b53becf2539f4624825a95b2b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1MDM4Ng==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r513550386", "bodyText": "This functionality was broken out to the CfnResource data class. Other related components were also moved to Cfn prefixed class names.", "author": "kstich", "createdAt": "2020-10-28T15:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQyODMyMw=="}], "type": "inlineReview", "revised_code": {"commit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\ndeleted file mode 100644\nindex a50e1e958..000000000\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/ResourceIndex.java\n+++ /dev/null\n\n@@ -1,479 +0,0 @@\n-/*\n- * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.smithy.aws.cloudformation.traits;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import software.amazon.smithy.model.Model;\n-import software.amazon.smithy.model.knowledge.IdentifierBindingIndex;\n-import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n-import software.amazon.smithy.model.knowledge.OperationIndex;\n-import software.amazon.smithy.model.shapes.MemberShape;\n-import software.amazon.smithy.model.shapes.ResourceShape;\n-import software.amazon.smithy.model.shapes.Shape;\n-import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.model.shapes.ShapeVisitor;\n-import software.amazon.smithy.model.shapes.StructureShape;\n-import software.amazon.smithy.model.shapes.ToShapeId;\n-import software.amazon.smithy.model.traits.Trait;\n-import software.amazon.smithy.utils.ListUtils;\n-import software.amazon.smithy.utils.MapUtils;\n-import software.amazon.smithy.utils.SetUtils;\n-\n-/**\n- * Index of resources to their CloudFormation identifiers\n- * and properties.\n- *\n- * <p>This index performs no validation that the identifiers\n- * and reference valid shapes.\n- */\n-public final class ResourceIndex implements KnowledgeIndex {\n-\n-    static final Set<Mutability> FULLY_MUTABLE = SetUtils.of(\n-            Mutability.CREATE, Mutability.READ, Mutability.WRITE);\n-\n-    private final Model model;\n-    private final Map<ShapeId, Map<String, ResourcePropertyDefinition>> resourcePropertyMutabilities = new HashMap<>();\n-    private final Map<ShapeId, Set<ShapeId>> resourceExcludedProperties = new HashMap<>();\n-    private final Map<ShapeId, Set<String>> resourcePrimaryIdentifiers = new HashMap<>();\n-    private final Map<ShapeId, List<Set<String>>> resourceAdditionalIdentifiers = new HashMap<>();\n-\n-    /**\n-     * CloudFormation-specific property mutability options.\n-     */\n-    public enum Mutability {\n-        CREATE,\n-        READ,\n-        WRITE\n-    }\n-\n-    public ResourceIndex(Model model) {\n-        this.model = model;\n-\n-        OperationIndex operationIndex = OperationIndex.of(model);\n-        model.shapes(ResourceShape.class)\n-                .flatMap(shape -> Trait.flatMapStream(shape, ResourceTrait.class))\n-                .forEach(pair -> {\n-                    ResourceShape resource = pair.getLeft();\n-                    ShapeId resourceId = resource.getId();\n-\n-                    // Start with the explicit resource identifiers.\n-                    resourcePrimaryIdentifiers.put(resourceId, SetUtils.copyOf(resource.getIdentifiers().keySet()));\n-                    setIdentifierMutabilities(resource);\n-\n-                    // Use the read lifecycle's input to collect the additional identifiers\n-                    // and its output to collect readable properties.\n-                    resource.getRead().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            addAdditionalIdentifiers(resource, computeResourceAdditionalIdentifiers(input));\n-                        });\n-                        operationIndex.getOutput(operationId).ifPresent(output -> {\n-                            updatePropertyMutabilities(resourceId, operationId, output,\n-                                    SetUtils.of(Mutability.READ), this::addReadMutability);\n-                        });\n-                    });\n-\n-                    // Use the put lifecycle's input to collect put-able properties.\n-                    resource.getPut().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE, Mutability.WRITE), this::addPutMutability);\n-                        });\n-                    });\n-\n-                    // Use the create lifecycle's input to collect creatable properties.\n-                    resource.getCreate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.CREATE), this::addCreateMutability);\n-                        });\n-                    });\n-\n-                    // Use the update lifecycle's input to collect writeable properties.\n-                    resource.getUpdate().ifPresent(operationId -> {\n-                        operationIndex.getInput(operationId).ifPresent(input -> {\n-                            updatePropertyMutabilities(resourceId, operationId, input,\n-                                    SetUtils.of(Mutability.WRITE), this::addWriteMutability);\n-                        });\n-                    });\n-\n-                    // Apply any members found through the trait's additionalSchemas property.\n-                    for (ShapeId additionalSchema : pair.getRight().getAdditionalSchemas()) {\n-                        StructureShape shape = model.expectShape(additionalSchema, StructureShape.class);\n-                        updatePropertyMutabilities(resourceId, null, shape,\n-                                SetUtils.of(), Function.identity());\n-                    }\n-                });\n-    }\n-\n-    public static ResourceIndex of(Model model) {\n-        return model.getKnowledge(ResourceIndex.class, ResourceIndex::new);\n-    }\n-\n-    /**\n-     * Get all members of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns all members that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Map<String, ResourcePropertyDefinition> getProperties(ToShapeId resource) {\n-        return resourcePropertyMutabilities.getOrDefault(resource.toShapeId(), MapUtils.of())\n-                .entrySet().stream()\n-                .filter(entry -> !getExcludedProperties(resource).contains(entry.getValue().getShapeId()))\n-                .collect(MapUtils.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n-    }\n-\n-    /**\n-     * Gets the specified member of the CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource\n-     * @param propertyName Name of the property to retrieve\n-     * @return The property definition.\n-     */\n-    public Optional<ResourcePropertyDefinition> getProperty(ToShapeId resource, String propertyName) {\n-        return Optional.ofNullable(getProperties(resource).get(propertyName));\n-    }\n-\n-    /**\n-     * Get create-specifiable-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified only during resource creation and\n-     * can be returned in a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns create-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getCreateOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.contains(Mutability.CREATE) && !mutabilities.contains(Mutability.WRITE);\n-        });\n-    }\n-\n-    /**\n-     * Get read-only members of the CloudFormation resource.\n-     *\n-     * These properties can be returned by a `read` or `list` request,\n-     * but cannot be set by the user.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns read-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getReadOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            return mutabilities.size() == 1 && mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    /**\n-     * Get write-only members of the CloudFormation resource.\n-     *\n-     * These properties can be specified by the user, but cannot be\n-     * returned by a `read` or `list` request.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns write-only member names that map to CloudFormation resource\n-     *   properties.\n-     */\n-    public Set<String> getWriteOnlyProperties(ToShapeId resource) {\n-        return getConstrainedProperties(resource, definition -> {\n-            Set<Mutability> mutabilities = definition.getMutabilities();\n-            // Create and non-read properties need to be set as createOnly and writeOnly.\n-            if (mutabilities.size() == 1 && mutabilities.contains(Mutability.CREATE)) {\n-                return true;\n-            }\n-\n-            // Otherwise, create and update, or update only become writeOnly.\n-            return mutabilities.contains(Mutability.WRITE) && !mutabilities.contains(Mutability.READ);\n-        });\n-    }\n-\n-    private Set<String> getConstrainedProperties(\n-            ToShapeId resource,\n-            Predicate<ResourcePropertyDefinition> constraint\n-    ) {\n-        return getProperties(resource)\n-                .entrySet()\n-                .stream()\n-                .filter(property -> constraint.test(property.getValue()))\n-                .map(Map.Entry::getKey)\n-                .collect(Collectors.toSet());\n-    }\n-\n-    /**\n-     * Get members that have been explicitly excluded from the CloudFormation\n-     * resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns members that have been excluded from a CloudFormation\n-     *   resource.\n-     */\n-    public Set<ShapeId> getExcludedProperties(ToShapeId resource) {\n-        return resourceExcludedProperties.getOrDefault(resource.toShapeId(), SetUtils.of());\n-    }\n-\n-    /**\n-     * Gets a set of member shape ids that represent the primary way\n-     * to identify a CloudFormation resource.\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns the identifier set primarily used to access a\n-     *   CloudFormation resource.\n-     */\n-    public Set<String> getPrimaryIdentifiers(ToShapeId resource) {\n-        return resourcePrimaryIdentifiers.get(resource.toShapeId());\n-    }\n-\n-    /**\n-     * Get a list of sets of member shape ids, each set can be used to identify\n-     * the CloudFormation resource in addition to its primary identifier(s).\n-     *\n-     * @param resource ShapeID of a resource.\n-     * @return Returns identifier sets used to access a CloudFormation resource.\n-     */\n-    public List<Set<String>> getAdditionalIdentifiers(ToShapeId resource) {\n-        return resourceAdditionalIdentifiers.getOrDefault(resource.toShapeId(), ListUtils.of());\n-    }\n-\n-    private void setIdentifierMutabilities(ResourceShape resource) {\n-        Set<Mutability> mutability = getDefaultIdentifierMutabilities(resource);\n-\n-        ShapeId resourceId = resource.getId();\n-\n-        resource.getIdentifiers().forEach((name, shape) -> {\n-            setResourceProperty(resourceId, name, ResourcePropertyDefinition.builder()\n-                    .hasExplicitMutability(true)\n-                    .mutabilities(mutability)\n-                    .shapeId(shape)\n-                    .build());\n-        });\n-    }\n-\n-    private void setResourceProperty(ShapeId resourceId, String name, ResourcePropertyDefinition property) {\n-        Map<String, ResourcePropertyDefinition> resourceProperties =\n-                resourcePropertyMutabilities.getOrDefault(resourceId, new HashMap<>());\n-        resourceProperties.put(name, property);\n-        resourcePropertyMutabilities.put(resourceId, resourceProperties);\n-    }\n-\n-    private Set<Mutability> getDefaultIdentifierMutabilities(ResourceShape resource) {\n-        // If we have a put operation, the identifier will be specified\n-        // on creation. Otherwise, it's read only.\n-        if (resource.getPut().isPresent()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        }\n-\n-        return SetUtils.of(Mutability.READ);\n-    }\n-\n-    private List<Map<String, ShapeId>> computeResourceAdditionalIdentifiers(StructureShape readInput) {\n-        List<Map<String, ShapeId>> identifiers = new ArrayList<>();\n-        for (MemberShape member : readInput.members()) {\n-            if (!member.hasTrait(AdditionalIdentifierTrait.class)) {\n-                continue;\n-            }\n-\n-            identifiers.add(MapUtils.of(member.getMemberName(), member.getId()));\n-        }\n-        return identifiers;\n-    }\n-\n-    private void addAdditionalIdentifiers(ResourceShape resource, List<Map<String, ShapeId>> addedIdentifiers) {\n-        if (addedIdentifiers.isEmpty()) {\n-            return;\n-        }\n-        ShapeId resourceId = resource.getId();\n-\n-        List<Set<String>> newIdentifierNames = new ArrayList<>();\n-        // Make sure we have properties entries for the additional identifiers.\n-        for (Map<String, ShapeId> addedIdentifier : addedIdentifiers) {\n-            for (Map.Entry<String, ShapeId> idEntry : addedIdentifier.entrySet()) {\n-                setResourceProperty(resourceId, idEntry.getKey(), ResourcePropertyDefinition.builder()\n-                        .mutabilities(SetUtils.of(Mutability.READ))\n-                        .shapeId(idEntry.getValue())\n-                        .build());\n-            }\n-            newIdentifierNames.add(addedIdentifier.keySet());\n-        }\n-\n-        List<Set<String>> currentIdentifiers =\n-                resourceAdditionalIdentifiers.getOrDefault(resourceId, new ArrayList<>());\n-        currentIdentifiers.addAll(newIdentifierNames);\n-        resourceAdditionalIdentifiers.put(resourceId, currentIdentifiers);\n-    }\n-\n-    private void updatePropertyMutabilities(\n-            ShapeId resourceId,\n-            ShapeId operationId,\n-            StructureShape propertyContainer,\n-            Set<Mutability> defaultMutabilities,\n-            Function<Set<Mutability>, Set<Mutability>> updater\n-    ) {\n-        addExcludedProperties(resourceId, propertyContainer);\n-\n-        for (MemberShape member : propertyContainer.members()) {\n-            // We've explicitly set identifier mutability based on how the\n-            // resource instance comes about, so only handle non-identifiers.\n-            if (operationMemberIsIdentifier(resourceId, operationId, member)) {\n-                continue;\n-            }\n-\n-            String memberName = member.getMemberName();\n-            ResourcePropertyDefinition memberProperty = getProperties(resourceId).get(memberName);\n-            Set<Mutability> explicitMutability = getExplicitMutability(member, memberProperty);\n-\n-            if (memberProperty != null) {\n-                // Validate that members with the same name target the same shape.\n-                model.getShape(memberProperty.getShapeId())\n-                        .flatMap(Shape::asMemberShape)\n-                        .filter(shape -> !member.getTarget().equals(shape.getTarget()))\n-                        .ifPresent(shape -> {\n-                            throw new RuntimeException(String.format(\"The derived CloudFormation resource \"\n-                                    + \"property for %s is composed of members that target different shapes: %s and %s\",\n-                                    memberName, member.getTarget(), shape.getTarget()));\n-                        });\n-\n-                // Apply updates to the mutability of the property.\n-                if (!memberProperty.hasExplicitMutability()) {\n-                    memberProperty = memberProperty.toBuilder()\n-                            .mutabilities(updater.apply(memberProperty.getMutabilities()))\n-                            .build();\n-                }\n-            } else {\n-                // Set the correct mutability for this new property.\n-                Set<Mutability> mutabilities = !explicitMutability.isEmpty()\n-                        ? explicitMutability\n-                        : defaultMutabilities;\n-                memberProperty = ResourcePropertyDefinition.builder()\n-                        .shapeId(member.getId())\n-                        .mutabilities(mutabilities)\n-                        .hasExplicitMutability(!explicitMutability.isEmpty())\n-                        .build();\n-            }\n-\n-            setResourceProperty(resourceId, memberName, memberProperty);\n-        }\n-    }\n-\n-    private void addExcludedProperties(ShapeId resourceId, StructureShape propertyContainer) {\n-        Set<ShapeId> currentExcludedProperties =\n-                resourceExcludedProperties.getOrDefault(resourceId, new HashSet<>());\n-        currentExcludedProperties.addAll(propertyContainer.accept(new ExcludedPropertiesVisitor()));\n-        resourceExcludedProperties.put(resourceId, currentExcludedProperties);\n-    }\n-\n-    private boolean operationMemberIsIdentifier(ShapeId resourceId, ShapeId operationId, MemberShape member) {\n-        // The operationId will be null in the case of additionalSchemas, so\n-        // we shouldn't worry if these are bound to operation identifiers.\n-        if (operationId == null) {\n-            return false;\n-        }\n-\n-        IdentifierBindingIndex index = IdentifierBindingIndex.of(model);\n-        Map<String, String> bindings = index.getOperationBindings(resourceId, operationId);\n-        String memberName = member.getMemberName();\n-        // Check for literal identifier bindings.\n-        for (String bindingMemberName : bindings.values()) {\n-            if (memberName.equals(bindingMemberName)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private Set<Mutability> getExplicitMutability(\n-            MemberShape member,\n-            ResourcePropertyDefinition memberProperty\n-    ) {\n-        if (memberProperty != null && memberProperty.hasExplicitMutability()) {\n-            return memberProperty.getMutabilities();\n-        }\n-\n-        Optional<MutabilityTrait> traitOptional = member.getMemberTrait(model, MutabilityTrait.class);\n-        if (!traitOptional.isPresent()) {\n-            return SetUtils.of();\n-        }\n-\n-        MutabilityTrait trait = traitOptional.get();\n-        if (trait.isFullyMutable()) {\n-            return FULLY_MUTABLE;\n-        } else if (trait.isCreateAndRead()) {\n-            return SetUtils.of(Mutability.CREATE, Mutability.READ);\n-        } else if (trait.isCreate()) {\n-            return SetUtils.of(Mutability.CREATE);\n-        } else if (trait.isRead()) {\n-            return SetUtils.of(Mutability.READ);\n-        } else if (trait.isWrite()) {\n-            return SetUtils.of(Mutability.WRITE);\n-        }\n-        return SetUtils.of();\n-    }\n-\n-    private Set<Mutability> addReadMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.READ);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addCreateMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.CREATE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addWriteMutability(Set<Mutability> mutabilities) {\n-        Set<Mutability> newMutabilities = new HashSet<>(mutabilities);\n-        newMutabilities.add(Mutability.WRITE);\n-        return SetUtils.copyOf(newMutabilities);\n-    }\n-\n-    private Set<Mutability> addPutMutability(Set<Mutability> mutabilities) {\n-        return addWriteMutability(addCreateMutability(mutabilities));\n-    }\n-\n-    private final class ExcludedPropertiesVisitor extends ShapeVisitor.Default<Set<ShapeId>> {\n-        @Override\n-        protected Set<ShapeId> getDefault(Shape shape) {\n-            return SetUtils.of();\n-        }\n-\n-        @Override\n-        public Set<ShapeId> structureShape(StructureShape shape) {\n-            Set<ShapeId> excludedShapes = new HashSet<>();\n-            for (MemberShape member : shape.members()) {\n-                if (member.hasTrait(ExcludePropertyTrait.ID)) {\n-                    excludedShapes.add(member.getId());\n-                } else {\n-                    excludedShapes.addAll(model.expectShape(member.getTarget()).accept(this));\n-                }\n-            }\n-            return excludedShapes;\n-        }\n-    }\n-}\n"}}, {"oid": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "url": "https://github.com/awslabs/smithy/commit/7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "message": "Add aws.cloudformation traits\n\nThis commit adds several traits in the aws.cloudformation namespace,\ncontained in a new smithy-aws-cloudformation-traits package. These\ntraits indicate CloudFormation resources and the additional metadata\nabout their properties. A CfnResourceIndex is also included to make using\nthis information more accessible and to handle derived property\nmutabilities.", "committedDate": "2020-10-28T04:23:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5NjE2OA==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r514596168", "bodyText": "This includes excluded properties? Might need to call that out.", "author": "mtdowling", "createdAt": "2020-10-29T22:08:43Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.utils.MapUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.ToSmithyBuilder;\n+\n+/**\n+ * Contains extracted resource information.\n+ */\n+public final class CfnResource implements ToSmithyBuilder<CfnResource> {\n+    private final Map<String, CfnResourceProperty> propertyDefinitions = new HashMap<>();\n+    private final Set<ShapeId> excludedProperties = new HashSet<>();\n+    private final Set<String> primaryIdentifiers = new HashSet<>();\n+    private final List<Set<String>> additionalIdentifiers = new ArrayList<>();\n+\n+    private CfnResource(Builder builder) {\n+        this.propertyDefinitions.putAll(builder.propertyDefinitions);\n+        this.excludedProperties.addAll(builder.excludedProperties);\n+        this.primaryIdentifiers.addAll(builder.primaryIdentifiers);\n+        this.additionalIdentifiers.addAll(builder.additionalIdentifiers);\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Get all property definitions of the CloudFormation resource.\n+     *\n+     * @return Returns all members that map to CloudFormation resource\n+     *   properties.\n+     */\n+    public Map<String, CfnResourceProperty> getProperties() {\n+        return propertyDefinitions.entrySet().stream()\n+                .filter(entry -> !getExcludedProperties().contains(entry.getValue().getShapeId()))\n+                .collect(MapUtils.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    /**\n+     * Gets the definition of the specified property of the CloudFormation resource.", "originalCommit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff3402b4090b37d7aafb3711356cf1982cd220ab", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java\nindex 8859e3e1c..2735067e3 100644\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java\n+++ b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java\n\n@@ -26,7 +26,6 @@ import java.util.function.Function;\n import java.util.function.Predicate;\n import java.util.stream.Collectors;\n import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.utils.MapUtils;\n import software.amazon.smithy.utils.SmithyBuilder;\n import software.amazon.smithy.utils.ToSmithyBuilder;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5Njg3OA==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r514596878", "bodyText": "Can this just be computed up front? It gets called a lot, and it might make the implementation clearer IMO.", "author": "mtdowling", "createdAt": "2020-10-29T22:10:23Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.utils.MapUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.ToSmithyBuilder;\n+\n+/**\n+ * Contains extracted resource information.\n+ */\n+public final class CfnResource implements ToSmithyBuilder<CfnResource> {\n+    private final Map<String, CfnResourceProperty> propertyDefinitions = new HashMap<>();\n+    private final Set<ShapeId> excludedProperties = new HashSet<>();\n+    private final Set<String> primaryIdentifiers = new HashSet<>();\n+    private final List<Set<String>> additionalIdentifiers = new ArrayList<>();\n+\n+    private CfnResource(Builder builder) {\n+        this.propertyDefinitions.putAll(builder.propertyDefinitions);\n+        this.excludedProperties.addAll(builder.excludedProperties);\n+        this.primaryIdentifiers.addAll(builder.primaryIdentifiers);\n+        this.additionalIdentifiers.addAll(builder.additionalIdentifiers);\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Get all property definitions of the CloudFormation resource.\n+     *\n+     * @return Returns all members that map to CloudFormation resource\n+     *   properties.\n+     */\n+    public Map<String, CfnResourceProperty> getProperties() {\n+        return propertyDefinitions.entrySet().stream()", "originalCommit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff3402b4090b37d7aafb3711356cf1982cd220ab", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java\nindex 8859e3e1c..2735067e3 100644\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java\n+++ b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java\n\n@@ -26,7 +26,6 @@ import java.util.function.Function;\n import java.util.function.Predicate;\n import java.util.stream.Collectors;\n import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.utils.MapUtils;\n import software.amazon.smithy.utils.SmithyBuilder;\n import software.amazon.smithy.utils.ToSmithyBuilder;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5NzA1MQ==", "url": "https://github.com/awslabs/smithy/pull/579#discussion_r514597051", "bodyText": "Can you clarify in code what \"primary\" means?", "author": "mtdowling", "createdAt": "2020-10-29T22:10:51Z", "path": "smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.aws.cloudformation.traits;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.utils.MapUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.ToSmithyBuilder;\n+\n+/**\n+ * Contains extracted resource information.\n+ */\n+public final class CfnResource implements ToSmithyBuilder<CfnResource> {\n+    private final Map<String, CfnResourceProperty> propertyDefinitions = new HashMap<>();\n+    private final Set<ShapeId> excludedProperties = new HashSet<>();\n+    private final Set<String> primaryIdentifiers = new HashSet<>();\n+    private final List<Set<String>> additionalIdentifiers = new ArrayList<>();\n+\n+    private CfnResource(Builder builder) {\n+        this.propertyDefinitions.putAll(builder.propertyDefinitions);\n+        this.excludedProperties.addAll(builder.excludedProperties);\n+        this.primaryIdentifiers.addAll(builder.primaryIdentifiers);\n+        this.additionalIdentifiers.addAll(builder.additionalIdentifiers);\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Get all property definitions of the CloudFormation resource.\n+     *\n+     * @return Returns all members that map to CloudFormation resource\n+     *   properties.\n+     */\n+    public Map<String, CfnResourceProperty> getProperties() {\n+        return propertyDefinitions.entrySet().stream()\n+                .filter(entry -> !getExcludedProperties().contains(entry.getValue().getShapeId()))\n+                .collect(MapUtils.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    /**\n+     * Gets the definition of the specified property of the CloudFormation resource.\n+     *\n+     * @param propertyName Name of the property to retrieve\n+     * @return The property definition.\n+     */\n+    public Optional<CfnResourceProperty> getProperty(String propertyName) {\n+        return Optional.ofNullable(getProperties().get(propertyName));\n+    }\n+\n+    /**\n+     * Get create-specifiable-only property definitions of the CloudFormation resource.\n+     *\n+     * These properties can be specified only during resource creation and\n+     * can be returned in a {@code read} or {@code list} request.\n+     *\n+     * @return Returns create-only member names that map to CloudFormation resource\n+     *   properties.\n+     */\n+    public Set<String> getCreateOnlyProperties() {\n+        return getConstrainedProperties(definition -> {\n+            Set<CfnResourceIndex.Mutability> mutabilities = definition.getMutabilities();\n+            return mutabilities.contains(CfnResourceIndex.Mutability.CREATE)\n+                    && !mutabilities.contains(CfnResourceIndex.Mutability.WRITE);\n+        });\n+    }\n+\n+    /**\n+     * Get read-only property definitions of the CloudFormation resource.\n+     *\n+     * These properties can be returned by a {@code read} or {@code list} request,\n+     * but cannot be set by the user.\n+     *\n+     * @return Returns read-only member names that map to CloudFormation resource\n+     *   properties.\n+     */\n+    public Set<String> getReadOnlyProperties() {\n+        return getConstrainedProperties(definition -> {\n+            Set<CfnResourceIndex.Mutability> mutabilities = definition.getMutabilities();\n+            return mutabilities.size() == 1 && mutabilities.contains(CfnResourceIndex.Mutability.READ);\n+        });\n+    }\n+\n+    /**\n+     * Get write-only property definitions of the CloudFormation resource.\n+     *\n+     * These properties can be specified by the user, but cannot be\n+     * returned by a {@code read} or {@code list} request.\n+     *\n+     * @return Returns write-only member names that map to CloudFormation resource\n+     *   properties.\n+     */\n+    public Set<String> getWriteOnlyProperties() {\n+        return getConstrainedProperties(definition -> {\n+            Set<CfnResourceIndex.Mutability> mutabilities = definition.getMutabilities();\n+            // Create and non-read properties need to be set as createOnly and writeOnly.\n+            if (mutabilities.size() == 1 && mutabilities.contains(CfnResourceIndex.Mutability.CREATE)) {\n+                return true;\n+            }\n+\n+            // Otherwise, create and update, or update only become writeOnly.\n+            return mutabilities.contains(CfnResourceIndex.Mutability.WRITE)\n+                    && !mutabilities.contains(CfnResourceIndex.Mutability.READ);\n+        });\n+    }\n+\n+    private Set<String> getConstrainedProperties(Predicate<CfnResourceProperty> constraint) {\n+        return getProperties().entrySet().stream()\n+                       .filter(property -> constraint.test(property.getValue()))\n+                       .map(Map.Entry::getKey)\n+                       .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Get members that have been explicitly excluded from the CloudFormation\n+     * resource.\n+     *\n+     * @return Returns members that have been excluded from a CloudFormation\n+     *   resource.\n+     */\n+    public Set<ShapeId> getExcludedProperties() {\n+        return excludedProperties;\n+    }\n+\n+    /**\n+     * Gets a set of member shape ids that represent the primary way\n+     * to identify a CloudFormation resource.\n+     *\n+     * @return Returns the identifier set primarily used to access a\n+     *   CloudFormation resource.\n+     */\n+    public Set<String> getPrimaryIdentifiers() {", "originalCommit": "7ef7419ed75b5f447c4a64ac59e16ff096121f6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff3402b4090b37d7aafb3711356cf1982cd220ab", "chunk": "diff --git a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java\nindex 8859e3e1c..2735067e3 100644\n--- a/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java\n+++ b/smithy-aws-cloudformation-traits/src/main/java/software/amazon/smithy/aws/cloudformation/traits/CfnResource.java\n\n@@ -26,7 +26,6 @@ import java.util.function.Function;\n import java.util.function.Predicate;\n import java.util.stream.Collectors;\n import software.amazon.smithy.model.shapes.ShapeId;\n-import software.amazon.smithy.utils.MapUtils;\n import software.amazon.smithy.utils.SmithyBuilder;\n import software.amazon.smithy.utils.ToSmithyBuilder;\n \n"}}, {"oid": "ff3402b4090b37d7aafb3711356cf1982cd220ab", "url": "https://github.com/awslabs/smithy/commit/ff3402b4090b37d7aafb3711356cf1982cd220ab", "message": "Add aws.cloudformation traits\n\nThis commit adds several traits in the aws.cloudformation namespace,\ncontained in a new smithy-aws-cloudformation-traits package. These\ntraits indicate CloudFormation resources and the additional metadata\nabout their properties. A CfnResourceIndex is also included to make using\nthis information more accessible and to handle derived property\nmutabilities.", "committedDate": "2020-10-30T00:40:20Z", "type": "forcePushed"}, {"oid": "5bd9e9b3f7392090663bf3f3d5c47d25976d002a", "url": "https://github.com/awslabs/smithy/commit/5bd9e9b3f7392090663bf3f3d5c47d25976d002a", "message": "Add aws.cloudformation traits\n\nThis commit adds several traits in the aws.cloudformation namespace,\ncontained in a new smithy-aws-cloudformation-traits package. These\ntraits indicate CloudFormation resources and the additional metadata\nabout their properties. A CfnResourceIndex is also included to make using\nthis information more accessible and to handle derived property\nmutabilities.", "committedDate": "2020-11-13T21:52:28Z", "type": "commit"}, {"oid": "5bd9e9b3f7392090663bf3f3d5c47d25976d002a", "url": "https://github.com/awslabs/smithy/commit/5bd9e9b3f7392090663bf3f3d5c47d25976d002a", "message": "Add aws.cloudformation traits\n\nThis commit adds several traits in the aws.cloudformation namespace,\ncontained in a new smithy-aws-cloudformation-traits package. These\ntraits indicate CloudFormation resources and the additional metadata\nabout their properties. A CfnResourceIndex is also included to make using\nthis information more accessible and to handle derived property\nmutabilities.", "committedDate": "2020-11-13T21:52:28Z", "type": "forcePushed"}, {"oid": "4c0cfc1463d4e0521eaf76985909c2f2e5c9b1f2", "url": "https://github.com/awslabs/smithy/commit/4c0cfc1463d4e0521eaf76985909c2f2e5c9b1f2", "message": "Add CloudFormation resource schema generation\n\nThis commit introduces a new \"cloudformation\" build plugin that, given\na model decorated with the aws.cloudformation traits, will generate\nCloudFormation Resource Schemas. This includes support for specifying\nthe mutability of properties, their documentation, and more.", "committedDate": "2020-11-19T19:46:04Z", "type": "commit"}]}