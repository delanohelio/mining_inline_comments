{"pr_number": 545, "pr_title": "Add reverse-topological index", "pr_createdAt": "2020-08-28T16:43:49Z", "pr_url": "https://github.com/awslabs/smithy/pull/545", "timeline": [{"oid": "8279f54985157e7e129e27dfae2ad4dc5039296a", "url": "https://github.com/awslabs/smithy/commit/8279f54985157e7e129e27dfae2ad4dc5039296a", "message": "Add reverse-topological index\n\nSome languages require types to be defined before they're referenced, so\nthey need a reverse topological ordering of shapes. They also need to\nknow which shapes are recursive so that they can use forward\ndeclarations before referencing recursive types. This commit adds a\nTopologicalIndex to smithy-codegen-core to provide a stable ordered\nreverse-topological set of shapes, and a set of recursive shapes along\nwith their recursive closures. This recursive closure may also be of\ninterest to code generators when deciding whether or not a recursive\nreference needs to be boxed or not to compute a type's size at compile\ntime.", "committedDate": "2020-08-28T16:45:17Z", "type": "commit"}, {"oid": "8279f54985157e7e129e27dfae2ad4dc5039296a", "url": "https://github.com/awslabs/smithy/commit/8279f54985157e7e129e27dfae2ad4dc5039296a", "message": "Add reverse-topological index\n\nSome languages require types to be defined before they're referenced, so\nthey need a reverse topological ordering of shapes. They also need to\nknow which shapes are recursive so that they can use forward\ndeclarations before referencing recursive types. This commit adds a\nTopologicalIndex to smithy-codegen-core to provide a stable ordered\nreverse-topological set of shapes, and a set of recursive shapes along\nwith their recursive closures. This recursive closure may also be of\ninterest to code generators when deciding whether or not a recursive\nreference needs to be boxed or not to compute a type's size at compile\ntime.", "committedDate": "2020-08-28T16:45:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NDM4Mg==", "url": "https://github.com/awslabs/smithy/pull/545#discussion_r479454382", "bodyText": "Is the ordering of this stable?", "author": "JordonPhillips", "createdAt": "2020-08-28T17:55:47Z", "path": "smithy-codegen-core/src/main/java/software/amazon/smithy/codegen/core/TopologicalIndex.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.codegen.core;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n+import software.amazon.smithy.model.knowledge.NeighborProviderIndex;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.neighbor.NeighborProvider;\n+import software.amazon.smithy.model.neighbor.Relationship;\n+import software.amazon.smithy.model.neighbor.RelationshipDirection;\n+import software.amazon.smithy.model.selector.PathFinder;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.SimpleShape;\n+import software.amazon.smithy.model.shapes.ToShapeId;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+\n+/**\n+ * Creates a reverse-topological ordering of shapes.\n+ *\n+ * <p>This kind of reverse topological ordering is useful for languages\n+ * like C++ that need to define shapes before they can be referenced.\n+ * Only non-recursive shapes are reverse-topologically ordered using\n+ * {@link #getOrderedShapes()}. However, recursive shapes are queryable\n+ * through {@link #getRecursiveShapes()}. When this returned {@code Set} is\n+ * iterated, recursive shapes are ordered by their degree of recursion (the\n+ * number of edges across all recursive closures), and then by shape ID\n+ * when multiple shapes have the same degree of recursion.\n+ *\n+ * <p>The recursion closures of a shape can be queried using\n+ * {@link #getRecursiveClosure(ToShapeId)}. This method returns a list of\n+ * paths from the shape back to itself. This list can be useful for code\n+ * generation to generate different code based on if a recursive path\n+ * passes through particular types of shapes.\n+ */\n+public final class TopologicalIndex implements KnowledgeIndex {\n+\n+    private final Set<Shape> shapes = new LinkedHashSet<>();\n+    private final Map<Shape, List<PathFinder.Path>> recursiveShapes = new LinkedHashMap<>();\n+\n+    public TopologicalIndex(Model model) {\n+        // A reverse-topological sort can't be performed on recursive shapes,\n+        // so instead, recursive shapes are explored first and removed from\n+        // the topological sort.\n+        computeRecursiveShapes(model);\n+\n+        // Next, the model is explored using a DFS so that targets of shapes\n+        // are ordered before the shape itself.\n+        NeighborProvider provider = NeighborProviderIndex.of(model).getProvider();\n+        model.shapes()\n+                // Note that while we do not scan the prelude here, shapes from\n+                // the prelude are pull into the ordered result if referenced.\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .filter(shape -> !recursiveShapes.containsKey(shape))\n+                // Sort here to provide a deterministic result.\n+                .sorted()\n+                .forEach(shape -> visitShape(provider, shape));\n+    }\n+\n+    private void computeRecursiveShapes(Model model) {\n+        // PathFinder is used to find all paths from U -> U.\n+        PathFinder finder = PathFinder.create(model);\n+\n+        // The order of recursive shapes is first by the number of edges\n+        // (the degree of recursion), and then alphabetically by shape ID.\n+        Map<Integer, Map<Shape, List<PathFinder.Path>>> edgesToShapePaths = new TreeMap<>();\n+        for (Shape shape : model.toSet()) {\n+            if (!Prelude.isPreludeShape(shape) && !(shape instanceof SimpleShape)) {\n+                // Find all paths from the shape back to itself.\n+                List<PathFinder.Path> paths = finder.search(shape, shape);\n+                if (!paths.isEmpty()) {\n+                    int edgeCount = 0;\n+                    for (PathFinder.Path path : paths) {\n+                        edgeCount += path.size();\n+                    }\n+                    edgesToShapePaths.computeIfAbsent(edgeCount, s -> new TreeMap<>())\n+                            .put(shape, Collections.unmodifiableList(paths));\n+                }\n+            }\n+        }\n+\n+        for (Map.Entry<Integer, Map<Shape, List<PathFinder.Path>>> entry : edgesToShapePaths.entrySet()) {\n+            recursiveShapes.putAll(entry.getValue());\n+        }\n+    }\n+\n+    private void visitShape(NeighborProvider provider, Shape shape) {\n+        // Visit members before visiting containers. Note that no 'visited'\n+        // set is needed since only non-recursive shapes are traversed.\n+        for (Relationship rel : provider.getNeighbors(shape)) {", "originalCommit": "8279f54985157e7e129e27dfae2ad4dc5039296a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwOTkwNw==", "url": "https://github.com/awslabs/smithy/pull/545#discussion_r479509907", "bodyText": "It is stable, but not alphabetically ordered. I updated it to sort neighbors alphabetically to make it more predictable.", "author": "mtdowling", "createdAt": "2020-08-28T20:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NDM4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "42c944456313cdee003d33910f85fdac113c0bec", "chunk": "diff --git a/smithy-codegen-core/src/main/java/software/amazon/smithy/codegen/core/TopologicalIndex.java b/smithy-codegen-core/src/main/java/software/amazon/smithy/codegen/core/TopologicalIndex.java\nindex 80b9b8060..853ad2de9 100644\n--- a/smithy-codegen-core/src/main/java/software/amazon/smithy/codegen/core/TopologicalIndex.java\n+++ b/smithy-codegen-core/src/main/java/software/amazon/smithy/codegen/core/TopologicalIndex.java\n\n@@ -22,6 +22,7 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.TreeMap;\n+import java.util.TreeSet;\n import software.amazon.smithy.model.Model;\n import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n import software.amazon.smithy.model.knowledge.NeighborProviderIndex;\n"}}, {"oid": "42c944456313cdee003d33910f85fdac113c0bec", "url": "https://github.com/awslabs/smithy/commit/42c944456313cdee003d33910f85fdac113c0bec", "message": "Visit topological neighbors alphabetically", "committedDate": "2020-08-28T20:01:40Z", "type": "commit"}]}