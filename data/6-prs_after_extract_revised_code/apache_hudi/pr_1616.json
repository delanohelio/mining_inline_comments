{"pr_number": 1616, "pr_title": "[HUDI-786] Fixing read beyond inline length in InlineFS", "pr_createdAt": "2020-05-11T13:41:15Z", "pr_url": "https://github.com/apache/hudi/pull/1616", "timeline": [{"oid": "7bddcf662a33079e32d3ae69e06d7995a9bc7e16", "url": "https://github.com/apache/hudi/commit/7bddcf662a33079e32d3ae69e06d7995a9bc7e16", "message": "Fixing read beyond inline length FS", "committedDate": "2020-05-11T13:41:26Z", "type": "commit"}, {"oid": "7bddcf662a33079e32d3ae69e06d7995a9bc7e16", "url": "https://github.com/apache/hudi/commit/7bddcf662a33079e32d3ae69e06d7995a9bc7e16", "message": "Fixing read beyond inline length FS", "committedDate": "2020-05-11T13:41:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NTY2NQ==", "url": "https://github.com/apache/hudi/pull/1616#discussion_r423155665", "bodyText": "@nsivabalan : Dont we need to have this bounds check even for seek/read (offset-based) APIs ?", "author": "bvaradar", "createdAt": "2020-05-11T16:14:39Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/fs/inline/InLineFsDataInputStream.java", "diffHunk": "@@ -56,24 +56,29 @@ public long getPos() throws IOException {\n \n   @Override\n   public int read(long position, byte[] buffer, int offset, int length) throws IOException {\n+    if ((length - offset) > this.length) {\n+      throw new IOException(\"Attempting to read past inline content\");\n+    }\n     return outerStream.read(startOffset + position, buffer, offset, length);\n   }\n \n   @Override\n   public void readFully(long position, byte[] buffer, int offset, int length) throws IOException {\n+    if ((length - offset) > this.length) {\n+      throw new IOException(\"Attempting to read past inline content\");\n+    }\n     outerStream.readFully(startOffset + position, buffer, offset, length);\n   }\n \n   @Override\n   public void readFully(long position, byte[] buffer)\n       throws IOException {\n-    outerStream.readFully(startOffset + position, buffer, 0, buffer.length);\n+    readFully(position, buffer, 0, buffer.length);\n   }\n \n   @Override\n   public boolean seekToNewSource(long targetPos) throws IOException {", "originalCommit": "7bddcf662a33079e32d3ae69e06d7995a9bc7e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3Njg0Mg==", "url": "https://github.com/apache/hudi/pull/1616#discussion_r425276842", "bodyText": "+1 we need to rethink this entire class this way ..", "author": "vinothchandar", "createdAt": "2020-05-14T16:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NTY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5NDU3Nw==", "url": "https://github.com/apache/hudi/pull/1616#discussion_r425494577", "bodyText": "have fixed seek(targetpos). Trying to understand seekToNewSource(long targetPos). Docs says \"Seek to the given position on an alternate copy of the data. Returns true if alternate copy is found, false otherwise\". I am not sure how to go about this.\nIf we check for bounds and could return false (if targetPos > length), but what in case alternate copy is not found?\nOr I could do something like this.\n@Override\n   public boolean seekToNewSource(long targetPos) throws IOException {\n         boolean returnVal = outerStream.seekToNewSource(startOffset + targetPos)\n         if(returnVal) {\n               if(targetPos > length ) {\n                   returnVal = false\n               }\n          }\n       return returnVal; \n    }", "author": "nsivabalan", "createdAt": "2020-05-15T00:03:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NTY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3MDE1OA==", "url": "https://github.com/apache/hudi/pull/1616#discussion_r428970158", "bodyText": "@bvaradar ping.", "author": "nsivabalan", "createdAt": "2020-05-21T23:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NTY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5Mjg5Mw==", "url": "https://github.com/apache/hudi/pull/1616#discussion_r429392893", "bodyText": "@nsivabalan : Can we do bounds check first and throw error if it fails then delegate. Even if it is a different copy, the offsets are expected to be consistent across copies.", "author": "bvaradar", "createdAt": "2020-05-22T18:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NTY2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "84dc7b55d70518f2353e243c28689e0c8fb28676", "chunk": "diff --git a/hudi-common/src/main/java/org/apache/hudi/common/fs/inline/InLineFsDataInputStream.java b/hudi-common/src/main/java/org/apache/hudi/common/fs/inline/InLineFsDataInputStream.java\nindex 5d1adcdf5..4e8701244 100644\n--- a/hudi-common/src/main/java/org/apache/hudi/common/fs/inline/InLineFsDataInputStream.java\n+++ b/hudi-common/src/main/java/org/apache/hudi/common/fs/inline/InLineFsDataInputStream.java\n\n@@ -56,7 +60,7 @@ public class InLineFsDataInputStream extends FSDataInputStream {\n \n   @Override\n   public int read(long position, byte[] buffer, int offset, int length) throws IOException {\n-    if ((length - offset) > this.length) {\n+    if ((length + offset) > this.length) {\n       throw new IOException(\"Attempting to read past inline content\");\n     }\n     return outerStream.read(startOffset + position, buffer, offset, length);\n"}}, {"oid": "84dc7b55d70518f2353e243c28689e0c8fb28676", "url": "https://github.com/apache/hudi/commit/84dc7b55d70518f2353e243c28689e0c8fb28676", "message": "Fixing seek and tests", "committedDate": "2020-05-28T18:02:23Z", "type": "commit"}, {"oid": "84dc7b55d70518f2353e243c28689e0c8fb28676", "url": "https://github.com/apache/hudi/commit/84dc7b55d70518f2353e243c28689e0c8fb28676", "message": "Fixing seek and tests", "committedDate": "2020-05-28T18:02:23Z", "type": "forcePushed"}]}