{"pr_number": 2202, "pr_title": "[HUDI-1352] Add FileSystemView APIs to query pending clustering ops", "pr_createdAt": "2020-10-23T22:27:57Z", "pr_url": "https://github.com/apache/hudi/pull/2202", "timeline": [{"oid": "5071687bfd54c1645eb6770398290e9712eb3e0d", "url": "https://github.com/apache/hudi/commit/5071687bfd54c1645eb6770398290e9712eb3e0d", "message": "[HUDI-1352] Add FileSystemView APIs to query pending clustering operations", "committedDate": "2020-10-28T00:05:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMDA0OA==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513520048", "bodyText": "Alter comments accordingly", "author": "n3nash", "createdAt": "2020-10-28T15:05:25Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/table/timeline/dto/ClusteringOpDTO.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.table.timeline.dto;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.collection.Pair;\n+\n+/**\n+ * The data transfer object of compaction.", "originalCommit": "5071687bfd54c1645eb6770398290e9712eb3e0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY4MDI3OQ==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513680279", "bodyText": "Will fix it. thanks", "author": "satishkotha", "createdAt": "2020-10-28T18:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMDA0OA=="}], "type": "inlineReview", "revised_code": {"commit": "5630f181e6a0a87eef2759947a375a9a63581ab0", "chunk": "diff --git a/hudi-common/src/main/java/org/apache/hudi/common/table/timeline/dto/ClusteringOpDTO.java b/hudi-common/src/main/java/org/apache/hudi/common/table/timeline/dto/ClusteringOpDTO.java\nindex 3bf34fa70..e87226c99 100644\n--- a/hudi-common/src/main/java/org/apache/hudi/common/table/timeline/dto/ClusteringOpDTO.java\n+++ b/hudi-common/src/main/java/org/apache/hudi/common/table/timeline/dto/ClusteringOpDTO.java\n\n@@ -25,7 +25,7 @@ import org.apache.hudi.common.table.timeline.HoodieInstant;\n import org.apache.hudi.common.util.collection.Pair;\n \n /**\n- * The data transfer object of compaction.\n+ * The data transfer object of clustering.\n  */\n @JsonIgnoreProperties(ignoreUnknown = true)\n public class ClusteringOpDTO {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMDkyMw==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513520923", "bodyText": "What does a fileID mean here ? Is this the lowest representation of the clustering plan, will the clustering plan contain a bunch of ClusteringOpDTO's ?", "author": "n3nash", "createdAt": "2020-10-28T15:06:29Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/table/timeline/dto/ClusteringOpDTO.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.table.timeline.dto;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.collection.Pair;\n+\n+/**\n+ * The data transfer object of compaction.\n+ */\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class ClusteringOpDTO {\n+\n+  @JsonProperty(\"id\")\n+  private String fileId;", "originalCommit": "5071687bfd54c1645eb6770398290e9712eb3e0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY4MTgwMg==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513681802", "bodyText": "This is only used for RemoteFileSystemView implementation. RemoteFSV uses DTOs to serialize and deserialize the data over wire. One of the APIs filesystem view provides is to list all fileIds that have pending clustering scheduled. So this file contains all the information we need to send over network. It has nothing to do with clustering plan stored in avro format. Its just there to support getFilesInPendingClusteringOperation API", "author": "satishkotha", "createdAt": "2020-10-28T18:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMDkyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI5NTU2NA==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r514295564", "bodyText": "Thanks for the explanation.", "author": "n3nash", "createdAt": "2020-10-29T14:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMDkyMw=="}], "type": "inlineReview", "revised_code": {"commit": "5630f181e6a0a87eef2759947a375a9a63581ab0", "chunk": "diff --git a/hudi-common/src/main/java/org/apache/hudi/common/table/timeline/dto/ClusteringOpDTO.java b/hudi-common/src/main/java/org/apache/hudi/common/table/timeline/dto/ClusteringOpDTO.java\nindex 3bf34fa70..e87226c99 100644\n--- a/hudi-common/src/main/java/org/apache/hudi/common/table/timeline/dto/ClusteringOpDTO.java\n+++ b/hudi-common/src/main/java/org/apache/hudi/common/table/timeline/dto/ClusteringOpDTO.java\n\n@@ -25,7 +25,7 @@ import org.apache.hudi.common.table.timeline.HoodieInstant;\n import org.apache.hudi.common.util.collection.Pair;\n \n /**\n- * The data transfer object of compaction.\n+ * The data transfer object of clustering.\n  */\n @JsonIgnoreProperties(ignoreUnknown = true)\n public class ClusteringOpDTO {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMjUxMA==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513522510", "bodyText": "Is this comment the right description for this API ?", "author": "n3nash", "createdAt": "2020-10-28T15:08:25Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/table/view/AbstractTableFileSystemView.java", "diffHunk": "@@ -710,6 +721,40 @@ private String formatPartitionKey(String partitionStr) {\n    */\n   abstract void removePendingCompactionOperations(Stream<Pair<String, CompactionOperation>> operations);\n \n+  /**\n+   * Check if there is an outstanding clustering operation (requested/inflight) scheduled for this file.\n+   *\n+   * @param fgId File-Group Id\n+   * @return true if there is a pending clustering, false otherwise\n+   */\n+  protected abstract boolean isPendingClusteringScheduledForFileId(HoodieFileGroupId fgId);\n+\n+  /**\n+   *  Get pending clustering instant time for specified file group. Return None if file group is not in pending\n+   *  clustering operation.\n+   */\n+  protected abstract Option<HoodieInstant> getPendingClusteringInstant(final HoodieFileGroupId fileGroupId);\n+\n+  /**\n+   * Fetch all file groups in pending clustering.\n+   */\n+  protected abstract Stream<Pair<HoodieFileGroupId, HoodieInstant>> fetchFileGroupsInPendingClustering();\n+\n+  /**\n+   * resets the pending clustering operation and overwrite with the new list.\n+   */\n+  abstract void resetFileGroupsInPendingClustering(Map<HoodieFileGroupId, HoodieInstant> fgIdToInstantMap);\n+\n+  /**\n+   * Add metadata for pending clustering operation to store for given instant.", "originalCommit": "5071687bfd54c1645eb6770398290e9712eb3e0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY4MjE0OQ==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513682149", "bodyText": "I will expand it to explain better", "author": "satishkotha", "createdAt": "2020-10-28T18:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMjUxMA=="}], "type": "inlineReview", "revised_code": {"commit": "5630f181e6a0a87eef2759947a375a9a63581ab0", "chunk": "diff --git a/hudi-common/src/main/java/org/apache/hudi/common/table/view/AbstractTableFileSystemView.java b/hudi-common/src/main/java/org/apache/hudi/common/table/view/AbstractTableFileSystemView.java\nindex c47aa0d1f..1dd6b006b 100644\n--- a/hudi-common/src/main/java/org/apache/hudi/common/table/view/AbstractTableFileSystemView.java\n+++ b/hudi-common/src/main/java/org/apache/hudi/common/table/view/AbstractTableFileSystemView.java\n\n@@ -746,12 +746,12 @@ public abstract class AbstractTableFileSystemView implements SyncableFileSystemV\n   abstract void resetFileGroupsInPendingClustering(Map<HoodieFileGroupId, HoodieInstant> fgIdToInstantMap);\n \n   /**\n-   * Add metadata for pending clustering operation to store for given instant.\n+   * Add metadata for file groups in pending clustering operations to the view.\n    */\n   abstract void addFileGroupsInPendingClustering(Stream<Pair<HoodieFileGroupId, HoodieInstant>> fileGroups);\n \n   /**\n-   * Remove metadata for pending clustering operations from store for given instant.\n+   * Remove metadata for file groups in pending clustering operations from the view.\n    */\n   abstract void removeFileGroupsInPendingClustering(Stream<Pair<HoodieFileGroupId, HoodieInstant>> fileGroups);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMjg4OQ==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513522889", "bodyText": "How will this API be used ?", "author": "n3nash", "createdAt": "2020-10-28T15:08:54Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/table/view/AbstractTableFileSystemView.java", "diffHunk": "@@ -710,6 +721,40 @@ private String formatPartitionKey(String partitionStr) {\n    */\n   abstract void removePendingCompactionOperations(Stream<Pair<String, CompactionOperation>> operations);\n \n+  /**\n+   * Check if there is an outstanding clustering operation (requested/inflight) scheduled for this file.\n+   *\n+   * @param fgId File-Group Id\n+   * @return true if there is a pending clustering, false otherwise\n+   */\n+  protected abstract boolean isPendingClusteringScheduledForFileId(HoodieFileGroupId fgId);\n+\n+  /**\n+   *  Get pending clustering instant time for specified file group. Return None if file group is not in pending\n+   *  clustering operation.\n+   */\n+  protected abstract Option<HoodieInstant> getPendingClusteringInstant(final HoodieFileGroupId fileGroupId);\n+\n+  /**\n+   * Fetch all file groups in pending clustering.\n+   */\n+  protected abstract Stream<Pair<HoodieFileGroupId, HoodieInstant>> fetchFileGroupsInPendingClustering();\n+\n+  /**\n+   * resets the pending clustering operation and overwrite with the new list.\n+   */\n+  abstract void resetFileGroupsInPendingClustering(Map<HoodieFileGroupId, HoodieInstant> fgIdToInstantMap);", "originalCommit": "5071687bfd54c1645eb6770398290e9712eb3e0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY4MzM1NA==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513683354", "bodyText": "This is called from FileSystemView#init method to refresh list of files in pending clustering. The list is used to block updates  HUDI-1354 and scheduling further clustering operations.", "author": "satishkotha", "createdAt": "2020-10-28T18:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMjg4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "5630f181e6a0a87eef2759947a375a9a63581ab0", "chunk": "diff --git a/hudi-common/src/main/java/org/apache/hudi/common/table/view/AbstractTableFileSystemView.java b/hudi-common/src/main/java/org/apache/hudi/common/table/view/AbstractTableFileSystemView.java\nindex c47aa0d1f..1dd6b006b 100644\n--- a/hudi-common/src/main/java/org/apache/hudi/common/table/view/AbstractTableFileSystemView.java\n+++ b/hudi-common/src/main/java/org/apache/hudi/common/table/view/AbstractTableFileSystemView.java\n\n@@ -746,12 +746,12 @@ public abstract class AbstractTableFileSystemView implements SyncableFileSystemV\n   abstract void resetFileGroupsInPendingClustering(Map<HoodieFileGroupId, HoodieInstant> fgIdToInstantMap);\n \n   /**\n-   * Add metadata for pending clustering operation to store for given instant.\n+   * Add metadata for file groups in pending clustering operations to the view.\n    */\n   abstract void addFileGroupsInPendingClustering(Stream<Pair<HoodieFileGroupId, HoodieInstant>> fileGroups);\n \n   /**\n-   * Remove metadata for pending clustering operations from store for given instant.\n+   * Remove metadata for file groups in pending clustering operations from the view.\n    */\n   abstract void removeFileGroupsInPendingClustering(Stream<Pair<HoodieFileGroupId, HoodieInstant>> fileGroups);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyODA2Ng==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513528066", "bodyText": "Can we change this loop to java 8 stream style, fileSliceGroups.stream().foreach()..", "author": "n3nash", "createdAt": "2020-10-28T15:15:21Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.util;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieClusteringStrategy;\n+import org.apache.hudi.avro.model.HoodieRequestedReplaceMetadata;\n+import org.apache.hudi.avro.model.HoodieSliceInfo;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.BaseFile;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.model.HoodieLogFile;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.TimelineMetadataUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Helper class to generate clustering plan from metadata.\n+ */\n+public class ClusteringUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(ClusteringUtils.class);\n+\n+  public static final String TOTAL_IO_READ_MB = \"TOTAL_IO_READ_MB\";\n+  public static final String TOTAL_LOG_FILE_SIZE = \"TOTAL_LOG_FILES_SIZE\";\n+  public static final String TOTAL_LOG_FILES = \"TOTAL_LOG_FILES\";\n+\n+  /**\n+   * Get all pending clustering plans along with their instants.\n+   */\n+  public static Stream<Pair<HoodieInstant, HoodieClusteringPlan>> getAllPendingClusteringPlans(\n+      HoodieTableMetaClient metaClient) {\n+    List<HoodieInstant> pendingReplaceInstants =\n+        metaClient.getActiveTimeline().filterPendingReplaceTimeline().getInstants().collect(Collectors.toList());\n+    return pendingReplaceInstants.stream().map(instant -> getClusteringPlan(metaClient, instant))\n+        .filter(Option::isPresent).map(Option::get);\n+  }\n+\n+  public static Option<Pair<HoodieInstant, HoodieClusteringPlan>> getClusteringPlan(HoodieTableMetaClient metaClient, HoodieInstant requestedReplaceInstant) {\n+    try {\n+      Option<byte[]> content = metaClient.getActiveTimeline().getInstantDetails(requestedReplaceInstant);\n+      if (!content.isPresent() || content.get().length == 0) {\n+        // few operations create requested file without any content. Assume these are not clustering\n+        LOG.warn(\"No content found in requested file for instant \" + requestedReplaceInstant);\n+        return Option.empty();\n+      }\n+      HoodieRequestedReplaceMetadata requestedReplaceMetadata = TimelineMetadataUtils.deserializeRequestedReplaceMetadta(content.get());\n+      if (WriteOperationType.CLUSTER.name().equals(requestedReplaceMetadata.getOperationType())) {\n+        return Option.of(Pair.of(requestedReplaceInstant, requestedReplaceMetadata.getClusteringPlan()));\n+      }\n+      return Option.empty();\n+    } catch (IOException e) {\n+      throw new HoodieIOException(\"Error reading clustering plan \" + requestedReplaceInstant.getTimestamp(), e);\n+    }\n+  }\n+\n+  /**\n+   * Get filegroups to pending clustering instant mapping for all pending clustering plans.\n+   * This includes all clustering operattions in 'requested' and 'inflight' states.\n+   */\n+  public static Map<HoodieFileGroupId, HoodieInstant> getAllFileGroupsInPendingClusteringPlans(\n+      HoodieTableMetaClient metaClient) {\n+    Stream<Pair<HoodieInstant, HoodieClusteringPlan>> pendingClusteringPlans = getAllPendingClusteringPlans(metaClient);\n+    Stream<Map.Entry<HoodieFileGroupId, HoodieInstant>> resultStream = pendingClusteringPlans.flatMap(clusteringPlan ->\n+        // get all filegroups in the plan\n+        getFileGroupEntriesInClusteringPlan(clusteringPlan.getLeft(), clusteringPlan.getRight()));\n+\n+    Map<HoodieFileGroupId, HoodieInstant> resultMap = resultStream.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    LOG.info(\"Found \" + resultMap.size() + \" files in pending clustering operations\");\n+    return resultMap;\n+  }\n+\n+  public static Stream<Pair<HoodieFileGroupId, HoodieInstant>> getFileGroupsInPendingClusteringInstant(\n+      HoodieInstant instant, HoodieClusteringPlan clusteringPlan) {\n+    Stream<HoodieFileGroupId> partitionToFileIdLists = clusteringPlan.getInputGroups().stream().flatMap(ClusteringUtils::getFileGroupsFromClusteringGroup);\n+    return partitionToFileIdLists.map(e -> Pair.of(e, instant));\n+  }\n+\n+  private static Stream<Map.Entry<HoodieFileGroupId, HoodieInstant>> getFileGroupEntriesInClusteringPlan(\n+      HoodieInstant instant, HoodieClusteringPlan clusteringPlan) {\n+    return getFileGroupsInPendingClusteringInstant(instant, clusteringPlan).map(entry ->\n+        new AbstractMap.SimpleEntry<>(entry.getLeft(), entry.getRight()));\n+  }\n+\n+  private static Stream<HoodieFileGroupId> getFileGroupsFromClusteringGroup(HoodieClusteringGroup group) {\n+    return group.getSlices().stream().map(slice -> new HoodieFileGroupId(slice.getPartitionPath(), slice.getFileId()));\n+  }\n+\n+  /**\n+   * Create clustering plan from input fileSliceGroups.\n+   */\n+  public static HoodieClusteringPlan createClusteringPlan(String strategyClassName,\n+                                                          Map<String, String> strategyParams,\n+                                                          List<FileSlice>[] fileSliceGroups) {\n+    List<HoodieClusteringGroup> clusteringGroups = new ArrayList<>();\n+    for (int i = 0; i < fileSliceGroups.length; i++) {", "originalCommit": "5071687bfd54c1645eb6770398290e9712eb3e0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY4MzQ3MA==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513683470", "bodyText": "Sure. will fix it.", "author": "satishkotha", "createdAt": "2020-10-28T18:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyODA2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5630f181e6a0a87eef2759947a375a9a63581ab0", "chunk": "diff --git a/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java b/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java\nindex ee35a0a6d..3289cb61e 100644\n--- a/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java\n+++ b/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java\n\n@@ -40,6 +40,7 @@ import org.apache.log4j.Logger;\n import java.io.IOException;\n import java.util.AbstractMap;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyOTE3NA==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513529174", "bodyText": "What happens if we don't setExtraMetadata to new Hashmap ? In general, we should only set the params which we need to and rest of the uninitialized params should be handled internally in the HoodieClusteringPlan.", "author": "n3nash", "createdAt": "2020-10-28T15:16:42Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.util;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieClusteringStrategy;\n+import org.apache.hudi.avro.model.HoodieRequestedReplaceMetadata;\n+import org.apache.hudi.avro.model.HoodieSliceInfo;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.BaseFile;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.model.HoodieLogFile;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.TimelineMetadataUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Helper class to generate clustering plan from metadata.\n+ */\n+public class ClusteringUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(ClusteringUtils.class);\n+\n+  public static final String TOTAL_IO_READ_MB = \"TOTAL_IO_READ_MB\";\n+  public static final String TOTAL_LOG_FILE_SIZE = \"TOTAL_LOG_FILES_SIZE\";\n+  public static final String TOTAL_LOG_FILES = \"TOTAL_LOG_FILES\";\n+\n+  /**\n+   * Get all pending clustering plans along with their instants.\n+   */\n+  public static Stream<Pair<HoodieInstant, HoodieClusteringPlan>> getAllPendingClusteringPlans(\n+      HoodieTableMetaClient metaClient) {\n+    List<HoodieInstant> pendingReplaceInstants =\n+        metaClient.getActiveTimeline().filterPendingReplaceTimeline().getInstants().collect(Collectors.toList());\n+    return pendingReplaceInstants.stream().map(instant -> getClusteringPlan(metaClient, instant))\n+        .filter(Option::isPresent).map(Option::get);\n+  }\n+\n+  public static Option<Pair<HoodieInstant, HoodieClusteringPlan>> getClusteringPlan(HoodieTableMetaClient metaClient, HoodieInstant requestedReplaceInstant) {\n+    try {\n+      Option<byte[]> content = metaClient.getActiveTimeline().getInstantDetails(requestedReplaceInstant);\n+      if (!content.isPresent() || content.get().length == 0) {\n+        // few operations create requested file without any content. Assume these are not clustering\n+        LOG.warn(\"No content found in requested file for instant \" + requestedReplaceInstant);\n+        return Option.empty();\n+      }\n+      HoodieRequestedReplaceMetadata requestedReplaceMetadata = TimelineMetadataUtils.deserializeRequestedReplaceMetadta(content.get());\n+      if (WriteOperationType.CLUSTER.name().equals(requestedReplaceMetadata.getOperationType())) {\n+        return Option.of(Pair.of(requestedReplaceInstant, requestedReplaceMetadata.getClusteringPlan()));\n+      }\n+      return Option.empty();\n+    } catch (IOException e) {\n+      throw new HoodieIOException(\"Error reading clustering plan \" + requestedReplaceInstant.getTimestamp(), e);\n+    }\n+  }\n+\n+  /**\n+   * Get filegroups to pending clustering instant mapping for all pending clustering plans.\n+   * This includes all clustering operattions in 'requested' and 'inflight' states.\n+   */\n+  public static Map<HoodieFileGroupId, HoodieInstant> getAllFileGroupsInPendingClusteringPlans(\n+      HoodieTableMetaClient metaClient) {\n+    Stream<Pair<HoodieInstant, HoodieClusteringPlan>> pendingClusteringPlans = getAllPendingClusteringPlans(metaClient);\n+    Stream<Map.Entry<HoodieFileGroupId, HoodieInstant>> resultStream = pendingClusteringPlans.flatMap(clusteringPlan ->\n+        // get all filegroups in the plan\n+        getFileGroupEntriesInClusteringPlan(clusteringPlan.getLeft(), clusteringPlan.getRight()));\n+\n+    Map<HoodieFileGroupId, HoodieInstant> resultMap = resultStream.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    LOG.info(\"Found \" + resultMap.size() + \" files in pending clustering operations\");\n+    return resultMap;\n+  }\n+\n+  public static Stream<Pair<HoodieFileGroupId, HoodieInstant>> getFileGroupsInPendingClusteringInstant(\n+      HoodieInstant instant, HoodieClusteringPlan clusteringPlan) {\n+    Stream<HoodieFileGroupId> partitionToFileIdLists = clusteringPlan.getInputGroups().stream().flatMap(ClusteringUtils::getFileGroupsFromClusteringGroup);\n+    return partitionToFileIdLists.map(e -> Pair.of(e, instant));\n+  }\n+\n+  private static Stream<Map.Entry<HoodieFileGroupId, HoodieInstant>> getFileGroupEntriesInClusteringPlan(\n+      HoodieInstant instant, HoodieClusteringPlan clusteringPlan) {\n+    return getFileGroupsInPendingClusteringInstant(instant, clusteringPlan).map(entry ->\n+        new AbstractMap.SimpleEntry<>(entry.getLeft(), entry.getRight()));\n+  }\n+\n+  private static Stream<HoodieFileGroupId> getFileGroupsFromClusteringGroup(HoodieClusteringGroup group) {\n+    return group.getSlices().stream().map(slice -> new HoodieFileGroupId(slice.getPartitionPath(), slice.getFileId()));\n+  }\n+\n+  /**\n+   * Create clustering plan from input fileSliceGroups.\n+   */\n+  public static HoodieClusteringPlan createClusteringPlan(String strategyClassName,\n+                                                          Map<String, String> strategyParams,\n+                                                          List<FileSlice>[] fileSliceGroups) {\n+    List<HoodieClusteringGroup> clusteringGroups = new ArrayList<>();\n+    for (int i = 0; i < fileSliceGroups.length; i++) {\n+      List<FileSlice> fileSliceGroup = fileSliceGroups[i];\n+      Map<String, Double> groupMetrics = buildMetrics(fileSliceGroup);\n+      List<HoodieSliceInfo> sliceInfos = getFileSliceInfo(fileSliceGroup);\n+      clusteringGroups.add(HoodieClusteringGroup.newBuilder().setSlices(sliceInfos).setMetrics(groupMetrics).build());\n+    }\n+\n+    HoodieClusteringStrategy strategy = HoodieClusteringStrategy.newBuilder()\n+        .setStrategyClassName(strategyClassName).setStrategyParams(strategyParams)\n+        .build();\n+\n+    HoodieClusteringPlan plan = HoodieClusteringPlan.newBuilder()\n+        .setInputGroups(clusteringGroups)\n+        .setExtraMetadata(new HashMap<>())", "originalCommit": "5071687bfd54c1645eb6770398290e9712eb3e0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcyODU0Mg==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513728542", "bodyText": "fixed", "author": "satishkotha", "createdAt": "2020-10-28T20:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyOTE3NA=="}], "type": "inlineReview", "revised_code": {"commit": "5630f181e6a0a87eef2759947a375a9a63581ab0", "chunk": "diff --git a/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java b/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java\nindex ee35a0a6d..3289cb61e 100644\n--- a/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java\n+++ b/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java\n\n@@ -40,6 +40,7 @@ import org.apache.log4j.Logger;\n import java.io.IOException;\n import java.util.AbstractMap;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyOTU5NQ==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513529595", "bodyText": "Should the dataFilePath be empty string or empty Option ?", "author": "n3nash", "createdAt": "2020-10-28T15:17:13Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.util;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieClusteringStrategy;\n+import org.apache.hudi.avro.model.HoodieRequestedReplaceMetadata;\n+import org.apache.hudi.avro.model.HoodieSliceInfo;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.BaseFile;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.model.HoodieLogFile;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.TimelineMetadataUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Helper class to generate clustering plan from metadata.\n+ */\n+public class ClusteringUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(ClusteringUtils.class);\n+\n+  public static final String TOTAL_IO_READ_MB = \"TOTAL_IO_READ_MB\";\n+  public static final String TOTAL_LOG_FILE_SIZE = \"TOTAL_LOG_FILES_SIZE\";\n+  public static final String TOTAL_LOG_FILES = \"TOTAL_LOG_FILES\";\n+\n+  /**\n+   * Get all pending clustering plans along with their instants.\n+   */\n+  public static Stream<Pair<HoodieInstant, HoodieClusteringPlan>> getAllPendingClusteringPlans(\n+      HoodieTableMetaClient metaClient) {\n+    List<HoodieInstant> pendingReplaceInstants =\n+        metaClient.getActiveTimeline().filterPendingReplaceTimeline().getInstants().collect(Collectors.toList());\n+    return pendingReplaceInstants.stream().map(instant -> getClusteringPlan(metaClient, instant))\n+        .filter(Option::isPresent).map(Option::get);\n+  }\n+\n+  public static Option<Pair<HoodieInstant, HoodieClusteringPlan>> getClusteringPlan(HoodieTableMetaClient metaClient, HoodieInstant requestedReplaceInstant) {\n+    try {\n+      Option<byte[]> content = metaClient.getActiveTimeline().getInstantDetails(requestedReplaceInstant);\n+      if (!content.isPresent() || content.get().length == 0) {\n+        // few operations create requested file without any content. Assume these are not clustering\n+        LOG.warn(\"No content found in requested file for instant \" + requestedReplaceInstant);\n+        return Option.empty();\n+      }\n+      HoodieRequestedReplaceMetadata requestedReplaceMetadata = TimelineMetadataUtils.deserializeRequestedReplaceMetadta(content.get());\n+      if (WriteOperationType.CLUSTER.name().equals(requestedReplaceMetadata.getOperationType())) {\n+        return Option.of(Pair.of(requestedReplaceInstant, requestedReplaceMetadata.getClusteringPlan()));\n+      }\n+      return Option.empty();\n+    } catch (IOException e) {\n+      throw new HoodieIOException(\"Error reading clustering plan \" + requestedReplaceInstant.getTimestamp(), e);\n+    }\n+  }\n+\n+  /**\n+   * Get filegroups to pending clustering instant mapping for all pending clustering plans.\n+   * This includes all clustering operattions in 'requested' and 'inflight' states.\n+   */\n+  public static Map<HoodieFileGroupId, HoodieInstant> getAllFileGroupsInPendingClusteringPlans(\n+      HoodieTableMetaClient metaClient) {\n+    Stream<Pair<HoodieInstant, HoodieClusteringPlan>> pendingClusteringPlans = getAllPendingClusteringPlans(metaClient);\n+    Stream<Map.Entry<HoodieFileGroupId, HoodieInstant>> resultStream = pendingClusteringPlans.flatMap(clusteringPlan ->\n+        // get all filegroups in the plan\n+        getFileGroupEntriesInClusteringPlan(clusteringPlan.getLeft(), clusteringPlan.getRight()));\n+\n+    Map<HoodieFileGroupId, HoodieInstant> resultMap = resultStream.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    LOG.info(\"Found \" + resultMap.size() + \" files in pending clustering operations\");\n+    return resultMap;\n+  }\n+\n+  public static Stream<Pair<HoodieFileGroupId, HoodieInstant>> getFileGroupsInPendingClusteringInstant(\n+      HoodieInstant instant, HoodieClusteringPlan clusteringPlan) {\n+    Stream<HoodieFileGroupId> partitionToFileIdLists = clusteringPlan.getInputGroups().stream().flatMap(ClusteringUtils::getFileGroupsFromClusteringGroup);\n+    return partitionToFileIdLists.map(e -> Pair.of(e, instant));\n+  }\n+\n+  private static Stream<Map.Entry<HoodieFileGroupId, HoodieInstant>> getFileGroupEntriesInClusteringPlan(\n+      HoodieInstant instant, HoodieClusteringPlan clusteringPlan) {\n+    return getFileGroupsInPendingClusteringInstant(instant, clusteringPlan).map(entry ->\n+        new AbstractMap.SimpleEntry<>(entry.getLeft(), entry.getRight()));\n+  }\n+\n+  private static Stream<HoodieFileGroupId> getFileGroupsFromClusteringGroup(HoodieClusteringGroup group) {\n+    return group.getSlices().stream().map(slice -> new HoodieFileGroupId(slice.getPartitionPath(), slice.getFileId()));\n+  }\n+\n+  /**\n+   * Create clustering plan from input fileSliceGroups.\n+   */\n+  public static HoodieClusteringPlan createClusteringPlan(String strategyClassName,\n+                                                          Map<String, String> strategyParams,\n+                                                          List<FileSlice>[] fileSliceGroups) {\n+    List<HoodieClusteringGroup> clusteringGroups = new ArrayList<>();\n+    for (int i = 0; i < fileSliceGroups.length; i++) {\n+      List<FileSlice> fileSliceGroup = fileSliceGroups[i];\n+      Map<String, Double> groupMetrics = buildMetrics(fileSliceGroup);\n+      List<HoodieSliceInfo> sliceInfos = getFileSliceInfo(fileSliceGroup);\n+      clusteringGroups.add(HoodieClusteringGroup.newBuilder().setSlices(sliceInfos).setMetrics(groupMetrics).build());\n+    }\n+\n+    HoodieClusteringStrategy strategy = HoodieClusteringStrategy.newBuilder()\n+        .setStrategyClassName(strategyClassName).setStrategyParams(strategyParams)\n+        .build();\n+\n+    HoodieClusteringPlan plan = HoodieClusteringPlan.newBuilder()\n+        .setInputGroups(clusteringGroups)\n+        .setExtraMetadata(new HashMap<>())\n+        .setStrategy(strategy)\n+        .build();\n+\n+    return plan;\n+  }\n+\n+  private static List<HoodieSliceInfo> getFileSliceInfo(List<FileSlice> slices) {\n+    FileSlice slice1 = slices.get(0);\n+    System.out.println(slice1.getLogFiles().count());\n+    System.out.println(slice1.getBaseFile().get());\n+    System.out.println(slice1.getPartitionPath());\n+    return slices.stream().map(slice -> new HoodieSliceInfo().newBuilder()\n+        .setPartitionPath(slice.getPartitionPath())\n+        .setFileId(slice.getFileId())\n+        .setDataFilePath(slice.getBaseFile().map(BaseFile::getPath).orElse(\"\"))", "originalCommit": "5071687bfd54c1645eb6770398290e9712eb3e0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcyODk3MA==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513728970", "bodyText": "Because this is avro, I'm not sure if Option would work. Changed it to null to match with compaction.", "author": "satishkotha", "createdAt": "2020-10-28T20:09:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyOTU5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "5630f181e6a0a87eef2759947a375a9a63581ab0", "chunk": "diff --git a/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java b/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java\nindex ee35a0a6d..3289cb61e 100644\n--- a/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java\n+++ b/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java\n\n@@ -40,6 +40,7 @@ import org.apache.log4j.Logger;\n import java.io.IOException;\n import java.util.AbstractMap;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUzMDAyNQ==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513530025", "bodyText": "Same question here for data file path empty", "author": "n3nash", "createdAt": "2020-10-28T15:17:50Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.util;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieClusteringStrategy;\n+import org.apache.hudi.avro.model.HoodieRequestedReplaceMetadata;\n+import org.apache.hudi.avro.model.HoodieSliceInfo;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.BaseFile;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.model.HoodieLogFile;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.TimelineMetadataUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Helper class to generate clustering plan from metadata.\n+ */\n+public class ClusteringUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(ClusteringUtils.class);\n+\n+  public static final String TOTAL_IO_READ_MB = \"TOTAL_IO_READ_MB\";\n+  public static final String TOTAL_LOG_FILE_SIZE = \"TOTAL_LOG_FILES_SIZE\";\n+  public static final String TOTAL_LOG_FILES = \"TOTAL_LOG_FILES\";\n+\n+  /**\n+   * Get all pending clustering plans along with their instants.\n+   */\n+  public static Stream<Pair<HoodieInstant, HoodieClusteringPlan>> getAllPendingClusteringPlans(\n+      HoodieTableMetaClient metaClient) {\n+    List<HoodieInstant> pendingReplaceInstants =\n+        metaClient.getActiveTimeline().filterPendingReplaceTimeline().getInstants().collect(Collectors.toList());\n+    return pendingReplaceInstants.stream().map(instant -> getClusteringPlan(metaClient, instant))\n+        .filter(Option::isPresent).map(Option::get);\n+  }\n+\n+  public static Option<Pair<HoodieInstant, HoodieClusteringPlan>> getClusteringPlan(HoodieTableMetaClient metaClient, HoodieInstant requestedReplaceInstant) {\n+    try {\n+      Option<byte[]> content = metaClient.getActiveTimeline().getInstantDetails(requestedReplaceInstant);\n+      if (!content.isPresent() || content.get().length == 0) {\n+        // few operations create requested file without any content. Assume these are not clustering\n+        LOG.warn(\"No content found in requested file for instant \" + requestedReplaceInstant);\n+        return Option.empty();\n+      }\n+      HoodieRequestedReplaceMetadata requestedReplaceMetadata = TimelineMetadataUtils.deserializeRequestedReplaceMetadta(content.get());\n+      if (WriteOperationType.CLUSTER.name().equals(requestedReplaceMetadata.getOperationType())) {\n+        return Option.of(Pair.of(requestedReplaceInstant, requestedReplaceMetadata.getClusteringPlan()));\n+      }\n+      return Option.empty();\n+    } catch (IOException e) {\n+      throw new HoodieIOException(\"Error reading clustering plan \" + requestedReplaceInstant.getTimestamp(), e);\n+    }\n+  }\n+\n+  /**\n+   * Get filegroups to pending clustering instant mapping for all pending clustering plans.\n+   * This includes all clustering operattions in 'requested' and 'inflight' states.\n+   */\n+  public static Map<HoodieFileGroupId, HoodieInstant> getAllFileGroupsInPendingClusteringPlans(\n+      HoodieTableMetaClient metaClient) {\n+    Stream<Pair<HoodieInstant, HoodieClusteringPlan>> pendingClusteringPlans = getAllPendingClusteringPlans(metaClient);\n+    Stream<Map.Entry<HoodieFileGroupId, HoodieInstant>> resultStream = pendingClusteringPlans.flatMap(clusteringPlan ->\n+        // get all filegroups in the plan\n+        getFileGroupEntriesInClusteringPlan(clusteringPlan.getLeft(), clusteringPlan.getRight()));\n+\n+    Map<HoodieFileGroupId, HoodieInstant> resultMap = resultStream.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    LOG.info(\"Found \" + resultMap.size() + \" files in pending clustering operations\");\n+    return resultMap;\n+  }\n+\n+  public static Stream<Pair<HoodieFileGroupId, HoodieInstant>> getFileGroupsInPendingClusteringInstant(\n+      HoodieInstant instant, HoodieClusteringPlan clusteringPlan) {\n+    Stream<HoodieFileGroupId> partitionToFileIdLists = clusteringPlan.getInputGroups().stream().flatMap(ClusteringUtils::getFileGroupsFromClusteringGroup);\n+    return partitionToFileIdLists.map(e -> Pair.of(e, instant));\n+  }\n+\n+  private static Stream<Map.Entry<HoodieFileGroupId, HoodieInstant>> getFileGroupEntriesInClusteringPlan(\n+      HoodieInstant instant, HoodieClusteringPlan clusteringPlan) {\n+    return getFileGroupsInPendingClusteringInstant(instant, clusteringPlan).map(entry ->\n+        new AbstractMap.SimpleEntry<>(entry.getLeft(), entry.getRight()));\n+  }\n+\n+  private static Stream<HoodieFileGroupId> getFileGroupsFromClusteringGroup(HoodieClusteringGroup group) {\n+    return group.getSlices().stream().map(slice -> new HoodieFileGroupId(slice.getPartitionPath(), slice.getFileId()));\n+  }\n+\n+  /**\n+   * Create clustering plan from input fileSliceGroups.\n+   */\n+  public static HoodieClusteringPlan createClusteringPlan(String strategyClassName,\n+                                                          Map<String, String> strategyParams,\n+                                                          List<FileSlice>[] fileSliceGroups) {\n+    List<HoodieClusteringGroup> clusteringGroups = new ArrayList<>();\n+    for (int i = 0; i < fileSliceGroups.length; i++) {\n+      List<FileSlice> fileSliceGroup = fileSliceGroups[i];\n+      Map<String, Double> groupMetrics = buildMetrics(fileSliceGroup);\n+      List<HoodieSliceInfo> sliceInfos = getFileSliceInfo(fileSliceGroup);\n+      clusteringGroups.add(HoodieClusteringGroup.newBuilder().setSlices(sliceInfos).setMetrics(groupMetrics).build());\n+    }\n+\n+    HoodieClusteringStrategy strategy = HoodieClusteringStrategy.newBuilder()\n+        .setStrategyClassName(strategyClassName).setStrategyParams(strategyParams)\n+        .build();\n+\n+    HoodieClusteringPlan plan = HoodieClusteringPlan.newBuilder()\n+        .setInputGroups(clusteringGroups)\n+        .setExtraMetadata(new HashMap<>())\n+        .setStrategy(strategy)\n+        .build();\n+\n+    return plan;\n+  }\n+\n+  private static List<HoodieSliceInfo> getFileSliceInfo(List<FileSlice> slices) {\n+    FileSlice slice1 = slices.get(0);\n+    System.out.println(slice1.getLogFiles().count());\n+    System.out.println(slice1.getBaseFile().get());\n+    System.out.println(slice1.getPartitionPath());\n+    return slices.stream().map(slice -> new HoodieSliceInfo().newBuilder()\n+        .setPartitionPath(slice.getPartitionPath())\n+        .setFileId(slice.getFileId())\n+        .setDataFilePath(slice.getBaseFile().map(BaseFile::getPath).orElse(\"\"))\n+        .setDeltaFilePaths(slice.getLogFiles().map(f -> f.getPath().getName()).collect(Collectors.toList()))\n+        .setBootstrapFilePath(slice.getBaseFile().map(bf -> bf.getBootstrapBaseFile().map(bbf -> bbf.getPath()).orElse(\"\")).orElse(\"\"))", "originalCommit": "5071687bfd54c1645eb6770398290e9712eb3e0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcyOTA3Mg==", "url": "https://github.com/apache/hudi/pull/2202#discussion_r513729072", "bodyText": "Changed it to null to match with compaction.", "author": "satishkotha", "createdAt": "2020-10-28T20:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUzMDAyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5630f181e6a0a87eef2759947a375a9a63581ab0", "chunk": "diff --git a/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java b/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java\nindex ee35a0a6d..3289cb61e 100644\n--- a/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java\n+++ b/hudi-common/src/main/java/org/apache/hudi/common/util/ClusteringUtils.java\n\n@@ -40,6 +40,7 @@ import org.apache.log4j.Logger;\n import java.io.IOException;\n import java.util.AbstractMap;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"oid": "5630f181e6a0a87eef2759947a375a9a63581ab0", "url": "https://github.com/apache/hudi/commit/5630f181e6a0a87eef2759947a375a9a63581ab0", "message": "[HUDI-1352] Add FileSystemView APIs to query pending clustering operations", "committedDate": "2020-10-28T20:08:05Z", "type": "forcePushed"}, {"oid": "fe11638146b83f0a4ba972bcc7417d868f1872c4", "url": "https://github.com/apache/hudi/commit/fe11638146b83f0a4ba972bcc7417d868f1872c4", "message": "[HUDI-1352] Add FileSystemView APIs to query pending clustering operations", "committedDate": "2020-10-28T20:14:52Z", "type": "forcePushed"}, {"oid": "d20e11d3e47be7af8a62d5c3f9cd0efa500adce3", "url": "https://github.com/apache/hudi/commit/d20e11d3e47be7af8a62d5c3f9cd0efa500adce3", "message": "[HUDI-1352] Add FileSystemView APIs to query pending clustering operations", "committedDate": "2020-10-28T23:26:31Z", "type": "forcePushed"}, {"oid": "6e6e5f471aec179891b8a74640c5559ff521f809", "url": "https://github.com/apache/hudi/commit/6e6e5f471aec179891b8a74640c5559ff521f809", "message": "[HUDI-1352] Add FileSystemView APIs to query pending clustering operations", "committedDate": "2020-11-05T04:09:14Z", "type": "forcePushed"}, {"oid": "5973890d4772603e729b3c1de3c3d87e4c5094f3", "url": "https://github.com/apache/hudi/commit/5973890d4772603e729b3c1de3c3d87e4c5094f3", "message": "[HUDI-1352] Add FileSystemView APIs to query pending clustering operations", "committedDate": "2020-11-05T04:12:30Z", "type": "commit"}, {"oid": "5973890d4772603e729b3c1de3c3d87e4c5094f3", "url": "https://github.com/apache/hudi/commit/5973890d4772603e729b3c1de3c3d87e4c5094f3", "message": "[HUDI-1352] Add FileSystemView APIs to query pending clustering operations", "committedDate": "2020-11-05T04:12:30Z", "type": "forcePushed"}]}