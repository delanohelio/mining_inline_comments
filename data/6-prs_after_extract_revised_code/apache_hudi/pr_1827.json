{"pr_number": 1827, "pr_title": "[HUDI-1089] Refactor hudi-client to support multi-engine", "pr_createdAt": "2020-07-14T11:56:30Z", "pr_url": "https://github.com/apache/hudi/pull/1827", "timeline": [{"oid": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "url": "https://github.com/apache/hudi/commit/9d7a51de66b0198df85c04d93d2e73ed5381714c", "message": "Renaming some Abstract* classes as Hoodie* to improve readability", "committedDate": "2020-10-01T16:13:53Z", "type": "commit"}, {"oid": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "url": "https://github.com/apache/hudi/commit/9d7a51de66b0198df85c04d93d2e73ed5381714c", "message": "Renaming some Abstract* classes as Hoodie* to improve readability", "committedDate": "2020-10-01T16:13:53Z", "type": "forcePushed"}, {"oid": "137da2b4ab862e16a48cfba84d56fc61ca762d69", "url": "https://github.com/apache/hudi/commit/137da2b4ab862e16a48cfba84d56fc61ca762d69", "message": "fix Unable to find driver bind address from spark config", "committedDate": "2020-10-01T18:21:52Z", "type": "commit"}, {"oid": "13795f5c1223424d44244e46acb0864b93ec403e", "url": "https://github.com/apache/hudi/commit/13795f5c1223424d44244e46acb0864b93ec403e", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-07-15T15:22:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwMjIwNg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r455702206", "bodyText": "The new style or the old style, which one is right?", "author": "yanghua", "createdAt": "2020-07-16T10:58:14Z", "path": "hudi-cli/src/main/java/org/apache/hudi/cli/commands/CompactionCommand.java", "diffHunk": "@@ -593,8 +592,8 @@ public String repairCompaction(\n     return output;\n   }\n \n-  private String getRenamesToBePrinted(List<RenameOpResult> res, Integer limit, String sortByField, boolean descending,\n-      boolean headerOnly, String operation) {\n+  private String getRenamesToBePrinted(List<BaseCompactionAdminClient.RenameOpResult> res, Integer limit, String sortByField, boolean descending,\n+                                       boolean headerOnly, String operation) {", "originalCommit": "13795f5c1223424d44244e46acb0864b93ec403e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzOTM4NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r456239385", "bodyText": "Hi, @yanghua thanks for your review. I am not sure which one is right either, I will roll back these style issues just to keep as same as before.", "author": "wangxianghu", "createdAt": "2020-07-17T06:14:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwMjIwNg=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-cli/src/main/java/org/apache/hudi/cli/commands/CompactionCommand.java b/hudi-cli/src/main/java/org/apache/hudi/cli/commands/CompactionCommand.java\nindex 481b54fb0..ffbf70e12 100644\n--- a/hudi-cli/src/main/java/org/apache/hudi/cli/commands/CompactionCommand.java\n+++ b/hudi-cli/src/main/java/org/apache/hudi/cli/commands/CompactionCommand.java\n\n@@ -592,8 +593,8 @@ public class CompactionCommand implements CommandMarker {\n     return output;\n   }\n \n-  private String getRenamesToBePrinted(List<BaseCompactionAdminClient.RenameOpResult> res, Integer limit, String sortByField, boolean descending,\n-                                       boolean headerOnly, String operation) {\n+  private String getRenamesToBePrinted(List<RenameOpResult> res, Integer limit, String sortByField, boolean descending,\n+      boolean headerOnly, String operation) {\n \n     Option<Boolean> result =\n         Option.fromJavaOptional(res.stream().map(r -> r.isExecuted() && r.isSuccess()).reduce(Boolean::logicalAnd));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwNTI1OA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r455705258", "bodyText": "Why do we need to change this class?", "author": "yanghua", "createdAt": "2020-07-16T11:04:11Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/storage/HoodieParquetWriter.java", "diffHunk": "@@ -40,7 +39,7 @@\n  * HoodieParquetWriter extends the ParquetWriter to help limit the size of underlying file. Provides a way to check if\n  * the current file can take more records with the <code>canWrite()</code>\n  */\n-public class HoodieParquetWriter<T extends HoodieRecordPayload, R extends IndexedRecord>\n+public class HoodieParquetWriter<R extends IndexedRecord>", "originalCommit": "13795f5c1223424d44244e46acb0864b93ec403e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI0NzcyMQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r456247721", "bodyText": "Why do we need to change this class?\n\nThe Generic \"T\" is useless in this class, and it causes some generic problems in the abstraction, so I removed it.", "author": "wangxianghu", "createdAt": "2020-07-17T06:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwNTI1OA=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/storage/HoodieParquetWriter.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/storage/HoodieParquetWriter.java\nindex 63082cb3b..166e2bc42 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/storage/HoodieParquetWriter.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/storage/HoodieParquetWriter.java\n\n@@ -39,7 +40,7 @@ import java.util.concurrent.atomic.AtomicLong;\n  * HoodieParquetWriter extends the ParquetWriter to help limit the size of underlying file. Provides a way to check if\n  * the current file can take more records with the <code>canWrite()</code>\n  */\n-public class HoodieParquetWriter<R extends IndexedRecord>\n+public class HoodieParquetWriter<T extends HoodieRecordPayload, R extends IndexedRecord>\n     extends ParquetWriter<IndexedRecord> implements HoodieFileWriter<R> {\n \n   private static AtomicLong recordIndex = new AtomicLong(1);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MDc1MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r456980751", "bodyText": "Just bump into this... Since this is a generic engine context, will it be better to use a generic name like engineConfig?", "author": "henrywu2019", "createdAt": "2020-07-20T01:04:42Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/common/HoodieEngineContext.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common;\n+\n+import org.apache.hudi.client.TaskContextSupplier;\n+import org.apache.hudi.common.config.SerializableConfiguration;\n+\n+/**\n+ * Base class contains the context information needed by the engine at runtime. It will be extended by different\n+ * engine implementation if needed.\n+ */\n+public class HoodieEngineContext {\n+  /**\n+   * A wrapped hadoop configuration which can be serialized.\n+   */\n+  private SerializableConfiguration hadoopConf;", "originalCommit": "88c6661e865945059f782880c395547c16ef1a1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEyNzAwNA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r457127004", "bodyText": "Just bump into this... Since this is a generic engine context, will it be better to use a generic name like engineConfig?\n\nHi, henry thanks for your review. This class holds more than config stuff(your can see its child class HoodieSparkEngineContext),  maybe context is better, WDYT\uff1f", "author": "wangxianghu", "createdAt": "2020-07-20T07:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MDc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEyODk4OA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r457128988", "bodyText": "", "author": "wangxianghu", "createdAt": "2020-07-20T07:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MDc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5ODQyNg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r457798426", "bodyText": "Oh...What I meant is at line 32 the name hadoopConf, not the class name, which implies hadoop. I bumped into this searching for Flink support from HUDI and this PR looks a big step moving in that direction. Thanks tons @Mathieu1124 and definitely @vinothchandar as well.", "author": "henrywu2019", "createdAt": "2020-07-21T02:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MDc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5Njk4Nw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484096987", "bodyText": "I am okay leaving it as hadoopConf given that's what we wrap. leave it you both :)", "author": "vinothchandar", "createdAt": "2020-09-06T17:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MDc1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/common/HoodieEngineContext.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/common/HoodieEngineContext.java\nsimilarity index 59%\nrename from hudi-client/hudi-client-common/src/main/java/org/apache/hudi/common/HoodieEngineContext.java\nrename to hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/common/HoodieEngineContext.java\nindex 9d49af531..f8d889640 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/common/HoodieEngineContext.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/common/HoodieEngineContext.java\n\n@@ -16,16 +16,24 @@\n  * limitations under the License.\n  */\n \n-package org.apache.hudi.common;\n+package org.apache.hudi.client.common;\n \n-import org.apache.hudi.client.TaskContextSupplier;\n import org.apache.hudi.common.config.SerializableConfiguration;\n+import org.apache.hudi.client.common.function.SerializableConsumer;\n+import org.apache.hudi.client.common.function.SerializableFunction;\n+import org.apache.hudi.client.common.function.SerializablePairFunction;\n+import org.apache.hudi.common.util.Option;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n \n /**\n  * Base class contains the context information needed by the engine at runtime. It will be extended by different\n  * engine implementation if needed.\n  */\n-public class HoodieEngineContext {\n+public abstract class HoodieEngineContext {\n+\n   /**\n    * A wrapped hadoop configuration which can be serialized.\n    */\n"}}, {"oid": "b30f9738a504ac28bdb30485b83a1313ee3ee248", "url": "https://github.com/apache/hudi/commit/b30f9738a504ac28bdb30485b83a1313ee3ee248", "message": "resolve conflicts", "committedDate": "2020-07-20T11:21:19Z", "type": "forcePushed"}, {"oid": "39db50b5e64666e7f688a83aa06e7096cdf8ce16", "url": "https://github.com/apache/hudi/commit/39db50b5e64666e7f688a83aa06e7096cdf8ce16", "message": "mv class to hudi-client-common", "committedDate": "2020-07-21T11:53:45Z", "type": "forcePushed"}, {"oid": "9fa51f49f38ef3b80fa391b27fc45d9d2d424ed2", "url": "https://github.com/apache/hudi/commit/9fa51f49f38ef3b80fa391b27fc45d9d2d424ed2", "message": "rebase master", "committedDate": "2020-07-22T15:34:37Z", "type": "forcePushed"}, {"oid": "c42bed02e73b74d730d489ebb0a8ce297d074517", "url": "https://github.com/apache/hudi/commit/c42bed02e73b74d730d489ebb0a8ce297d074517", "message": "rebase master", "committedDate": "2020-07-22T15:35:49Z", "type": "forcePushed"}, {"oid": "56dfec1d2da5b27397ee7821cd90aa3e81728f56", "url": "https://github.com/apache/hudi/commit/56dfec1d2da5b27397ee7821cd90aa3e81728f56", "message": "fix conflicts", "committedDate": "2020-07-30T15:31:03Z", "type": "forcePushed"}, {"oid": "b5c1ad3daaf17404d22e52efd54687687dc9d1a2", "url": "https://github.com/apache/hudi/commit/b5c1ad3daaf17404d22e52efd54687687dc9d1a2", "message": "fix conflicts", "committedDate": "2020-08-19T15:49:09Z", "type": "forcePushed"}, {"oid": "85a8457d29d315c4c7f1766e46ad4fca5ab211e9", "url": "https://github.com/apache/hudi/commit/85a8457d29d315c4c7f1766e46ad4fca5ab211e9", "message": "[HUDI-1089] [WIP]Refactor hudi-client to support multi-engine", "committedDate": "2020-08-20T12:39:10Z", "type": "forcePushed"}, {"oid": "2d9cc47260d6f35584db45b75261fbbd343c7b0c", "url": "https://github.com/apache/hudi/commit/2d9cc47260d6f35584db45b75261fbbd343c7b0c", "message": "finish index refactor", "committedDate": "2020-08-21T03:32:22Z", "type": "forcePushed"}, {"oid": "e7e8cb85fc7ee38bcbc56a6c2479931d4fde4fcb", "url": "https://github.com/apache/hudi/commit/e7e8cb85fc7ee38bcbc56a6c2479931d4fde4fcb", "message": "finish index refactor", "committedDate": "2020-08-21T07:21:35Z", "type": "forcePushed"}, {"oid": "b8d06e925943ee02d5e19ae89256b5aa404e197d", "url": "https://github.com/apache/hudi/commit/b8d06e925943ee02d5e19ae89256b5aa404e197d", "message": "rebase master WIP", "committedDate": "2020-08-21T10:13:31Z", "type": "forcePushed"}, {"oid": "958dac8b6c33b0ee46645c901f0ee0fafcd0f846", "url": "https://github.com/apache/hudi/commit/958dac8b6c33b0ee46645c901f0ee0fafcd0f846", "message": "rebase master WIP", "committedDate": "2020-08-23T03:58:42Z", "type": "forcePushed"}, {"oid": "009fae91da08a60624f054cebff04d5c59077251", "url": "https://github.com/apache/hudi/commit/009fae91da08a60624f054cebff04d5c59077251", "message": "abstract Helper class and write client", "committedDate": "2020-08-24T13:06:54Z", "type": "forcePushed"}, {"oid": "1c7d03a43097ffecf404dda29dd5aaa74fde95ca", "url": "https://github.com/apache/hudi/commit/1c7d03a43097ffecf404dda29dd5aaa74fde95ca", "message": "finish most source class", "committedDate": "2020-08-27T15:31:57Z", "type": "forcePushed"}, {"oid": "48cf8c614f745ec91612cf1ba04063838891d8e5", "url": "https://github.com/apache/hudi/commit/48cf8c614f745ec91612cf1ba04063838891d8e5", "message": "rebase master", "committedDate": "2020-08-30T04:33:48Z", "type": "forcePushed"}, {"oid": "e755bf5d58817c627aeda63c504902ef504b9de5", "url": "https://github.com/apache/hudi/commit/e755bf5d58817c627aeda63c504902ef504b9de5", "message": "Make it compilable", "committedDate": "2020-08-30T11:46:09Z", "type": "forcePushed"}, {"oid": "74a0af4ffab2de6032e90ac31e0aae3787823a86", "url": "https://github.com/apache/hudi/commit/74a0af4ffab2de6032e90ac31e0aae3787823a86", "message": "Make it compilable", "committedDate": "2020-08-30T11:48:13Z", "type": "forcePushed"}, {"oid": "cd697a95bafc5ae0566a8cacbe8c4a93c053a91f", "url": "https://github.com/apache/hudi/commit/cd697a95bafc5ae0566a8cacbe8c4a93c053a91f", "message": "Make it compilable", "committedDate": "2020-08-30T12:14:27Z", "type": "forcePushed"}, {"oid": "57660f91ea21db5d011af54511abbe9a2c75b5c7", "url": "https://github.com/apache/hudi/commit/57660f91ea21db5d011af54511abbe9a2c75b5c7", "message": "Make it compilable", "committedDate": "2020-08-30T16:18:15Z", "type": "forcePushed"}, {"oid": "0808014b1b90aadcef14ccb8907b4215ccafe586", "url": "https://github.com/apache/hudi/commit/0808014b1b90aadcef14ccb8907b4215ccafe586", "message": "Make it compilable", "committedDate": "2020-08-31T09:43:57Z", "type": "forcePushed"}, {"oid": "5d6f909a4006cfb8c54b6ed70baa2256077cab4e", "url": "https://github.com/apache/hudi/commit/5d6f909a4006cfb8c54b6ed70baa2256077cab4e", "message": "Make it compilable", "committedDate": "2020-08-31T15:04:30Z", "type": "forcePushed"}, {"oid": "4d71c51ba6a1dd2401473a668565b965b37505a3", "url": "https://github.com/apache/hudi/commit/4d71c51ba6a1dd2401473a668565b965b37505a3", "message": "rebase master", "committedDate": "2020-08-31T15:57:40Z", "type": "forcePushed"}, {"oid": "9d83635dd77d77d003946c6d39c5aaeb64c975a4", "url": "https://github.com/apache/hudi/commit/9d83635dd77d77d003946c6d39c5aaeb64c975a4", "message": "rebase master", "committedDate": "2020-08-31T16:50:36Z", "type": "forcePushed"}, {"oid": "a7b3a4e268842d87ebace4c03d7f12dd3be1f103", "url": "https://github.com/apache/hudi/commit/a7b3a4e268842d87ebace4c03d7f12dd3be1f103", "message": "rebase master", "committedDate": "2020-09-01T16:42:44Z", "type": "forcePushed"}, {"oid": "93fa69ebbc770c191c6834330e0bcb2898eba88b", "url": "https://github.com/apache/hudi/commit/93fa69ebbc770c191c6834330e0bcb2898eba88b", "message": "rebase master", "committedDate": "2020-09-01T16:51:21Z", "type": "forcePushed"}, {"oid": "c51ef79e9c7fb5ff47558d701b37c73b16499834", "url": "https://github.com/apache/hudi/commit/c51ef79e9c7fb5ff47558d701b37c73b16499834", "message": "rebase master", "committedDate": "2020-09-01T17:40:25Z", "type": "forcePushed"}, {"oid": "abf3c654665362be70a78392f638d0ae7ad7bc6d", "url": "https://github.com/apache/hudi/commit/abf3c654665362be70a78392f638d0ae7ad7bc6d", "message": "rebase master", "committedDate": "2020-09-02T15:06:58Z", "type": "forcePushed"}, {"oid": "3901bcbcc191319a8cd7394f0f058b6c5e28d566", "url": "https://github.com/apache/hudi/commit/3901bcbcc191319a8cd7394f0f058b6c5e28d566", "message": "rebase master", "committedDate": "2020-09-03T15:27:15Z", "type": "forcePushed"}, {"oid": "7902ca9485788a5eada5e8f2b0bd0b0389ad90a3", "url": "https://github.com/apache/hudi/commit/7902ca9485788a5eada5e8f2b0bd0b0389ad90a3", "message": "rebase master", "committedDate": "2020-09-05T09:48:06Z", "type": "forcePushed"}, {"oid": "3e637ea42d9228eacbb4d76bb9f551334a05f01d", "url": "https://github.com/apache/hudi/commit/3e637ea42d9228eacbb4d76bb9f551334a05f01d", "message": "rebase master", "committedDate": "2020-09-05T09:52:53Z", "type": "forcePushed"}, {"oid": "32d00412e619964df8ded5c8bd273d941f23acf8", "url": "https://github.com/apache/hudi/commit/32d00412e619964df8ded5c8bd273d941f23acf8", "message": "rebase master", "committedDate": "2020-09-05T10:18:42Z", "type": "forcePushed"}, {"oid": "e13408780ee7dfd29680551d397ecdc0b4d6505f", "url": "https://github.com/apache/hudi/commit/e13408780ee7dfd29680551d397ecdc0b4d6505f", "message": "rebase master", "committedDate": "2020-09-06T03:52:05Z", "type": "forcePushed"}, {"oid": "f16ded111e1cef45443da8df30c3d060a82758e8", "url": "https://github.com/apache/hudi/commit/f16ded111e1cef45443da8df30c3d060a82758e8", "message": "rebase master", "committedDate": "2020-09-06T05:02:44Z", "type": "forcePushed"}, {"oid": "71ad86f3a89e42fabbcb6d0ebb2734113c8c2323", "url": "https://github.com/apache/hudi/commit/71ad86f3a89e42fabbcb6d0ebb2734113c8c2323", "message": "rebase master", "committedDate": "2020-09-06T05:59:51Z", "type": "forcePushed"}, {"oid": "36573ef00199fc7648c2cbf543f811f1697306f2", "url": "https://github.com/apache/hudi/commit/36573ef00199fc7648c2cbf543f811f1697306f2", "message": "rebase master", "committedDate": "2020-09-06T13:19:56Z", "type": "forcePushed"}, {"oid": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "url": "https://github.com/apache/hudi/commit/28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "message": "rebase master", "committedDate": "2020-09-06T14:29:42Z", "type": "forcePushed"}, {"oid": "2348f73b4a270e4d04d2f67f9d7bd9691391b569", "url": "https://github.com/apache/hudi/commit/2348f73b4a270e4d04d2f67f9d7bd9691391b569", "message": "rebase master", "committedDate": "2020-09-06T15:41:07Z", "type": "forcePushed"}, {"oid": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "url": "https://github.com/apache/hudi/commit/ac3339704c703741f9ff50f2d96019cef2d2c72b", "message": "rebase master", "committedDate": "2020-09-06T16:35:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5MTAwNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r483291007", "bodyText": "nit: extra line.", "author": "vinothchandar", "createdAt": "2020-09-03T22:41:18Z", "path": "hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestArchivedCommitsCommand.java", "diffHunk": "@@ -92,8 +92,9 @@ public void init() throws IOException {\n     metaClient.getActiveTimeline().reload().getAllCommitsTimeline().filterCompletedInstants();\n \n     // archive\n-    HoodieTimelineArchiveLog archiveLog = new HoodieTimelineArchiveLog(cfg, hadoopConf);\n-    archiveLog.archiveIfRequired(jsc);\n+", "originalCommit": "3901bcbcc191319a8cd7394f0f058b6c5e28d566", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestArchivedCommitsCommand.java b/hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestArchivedCommitsCommand.java\nindex 4d86da320..5c27636da 100644\n--- a/hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestArchivedCommitsCommand.java\n+++ b/hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestArchivedCommitsCommand.java\n\n@@ -92,8 +93,8 @@ public class TestArchivedCommitsCommand extends AbstractShellIntegrationTest {\n     metaClient.getActiveTimeline().reload().getAllCommitsTimeline().filterCompletedInstants();\n \n     // archive\n-\n-    HoodieSparkTimelineArchiveLog archiveLog = new HoodieSparkTimelineArchiveLog(cfg, context);\n+    HoodieSparkTable table = HoodieSparkTable.create(cfg, context, metaClient);\n+    HoodieTimelineArchiveLog archiveLog = new HoodieTimelineArchiveLog(cfg, table);\n     archiveLog.archiveIfRequired(context);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5MTcwNQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r483291705", "bodyText": "typo: async", "author": "vinothchandar", "createdAt": "2020-09-03T22:43:39Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/asyc/AbstractAsyncService.java", "diffHunk": "@@ -16,7 +16,7 @@\n  * limitations under the License.\n  */\n \n-package org.apache.hudi.async;\n+package org.apache.hudi.asyc;", "originalCommit": "3901bcbcc191319a8cd7394f0f058b6c5e28d566", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgxNTEwNA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484815104", "bodyText": "done", "author": "wangxianghu", "createdAt": "2020-09-08T10:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5MTcwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/asyc/AbstractAsyncService.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/async/HoodieAsyncService.java\nsimilarity index 94%\nrename from hudi-client/hudi-client-common/src/main/java/org/apache/hudi/asyc/AbstractAsyncService.java\nrename to hudi-client/hudi-client-common/src/main/java/org/apache/hudi/async/HoodieAsyncService.java\nindex f957cd58f..32dd04272 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/asyc/AbstractAsyncService.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/async/HoodieAsyncService.java\n\n@@ -16,7 +16,7 @@\n  * limitations under the License.\n  */\n \n-package org.apache.hudi.asyc;\n+package org.apache.hudi.async;\n \n import org.apache.hudi.common.util.collection.Pair;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MjkzNg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484082936", "bodyText": "not sure if this is right. index must be not be needed at the the write client level.", "author": "vinothchandar", "createdAt": "2020-09-06T15:25:44Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -18,120 +18,195 @@\n \n package org.apache.hudi.client;\n \n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n import org.apache.hudi.avro.model.HoodieCleanMetadata;\n import org.apache.hudi.avro.model.HoodieCompactionPlan;\n import org.apache.hudi.avro.model.HoodieRestoreMetadata;\n import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n-import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.callback.HoodieWriteCommitCallback;\n+import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n+import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.model.HoodieWriteStat;\n import org.apache.hudi.common.model.WriteOperationType;\n import org.apache.hudi.common.table.HoodieTableMetaClient;\n import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n import org.apache.hudi.common.table.timeline.HoodieInstant;\n-import org.apache.hudi.common.table.timeline.HoodieInstant.State;\n import org.apache.hudi.common.table.timeline.HoodieTimeline;\n import org.apache.hudi.common.util.Option;\n import org.apache.hudi.common.util.ValidationUtils;\n-import org.apache.hudi.config.HoodieCompactionConfig;\n import org.apache.hudi.config.HoodieWriteConfig;\n+\n import org.apache.hudi.exception.HoodieCommitException;\n import org.apache.hudi.exception.HoodieIOException;\n import org.apache.hudi.exception.HoodieRestoreException;\n import org.apache.hudi.exception.HoodieRollbackException;\n import org.apache.hudi.exception.HoodieSavepointException;\n import org.apache.hudi.index.HoodieIndex;\n import org.apache.hudi.metrics.HoodieMetrics;\n-import org.apache.hudi.table.HoodieTable;\n-import org.apache.hudi.table.HoodieTimelineArchiveLog;\n-import org.apache.hudi.table.MarkerFiles;\n import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieTable;\n import org.apache.hudi.table.action.HoodieWriteMetadata;\n-import org.apache.hudi.table.action.compact.CompactHelpers;\n import org.apache.hudi.table.action.savepoint.SavepointHelpers;\n-\n-import com.codahale.metrics.Timer;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n-import org.apache.spark.SparkConf;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n import java.text.ParseException;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n /**\n- * Hoodie Write Client helps you build tables on HDFS [insert()] and then perform efficient mutations on an HDFS\n- * table [upsert()]\n- * <p>\n- * Note that, at any given time, there can only be one Spark job performing these operations on a Hoodie table.\n+ * Abstract Write Client providing functionality for performing commit, index updates and rollback\n+ * Reused for regular write operations like upsert/insert/bulk-insert.. as well as bootstrap\n+ *\n+ * @param <T> Sub type of HoodieRecordPayload\n+ * @param <I> Type of inputs\n+ * @param <K> Type of keys\n+ * @param <O> Type of outputs\n+ * @param <P> Type of record position [Key, Option[partitionPath, fileID]] in hoodie table\n  */\n-public class HoodieWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T> {\n-\n+public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I, K, O, P> extends AbstractHoodieClient {\n   private static final long serialVersionUID = 1L;\n-  private static final Logger LOG = LogManager.getLogger(HoodieWriteClient.class);\n-  private static final String LOOKUP_STR = \"lookup\";\n-  private final boolean rollbackPending;\n-  private final transient HoodieMetrics metrics;\n-  private transient Timer.Context compactionTimer;\n+  private static final Logger LOG = LogManager.getLogger(AbstractHoodieWriteClient.class);\n+\n+  protected final transient HoodieMetrics metrics;\n+  private final transient HoodieIndex<T, I, K, O, P> index;", "originalCommit": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\nindex e1f872076..0f35e270e 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n\n@@ -27,8 +27,8 @@ import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n import org.apache.hudi.callback.HoodieWriteCommitCallback;\n import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n-import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n-import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MzA3MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484083071", "bodyText": "can we move all the static members to the top, like how it was before.", "author": "vinothchandar", "createdAt": "2020-09-06T15:27:01Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -18,120 +18,195 @@\n \n package org.apache.hudi.client;\n \n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n import org.apache.hudi.avro.model.HoodieCleanMetadata;\n import org.apache.hudi.avro.model.HoodieCompactionPlan;\n import org.apache.hudi.avro.model.HoodieRestoreMetadata;\n import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n-import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.callback.HoodieWriteCommitCallback;\n+import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n+import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.model.HoodieWriteStat;\n import org.apache.hudi.common.model.WriteOperationType;\n import org.apache.hudi.common.table.HoodieTableMetaClient;\n import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n import org.apache.hudi.common.table.timeline.HoodieInstant;\n-import org.apache.hudi.common.table.timeline.HoodieInstant.State;\n import org.apache.hudi.common.table.timeline.HoodieTimeline;\n import org.apache.hudi.common.util.Option;\n import org.apache.hudi.common.util.ValidationUtils;\n-import org.apache.hudi.config.HoodieCompactionConfig;\n import org.apache.hudi.config.HoodieWriteConfig;\n+\n import org.apache.hudi.exception.HoodieCommitException;\n import org.apache.hudi.exception.HoodieIOException;\n import org.apache.hudi.exception.HoodieRestoreException;\n import org.apache.hudi.exception.HoodieRollbackException;\n import org.apache.hudi.exception.HoodieSavepointException;\n import org.apache.hudi.index.HoodieIndex;\n import org.apache.hudi.metrics.HoodieMetrics;\n-import org.apache.hudi.table.HoodieTable;\n-import org.apache.hudi.table.HoodieTimelineArchiveLog;\n-import org.apache.hudi.table.MarkerFiles;\n import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieTable;\n import org.apache.hudi.table.action.HoodieWriteMetadata;\n-import org.apache.hudi.table.action.compact.CompactHelpers;\n import org.apache.hudi.table.action.savepoint.SavepointHelpers;\n-\n-import com.codahale.metrics.Timer;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n-import org.apache.spark.SparkConf;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n import java.text.ParseException;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n /**\n- * Hoodie Write Client helps you build tables on HDFS [insert()] and then perform efficient mutations on an HDFS\n- * table [upsert()]\n- * <p>\n- * Note that, at any given time, there can only be one Spark job performing these operations on a Hoodie table.\n+ * Abstract Write Client providing functionality for performing commit, index updates and rollback\n+ * Reused for regular write operations like upsert/insert/bulk-insert.. as well as bootstrap\n+ *\n+ * @param <T> Sub type of HoodieRecordPayload\n+ * @param <I> Type of inputs\n+ * @param <K> Type of keys\n+ * @param <O> Type of outputs\n+ * @param <P> Type of record position [Key, Option[partitionPath, fileID]] in hoodie table\n  */\n-public class HoodieWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T> {\n-\n+public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I, K, O, P> extends AbstractHoodieClient {\n   private static final long serialVersionUID = 1L;\n-  private static final Logger LOG = LogManager.getLogger(HoodieWriteClient.class);\n-  private static final String LOOKUP_STR = \"lookup\";\n-  private final boolean rollbackPending;\n-  private final transient HoodieMetrics metrics;\n-  private transient Timer.Context compactionTimer;\n+  private static final Logger LOG = LogManager.getLogger(AbstractHoodieWriteClient.class);\n+\n+  protected final transient HoodieMetrics metrics;\n+  private final transient HoodieIndex<T, I, K, O, P> index;\n+\n+  protected transient Timer.Context writeContext = null;\n+  private transient WriteOperationType operationType;\n+  private transient HoodieWriteCommitCallback commitCallback;\n+\n+  protected static final String LOOKUP_STR = \"lookup\";", "originalCommit": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\nindex e1f872076..0f35e270e 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n\n@@ -27,8 +27,8 @@ import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n import org.apache.hudi.callback.HoodieWriteCommitCallback;\n import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n-import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n-import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MzIxNg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484083216", "bodyText": "why did this constructor have to change", "author": "vinothchandar", "createdAt": "2020-09-06T15:28:40Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -18,120 +18,195 @@\n \n package org.apache.hudi.client;\n \n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n import org.apache.hudi.avro.model.HoodieCleanMetadata;\n import org.apache.hudi.avro.model.HoodieCompactionPlan;\n import org.apache.hudi.avro.model.HoodieRestoreMetadata;\n import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n-import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.callback.HoodieWriteCommitCallback;\n+import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n+import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.model.HoodieWriteStat;\n import org.apache.hudi.common.model.WriteOperationType;\n import org.apache.hudi.common.table.HoodieTableMetaClient;\n import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n import org.apache.hudi.common.table.timeline.HoodieInstant;\n-import org.apache.hudi.common.table.timeline.HoodieInstant.State;\n import org.apache.hudi.common.table.timeline.HoodieTimeline;\n import org.apache.hudi.common.util.Option;\n import org.apache.hudi.common.util.ValidationUtils;\n-import org.apache.hudi.config.HoodieCompactionConfig;\n import org.apache.hudi.config.HoodieWriteConfig;\n+\n import org.apache.hudi.exception.HoodieCommitException;\n import org.apache.hudi.exception.HoodieIOException;\n import org.apache.hudi.exception.HoodieRestoreException;\n import org.apache.hudi.exception.HoodieRollbackException;\n import org.apache.hudi.exception.HoodieSavepointException;\n import org.apache.hudi.index.HoodieIndex;\n import org.apache.hudi.metrics.HoodieMetrics;\n-import org.apache.hudi.table.HoodieTable;\n-import org.apache.hudi.table.HoodieTimelineArchiveLog;\n-import org.apache.hudi.table.MarkerFiles;\n import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieTable;\n import org.apache.hudi.table.action.HoodieWriteMetadata;\n-import org.apache.hudi.table.action.compact.CompactHelpers;\n import org.apache.hudi.table.action.savepoint.SavepointHelpers;\n-\n-import com.codahale.metrics.Timer;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n-import org.apache.spark.SparkConf;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n import java.text.ParseException;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n /**\n- * Hoodie Write Client helps you build tables on HDFS [insert()] and then perform efficient mutations on an HDFS\n- * table [upsert()]\n- * <p>\n- * Note that, at any given time, there can only be one Spark job performing these operations on a Hoodie table.\n+ * Abstract Write Client providing functionality for performing commit, index updates and rollback\n+ * Reused for regular write operations like upsert/insert/bulk-insert.. as well as bootstrap\n+ *\n+ * @param <T> Sub type of HoodieRecordPayload\n+ * @param <I> Type of inputs\n+ * @param <K> Type of keys\n+ * @param <O> Type of outputs\n+ * @param <P> Type of record position [Key, Option[partitionPath, fileID]] in hoodie table\n  */\n-public class HoodieWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T> {\n-\n+public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I, K, O, P> extends AbstractHoodieClient {\n   private static final long serialVersionUID = 1L;\n-  private static final Logger LOG = LogManager.getLogger(HoodieWriteClient.class);\n-  private static final String LOOKUP_STR = \"lookup\";\n-  private final boolean rollbackPending;\n-  private final transient HoodieMetrics metrics;\n-  private transient Timer.Context compactionTimer;\n+  private static final Logger LOG = LogManager.getLogger(AbstractHoodieWriteClient.class);\n+\n+  protected final transient HoodieMetrics metrics;\n+  private final transient HoodieIndex<T, I, K, O, P> index;\n+\n+  protected transient Timer.Context writeContext = null;\n+  private transient WriteOperationType operationType;\n+  private transient HoodieWriteCommitCallback commitCallback;\n+\n+  protected static final String LOOKUP_STR = \"lookup\";\n+  protected final boolean rollbackPending;\n+  protected transient Timer.Context compactionTimer;\n   private transient AsyncCleanerService asyncCleanerService;\n \n+  public void setOperationType(WriteOperationType operationType) {\n+    this.operationType = operationType;\n+  }\n+\n+  public WriteOperationType getOperationType() {\n+    return this.operationType;\n+  }\n+\n   /**\n    * Create a write client, without cleaning up failed/inflight commits.\n    *\n-   * @param jsc Java Spark Context\n+   * @param context      Java Spark Context\n    * @param clientConfig instance of HoodieWriteConfig\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig clientConfig) {\n-    this(jsc, clientConfig, false);\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig clientConfig) {\n+    this(context, clientConfig, false);\n   }\n \n   /**\n    * Create a write client, with new hudi index.\n    *\n-   * @param jsc Java Spark Context\n-   * @param writeConfig instance of HoodieWriteConfig\n+   * @param context         HoodieEngineContext\n+   * @param writeConfig     instance of HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n-    this(jsc, writeConfig, rollbackPending, HoodieIndex.createIndex(writeConfig));\n-  }\n-\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending, HoodieIndex index) {\n-    this(jsc, writeConfig, rollbackPending, index, Option.empty());\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n+    this(context, writeConfig, rollbackPending, Option.empty());\n   }\n \n   /**\n-   *  Create a write client, allows to specify all parameters.\n+   * Create a write client, allows to specify all parameters.\n    *\n-   * @param jsc Java Spark Context\n-   * @param writeConfig instance of HoodieWriteConfig\n+   * @param context         HoodieEngineContext\n+   * @param writeConfig     instance of HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    * @param timelineService Timeline Service that runs as part of write client.\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending,\n-      HoodieIndex index, Option<EmbeddedTimelineService> timelineService) {\n-    super(jsc, index, writeConfig, timelineService);\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending,\n+                                   Option<BaseEmbeddedTimelineService> timelineService) {\n+    super(context, writeConfig, timelineService);\n     this.metrics = new HoodieMetrics(config, config.getTableName());\n     this.rollbackPending = rollbackPending;\n+    this.index = createIndex(writeConfig);", "originalCommit": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NzY1MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494747651", "bodyText": "Understood", "author": "vinothchandar", "createdAt": "2020-09-25T04:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MzIxNg=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\nindex e1f872076..0f35e270e 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n\n@@ -27,8 +27,8 @@ import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n import org.apache.hudi.callback.HoodieWriteCommitCallback;\n import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n-import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n-import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MzI3NA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484083274", "bodyText": "same point, not sure if this is correct.", "author": "vinothchandar", "createdAt": "2020-09-06T15:29:19Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -18,120 +18,195 @@\n \n package org.apache.hudi.client;\n \n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n import org.apache.hudi.avro.model.HoodieCleanMetadata;\n import org.apache.hudi.avro.model.HoodieCompactionPlan;\n import org.apache.hudi.avro.model.HoodieRestoreMetadata;\n import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n-import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.callback.HoodieWriteCommitCallback;\n+import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n+import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.model.HoodieWriteStat;\n import org.apache.hudi.common.model.WriteOperationType;\n import org.apache.hudi.common.table.HoodieTableMetaClient;\n import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n import org.apache.hudi.common.table.timeline.HoodieInstant;\n-import org.apache.hudi.common.table.timeline.HoodieInstant.State;\n import org.apache.hudi.common.table.timeline.HoodieTimeline;\n import org.apache.hudi.common.util.Option;\n import org.apache.hudi.common.util.ValidationUtils;\n-import org.apache.hudi.config.HoodieCompactionConfig;\n import org.apache.hudi.config.HoodieWriteConfig;\n+\n import org.apache.hudi.exception.HoodieCommitException;\n import org.apache.hudi.exception.HoodieIOException;\n import org.apache.hudi.exception.HoodieRestoreException;\n import org.apache.hudi.exception.HoodieRollbackException;\n import org.apache.hudi.exception.HoodieSavepointException;\n import org.apache.hudi.index.HoodieIndex;\n import org.apache.hudi.metrics.HoodieMetrics;\n-import org.apache.hudi.table.HoodieTable;\n-import org.apache.hudi.table.HoodieTimelineArchiveLog;\n-import org.apache.hudi.table.MarkerFiles;\n import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieTable;\n import org.apache.hudi.table.action.HoodieWriteMetadata;\n-import org.apache.hudi.table.action.compact.CompactHelpers;\n import org.apache.hudi.table.action.savepoint.SavepointHelpers;\n-\n-import com.codahale.metrics.Timer;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n-import org.apache.spark.SparkConf;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n import java.text.ParseException;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n /**\n- * Hoodie Write Client helps you build tables on HDFS [insert()] and then perform efficient mutations on an HDFS\n- * table [upsert()]\n- * <p>\n- * Note that, at any given time, there can only be one Spark job performing these operations on a Hoodie table.\n+ * Abstract Write Client providing functionality for performing commit, index updates and rollback\n+ * Reused for regular write operations like upsert/insert/bulk-insert.. as well as bootstrap\n+ *\n+ * @param <T> Sub type of HoodieRecordPayload\n+ * @param <I> Type of inputs\n+ * @param <K> Type of keys\n+ * @param <O> Type of outputs\n+ * @param <P> Type of record position [Key, Option[partitionPath, fileID]] in hoodie table\n  */\n-public class HoodieWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T> {\n-\n+public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I, K, O, P> extends AbstractHoodieClient {\n   private static final long serialVersionUID = 1L;\n-  private static final Logger LOG = LogManager.getLogger(HoodieWriteClient.class);\n-  private static final String LOOKUP_STR = \"lookup\";\n-  private final boolean rollbackPending;\n-  private final transient HoodieMetrics metrics;\n-  private transient Timer.Context compactionTimer;\n+  private static final Logger LOG = LogManager.getLogger(AbstractHoodieWriteClient.class);\n+\n+  protected final transient HoodieMetrics metrics;\n+  private final transient HoodieIndex<T, I, K, O, P> index;\n+\n+  protected transient Timer.Context writeContext = null;\n+  private transient WriteOperationType operationType;\n+  private transient HoodieWriteCommitCallback commitCallback;\n+\n+  protected static final String LOOKUP_STR = \"lookup\";\n+  protected final boolean rollbackPending;\n+  protected transient Timer.Context compactionTimer;\n   private transient AsyncCleanerService asyncCleanerService;\n \n+  public void setOperationType(WriteOperationType operationType) {\n+    this.operationType = operationType;\n+  }\n+\n+  public WriteOperationType getOperationType() {\n+    return this.operationType;\n+  }\n+\n   /**\n    * Create a write client, without cleaning up failed/inflight commits.\n    *\n-   * @param jsc Java Spark Context\n+   * @param context      Java Spark Context\n    * @param clientConfig instance of HoodieWriteConfig\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig clientConfig) {\n-    this(jsc, clientConfig, false);\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig clientConfig) {\n+    this(context, clientConfig, false);\n   }\n \n   /**\n    * Create a write client, with new hudi index.\n    *\n-   * @param jsc Java Spark Context\n-   * @param writeConfig instance of HoodieWriteConfig\n+   * @param context         HoodieEngineContext\n+   * @param writeConfig     instance of HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n-    this(jsc, writeConfig, rollbackPending, HoodieIndex.createIndex(writeConfig));\n-  }\n-\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending, HoodieIndex index) {\n-    this(jsc, writeConfig, rollbackPending, index, Option.empty());\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n+    this(context, writeConfig, rollbackPending, Option.empty());\n   }\n \n   /**\n-   *  Create a write client, allows to specify all parameters.\n+   * Create a write client, allows to specify all parameters.\n    *\n-   * @param jsc Java Spark Context\n-   * @param writeConfig instance of HoodieWriteConfig\n+   * @param context         HoodieEngineContext\n+   * @param writeConfig     instance of HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    * @param timelineService Timeline Service that runs as part of write client.\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending,\n-      HoodieIndex index, Option<EmbeddedTimelineService> timelineService) {\n-    super(jsc, index, writeConfig, timelineService);\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending,\n+                                   Option<BaseEmbeddedTimelineService> timelineService) {\n+    super(context, writeConfig, timelineService);\n     this.metrics = new HoodieMetrics(config, config.getTableName());\n     this.rollbackPending = rollbackPending;\n+    this.index = createIndex(writeConfig);\n   }\n \n+  protected abstract HoodieIndex<T, I, K, O, P> createIndex(HoodieWriteConfig writeConfig);", "originalCommit": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\nindex e1f872076..0f35e270e 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n\n@@ -27,8 +27,8 @@ import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n import org.apache.hudi.callback.HoodieWriteCommitCallback;\n import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n-import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n-import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MzQ0Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484083442", "bodyText": "guessing this is all moved to spark client now?", "author": "vinothchandar", "createdAt": "2020-09-06T15:30:50Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -18,120 +18,195 @@\n \n package org.apache.hudi.client;\n \n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n import org.apache.hudi.avro.model.HoodieCleanMetadata;\n import org.apache.hudi.avro.model.HoodieCompactionPlan;\n import org.apache.hudi.avro.model.HoodieRestoreMetadata;\n import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n-import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.callback.HoodieWriteCommitCallback;\n+import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n+import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.model.HoodieWriteStat;\n import org.apache.hudi.common.model.WriteOperationType;\n import org.apache.hudi.common.table.HoodieTableMetaClient;\n import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n import org.apache.hudi.common.table.timeline.HoodieInstant;\n-import org.apache.hudi.common.table.timeline.HoodieInstant.State;\n import org.apache.hudi.common.table.timeline.HoodieTimeline;\n import org.apache.hudi.common.util.Option;\n import org.apache.hudi.common.util.ValidationUtils;\n-import org.apache.hudi.config.HoodieCompactionConfig;\n import org.apache.hudi.config.HoodieWriteConfig;\n+\n import org.apache.hudi.exception.HoodieCommitException;\n import org.apache.hudi.exception.HoodieIOException;\n import org.apache.hudi.exception.HoodieRestoreException;\n import org.apache.hudi.exception.HoodieRollbackException;\n import org.apache.hudi.exception.HoodieSavepointException;\n import org.apache.hudi.index.HoodieIndex;\n import org.apache.hudi.metrics.HoodieMetrics;\n-import org.apache.hudi.table.HoodieTable;\n-import org.apache.hudi.table.HoodieTimelineArchiveLog;\n-import org.apache.hudi.table.MarkerFiles;\n import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieTable;\n import org.apache.hudi.table.action.HoodieWriteMetadata;\n-import org.apache.hudi.table.action.compact.CompactHelpers;\n import org.apache.hudi.table.action.savepoint.SavepointHelpers;\n-\n-import com.codahale.metrics.Timer;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n-import org.apache.spark.SparkConf;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n import java.text.ParseException;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n /**\n- * Hoodie Write Client helps you build tables on HDFS [insert()] and then perform efficient mutations on an HDFS\n- * table [upsert()]\n- * <p>\n- * Note that, at any given time, there can only be one Spark job performing these operations on a Hoodie table.\n+ * Abstract Write Client providing functionality for performing commit, index updates and rollback\n+ * Reused for regular write operations like upsert/insert/bulk-insert.. as well as bootstrap\n+ *\n+ * @param <T> Sub type of HoodieRecordPayload\n+ * @param <I> Type of inputs\n+ * @param <K> Type of keys\n+ * @param <O> Type of outputs\n+ * @param <P> Type of record position [Key, Option[partitionPath, fileID]] in hoodie table\n  */\n-public class HoodieWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T> {\n-\n+public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I, K, O, P> extends AbstractHoodieClient {\n   private static final long serialVersionUID = 1L;\n-  private static final Logger LOG = LogManager.getLogger(HoodieWriteClient.class);\n-  private static final String LOOKUP_STR = \"lookup\";\n-  private final boolean rollbackPending;\n-  private final transient HoodieMetrics metrics;\n-  private transient Timer.Context compactionTimer;\n+  private static final Logger LOG = LogManager.getLogger(AbstractHoodieWriteClient.class);\n+\n+  protected final transient HoodieMetrics metrics;\n+  private final transient HoodieIndex<T, I, K, O, P> index;\n+\n+  protected transient Timer.Context writeContext = null;\n+  private transient WriteOperationType operationType;\n+  private transient HoodieWriteCommitCallback commitCallback;\n+\n+  protected static final String LOOKUP_STR = \"lookup\";\n+  protected final boolean rollbackPending;\n+  protected transient Timer.Context compactionTimer;\n   private transient AsyncCleanerService asyncCleanerService;\n \n+  public void setOperationType(WriteOperationType operationType) {\n+    this.operationType = operationType;\n+  }\n+\n+  public WriteOperationType getOperationType() {\n+    return this.operationType;\n+  }\n+\n   /**\n    * Create a write client, without cleaning up failed/inflight commits.\n    *\n-   * @param jsc Java Spark Context\n+   * @param context      Java Spark Context\n    * @param clientConfig instance of HoodieWriteConfig\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig clientConfig) {\n-    this(jsc, clientConfig, false);\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig clientConfig) {\n+    this(context, clientConfig, false);\n   }\n \n   /**\n    * Create a write client, with new hudi index.\n    *\n-   * @param jsc Java Spark Context\n-   * @param writeConfig instance of HoodieWriteConfig\n+   * @param context         HoodieEngineContext\n+   * @param writeConfig     instance of HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n-    this(jsc, writeConfig, rollbackPending, HoodieIndex.createIndex(writeConfig));\n-  }\n-\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending, HoodieIndex index) {\n-    this(jsc, writeConfig, rollbackPending, index, Option.empty());\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n+    this(context, writeConfig, rollbackPending, Option.empty());\n   }\n \n   /**\n-   *  Create a write client, allows to specify all parameters.\n+   * Create a write client, allows to specify all parameters.\n    *\n-   * @param jsc Java Spark Context\n-   * @param writeConfig instance of HoodieWriteConfig\n+   * @param context         HoodieEngineContext\n+   * @param writeConfig     instance of HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    * @param timelineService Timeline Service that runs as part of write client.\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending,\n-      HoodieIndex index, Option<EmbeddedTimelineService> timelineService) {\n-    super(jsc, index, writeConfig, timelineService);\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending,\n+                                   Option<BaseEmbeddedTimelineService> timelineService) {\n+    super(context, writeConfig, timelineService);\n     this.metrics = new HoodieMetrics(config, config.getTableName());\n     this.rollbackPending = rollbackPending;\n+    this.index = createIndex(writeConfig);\n   }\n \n+  protected abstract HoodieIndex<T, I, K, O, P> createIndex(HoodieWriteConfig writeConfig);\n+\n   /**\n-   * Register hudi classes for Kryo serialization.\n-   *\n-   * @param conf instance of SparkConf\n-   * @return SparkConf\n+   * Commit changes performed at the given instantTime marker.\n    */\n-  public static SparkConf registerClasses(SparkConf conf) {", "originalCommit": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTYxOA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r485591618", "bodyText": "guessing this is all moved to spark client now?\n\nyes, In SparkRDDWriteClient now", "author": "wangxianghu", "createdAt": "2020-09-09T13:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MzQ0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\nindex e1f872076..0f35e270e 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n\n@@ -27,8 +27,8 @@ import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n import org.apache.hudi.callback.HoodieWriteCommitCallback;\n import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n-import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n-import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4NDI5NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484084295", "bodyText": "it would be great, if you can avoid the whitespace changes :) Have to fish for what the real changes are", "author": "vinothchandar", "createdAt": "2020-09-06T15:39:17Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -242,150 +286,93 @@ protected void rollBackInflightBootstrap() {\n    * de-duped if needed.\n    *\n    * @param preppedRecords HoodieRecords to insert\n-   * @param instantTime Instant time of the commit\n+   * @param instantTime    Instant time of the commit\n    * @return JavaRDD[WriteStatus] - RDD of WriteStatus to inspect errors and counts\n    */\n-  public JavaRDD<WriteStatus> insertPreppedRecords(JavaRDD<HoodieRecord<T>> preppedRecords, final String instantTime) {\n-    HoodieTable<T> table = getTableAndInitCtx(WriteOperationType.INSERT_PREPPED, instantTime);\n-    table.validateInsertSchema();\n-    setOperationType(WriteOperationType.INSERT_PREPPED);\n-    this.asyncCleanerService = AsyncCleanerService.startAsyncCleaningIfEnabled(this, instantTime);\n-    HoodieWriteMetadata result = table.insertPrepped(jsc,instantTime, preppedRecords);\n-    return postWrite(result, instantTime, table);\n-  }\n+  public abstract O insertPreppedRecords(I preppedRecords, final String instantTime);\n \n   /**\n    * Loads the given HoodieRecords, as inserts into the table. This is suitable for doing big bulk loads into a Hoodie\n    * table for the very first time (e.g: converting an existing table to Hoodie).\n    * <p>\n    * This implementation uses sortBy (which does range partitioning based on reservoir sampling) and attempts to control\n-   * the numbers of files with less memory compared to the {@link HoodieWriteClient#insert(JavaRDD, String)}\n+   * the numbers of files with less memory compared to the {@link AbstractHoodieWriteClient#insert(I, String)}\n    *\n-   * @param records HoodieRecords to insert\n+   * @param records     HoodieRecords to insert\n    * @param instantTime Instant time of the commit\n    * @return JavaRDD[WriteStatus] - RDD of WriteStatus to inspect errors and counts\n    */\n-  public JavaRDD<WriteStatus> bulkInsert(JavaRDD<HoodieRecord<T>> records, final String instantTime) {\n-    return bulkInsert(records, instantTime, Option.empty());\n-  }\n+  public abstract O bulkInsert(I records, final String instantTime);\n \n   /**\n    * Loads the given HoodieRecords, as inserts into the table. This is suitable for doing big bulk loads into a Hoodie\n    * table for the very first time (e.g: converting an existing table to Hoodie).\n    * <p>\n    * This implementation uses sortBy (which does range partitioning based on reservoir sampling) and attempts to control\n-   * the numbers of files with less memory compared to the {@link HoodieWriteClient#insert(JavaRDD, String)}. Optionally\n+   * the numbers of files with less memory compared to the {@link AbstractHoodieWriteClient#insert(I, String)}. Optionally\n    * it allows users to specify their own partitioner. If specified then it will be used for repartitioning records. See\n    * {@link BulkInsertPartitioner}.\n    *\n-   * @param records HoodieRecords to insert\n-   * @param instantTime Instant time of the commit\n+   * @param records                          HoodieRecords to insert\n+   * @param instantTime                      Instant time of the commit\n    * @param userDefinedBulkInsertPartitioner If specified then it will be used to partition input records before they are inserted\n-   * into hoodie.\n+   *                                         into hoodie.\n    * @return JavaRDD[WriteStatus] - RDD of WriteStatus to inspect errors and counts\n    */\n-  public JavaRDD<WriteStatus> bulkInsert(JavaRDD<HoodieRecord<T>> records, final String instantTime,\n-                                         Option<BulkInsertPartitioner> userDefinedBulkInsertPartitioner) {\n-    HoodieTable<T> table = getTableAndInitCtx(WriteOperationType.BULK_INSERT, instantTime);\n-    table.validateInsertSchema();\n-    setOperationType(WriteOperationType.BULK_INSERT);\n-    this.asyncCleanerService = AsyncCleanerService.startAsyncCleaningIfEnabled(this, instantTime);\n-    HoodieWriteMetadata result = table.bulkInsert(jsc,instantTime, records, userDefinedBulkInsertPartitioner);\n-    return postWrite(result, instantTime, table);\n-  }\n+  public abstract O bulkInsert(I records, final String instantTime,\n+                      Option<BulkInsertPartitioner<I>> userDefinedBulkInsertPartitioner);\n+\n \n   /**\n    * Loads the given HoodieRecords, as inserts into the table. This is suitable for doing big bulk loads into a Hoodie\n    * table for the very first time (e.g: converting an existing table to Hoodie). The input records should contain no\n    * duplicates if needed.\n    * <p>\n    * This implementation uses sortBy (which does range partitioning based on reservoir sampling) and attempts to control\n-   * the numbers of files with less memory compared to the {@link HoodieWriteClient#insert(JavaRDD, String)}. Optionally\n+   * the numbers of files with less memory compared to the {@link AbstractHoodieWriteClient#insert(I, String)}. Optionally\n    * it allows users to specify their own partitioner. If specified then it will be used for repartitioning records. See\n    * {@link BulkInsertPartitioner}.\n    *\n-   * @param preppedRecords HoodieRecords to insert\n-   * @param instantTime Instant time of the commit\n+   * @param preppedRecords        HoodieRecords to insert", "originalCommit": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\nindex e1f872076..0f35e270e 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n\n@@ -286,7 +292,7 @@ public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I\n    * de-duped if needed.\n    *\n    * @param preppedRecords HoodieRecords to insert\n-   * @param instantTime    Instant time of the commit\n+   * @param instantTime Instant time of the commit\n    * @return JavaRDD[WriteStatus] - RDD of WriteStatus to inspect errors and counts\n    */\n   public abstract O insertPreppedRecords(I preppedRecords, final String instantTime);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4NDg3Mw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484084873", "bodyText": "this method need not have moved?", "author": "vinothchandar", "createdAt": "2020-09-06T15:44:19Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AsyncCleanerService.java", "diffHunk": "@@ -52,19 +52,6 @@ protected AsyncCleanerService(HoodieWriteClient<?> writeClient, String cleanInst\n     }), executor);\n   }\n \n-  public static AsyncCleanerService startAsyncCleaningIfEnabled(HoodieWriteClient writeClient,", "originalCommit": "2348f73b4a270e4d04d2f67f9d7bd9691391b569", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5OTYyOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r493999629", "bodyText": "this method need not have moved?\n\nIt is back now.", "author": "wangxianghu", "createdAt": "2020-09-24T02:18:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4NDg3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AsyncCleanerService.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AsyncCleanerService.java\nindex 50a338902..e8016c957 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AsyncCleanerService.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AsyncCleanerService.java\n\n@@ -52,6 +52,19 @@ public class AsyncCleanerService extends AbstractAsyncService {\n     }), executor);\n   }\n \n+  public static AsyncCleanerService startAsyncCleaningIfEnabled(AbstractHoodieWriteClient writeClient,\n+                                                                String instantTime) {\n+    AsyncCleanerService asyncCleanerService = null;\n+    if (writeClient.getConfig().isAutoClean() && writeClient.getConfig().isAsyncClean()) {\n+      LOG.info(\"Auto cleaning is enabled. Running cleaner async to write operation\");\n+      asyncCleanerService = new AsyncCleanerService(writeClient, instantTime);\n+      asyncCleanerService.start(null);\n+    } else {\n+      LOG.info(\"Auto cleaning is not enabled. Not running cleaner now\");\n+    }\n+    return asyncCleanerService;\n+  }\n+\n   public static void waitForCompletion(AsyncCleanerService asyncCleanerService) {\n     if (asyncCleanerService != null) {\n       LOG.info(\"Waiting for async cleaner to finish\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5Njc3Ng==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484096776", "bodyText": "are these from reformatting via IDE .", "author": "vinothchandar", "createdAt": "2020-09-06T17:48:51Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/bootstrap/selector/BootstrapRegexModeSelector.java", "diffHunk": "@@ -18,17 +18,18 @@\n \n package org.apache.hudi.client.bootstrap.selector;\n \n-import java.util.List;\n-import java.util.Map;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n import org.apache.hudi.avro.model.HoodieFileStatus;\n import org.apache.hudi.client.bootstrap.BootstrapMode;\n import org.apache.hudi.common.util.collection.Pair;\n import org.apache.hudi.config.HoodieWriteConfig;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n \n+import java.util.List;", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/bootstrap/selector/BootstrapRegexModeSelector.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/bootstrap/selector/BootstrapRegexModeSelector.java\nindex 36d90d1dc..43fae7000 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/bootstrap/selector/BootstrapRegexModeSelector.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/bootstrap/selector/BootstrapRegexModeSelector.java\n\n@@ -18,6 +18,10 @@\n \n package org.apache.hudi.client.bootstrap.selector;\n \n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n import org.apache.hudi.avro.model.HoodieFileStatus;\n import org.apache.hudi.client.bootstrap.BootstrapMode;\n import org.apache.hudi.common.util.collection.Pair;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzE2MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484097160", "bodyText": "In general, not sure if this class is applicable outside of Spark. but we do use it in all of the code paths. So understand that we needed to do this.", "author": "vinothchandar", "createdAt": "2020-09-06T17:52:53Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/execution/BaseLazyInsertIterable.java", "diffHunk": "@@ -18,64 +18,47 @@\n \n package org.apache.hudi.execution;\n \n-import org.apache.hudi.client.SparkTaskContextSupplier;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.hudi.client.TaskContextSupplier;\n import org.apache.hudi.client.WriteStatus;\n import org.apache.hudi.client.utils.LazyIterableIterator;\n import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.util.Option;\n-import org.apache.hudi.common.util.queue.BoundedInMemoryExecutor;\n import org.apache.hudi.config.HoodieWriteConfig;\n-import org.apache.hudi.exception.HoodieException;\n-import org.apache.hudi.io.CreateHandleFactory;\n import org.apache.hudi.io.WriteHandleFactory;\n import org.apache.hudi.table.HoodieTable;\n \n-import org.apache.avro.Schema;\n-import org.apache.avro.generic.IndexedRecord;\n-\n import java.util.Iterator;\n import java.util.List;\n import java.util.function.Function;\n \n /**\n  * Lazy Iterable, that writes a stream of HoodieRecords sorted by the partitionPath, into new files.\n  */\n-public class LazyInsertIterable<T extends HoodieRecordPayload>\n+public abstract class BaseLazyInsertIterable<T extends HoodieRecordPayload>", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/execution/BaseLazyInsertIterable.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/execution/HoodieLazyInsertIterable.java\nsimilarity index 76%\nrename from hudi-client/hudi-client-common/src/main/java/org/apache/hudi/execution/BaseLazyInsertIterable.java\nrename to hudi-client/hudi-client-common/src/main/java/org/apache/hudi/execution/HoodieLazyInsertIterable.java\nindex 175f4fc92..b435c68de 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/execution/BaseLazyInsertIterable.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/execution/HoodieLazyInsertIterable.java\n\n@@ -18,18 +18,20 @@\n \n package org.apache.hudi.execution;\n \n-import org.apache.avro.Schema;\n-import org.apache.avro.generic.IndexedRecord;\n-import org.apache.hudi.client.TaskContextSupplier;\n import org.apache.hudi.client.WriteStatus;\n import org.apache.hudi.client.utils.LazyIterableIterator;\n+import org.apache.hudi.client.common.TaskContextSupplier;\n import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.util.Option;\n import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.io.CreateHandleFactory;\n import org.apache.hudi.io.WriteHandleFactory;\n import org.apache.hudi.table.HoodieTable;\n \n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.IndexedRecord;\n+\n import java.util.Iterator;\n import java.util.List;\n import java.util.function.Function;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzM0Mw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484097343", "bodyText": "some of these index types don't make sense without Spark Index now. actually almost all of them except may be HBaseIndex.\nSo these should all be renamed with the Spark prefix", "author": "vinothchandar", "createdAt": "2020-09-06T17:55:12Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java", "diffHunk": "@@ -21,94 +21,52 @@\n import org.apache.hudi.ApiMaturityLevel;\n import org.apache.hudi.PublicAPIClass;\n import org.apache.hudi.PublicAPIMethod;\n-import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.FileSlice;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n-import org.apache.hudi.common.util.Option;\n-import org.apache.hudi.common.util.ReflectionUtils;\n-import org.apache.hudi.common.util.StringUtils;\n-import org.apache.hudi.common.util.collection.Pair;\n import org.apache.hudi.config.HoodieWriteConfig;\n import org.apache.hudi.exception.HoodieIndexException;\n-import org.apache.hudi.index.bloom.HoodieBloomIndex;\n-import org.apache.hudi.index.bloom.HoodieGlobalBloomIndex;\n-import org.apache.hudi.index.hbase.HBaseIndex;\n-import org.apache.hudi.index.simple.HoodieGlobalSimpleIndex;\n-import org.apache.hudi.index.simple.HoodieSimpleIndex;\n import org.apache.hudi.table.HoodieTable;\n \n-import org.apache.spark.api.java.JavaPairRDD;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n-\n import java.io.Serializable;\n \n /**\n  * Base class for different types of indexes to determine the mapping from uuid.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.EVOLVING)\n-public abstract class HoodieIndex<T extends HoodieRecordPayload> implements Serializable {\n+public abstract class HoodieIndex<T extends HoodieRecordPayload, I, K, O, P> implements Serializable {\n \n   protected final HoodieWriteConfig config;\n \n   protected HoodieIndex(HoodieWriteConfig config) {\n     this.config = config;\n   }\n \n-  public static <T extends HoodieRecordPayload> HoodieIndex<T> createIndex(", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java\nindex 8ab85ddf0..c71b34e69 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java\n\n@@ -21,7 +21,7 @@ package org.apache.hudi.index;\n import org.apache.hudi.ApiMaturityLevel;\n import org.apache.hudi.PublicAPIClass;\n import org.apache.hudi.PublicAPIMethod;\n-import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n import org.apache.hudi.common.model.FileSlice;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzQxNg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484097416", "bodyText": "now I understand P better.", "author": "vinothchandar", "createdAt": "2020-09-06T17:56:00Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java", "diffHunk": "@@ -21,94 +21,52 @@\n import org.apache.hudi.ApiMaturityLevel;\n import org.apache.hudi.PublicAPIClass;\n import org.apache.hudi.PublicAPIMethod;\n-import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.FileSlice;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n-import org.apache.hudi.common.util.Option;\n-import org.apache.hudi.common.util.ReflectionUtils;\n-import org.apache.hudi.common.util.StringUtils;\n-import org.apache.hudi.common.util.collection.Pair;\n import org.apache.hudi.config.HoodieWriteConfig;\n import org.apache.hudi.exception.HoodieIndexException;\n-import org.apache.hudi.index.bloom.HoodieBloomIndex;\n-import org.apache.hudi.index.bloom.HoodieGlobalBloomIndex;\n-import org.apache.hudi.index.hbase.HBaseIndex;\n-import org.apache.hudi.index.simple.HoodieGlobalSimpleIndex;\n-import org.apache.hudi.index.simple.HoodieSimpleIndex;\n import org.apache.hudi.table.HoodieTable;\n \n-import org.apache.spark.api.java.JavaPairRDD;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n-\n import java.io.Serializable;\n \n /**\n  * Base class for different types of indexes to determine the mapping from uuid.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.EVOLVING)\n-public abstract class HoodieIndex<T extends HoodieRecordPayload> implements Serializable {\n+public abstract class HoodieIndex<T extends HoodieRecordPayload, I, K, O, P> implements Serializable {\n \n   protected final HoodieWriteConfig config;\n \n   protected HoodieIndex(HoodieWriteConfig config) {\n     this.config = config;\n   }\n \n-  public static <T extends HoodieRecordPayload> HoodieIndex<T> createIndex(\n-      HoodieWriteConfig config) throws HoodieIndexException {\n-    // first use index class config to create index.\n-    if (!StringUtils.isNullOrEmpty(config.getIndexClass())) {\n-      Object instance = ReflectionUtils.loadClass(config.getIndexClass(), config);\n-      if (!(instance instanceof HoodieIndex)) {\n-        throw new HoodieIndexException(config.getIndexClass() + \" is not a subclass of HoodieIndex\");\n-      }\n-      return (HoodieIndex) instance;\n-    }\n-    switch (config.getIndexType()) {\n-      case HBASE:\n-        return new HBaseIndex<>(config);\n-      case INMEMORY:\n-        return new InMemoryHashIndex<>(config);\n-      case BLOOM:\n-        return new HoodieBloomIndex<>(config);\n-      case GLOBAL_BLOOM:\n-        return new HoodieGlobalBloomIndex<>(config);\n-      case SIMPLE:\n-        return new HoodieSimpleIndex<>(config);\n-      case GLOBAL_SIMPLE:\n-        return new HoodieGlobalSimpleIndex<>(config);\n-      default:\n-        throw new HoodieIndexException(\"Index type unspecified, set \" + config.getIndexType());\n-    }\n-  }\n-\n   /**\n    * Checks if the given [Keys] exists in the hoodie table and returns [Key, Option[partitionPath, fileID]] If the\n    * optional is empty, then the key is not found.\n    */\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n-  public abstract JavaPairRDD<HoodieKey, Option<Pair<String, String>>> fetchRecordLocation(\n-      JavaRDD<HoodieKey> hoodieKeys, final JavaSparkContext jsc, HoodieTable<T> hoodieTable);\n+  public abstract P fetchRecordLocation(", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java\nindex 8ab85ddf0..c71b34e69 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java\n\n@@ -21,7 +21,7 @@ package org.apache.hudi.index;\n import org.apache.hudi.ApiMaturityLevel;\n import org.apache.hudi.PublicAPIClass;\n import org.apache.hudi.PublicAPIMethod;\n-import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n import org.apache.hudi.common.model.FileSlice;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzYxMw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484097613", "bodyText": "these annotations needs to moved over to a SparkHoodieIndex class? it will be hard for end developers to program against HoodieIndex directly anymore. This is a general point actually. The current public APIs should all be annotated against the Spark child classes.  wdyt?", "author": "vinothchandar", "createdAt": "2020-09-06T17:58:04Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java", "diffHunk": "@@ -21,94 +21,52 @@\n import org.apache.hudi.ApiMaturityLevel;\n import org.apache.hudi.PublicAPIClass;\n import org.apache.hudi.PublicAPIMethod;\n-import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.FileSlice;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n-import org.apache.hudi.common.util.Option;\n-import org.apache.hudi.common.util.ReflectionUtils;\n-import org.apache.hudi.common.util.StringUtils;\n-import org.apache.hudi.common.util.collection.Pair;\n import org.apache.hudi.config.HoodieWriteConfig;\n import org.apache.hudi.exception.HoodieIndexException;\n-import org.apache.hudi.index.bloom.HoodieBloomIndex;\n-import org.apache.hudi.index.bloom.HoodieGlobalBloomIndex;\n-import org.apache.hudi.index.hbase.HBaseIndex;\n-import org.apache.hudi.index.simple.HoodieGlobalSimpleIndex;\n-import org.apache.hudi.index.simple.HoodieSimpleIndex;\n import org.apache.hudi.table.HoodieTable;\n \n-import org.apache.spark.api.java.JavaPairRDD;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n-\n import java.io.Serializable;\n \n /**\n  * Base class for different types of indexes to determine the mapping from uuid.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.EVOLVING)\n-public abstract class HoodieIndex<T extends HoodieRecordPayload> implements Serializable {\n+public abstract class HoodieIndex<T extends HoodieRecordPayload, I, K, O, P> implements Serializable {\n \n   protected final HoodieWriteConfig config;\n \n   protected HoodieIndex(HoodieWriteConfig config) {\n     this.config = config;\n   }\n \n-  public static <T extends HoodieRecordPayload> HoodieIndex<T> createIndex(\n-      HoodieWriteConfig config) throws HoodieIndexException {\n-    // first use index class config to create index.\n-    if (!StringUtils.isNullOrEmpty(config.getIndexClass())) {\n-      Object instance = ReflectionUtils.loadClass(config.getIndexClass(), config);\n-      if (!(instance instanceof HoodieIndex)) {\n-        throw new HoodieIndexException(config.getIndexClass() + \" is not a subclass of HoodieIndex\");\n-      }\n-      return (HoodieIndex) instance;\n-    }\n-    switch (config.getIndexType()) {\n-      case HBASE:\n-        return new HBaseIndex<>(config);\n-      case INMEMORY:\n-        return new InMemoryHashIndex<>(config);\n-      case BLOOM:\n-        return new HoodieBloomIndex<>(config);\n-      case GLOBAL_BLOOM:\n-        return new HoodieGlobalBloomIndex<>(config);\n-      case SIMPLE:\n-        return new HoodieSimpleIndex<>(config);\n-      case GLOBAL_SIMPLE:\n-        return new HoodieGlobalSimpleIndex<>(config);\n-      default:\n-        throw new HoodieIndexException(\"Index type unspecified, set \" + config.getIndexType());\n-    }\n-  }\n-\n   /**\n    * Checks if the given [Keys] exists in the hoodie table and returns [Key, Option[partitionPath, fileID]] If the\n    * optional is empty, then the key is not found.\n    */\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n-  public abstract JavaPairRDD<HoodieKey, Option<Pair<String, String>>> fetchRecordLocation(\n-      JavaRDD<HoodieKey> hoodieKeys, final JavaSparkContext jsc, HoodieTable<T> hoodieTable);\n+  public abstract P fetchRecordLocation(\n+      K hoodieKeys, final HoodieEngineContext context, HoodieTable<T, I, K, O, P> hoodieTable);\n \n   /**\n    * Looks up the index and tags each incoming record with a location of a file that contains the row (if it is actually\n    * present).\n    */\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgxNTQwMg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484815402", "bodyText": "these annotations needs to moved over to a SparkHoodieIndex class? it will be hard for end developers to program against HoodieIndex directly anymore. This is a general point actually. The current public APIs should all be annotated against the Spark child classes. wdyt?\n\ngood idea, done", "author": "wangxianghu", "createdAt": "2020-09-08T10:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzYxMw=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java\nindex 8ab85ddf0..c71b34e69 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java\n\n@@ -21,7 +21,7 @@ package org.apache.hudi.index;\n import org.apache.hudi.ApiMaturityLevel;\n import org.apache.hudi.PublicAPIClass;\n import org.apache.hudi.PublicAPIMethod;\n-import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n import org.apache.hudi.common.model.FileSlice;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzY1NA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484097654", "bodyText": "I suggest introducing a SparkHoodieIndex base class", "author": "vinothchandar", "createdAt": "2020-09-06T17:58:34Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/bloom/BaseHoodieBloomIndex.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.index.bloom;\n+\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieIndexException;\n+import org.apache.hudi.index.HoodieIndex;\n+import org.apache.hudi.table.HoodieTable;\n+\n+/**\n+ * Indexing mechanism based on bloom filter. Each parquet file includes its row_key bloom filter in its metadata.\n+ */\n+public abstract class BaseHoodieBloomIndex<T extends HoodieRecordPayload, I, K, O, P> extends HoodieIndex<T, I, K, O, P> {", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkyMTYxMg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484921612", "bodyText": "I suggest introducing a SparkHoodieIndex base class\n\ndone", "author": "wangxianghu", "createdAt": "2020-09-08T13:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzY1NA=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/bloom/BaseHoodieBloomIndex.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/bloom/BaseHoodieBloomIndex.java\ndeleted file mode 100644\nindex 244810558..000000000\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/bloom/BaseHoodieBloomIndex.java\n+++ /dev/null\n\n@@ -1,71 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hudi.index.bloom;\n-\n-import org.apache.hudi.common.HoodieEngineContext;\n-import org.apache.hudi.common.model.HoodieRecordPayload;\n-import org.apache.hudi.config.HoodieWriteConfig;\n-import org.apache.hudi.exception.HoodieIndexException;\n-import org.apache.hudi.index.HoodieIndex;\n-import org.apache.hudi.table.HoodieTable;\n-\n-/**\n- * Indexing mechanism based on bloom filter. Each parquet file includes its row_key bloom filter in its metadata.\n- */\n-public abstract class BaseHoodieBloomIndex<T extends HoodieRecordPayload, I, K, O, P> extends HoodieIndex<T, I, K, O, P> {\n-\n-  public BaseHoodieBloomIndex(HoodieWriteConfig config) {\n-    super(config);\n-  }\n-\n-  @Override\n-  public boolean rollbackCommit(String instantTime) {\n-    // Nope, don't need to do anything.\n-    return true;\n-  }\n-\n-  /**\n-   * This is not global, since we depend on the partitionPath to do the lookup.\n-   */\n-  @Override\n-  public boolean isGlobal() {\n-    return false;\n-  }\n-\n-  /**\n-   * No indexes into log files yet.\n-   */\n-  @Override\n-  public boolean canIndexLogFiles() {\n-    return false;\n-  }\n-\n-  /**\n-   * Bloom filters are stored, into the same data files.\n-   */\n-  @Override\n-  public boolean isImplicitWithStorage() {\n-    return true;\n-  }\n-\n-  @Override\n-  public O updateLocation(O writeStatusRDD, HoodieEngineContext context, HoodieTable<T, I, K, O, P> hoodieTable) throws HoodieIndexException {\n-    return writeStatusRDD;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5Nzk1MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484097950", "bodyText": "are there any code changes here, i.e logic changes?", "author": "vinothchandar", "createdAt": "2020-09-06T18:01:32Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/hbase/BaseHoodieHBaseIndex.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.index.hbase;\n+\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.ReflectionUtils;\n+import org.apache.hudi.config.HoodieHBaseIndexConfig;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieDependentSystemUnavailableException;\n+import org.apache.hudi.index.HoodieIndex;\n+import org.apache.hudi.table.HoodieTable;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.BufferedMutator;\n+import org.apache.hadoop.hbase.client.Connection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.client.Get;\n+import org.apache.hadoop.hbase.client.HTable;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.RegionLocator;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+/**\n+ * Hoodie Index implementation backed by HBase.\n+ */\n+public abstract class BaseHoodieHBaseIndex<T extends HoodieRecordPayload, I, K, O, P> extends HoodieIndex<T, I, K, O, P> {", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkyMTk5NA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484921994", "bodyText": "are there any code changes here, i.e logic changes?\n\nnothing changed", "author": "wangxianghu", "createdAt": "2020-09-08T13:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5Nzk1MA=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/hbase/BaseHoodieHBaseIndex.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/hbase/BaseHoodieHBaseIndex.java\ndeleted file mode 100644\nindex 755b0547b..000000000\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/hbase/BaseHoodieHBaseIndex.java\n+++ /dev/null\n\n@@ -1,295 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hudi.index.hbase;\n-\n-import org.apache.hudi.common.HoodieEngineContext;\n-import org.apache.hudi.common.model.HoodieRecordPayload;\n-import org.apache.hudi.common.table.HoodieTableMetaClient;\n-import org.apache.hudi.common.table.timeline.HoodieTimeline;\n-import org.apache.hudi.common.util.ReflectionUtils;\n-import org.apache.hudi.config.HoodieHBaseIndexConfig;\n-import org.apache.hudi.config.HoodieWriteConfig;\n-import org.apache.hudi.exception.HoodieDependentSystemUnavailableException;\n-import org.apache.hudi.index.HoodieIndex;\n-import org.apache.hudi.table.HoodieTable;\n-\n-import org.apache.hadoop.conf.Configuration;\n-import org.apache.hadoop.hbase.HBaseConfiguration;\n-import org.apache.hadoop.hbase.HRegionLocation;\n-import org.apache.hadoop.hbase.TableName;\n-import org.apache.hadoop.hbase.client.BufferedMutator;\n-import org.apache.hadoop.hbase.client.Connection;\n-import org.apache.hadoop.hbase.client.ConnectionFactory;\n-import org.apache.hadoop.hbase.client.Get;\n-import org.apache.hadoop.hbase.client.HTable;\n-import org.apache.hadoop.hbase.client.Mutation;\n-import org.apache.hadoop.hbase.client.RegionLocator;\n-import org.apache.hadoop.hbase.client.Result;\n-import org.apache.hadoop.hbase.util.Bytes;\n-import org.apache.log4j.LogManager;\n-import org.apache.log4j.Logger;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.util.List;\n-\n-/**\n- * Hoodie Index implementation backed by HBase.\n- */\n-public abstract class BaseHoodieHBaseIndex<T extends HoodieRecordPayload, I, K, O, P> extends HoodieIndex<T, I, K, O, P> {\n-\n-  protected static final byte[] SYSTEM_COLUMN_FAMILY = Bytes.toBytes(\"_s\");\n-  protected static final byte[] COMMIT_TS_COLUMN = Bytes.toBytes(\"commit_ts\");\n-  protected static final byte[] FILE_NAME_COLUMN = Bytes.toBytes(\"file_name\");\n-  protected static final byte[] PARTITION_PATH_COLUMN = Bytes.toBytes(\"partition_path\");\n-  protected static final int SLEEP_TIME_MILLISECONDS = 100;\n-\n-  private static final Logger LOG = LogManager.getLogger(BaseHoodieHBaseIndex.class);\n-  protected static Connection hbaseConnection = null;\n-  private HBaseIndexQPSResourceAllocator hBaseIndexQPSResourceAllocator = null;\n-  private float qpsFraction;\n-  protected int maxQpsPerRegionServer;\n-  /**\n-   * multiPutBatchSize will be computed and re-set in updateLocation if\n-   * {@link HoodieHBaseIndexConfig#HBASE_PUT_BATCH_SIZE_AUTO_COMPUTE_PROP} is set to true.\n-   */\n-  protected Integer multiPutBatchSize;\n-  protected Integer numRegionServersForTable;\n-  protected final String tableName;\n-  protected HBasePutBatchSizeCalculator putBatchSizeCalculator;\n-\n-  public BaseHoodieHBaseIndex(HoodieWriteConfig config) {\n-    super(config);\n-    this.tableName = config.getHbaseTableName();\n-    addShutDownHook();\n-    init(config);\n-  }\n-\n-  private void init(HoodieWriteConfig config) {\n-    this.multiPutBatchSize = config.getHbaseIndexGetBatchSize();\n-    this.qpsFraction = config.getHbaseIndexQPSFraction();\n-    this.maxQpsPerRegionServer = config.getHbaseIndexMaxQPSPerRegionServer();\n-    this.putBatchSizeCalculator = new HBasePutBatchSizeCalculator();\n-    this.hBaseIndexQPSResourceAllocator = createQPSResourceAllocator(this.config);\n-  }\n-\n-  public HBaseIndexQPSResourceAllocator createQPSResourceAllocator(HoodieWriteConfig config) {\n-    try {\n-      LOG.info(\"createQPSResourceAllocator :\" + config.getHBaseQPSResourceAllocatorClass());\n-      return (HBaseIndexQPSResourceAllocator) ReflectionUtils\n-              .loadClass(config.getHBaseQPSResourceAllocatorClass(), config);\n-    } catch (Exception e) {\n-      LOG.warn(\"error while instantiating HBaseIndexQPSResourceAllocator\", e);\n-    }\n-    return new DefaultHBaseQPSResourceAllocator(config);\n-  }\n-\n-  @Override\n-  public P fetchRecordLocation(K hoodieKeys,\n-                               HoodieEngineContext context, HoodieTable<T,I,K,O,P> hoodieTable) {\n-    throw new UnsupportedOperationException(\"HBase index does not implement check exist\");\n-  }\n-\n-  protected Connection getHBaseConnection() {\n-    Configuration hbaseConfig = HBaseConfiguration.create();\n-    String quorum = config.getHbaseZkQuorum();\n-    hbaseConfig.set(\"hbase.zookeeper.quorum\", quorum);\n-    String zkZnodeParent = config.getHBaseZkZnodeParent();\n-    if (zkZnodeParent != null) {\n-      hbaseConfig.set(\"zookeeper.znode.parent\", zkZnodeParent);\n-    }\n-    String port = String.valueOf(config.getHbaseZkPort());\n-    hbaseConfig.set(\"hbase.zookeeper.property.clientPort\", port);\n-    try {\n-      return ConnectionFactory.createConnection(hbaseConfig);\n-    } catch (IOException e) {\n-      throw new HoodieDependentSystemUnavailableException(HoodieDependentSystemUnavailableException.HBASE,\n-          quorum + \":\" + port);\n-    }\n-  }\n-\n-  /**\n-   * Since we are sharing the HBaseConnection across tasks in a JVM, make sure the HBaseConnection is closed when JVM\n-   * exits.\n-   */\n-  private void addShutDownHook() {\n-    Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n-      try {\n-        hbaseConnection.close();\n-      } catch (Exception e) {\n-        // fail silently for any sort of exception\n-      }\n-    }));\n-  }\n-\n-  /**\n-   * Ensure that any resources used for indexing are released here.\n-   */\n-  @Override\n-  public void close() {\n-    this.hBaseIndexQPSResourceAllocator.releaseQPSResources();\n-  }\n-\n-  protected Get generateStatement(String key) throws IOException {\n-    return new Get(Bytes.toBytes(key)).setMaxVersions(1).addColumn(SYSTEM_COLUMN_FAMILY, COMMIT_TS_COLUMN)\n-        .addColumn(SYSTEM_COLUMN_FAMILY, FILE_NAME_COLUMN).addColumn(SYSTEM_COLUMN_FAMILY, PARTITION_PATH_COLUMN);\n-  }\n-\n-  protected boolean checkIfValidCommit(HoodieTableMetaClient metaClient, String commitTs) {\n-    HoodieTimeline commitTimeline = metaClient.getCommitsTimeline().filterCompletedInstants();\n-    // Check if the last commit ts for this row is 1) present in the timeline or\n-    // 2) is less than the first commit ts in the timeline\n-    return !commitTimeline.empty()\n-        && commitTimeline.containsOrBeforeTimelineStarts(commitTs);\n-  }\n-\n-  protected Result[] doGet(HTable hTable, List<Get> keys) throws IOException {\n-    sleepForTime(SLEEP_TIME_MILLISECONDS);\n-    return hTable.get(keys);\n-  }\n-\n-  /**\n-   * Helper method to facilitate performing mutations (including puts and deletes) in Hbase.\n-   */\n-  protected void doMutations(BufferedMutator mutator, List<Mutation> mutations) throws IOException {\n-    if (mutations.isEmpty()) {\n-      return;\n-    }\n-    mutator.mutate(mutations);\n-    mutator.flush();\n-    mutations.clear();\n-    sleepForTime(SLEEP_TIME_MILLISECONDS);\n-  }\n-\n-  private static void sleepForTime(int sleepTimeMs) {\n-    try {\n-      Thread.sleep(sleepTimeMs);\n-    } catch (InterruptedException e) {\n-      LOG.error(\"Sleep interrupted during throttling\", e);\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  public static class HBasePutBatchSizeCalculator implements Serializable {\n-\n-    private static final int MILLI_SECONDS_IN_A_SECOND = 1000;\n-    private static final Logger LOG = LogManager.getLogger(HBasePutBatchSizeCalculator.class);\n-\n-    /**\n-     * Calculate putBatch size so that sum of requests across multiple jobs in a second does not exceed\n-     * maxQpsPerRegionServer for each Region Server. Multiplying qpsFraction to reduce the aggregate load on common RS\n-     * across topics. Assumption here is that all tables have regions across all RS, which is not necessarily true for\n-     * smaller tables. So, they end up getting a smaller share of QPS than they deserve, but it might be ok.\n-     * <p>\n-     * Example: int putBatchSize = batchSizeCalculator.getBatchSize(10, 16667, 1200, 200, 100, 0.1f)\n-     * </p>\n-     * <p>\n-     * Expected batchSize is 8 because in that case, total request sent to a Region Server in one second is:\n-     *\n-     * 8 (batchSize) * 200 (parallelism) * 10 (maxReqsInOneSecond) * 10 (numRegionServers) * 0.1 (qpsFraction)) =>\n-     * 16000. We assume requests get distributed to Region Servers uniformly, so each RS gets 1600 requests which\n-     * happens to be 10% of 16667 (maxQPSPerRegionServer), as expected.\n-     * </p>\n-     * <p>\n-     * Assumptions made here\n-     * <li>In a batch, writes get evenly distributed to each RS for that table. Since we do writes only in the case of\n-     * inserts and not updates, for this assumption to fail, inserts would have to be skewed towards few RS, likelihood\n-     * of which is less if Hbase table is pre-split and rowKeys are UUIDs (random strings). If this assumption fails,\n-     * then it is possible for some RS to receive more than maxQpsPerRegionServer QPS, but for simplicity, we are going\n-     * ahead with this model, since this is meant to be a lightweight distributed throttling mechanism without\n-     * maintaining a global context. So if this assumption breaks, we are hoping the HBase Master relocates hot-spot\n-     * regions to new Region Servers.\n-     *\n-     * </li>\n-     * <li>For Region Server stability, throttling at a second level granularity is fine. Although, within a second, the\n-     * sum of queries might be within maxQpsPerRegionServer, there could be peaks at some sub second intervals. So, the\n-     * assumption is that these peaks are tolerated by the Region Server (which at max can be maxQpsPerRegionServer).\n-     * </li>\n-     * </p>\n-     */\n-    public int getBatchSize(int numRegionServersForTable, int maxQpsPerRegionServer, int numTasksDuringPut,\n-        int maxExecutors, int sleepTimeMs, float qpsFraction) {\n-      int maxReqPerSec = (int) (qpsFraction * numRegionServersForTable * maxQpsPerRegionServer);\n-      int maxParallelPuts = Math.max(1, Math.min(numTasksDuringPut, maxExecutors));\n-      int maxReqsSentPerTaskPerSec = MILLI_SECONDS_IN_A_SECOND / sleepTimeMs;\n-      int multiPutBatchSize = Math.max(1, maxReqPerSec / (maxParallelPuts * maxReqsSentPerTaskPerSec));\n-      LOG.info(\"HbaseIndexThrottling: qpsFraction :\" + qpsFraction);\n-      LOG.info(\"HbaseIndexThrottling: numRSAlive :\" + numRegionServersForTable);\n-      LOG.info(\"HbaseIndexThrottling: maxReqPerSec :\" + maxReqPerSec);\n-      LOG.info(\"HbaseIndexThrottling: numTasks :\" + numTasksDuringPut);\n-      LOG.info(\"HbaseIndexThrottling: maxExecutors :\" + maxExecutors);\n-      LOG.info(\"HbaseIndexThrottling: maxParallelPuts :\" + maxParallelPuts);\n-      LOG.info(\"HbaseIndexThrottling: maxReqsSentPerTaskPerSec :\" + maxReqsSentPerTaskPerSec);\n-      LOG.info(\"HbaseIndexThrottling: numRegionServersForTable :\" + numRegionServersForTable);\n-      LOG.info(\"HbaseIndexThrottling: multiPutBatchSize :\" + multiPutBatchSize);\n-      return multiPutBatchSize;\n-    }\n-  }\n-\n-  protected Integer getNumRegionServersAliveForTable() {\n-    // This is being called in the driver, so there is only one connection\n-    // from the driver, so ok to use a local connection variable.\n-    if (numRegionServersForTable == null) {\n-      try (Connection conn = getHBaseConnection()) {\n-        RegionLocator regionLocator = conn.getRegionLocator(TableName.valueOf(tableName));\n-        numRegionServersForTable = Math\n-            .toIntExact(regionLocator.getAllRegionLocations().stream().map(HRegionLocation::getServerName).distinct().count());\n-        return numRegionServersForTable;\n-      } catch (IOException e) {\n-        LOG.error(e);\n-        throw new RuntimeException(e);\n-      }\n-    }\n-    return numRegionServersForTable;\n-  }\n-\n-  @Override\n-  public boolean rollbackCommit(String instantTime) {\n-    // Rollback in HbaseIndex is managed via method {@link #checkIfValidCommit()}\n-    return true;\n-  }\n-\n-  /**\n-   * Only looks up by recordKey.\n-   */\n-  @Override\n-  public boolean isGlobal() {\n-    return true;\n-  }\n-\n-  /**\n-   * Mapping is available in HBase already.\n-   */\n-  @Override\n-  public boolean canIndexLogFiles() {\n-    return true;\n-  }\n-\n-  /**\n-   * Index needs to be explicitly updated after storage write.\n-   */\n-  @Override\n-  public boolean isImplicitWithStorage() {\n-    return false;\n-  }\n-\n-  public void setHbaseConnection(Connection hbaseConnection) {\n-    BaseHoodieHBaseIndex.hbaseConnection = hbaseConnection;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODM1MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484098350", "bodyText": "we should make sure there are no backwards incompatible changes to the key generator interface", "author": "vinothchandar", "createdAt": "2020-09-06T18:05:46Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/keygen/KeyGeneratorInterface.java", "diffHunk": "@@ -34,8 +33,4 @@\n \n   List<String> getRecordKeyFieldNames();\n \n-  String getRecordKey(Row row);", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgxNjY5MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484816690", "bodyText": "we should make sure there are no backwards incompatible changes to the key generator interface\n\nYes, I moved it to SparkKeyGeneratorInterface", "author": "wangxianghu", "createdAt": "2020-09-08T10:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODM1MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODg5Mw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484098893", "bodyText": "why is this no longer a mergeHandle?", "author": "vinothchandar", "createdAt": "2020-09-06T18:12:15Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/commit/BaseMergeHelper.java", "diffHunk": "@@ -161,11 +108,11 @@ private static GenericRecord transformRecordBasedOnNewSchema(GenericDatumReader<\n   /**\n    * Consumer that dequeues records from queue and sends to Merge Handle.\n    */\n-  private static class UpdateHandler extends BoundedInMemoryQueueConsumer<GenericRecord, Void> {\n+  static class UpdateHandler extends BoundedInMemoryQueueConsumer<GenericRecord, Void> {\n \n-    private final HoodieMergeHandle upsertHandle;\n+    private final HoodieWriteHandle upsertHandle;", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkyNTY4OQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484925689", "bodyText": "why is this no longer a mergeHandle?\n\nHoodieWriteHandle is spark-free, while HoodieMergeHandle is not. To abstract MergeHelper, the variables it holds should be spark-free too", "author": "wangxianghu", "createdAt": "2020-09-08T13:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5OTExNA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r493999114", "bodyText": "why is this no longer a mergeHandle?\n\nWith parallelDo method introduced in, this change is no longer needed.  rollback already", "author": "wangxianghu", "createdAt": "2020-09-24T02:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODg5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/commit/BaseMergeHelper.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/commit/AbstractMergeHelper.java\nsimilarity index 83%\nrename from hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/commit/BaseMergeHelper.java\nrename to hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/commit/AbstractMergeHelper.java\nindex db21fb88c..1bbffadb3 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/commit/BaseMergeHelper.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/commit/AbstractMergeHelper.java\n\n@@ -108,11 +109,11 @@ public abstract class BaseMergeHelper<T extends HoodieRecordPayload, I, K, O, P>\n   /**\n    * Consumer that dequeues records from queue and sends to Merge Handle.\n    */\n-  static class UpdateHandler extends BoundedInMemoryQueueConsumer<GenericRecord, Void> {\n+  protected static class UpdateHandler extends BoundedInMemoryQueueConsumer<GenericRecord, Void> {\n \n-    private final HoodieWriteHandle upsertHandle;\n+    private final HoodieMergeHandle upsertHandle;\n \n-    UpdateHandler(HoodieWriteHandle upsertHandle) {\n+    protected UpdateHandler(HoodieMergeHandle upsertHandle) {\n       this.upsertHandle = upsertHandle;\n     }\n \n"}}, {"oid": "57869f2f1ad83183779c98536ea3862eb30d0cc3", "url": "https://github.com/apache/hudi/commit/57869f2f1ad83183779c98536ea3862eb30d0cc3", "message": "rebase master", "committedDate": "2020-09-07T05:36:24Z", "type": "forcePushed"}, {"oid": "a9ddf89e5c79996b2a4720bb467b7dc696e4f3d8", "url": "https://github.com/apache/hudi/commit/a9ddf89e5c79996b2a4720bb467b7dc696e4f3d8", "message": "rebase master", "committedDate": "2020-09-07T05:47:04Z", "type": "forcePushed"}, {"oid": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "url": "https://github.com/apache/hudi/commit/ac3339704c703741f9ff50f2d96019cef2d2c72b", "message": "rebase master", "committedDate": "2020-09-06T16:35:49Z", "type": "forcePushed"}, {"oid": "e24c968a27d9cdbb746e68ff09b86c25da758c82", "url": "https://github.com/apache/hudi/commit/e24c968a27d9cdbb746e68ff09b86c25da758c82", "message": "resolve conflicts", "committedDate": "2020-09-07T14:04:45Z", "type": "forcePushed"}, {"oid": "7aedc0bdc1565d47b044487aab04b659167bd086", "url": "https://github.com/apache/hudi/commit/7aedc0bdc1565d47b044487aab04b659167bd086", "message": "resolve conflicts", "committedDate": "2020-09-07T14:23:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEzNDg1Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484134852", "bodyText": "These sort of classes, we should have a way to implement with just a reference to engineContext ideally. Even though we cannot implement every method in sparkContext. This is a topic for later", "author": "vinothchandar", "createdAt": "2020-09-07T00:30:06Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/BaseMarkerBasedRollbackStrategy.java", "diffHunk": "@@ -18,63 +18,58 @@\n \n package org.apache.hudi.table.action.rollback;\n \n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.HoodieRollbackStat;\n import org.apache.hudi.common.fs.FSUtils;\n import org.apache.hudi.common.model.HoodieLogFile;\n-import org.apache.hudi.common.model.IOType;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.table.log.HoodieLogFormat;\n import org.apache.hudi.common.table.log.block.HoodieCommandBlock;\n import org.apache.hudi.common.table.log.block.HoodieLogBlock;\n import org.apache.hudi.common.table.timeline.HoodieInstant;\n import org.apache.hudi.config.HoodieWriteConfig;\n import org.apache.hudi.exception.HoodieIOException;\n-import org.apache.hudi.exception.HoodieRollbackException;\n import org.apache.hudi.table.HoodieTable;\n-import org.apache.hudi.table.MarkerFiles;\n \n-import org.apache.hadoop.fs.Path;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n-import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n import java.util.Collections;\n-import java.util.List;\n import java.util.Map;\n \n-import scala.Tuple2;\n-\n /**\n  * Performs rollback using marker files generated during the write..\n  */\n-public class MarkerBasedRollbackStrategy implements BaseRollbackActionExecutor.RollbackStrategy {\n+public abstract class BaseMarkerBasedRollbackStrategy<T extends HoodieRecordPayload, I, K, O, P> implements BaseRollbackActionExecutor.RollbackStrategy {", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/BaseMarkerBasedRollbackStrategy.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/AbstractMarkerBasedRollbackStrategy.java\nsimilarity index 90%\nrename from hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/BaseMarkerBasedRollbackStrategy.java\nrename to hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/AbstractMarkerBasedRollbackStrategy.java\nindex 1addc92dd..40526b86f 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/BaseMarkerBasedRollbackStrategy.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/AbstractMarkerBasedRollbackStrategy.java\n\n@@ -19,7 +19,7 @@\n package org.apache.hudi.table.action.rollback;\n \n import org.apache.hadoop.fs.Path;\n-import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n import org.apache.hudi.common.HoodieRollbackStat;\n import org.apache.hudi.common.fs.FSUtils;\n import org.apache.hudi.common.model.HoodieLogFile;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEzNTEzNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484135137", "bodyText": "would a parallelDo(func, parallelism) method in HoodieEngineContext help us avoid a lot of base/child class duplication of logic like this?\nMost of clean, compact, rollback, restore etc can be implemented this way. Most of them just take a list, parallelize it, and execute some function, collect results and get the objects back", "author": "vinothchandar", "createdAt": "2020-09-07T00:32:18Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/BaseMarkerBasedRollbackStrategy.java", "diffHunk": "@@ -132,32 +127,4 @@ private HoodieRollbackStat undoAppend(String appendBaseFilePath, HoodieInstant i\n         .build();\n   }\n \n-  @Override\n-  public List<HoodieRollbackStat> execute(HoodieInstant instantToRollback) {\n-    try {\n-      MarkerFiles markerFiles = new MarkerFiles(table, instantToRollback.getTimestamp());\n-      List<String> markerFilePaths = markerFiles.allMarkerFilePaths();\n-      int parallelism = Math.max(Math.min(markerFilePaths.size(), config.getRollbackParallelism()), 1);\n-      return jsc.parallelize(markerFilePaths, parallelism)\n-          .map(markerFilePath -> {", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/BaseMarkerBasedRollbackStrategy.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/AbstractMarkerBasedRollbackStrategy.java\nsimilarity index 90%\nrename from hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/BaseMarkerBasedRollbackStrategy.java\nrename to hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/AbstractMarkerBasedRollbackStrategy.java\nindex 1addc92dd..40526b86f 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/BaseMarkerBasedRollbackStrategy.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/AbstractMarkerBasedRollbackStrategy.java\n\n@@ -126,5 +125,4 @@ public abstract class BaseMarkerBasedRollbackStrategy<T extends HoodieRecordPayl\n         .withRollbackBlockAppendResults(Collections.emptyMap())\n         .build();\n   }\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUxNjMzOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484516339", "bodyText": "the MOR equivalent method got moved I guess", "author": "vinothchandar", "createdAt": "2020-09-07T16:33:44Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/RollbackUtils.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.rollback;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import org.apache.hudi.common.HoodieRollbackStat;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieWriteStat;\n+import org.apache.hudi.common.table.log.block.HoodieCommandBlock;\n+import org.apache.hudi.common.table.log.block.HoodieLogBlock;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.table.HoodieTable;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+public class RollbackUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(RollbackUtils.class);\n+\n+  static Map<HoodieLogBlock.HeaderMetadataType, String> generateHeader(String instantToRollback, String rollbackInstantTime) {\n+    // generate metadata\n+    Map<HoodieLogBlock.HeaderMetadataType, String> header = new HashMap<>(3);\n+    header.put(HoodieLogBlock.HeaderMetadataType.INSTANT_TIME, rollbackInstantTime);\n+    header.put(HoodieLogBlock.HeaderMetadataType.TARGET_INSTANT_TIME, instantToRollback);\n+    header.put(HoodieLogBlock.HeaderMetadataType.COMMAND_BLOCK_TYPE,\n+        String.valueOf(HoodieCommandBlock.HoodieCommandBlockTypeEnum.ROLLBACK_PREVIOUS_BLOCK.ordinal()));\n+    return header;\n+  }\n+\n+  /**\n+   * Helper to merge 2 rollback-stats for a given partition.\n+   *\n+   * @param stat1 HoodieRollbackStat\n+   * @param stat2 HoodieRollbackStat\n+   * @return Merged HoodieRollbackStat\n+   */\n+  static HoodieRollbackStat mergeRollbackStat(HoodieRollbackStat stat1, HoodieRollbackStat stat2) {\n+    ValidationUtils.checkArgument(stat1.getPartitionPath().equals(stat2.getPartitionPath()));\n+    final List<String> successDeleteFiles = new ArrayList<>();\n+    final List<String> failedDeleteFiles = new ArrayList<>();\n+    final Map<FileStatus, Long> commandBlocksCount = new HashMap<>();\n+    final List<FileStatus> filesToRollback = new ArrayList<>();\n+    Option.ofNullable(stat1.getSuccessDeleteFiles()).ifPresent(successDeleteFiles::addAll);\n+    Option.ofNullable(stat2.getSuccessDeleteFiles()).ifPresent(successDeleteFiles::addAll);\n+    Option.ofNullable(stat1.getFailedDeleteFiles()).ifPresent(failedDeleteFiles::addAll);\n+    Option.ofNullable(stat2.getFailedDeleteFiles()).ifPresent(failedDeleteFiles::addAll);\n+    Option.ofNullable(stat1.getCommandBlocksCount()).ifPresent(commandBlocksCount::putAll);\n+    Option.ofNullable(stat2.getCommandBlocksCount()).ifPresent(commandBlocksCount::putAll);\n+    return new HoodieRollbackStat(stat1.getPartitionPath(), successDeleteFiles, failedDeleteFiles, commandBlocksCount);\n+  }\n+\n+  /**\n+   * Generate all rollback requests that needs rolling back this action without actually performing rollback for COW table type.\n+   * @param fs instance of {@link FileSystem} to use.\n+   * @param basePath base path of interest.\n+   * @param shouldAssumeDatePartitioning {@code true} if date partitioning should be assumed. {@code false} otherwise.\n+   * @return {@link List} of {@link ListingBasedRollbackRequest}s thus collected.\n+   */\n+  public static List<ListingBasedRollbackRequest> generateRollbackRequestsByListingCOW(FileSystem fs, String basePath, boolean shouldAssumeDatePartitioning) {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyMzQ2NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484823465", "bodyText": "the MOR equivalent method got moved I guess\n\nYes,  MOR equivalent method moved to SparkRollbackUtils.", "author": "wangxianghu", "createdAt": "2020-09-08T10:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUxNjMzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/RollbackUtils.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/RollbackUtils.java\nindex 1984c415e..897b448fb 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/RollbackUtils.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/RollbackUtils.java\n\n@@ -20,6 +20,7 @@ package org.apache.hudi.table.action.rollback;\n \n import org.apache.hadoop.fs.FileStatus;\n import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUxNjk5Ng==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484516996", "bodyText": "might make sense to move the COMPACT_POOL_NAME also to the child class", "author": "vinothchandar", "createdAt": "2020-09-07T16:35:59Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/async/HoodieSparkAsyncCompactService.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.async;\n+\n+import org.apache.hudi.asyc.BaseAsyncCompactService;\n+import org.apache.hudi.client.AbstractHoodieWriteClient;\n+import org.apache.hudi.client.BaseCompactor;\n+import org.apache.hudi.client.HoodieSparkCompactor;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.IntStream;\n+\n+public class HoodieSparkAsyncCompactService extends BaseAsyncCompactService {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieSparkAsyncCompactService.class);\n+\n+  private transient JavaSparkContext jssc;\n+  public HoodieSparkAsyncCompactService(HoodieEngineContext context, AbstractHoodieWriteClient client) {\n+    super(context, client);\n+    this.jssc = HoodieSparkEngineContext.getSparkContext(context);\n+  }\n+\n+  public HoodieSparkAsyncCompactService(HoodieEngineContext context, AbstractHoodieWriteClient client, boolean runInDaemonMode) {\n+    super(context, client, runInDaemonMode);\n+    this.jssc = HoodieSparkEngineContext.getSparkContext(context);\n+  }\n+\n+  @Override\n+  protected BaseCompactor createCompactor(AbstractHoodieWriteClient client) {\n+    return new HoodieSparkCompactor(client);\n+  }\n+\n+  @Override\n+  protected Pair<CompletableFuture, ExecutorService> startService() {\n+    ExecutorService executor = Executors.newFixedThreadPool(maxConcurrentCompaction,\n+        r -> {\n+          Thread t = new Thread(r, \"async_compact_thread\");\n+          t.setDaemon(isRunInDaemonMode());\n+          return t;\n+        });\n+    return Pair.of(CompletableFuture.allOf(IntStream.range(0, maxConcurrentCompaction).mapToObj(i -> CompletableFuture.supplyAsync(() -> {\n+      try {\n+        // Set Compactor Pool Name for allowing users to prioritize compaction\n+        LOG.info(\"Setting Spark Pool name for compaction to \" + COMPACT_POOL_NAME);\n+        jssc.setLocalProperty(\"spark.scheduler.pool\", COMPACT_POOL_NAME);", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/async/HoodieSparkAsyncCompactService.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/async/HoodieSparkAsyncCompactService.java\ndeleted file mode 100644\nindex 0e14cd09f..000000000\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/async/HoodieSparkAsyncCompactService.java\n+++ /dev/null\n\n@@ -1,93 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hudi.async;\n-\n-import org.apache.hudi.asyc.BaseAsyncCompactService;\n-import org.apache.hudi.client.AbstractHoodieWriteClient;\n-import org.apache.hudi.client.BaseCompactor;\n-import org.apache.hudi.client.HoodieSparkCompactor;\n-import org.apache.hudi.common.HoodieEngineContext;\n-import org.apache.hudi.common.HoodieSparkEngineContext;\n-import org.apache.hudi.common.table.timeline.HoodieInstant;\n-import org.apache.hudi.common.util.collection.Pair;\n-import org.apache.hudi.exception.HoodieIOException;\n-import org.apache.log4j.LogManager;\n-import org.apache.log4j.Logger;\n-import org.apache.spark.api.java.JavaSparkContext;\n-\n-import java.io.IOException;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.stream.IntStream;\n-\n-public class HoodieSparkAsyncCompactService extends BaseAsyncCompactService {\n-\n-  private static final Logger LOG = LogManager.getLogger(HoodieSparkAsyncCompactService.class);\n-\n-  private transient JavaSparkContext jssc;\n-  public HoodieSparkAsyncCompactService(HoodieEngineContext context, AbstractHoodieWriteClient client) {\n-    super(context, client);\n-    this.jssc = HoodieSparkEngineContext.getSparkContext(context);\n-  }\n-\n-  public HoodieSparkAsyncCompactService(HoodieEngineContext context, AbstractHoodieWriteClient client, boolean runInDaemonMode) {\n-    super(context, client, runInDaemonMode);\n-    this.jssc = HoodieSparkEngineContext.getSparkContext(context);\n-  }\n-\n-  @Override\n-  protected BaseCompactor createCompactor(AbstractHoodieWriteClient client) {\n-    return new HoodieSparkCompactor(client);\n-  }\n-\n-  @Override\n-  protected Pair<CompletableFuture, ExecutorService> startService() {\n-    ExecutorService executor = Executors.newFixedThreadPool(maxConcurrentCompaction,\n-        r -> {\n-          Thread t = new Thread(r, \"async_compact_thread\");\n-          t.setDaemon(isRunInDaemonMode());\n-          return t;\n-        });\n-    return Pair.of(CompletableFuture.allOf(IntStream.range(0, maxConcurrentCompaction).mapToObj(i -> CompletableFuture.supplyAsync(() -> {\n-      try {\n-        // Set Compactor Pool Name for allowing users to prioritize compaction\n-        LOG.info(\"Setting Spark Pool name for compaction to \" + COMPACT_POOL_NAME);\n-        jssc.setLocalProperty(\"spark.scheduler.pool\", COMPACT_POOL_NAME);\n-\n-        while (!isShutdownRequested()) {\n-          final HoodieInstant instant = fetchNextCompactionInstant();\n-\n-          if (null != instant) {\n-            LOG.info(\"Starting Compaction for instant \" + instant);\n-            compactor.compact(instant);\n-            LOG.info(\"Finished Compaction for instant \" + instant);\n-          }\n-        }\n-        LOG.info(\"Compactor shutting down properly!!\");\n-      } catch (InterruptedException ie) {\n-        LOG.warn(\"Compactor executor thread got interrupted exception. Stopping\", ie);\n-      } catch (IOException e) {\n-        LOG.error(\"Compactor executor failed\", e);\n-        throw new HoodieIOException(e.getMessage(), e);\n-      }\n-      return true;\n-    }, executor)).toArray(CompletableFuture[]::new)), executor);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUyMDAxMw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484520013", "bodyText": "wondering if this renaming will have any impact on deserializing older plans. cc @bvaradar to confirm", "author": "vinothchandar", "createdAt": "2020-09-07T16:46:49Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieCompactionAdminTool.java", "diffHunk": "@@ -60,38 +60,38 @@ public static void main(String[] args) throws Exception {\n    */\n   public void run(JavaSparkContext jsc) throws Exception {\n     HoodieTableMetaClient metaClient = new HoodieTableMetaClient(jsc.hadoopConfiguration(), cfg.basePath);\n-    try (CompactionAdminClient admin = new CompactionAdminClient(jsc, cfg.basePath)) {\n+    try (HoodieSparkCompactionAdminClient admin = new HoodieSparkCompactionAdminClient(new HoodieSparkEngineContext(jsc), cfg.basePath)) {\n       final FileSystem fs = FSUtils.getFs(cfg.basePath, jsc.hadoopConfiguration());\n       if (cfg.outputPath != null && fs.exists(new Path(cfg.outputPath))) {\n         throw new IllegalStateException(\"Output File Path already exists\");\n       }\n       switch (cfg.operation) {\n         case VALIDATE:\n-          List<ValidationOpResult> res =\n+          List<BaseCompactionAdminClient.ValidationOpResult> res =\n               admin.validateCompactionPlan(metaClient, cfg.compactionInstantTime, cfg.parallelism);\n           if (cfg.printOutput) {\n             printOperationResult(\"Result of Validation Operation :\", res);\n           }\n           serializeOperationResult(fs, res);\n           break;\n         case UNSCHEDULE_FILE:\n-          List<RenameOpResult> r = admin.unscheduleCompactionFileId(\n+          List<BaseCompactionAdminClient.RenameOpResult> r = admin.unscheduleCompactionFileId(\n               new HoodieFileGroupId(cfg.partitionPath, cfg.fileId), cfg.skipValidation, cfg.dryRun);\n           if (cfg.printOutput) {\n             System.out.println(r);\n           }\n           serializeOperationResult(fs, r);\n           break;\n         case UNSCHEDULE_PLAN:\n-          List<RenameOpResult> r2 = admin.unscheduleCompactionPlan(cfg.compactionInstantTime, cfg.skipValidation,\n+          List<BaseCompactionAdminClient.RenameOpResult> r2 = admin.unscheduleCompactionPlan(cfg.compactionInstantTime, cfg.skipValidation,", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieCompactionAdminTool.java b/hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieCompactionAdminTool.java\nindex a032cb467..d3e4dbab7 100644\n--- a/hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieCompactionAdminTool.java\n+++ b/hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieCompactionAdminTool.java\n\n@@ -60,14 +61,14 @@ public class HoodieCompactionAdminTool {\n    */\n   public void run(JavaSparkContext jsc) throws Exception {\n     HoodieTableMetaClient metaClient = new HoodieTableMetaClient(jsc.hadoopConfiguration(), cfg.basePath);\n-    try (HoodieSparkCompactionAdminClient admin = new HoodieSparkCompactionAdminClient(new HoodieSparkEngineContext(jsc), cfg.basePath)) {\n+    try (CompactionAdminClient admin = new CompactionAdminClient(new HoodieSparkEngineContext(jsc), cfg.basePath)) {\n       final FileSystem fs = FSUtils.getFs(cfg.basePath, jsc.hadoopConfiguration());\n       if (cfg.outputPath != null && fs.exists(new Path(cfg.outputPath))) {\n         throw new IllegalStateException(\"Output File Path already exists\");\n       }\n       switch (cfg.operation) {\n         case VALIDATE:\n-          List<BaseCompactionAdminClient.ValidationOpResult> res =\n+          List<ValidationOpResult> res =\n               admin.validateCompactionPlan(metaClient, cfg.compactionInstantTime, cfg.parallelism);\n           if (cfg.printOutput) {\n             printOperationResult(\"Result of Validation Operation :\", res);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUyMDkyOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484520929", "bodyText": "rename: generateInputRecords", "author": "vinothchandar", "createdAt": "2020-09-07T16:50:14Z", "path": "hudi-spark/src/main/java/org/apache/hudi/bootstrap/SparkParquetBootstrapDataProvider.java", "diffHunk": "@@ -43,18 +43,18 @@\n /**\n  * Spark Data frame based bootstrap input provider.\n  */\n-public class SparkParquetBootstrapDataProvider extends FullRecordBootstrapDataProvider {\n+public class SparkParquetBootstrapDataProvider extends FullRecordBootstrapDataProvider<JavaRDD<HoodieRecord>> {\n \n   private final transient SparkSession sparkSession;\n \n   public SparkParquetBootstrapDataProvider(TypedProperties props,\n-                                           JavaSparkContext jsc) {\n-    super(props, jsc);\n-    this.sparkSession = SparkSession.builder().config(jsc.getConf()).getOrCreate();\n+                                           HoodieSparkEngineContext context) {\n+    super(props, context);\n+    this.sparkSession = SparkSession.builder().config(context.getJavaSparkContext().getConf()).getOrCreate();\n   }\n \n   @Override\n-  public JavaRDD<HoodieRecord> generateInputRecordRDD(String tableName, String sourceBasePath,\n+  public JavaRDD<HoodieRecord> generateInputRecord(String tableName, String sourceBasePath,", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkyODExNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484928117", "bodyText": "rename: generateInputRecords\n\ndone", "author": "wangxianghu", "createdAt": "2020-09-08T13:39:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUyMDkyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-spark/src/main/java/org/apache/hudi/bootstrap/SparkParquetBootstrapDataProvider.java b/hudi-spark/src/main/java/org/apache/hudi/bootstrap/SparkParquetBootstrapDataProvider.java\nindex adf84922a..022abe308 100644\n--- a/hudi-spark/src/main/java/org/apache/hudi/bootstrap/SparkParquetBootstrapDataProvider.java\n+++ b/hudi-spark/src/main/java/org/apache/hudi/bootstrap/SparkParquetBootstrapDataProvider.java\n\n@@ -54,7 +54,7 @@ public class SparkParquetBootstrapDataProvider extends FullRecordBootstrapDataPr\n   }\n \n   @Override\n-  public JavaRDD<HoodieRecord> generateInputRecord(String tableName, String sourceBasePath,\n+  public JavaRDD<HoodieRecord> generateInputRecords(String tableName, String sourceBasePath,\n       List<Pair<String, List<HoodieFileStatus>>> partitionPathsWithFiles) {\n     String[] filePaths = partitionPathsWithFiles.stream().map(Pair::getValue)\n         .flatMap(f -> f.stream().map(fs -> FileStatusUtils.toPath(fs.getPath()).toString()))\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUzODgxNQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484538815", "bodyText": "why was this change required?", "author": "vinothchandar", "createdAt": "2020-09-07T18:15:06Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/testutils/HoodieClientTestUtils.java", "diffHunk": "@@ -81,7 +82,9 @@\n    */\n   public static SparkConf getSparkConfForTest(String appName) {\n     SparkConf sparkConf = new SparkConf().setAppName(appName)\n-        .set(\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\").setMaster(\"local[8]\");\n+        .set(\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\")\n+        .set(\"spark.driver.host\",\"localhost\")", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzMTE2MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484931161", "bodyText": "why was this change required?\n\nI have rolled back this.\nThe unit test is not runnable in my local yesterday, but ok now... weird", "author": "wangxianghu", "createdAt": "2020-09-08T13:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUzODgxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/testutils/HoodieClientTestUtils.java b/hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/testutils/HoodieClientTestUtils.java\nindex 2f4e36c3f..307e06867 100644\n--- a/hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/testutils/HoodieClientTestUtils.java\n+++ b/hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/testutils/HoodieClientTestUtils.java\n\n@@ -82,9 +81,7 @@ public class HoodieClientTestUtils {\n    */\n   public static SparkConf getSparkConfForTest(String appName) {\n     SparkConf sparkConf = new SparkConf().setAppName(appName)\n-        .set(\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\")\n-        .set(\"spark.driver.host\",\"localhost\")\n-        .setMaster(\"local[8]\");\n+        .set(\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\").setMaster(\"local[8]\");\n \n     String evlogDir = System.getProperty(\"SPARK_EVLOG_DIR\");\n     if (evlogDir != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU5ODU1OQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484598559", "bodyText": "need to ensure the ordering of closing resources is the same as before/", "author": "vinothchandar", "createdAt": "2020-09-08T01:01:41Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -716,32 +674,97 @@ private void rollbackPendingCommits() {\n    * @param compactionInstantTime Compaction Instant Time\n    * @return RDD of Write Status\n    */\n-  private JavaRDD<WriteStatus> compact(String compactionInstantTime, boolean shouldComplete) {\n-    HoodieTable<T> table = HoodieTable.create(config, hadoopConf);\n-    HoodieTimeline pendingCompactionTimeline = table.getActiveTimeline().filterPendingCompactionTimeline();\n-    HoodieInstant inflightInstant = HoodieTimeline.getCompactionInflightInstant(compactionInstantTime);\n-    if (pendingCompactionTimeline.containsInstant(inflightInstant)) {\n-      rollbackInflightCompaction(inflightInstant, table);\n-      table.getMetaClient().reloadActiveTimeline();\n-    }\n-    compactionTimer = metrics.getCompactionCtx();\n-    HoodieWriteMetadata compactionMetadata = table.compact(jsc, compactionInstantTime);\n-    JavaRDD<WriteStatus> statuses = compactionMetadata.getWriteStatuses();\n-    if (shouldComplete && compactionMetadata.getCommitMetadata().isPresent()) {\n-      completeCompaction(compactionMetadata.getCommitMetadata().get(), statuses, table, compactionInstantTime);\n-    }\n-    return statuses;\n-  }\n+  protected abstract O compact(String compactionInstantTime, boolean shouldComplete);\n \n   /**\n    * Performs a compaction operation on a table, serially before or after an insert/upsert action.\n    */\n-  private Option<String> inlineCompact(Option<Map<String, String>> extraMetadata) {\n+  protected Option<String> inlineCompact(Option<Map<String, String>> extraMetadata) {\n     Option<String> compactionInstantTimeOpt = scheduleCompaction(extraMetadata);\n     compactionInstantTimeOpt.ifPresent(compactionInstantTime -> {\n       // inline compaction should auto commit as the user is never given control\n       compact(compactionInstantTime, true);\n     });\n     return compactionInstantTimeOpt;\n   }\n+\n+  /**\n+   * Finalize Write operation.\n+   *\n+   * @param table       HoodieTable\n+   * @param instantTime Instant Time\n+   * @param stats       Hoodie Write Stat\n+   */\n+  protected void finalizeWrite(HoodieTable<T, I, K, O, P> table, String instantTime, List<HoodieWriteStat> stats) {\n+    try {\n+      final Timer.Context finalizeCtx = metrics.getFinalizeCtx();\n+      table.finalizeWrite(context, instantTime, stats);\n+      if (finalizeCtx != null) {\n+        Option<Long> durationInMs = Option.of(metrics.getDurationInMs(finalizeCtx.stop()));\n+        durationInMs.ifPresent(duration -> {\n+          LOG.info(\"Finalize write elapsed time (milliseconds): \" + duration);\n+          metrics.updateFinalizeWriteMetrics(duration, stats.size());\n+        });\n+      }\n+    } catch (HoodieIOException ioe) {\n+      throw new HoodieCommitException(\"Failed to complete commit \" + instantTime + \" due to finalize errors.\", ioe);\n+    }\n+  }\n+\n+  public HoodieMetrics getMetrics() {\n+    return metrics;\n+  }\n+\n+  public HoodieIndex<T, I, K, O, P> getIndex() {\n+    return index;\n+  }\n+\n+  /**\n+   * Get HoodieTable and init {@link Timer.Context}.\n+   *\n+   * @param operationType write operation type\n+   * @param instantTime   current inflight instant time\n+   * @return HoodieTable\n+   */\n+  protected abstract HoodieTable<T, I, K, O, P> getTableAndInitCtx(WriteOperationType operationType, String instantTime);\n+\n+  /**\n+   * Sets write schema from last instant since deletes may not have schema set in the config.\n+   */\n+  protected void setWriteSchemaForDeletes(HoodieTableMetaClient metaClient) {\n+    try {\n+      HoodieActiveTimeline activeTimeline = metaClient.getActiveTimeline();\n+      Option<HoodieInstant> lastInstant =\n+          activeTimeline.filterCompletedInstants().filter(s -> s.getAction().equals(metaClient.getCommitActionType()))\n+              .lastInstant();\n+      if (lastInstant.isPresent()) {\n+        HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(\n+            activeTimeline.getInstantDetails(lastInstant.get()).get(), HoodieCommitMetadata.class);\n+        if (commitMetadata.getExtraMetadata().containsKey(HoodieCommitMetadata.SCHEMA_KEY)) {\n+          config.setSchema(commitMetadata.getExtraMetadata().get(HoodieCommitMetadata.SCHEMA_KEY));\n+        } else {\n+          throw new HoodieIOException(\"Latest commit does not have any schema in commit metadata\");\n+        }\n+      } else {\n+        throw new HoodieIOException(\"Deletes issued without any prior commits\");\n+      }\n+    } catch (IOException e) {\n+      throw new HoodieIOException(\"IOException thrown while reading last commit metadata\", e);\n+    }\n+  }\n+\n+  public abstract AsyncCleanerService startAsyncCleaningIfEnabled(AbstractHoodieWriteClient<T, I, K, O, P> client, String instantTime);\n+\n+  @Override\n+  public void close() {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzMTcwNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484931707", "bodyText": "need to ensure the ordering of closing resources is the same as before/\n\nYes, they are the same.", "author": "wangxianghu", "createdAt": "2020-09-08T13:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU5ODU1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\nindex e1f872076..0f35e270e 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n\n@@ -691,11 +729,11 @@ public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I\n   /**\n    * Finalize Write operation.\n    *\n-   * @param table       HoodieTable\n+   * @param table HoodieTable\n    * @param instantTime Instant Time\n-   * @param stats       Hoodie Write Stat\n+   * @param stats Hoodie Write Stat\n    */\n-  protected void finalizeWrite(HoodieTable<T, I, K, O, P> table, String instantTime, List<HoodieWriteStat> stats) {\n+  protected void finalizeWrite(HoodieTable<T, I, K, O> table, String instantTime, List<HoodieWriteStat> stats) {\n     try {\n       final Timer.Context finalizeCtx = metrics.getFinalizeCtx();\n       table.finalizeWrite(context, instantTime, stats);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU5OTI3NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484599275", "bodyText": "Let's name this SparkRDDWriteClient ?", "author": "vinothchandar", "createdAt": "2020-09-08T01:05:55Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client;\n+\n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.client.embedded.SparkEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.HoodieWriteStat;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTableVersion;\n+import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieCompactionConfig;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieCommitException;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.index.HoodieIndex;\n+import org.apache.hudi.index.HoodieSparkIndexFactory;\n+import org.apache.hudi.table.BaseHoodieTimelineArchiveLog;\n+import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieSparkTable;\n+import org.apache.hudi.table.HoodieSparkTimelineArchiveLog;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.SparkMarkerFiles;\n+import org.apache.hudi.table.action.HoodieWriteMetadata;\n+import org.apache.hudi.table.action.compact.SparkCompactHelpers;\n+import org.apache.hudi.table.upgrade.SparkUpgradeDowngrade;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.SparkConf;\n+import org.apache.spark.api.java.JavaPairRDD;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HoodieSparkWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T,", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzMTMxNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484931317", "bodyText": "Let's name this SparkRDDWriteClient ?\n\ndone", "author": "wangxianghu", "createdAt": "2020-09-08T13:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU5OTI3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java\nsimilarity index 54%\nrename from hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java\nrename to hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java\nindex cf04b4d99..56f06898a 100644\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java\n+++ b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java\n\n@@ -18,12 +18,9 @@\n \n package org.apache.hudi.client;\n \n-import com.codahale.metrics.Timer;\n-import org.apache.hadoop.conf.Configuration;\n-import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n-import org.apache.hudi.client.embedded.SparkEmbeddedTimelineService;\n-import org.apache.hudi.common.HoodieEngineContext;\n-import org.apache.hudi.common.HoodieSparkEngineContext;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecord;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMDc0Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484600742", "bodyText": "why are we not hanging onto the returned object?", "author": "vinothchandar", "createdAt": "2020-09-08T01:13:43Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client;\n+\n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.client.embedded.SparkEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.HoodieWriteStat;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTableVersion;\n+import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieCompactionConfig;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieCommitException;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.index.HoodieIndex;\n+import org.apache.hudi.index.HoodieSparkIndexFactory;\n+import org.apache.hudi.table.BaseHoodieTimelineArchiveLog;\n+import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieSparkTable;\n+import org.apache.hudi.table.HoodieSparkTimelineArchiveLog;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.SparkMarkerFiles;\n+import org.apache.hudi.table.action.HoodieWriteMetadata;\n+import org.apache.hudi.table.action.compact.SparkCompactHelpers;\n+import org.apache.hudi.table.upgrade.SparkUpgradeDowngrade;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.SparkConf;\n+import org.apache.spark.api.java.JavaPairRDD;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HoodieSparkWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T,\n+    JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieSparkWriteClient.class);\n+\n+  public HoodieSparkWriteClient(HoodieEngineContext context, HoodieWriteConfig clientConfig) {\n+    super(context, clientConfig);\n+  }\n+\n+  public HoodieSparkWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n+    super(context, writeConfig, rollbackPending);\n+  }\n+\n+  public HoodieSparkWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending, Option<BaseEmbeddedTimelineService> timelineService) {\n+    super(context, writeConfig, rollbackPending, timelineService);\n+  }\n+\n+  /**\n+   * Register hudi classes for Kryo serialization.\n+   *\n+   * @param conf instance of SparkConf\n+   * @return SparkConf\n+   */\n+  public static SparkConf registerClasses(SparkConf conf) {\n+    conf.registerKryoClasses(new Class[]{HoodieWriteConfig.class, HoodieRecord.class, HoodieKey.class});\n+    return conf;\n+  }\n+\n+  @Override\n+  protected HoodieIndex<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> createIndex(HoodieWriteConfig writeConfig) {\n+    return HoodieSparkIndexFactory.createIndex(config);\n+  }\n+\n+  @Override\n+  public boolean commit(String instantTime, JavaRDD<WriteStatus> writeStatuses, Option<Map<String, String>> extraMetadata) {\n+    List<HoodieWriteStat> stats = writeStatuses.map(WriteStatus::getStat).collect();\n+    return commitStats(instantTime, stats, extraMetadata);\n+  }\n+\n+  @Override\n+  protected HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> createTable(HoodieWriteConfig config, Configuration hadoopConf) {\n+    return HoodieSparkTable.create(config, context);\n+  }\n+\n+  @Override\n+  public JavaRDD<HoodieRecord<T>> filterExists(JavaRDD<HoodieRecord<T>> hoodieRecords) {\n+    // Create a Hoodie table which encapsulated the commits and files visible\n+    HoodieTable table = HoodieSparkTable.create(config, context);\n+    Timer.Context indexTimer = metrics.getIndexCtx();\n+    JavaRDD<HoodieRecord<T>> recordsWithLocation = getIndex().tagLocation(hoodieRecords, context, table);\n+    metrics.updateIndexMetrics(LOOKUP_STR, metrics.getDurationInMs(indexTimer == null ? 0L : indexTimer.stop()));\n+    return recordsWithLocation.filter(v1 -> !v1.isCurrentLocationKnown());\n+  }\n+\n+  /**\n+   * Main API to run bootstrap to hudi.\n+   */\n+  @Override\n+  public void bootstrap(Option<Map<String, String>> extraMetadata) {\n+    if (rollbackPending) {\n+      rollBackInflightBootstrap();\n+    }\n+    HoodieSparkTable table = (HoodieSparkTable) getTableAndInitCtx(WriteOperationType.UPSERT, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS);\n+    table.bootstrap(context, extraMetadata);\n+  }\n+\n+  @Override\n+  public JavaRDD<WriteStatus> upsert(JavaRDD<HoodieRecord<T>> records, String instantTime) {\n+    HoodieSparkTable table = (HoodieSparkTable) getTableAndInitCtx(WriteOperationType.UPSERT, instantTime);\n+    table.validateUpsertSchema();\n+    setOperationType(WriteOperationType.UPSERT);\n+    startAsyncCleaningIfEnabled(this, instantTime);", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzMzAxMw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484933013", "bodyText": "why are we not hanging onto the returned object?\n\nmy bad. done", "author": "wangxianghu", "createdAt": "2020-09-08T13:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMDc0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java\nsimilarity index 54%\nrename from hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java\nrename to hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java\nindex cf04b4d99..56f06898a 100644\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java\n+++ b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java\n\n@@ -18,12 +18,9 @@\n \n package org.apache.hudi.client;\n \n-import com.codahale.metrics.Timer;\n-import org.apache.hadoop.conf.Configuration;\n-import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n-import org.apache.hudi.client.embedded.SparkEmbeddedTimelineService;\n-import org.apache.hudi.common.HoodieEngineContext;\n-import org.apache.hudi.common.HoodieSparkEngineContext;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecord;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMDgwNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484600807", "bodyText": "same here and everywhere else.", "author": "vinothchandar", "createdAt": "2020-09-08T01:14:01Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client;\n+\n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.client.embedded.SparkEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.HoodieWriteStat;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTableVersion;\n+import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieCompactionConfig;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieCommitException;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.index.HoodieIndex;\n+import org.apache.hudi.index.HoodieSparkIndexFactory;\n+import org.apache.hudi.table.BaseHoodieTimelineArchiveLog;\n+import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieSparkTable;\n+import org.apache.hudi.table.HoodieSparkTimelineArchiveLog;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.SparkMarkerFiles;\n+import org.apache.hudi.table.action.HoodieWriteMetadata;\n+import org.apache.hudi.table.action.compact.SparkCompactHelpers;\n+import org.apache.hudi.table.upgrade.SparkUpgradeDowngrade;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.SparkConf;\n+import org.apache.spark.api.java.JavaPairRDD;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HoodieSparkWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T,\n+    JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieSparkWriteClient.class);\n+\n+  public HoodieSparkWriteClient(HoodieEngineContext context, HoodieWriteConfig clientConfig) {\n+    super(context, clientConfig);\n+  }\n+\n+  public HoodieSparkWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n+    super(context, writeConfig, rollbackPending);\n+  }\n+\n+  public HoodieSparkWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending, Option<BaseEmbeddedTimelineService> timelineService) {\n+    super(context, writeConfig, rollbackPending, timelineService);\n+  }\n+\n+  /**\n+   * Register hudi classes for Kryo serialization.\n+   *\n+   * @param conf instance of SparkConf\n+   * @return SparkConf\n+   */\n+  public static SparkConf registerClasses(SparkConf conf) {\n+    conf.registerKryoClasses(new Class[]{HoodieWriteConfig.class, HoodieRecord.class, HoodieKey.class});\n+    return conf;\n+  }\n+\n+  @Override\n+  protected HoodieIndex<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> createIndex(HoodieWriteConfig writeConfig) {\n+    return HoodieSparkIndexFactory.createIndex(config);\n+  }\n+\n+  @Override\n+  public boolean commit(String instantTime, JavaRDD<WriteStatus> writeStatuses, Option<Map<String, String>> extraMetadata) {\n+    List<HoodieWriteStat> stats = writeStatuses.map(WriteStatus::getStat).collect();\n+    return commitStats(instantTime, stats, extraMetadata);\n+  }\n+\n+  @Override\n+  protected HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> createTable(HoodieWriteConfig config, Configuration hadoopConf) {\n+    return HoodieSparkTable.create(config, context);\n+  }\n+\n+  @Override\n+  public JavaRDD<HoodieRecord<T>> filterExists(JavaRDD<HoodieRecord<T>> hoodieRecords) {\n+    // Create a Hoodie table which encapsulated the commits and files visible\n+    HoodieTable table = HoodieSparkTable.create(config, context);\n+    Timer.Context indexTimer = metrics.getIndexCtx();\n+    JavaRDD<HoodieRecord<T>> recordsWithLocation = getIndex().tagLocation(hoodieRecords, context, table);\n+    metrics.updateIndexMetrics(LOOKUP_STR, metrics.getDurationInMs(indexTimer == null ? 0L : indexTimer.stop()));\n+    return recordsWithLocation.filter(v1 -> !v1.isCurrentLocationKnown());\n+  }\n+\n+  /**\n+   * Main API to run bootstrap to hudi.\n+   */\n+  @Override\n+  public void bootstrap(Option<Map<String, String>> extraMetadata) {\n+    if (rollbackPending) {\n+      rollBackInflightBootstrap();\n+    }\n+    HoodieSparkTable table = (HoodieSparkTable) getTableAndInitCtx(WriteOperationType.UPSERT, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS);\n+    table.bootstrap(context, extraMetadata);\n+  }\n+\n+  @Override\n+  public JavaRDD<WriteStatus> upsert(JavaRDD<HoodieRecord<T>> records, String instantTime) {\n+    HoodieSparkTable table = (HoodieSparkTable) getTableAndInitCtx(WriteOperationType.UPSERT, instantTime);\n+    table.validateUpsertSchema();\n+    setOperationType(WriteOperationType.UPSERT);\n+    startAsyncCleaningIfEnabled(this, instantTime);\n+    HoodieWriteMetadata<JavaRDD<WriteStatus>> result = table.upsert(context, instantTime, records);\n+    if (result.getIndexLookupDuration().isPresent()) {\n+      metrics.updateIndexMetrics(LOOKUP_STR, result.getIndexLookupDuration().get().toMillis());\n+    }\n+    return postWrite(result, instantTime, table);\n+  }\n+\n+  @Override\n+  public JavaRDD<WriteStatus> upsertPreppedRecords(JavaRDD<HoodieRecord<T>> preppedRecords, String instantTime) {\n+    HoodieSparkTable table = (HoodieSparkTable) getTableAndInitCtx(WriteOperationType.UPSERT_PREPPED, instantTime);\n+    table.validateUpsertSchema();\n+    setOperationType(WriteOperationType.UPSERT_PREPPED);\n+    startAsyncCleaningIfEnabled(this, instantTime);", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java\nsimilarity index 54%\nrename from hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java\nrename to hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java\nindex cf04b4d99..56f06898a 100644\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java\n+++ b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java\n\n@@ -18,12 +18,9 @@\n \n package org.apache.hudi.client;\n \n-import com.codahale.metrics.Timer;\n-import org.apache.hadoop.conf.Configuration;\n-import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n-import org.apache.hudi.client.embedded.SparkEmbeddedTimelineService;\n-import org.apache.hudi.common.HoodieEngineContext;\n-import org.apache.hudi.common.HoodieSparkEngineContext;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecord;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMTYzMQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484601631", "bodyText": "I think we can eliminate the need for breaking this up into spark vs non-spark, by just passing in the host. This class does not make much sense being broken up.", "author": "vinothchandar", "createdAt": "2020-09-08T01:18:10Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/embedded/SparkEmbeddedTimelineService.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.embedded;\n+\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.table.view.FileSystemViewStorageConfig;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.SparkConf;\n+\n+/**\n+ * Spark implementation of Timeline Service.\n+ */\n+public class SparkEmbeddedTimelineService extends BaseEmbeddedTimelineService {\n+\n+  private static final Logger LOG = LogManager.getLogger(SparkEmbeddedTimelineService.class);\n+\n+  public SparkEmbeddedTimelineService(HoodieEngineContext context, FileSystemViewStorageConfig config) {\n+    super(context, config);\n+  }\n+\n+  @Override\n+  public void setHostAddrFromContext(HoodieEngineContext context) {\n+    SparkConf sparkConf = HoodieSparkEngineContext.getSparkContext(context).getConf();\n+    String hostAddr = sparkConf.get(\"spark.driver.host\", null);", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAxNjI5NA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r485016294", "bodyText": "I think we can eliminate the need for breaking this up into spark vs non-spark, by just passing in the host. This class does not make much sense being broken up.\n\ndone, add hoodie.embed.timeline.server.host to HoodieWriteConfig,  it can be obtained via method getEmbeddedServerHost()\nThis is not the same as before(acquired from sparkConf). users who enabled the embedded timeline service should config this hostaddr additionally.", "author": "wangxianghu", "createdAt": "2020-09-08T15:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMTYzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/embedded/SparkEmbeddedTimelineService.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/embedded/SparkEmbeddedTimelineService.java\ndeleted file mode 100644\nindex 4725e8e56..000000000\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/embedded/SparkEmbeddedTimelineService.java\n+++ /dev/null\n\n@@ -1,51 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hudi.client.embedded;\n-\n-import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n-import org.apache.hudi.common.HoodieEngineContext;\n-import org.apache.hudi.common.HoodieSparkEngineContext;\n-import org.apache.hudi.common.table.view.FileSystemViewStorageConfig;\n-import org.apache.log4j.LogManager;\n-import org.apache.log4j.Logger;\n-import org.apache.spark.SparkConf;\n-\n-/**\n- * Spark implementation of Timeline Service.\n- */\n-public class SparkEmbeddedTimelineService extends BaseEmbeddedTimelineService {\n-\n-  private static final Logger LOG = LogManager.getLogger(SparkEmbeddedTimelineService.class);\n-\n-  public SparkEmbeddedTimelineService(HoodieEngineContext context, FileSystemViewStorageConfig config) {\n-    super(context, config);\n-  }\n-\n-  @Override\n-  public void setHostAddrFromContext(HoodieEngineContext context) {\n-    SparkConf sparkConf = HoodieSparkEngineContext.getSparkContext(context).getConf();\n-    String hostAddr = sparkConf.get(\"spark.driver.host\", null);\n-    if (hostAddr != null) {\n-      LOG.info(\"Overriding hostIp to (\" + hostAddr + \") found in spark-conf. It was \" + this.hostAddr);\n-      this.hostAddr = hostAddr;\n-    } else {\n-      LOG.warn(\"Unable to find driver bind address from spark config\");\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMjU2Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484602562", "bodyText": "note to self: make sure these methods are now in the base class", "author": "vinothchandar", "createdAt": "2020-09-08T01:23:12Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/index/hbase/HoodieSparkHBaseIndex.java", "diffHunk": "@@ -18,169 +18,60 @@\n \n package org.apache.hudi.index.hbase;\n \n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.BufferedMutator;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Get;\n+import org.apache.hadoop.hbase.client.HTable;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n import org.apache.hudi.client.WriteStatus;\n import org.apache.hudi.client.utils.SparkConfigUtils;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.HoodieSparkEngineContext;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordLocation;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.table.HoodieTableMetaClient;\n-import org.apache.hudi.common.table.timeline.HoodieTimeline;\n import org.apache.hudi.common.util.Option;\n-import org.apache.hudi.common.util.ReflectionUtils;\n import org.apache.hudi.common.util.collection.Pair;\n-import org.apache.hudi.config.HoodieHBaseIndexConfig;\n import org.apache.hudi.config.HoodieWriteConfig;\n-import org.apache.hudi.exception.HoodieDependentSystemUnavailableException;\n import org.apache.hudi.exception.HoodieIndexException;\n-import org.apache.hudi.index.HoodieIndex;\n import org.apache.hudi.table.HoodieTable;\n-\n-import org.apache.hadoop.conf.Configuration;\n-import org.apache.hadoop.hbase.HBaseConfiguration;\n-import org.apache.hadoop.hbase.HRegionLocation;\n-import org.apache.hadoop.hbase.TableName;\n-import org.apache.hadoop.hbase.client.BufferedMutator;\n-import org.apache.hadoop.hbase.client.Connection;\n-import org.apache.hadoop.hbase.client.ConnectionFactory;\n-import org.apache.hadoop.hbase.client.Delete;\n-import org.apache.hadoop.hbase.client.Get;\n-import org.apache.hadoop.hbase.client.HTable;\n-import org.apache.hadoop.hbase.client.Mutation;\n-import org.apache.hadoop.hbase.client.Put;\n-import org.apache.hadoop.hbase.client.RegionLocator;\n-import org.apache.hadoop.hbase.client.Result;\n-import org.apache.hadoop.hbase.util.Bytes;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n import org.apache.spark.SparkConf;\n import org.apache.spark.api.java.JavaPairRDD;\n import org.apache.spark.api.java.JavaRDD;\n import org.apache.spark.api.java.JavaSparkContext;\n import org.apache.spark.api.java.function.Function2;\n+import scala.Tuple2;\n \n import java.io.IOException;\n-import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n \n-import scala.Tuple2;\n+public class HoodieSparkHBaseIndex<T extends HoodieRecordPayload> extends BaseHoodieHBaseIndex<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {\n \n-/**\n- * Hoodie Index implementation backed by HBase.\n- */\n-public class HBaseIndex<T extends HoodieRecordPayload> extends HoodieIndex<T> {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSparkHBaseIndex.class);\n \n   public static final String DEFAULT_SPARK_EXECUTOR_INSTANCES_CONFIG_NAME = \"spark.executor.instances\";\n   public static final String DEFAULT_SPARK_DYNAMIC_ALLOCATION_ENABLED_CONFIG_NAME = \"spark.dynamicAllocation.enabled\";\n   public static final String DEFAULT_SPARK_DYNAMIC_ALLOCATION_MAX_EXECUTORS_CONFIG_NAME =\n       \"spark.dynamicAllocation.maxExecutors\";\n \n-  private static final byte[] SYSTEM_COLUMN_FAMILY = Bytes.toBytes(\"_s\");\n-  private static final byte[] COMMIT_TS_COLUMN = Bytes.toBytes(\"commit_ts\");\n-  private static final byte[] FILE_NAME_COLUMN = Bytes.toBytes(\"file_name\");\n-  private static final byte[] PARTITION_PATH_COLUMN = Bytes.toBytes(\"partition_path\");\n-  private static final int SLEEP_TIME_MILLISECONDS = 100;\n-\n-  private static final Logger LOG = LogManager.getLogger(HBaseIndex.class);\n-  private static Connection hbaseConnection = null;\n-  private HBaseIndexQPSResourceAllocator hBaseIndexQPSResourceAllocator = null;\n-  private float qpsFraction;\n-  private int maxQpsPerRegionServer;\n-  /**\n-   * multiPutBatchSize will be computed and re-set in updateLocation if\n-   * {@link HoodieHBaseIndexConfig#HBASE_PUT_BATCH_SIZE_AUTO_COMPUTE_PROP} is set to true.\n-   */\n-  private Integer multiPutBatchSize;\n-  private Integer numRegionServersForTable;\n-  private final String tableName;\n-  private HBasePutBatchSizeCalculator putBatchSizeCalculator;\n-\n-  public HBaseIndex(HoodieWriteConfig config) {\n+  public HoodieSparkHBaseIndex(HoodieWriteConfig config) {\n     super(config);\n-    this.tableName = config.getHbaseTableName();\n-    addShutDownHook();\n-    init(config);\n-  }\n-\n-  private void init(HoodieWriteConfig config) {\n-    this.multiPutBatchSize = config.getHbaseIndexGetBatchSize();\n-    this.qpsFraction = config.getHbaseIndexQPSFraction();\n-    this.maxQpsPerRegionServer = config.getHbaseIndexMaxQPSPerRegionServer();\n-    this.putBatchSizeCalculator = new HBasePutBatchSizeCalculator();\n-    this.hBaseIndexQPSResourceAllocator = createQPSResourceAllocator(this.config);\n-  }\n-\n-  public HBaseIndexQPSResourceAllocator createQPSResourceAllocator(HoodieWriteConfig config) {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/index/hbase/HoodieSparkHBaseIndex.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/index/hbase/HoodieSparkHBaseIndex.java\ndeleted file mode 100644\nindex 3640bb646..000000000\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/index/hbase/HoodieSparkHBaseIndex.java\n+++ /dev/null\n\n@@ -1,249 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hudi.index.hbase;\n-\n-import org.apache.hadoop.hbase.TableName;\n-import org.apache.hadoop.hbase.client.BufferedMutator;\n-import org.apache.hadoop.hbase.client.Delete;\n-import org.apache.hadoop.hbase.client.Get;\n-import org.apache.hadoop.hbase.client.HTable;\n-import org.apache.hadoop.hbase.client.Mutation;\n-import org.apache.hadoop.hbase.client.Put;\n-import org.apache.hadoop.hbase.client.Result;\n-import org.apache.hadoop.hbase.util.Bytes;\n-import org.apache.hudi.client.WriteStatus;\n-import org.apache.hudi.client.utils.SparkConfigUtils;\n-import org.apache.hudi.common.HoodieEngineContext;\n-import org.apache.hudi.common.HoodieSparkEngineContext;\n-import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n-import org.apache.hudi.common.model.HoodieRecordLocation;\n-import org.apache.hudi.common.model.HoodieRecordPayload;\n-import org.apache.hudi.common.table.HoodieTableMetaClient;\n-import org.apache.hudi.common.util.Option;\n-import org.apache.hudi.common.util.collection.Pair;\n-import org.apache.hudi.config.HoodieWriteConfig;\n-import org.apache.hudi.exception.HoodieIndexException;\n-import org.apache.hudi.table.HoodieTable;\n-import org.apache.log4j.LogManager;\n-import org.apache.log4j.Logger;\n-import org.apache.spark.SparkConf;\n-import org.apache.spark.api.java.JavaPairRDD;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n-import org.apache.spark.api.java.function.Function2;\n-import scala.Tuple2;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-public class HoodieSparkHBaseIndex<T extends HoodieRecordPayload> extends BaseHoodieHBaseIndex<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {\n-\n-  private static final Logger LOG = LogManager.getLogger(HoodieSparkHBaseIndex.class);\n-\n-  public static final String DEFAULT_SPARK_EXECUTOR_INSTANCES_CONFIG_NAME = \"spark.executor.instances\";\n-  public static final String DEFAULT_SPARK_DYNAMIC_ALLOCATION_ENABLED_CONFIG_NAME = \"spark.dynamicAllocation.enabled\";\n-  public static final String DEFAULT_SPARK_DYNAMIC_ALLOCATION_MAX_EXECUTORS_CONFIG_NAME =\n-      \"spark.dynamicAllocation.maxExecutors\";\n-\n-  public HoodieSparkHBaseIndex(HoodieWriteConfig config) {\n-    super(config);\n-  }\n-\n-  @Override\n-  public JavaRDD<HoodieRecord<T>> tagLocation(JavaRDD<HoodieRecord<T>> recordRDD, HoodieEngineContext context, HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> hoodieTable) throws HoodieIndexException {\n-    return recordRDD.mapPartitionsWithIndex(locationTagFunction(hoodieTable.getMetaClient()), true);\n-  }\n-\n-  /**\n-   * Function that tags each HoodieRecord with an existing location, if known.\n-   */\n-  private Function2<Integer, Iterator<HoodieRecord<T>>, Iterator<HoodieRecord<T>>> locationTagFunction(\n-      HoodieTableMetaClient metaClient) {\n-\n-    return (Function2<Integer, Iterator<HoodieRecord<T>>, Iterator<HoodieRecord<T>>>) (partitionNum,\n-                                                                                       hoodieRecordIterator) -> {\n-\n-      int multiGetBatchSize = config.getHbaseIndexGetBatchSize();\n-\n-      // Grab the global HBase connection\n-      synchronized (HoodieSparkHBaseIndex.class) {\n-        if (hbaseConnection == null || hbaseConnection.isClosed()) {\n-          hbaseConnection = getHBaseConnection();\n-        }\n-      }\n-      List<HoodieRecord<T>> taggedRecords = new ArrayList<>();\n-      try (HTable hTable = (HTable) hbaseConnection.getTable(TableName.valueOf(tableName))) {\n-        List<Get> statements = new ArrayList<>();\n-        List<HoodieRecord> currentBatchOfRecords = new LinkedList<>();\n-        // Do the tagging.\n-        while (hoodieRecordIterator.hasNext()) {\n-          HoodieRecord rec = hoodieRecordIterator.next();\n-          statements.add(generateStatement(rec.getRecordKey()));\n-          currentBatchOfRecords.add(rec);\n-          // iterator till we reach batch size\n-          if (statements.size() >= multiGetBatchSize || !hoodieRecordIterator.hasNext()) {\n-            // get results for batch from Hbase\n-            Result[] results = doGet(hTable, statements);\n-            // clear statements to be GC'd\n-            statements.clear();\n-            for (Result result : results) {\n-              // first, attempt to grab location from HBase\n-              HoodieRecord currentRecord = currentBatchOfRecords.remove(0);\n-              if (result.getRow() != null) {\n-                String keyFromResult = Bytes.toString(result.getRow());\n-                String commitTs = Bytes.toString(result.getValue(SYSTEM_COLUMN_FAMILY, COMMIT_TS_COLUMN));\n-                String fileId = Bytes.toString(result.getValue(SYSTEM_COLUMN_FAMILY, FILE_NAME_COLUMN));\n-                String partitionPath = Bytes.toString(result.getValue(SYSTEM_COLUMN_FAMILY, PARTITION_PATH_COLUMN));\n-\n-                if (checkIfValidCommit(metaClient, commitTs)) {\n-                  currentRecord = new HoodieRecord(new HoodieKey(currentRecord.getRecordKey(), partitionPath),\n-                      currentRecord.getData());\n-                  currentRecord.unseal();\n-                  currentRecord.setCurrentLocation(new HoodieRecordLocation(commitTs, fileId));\n-                  currentRecord.seal();\n-                  taggedRecords.add(currentRecord);\n-                  // the key from Result and the key being processed should be same\n-                  assert (currentRecord.getRecordKey().contentEquals(keyFromResult));\n-                } else { // if commit is invalid, treat this as a new taggedRecord\n-                  taggedRecords.add(currentRecord);\n-                }\n-              } else {\n-                taggedRecords.add(currentRecord);\n-              }\n-            }\n-          }\n-        }\n-      } catch (IOException e) {\n-        throw new HoodieIndexException(\"Failed to Tag indexed locations because of exception with HBase Client\", e);\n-      }\n-      return taggedRecords.iterator();\n-    };\n-  }\n-\n-  @Override\n-  public JavaRDD<WriteStatus> updateLocation(JavaRDD<WriteStatus> writeStatusRDD, HoodieEngineContext context, HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> hoodieTable) throws HoodieIndexException {\n-    JavaSparkContext jsc = HoodieSparkEngineContext.getSparkContext(context);\n-    final HBaseIndexQPSResourceAllocator hBaseIndexQPSResourceAllocator = createQPSResourceAllocator(this.config);\n-    setPutBatchSize(writeStatusRDD, hBaseIndexQPSResourceAllocator, jsc);\n-    LOG.info(\"multiPutBatchSize: before hbase puts\" + multiPutBatchSize);\n-    JavaRDD<WriteStatus> writeStatusJavaRDD = writeStatusRDD.mapPartitionsWithIndex(updateLocationFunction(), true);\n-    // caching the index updated status RDD\n-    writeStatusJavaRDD = writeStatusJavaRDD.persist(SparkConfigUtils.getWriteStatusStorageLevel(config.getProps()));\n-    return writeStatusJavaRDD;\n-  }\n-\n-  private Function2<Integer, Iterator<WriteStatus>, Iterator<WriteStatus>> updateLocationFunction() {\n-\n-    return (Function2<Integer, Iterator<WriteStatus>, Iterator<WriteStatus>>) (partition, statusIterator) -> {\n-\n-      List<WriteStatus> writeStatusList = new ArrayList<>();\n-      // Grab the global HBase connection\n-      synchronized (HoodieSparkHBaseIndex.class) {\n-        if (hbaseConnection == null || hbaseConnection.isClosed()) {\n-          hbaseConnection = getHBaseConnection();\n-        }\n-      }\n-      try (BufferedMutator mutator = hbaseConnection.getBufferedMutator(TableName.valueOf(tableName))) {\n-        while (statusIterator.hasNext()) {\n-          WriteStatus writeStatus = statusIterator.next();\n-          List<Mutation> mutations = new ArrayList<>();\n-          try {\n-            for (HoodieRecord rec : writeStatus.getWrittenRecords()) {\n-              if (!writeStatus.isErrored(rec.getKey())) {\n-                Option<HoodieRecordLocation> loc = rec.getNewLocation();\n-                if (loc.isPresent()) {\n-                  if (rec.getCurrentLocation() != null) {\n-                    // This is an update, no need to update index\n-                    continue;\n-                  }\n-                  Put put = new Put(Bytes.toBytes(rec.getRecordKey()));\n-                  put.addColumn(SYSTEM_COLUMN_FAMILY, COMMIT_TS_COLUMN, Bytes.toBytes(loc.get().getInstantTime()));\n-                  put.addColumn(SYSTEM_COLUMN_FAMILY, FILE_NAME_COLUMN, Bytes.toBytes(loc.get().getFileId()));\n-                  put.addColumn(SYSTEM_COLUMN_FAMILY, PARTITION_PATH_COLUMN, Bytes.toBytes(rec.getPartitionPath()));\n-                  mutations.add(put);\n-                } else {\n-                  // Delete existing index for a deleted record\n-                  Delete delete = new Delete(Bytes.toBytes(rec.getRecordKey()));\n-                  mutations.add(delete);\n-                }\n-              }\n-              if (mutations.size() < multiPutBatchSize) {\n-                continue;\n-              }\n-              doMutations(mutator, mutations);\n-            }\n-            // process remaining puts and deletes, if any\n-            doMutations(mutator, mutations);\n-          } catch (Exception e) {\n-            Exception we = new Exception(\"Error updating index for \" + writeStatus, e);\n-            LOG.error(we);\n-            writeStatus.setGlobalError(we);\n-          }\n-          writeStatusList.add(writeStatus);\n-        }\n-      } catch (IOException e) {\n-        throw new HoodieIndexException(\"Failed to Update Index locations because of exception with HBase Client\", e);\n-      }\n-      return writeStatusList.iterator();\n-    };\n-  }\n-\n-  private void setPutBatchSize(JavaRDD<WriteStatus> writeStatusRDD,\n-                               HBaseIndexQPSResourceAllocator hBaseIndexQPSResourceAllocator, final JavaSparkContext jsc) {\n-    if (config.getHbaseIndexPutBatchSizeAutoCompute()) {\n-      SparkConf conf = jsc.getConf();\n-      int maxExecutors = conf.getInt(DEFAULT_SPARK_EXECUTOR_INSTANCES_CONFIG_NAME, 1);\n-      if (conf.getBoolean(DEFAULT_SPARK_DYNAMIC_ALLOCATION_ENABLED_CONFIG_NAME, false)) {\n-        maxExecutors =\n-            Math.max(maxExecutors, conf.getInt(DEFAULT_SPARK_DYNAMIC_ALLOCATION_MAX_EXECUTORS_CONFIG_NAME, 1));\n-      }\n-\n-      /*\n-       * Each writeStatus represents status information from a write done in one of the IOHandles. If a writeStatus has\n-       * any insert, it implies that the corresponding task contacts HBase for doing puts, since we only do puts for\n-       * inserts from HBaseIndex.\n-       */\n-      final Tuple2<Long, Integer> numPutsParallelismTuple = getHBasePutAccessParallelism(writeStatusRDD);\n-      final long numPuts = numPutsParallelismTuple._1;\n-      final int hbasePutsParallelism = numPutsParallelismTuple._2;\n-      this.numRegionServersForTable = getNumRegionServersAliveForTable();\n-      final float desiredQPSFraction =\n-          hBaseIndexQPSResourceAllocator.calculateQPSFractionForPutsTime(numPuts, this.numRegionServersForTable);\n-      LOG.info(\"Desired QPSFraction :\" + desiredQPSFraction);\n-      LOG.info(\"Number HBase puts :\" + numPuts);\n-      LOG.info(\"Hbase Puts Parallelism :\" + hbasePutsParallelism);\n-      final float availableQpsFraction =\n-          hBaseIndexQPSResourceAllocator.acquireQPSResources(desiredQPSFraction, numPuts);\n-      LOG.info(\"Allocated QPS Fraction :\" + availableQpsFraction);\n-      multiPutBatchSize = putBatchSizeCalculator.getBatchSize(numRegionServersForTable, maxQpsPerRegionServer,\n-          hbasePutsParallelism, maxExecutors, SLEEP_TIME_MILLISECONDS, availableQpsFraction);\n-      LOG.info(\"multiPutBatchSize :\" + multiPutBatchSize);\n-    }\n-  }\n-\n-  protected Tuple2<Long, Integer> getHBasePutAccessParallelism(final JavaRDD<WriteStatus> writeStatusRDD) {\n-    final JavaPairRDD<Long, Integer> insertOnlyWriteStatusRDD = writeStatusRDD\n-        .filter(w -> w.getStat().getNumInserts() > 0).mapToPair(w -> new Tuple2<>(w.getStat().getNumInserts(), 1));\n-    return insertOnlyWriteStatusRDD.fold(new Tuple2<>(0L, 0), (w, c) -> new Tuple2<>(w._1 + c._1, w._2 + c._2));\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMzIzOA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484603238", "bodyText": "note to self: make sure these methods are in the base class now", "author": "vinothchandar", "createdAt": "2020-09-08T01:26:16Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/index/simple/HoodieSparkGlobalSimpleIndex.java", "diffHunk": "@@ -71,43 +75,14 @@ public HoodieGlobalSimpleIndex(HoodieWriteConfig config) {\n    * @return {@link JavaRDD} of records with record locations set\n    */\n   protected JavaRDD<HoodieRecord<T>> tagLocationInternal(JavaRDD<HoodieRecord<T>> inputRecordRDD, JavaSparkContext jsc,\n-                                                         HoodieTable<T> hoodieTable) {\n+                                                         HoodieTable hoodieTable) {\n \n     JavaPairRDD<String, HoodieRecord<T>> keyedInputRecordRDD = inputRecordRDD.mapToPair(entry -> new Tuple2<>(entry.getRecordKey(), entry));\n     JavaPairRDD<HoodieKey, HoodieRecordLocation> allRecordLocationsInTable = fetchAllRecordLocations(jsc, hoodieTable,\n         config.getGlobalSimpleIndexParallelism());\n     return getTaggedRecords(keyedInputRecordRDD, allRecordLocationsInTable);\n   }\n \n-  /**\n-   * Fetch record locations for passed in {@link HoodieKey}s.\n-   *\n-   * @param jsc         instance of {@link JavaSparkContext} to use\n-   * @param hoodieTable instance of {@link HoodieTable} of interest\n-   * @param parallelism parallelism to use\n-   * @return {@link JavaPairRDD} of {@link HoodieKey} and {@link HoodieRecordLocation}\n-   */\n-  protected JavaPairRDD<HoodieKey, HoodieRecordLocation> fetchAllRecordLocations(JavaSparkContext jsc,\n-                                                                                 HoodieTable hoodieTable,\n-                                                                                 int parallelism) {\n-    List<Pair<String, HoodieBaseFile>> latestBaseFiles = getAllBaseFilesInTable(jsc, hoodieTable);\n-    return fetchRecordLocations(jsc, hoodieTable, parallelism, latestBaseFiles);\n-  }\n-\n-  /**\n-   * Load all files for all partitions as <Partition, filename> pair RDD.\n-   */\n-  protected List<Pair<String, HoodieBaseFile>> getAllBaseFilesInTable(final JavaSparkContext jsc, final HoodieTable hoodieTable) {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/index/simple/HoodieSparkGlobalSimpleIndex.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/index/simple/SparkHoodieGlobalSimpleIndex.java\nsimilarity index 78%\nrename from hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/index/simple/HoodieSparkGlobalSimpleIndex.java\nrename to hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/index/simple/SparkHoodieGlobalSimpleIndex.java\nindex d8d699000..bdb4991cf 100644\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/index/simple/HoodieSparkGlobalSimpleIndex.java\n+++ b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/index/simple/SparkHoodieGlobalSimpleIndex.java\n\n@@ -56,33 +51,67 @@ import static org.apache.hudi.index.HoodieIndexUtils.getLatestBaseFilesForAllPar\n  *\n  * @param <T>\n  */\n-public class HoodieSparkGlobalSimpleIndex<T extends HoodieRecordPayload> extends HoodieSparkSimpleIndex<T> {\n-  public HoodieSparkGlobalSimpleIndex(HoodieWriteConfig config) {\n+@SuppressWarnings(\"checkstyle:LineLength\")\n+public class SparkHoodieGlobalSimpleIndex<T extends HoodieRecordPayload> extends SparkHoodieSimpleIndex<T> {\n+\n+  public SparkHoodieGlobalSimpleIndex(HoodieWriteConfig config) {\n     super(config);\n   }\n \n   @Override\n-  public JavaRDD<HoodieRecord<T>> tagLocation(JavaRDD<HoodieRecord<T>> recordRDD, HoodieEngineContext context, HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> hoodieTable) throws HoodieIndexException {\n-    return tagLocationInternal(recordRDD, HoodieSparkEngineContext.getSparkContext(context), hoodieTable);\n+  public JavaRDD<HoodieRecord<T>> tagLocation(JavaRDD<HoodieRecord<T>> recordRDD, HoodieEngineContext context,\n+                                              HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> hoodieTable) {\n+    return tagLocationInternal(recordRDD, context, hoodieTable);\n   }\n \n   /**\n    * Tags records location for incoming records.\n    *\n    * @param inputRecordRDD   {@link JavaRDD} of incoming records\n-   * @param jsc         instance of {@link JavaSparkContext} to use\n+   * @param context         instance of {@link HoodieEngineContext} to use\n    * @param hoodieTable instance of {@link HoodieTable} to use\n    * @return {@link JavaRDD} of records with record locations set\n    */\n-  protected JavaRDD<HoodieRecord<T>> tagLocationInternal(JavaRDD<HoodieRecord<T>> inputRecordRDD, JavaSparkContext jsc,\n-                                                         HoodieTable hoodieTable) {\n+  @Override\n+  protected JavaRDD<HoodieRecord<T>> tagLocationInternal(JavaRDD<HoodieRecord<T>> inputRecordRDD, HoodieEngineContext context,\n+                                                         HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> hoodieTable) {\n \n     JavaPairRDD<String, HoodieRecord<T>> keyedInputRecordRDD = inputRecordRDD.mapToPair(entry -> new Tuple2<>(entry.getRecordKey(), entry));\n-    JavaPairRDD<HoodieKey, HoodieRecordLocation> allRecordLocationsInTable = fetchAllRecordLocations(jsc, hoodieTable,\n+    JavaPairRDD<HoodieKey, HoodieRecordLocation> allRecordLocationsInTable = fetchAllRecordLocations(context, hoodieTable,\n         config.getGlobalSimpleIndexParallelism());\n     return getTaggedRecords(keyedInputRecordRDD, allRecordLocationsInTable);\n   }\n \n+  /**\n+   * Fetch record locations for passed in {@link HoodieKey}s.\n+   *\n+   * @param context         instance of {@link HoodieEngineContext} to use\n+   * @param hoodieTable instance of {@link HoodieTable} of interest\n+   * @param parallelism parallelism to use\n+   * @return {@link JavaPairRDD} of {@link HoodieKey} and {@link HoodieRecordLocation}\n+   */\n+  protected JavaPairRDD<HoodieKey, HoodieRecordLocation> fetchAllRecordLocations(HoodieEngineContext context,\n+                                                                                 HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> hoodieTable,\n+                                                                                 int parallelism) {\n+    List<Pair<String, HoodieBaseFile>> latestBaseFiles = getAllBaseFilesInTable(context, hoodieTable);\n+    return fetchRecordLocations(context, hoodieTable, parallelism, latestBaseFiles);\n+  }\n+\n+  /**\n+   * Load all files for all partitions as <Partition, filename> pair RDD.\n+   */\n+  protected List<Pair<String, HoodieBaseFile>> getAllBaseFilesInTable(final HoodieEngineContext context,\n+                                                                      final HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> hoodieTable) {\n+    HoodieTableMetaClient metaClient = hoodieTable.getMetaClient();\n+    try {\n+      List<String> allPartitionPaths = FSUtils.getAllPartitionPaths(metaClient.getFs(), metaClient.getBasePath(), config.shouldAssumeDatePartitioning());\n+      // Obtain the latest data files from all the partitions.\n+      return getLatestBaseFilesForAllPartitions(allPartitionPaths, context, hoodieTable);\n+    } catch (IOException e) {\n+      throw new HoodieIOException(\"Failed to load all partitions\", e);\n+    }\n+  }\n+\n   /**\n    * Tag records with right {@link HoodieRecordLocation}.\n    *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMzgwMA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484603800", "bodyText": "at the MergeHandle level, we need not introduce any notion of RDDs. the io package should be free of spark already. All we need to do is to pass in the taskContextSupplier correctly? This is a large outstanding issue we need to resolve", "author": "vinothchandar", "createdAt": "2020-09-08T01:29:10Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/HoodieSparkMergeHandle.java", "diffHunk": "@@ -54,9 +60,9 @@\n import java.util.Set;\n \n @SuppressWarnings(\"Duplicates\")\n-public class HoodieMergeHandle<T extends HoodieRecordPayload> extends HoodieWriteHandle<T> {\n+public class HoodieSparkMergeHandle<T extends HoodieRecordPayload> extends HoodieWriteHandle<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyNjU4MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r485026581", "bodyText": "at the MergeHandle level, we need not introduce any notion of RDDs. the io package should be free of spark already. All we need to do is to pass in the taskContextSupplier correctly? This is a large outstanding issue we need to resolve\n\nActually not yet. #1756 added support for rollbacks using marker files, and MarkerFiles is spark related.", "author": "wangxianghu", "createdAt": "2020-09-08T15:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMzgwMA=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/HoodieSparkMergeHandle.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieMergeHandle.java\nsimilarity index 89%\nrename from hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/HoodieSparkMergeHandle.java\nrename to hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieMergeHandle.java\nindex 8d6e61590..77fef5c1d 100644\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/HoodieSparkMergeHandle.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieMergeHandle.java\n\n@@ -60,9 +53,9 @@ import java.util.Map;\n import java.util.Set;\n \n @SuppressWarnings(\"Duplicates\")\n-public class HoodieSparkMergeHandle<T extends HoodieRecordPayload> extends HoodieWriteHandle<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {\n+public class HoodieMergeHandle<T extends HoodieRecordPayload, I, K, O> extends HoodieWriteHandle<T, I, K, O> {\n \n-  private static final Logger LOG = LogManager.getLogger(HoodieSparkMergeHandle.class);\n+  private static final Logger LOG = LogManager.getLogger(HoodieMergeHandle.class);\n \n   protected Map<String, HoodieRecord<T>> keyToNewRecords;\n   protected Set<String> writtenRecordKeys;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNDAxMQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484604011", "bodyText": "please refrain from moving methods around within the file. it makes life hard during review :(", "author": "vinothchandar", "createdAt": "2020-09-08T01:30:08Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/HoodieSparkMergeHandle.java", "diffHunk": "@@ -71,34 +77,25 @@\n   protected boolean useWriterSchema;\n   private HoodieBaseFile baseFileToMerge;\n \n-  public HoodieMergeHandle(HoodieWriteConfig config, String instantTime, HoodieTable<T> hoodieTable,\n-       Iterator<HoodieRecord<T>> recordItr, String partitionPath, String fileId, SparkTaskContextSupplier sparkTaskContextSupplier) {\n-    super(config, instantTime, partitionPath, fileId, hoodieTable, sparkTaskContextSupplier);\n+  public HoodieSparkMergeHandle(HoodieWriteConfig config, String instantTime, HoodieTable hoodieTable,\n+                                Iterator<HoodieRecord<T>> recordItr, String partitionPath, String fileId, TaskContextSupplier taskContextSupplier) {\n+    super(config, instantTime, partitionPath, fileId, hoodieTable, taskContextSupplier);\n     init(fileId, recordItr);\n     init(fileId, partitionPath, hoodieTable.getBaseFileOnlyView().getLatestBaseFile(partitionPath, fileId).get());\n   }\n \n   /**\n    * Called by compactor code path.\n    */\n-  public HoodieMergeHandle(HoodieWriteConfig config, String instantTime, HoodieTable<T> hoodieTable,\n-      Map<String, HoodieRecord<T>> keyToNewRecords, String partitionPath, String fileId,\n-      HoodieBaseFile dataFileToBeMerged, SparkTaskContextSupplier sparkTaskContextSupplier) {\n-    super(config, instantTime, partitionPath, fileId, hoodieTable, sparkTaskContextSupplier);\n+  public HoodieSparkMergeHandle(HoodieWriteConfig config, String instantTime, HoodieTable hoodieTable,\n+                                Map<String, HoodieRecord<T>> keyToNewRecords, String partitionPath, String fileId,\n+                                HoodieBaseFile dataFileToBeMerged, TaskContextSupplier taskContextSupplier) {\n+    super(config, instantTime, partitionPath, fileId, hoodieTable, taskContextSupplier);\n     this.keyToNewRecords = keyToNewRecords;\n     this.useWriterSchema = true;\n     init(fileId, this.partitionPath, dataFileToBeMerged);\n   }\n \n-  @Override", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyNzU4Mw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r485027583", "bodyText": "please refrain from moving methods around within the file. it makes life hard during review :(\n\nsorry for the inconvenient, let me see what I can do to avoid this :)", "author": "wangxianghu", "createdAt": "2020-09-08T15:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNDAxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/HoodieSparkMergeHandle.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieMergeHandle.java\nsimilarity index 89%\nrename from hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/HoodieSparkMergeHandle.java\nrename to hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieMergeHandle.java\nindex 8d6e61590..77fef5c1d 100644\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/HoodieSparkMergeHandle.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieMergeHandle.java\n\n@@ -77,8 +70,9 @@ public class HoodieSparkMergeHandle<T extends HoodieRecordPayload> extends Hoodi\n   protected boolean useWriterSchema;\n   private HoodieBaseFile baseFileToMerge;\n \n-  public HoodieSparkMergeHandle(HoodieWriteConfig config, String instantTime, HoodieTable hoodieTable,\n-                                Iterator<HoodieRecord<T>> recordItr, String partitionPath, String fileId, TaskContextSupplier taskContextSupplier) {\n+  public HoodieMergeHandle(HoodieWriteConfig config, String instantTime, HoodieTable<T, I, K, O> hoodieTable,\n+                           Iterator<HoodieRecord<T>> recordItr, String partitionPath, String fileId,\n+                           TaskContextSupplier taskContextSupplier) {\n     super(config, instantTime, partitionPath, fileId, hoodieTable, taskContextSupplier);\n     init(fileId, recordItr);\n     init(fileId, partitionPath, hoodieTable.getBaseFileOnlyView().getLatestBaseFile(partitionPath, fileId).get());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNDI5Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484604292", "bodyText": "same here. we need to make sure these factory methods don't have spark vs non-spark versions", "author": "vinothchandar", "createdAt": "2020-09-08T01:31:14Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/SparkAppendHandleFactory.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.io;\n+\n+import org.apache.hudi.client.SparkTaskContextSupplier;\n+import org.apache.hudi.client.TaskContextSupplier;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.spark.api.java.JavaPairRDD;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+/**\n+ * Factory to create {@link HoodieSparkAppendHandle}.\n+ */\n+public class SparkAppendHandleFactory<T extends HoodieRecordPayload> extends WriteHandleFactory<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAwMDY4Nw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494000687", "bodyText": "same here. we need to make sure these factory methods don't have spark vs non-spark versions\n\ndone", "author": "wangxianghu", "createdAt": "2020-09-24T02:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNDI5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/SparkAppendHandleFactory.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/SparkAppendHandleFactory.java\ndeleted file mode 100644\nindex 2b845022d..000000000\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/SparkAppendHandleFactory.java\n+++ /dev/null\n\n@@ -1,45 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hudi.io;\n-\n-import org.apache.hudi.client.SparkTaskContextSupplier;\n-import org.apache.hudi.client.TaskContextSupplier;\n-import org.apache.hudi.client.WriteStatus;\n-import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n-import org.apache.hudi.common.model.HoodieRecordPayload;\n-import org.apache.hudi.common.util.Option;\n-import org.apache.hudi.common.util.collection.Pair;\n-import org.apache.hudi.config.HoodieWriteConfig;\n-\n-import org.apache.hudi.table.HoodieTable;\n-import org.apache.spark.api.java.JavaPairRDD;\n-import org.apache.spark.api.java.JavaRDD;\n-\n-/**\n- * Factory to create {@link HoodieSparkAppendHandle}.\n- */\n-public class SparkAppendHandleFactory<T extends HoodieRecordPayload> extends WriteHandleFactory<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {\n-\n-  @Override\n-  public HoodieSparkAppendHandle<T> create(HoodieWriteConfig config, String commitTime, HoodieTable hoodieTable, String partitionPath, String fileIdPrefix, TaskContextSupplier taskContextSupplier) {\n-    return new HoodieSparkAppendHandle(config, commitTime, hoodieTable, partitionPath,\n-        getNextFileId(fileIdPrefix), (SparkTaskContextSupplier) taskContextSupplier);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNDM2OQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484604369", "bodyText": "same. is there a way to not make these spark specific", "author": "vinothchandar", "createdAt": "2020-09-08T01:31:41Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/SparkCreateHandleFactory.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.io;\n+\n+import org.apache.hudi.client.TaskContextSupplier;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.spark.api.java.JavaPairRDD;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+public class SparkCreateHandleFactory<T extends HoodieRecordPayload> extends WriteHandleFactory<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {\n+\n+  @Override\n+  public HoodieSparkCreateHandle create(final HoodieWriteConfig hoodieConfig,", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzMzc1NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484933755", "bodyText": "same. is there a way to not make these spark specific\n\nI'll give a try", "author": "wangxianghu", "createdAt": "2020-09-08T13:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNDM2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/SparkCreateHandleFactory.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/SparkCreateHandleFactory.java\ndeleted file mode 100644\nindex 26b48debe..000000000\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/SparkCreateHandleFactory.java\n+++ /dev/null\n\n@@ -1,46 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hudi.io;\n-\n-import org.apache.hudi.client.TaskContextSupplier;\n-import org.apache.hudi.client.WriteStatus;\n-import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n-import org.apache.hudi.common.model.HoodieRecordPayload;\n-import org.apache.hudi.common.util.Option;\n-import org.apache.hudi.common.util.collection.Pair;\n-import org.apache.hudi.config.HoodieWriteConfig;\n-import org.apache.hudi.table.HoodieTable;\n-import org.apache.spark.api.java.JavaPairRDD;\n-import org.apache.spark.api.java.JavaRDD;\n-\n-public class SparkCreateHandleFactory<T extends HoodieRecordPayload> extends WriteHandleFactory<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {\n-\n-  @Override\n-  public HoodieSparkCreateHandle create(final HoodieWriteConfig hoodieConfig,\n-                                        final String commitTime,\n-                                        final HoodieTable hoodieTable,\n-                                        final String partitionPath,\n-                                        final String fileIdPrefix,\n-                                        TaskContextSupplier taskContextSupplier) {\n-\n-    return new HoodieSparkCreateHandle(hoodieConfig, commitTime, hoodieTable, partitionPath,\n-        getNextFileId(fileIdPrefix), taskContextSupplier);\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNTI5MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484605290", "bodyText": "we can actually try and keep this generic and just pass in what we need from taggedRecords to constructor instead of the entire thing", "author": "vinothchandar", "createdAt": "2020-09-08T01:36:26Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkWorkloadProfile.java", "diffHunk": "@@ -22,49 +22,22 @@\n import org.apache.hudi.common.model.HoodieRecordLocation;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.util.Option;\n-\n import org.apache.spark.api.java.JavaRDD;\n+import scala.Tuple2;\n \n-import java.io.Serializable;\n-import java.util.HashMap;\n import java.util.Map;\n-import java.util.Set;\n-\n-import scala.Tuple2;\n \n /**\n- * Information about incoming records for upsert/insert obtained either via sampling or introspecting the data fully.\n- * <p>\n- * TODO(vc): Think about obtaining this directly from index.tagLocation\n+ * Spark implementation of {@link BaseWorkloadProfile}.\n+ * @param <T>\n  */\n-public class WorkloadProfile<T extends HoodieRecordPayload> implements Serializable {\n-\n-  /**\n-   * Input workload.\n-   */\n-  private final JavaRDD<HoodieRecord<T>> taggedRecords;\n-\n-  /**\n-   * Computed workload profile.\n-   */\n-  private final HashMap<String, WorkloadStat> partitionPathStatMap;\n-\n-  /**\n-   * Global workloadStat.\n-   */\n-  private final WorkloadStat globalStat;\n-\n-  public WorkloadProfile(JavaRDD<HoodieRecord<T>> taggedRecords) {\n-    this.taggedRecords = taggedRecords;\n-    this.partitionPathStatMap = new HashMap<>();\n-    this.globalStat = new WorkloadStat();\n-    buildProfile();\n+public class SparkWorkloadProfile<T extends HoodieRecordPayload> extends BaseWorkloadProfile<JavaRDD<HoodieRecord<T>>> {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1ODI2MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r485058261", "bodyText": "we can actually try and keep this generic and just pass in what we need from taggedRecords to constructor instead of the entire thing\n\ndone", "author": "wangxianghu", "createdAt": "2020-09-08T16:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNTI5MA=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkWorkloadProfile.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkWorkloadProfile.java\ndeleted file mode 100644\nindex b5127c568..000000000\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkWorkloadProfile.java\n+++ /dev/null\n\n@@ -1,70 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hudi.table;\n-\n-import org.apache.hudi.common.model.HoodieRecord;\n-import org.apache.hudi.common.model.HoodieRecordLocation;\n-import org.apache.hudi.common.model.HoodieRecordPayload;\n-import org.apache.hudi.common.util.Option;\n-import org.apache.spark.api.java.JavaRDD;\n-import scala.Tuple2;\n-\n-import java.util.Map;\n-\n-/**\n- * Spark implementation of {@link BaseWorkloadProfile}.\n- * @param <T>\n- */\n-public class SparkWorkloadProfile<T extends HoodieRecordPayload> extends BaseWorkloadProfile<JavaRDD<HoodieRecord<T>>> {\n-  public SparkWorkloadProfile(JavaRDD<HoodieRecord<T>> taggedRecords) {\n-    super(taggedRecords);\n-  }\n-\n-  @Override\n-  public void buildProfile() {\n-    // group the records by partitionPath + currentLocation combination, count the number of\n-    // records in each partition\n-    Map<Tuple2<String, Option<HoodieRecordLocation>>, Long> partitionLocationCounts = taggedRecords\n-        .mapToPair(record -> new Tuple2<>(\n-            new Tuple2<>(record.getPartitionPath(), Option.ofNullable(record.getCurrentLocation())), record))\n-        .countByKey();\n-\n-    // count the number of both inserts and updates in each partition, update the counts to workLoadStats\n-    for (Map.Entry<Tuple2<String, Option<HoodieRecordLocation>>, Long> e : partitionLocationCounts.entrySet()) {\n-      String partitionPath = e.getKey()._1();\n-      Long count = e.getValue();\n-      Option<HoodieRecordLocation> locOption = e.getKey()._2();\n-\n-      if (!partitionPathStatMap.containsKey(partitionPath)) {\n-        partitionPathStatMap.put(partitionPath, new WorkloadStat());\n-      }\n-\n-      if (locOption.isPresent()) {\n-        // update\n-        partitionPathStatMap.get(partitionPath).addUpdates(locOption.get(), count);\n-        globalStat.addUpdates(locOption.get(), count);\n-      } else {\n-        // insert\n-        partitionPathStatMap.get(partitionPath).addInserts(count);\n-        globalStat.addInserts(count);\n-      }\n-    }\n-  }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNTUxNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484605517", "bodyText": "hmmm? why do we return null here", "author": "vinothchandar", "createdAt": "2020-09-08T01:37:30Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/bootstrap/SparkBootstrapCommitActionExecutor.java", "diffHunk": "@@ -77,34 +81,44 @@\n import org.apache.parquet.hadoop.ParquetReader;\n import org.apache.parquet.hadoop.metadata.ParquetMetadata;\n import org.apache.parquet.schema.MessageType;\n-import org.apache.spark.Partitioner;\n+import org.apache.spark.api.java.JavaPairRDD;\n import org.apache.spark.api.java.JavaRDD;\n import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n-public class BootstrapCommitActionExecutor<T extends HoodieRecordPayload<T>>\n-    extends BaseCommitActionExecutor<T, HoodieBootstrapWriteMetadata> {\n+public class SparkBootstrapCommitActionExecutor<T extends HoodieRecordPayload>\n+    extends BaseCommitActionExecutor<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>, HoodieBootstrapWriteMetadata> {\n \n-  private static final Logger LOG = LogManager.getLogger(BootstrapCommitActionExecutor.class);\n+  private static final Logger LOG = LogManager.getLogger(SparkBootstrapCommitActionExecutor.class);\n   protected String bootstrapSchema = null;\n   private transient FileSystem bootstrapSourceFileSystem;\n \n-  public BootstrapCommitActionExecutor(JavaSparkContext jsc, HoodieWriteConfig config, HoodieTable<?> table,\n-      Option<Map<String, String>> extraMetadata) {\n-    super(jsc, new HoodieWriteConfig.Builder().withProps(config.getProps())\n-        .withAutoCommit(true).withWriteStatusClass(BootstrapWriteStatus.class)\n-        .withBulkInsertParallelism(config.getBootstrapParallelism())\n-        .build(), table, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS, WriteOperationType.BOOTSTRAP,\n+  public SparkBootstrapCommitActionExecutor(HoodieSparkEngineContext context,\n+                                            HoodieWriteConfig config,\n+                                            HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> table,\n+                                            Option<Map<String, String>> extraMetadata) {\n+    super(context, new HoodieWriteConfig.Builder().withProps(config.getProps())\n+            .withAutoCommit(true).withWriteStatusClass(BootstrapWriteStatus.class)\n+            .withBulkInsertParallelism(config.getBootstrapParallelism())\n+            .build(), table, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS, WriteOperationType.BOOTSTRAP,\n         extraMetadata);\n     bootstrapSourceFileSystem = FSUtils.getFs(config.getBootstrapSourceBasePath(), hadoopConf);\n   }\n \n+  @Override\n+  public HoodieWriteMetadata<JavaRDD<WriteStatus>> execute(JavaRDD<HoodieRecord<T>> inputRecordsRDD) {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0MDIwMw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484940203", "bodyText": "hmmm? why do we return null here\n\nBootstrapCommitActionExecutor dose not need this method actually, inherited from its parent class.", "author": "wangxianghu", "createdAt": "2020-09-08T13:55:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNTUxNw=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/bootstrap/SparkBootstrapCommitActionExecutor.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/bootstrap/SparkBootstrapCommitActionExecutor.java\nindex 4bde30d61..64df78c0d 100644\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/bootstrap/SparkBootstrapCommitActionExecutor.java\n+++ b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/bootstrap/SparkBootstrapCommitActionExecutor.java\n\n@@ -81,7 +83,6 @@ import org.apache.parquet.hadoop.ParquetFileReader;\n import org.apache.parquet.hadoop.ParquetReader;\n import org.apache.parquet.hadoop.metadata.ParquetMetadata;\n import org.apache.parquet.schema.MessageType;\n-import org.apache.spark.api.java.JavaPairRDD;\n import org.apache.spark.api.java.JavaRDD;\n import org.apache.spark.api.java.JavaSparkContext;\n \n"}}, {"oid": "b002589fedc67299449c3356a4abd1cc6d363dae", "url": "https://github.com/apache/hudi/commit/b002589fedc67299449c3356a4abd1cc6d363dae", "message": "add SparkHoodieIndex", "committedDate": "2020-09-08T10:25:49Z", "type": "forcePushed"}, {"oid": "82f0cd83dfbed28aa693279943f89913025c6ccf", "url": "https://github.com/apache/hudi/commit/82f0cd83dfbed28aa693279943f89913025c6ccf", "message": "add SparkHoodieIndex", "committedDate": "2020-09-08T11:11:27Z", "type": "forcePushed"}, {"oid": "84656038e5ebafbb1585dc42cea14b76ef58a489", "url": "https://github.com/apache/hudi/commit/84656038e5ebafbb1585dc42cea14b76ef58a489", "message": "add SparkHoodieIndex", "committedDate": "2020-09-08T13:50:57Z", "type": "forcePushed"}, {"oid": "f39dfa997704f0dbd02fba8745699a92af668049", "url": "https://github.com/apache/hudi/commit/f39dfa997704f0dbd02fba8745699a92af668049", "message": "edit travis.yml", "committedDate": "2020-09-08T14:32:33Z", "type": "forcePushed"}, {"oid": "d59df457569584145896f08855cf5e53e765e9d1", "url": "https://github.com/apache/hudi/commit/d59df457569584145896f08855cf5e53e765e9d1", "message": "edit travis.yml", "committedDate": "2020-09-08T14:40:46Z", "type": "forcePushed"}, {"oid": "58746a68aaa2ffa8dd85a9a6cbc68db6af02d457", "url": "https://github.com/apache/hudi/commit/58746a68aaa2ffa8dd85a9a6cbc68db6af02d457", "message": "add SparkHoodieIndex", "committedDate": "2020-09-08T14:51:47Z", "type": "forcePushed"}, {"oid": "01b4f4a433c49a83df2d6370effaa1356df1343d", "url": "https://github.com/apache/hudi/commit/01b4f4a433c49a83df2d6370effaa1356df1343d", "message": "add SparkHoodieIndex", "committedDate": "2020-09-08T15:33:16Z", "type": "forcePushed"}, {"oid": "54d352ac06b57da3116aefa00aec80cdd45ada5a", "url": "https://github.com/apache/hudi/commit/54d352ac06b57da3116aefa00aec80cdd45ada5a", "message": "trigger ci", "committedDate": "2020-09-09T14:57:00Z", "type": "forcePushed"}, {"oid": "e94a33d304341fc61b9ddaf82b3e0868f223b92c", "url": "https://github.com/apache/hudi/commit/e94a33d304341fc61b9ddaf82b3e0868f223b92c", "message": "trigger ci", "committedDate": "2020-09-10T13:47:42Z", "type": "forcePushed"}, {"oid": "23b9e3649bb337c5815b3d1234354667e0a47859", "url": "https://github.com/apache/hudi/commit/23b9e3649bb337c5815b3d1234354667e0a47859", "message": "trigger ci", "committedDate": "2020-09-10T13:53:02Z", "type": "forcePushed"}, {"oid": "dc5e08a9eb3501c5a0bd86c12a5978d4070ea465", "url": "https://github.com/apache/hudi/commit/dc5e08a9eb3501c5a0bd86c12a5978d4070ea465", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-11T08:04:15Z", "type": "forcePushed"}, {"oid": "23b9e3649bb337c5815b3d1234354667e0a47859", "url": "https://github.com/apache/hudi/commit/23b9e3649bb337c5815b3d1234354667e0a47859", "message": "trigger ci", "committedDate": "2020-09-10T13:53:02Z", "type": "forcePushed"}, {"oid": "bb34e0d3c3d8be74472276f0899cb369600380bb", "url": "https://github.com/apache/hudi/commit/bb34e0d3c3d8be74472276f0899cb369600380bb", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-11T08:17:16Z", "type": "forcePushed"}, {"oid": "23b9e3649bb337c5815b3d1234354667e0a47859", "url": "https://github.com/apache/hudi/commit/23b9e3649bb337c5815b3d1234354667e0a47859", "message": "trigger ci", "committedDate": "2020-09-10T13:53:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492261837", "bodyText": "I think we should leave this abstract and let the engines implement this?  even for Java. Its better to have a HoodieJavaEngineContext. From what I can see, this is not overridden in HoodieSparkEngineContext and thus we lose the parallel execution that we currently have with Spark with this change.", "author": "vinothchandar", "createdAt": "2020-09-21T18:26:34Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/common/HoodieEngineContext.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common;\n+\n+import org.apache.hudi.client.TaskContextSupplier;\n+import org.apache.hudi.common.config.SerializableConfiguration;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Base class contains the context information needed by the engine at runtime. It will be extended by different\n+ * engine implementation if needed.\n+ */\n+public class HoodieEngineContext {\n+  /**\n+   * A wrapped hadoop configuration which can be serialized.\n+   */\n+  private SerializableConfiguration hadoopConf;\n+\n+  private TaskContextSupplier taskContextSupplier;\n+\n+  public HoodieEngineContext(SerializableConfiguration hadoopConf, TaskContextSupplier taskContextSupplier) {\n+    this.hadoopConf = hadoopConf;\n+    this.taskContextSupplier = taskContextSupplier;\n+  }\n+\n+  public SerializableConfiguration getHadoopConf() {\n+    return hadoopConf;\n+  }\n+\n+  public TaskContextSupplier getTaskContextSupplier() {\n+    return taskContextSupplier;\n+  }\n+\n+  public <I, O> List<O> map(List<I> data, Function<I, O> func) {", "originalCommit": "2d1f2124db067f1379fd342b94b4fe1775ace663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NDM1Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492264352", "bodyText": "Also these APIs should take in a parallelism parameter, no?", "author": "vinothchandar", "createdAt": "2020-09-21T18:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQzNDQwNQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492434405", "bodyText": "I think we should leave this abstract and let the engines implement this? even for Java. Its better to have a HoodieJavaEngineContext. From what I can see, this is not overridden in HoodieSparkEngineContext and thus we lose the parallel execution that we currently have with Spark with this change.\n\nas we discussed before, parallelDo model need a function as input parameter, Unfortunately, different engines need different type function, its hard to align them in an abstract parallelDo method. so we agreed to use  java.util.function.Function as the unified input function. in this way, there is no need to distinguish spark and flink, no need to make it abstract and the parallelism is not needed too. its just java, can be implemented directly.", "author": "wangxianghu", "createdAt": "2020-09-22T01:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0OTU0Mw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492449543", "bodyText": "@wangxianghu functionality wise, you are correct. it can be implemented just using Java. but, we do parallelization of different pieces of code e.g deletion of files in parallel using spark for a reason. It significantly speeds these up, for large tables.\nAll I am saying is to implement the HoodieSparkEngineContext#map like below\n public <I, O> List<O> map(List<I> data, Function<I, O> func, int parallelism) {\n    return javaSparkContext.parallelize(data, parallelism).map(func).collect();\n }\n\nsimilarly for the other two methods. I don't see any issues with this. do you?", "author": "vinothchandar", "createdAt": "2020-09-22T02:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ1MzI5OA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492453298", "bodyText": "@wangxianghu functionality wise, you are correct. it can be implemented just using Java. but, we do parallelization of different pieces of code e.g deletion of files in parallel using spark for a reason. It significantly speeds these up, for large tables.\nAll I am saying is to implement the HoodieSparkEngineContext#map like below\n public <I, O> List<O> map(List<I> data, Function<I, O> func, int parallelism) {\n    return javaSparkContext.parallelize(data, parallelism).map(func).collect();\n }\n\nsimilarly for the other two methods. I don't see any issues with this. do you?\n\nI know what you mean.\nwhat I am saying is that the func in HoodieSparkEngineContext#map and HoodieEngineContext#map is not the same type.\nfor HoodieEngineContext#map it is java.util.function.Function,\nfor HoodieSparkEngineContext#map  it is org.apache.spark.api.java.function.Function.\nHoodieSparkEngineContext#map can not override from HoodieEngineContext#map", "author": "wangxianghu", "createdAt": "2020-09-22T03:14:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2MDcxOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492460719", "bodyText": "Is it possible to take a java.util.function.Function and then within HoodieSparkEngineContext#map wrap that into a org.apache.spark.api.java.function.Function ?", "author": "vinothchandar", "createdAt": "2020-09-22T03:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2ODU0MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492468540", "bodyText": "Is it possible to take a java.util.function.Function and then within HoodieSparkEngineContext#map wrap that into a org.apache.spark.api.java.function.Function ?\n\nlet me try", "author": "wangxianghu", "createdAt": "2020-09-22T04:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ3NDEwOA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492474108", "bodyText": "In Spark, there is a functional interface defined like this\npackage org.apache.spark.api.java.function;\n\nimport java.io.Serializable;\n\n/**\n * Base interface for functions whose return types do not create special RDDs. PairFunction and\n * DoubleFunction are handled separately, to allow PairRDDs and DoubleRDDs to be constructed\n * when mapping RDDs of other types.\n */\n@FunctionalInterface\npublic interface Function<T1, R> extends Serializable {\n  R call(T1 v1) throws Exception;\n}", "author": "vinothchandar", "createdAt": "2020-09-22T04:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ3NDQ5NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492474495", "bodyText": "when the use passes in a regular lambda, into rdd.map(), this is what it gets converted into", "author": "vinothchandar", "createdAt": "2020-09-22T04:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ5MzczOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492493739", "bodyText": "when the use passes in a regular lambda, into rdd.map(), this is what it gets converted into\n\nThe serializable issue can be solved by introducing a seriableFuncition to replace java.util.function.Function\npublic interface SerializableFunction<I, O> extends Serializable {\n  O call(I v1) throws Exception;\n}\n\nHoodieEngineContext can be\npublic abstract class HoodieEngineContext {\n  public abstract  <I, O> List<O> map(List<I> data, SerializableFunction<I, O> func, int parallelism) ;\n}\n\nHoodieSparkEngineContext can be\npublic class HoodieSparkEngineContext extends HoodieEngineContext {\n  private static JavaSparkContext jsc;\n\n  // tmp\n  static {\n    SparkConf conf = new SparkConf()\n        .setMaster(\"local[4]\")\n        .set(\"spark.driver.host\",\"localhost\")\n        .setAppName(\"HoodieSparkEngineContext\");\n\n    jsc = new JavaSparkContext(conf);\n  }\n  \n  @Override\n  public <I, O> List<O> map(List<I> data, SerializableFunction<I, O> func, int parallelism) {\n    return jsc.parallelize(data, parallelism).map(func::call).collect();\n  }\n}\n\nthis works :)", "author": "wangxianghu", "createdAt": "2020-09-22T06:14:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg3MjUwNA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492872504", "bodyText": "@wangxianghu This is awesome. Hopefully this can reduce the amount of code you need to write for Flink significantly. TestMarkerFiles seems to pass, so guess the serialization etc is working as expected.\nWe can go ahead with doing more files in this approach and remerge the base/child classes back as much as possible. cc @leesf @yanghua  as well in case they have more things to add.\ncc @bvaradar as well as FYI", "author": "vinothchandar", "createdAt": "2020-09-22T16:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEyMDkyMg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r493120922", "bodyText": "@wangxianghu This is awesome. Hopefully this can reduce the amount of code you need to write for Flink significantly. TestMarkerFiles seems to pass, so guess the serialization etc is working as expected.\nWe can go ahead with doing more files in this approach and remerge the base/child classes back as much as possible. cc @leesf @yanghua as well in case they have more things to add.\ncc @bvaradar as well as FYI\n\nYes, it also reduce tons of code in the refactoring. I'm working on it ,hope to finish it today or tomorrow", "author": "wangxianghu", "createdAt": "2020-09-23T01:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/common/HoodieEngineContext.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/common/HoodieEngineContext.java\nsimilarity index 61%\nrename from hudi-client/hudi-client-common/src/main/java/org/apache/hudi/common/HoodieEngineContext.java\nrename to hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/common/HoodieEngineContext.java\nindex 88ba48733..f8d889640 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/common/HoodieEngineContext.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/common/HoodieEngineContext.java\n\n@@ -16,22 +16,24 @@\n  * limitations under the License.\n  */\n \n-package org.apache.hudi.common;\n+package org.apache.hudi.client.common;\n \n-import org.apache.hudi.client.TaskContextSupplier;\n import org.apache.hudi.common.config.SerializableConfiguration;\n+import org.apache.hudi.client.common.function.SerializableConsumer;\n+import org.apache.hudi.client.common.function.SerializableFunction;\n+import org.apache.hudi.client.common.function.SerializablePairFunction;\n+import org.apache.hudi.common.util.Option;\n \n import java.util.List;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n+import java.util.Map;\n import java.util.stream.Stream;\n \n /**\n  * Base class contains the context information needed by the engine at runtime. It will be extended by different\n  * engine implementation if needed.\n  */\n-public class HoodieEngineContext {\n+public abstract class HoodieEngineContext {\n+\n   /**\n    * A wrapped hadoop configuration which can be serialized.\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2Mjk2NA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492262964", "bodyText": "can we implement versiosn of map, flatMap, forEach here which use javaSparkContext.parallelize() ? It would be good to keep this PR free of any changes in terms of whether we are executing the deletes/lists in parallel or in serial.", "author": "vinothchandar", "createdAt": "2020-09-21T18:28:36Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/common/HoodieSparkEngineContext.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common;\n+\n+import org.apache.hudi.client.SparkTaskContextSupplier;\n+import org.apache.hudi.common.config.SerializableConfiguration;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.SQLContext;\n+\n+/**\n+ * A Spark engine implementation of HoodieEngineContext.\n+ */\n+public class HoodieSparkEngineContext extends HoodieEngineContext {", "originalCommit": "2d1f2124db067f1379fd342b94b4fe1775ace663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5ODQ0Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r493998442", "bodyText": "can we implement versiosn of map, flatMap, forEach here which use javaSparkContext.parallelize() ? It would be good to keep this PR free of any changes in terms of whether we are executing the deletes/lists in parallel or in serial.\n\ndone", "author": "wangxianghu", "createdAt": "2020-09-24T02:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2Mjk2NA=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/common/HoodieSparkEngineContext.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/common/HoodieSparkEngineContext.java\ndeleted file mode 100644\nindex 6c8707ff7..000000000\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/common/HoodieSparkEngineContext.java\n+++ /dev/null\n\n@@ -1,56 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hudi.common;\n-\n-import org.apache.hudi.client.SparkTaskContextSupplier;\n-import org.apache.hudi.common.config.SerializableConfiguration;\n-import org.apache.spark.api.java.JavaSparkContext;\n-import org.apache.spark.sql.SQLContext;\n-\n-/**\n- * A Spark engine implementation of HoodieEngineContext.\n- */\n-public class HoodieSparkEngineContext extends HoodieEngineContext {\n-  private JavaSparkContext javaSparkContext;\n-\n-  private SQLContext sqlContext;\n-\n-  public HoodieSparkEngineContext(JavaSparkContext jsc) {\n-    super(new SerializableConfiguration(jsc.hadoopConfiguration()), new SparkTaskContextSupplier());\n-    this.javaSparkContext = jsc;\n-    this.sqlContext = SQLContext.getOrCreate(jsc.sc());\n-  }\n-\n-  public void setSqlContext(SQLContext sqlContext) {\n-    this.sqlContext = sqlContext;\n-  }\n-\n-  public JavaSparkContext getJavaSparkContext() {\n-    return javaSparkContext;\n-  }\n-\n-  public SQLContext getSqlContext() {\n-    return sqlContext;\n-  }\n-\n-  public static JavaSparkContext getSparkContext(HoodieEngineContext context) {\n-    return ((HoodieSparkEngineContext) context).getJavaSparkContext();\n-  }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NDkxOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492264919", "bodyText": "we are not using parallelism here. This will lead to a perf regression w.r.t master.", "author": "vinothchandar", "createdAt": "2020-09-21T18:32:04Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkMarkerFiles.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.RemoteIterator;\n+import org.apache.hudi.bifunction.wrapper.ThrowingFunction;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.config.SerializableConfiguration;\n+import org.apache.hudi.common.model.IOType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.hudi.bifunction.wrapper.BiFunctionWrapper.throwingConsumerWrapper;\n+import static org.apache.hudi.bifunction.wrapper.BiFunctionWrapper.throwingFlatMapWrapper;\n+\n+public class SparkMarkerFiles extends BaseMarkerFiles {\n+\n+  private static final Logger LOG = LogManager.getLogger(SparkMarkerFiles.class);\n+\n+  public SparkMarkerFiles(HoodieTable table, String instantTime) {\n+    super(table, instantTime);\n+  }\n+\n+  public SparkMarkerFiles(FileSystem fs, String basePath, String markerFolderPath, String instantTime) {\n+    super(fs, basePath, markerFolderPath, instantTime);\n+  }\n+\n+  @Override\n+  public boolean deleteMarkerDir(HoodieEngineContext context, int parallelism) {\n+    try {\n+      if (fs.exists(markerDirPath)) {\n+        FileStatus[] fileStatuses = fs.listStatus(markerDirPath);\n+        List<String> markerDirSubPaths = Arrays.stream(fileStatuses)\n+            .map(fileStatus -> fileStatus.getPath().toString())\n+            .collect(Collectors.toList());\n+\n+        if (markerDirSubPaths.size() > 0) {\n+          SerializableConfiguration conf = new SerializableConfiguration(fs.getConf());\n+          context.foreach(markerDirSubPaths, throwingConsumerWrapper(subPathStr -> {\n+            Path subPath = new Path(subPathStr);\n+            FileSystem fileSystem = subPath.getFileSystem(conf.get());\n+            fileSystem.delete(subPath, true);\n+          }));\n+        }\n+\n+        boolean result = fs.delete(markerDirPath, true);\n+        LOG.info(\"Removing marker directory at \" + markerDirPath);\n+        return result;\n+      }\n+    } catch (IOException ioe) {\n+      throw new HoodieIOException(ioe.getMessage(), ioe);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public Set<String> createdAndMergedDataPaths(HoodieEngineContext context, int parallelism) throws IOException {", "originalCommit": "2d1f2124db067f1379fd342b94b4fe1775ace663", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkMarkerFiles.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkMarkerFiles.java\ndeleted file mode 100644\nindex e6e530e9a..000000000\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkMarkerFiles.java\n+++ /dev/null\n\n@@ -1,124 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hudi.table;\n-\n-import org.apache.hadoop.fs.FileStatus;\n-import org.apache.hadoop.fs.FileSystem;\n-import org.apache.hadoop.fs.LocatedFileStatus;\n-import org.apache.hadoop.fs.Path;\n-import org.apache.hadoop.fs.RemoteIterator;\n-import org.apache.hudi.bifunction.wrapper.ThrowingFunction;\n-import org.apache.hudi.common.HoodieEngineContext;\n-import org.apache.hudi.common.config.SerializableConfiguration;\n-import org.apache.hudi.common.model.IOType;\n-import org.apache.hudi.common.table.HoodieTableMetaClient;\n-import org.apache.hudi.exception.HoodieIOException;\n-import org.apache.log4j.LogManager;\n-import org.apache.log4j.Logger;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static org.apache.hudi.bifunction.wrapper.BiFunctionWrapper.throwingConsumerWrapper;\n-import static org.apache.hudi.bifunction.wrapper.BiFunctionWrapper.throwingFlatMapWrapper;\n-\n-public class SparkMarkerFiles extends BaseMarkerFiles {\n-\n-  private static final Logger LOG = LogManager.getLogger(SparkMarkerFiles.class);\n-\n-  public SparkMarkerFiles(HoodieTable table, String instantTime) {\n-    super(table, instantTime);\n-  }\n-\n-  public SparkMarkerFiles(FileSystem fs, String basePath, String markerFolderPath, String instantTime) {\n-    super(fs, basePath, markerFolderPath, instantTime);\n-  }\n-\n-  @Override\n-  public boolean deleteMarkerDir(HoodieEngineContext context, int parallelism) {\n-    try {\n-      if (fs.exists(markerDirPath)) {\n-        FileStatus[] fileStatuses = fs.listStatus(markerDirPath);\n-        List<String> markerDirSubPaths = Arrays.stream(fileStatuses)\n-            .map(fileStatus -> fileStatus.getPath().toString())\n-            .collect(Collectors.toList());\n-\n-        if (markerDirSubPaths.size() > 0) {\n-          SerializableConfiguration conf = new SerializableConfiguration(fs.getConf());\n-          context.foreach(markerDirSubPaths, throwingConsumerWrapper(subPathStr -> {\n-            Path subPath = new Path(subPathStr);\n-            FileSystem fileSystem = subPath.getFileSystem(conf.get());\n-            fileSystem.delete(subPath, true);\n-          }));\n-        }\n-\n-        boolean result = fs.delete(markerDirPath, true);\n-        LOG.info(\"Removing marker directory at \" + markerDirPath);\n-        return result;\n-      }\n-    } catch (IOException ioe) {\n-      throw new HoodieIOException(ioe.getMessage(), ioe);\n-    }\n-    return false;\n-  }\n-\n-  @Override\n-  public Set<String> createdAndMergedDataPaths(HoodieEngineContext context, int parallelism) throws IOException {\n-    Set<String> dataFiles = new HashSet<>();\n-\n-    FileStatus[] topLevelStatuses = fs.listStatus(markerDirPath);\n-    List<String> subDirectories = new ArrayList<>();\n-    for (FileStatus topLevelStatus: topLevelStatuses) {\n-      if (topLevelStatus.isFile()) {\n-        String pathStr = topLevelStatus.getPath().toString();\n-        if (pathStr.contains(HoodieTableMetaClient.MARKER_EXTN) && !pathStr.endsWith(IOType.APPEND.name())) {\n-          dataFiles.add(translateMarkerToDataPath(pathStr));\n-        }\n-      } else {\n-        subDirectories.add(topLevelStatus.getPath().toString());\n-      }\n-    }\n-\n-    if (subDirectories.size() > 0) {\n-      SerializableConfiguration serializedConf = new SerializableConfiguration(fs.getConf());\n-      List<String> datas = context.flatMap(subDirectories, throwingFlatMapWrapper((ThrowingFunction<String, Stream<String>, Exception>) directory -> {\n-        Path path = new Path(directory);\n-        FileSystem fileSystem = path.getFileSystem(serializedConf.get());\n-        RemoteIterator<LocatedFileStatus> itr = fileSystem.listFiles(path, true);\n-        List<String> result = new ArrayList<>();\n-        while (itr.hasNext()) {\n-          FileStatus status = itr.next();\n-          String pathStr = status.getPath().toString();\n-          if (pathStr.contains(HoodieTableMetaClient.MARKER_EXTN) && !pathStr.endsWith(IOType.APPEND.name())) {\n-            result.add(translateMarkerToDataPath(pathStr));\n-          }\n-        }\n-        return result.stream();\n-      }));\n-      dataFiles.addAll(datas);\n-    }\n-    return dataFiles;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NTE3Nw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492265177", "bodyText": "Given this file is now free of Spark, we dont have the need of breaking these into base and child classes right.", "author": "vinothchandar", "createdAt": "2020-09-21T18:32:33Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkMarkerFiles.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.RemoteIterator;\n+import org.apache.hudi.bifunction.wrapper.ThrowingFunction;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.config.SerializableConfiguration;\n+import org.apache.hudi.common.model.IOType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.hudi.bifunction.wrapper.BiFunctionWrapper.throwingConsumerWrapper;\n+import static org.apache.hudi.bifunction.wrapper.BiFunctionWrapper.throwingFlatMapWrapper;\n+\n+public class SparkMarkerFiles extends BaseMarkerFiles {", "originalCommit": "2d1f2124db067f1379fd342b94b4fe1775ace663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQzNTUzMQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492435531", "bodyText": "Given this file is now free of Spark, we dont have the need of breaking these into base and child classes right.\n\nYes, this is an example to show you the bi function, if you agree with this implementation, I'll rollback them in one class", "author": "wangxianghu", "createdAt": "2020-09-22T01:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NTE3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkMarkerFiles.java b/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkMarkerFiles.java\ndeleted file mode 100644\nindex e6e530e9a..000000000\n--- a/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkMarkerFiles.java\n+++ /dev/null\n\n@@ -1,124 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hudi.table;\n-\n-import org.apache.hadoop.fs.FileStatus;\n-import org.apache.hadoop.fs.FileSystem;\n-import org.apache.hadoop.fs.LocatedFileStatus;\n-import org.apache.hadoop.fs.Path;\n-import org.apache.hadoop.fs.RemoteIterator;\n-import org.apache.hudi.bifunction.wrapper.ThrowingFunction;\n-import org.apache.hudi.common.HoodieEngineContext;\n-import org.apache.hudi.common.config.SerializableConfiguration;\n-import org.apache.hudi.common.model.IOType;\n-import org.apache.hudi.common.table.HoodieTableMetaClient;\n-import org.apache.hudi.exception.HoodieIOException;\n-import org.apache.log4j.LogManager;\n-import org.apache.log4j.Logger;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static org.apache.hudi.bifunction.wrapper.BiFunctionWrapper.throwingConsumerWrapper;\n-import static org.apache.hudi.bifunction.wrapper.BiFunctionWrapper.throwingFlatMapWrapper;\n-\n-public class SparkMarkerFiles extends BaseMarkerFiles {\n-\n-  private static final Logger LOG = LogManager.getLogger(SparkMarkerFiles.class);\n-\n-  public SparkMarkerFiles(HoodieTable table, String instantTime) {\n-    super(table, instantTime);\n-  }\n-\n-  public SparkMarkerFiles(FileSystem fs, String basePath, String markerFolderPath, String instantTime) {\n-    super(fs, basePath, markerFolderPath, instantTime);\n-  }\n-\n-  @Override\n-  public boolean deleteMarkerDir(HoodieEngineContext context, int parallelism) {\n-    try {\n-      if (fs.exists(markerDirPath)) {\n-        FileStatus[] fileStatuses = fs.listStatus(markerDirPath);\n-        List<String> markerDirSubPaths = Arrays.stream(fileStatuses)\n-            .map(fileStatus -> fileStatus.getPath().toString())\n-            .collect(Collectors.toList());\n-\n-        if (markerDirSubPaths.size() > 0) {\n-          SerializableConfiguration conf = new SerializableConfiguration(fs.getConf());\n-          context.foreach(markerDirSubPaths, throwingConsumerWrapper(subPathStr -> {\n-            Path subPath = new Path(subPathStr);\n-            FileSystem fileSystem = subPath.getFileSystem(conf.get());\n-            fileSystem.delete(subPath, true);\n-          }));\n-        }\n-\n-        boolean result = fs.delete(markerDirPath, true);\n-        LOG.info(\"Removing marker directory at \" + markerDirPath);\n-        return result;\n-      }\n-    } catch (IOException ioe) {\n-      throw new HoodieIOException(ioe.getMessage(), ioe);\n-    }\n-    return false;\n-  }\n-\n-  @Override\n-  public Set<String> createdAndMergedDataPaths(HoodieEngineContext context, int parallelism) throws IOException {\n-    Set<String> dataFiles = new HashSet<>();\n-\n-    FileStatus[] topLevelStatuses = fs.listStatus(markerDirPath);\n-    List<String> subDirectories = new ArrayList<>();\n-    for (FileStatus topLevelStatus: topLevelStatuses) {\n-      if (topLevelStatus.isFile()) {\n-        String pathStr = topLevelStatus.getPath().toString();\n-        if (pathStr.contains(HoodieTableMetaClient.MARKER_EXTN) && !pathStr.endsWith(IOType.APPEND.name())) {\n-          dataFiles.add(translateMarkerToDataPath(pathStr));\n-        }\n-      } else {\n-        subDirectories.add(topLevelStatus.getPath().toString());\n-      }\n-    }\n-\n-    if (subDirectories.size() > 0) {\n-      SerializableConfiguration serializedConf = new SerializableConfiguration(fs.getConf());\n-      List<String> datas = context.flatMap(subDirectories, throwingFlatMapWrapper((ThrowingFunction<String, Stream<String>, Exception>) directory -> {\n-        Path path = new Path(directory);\n-        FileSystem fileSystem = path.getFileSystem(serializedConf.get());\n-        RemoteIterator<LocatedFileStatus> itr = fileSystem.listFiles(path, true);\n-        List<String> result = new ArrayList<>();\n-        while (itr.hasNext()) {\n-          FileStatus status = itr.next();\n-          String pathStr = status.getPath().toString();\n-          if (pathStr.contains(HoodieTableMetaClient.MARKER_EXTN) && !pathStr.endsWith(IOType.APPEND.name())) {\n-            result.add(translateMarkerToDataPath(pathStr));\n-          }\n-        }\n-        return result.stream();\n-      }));\n-      dataFiles.addAll(datas);\n-    }\n-    return dataFiles;\n-  }\n-}\n"}}, {"oid": "3a9b9a71a07c68dae940e5260ad1aab065652430", "url": "https://github.com/apache/hudi/commit/3a9b9a71a07c68dae940e5260ad1aab065652430", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-23T12:12:02Z", "type": "forcePushed"}, {"oid": "0609a9bafebb6fc4bb1b45bd26ab09bdfeb94e69", "url": "https://github.com/apache/hudi/commit/0609a9bafebb6fc4bb1b45bd26ab09bdfeb94e69", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-23T12:19:59Z", "type": "forcePushed"}, {"oid": "df2ffa1c2455538316551e9ecc71567d748ea3be", "url": "https://github.com/apache/hudi/commit/df2ffa1c2455538316551e9ecc71567d748ea3be", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-23T12:55:13Z", "type": "forcePushed"}, {"oid": "20f3a866ebb92c7db34d4c8d15fbebee4e78016c", "url": "https://github.com/apache/hudi/commit/20f3a866ebb92c7db34d4c8d15fbebee4e78016c", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-23T13:13:58Z", "type": "forcePushed"}, {"oid": "cab19a136418580dd69fc794787b63b07b372d08", "url": "https://github.com/apache/hudi/commit/cab19a136418580dd69fc794787b63b07b372d08", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-23T13:55:46Z", "type": "forcePushed"}, {"oid": "e675a4f9fc20fb9fc6aa017d66fab3da372580c5", "url": "https://github.com/apache/hudi/commit/e675a4f9fc20fb9fc6aa017d66fab3da372580c5", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-24T01:36:37Z", "type": "forcePushed"}, {"oid": "f05a20cf78dcc5c06558c8e8827e62acede4c4bf", "url": "https://github.com/apache/hudi/commit/f05a20cf78dcc5c06558c8e8827e62acede4c4bf", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-24T01:48:25Z", "type": "forcePushed"}, {"oid": "131aa883ec95f2cef0f9d4493ac4549770f59e8b", "url": "https://github.com/apache/hudi/commit/131aa883ec95f2cef0f9d4493ac4549770f59e8b", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-24T01:54:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5NjY0Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r493996642", "bodyText": "Here, I used org.apache.hudi.common.util.SizeEstimator#sizeEstimate to replace org.apache.spark.util.SizeEstimator#estimate is it ok?  @vinothchandar", "author": "wangxianghu", "createdAt": "2020-09-24T02:06:04Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieAppendHandle.java", "diffHunk": "@@ -134,7 +138,7 @@ private void init(HoodieRecord record) {\n       writeStatus.setPartitionPath(partitionPath);\n       writeStatus.getStat().setPartitionPath(partitionPath);\n       writeStatus.getStat().setFileId(fileId);\n-      averageRecordSize = SizeEstimator.estimate(record);\n+      averageRecordSize = sizeEstimator.sizeEstimate(record);\n       try {", "originalCommit": "131aa883ec95f2cef0f9d4493ac4549770f59e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA3Mzg3NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494073875", "bodyText": "Should be okay.", "author": "vinothchandar", "createdAt": "2020-09-24T06:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5NjY0Mg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "6ebd0e664ee5a159db7b2fd60ccce3978f26c9ee", "url": "https://github.com/apache/hudi/commit/6ebd0e664ee5a159db7b2fd60ccce3978f26c9ee", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-24T02:09:34Z", "type": "forcePushed"}, {"oid": "4199bcce2b1568383b685b2c188732e2adbc22b5", "url": "https://github.com/apache/hudi/commit/4199bcce2b1568383b685b2c188732e2adbc22b5", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-24T05:34:54Z", "type": "forcePushed"}, {"oid": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "url": "https://github.com/apache/hudi/commit/c24a47c9eae815337d7b7ad42695958a3afa9e3c", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-24T06:20:31Z", "type": "forcePushed"}, {"oid": "9737063a0845f5c0525f054095dab463bcdc423f", "url": "https://github.com/apache/hudi/commit/9737063a0845f5c0525f054095dab463bcdc423f", "message": "Code Review Comments\n\n* Renaming HoodieSparkAsyncCompactService to SparkAsyncCompactService\n* Bug in SparkStreamingAsyncCompactService of not calling the super constructor with daemon mode.\n* Rename methods in HoodieEngineContext to setJobStatus() and setProperty()\n* Rename common packages to under client.common package\n* Bug in HoodieMergeHandle and compactor not getting the right merge memory", "committedDate": "2020-09-28T01:08:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0ODM5Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494648392", "bodyText": "can we replace more of the code to direclty just use HoodieTable instead. Need to examine cases that need an explicit HoodieSparkTable", "author": "vinothchandar", "createdAt": "2020-09-24T22:37:33Z", "path": "hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestArchivedCommitsCommand.java", "diffHunk": "@@ -92,8 +93,9 @@ public void init() throws IOException {\n     metaClient.getActiveTimeline().reload().getAllCommitsTimeline().filterCompletedInstants();\n \n     // archive\n-    HoodieTimelineArchiveLog archiveLog = new HoodieTimelineArchiveLog(cfg, hadoopConf);\n-    archiveLog.archiveIfRequired(jsc);\n+    HoodieSparkTable table = HoodieSparkTable.create(cfg, context, metaClient);", "originalCommit": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY1MDcwNQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r495650705", "bodyText": "can we replace more of the code to direclty just use HoodieTable instead. Need to examine cases that need an explicit HoodieSparkTable\n\nyes, make sense", "author": "wangxianghu", "createdAt": "2020-09-28T01:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0ODM5Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0ODg1Nw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494648857", "bodyText": "just like this, we should try to  use the abstract class as much as we can", "author": "vinothchandar", "createdAt": "2020-09-24T22:38:54Z", "path": "hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestRollbacksCommand.java", "diffHunk": "@@ -88,7 +88,7 @@ public void init() throws IOException {\n     HoodieWriteConfig config = HoodieWriteConfig.newBuilder().withPath(tablePath)\n         .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(HoodieIndex.IndexType.INMEMORY).build()).build();\n \n-    try (HoodieWriteClient client = getHoodieWriteClient(config)) {\n+    try (AbstractHoodieWriteClient client = getHoodieWriteClient(config)) {", "originalCommit": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestRollbacksCommand.java b/hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestRollbacksCommand.java\nindex 65bc00706..8cf2be958 100644\n--- a/hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestRollbacksCommand.java\n+++ b/hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestRollbacksCommand.java\n\n@@ -59,39 +63,37 @@ import static org.junit.jupiter.api.Assertions.assertTrue;\n public class TestRollbacksCommand extends AbstractShellIntegrationTest {\n \n   @BeforeEach\n-  public void init() throws IOException {\n+  public void init() throws Exception {\n     String tableName = \"test_table\";\n-    String tablePath = basePath + File.separator + tableName;\n+    String tablePath = Paths.get(basePath, tableName).toString();\n     new TableCommand().createTable(\n         tablePath, tableName, HoodieTableType.MERGE_ON_READ.name(),\n         \"\", TimelineLayoutVersion.VERSION_1, \"org.apache.hudi.common.model.HoodieAvroPayload\");\n-\n+    metaClient = HoodieTableMetaClient.reload(HoodieCLI.getTableMetaClient());\n     //Create some commits files and parquet files\n-    String commitTime1 = \"100\";\n-    String commitTime2 = \"101\";\n-    String commitTime3 = \"102\";\n-    HoodieTestDataGenerator.writePartitionMetadata(fs, HoodieTestDataGenerator.DEFAULT_PARTITION_PATHS, tablePath);\n-\n-    // two commit files\n-    HoodieTestUtils.createCommitFiles(tablePath, commitTime1, commitTime2);\n-    // one .inflight commit file\n-    HoodieTestUtils.createInflightCommitFiles(tablePath, commitTime3);\n-\n-    // generate commit files for commits\n-    for (String commitTime : Arrays.asList(commitTime1, commitTime2, commitTime3)) {\n-      HoodieTestUtils.createDataFile(tablePath, HoodieTestDataGenerator.DEFAULT_FIRST_PARTITION_PATH, commitTime, \"file-1\");\n-      HoodieTestUtils.createDataFile(tablePath, HoodieTestDataGenerator.DEFAULT_SECOND_PARTITION_PATH, commitTime, \"file-2\");\n-      HoodieTestUtils.createDataFile(tablePath, HoodieTestDataGenerator.DEFAULT_THIRD_PARTITION_PATH, commitTime, \"file-3\");\n-    }\n-\n+    Map<String, String> partitionAndFileId = new HashMap<String, String>() {\n+      {\n+        put(DEFAULT_FIRST_PARTITION_PATH, \"file-1\");\n+        put(DEFAULT_SECOND_PARTITION_PATH, \"file-2\");\n+        put(DEFAULT_THIRD_PARTITION_PATH, \"file-3\");\n+      }\n+    };\n+    HoodieTestTable.of(metaClient)\n+        .withPartitionMetaFiles(DEFAULT_PARTITION_PATHS)\n+        .addCommit(\"100\")\n+        .withBaseFilesInPartitions(partitionAndFileId)\n+        .addCommit(\"101\")\n+        .withBaseFilesInPartitions(partitionAndFileId)\n+        .addInflightCommit(\"102\")\n+        .withBaseFilesInPartitions(partitionAndFileId);\n     // generate two rollback\n     HoodieWriteConfig config = HoodieWriteConfig.newBuilder().withPath(tablePath)\n         .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(HoodieIndex.IndexType.INMEMORY).build()).build();\n \n     try (AbstractHoodieWriteClient client = getHoodieWriteClient(config)) {\n       // Rollback inflight commit3 and commit2\n-      client.rollback(commitTime3);\n-      client.rollback(commitTime2);\n+      client.rollback(\"102\");\n+      client.rollback(\"101\");\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NjE5Ng==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494746196", "bodyText": "this was actually same. fixing it", "author": "vinothchandar", "createdAt": "2020-09-25T04:52:38Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -716,32 +669,95 @@ private void rollbackPendingCommits() {\n    * @param compactionInstantTime Compaction Instant Time\n    * @return RDD of Write Status\n    */\n-  private JavaRDD<WriteStatus> compact(String compactionInstantTime, boolean shouldComplete) {\n-    HoodieTable<T> table = HoodieTable.create(config, hadoopConf);\n-    HoodieTimeline pendingCompactionTimeline = table.getActiveTimeline().filterPendingCompactionTimeline();\n-    HoodieInstant inflightInstant = HoodieTimeline.getCompactionInflightInstant(compactionInstantTime);\n-    if (pendingCompactionTimeline.containsInstant(inflightInstant)) {\n-      rollbackInflightCompaction(inflightInstant, table);\n-      table.getMetaClient().reloadActiveTimeline();\n-    }\n-    compactionTimer = metrics.getCompactionCtx();\n-    HoodieWriteMetadata compactionMetadata = table.compact(jsc, compactionInstantTime);\n-    JavaRDD<WriteStatus> statuses = compactionMetadata.getWriteStatuses();\n-    if (shouldComplete && compactionMetadata.getCommitMetadata().isPresent()) {\n-      completeCompaction(compactionMetadata.getCommitMetadata().get(), statuses, table, compactionInstantTime);\n-    }\n-    return statuses;\n-  }\n+  protected abstract O compact(String compactionInstantTime, boolean shouldComplete);\n \n   /**\n    * Performs a compaction operation on a table, serially before or after an insert/upsert action.\n    */\n-  private Option<String> inlineCompact(Option<Map<String, String>> extraMetadata) {\n+  protected Option<String> inlineCompact(Option<Map<String, String>> extraMetadata) {\n     Option<String> compactionInstantTimeOpt = scheduleCompaction(extraMetadata);\n     compactionInstantTimeOpt.ifPresent(compactionInstantTime -> {\n       // inline compaction should auto commit as the user is never given control\n       compact(compactionInstantTime, true);\n     });\n     return compactionInstantTimeOpt;\n   }\n+\n+  /**\n+   * Finalize Write operation.\n+   *\n+   * @param table HoodieTable\n+   * @param instantTime Instant Time\n+   * @param stats Hoodie Write Stat\n+   */\n+  protected void finalizeWrite(HoodieTable<T, I, K, O, P> table, String instantTime, List<HoodieWriteStat> stats) {\n+    try {\n+      final Timer.Context finalizeCtx = metrics.getFinalizeCtx();\n+      table.finalizeWrite(context, instantTime, stats);\n+      if (finalizeCtx != null) {\n+        Option<Long> durationInMs = Option.of(metrics.getDurationInMs(finalizeCtx.stop()));\n+        durationInMs.ifPresent(duration -> {\n+          LOG.info(\"Finalize write elapsed time (milliseconds): \" + duration);\n+          metrics.updateFinalizeWriteMetrics(duration, stats.size());\n+        });\n+      }\n+    } catch (HoodieIOException ioe) {\n+      throw new HoodieCommitException(\"Failed to complete commit \" + instantTime + \" due to finalize errors.\", ioe);\n+    }\n+  }\n+\n+  public HoodieMetrics getMetrics() {\n+    return metrics;\n+  }\n+\n+  public HoodieIndex<T, I, K, O, P> getIndex() {\n+    return index;\n+  }\n+\n+  /**\n+   * Get HoodieTable and init {@link Timer.Context}.\n+   *\n+   * @param operationType write operation type\n+   * @param instantTime current inflight instant time\n+   * @return HoodieTable\n+   */\n+  protected abstract HoodieTable<T, I, K, O, P> getTableAndInitCtx(WriteOperationType operationType, String instantTime);\n+\n+  /**\n+   * Sets write schema from last instant since deletes may not have schema set in the config.\n+   */\n+  protected void setWriteSchemaForDeletes(HoodieTableMetaClient metaClient) {\n+    try {\n+      HoodieActiveTimeline activeTimeline = metaClient.getActiveTimeline();\n+      Option<HoodieInstant> lastInstant =\n+          activeTimeline.filterCompletedInstants().filter(s -> s.getAction().equals(metaClient.getCommitActionType()))\n+              .lastInstant();\n+      if (lastInstant.isPresent()) {\n+        HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(\n+            activeTimeline.getInstantDetails(lastInstant.get()).get(), HoodieCommitMetadata.class);\n+        if (commitMetadata.getExtraMetadata().containsKey(HoodieCommitMetadata.SCHEMA_KEY)) {\n+          config.setSchema(commitMetadata.getExtraMetadata().get(HoodieCommitMetadata.SCHEMA_KEY));\n+        } else {\n+          throw new HoodieIOException(\"Latest commit does not have any schema in commit metadata\");\n+        }\n+      } else {\n+        throw new HoodieIOException(\"Deletes issued without any prior commits\");\n+      }\n+    } catch (IOException e) {\n+      throw new HoodieIOException(\"IOException thrown while reading last commit metadata\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    // Stop timeline-server if running\n+    super.close();\n+    // Calling this here releases any resources used by your index, so make sure to finish any related operations\n+    // before this point\n+    this.index.close();\n+\n+    // release AsyncCleanerService\n+    AsyncCleanerService.forceShutdown(asyncCleanerService);\n+    asyncCleanerService = null;", "originalCommit": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\nindex 61386fdfc..0f35e270e 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n\n@@ -690,7 +733,7 @@ public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I\n    * @param instantTime Instant Time\n    * @param stats Hoodie Write Stat\n    */\n-  protected void finalizeWrite(HoodieTable<T, I, K, O, P> table, String instantTime, List<HoodieWriteStat> stats) {\n+  protected void finalizeWrite(HoodieTable<T, I, K, O> table, String instantTime, List<HoodieWriteStat> stats) {\n     try {\n       final Timer.Context finalizeCtx = metrics.getFinalizeCtx();\n       table.finalizeWrite(context, instantTime, stats);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NzUxOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494747519", "bodyText": "this needs to be removed. but not the issue for this PR to be bothered about may be", "author": "vinothchandar", "createdAt": "2020-09-25T04:58:30Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -716,32 +669,95 @@ private void rollbackPendingCommits() {\n    * @param compactionInstantTime Compaction Instant Time\n    * @return RDD of Write Status\n    */\n-  private JavaRDD<WriteStatus> compact(String compactionInstantTime, boolean shouldComplete) {\n-    HoodieTable<T> table = HoodieTable.create(config, hadoopConf);\n-    HoodieTimeline pendingCompactionTimeline = table.getActiveTimeline().filterPendingCompactionTimeline();\n-    HoodieInstant inflightInstant = HoodieTimeline.getCompactionInflightInstant(compactionInstantTime);\n-    if (pendingCompactionTimeline.containsInstant(inflightInstant)) {\n-      rollbackInflightCompaction(inflightInstant, table);\n-      table.getMetaClient().reloadActiveTimeline();\n-    }\n-    compactionTimer = metrics.getCompactionCtx();\n-    HoodieWriteMetadata compactionMetadata = table.compact(jsc, compactionInstantTime);\n-    JavaRDD<WriteStatus> statuses = compactionMetadata.getWriteStatuses();\n-    if (shouldComplete && compactionMetadata.getCommitMetadata().isPresent()) {\n-      completeCompaction(compactionMetadata.getCommitMetadata().get(), statuses, table, compactionInstantTime);\n-    }\n-    return statuses;\n-  }\n+  protected abstract O compact(String compactionInstantTime, boolean shouldComplete);\n \n   /**\n    * Performs a compaction operation on a table, serially before or after an insert/upsert action.\n    */\n-  private Option<String> inlineCompact(Option<Map<String, String>> extraMetadata) {\n+  protected Option<String> inlineCompact(Option<Map<String, String>> extraMetadata) {\n     Option<String> compactionInstantTimeOpt = scheduleCompaction(extraMetadata);\n     compactionInstantTimeOpt.ifPresent(compactionInstantTime -> {\n       // inline compaction should auto commit as the user is never given control\n       compact(compactionInstantTime, true);\n     });\n     return compactionInstantTimeOpt;\n   }\n+\n+  /**\n+   * Finalize Write operation.\n+   *\n+   * @param table HoodieTable\n+   * @param instantTime Instant Time\n+   * @param stats Hoodie Write Stat\n+   */\n+  protected void finalizeWrite(HoodieTable<T, I, K, O, P> table, String instantTime, List<HoodieWriteStat> stats) {\n+    try {\n+      final Timer.Context finalizeCtx = metrics.getFinalizeCtx();\n+      table.finalizeWrite(context, instantTime, stats);\n+      if (finalizeCtx != null) {\n+        Option<Long> durationInMs = Option.of(metrics.getDurationInMs(finalizeCtx.stop()));\n+        durationInMs.ifPresent(duration -> {\n+          LOG.info(\"Finalize write elapsed time (milliseconds): \" + duration);\n+          metrics.updateFinalizeWriteMetrics(duration, stats.size());\n+        });\n+      }\n+    } catch (HoodieIOException ioe) {\n+      throw new HoodieCommitException(\"Failed to complete commit \" + instantTime + \" due to finalize errors.\", ioe);\n+    }\n+  }\n+\n+  public HoodieMetrics getMetrics() {\n+    return metrics;\n+  }\n+\n+  public HoodieIndex<T, I, K, O, P> getIndex() {", "originalCommit": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\nindex 61386fdfc..0f35e270e 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n\n@@ -690,7 +733,7 @@ public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I\n    * @param instantTime Instant Time\n    * @param stats Hoodie Write Stat\n    */\n-  protected void finalizeWrite(HoodieTable<T, I, K, O, P> table, String instantTime, List<HoodieWriteStat> stats) {\n+  protected void finalizeWrite(HoodieTable<T, I, K, O> table, String instantTime, List<HoodieWriteStat> stats) {\n     try {\n       final Timer.Context finalizeCtx = metrics.getFinalizeCtx();\n       table.finalizeWrite(context, instantTime, stats);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIzNTI3MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r495235271", "bodyText": "this cannot be configurable. yarn/k8s will decide the actual driver host. changing it to how it was before", "author": "vinothchandar", "createdAt": "2020-09-25T21:14:01Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "diffHunk": "@@ -100,6 +99,7 @@\n \n   public static final String EMBEDDED_TIMELINE_SERVER_ENABLED = \"hoodie.embed.timeline.server\";\n   public static final String DEFAULT_EMBEDDED_TIMELINE_SERVER_ENABLED = \"true\";\n+  public static final String EMBEDDED_TIMELINE_SERVER_HOST = \"hoodie.embed.timeline.server.host\";", "originalCommit": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java\nindex c4d34be6d..60ca3c2dd 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java\n\n@@ -99,7 +99,6 @@ public class HoodieWriteConfig extends DefaultHoodieConfig {\n \n   public static final String EMBEDDED_TIMELINE_SERVER_ENABLED = \"hoodie.embed.timeline.server\";\n   public static final String DEFAULT_EMBEDDED_TIMELINE_SERVER_ENABLED = \"true\";\n-  public static final String EMBEDDED_TIMELINE_SERVER_HOST = \"hoodie.embed.timeline.server.host\";\n \n   public static final String FAIL_ON_TIMELINE_ARCHIVING_ENABLED_PROP = \"hoodie.fail.on.timeline.archiving\";\n   public static final String DEFAULT_FAIL_ON_TIMELINE_ARCHIVING_ENABLED = \"true\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5OTk0MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r495599940", "bodyText": "this is a problem. it changes behavior and needs to be reworked.", "author": "vinothchandar", "createdAt": "2020-09-27T18:18:11Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieMergeHandle.java", "diffHunk": "@@ -149,7 +148,7 @@ private void init(String fileId, String partitionPath, HoodieBaseFile baseFileTo\n   private void init(String fileId, Iterator<HoodieRecord<T>> newRecordsItr) {\n     try {\n       // Load the new records in a map\n-      long memoryForMerge = SparkConfigUtils.getMaxMemoryPerPartitionMerge(config.getProps());\n+      long memoryForMerge = config.getMaxMemoryPerPartitionMerge();", "originalCommit": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "chunk": "diff --git a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieMergeHandle.java b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieMergeHandle.java\nindex ec308d2be..77fef5c1d 100644\n--- a/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieMergeHandle.java\n+++ b/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieMergeHandle.java\n\n@@ -148,7 +149,7 @@ public class HoodieMergeHandle<T extends HoodieRecordPayload, I, K, O, P> extend\n   private void init(String fileId, Iterator<HoodieRecord<T>> newRecordsItr) {\n     try {\n       // Load the new records in a map\n-      long memoryForMerge = config.getMaxMemoryPerPartitionMerge();\n+      long memoryForMerge = IOUtils.getMaxMemoryPerPartitionMerge(taskContextSupplier, config.getProps());\n       LOG.info(\"MaxMemoryPerPartitionMerge => \" + memoryForMerge);\n       this.keyToNewRecords = new ExternalSpillableMap<>(memoryForMerge, config.getSpillableMapBasePath(),\n           new DefaultSizeEstimator(), new HoodieRecordSizeEstimator(writerSchema));\n"}}, {"oid": "c205bce39d13665e7393b743257d49a78d5f5f20", "url": "https://github.com/apache/hudi/commit/c205bce39d13665e7393b743257d49a78d5f5f20", "message": "Code Review Comments\n\n* Renaming HoodieSparkAsyncCompactService to SparkAsyncCompactService\n* Bug in SparkStreamingAsyncCompactService of not calling the super constructor with daemon mode.\n* Rename methods in HoodieEngineContext to setJobStatus() and setProperty()\n* Rename common packages to under client.common package\n* Bug in HoodieMergeHandle and compactor not getting the right merge memory", "committedDate": "2020-09-28T16:37:54Z", "type": "forcePushed"}, {"oid": "c158dee14355ec3cb24d1b16cb2fd7a84508fd44", "url": "https://github.com/apache/hudi/commit/c158dee14355ec3cb24d1b16cb2fd7a84508fd44", "message": "Code Review Comments\n\n* Renaming HoodieSparkAsyncCompactService to SparkAsyncCompactService\n* Bug in SparkStreamingAsyncCompactService of not calling the super constructor with daemon mode.\n* Rename methods in HoodieEngineContext to setJobStatus() and setProperty()\n* Rename common packages to under client.common package\n* Bug in HoodieMergeHandle and compactor not getting the right merge memory", "committedDate": "2020-09-28T20:56:04Z", "type": "forcePushed"}, {"oid": "bcf84a65661c9bdb517e4d982f10bc4ca14ad623", "url": "https://github.com/apache/hudi/commit/bcf84a65661c9bdb517e4d982f10bc4ca14ad623", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client", "committedDate": "2020-09-30T00:50:45Z", "type": "forcePushed"}, {"oid": "b67ee14568ceb0bc0519594de42a20f6972ce2c0", "url": "https://github.com/apache/hudi/commit/b67ee14568ceb0bc0519594de42a20f6972ce2c0", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-30T23:53:10Z", "type": "commit"}, {"oid": "cd5d75ec4eb8594f37b37f5cb78cdb0d0d138713", "url": "https://github.com/apache/hudi/commit/cd5d75ec4eb8594f37b37f5cb78cdb0d0d138713", "message": "Code Review Comments\n\n* Renaming HoodieSparkAsyncCompactService to SparkAsyncCompactService\n* Bug in SparkStreamingAsyncCompactService of not calling the super constructor with daemon mode.\n* Rename methods in HoodieEngineContext to setJobStatus() and setProperty()\n* Rename common packages to under client.common package\n* Bug in HoodieMergeHandle and compactor not getting the right merge memory", "committedDate": "2020-10-01T04:48:20Z", "type": "commit"}, {"oid": "6c66d499ba941cbf0ed4e9f04a9256561fa55e9b", "url": "https://github.com/apache/hudi/commit/6c66d499ba941cbf0ed4e9f04a9256561fa55e9b", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client", "committedDate": "2020-10-01T04:48:20Z", "type": "forcePushed"}, {"oid": "8b0670588e9d2d4454f5be0cf2dbbb28884e0cec", "url": "https://github.com/apache/hudi/commit/8b0670588e9d2d4454f5be0cf2dbbb28884e0cec", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client", "committedDate": "2020-10-01T05:24:56Z", "type": "forcePushed"}, {"oid": "8512cac40d6990e6ce3276bee7c63907c6d5d96c", "url": "https://github.com/apache/hudi/commit/8512cac40d6990e6ce3276bee7c63907c6d5d96c", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client", "committedDate": "2020-10-01T05:35:28Z", "type": "forcePushed"}, {"oid": "56690a5338b7cb0e10565544cbbd98daedd163c2", "url": "https://github.com/apache/hudi/commit/56690a5338b7cb0e10565544cbbd98daedd163c2", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client", "committedDate": "2020-10-01T06:14:41Z", "type": "forcePushed"}, {"oid": "c7b1cb1860496efcf90b2855e6b40600cb454efb", "url": "https://github.com/apache/hudi/commit/c7b1cb1860496efcf90b2855e6b40600cb454efb", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client\n* Removing usages of HoodieIndex#fetchRecordLocation everywhere", "committedDate": "2020-10-01T06:41:31Z", "type": "forcePushed"}, {"oid": "6a79819a84ffb129574b218e4dd4c435f4e94b58", "url": "https://github.com/apache/hudi/commit/6a79819a84ffb129574b218e4dd4c435f4e94b58", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client\n* Removing usages of HoodieIndex#fetchRecordLocation everywhere", "committedDate": "2020-10-01T06:52:52Z", "type": "commit"}, {"oid": "6a79819a84ffb129574b218e4dd4c435f4e94b58", "url": "https://github.com/apache/hudi/commit/6a79819a84ffb129574b218e4dd4c435f4e94b58", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client\n* Removing usages of HoodieIndex#fetchRecordLocation everywhere", "committedDate": "2020-10-01T06:52:52Z", "type": "forcePushed"}, {"oid": "7e33f73f70a65be635357e6fddc3053ac5a00694", "url": "https://github.com/apache/hudi/commit/7e33f73f70a65be635357e6fddc3053ac5a00694", "message": "Dropping HoodieIndex#fetchRecordLocation API\n\n* Not used by any other major API\n* Removing `P` from the templatized list of parameters", "committedDate": "2020-10-01T08:34:51Z", "type": "commit"}, {"oid": "d99096df897e64ca200df2cd9ca269c327faebf1", "url": "https://github.com/apache/hudi/commit/d99096df897e64ca200df2cd9ca269c327faebf1", "message": "Renaming some Abstract* classes as Hoodie* to improve readability", "committedDate": "2020-10-01T14:31:47Z", "type": "forcePushed"}]}