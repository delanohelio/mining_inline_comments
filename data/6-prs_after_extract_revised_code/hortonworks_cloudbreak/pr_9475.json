{"pr_number": 9475, "pr_title": "CB 9241 Create load balancer for data lake HA", "pr_createdAt": "2020-11-18T23:14:21Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9475", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3NzQyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r526777428", "bodyText": "Nit: remove unnecessary space after metadata().", "author": "lajosrodek", "createdAt": "2020-11-19T11:07:56Z", "path": "cloud-reactor/src/main/java/com/sequenceiq/cloudbreak/cloud/handler/CollectLoadBalancerMetadataHandler.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.sequenceiq.cloudbreak.cloud.handler;\n+\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cloud.CloudConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.event.loadbalancer.CollectLoadBalancerMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.loadbalancer.CollectLoadBalancerMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.init.CloudPlatformConnectors;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudLoadBalancerMetadata;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class CollectLoadBalancerMetadataHandler implements CloudPlatformEventHandler<CollectLoadBalancerMetadataRequest> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CollectLoadBalancerMetadataHandler.class);\n+\n+    @Inject\n+    private CloudPlatformConnectors cloudPlatformConnectors;\n+\n+    @Inject\n+    private EventBus eventBus;\n+\n+    @Override\n+    public Class<CollectLoadBalancerMetadataRequest> type() {\n+        return CollectLoadBalancerMetadataRequest.class;\n+    }\n+\n+    @Override\n+    public void accept(Event<CollectLoadBalancerMetadataRequest> collectLBMetadataRequestEvent) {\n+        LOGGER.debug(\"Received event: {}\", collectLBMetadataRequestEvent);\n+        CollectLoadBalancerMetadataRequest request = collectLBMetadataRequestEvent.getData();\n+        try {\n+            CloudConnector<Object> connector = cloudPlatformConnectors.get(request.getCloudContext().getPlatformVariant());\n+            AuthenticatedContext ac = connector.authentication().authenticate(request.getCloudContext(), request.getCloudCredential());\n+\n+            List<CloudLoadBalancerMetadata> loadBalancerStatuses = connector.metadata() .collectLoadBalancer(ac, request.getGatewayGroupNames());", "originalCommit": "de55a4bb1b4971dd8f935faf64cd1e01685b9bb1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/cloud-reactor/src/main/java/com/sequenceiq/cloudbreak/cloud/handler/CollectLoadBalancerMetadataHandler.java b/cloud-reactor/src/main/java/com/sequenceiq/cloudbreak/cloud/handler/CollectLoadBalancerMetadataHandler.java\nindex d506644bc4..f7d3ca86be 100644\n--- a/cloud-reactor/src/main/java/com/sequenceiq/cloudbreak/cloud/handler/CollectLoadBalancerMetadataHandler.java\n+++ b/cloud-reactor/src/main/java/com/sequenceiq/cloudbreak/cloud/handler/CollectLoadBalancerMetadataHandler.java\n\n@@ -42,7 +42,7 @@ public class CollectLoadBalancerMetadataHandler implements CloudPlatformEventHan\n             CloudConnector<Object> connector = cloudPlatformConnectors.get(request.getCloudContext().getPlatformVariant());\n             AuthenticatedContext ac = connector.authentication().authenticate(request.getCloudContext(), request.getCloudCredential());\n \n-            List<CloudLoadBalancerMetadata> loadBalancerStatuses = connector.metadata() .collectLoadBalancer(ac, request.getGatewayGroupNames());\n+            List<CloudLoadBalancerMetadata> loadBalancerStatuses = connector.metadata().collectLoadBalancer(ac, request.getTypesPresentInStack());\n             CollectLoadBalancerMetadataResult collectLBMetadataResult =\n                 new CollectLoadBalancerMetadataResult(request.getResourceId(), loadBalancerStatuses);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MjQ3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527162479", "bodyText": "Could do a instanceGroups.stream().filter(group -> InstanceGroupType.Gateway.equals(group.getInstanceGroupType).findAny().orElse(null);", "author": "frozenwizard", "createdAt": "2020-11-19T20:01:27Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java", "diffHunk": "@@ -574,6 +579,15 @@ public InstanceMetaData getPrimaryGatewayInstance() {\n         return metaData.orElse(null);\n     }\n \n+    public InstanceGroup getGatewayGroup() {\n+        for (InstanceGroup instanceGroup : instanceGroups) {", "originalCommit": "5e43c56ce52d7d662196ebae07c6db60206b53a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyMjYyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527222622", "bodyText": "This method was from a pretty early implementation, and I realized it's no longer being called, so it'll be removed in the most recent commit.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T21:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MjQ3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "chunk": "diff --git a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java\nindex aad82f6f53..2cd7948280 100644\n--- a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java\n+++ b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java\n\n@@ -579,15 +579,6 @@ public class Stack implements ProvisionEntity, WorkspaceAwareResource {\n         return metaData.orElse(null);\n     }\n \n-    public InstanceGroup getGatewayGroup() {\n-        for (InstanceGroup instanceGroup : instanceGroups) {\n-            if (InstanceGroupType.GATEWAY.equals(instanceGroup.getInstanceGroupType())) {\n-                return instanceGroup;\n-            }\n-        }\n-        return null;\n-    }\n-\n     public Network getNetwork() {\n         return network;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MzYwNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527163607", "bodyText": "probably want to do a fetch type of lazy", "author": "frozenwizard", "createdAt": "2020-11-19T20:03:32Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java", "diffHunk": "@@ -70,6 +73,9 @@\n \n     private int initialNodeCount;\n \n+    @ManyToMany(mappedBy = \"instanceGroups\", fetch = FetchType.EAGER)", "originalCommit": "5e43c56ce52d7d662196ebae07c6db60206b53a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzMjg2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527232865", "bodyText": "T'was I who was lazy. I'll change this and add a manual fetch instead.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MzYwNw=="}], "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java\nindex 3df2c79f59..743579fbcf 100644\n--- a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java\n+++ b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java\n\n@@ -73,8 +73,8 @@ public class InstanceGroup implements ProvisionEntity, Comparable<InstanceGroup>\n \n     private int initialNodeCount;\n \n-    @ManyToMany(mappedBy = \"instanceGroups\", fetch = FetchType.EAGER)\n-    private Set<TargetGroup> targetGroups;\n+    @ManyToMany(mappedBy = \"instanceGroups\", fetch = FetchType.LAZY)\n+    private Set<TargetGroup> targetGroups = new HashSet<>();\n \n     public String getGroupName() {\n         return groupName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NDYwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527164605", "bodyText": "could we just initialize targetgroups = new HashSet<>() at the top of the file?", "author": "frozenwizard", "createdAt": "2020-11-19T20:05:18Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java", "diffHunk": "@@ -208,6 +214,21 @@ public void setCloudIdentityType(CloudIdentityType cloudIdentityType) {\n         attributes = new Json(attributeMap);\n     }\n \n+    public Set<TargetGroup> getTargetGroups() {\n+        return targetGroups;\n+    }\n+\n+    public void setTargetGroups(Set<TargetGroup> targetGroups) {\n+        this.targetGroups = targetGroups;\n+    }\n+\n+    public void addTargetGroup(TargetGroup targetGroup) {\n+        if (targetGroups == null) {", "originalCommit": "5e43c56ce52d7d662196ebae07c6db60206b53a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java\nindex 3df2c79f59..743579fbcf 100644\n--- a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java\n+++ b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java\n\n@@ -223,9 +223,6 @@ public class InstanceGroup implements ProvisionEntity, Comparable<InstanceGroup>\n     }\n \n     public void addTargetGroup(TargetGroup targetGroup) {\n-        if (targetGroups == null) {\n-            targetGroups = new HashSet<>();\n-        }\n         targetGroups.add(targetGroup);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NTM5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527165391", "bodyText": "Do we need to make this a abstract class and subtype a awsloadbalancer from it so we can later support azure's loadbalancing?", "author": "frozenwizard", "createdAt": "2020-11-19T20:06:53Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+\n+@Entity\n+public class LoadBalancer implements ProvisionEntity  {", "originalCommit": "5e43c56ce52d7d662196ebae07c6db60206b53a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNTUwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527235504", "bodyText": "This is a database entity, so I don't think we should mess with it. It's also in a different module and serves a different purpose (used in an internal stack model vs. the cloud based model) than AwsLoadBalancer. I get what you're saying about having an abstract class we can implement for both cloud platforms. But the AwsLoadBalancer was explicitly modeled to mimic the relationship between load balancers, listeners, and target groups in AWS. Since I don't yet know what the Azure model will look like, I'd rather wait until we have more information about that to see what makes sense to abstract out.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NTM5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "chunk": "diff --git a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java\nindex 95af1e12d2..48b1340671 100644\n--- a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java\n+++ b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java\n\n@@ -4,6 +4,7 @@ import java.util.HashSet;\n import java.util.Set;\n \n import javax.persistence.CascadeType;\n+import javax.persistence.Convert;\n import javax.persistence.Entity;\n import javax.persistence.GeneratedValue;\n import javax.persistence.GenerationType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzIzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527167238", "bodyText": "Is there a jira for this one or is it a later commit in this pr?", "author": "frozenwizard", "createdAt": "2020-11-19T20:10:24Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n+            Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n+            Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n+                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n+                .collect(Collectors.toSet());\n+            if (!knoxGatewayGroups.isEmpty()) {\n+                LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n+                TargetGroup targetGroup = new TargetGroup();\n+                targetGroup.setType(TargetGroupType.KNOX.name());\n+                targetGroup.setInstanceGroups(knoxGatewayGroups);\n+                targetGroups.add(targetGroup);\n+                knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n+            }\n+            // TODO create target group for CM instances", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNjU1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527236550", "bodyText": "Yes, Bryce is working on figuring out the configuration for CM target groups in CB-9368. I'll put that JIRA in the comment.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzIzOA=="}], "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java b/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java\nindex a2e83fa1aa..7e0c045468 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java\n\n@@ -362,13 +369,13 @@ public class StackV4RequestToStackConverter extends AbstractConversionServiceAwa\n                 targetGroups.add(targetGroup);\n                 knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n             }\n-            // TODO create target group for CM instances\n+            // TODO CB-9368 - create target group for CM instances\n         }\n \n         if (!targetGroups.isEmpty()) {\n             LoadBalancer loadBalancer = new LoadBalancer();\n             loadBalancer.setStack(stack);\n-            // TODO actually figure out the type we need here\n+            // TODO CB-9900 make this dynamic based on network type instead of hardcoded\n             loadBalancer.setType(LoadBalancerType.PRIVATE.name());\n             loadBalancer.setTargetGroups(targetGroups);\n             targetGroups.forEach(tg -> tg.setLoadBalancer(loadBalancer));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzY4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527167683", "bodyText": "Assuming later commit has this in there?", "author": "frozenwizard", "createdAt": "2020-11-19T20:11:12Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n+            Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n+            Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n+                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n+                .collect(Collectors.toSet());\n+            if (!knoxGatewayGroups.isEmpty()) {\n+                LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n+                TargetGroup targetGroup = new TargetGroup();\n+                targetGroup.setType(TargetGroupType.KNOX.name());\n+                targetGroup.setInstanceGroups(knoxGatewayGroups);\n+                targetGroups.add(targetGroup);\n+                knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n+            }\n+            // TODO create target group for CM instances\n+        }\n+\n+        if (!targetGroups.isEmpty()) {\n+            LoadBalancer loadBalancer = new LoadBalancer();\n+            loadBalancer.setStack(stack);\n+            // TODO actually figure out the type we need here", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNjc1NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527236755", "bodyText": "This is going to be more work than I originally anticipated, so I opened CB-9900 about it. I'll update the comment.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzY4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java b/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java\nindex a2e83fa1aa..7e0c045468 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java\n\n@@ -362,13 +369,13 @@ public class StackV4RequestToStackConverter extends AbstractConversionServiceAwa\n                 targetGroups.add(targetGroup);\n                 knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n             }\n-            // TODO create target group for CM instances\n+            // TODO CB-9368 - create target group for CM instances\n         }\n \n         if (!targetGroups.isEmpty()) {\n             LoadBalancer loadBalancer = new LoadBalancer();\n             loadBalancer.setStack(stack);\n-            // TODO actually figure out the type we need here\n+            // TODO CB-9900 make this dynamic based on network type instead of hardcoded\n             loadBalancer.setType(LoadBalancerType.PRIVATE.name());\n             loadBalancer.setTargetGroups(targetGroups);\n             targetGroups.forEach(tg -> tg.setLoadBalancer(loadBalancer));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2OTMzNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527169335", "bodyText": "Should this be in an entitlement?", "author": "frozenwizard", "createdAt": "2020-11-19T20:14:12Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNTcxMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527235713", "bodyText": "Yep, the entitlement's coming in the next commit.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:09:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2OTMzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java b/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java\nindex a2e83fa1aa..7e0c045468 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java\n\n@@ -362,13 +369,13 @@ public class StackV4RequestToStackConverter extends AbstractConversionServiceAwa\n                 targetGroups.add(targetGroup);\n                 knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n             }\n-            // TODO create target group for CM instances\n+            // TODO CB-9368 - create target group for CM instances\n         }\n \n         if (!targetGroups.isEmpty()) {\n             LoadBalancer loadBalancer = new LoadBalancer();\n             loadBalancer.setStack(stack);\n-            // TODO actually figure out the type we need here\n+            // TODO CB-9900 make this dynamic based on network type instead of hardcoded\n             loadBalancer.setType(LoadBalancerType.PRIVATE.name());\n             loadBalancer.setTargetGroups(targetGroups);\n             targetGroups.forEach(tg -> tg.setLoadBalancer(loadBalancer));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3NzgwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527177804", "bodyText": "What happens if cluster is null?", "author": "frozenwizard", "createdAt": "2020-11-19T20:29:27Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNzQ3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527237474", "bodyText": "Then we don't have a way to check the cluster blueprint, so we don't do anything here and hit the next if that triggers if groupNames is still empty.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:13:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3NzgwNA=="}], "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\nindex c0b09a5a32..699a7028e0 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n\n@@ -1,10 +1,8 @@\n package com.sequenceiq.cloudbreak.service;\n \n import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.stream.Collectors;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MTYwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527181602", "bodyText": "More descriptive variable name please.\nAlso i feel like you could just do String s = stack.getname()+\"-\"+ENDPOING_SUFFIX;  and if public +=\"-\"+PUBLIC_SUFFIX.", "author": "frozenwizard", "createdAt": "2020-11-19T20:35:45Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        List<String> s = Arrays.asList(stack.getName(), ENDPOINT_SUFFIX);", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MTIwMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527241203", "bodyText": "Intellij fusses at you if you append strings with \"+\", but I've changed it to a StringBuilder.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MTYwMg=="}], "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\nindex c0b09a5a32..699a7028e0 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n\n@@ -1,10 +1,8 @@\n package com.sequenceiq.cloudbreak.service;\n \n import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.stream.Collectors;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjQ4MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527182480", "bodyText": "CM?", "author": "frozenwizard", "createdAt": "2020-11-19T20:37:07Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        List<String> s = Arrays.asList(stack.getName(), ENDPOINT_SUFFIX);\n+        if (LoadBalancerType.PUBLIC.equals(type)) {\n+            s.add(PUBLIC_SUFFIX);\n+        }\n+        return String.join(\"-\", s);\n+    }\n+\n+    public Set<Integer> getPortsForTargetGroup(TargetGroup targetGroup) {\n+        switch (targetGroup.getType()) {\n+            case \"KNOX\":", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MTY4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527241689", "bodyText": "Yep, that's why it's a switch statement, so we can add the CM case when it's ready.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjQ4MA=="}], "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\nindex c0b09a5a32..699a7028e0 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n\n@@ -1,10 +1,8 @@\n package com.sequenceiq.cloudbreak.service;\n \n import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.stream.Collectors;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NzgzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527187833", "bodyText": "Could do a Optional.ofNullable(context.loadBalncers).orElse(new ArrayList());", "author": "frozenwizard", "createdAt": "2020-11-19T20:47:17Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/CloudFormationTemplateBuilder.java", "diffHunk": "@@ -91,6 +92,7 @@ public String build(ModelContext context) {\n         model.put(\"outboundInternetTraffic\", context.outboundInternetTraffic);\n         model.put(\"vpcCidrs\", context.vpcCidrs);\n         model.put(\"prefixListIds\", context.prefixListIds);\n+        model.put(\"loadBalancers\", context.loadBalancers == null ? new ArrayList<>() : context.loadBalancers);", "originalCommit": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/CloudFormationTemplateBuilder.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/CloudFormationTemplateBuilder.java\nindex e449ebe096..9b22c22f5d 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/CloudFormationTemplateBuilder.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/CloudFormationTemplateBuilder.java\n\n@@ -92,7 +93,7 @@ public class CloudFormationTemplateBuilder {\n         model.put(\"outboundInternetTraffic\", context.outboundInternetTraffic);\n         model.put(\"vpcCidrs\", context.vpcCidrs);\n         model.put(\"prefixListIds\", context.prefixListIds);\n-        model.put(\"loadBalancers\", context.loadBalancers == null ? new ArrayList<>() : context.loadBalancers);\n+        model.put(\"loadBalancers\", Optional.ofNullable(context.loadBalancers).orElse(Collections.emptyList()));\n         try {\n             String template = freeMarkerTemplateUtils.processTemplateIntoString(new Template(\"aws-template\", context.template, freemarkerConfiguration), model);\n             return template.replaceAll(\"\\\\t|\\\\n| [\\\\s]+\", \"\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4OTkwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527189909", "bodyText": "there's a findFirst() you can use instead.", "author": "frozenwizard", "createdAt": "2020-11-19T20:51:10Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +164,128 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            ModelContext modelContext, List<CloudResource> instances) {\n+\n+        if (stack.getLoadBalancers().isPresent() && !stack.getLoadBalancers().get().isEmpty()) {\n+            if (modelContext == null) {\n+                modelContext = buildDefaultModelContext(ac, stack, resourceNotifier);\n+            }\n+\n+            List<AwsLoadBalancer> awsLoadBalancers = new ArrayList<>();\n+            List<CloudLoadBalancer> cloudLoadBalancers = stack.getLoadBalancers().get();\n+            for (CloudLoadBalancer cloudLoadBalancer : cloudLoadBalancers) {\n+                awsLoadBalancers.add(convert(cloudLoadBalancer, stack, instances));\n+            }\n+\n+            modelContext.withLoadBalancers(awsLoadBalancers);\n+            ListStackResourcesResult result = updateCloudFormationStack(ac, stack, modelContext);\n+\n+            for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n+                for (AwsListener listener : loadBalancer.getListeners()) {\n+                    for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n+                        StackResourceSummary targetGroupSummary = result.getStackResourceSummaries().stream()\n+                            .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                            .collect(Collectors.toList())\n+                            .get(0);", "originalCommit": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\nindex 98f9f1d7e0..ee421cec26 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\n\n@@ -224,18 +225,22 @@ public class AwsLaunchService {\n             for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n                 for (AwsListener listener : loadBalancer.getListeners()) {\n                     for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n-                        StackResourceSummary targetGroupSummary = result.getStackResourceSummaries().stream()\n+                        Optional<StackResourceSummary> targetGroupSummary = result.getStackResourceSummaries().stream()\n                             .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n-                            .collect(Collectors.toList())\n-                            .get(0);\n-                        targetGroup.setArn(targetGroupSummary.getPhysicalResourceId());\n+                            .findFirst();\n+                        if (targetGroupSummary.isEmpty()) {\n+                            throw new CloudConnectorException(\"Could not create load balancer listeners: target group not found.\");\n+                        }\n+                        targetGroup.setArn(targetGroupSummary.get().getPhysicalResourceId());\n                     }\n                 }\n-                StackResourceSummary loadBalancerSummary = result.getStackResourceSummaries().stream()\n+                Optional<StackResourceSummary> loadBalancerSummary = result.getStackResourceSummaries().stream()\n                     .filter(stackResourceSummary -> loadBalancer.getName().equals(stackResourceSummary.getLogicalResourceId()))\n-                    .collect(Collectors.toList())\n-                    .get(0);\n-                loadBalancer.setArn(loadBalancerSummary.getPhysicalResourceId());\n+                    .findFirst();\n+                if (loadBalancerSummary.isEmpty()) {\n+                    throw new CloudConnectorException(\"Could not create load balancer listeners: load balancer not found.\");\n+                }\n+                loadBalancer.setArn(loadBalancerSummary.get().getPhysicalResourceId());\n                 loadBalancer.canCreateListeners();\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4OTk1Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527189957", "bodyText": "findFirst()", "author": "frozenwizard", "createdAt": "2020-11-19T20:51:16Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +164,128 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            ModelContext modelContext, List<CloudResource> instances) {\n+\n+        if (stack.getLoadBalancers().isPresent() && !stack.getLoadBalancers().get().isEmpty()) {\n+            if (modelContext == null) {\n+                modelContext = buildDefaultModelContext(ac, stack, resourceNotifier);\n+            }\n+\n+            List<AwsLoadBalancer> awsLoadBalancers = new ArrayList<>();\n+            List<CloudLoadBalancer> cloudLoadBalancers = stack.getLoadBalancers().get();\n+            for (CloudLoadBalancer cloudLoadBalancer : cloudLoadBalancers) {\n+                awsLoadBalancers.add(convert(cloudLoadBalancer, stack, instances));\n+            }\n+\n+            modelContext.withLoadBalancers(awsLoadBalancers);\n+            ListStackResourcesResult result = updateCloudFormationStack(ac, stack, modelContext);\n+\n+            for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n+                for (AwsListener listener : loadBalancer.getListeners()) {\n+                    for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n+                        StackResourceSummary targetGroupSummary = result.getStackResourceSummaries().stream()\n+                            .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                            .collect(Collectors.toList())\n+                            .get(0);\n+                        targetGroup.setArn(targetGroupSummary.getPhysicalResourceId());\n+                    }\n+                }\n+                StackResourceSummary loadBalancerSummary = result.getStackResourceSummaries().stream()\n+                    .filter(stackResourceSummary -> loadBalancer.getName().equals(stackResourceSummary.getLogicalResourceId()))", "originalCommit": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\nindex 98f9f1d7e0..ee421cec26 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\n\n@@ -224,18 +225,22 @@ public class AwsLaunchService {\n             for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n                 for (AwsListener listener : loadBalancer.getListeners()) {\n                     for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n-                        StackResourceSummary targetGroupSummary = result.getStackResourceSummaries().stream()\n+                        Optional<StackResourceSummary> targetGroupSummary = result.getStackResourceSummaries().stream()\n                             .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n-                            .collect(Collectors.toList())\n-                            .get(0);\n-                        targetGroup.setArn(targetGroupSummary.getPhysicalResourceId());\n+                            .findFirst();\n+                        if (targetGroupSummary.isEmpty()) {\n+                            throw new CloudConnectorException(\"Could not create load balancer listeners: target group not found.\");\n+                        }\n+                        targetGroup.setArn(targetGroupSummary.get().getPhysicalResourceId());\n                     }\n                 }\n-                StackResourceSummary loadBalancerSummary = result.getStackResourceSummaries().stream()\n+                Optional<StackResourceSummary> loadBalancerSummary = result.getStackResourceSummaries().stream()\n                     .filter(stackResourceSummary -> loadBalancer.getName().equals(stackResourceSummary.getLogicalResourceId()))\n-                    .collect(Collectors.toList())\n-                    .get(0);\n-                loadBalancer.setArn(loadBalancerSummary.getPhysicalResourceId());\n+                    .findFirst();\n+                if (loadBalancerSummary.isEmpty()) {\n+                    throw new CloudConnectorException(\"Could not create load balancer listeners: load balancer not found.\");\n+                }\n+                loadBalancer.setArn(loadBalancerSummary.get().getPhysicalResourceId());\n                 loadBalancer.canCreateListeners();\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MTQ4MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527191480", "bodyText": "huh?  capatilize into lower case?", "author": "frozenwizard", "createdAt": "2020-11-19T20:54:07Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsTargetGroup.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsTargetGroup {\n+\n+    private static final String TARGET_GROUP_NAME_PREFIX = \"TargetGroupPort\";\n+\n+    private final int port;\n+\n+    private final String name;\n+\n+    private final int order;\n+\n+    private final List<String> instanceIds;\n+\n+    private String arn;\n+\n+    public AwsTargetGroup(int port, AwsLoadBalancerScheme scheme, int order, List<String> instanceIds) {\n+        this.port = port;\n+        this.order = order;\n+        this.instanceIds = instanceIds;\n+        name = getTargetGroupName(port, scheme);\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public String getArn() {\n+        return arn;\n+    }\n+\n+    public void setArn(String arn) {\n+        this.arn = arn;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public int getOrder() {\n+        return order;\n+    }\n+\n+    public List<String> getInstanceIds() {\n+        return instanceIds;\n+    }\n+\n+    private static String getTargetGroupName(int port, AwsLoadBalancerScheme scheme) {\n+        return TARGET_GROUP_NAME_PREFIX + port +\n+            StringUtils.capitalize(scheme.name().toLowerCase());", "originalCommit": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0NTEyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527245127", "bodyText": "Technically lowercase into capitalize, so PRIVATE becomes Private. I couldn't find a more elegant way to do it. There's no real reason to be this nitpicky about the capitalization, I just think it looks better to have LoadBalancerPrivate instead of LoadBalancerprivate or LoadBalancerPRIVATE.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:25:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MTQ4MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MjcwOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527192708", "bodyText": "jira?", "author": "frozenwizard", "createdAt": "2020-11-19T20:56:17Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,30 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> gatewayGroupNames) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());\n+\n+        String region = ac.getCloudContext().getLocation().getRegion().value();\n+\n+        List<CloudLoadBalancerMetadata> cloudLoadBalancerMetadata = new ArrayList<>();\n+        try {\n+            for (String groupName : gatewayGroupNames) {\n+                String loadBalancerName = AwsLoadBalancer.getLoadBalancerName(AwsLoadBalancerScheme.PRIVATE);\n+                LoadBalancer loadBalancer = cloudFormationStackUtil.getLoadBalancerByLogicalId(ac, loadBalancerName, region);\n+                cloudLoadBalancerMetadata.add(new CloudLoadBalancerMetadata(\n+                    groupName,\n+                    LoadBalancerType.PRIVATE,\n+                    loadBalancer.getDNSName(),\n+                    loadBalancer.getCanonicalHostedZoneId(),\n+                    null\n+                ));\n+                // TODO public endpoints", "originalCommit": "de55a4bb1b4971dd8f935faf64cd1e01685b9bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MjM4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527242388", "bodyText": "Old comment. Deleted it and changed LoadBalancerType.PRIVATE to LoadBalancerType.valueOf(type), which should handle either case.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MjcwOA=="}], "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java\nindex f7236dfdd0..63434afcce 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java\n\n@@ -178,24 +178,22 @@ public class AwsMetadataCollector implements MetadataCollector {\n     }\n \n     @Override\n-    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> gatewayGroupNames) {\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> loadBalancerTypes) {\n         LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());\n \n         String region = ac.getCloudContext().getLocation().getRegion().value();\n \n         List<CloudLoadBalancerMetadata> cloudLoadBalancerMetadata = new ArrayList<>();\n         try {\n-            for (String groupName : gatewayGroupNames) {\n-                String loadBalancerName = AwsLoadBalancer.getLoadBalancerName(AwsLoadBalancerScheme.PRIVATE);\n+            for (String type : loadBalancerTypes) {\n+                String loadBalancerName = AwsLoadBalancer.getLoadBalancerName(AwsLoadBalancerScheme.valueOf(type));\n                 LoadBalancer loadBalancer = cloudFormationStackUtil.getLoadBalancerByLogicalId(ac, loadBalancerName, region);\n                 cloudLoadBalancerMetadata.add(new CloudLoadBalancerMetadata(\n-                    groupName,\n-                    LoadBalancerType.PRIVATE,\n+                    LoadBalancerType.valueOf(type),\n                     loadBalancer.getDNSName(),\n                     loadBalancer.getCanonicalHostedZoneId(),\n                     null\n                 ));\n-                // TODO public endpoints\n             }\n             return cloudLoadBalancerMetadata;\n         } catch (RuntimeException e) {\n"}}, {"oid": "6d89db90bbc4014d490a9f57fa21920c583a753c", "url": "https://github.com/hortonworks/cloudbreak/commit/6d89db90bbc4014d490a9f57fa21920c583a753c", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes.", "committedDate": "2020-11-20T00:16:55Z", "type": "forcePushed"}, {"oid": "9135c5e07472800ad49f077d0c2a90995404f308", "url": "https://github.com/hortonworks/cloudbreak/commit/9135c5e07472800ad49f077d0c2a90995404f308", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes.", "committedDate": "2020-11-20T16:25:43Z", "type": "forcePushed"}, {"oid": "13ceaf192fc8588e41c803e6764c650de33d9d8d", "url": "https://github.com/hortonworks/cloudbreak/commit/13ceaf192fc8588e41c803e6764c650de33d9d8d", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes.", "committedDate": "2020-11-20T16:59:43Z", "type": "forcePushed"}, {"oid": "a90cb7616434e79f07beb3b2521875754c0f15b0", "url": "https://github.com/hortonworks/cloudbreak/commit/a90cb7616434e79f07beb3b2521875754c0f15b0", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes.", "committedDate": "2020-11-20T22:27:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjMzNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527182336", "bodyText": "question: I see that we're typing ProvisionEntity in lots of places, but I don't see anywhere that it's used to narrow a type or provide for multiple implementations. It looks like it's just an extension of Serializable -- is that the case?", "author": "brycederriso", "createdAt": "2020-11-19T20:36:53Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import java.util.Set;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+\n+@Entity\n+public class TargetGroup implements ProvisionEntity {", "originalCommit": "5e43c56ce52d7d662196ebae07c6db60206b53a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyMTQ1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528021453", "bodyText": "Yes. There's some check in the code that makes sure all database entity classes are serializable, and that's done through the ProvisionEntity interface. I don't know if that has something to do with JPA or is a CB requirement, but the build won't work without it.", "author": "hreeve-cloudera", "createdAt": "2020-11-20T23:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjMzNg=="}], "type": "inlineReview", "revised_code": {"commit": "6d89db90bbc4014d490a9f57fa21920c583a753c", "chunk": "diff --git a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java\nindex f862c6d32f..5d44d74b23 100644\n--- a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java\n+++ b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java\n\n@@ -29,6 +29,10 @@ public class TargetGroup implements ProvisionEntity {\n     @ManyToMany(fetch = FetchType.EAGER)\n     private Set<InstanceGroup> instanceGroups;\n \n+    public Long getId() {\n+        return id;\n+    }\n+\n     public String getType() {\n         return type;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NTEwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527185104", "bodyText": "suggestion: LoadBalancerPersistenceService maybe? I'm not generally a huge fan of the @Service ...Service pattern of naming.\nI think it's clearer to indicate that this deals with the persistence aspects of Load balancer entities.", "author": "brycederriso", "createdAt": "2020-11-19T20:42:17Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/stack/LoadBalancerService.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package com.sequenceiq.cloudbreak.service.stack;\n+\n+import java.util.Set;\n+\n+import javax.inject.Inject;\n+\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.LoadBalancer;\n+import com.sequenceiq.cloudbreak.repository.LoadBalancerRepository;\n+\n+@Service\n+public class LoadBalancerService {", "originalCommit": "5e43c56ce52d7d662196ebae07c6db60206b53a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyODU4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528028587", "bodyText": "I'm fine with that. But so you know there a lot of @Service ...Service class names in this part of the code. :)", "author": "hreeve-cloudera", "createdAt": "2020-11-20T23:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NTEwNA=="}], "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/stack/LoadBalancerService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/stack/LoadBalancerPersistenceService.java\nsimilarity index 94%\nrename from core/src/main/java/com/sequenceiq/cloudbreak/service/stack/LoadBalancerService.java\nrename to core/src/main/java/com/sequenceiq/cloudbreak/service/stack/LoadBalancerPersistenceService.java\nindex a465990462..134e39b32f 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/stack/LoadBalancerService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/stack/LoadBalancerPersistenceService.java\n\n@@ -10,7 +10,7 @@ import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.LoadBalancer;\n import com.sequenceiq.cloudbreak.repository.LoadBalancerRepository;\n \n @Service\n-public class LoadBalancerService {\n+public class LoadBalancerPersistenceService {\n \n     @Inject\n     private LoadBalancerRepository repository;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5OTY2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527199665", "bodyText": "suggestion: Consider using an empty List here instead of null.\nI'd prefer the semantics of an empty List<CloudLoadBalancer> over Optional<List<CloudLoadBalancer> as well.\nI'd only expect that to throw a wrench in maybe serialization? Are there other reasons you chose Optional over an empty list?", "author": "brycederriso", "createdAt": "2020-11-19T21:08:56Z", "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudStack.java", "diffHunk": "@@ -33,8 +33,16 @@\n \n     private final Optional<SpiFileSystem> fileSystem;\n \n+    private final Optional<List<CloudLoadBalancer>> loadBalancers;\n+\n     public CloudStack(Collection<Group> groups, Network network, Image image, Map<String, String> parameters, Map<String, String> tags, String template,\n             InstanceAuthentication instanceAuthentication, String loginUserName, String publicKey, SpiFileSystem fileSystem) {\n+        this(groups, network, image, parameters, tags, template, instanceAuthentication, loginUserName, publicKey, fileSystem, null);", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNzUyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528027523", "bodyText": "Serialization should be fine. I've been working on these changes for about a month, and I think the optional choice was made here when I thought there would only be a single load balancer, and I just never updated it when I changed that to a list. But that makes sense, and I'll change it to empty list.", "author": "hreeve-cloudera", "createdAt": "2020-11-20T23:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5OTY2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudStack.java b/cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudStack.java\nindex 82e2b938bc..01cccfcf21 100644\n--- a/cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudStack.java\n+++ b/cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudStack.java\n\n@@ -33,16 +34,16 @@ public class CloudStack {\n \n     private final Optional<SpiFileSystem> fileSystem;\n \n-    private final Optional<List<CloudLoadBalancer>> loadBalancers;\n+    private final List<CloudLoadBalancer> loadBalancers;\n \n     public CloudStack(Collection<Group> groups, Network network, Image image, Map<String, String> parameters, Map<String, String> tags, String template,\n             InstanceAuthentication instanceAuthentication, String loginUserName, String publicKey, SpiFileSystem fileSystem) {\n-        this(groups, network, image, parameters, tags, template, instanceAuthentication, loginUserName, publicKey, fileSystem, null);\n+        this(groups, network, image, parameters, tags, template, instanceAuthentication, loginUserName, publicKey, fileSystem, Collections.emptyList());\n     }\n \n     public CloudStack(Collection<Group> groups, Network network, Image image, Map<String, String> parameters, Map<String, String> tags,\n             String template, InstanceAuthentication instanceAuthentication, String loginUserName, String publicKey, SpiFileSystem fileSystem,\n-            List<CloudLoadBalancer> cloudLoadBalancers) {\n+            List<CloudLoadBalancer> loadBalancers) {\n         this.groups = ImmutableList.copyOf(groups);\n         this.network = network;\n         this.image = image;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwMDIzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527200238", "bodyText": "praise: Thank you for not making these just String constants!\nLove me some enums.", "author": "brycederriso", "createdAt": "2020-11-19T21:09:51Z", "path": "common-model/src/main/java/com/sequenceiq/common/api/type/LoadBalancerType.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package com.sequenceiq.common.api.type;\n+\n+public enum LoadBalancerType {", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMjYxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528002614", "bodyText": "question: The body of this if is adding knox TargetGroups to the targetGroups set if the stack we're working with is a Datalake?\nIf possible, I think it would be clearer to move the knoxGatewayGroups out of the if block and do an else:\n    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n        Set<LoadBalancer> loadBalancers = new HashSet<>();\n        Set<TargetGroup> targetGroups = new HashSet<>();\n        // TODO expand this to data hubs\n\n        Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n        Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n                .collect(Collectors.toSet());\n\n        if (StackType.DATALAKE.equals(source.getType()) && !knoxGatewayGroups.isEmpty()) {\n            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n            LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n            TargetGroup targetGroup = new TargetGroup();\n            targetGroup.setType(TargetGroupType.KNOX.name());\n            targetGroup.setInstanceGroups(knoxGatewayGroups);\n            targetGroups.add(targetGroup);\n            // TODO create target group for CM instances\n        } else {\n            LoadBalancer loadBalancer = new LoadBalancer();\n            loadBalancer.setStack(stack);\n            // TODO actually figure out the type we need here\n            loadBalancer.setType(LoadBalancerType.PRIVATE.name());\n            loadBalancer.setTargetGroups(targetGroups);\n            targetGroups.forEach(tg -> tg.setLoadBalancer(loadBalancer));\n            loadBalancers.add(loadBalancer);\n        }\n\n        return loadBalancers;\n    }", "author": "brycederriso", "createdAt": "2020-11-20T22:23:11Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNzQ1NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528027455", "bodyText": "My intention was to limit the stack types that could have load balancers at all to only data lakes. If it's any other kind of stack we shouldn't add anything to the target groups at all. So having an else at all is anathema to that. It's a gatekeeping if.\nThe way target groups work is they're just a type of traffic and the instance groups that traffic is forwarded to. In the else you're creating target groups, but not setting either of those properties. Which is basically saying to the load balancer, \"I want you to forward traffic, but I'm not going to tell you what traffic to forward or where it's going.\" Which is making me realize I should really mark those fields as non-null so we know they need to be set.\nWith that in mind, do you have any suggestions on how to clarify it?", "author": "hreeve-cloudera", "createdAt": "2020-11-20T23:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMjYxNA=="}], "type": "inlineReview", "revised_code": {"commit": "a90cb7616434e79f07beb3b2521875754c0f15b0", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java b/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java\nindex a2e83fa1aa..a5d51a921f 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java\n\n@@ -348,7 +353,8 @@ public class StackV4RequestToStackConverter extends AbstractConversionServiceAwa\n         Set<LoadBalancer> loadBalancers = new HashSet<>();\n         Set<TargetGroup> targetGroups = new HashSet<>();\n         // TODO expand this to data hubs\n-        if (StackType.DATALAKE.equals(source.getType())) {\n+        if (StackType.DATALAKE.equals(source.getType()) &&\n+            entitlementService.datalakeLoadBalancerEnabled(ThreadBasedUserCrnProvider.getUserCrn(), ThreadBasedUserCrnProvider.getAccountId())) {\n             LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n             Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n             Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAxNDYwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528014606", "bodyText": "suggestion: I'd generally prefer not to double nest streams like this, but I'm not sure it's avoidable here.\nYou could extract a function hostGroupContainsKnoxGateway that contains the e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())) portion and then do:\n            groupNames = components.entrySet().stream()\n                .filter(hostGroupContainsKnoxGateway)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toSet());\nBut, barring that, consider expanding the lambda function parameters e and c into what they they actually represent -- entry and serviceComponent I think.", "author": "brycederriso", "createdAt": "2020-11-20T22:58:58Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNzQwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528027400", "bodyText": "I can do a separate function to make it more readable.", "author": "hreeve-cloudera", "createdAt": "2020-11-20T23:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAxNDYwNg=="}], "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\nindex c0b09a5a32..d7741bd5ec 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n\n@@ -1,10 +1,8 @@\n package com.sequenceiq.cloudbreak.service;\n \n import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.stream.Collectors;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwMzc0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r529203743", "bodyText": "do you want to also rename the variable name to match the remaining refactoring.", "author": "enis", "createdAt": "2020-11-24T04:59:51Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/stack/flow/MetadataSetupService.java", "diffHunk": "@@ -54,7 +54,7 @@\n     private InstanceMetaDataService instanceMetaDataService;\n \n     @Inject\n-    private LoadBalancerService loadBalancerMetadataService;\n+    private LoadBalancerPersistenceService loadBalancerMetadataService;", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/stack/flow/MetadataSetupService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/stack/flow/MetadataSetupService.java\nindex ebf1e4cd44..c38b416c62 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/stack/flow/MetadataSetupService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/stack/flow/MetadataSetupService.java\n\n@@ -54,7 +54,7 @@ public class MetadataSetupService {\n     private InstanceMetaDataService instanceMetaDataService;\n \n     @Inject\n-    private LoadBalancerPersistenceService loadBalancerMetadataService;\n+    private LoadBalancerPersistenceService loadBalancerPersistenceService;\n \n     @Inject\n     private LoadBalancerConfigService loadBalancerConfigService;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwMzY4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530003686", "bodyText": "Just linking https://github.infra.cloudera.com/thunderhead/thunderhead/pull/2780 for other reviewers.", "author": "enis", "createdAt": "2020-11-24T23:29:23Z", "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/model/Entitlement.java", "diffHunk": "@@ -33,5 +33,6 @@\n     DATAHUB_AZURE_AUTOSCALING,\n     CDP_CB_DATABASE_WIRE_ENCRYPTION,\n     CDP_ENABLE_DISTROX_INSTANCE_TYPES,\n-    CDP_SHOW_CLI;\n+    CDP_SHOW_CLI,\n+    CDP_DL_LOAD_BALANCER;", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/model/Entitlement.java b/auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/model/Entitlement.java\nindex 76b0cf96c3..2b58e41bd6 100644\n--- a/auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/model/Entitlement.java\n+++ b/auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/model/Entitlement.java\n\n@@ -34,5 +34,6 @@ public enum Entitlement {\n     CDP_CB_DATABASE_WIRE_ENCRYPTION,\n     CDP_ENABLE_DISTROX_INSTANCE_TYPES,\n     CDP_SHOW_CLI,\n-    CDP_DL_LOAD_BALANCER;\n+    CDP_LIST_FILTERING,\n+    CDP_DATA_LAKE_LOAD_BALANCER;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwODI4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530008286", "bodyText": "AWS load balancers bind to 1 ip per subnet for better cross-AZ availability. I think you should make this a List instead.", "author": "enis", "createdAt": "2020-11-24T23:34:15Z", "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudLoadBalancerMetadata.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.sequenceiq.cloudbreak.cloud.model;\n+\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+public class CloudLoadBalancerMetadata {\n+\n+    private final LoadBalancerType type;\n+\n+    private final String cloudDns;\n+\n+    private final String hostedZoneId;\n+\n+    private final String ip;", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY3ODgwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532678801", "bodyText": "The ip field isn't used for AWS load balancers at all. We instead use the dns and hostedZoneId. I put this here because my understanding is that Azure LBs use IPs, so we'll need an ip field eventually. But if it needs to be a list we'll update it when the Azure work is being done.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwODI4Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxMTk4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530011988", "bodyText": "I do not see these two methods being used.", "author": "enis", "createdAt": "2020-11-24T23:38:07Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java", "diffHunk": "@@ -170,6 +172,23 @@ public AmazonCloudFormationRetryClient createCloudFormationRetryClient(AmazonClo\n         return new AmazonCloudFormationRetryClient(amazonCloudFormationClient, retry);\n     }\n \n+    public AmazonElasticLoadBalancingClient createElasticLoadBalancingClient(AwsCredentialView awsCredential, String regionName) {\n+        AmazonElasticLoadBalancingClient client = isRoleAssumeRequired(awsCredential) ?\n+            new AmazonElasticLoadBalancingClient(createAwsSessionCredentialProvider(awsCredential), getDefaultClientConfiguration()) :\n+            new AmazonElasticLoadBalancingClient(createAwsCredentials(awsCredential), getDefaultClientConfiguration());\n+        client.setRegion(RegionUtils.getRegion(regionName));\n+        client.addRequestHandler(new AwsTracingRequestHandler(tracer));\n+        return client;\n+    }\n+\n+    public AmazonElbV2RetryClient createElbV2RetryClient(AwsCredentialView awsCredential, String regionName) {", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java\nindex d1771b65c1..2b4a35996f 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java\n\n@@ -181,14 +180,6 @@ public class AwsClient {\n         return client;\n     }\n \n-    public AmazonElbV2RetryClient createElbV2RetryClient(AwsCredentialView awsCredential, String regionName) {\n-        return new AmazonElbV2RetryClient(createElasticLoadBalancingClient(awsCredential, regionName), retry);\n-    }\n-\n-    public AmazonElbV2RetryClient createElbV2RetryClient(AmazonElasticLoadBalancingClient amazonElasticLoadBalancingClient) {\n-        return new AmazonElbV2RetryClient(amazonElasticLoadBalancingClient, retry);\n-    }\n-\n     public AmazonAutoScalingClient createAutoScalingClient(AwsCredentialView awsCredential, String regionName) {\n         AmazonAutoScalingClient client = isRoleAssumeRequired(awsCredential) ?\n                 new AmazonAutoScalingClient(createAwsSessionCredentialProvider(awsCredential), getDefaultClientConfiguration()) :\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxMjA3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530012076", "bodyText": "same here.", "author": "enis", "createdAt": "2020-11-24T23:38:13Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java", "diffHunk": "@@ -170,6 +172,23 @@ public AmazonCloudFormationRetryClient createCloudFormationRetryClient(AmazonClo\n         return new AmazonCloudFormationRetryClient(amazonCloudFormationClient, retry);\n     }\n \n+    public AmazonElasticLoadBalancingClient createElasticLoadBalancingClient(AwsCredentialView awsCredential, String regionName) {\n+        AmazonElasticLoadBalancingClient client = isRoleAssumeRequired(awsCredential) ?\n+            new AmazonElasticLoadBalancingClient(createAwsSessionCredentialProvider(awsCredential), getDefaultClientConfiguration()) :\n+            new AmazonElasticLoadBalancingClient(createAwsCredentials(awsCredential), getDefaultClientConfiguration());\n+        client.setRegion(RegionUtils.getRegion(regionName));\n+        client.addRequestHandler(new AwsTracingRequestHandler(tracer));\n+        return client;\n+    }\n+\n+    public AmazonElbV2RetryClient createElbV2RetryClient(AwsCredentialView awsCredential, String regionName) {\n+        return new AmazonElbV2RetryClient(createElasticLoadBalancingClient(awsCredential, regionName), retry);\n+    }\n+\n+    public AmazonElbV2RetryClient createElbV2RetryClient(AmazonElasticLoadBalancingClient amazonElasticLoadBalancingClient) {", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java\nindex d1771b65c1..2b4a35996f 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java\n\n@@ -181,14 +180,6 @@ public class AwsClient {\n         return client;\n     }\n \n-    public AmazonElbV2RetryClient createElbV2RetryClient(AwsCredentialView awsCredential, String regionName) {\n-        return new AmazonElbV2RetryClient(createElasticLoadBalancingClient(awsCredential, regionName), retry);\n-    }\n-\n-    public AmazonElbV2RetryClient createElbV2RetryClient(AmazonElasticLoadBalancingClient amazonElasticLoadBalancingClient) {\n-        return new AmazonElbV2RetryClient(amazonElasticLoadBalancingClient, retry);\n-    }\n-\n     public AmazonAutoScalingClient createAutoScalingClient(AwsCredentialView awsCredential, String regionName) {\n         AmazonAutoScalingClient client = isRoleAssumeRequired(awsCredential) ?\n                 new AmazonAutoScalingClient(createAwsSessionCredentialProvider(awsCredential), getDefaultClientConfiguration()) :\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjA3MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530016070", "bodyText": "AWS and Azure calls these \"Internal\" load balancers rather than public / private. In AWS, they are called \"internet-facing\".\nLoadBalancerType in AWS is a selection between \"ELB\", \"NLB\", or \"ALB\" versus the internal vs internet-facing is called \"load balancer scheme\". See https://docs.aws.amazon.com/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html.\nWe do not necessarily need to follow the same naming, but just a sugestion if we want to be consistent with the cloud providers.", "author": "enis", "createdAt": "2020-11-24T23:44:17Z", "path": "common-model/src/main/java/com/sequenceiq/common/api/type/LoadBalancerType.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package com.sequenceiq.common.api.type;\n+\n+public enum LoadBalancerType {\n+    PUBLIC,\n+    PRIVATE", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY4MTg3OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532681878", "bodyText": "The purpose of this module is to provide a cloud provider agnostic modeling of the cloud resources. So I don't feel any particular need to follow the cloud provide convention super closely. Especially since I only know the AWS convention, so following that might just mean we're contradicting the Azure convention.\nI am considering changing these to INTERNAL and EXTERNAL, but I'm going to think about that and make the change later if necessary.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjA3MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjYzNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530016634", "bodyText": "nit: typo in balanacer", "author": "enis", "createdAt": "2020-11-24T23:45:45Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,28 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> loadBalancerTypes) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java\nindex 63434afcce..916b2781aa 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java\n\n@@ -179,7 +179,7 @@ public class AwsMetadataCollector implements MetadataCollector {\n \n     @Override\n     public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> loadBalancerTypes) {\n-        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());\n+        LOGGER.debug(\"Collect AWS load balancer metadata, for cluster {}\", ac.getCloudContext().getName());\n \n         String region = ac.getCloudContext().getLocation().getRegion().value();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNzM5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530017391", "bodyText": "we do not have access to the ip at this point?", "author": "enis", "createdAt": "2020-11-24T23:48:06Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,28 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> loadBalancerTypes) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());\n+\n+        String region = ac.getCloudContext().getLocation().getRegion().value();\n+\n+        List<CloudLoadBalancerMetadata> cloudLoadBalancerMetadata = new ArrayList<>();\n+        try {\n+            for (String type : loadBalancerTypes) {\n+                String loadBalancerName = AwsLoadBalancer.getLoadBalancerName(AwsLoadBalancerScheme.valueOf(type));\n+                LoadBalancer loadBalancer = cloudFormationStackUtil.getLoadBalancerByLogicalId(ac, loadBalancerName, region);\n+                cloudLoadBalancerMetadata.add(new CloudLoadBalancerMetadata(\n+                    LoadBalancerType.valueOf(type),\n+                    loadBalancer.getDNSName(),\n+                    loadBalancer.getCanonicalHostedZoneId(),\n+                    null", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY4MzA5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532683091", "bodyText": "No. For AWS load balancers we use the cloud DNS name and hostedZoneId, not the IP address.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNzM5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java\nindex 63434afcce..916b2781aa 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java\n\n@@ -179,7 +179,7 @@ public class AwsMetadataCollector implements MetadataCollector {\n \n     @Override\n     public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> loadBalancerTypes) {\n-        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());\n+        LOGGER.debug(\"Collect AWS load balancer metadata, for cluster {}\", ac.getCloudContext().getName());\n \n         String region = ac.getCloudContext().getLocation().getRegion().value();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxOTk2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530019968", "bodyText": "Do you want to rename subnet to newSubnetCidr to match the one in getStackParameters. I am assuming that this is the CIDR for the subnet.", "author": "enis", "createdAt": "2020-11-24T23:55:56Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java", "diffHunk": "@@ -86,6 +87,20 @@ public DeleteStackRequest createDeleteStackRequest(String cFStackName) {\n                 .withStackName(cFStackName);\n     }\n \n+    public UpdateStackRequest createUpdateStackRequest(AuthenticatedContext ac, CloudStack stack, String cFStackName, String subnet, String cfTemplate) {\n+        return new UpdateStackRequest()\n+            .withStackName(cFStackName)\n+            .withTemplateBody(cfTemplate)\n+            .withTags(awsTaggingService.prepareCloudformationTags(ac, stack.getTags()))\n+            .withCapabilities(CAPABILITY_IAM)\n+            .withParameters(getStackParameters(ac, stack, cFStackName, subnet));", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java\nindex fa67fbc0cb..c52562bde0 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java\n\n@@ -90,10 +90,10 @@ public class AwsStackRequestHelper {\n     public UpdateStackRequest createUpdateStackRequest(AuthenticatedContext ac, CloudStack stack, String cFStackName, String subnet, String cfTemplate) {\n         return new UpdateStackRequest()\n             .withStackName(cFStackName)\n+            .withParameters(getStackParameters(ac, stack, cFStackName, subnet))\n             .withTemplateBody(cfTemplate)\n             .withTags(awsTaggingService.prepareCloudformationTags(ac, stack.getTags()))\n-            .withCapabilities(CAPABILITY_IAM)\n-            .withParameters(getStackParameters(ac, stack, cFStackName, subnet));\n+            .withCapabilities(CAPABILITY_IAM);\n     }\n \n     public ListStackResourcesRequest createListStackResourcesRequest(String cFStackName) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMDIxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530020214", "bodyText": "This overloads the function defined above. I suggest moving it to be just below that, and changing that function definition to call this with subnet = null", "author": "enis", "createdAt": "2020-11-24T23:56:48Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java", "diffHunk": "@@ -86,6 +87,20 @@ public DeleteStackRequest createDeleteStackRequest(String cFStackName) {\n                 .withStackName(cFStackName);\n     }\n \n+    public UpdateStackRequest createUpdateStackRequest(AuthenticatedContext ac, CloudStack stack, String cFStackName, String subnet, String cfTemplate) {", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzMzQ2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532833461", "bodyText": "I took a closer look and realized we didn't need two different methods, so I've removed this one and am using the other createUpdateStackRequest method.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T19:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMDIxNA=="}], "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java\nindex fa67fbc0cb..c52562bde0 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java\n\n@@ -90,10 +90,10 @@ public class AwsStackRequestHelper {\n     public UpdateStackRequest createUpdateStackRequest(AuthenticatedContext ac, CloudStack stack, String cFStackName, String subnet, String cfTemplate) {\n         return new UpdateStackRequest()\n             .withStackName(cFStackName)\n+            .withParameters(getStackParameters(ac, stack, cFStackName, subnet))\n             .withTemplateBody(cfTemplate)\n             .withTags(awsTaggingService.prepareCloudformationTags(ac, stack.getTags()))\n-            .withCapabilities(CAPABILITY_IAM)\n-            .withParameters(getStackParameters(ac, stack, cFStackName, subnet));\n+            .withCapabilities(CAPABILITY_IAM);\n     }\n \n     public ListStackResourcesRequest createListStackResourcesRequest(String cFStackName) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMTQ2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530021462", "bodyText": "should be named describeLoadBalancers()", "author": "enis", "createdAt": "2020-11-25T00:00:37Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.client;\n+\n+import com.amazonaws.services.elasticloadbalancingv2.AmazonElasticLoadBalancingClient;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersResult;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsResult;\n+import com.sequenceiq.cloudbreak.service.Retry;\n+\n+public class AmazonElbV2RetryClient extends AmazonRetryClient {\n+\n+    private final AmazonElasticLoadBalancingClient client;\n+\n+    private final Retry retry;\n+\n+    public AmazonElbV2RetryClient(AmazonElasticLoadBalancingClient client, Retry retry) {\n+        this.client = client;\n+        this.retry = retry;\n+    }\n+\n+    public DescribeLoadBalancersResult describeLoadBalancer(DescribeLoadBalancersRequest request) {", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY4NzE0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532687143", "bodyText": "Looking at this class made me realize I'm not actually using it anymore, so I'm deleting it.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMTQ2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java\ndeleted file mode 100644\nindex 4f6045f06a..0000000000\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java\n+++ /dev/null\n\n@@ -1,28 +0,0 @@\n-package com.sequenceiq.cloudbreak.cloud.aws.client;\n-\n-import com.amazonaws.services.elasticloadbalancingv2.AmazonElasticLoadBalancingClient;\n-import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersRequest;\n-import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersResult;\n-import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsRequest;\n-import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsResult;\n-import com.sequenceiq.cloudbreak.service.Retry;\n-\n-public class AmazonElbV2RetryClient extends AmazonRetryClient {\n-\n-    private final AmazonElasticLoadBalancingClient client;\n-\n-    private final Retry retry;\n-\n-    public AmazonElbV2RetryClient(AmazonElasticLoadBalancingClient client, Retry retry) {\n-        this.client = client;\n-        this.retry = retry;\n-    }\n-\n-    public DescribeLoadBalancersResult describeLoadBalancer(DescribeLoadBalancersRequest request) {\n-        return retry.testWith2SecDelayMax15Times(() -> mapThrottlingError(() -> client.describeLoadBalancers(request)));\n-    }\n-\n-    public DescribeTargetGroupsResult describeLoadBalancer(DescribeTargetGroupsRequest request) {\n-        return retry.testWith2SecDelayMax15Times(() -> mapThrottlingError(() -> client.describeTargetGroups(request)));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMTU1NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530021554", "bodyText": "Should be named describeTargetGroups()", "author": "enis", "createdAt": "2020-11-25T00:00:59Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.client;\n+\n+import com.amazonaws.services.elasticloadbalancingv2.AmazonElasticLoadBalancingClient;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersResult;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsResult;\n+import com.sequenceiq.cloudbreak.service.Retry;\n+\n+public class AmazonElbV2RetryClient extends AmazonRetryClient {\n+\n+    private final AmazonElasticLoadBalancingClient client;\n+\n+    private final Retry retry;\n+\n+    public AmazonElbV2RetryClient(AmazonElasticLoadBalancingClient client, Retry retry) {\n+        this.client = client;\n+        this.retry = retry;\n+    }\n+\n+    public DescribeLoadBalancersResult describeLoadBalancer(DescribeLoadBalancersRequest request) {\n+        return retry.testWith2SecDelayMax15Times(() -> mapThrottlingError(() -> client.describeLoadBalancers(request)));\n+    }\n+\n+    public DescribeTargetGroupsResult describeLoadBalancer(DescribeTargetGroupsRequest request) {", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java\ndeleted file mode 100644\nindex 4f6045f06a..0000000000\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java\n+++ /dev/null\n\n@@ -1,28 +0,0 @@\n-package com.sequenceiq.cloudbreak.cloud.aws.client;\n-\n-import com.amazonaws.services.elasticloadbalancingv2.AmazonElasticLoadBalancingClient;\n-import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersRequest;\n-import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersResult;\n-import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsRequest;\n-import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsResult;\n-import com.sequenceiq.cloudbreak.service.Retry;\n-\n-public class AmazonElbV2RetryClient extends AmazonRetryClient {\n-\n-    private final AmazonElasticLoadBalancingClient client;\n-\n-    private final Retry retry;\n-\n-    public AmazonElbV2RetryClient(AmazonElasticLoadBalancingClient client, Retry retry) {\n-        this.client = client;\n-        this.retry = retry;\n-    }\n-\n-    public DescribeLoadBalancersResult describeLoadBalancer(DescribeLoadBalancersRequest request) {\n-        return retry.testWith2SecDelayMax15Times(() -> mapThrottlingError(() -> client.describeLoadBalancers(request)));\n-    }\n-\n-    public DescribeTargetGroupsResult describeLoadBalancer(DescribeTargetGroupsRequest request) {\n-        return retry.testWith2SecDelayMax15Times(() -> mapThrottlingError(() -> client.describeTargetGroups(request)));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNjg2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530026867", "bodyText": "some of these exist already in the scope  in the above call to this function. Maybe you can look at sending these to the function rather than recreating.", "author": "enis", "createdAt": "2020-11-25T00:17:11Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +165,132 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\nindex 80cbdafbda..6e3d4b9d5a 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\n\n@@ -163,20 +164,16 @@ public class AwsLaunchService {\n \n         awsTaggingService.tagRootVolumes(ac, amazonEC2Client, instances, stack.getTags());\n \n-        awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n+        awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, regionName, credentialView);\n \n-        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+        updateCloudformationWithLoadBalancers(ac, stack, resourceNotifier, modelContext, instances, regionName,\n+            amazonEC2Client, network, awsNetworkView, mapPublicIpOnLaunch);\n \n         return awsResourceConnector.check(ac, instances);\n     }\n \n-    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n-        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n-        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n-        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n-        Network network = stack.getNetwork();\n-        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n-        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            String regionName, AmazonEC2Client amazonEC2Client, Network network, AwsNetworkView awsNetworkView, boolean mapPublicIpOnLaunch) {\n \n         boolean existingVPC = awsNetworkView.isExistingVPC();\n         boolean existingSubnet = awsNetworkView.isExistingSubnet();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNzExNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530027114", "bodyText": "nit: rename to updateCloudformationWithLoadBalancers()?", "author": "enis", "createdAt": "2020-11-25T00:17:56Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +165,132 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\nindex 80cbdafbda..6e3d4b9d5a 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\n\n@@ -163,20 +164,16 @@ public class AwsLaunchService {\n \n         awsTaggingService.tagRootVolumes(ac, amazonEC2Client, instances, stack.getTags());\n \n-        awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n+        awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, regionName, credentialView);\n \n-        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+        updateCloudformationWithLoadBalancers(ac, stack, resourceNotifier, modelContext, instances, regionName,\n+            amazonEC2Client, network, awsNetworkView, mapPublicIpOnLaunch);\n \n         return awsResourceConnector.check(ac, instances);\n     }\n \n-    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n-        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n-        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n-        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n-        Network network = stack.getNetwork();\n-        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n-        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            String regionName, AmazonEC2Client amazonEC2Client, Network network, AwsNetworkView awsNetworkView, boolean mapPublicIpOnLaunch) {\n \n         boolean existingVPC = awsNetworkView.isExistingVPC();\n         boolean existingSubnet = awsNetworkView.isExistingSubnet();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyOTUzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530029538", "bodyText": "Is this logic mimicing an existing behaviour? maybe you can make a comment here about what CIDR we chose and how.", "author": "enis", "createdAt": "2020-11-25T00:25:20Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +165,132 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            ModelContext modelContext, List<CloudResource> instances) {\n+\n+        List<CloudLoadBalancer> cloudLoadBalancers = stack.getLoadBalancers();\n+        if (!cloudLoadBalancers.isEmpty()) {\n+            if (modelContext == null) {\n+                modelContext = buildDefaultModelContext(ac, stack, resourceNotifier);\n+            }\n+\n+            List<AwsLoadBalancer> awsLoadBalancers = new ArrayList<>();\n+            for (CloudLoadBalancer cloudLoadBalancer : cloudLoadBalancers) {\n+                awsLoadBalancers.add(convert(cloudLoadBalancer, stack, instances));\n+            }\n+\n+            modelContext.withLoadBalancers(awsLoadBalancers);\n+            ListStackResourcesResult result = updateCloudFormationStack(ac, stack, modelContext);\n+\n+            for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n+                for (AwsListener listener : loadBalancer.getListeners()) {\n+                    for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n+                        Optional<StackResourceSummary> targetGroupSummary = result.getStackResourceSummaries().stream()\n+                            .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                            .findFirst();\n+                        if (targetGroupSummary.isEmpty()) {\n+                            throw new CloudConnectorException(\"Could not create load balancer listeners: target group not found.\");\n+                        }\n+                        targetGroup.setArn(targetGroupSummary.get().getPhysicalResourceId());\n+                    }\n+                }\n+                Optional<StackResourceSummary> loadBalancerSummary = result.getStackResourceSummaries().stream()\n+                    .filter(stackResourceSummary -> loadBalancer.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                    .findFirst();\n+                if (loadBalancerSummary.isEmpty()) {\n+                    throw new CloudConnectorException(\"Could not create load balancer listeners: load balancer not found.\");\n+                }\n+                loadBalancer.setArn(loadBalancerSummary.get().getPhysicalResourceId());\n+                loadBalancer.canCreateListeners();\n+            }\n+\n+            updateCloudFormationStack(ac, stack, modelContext);\n+        }\n+    }\n+\n+    private AwsLoadBalancer convert(CloudLoadBalancer cloudLoadBalancer, CloudStack stack, List<CloudResource> instances) {\n+        int order = 1;\n+        List<AwsListener> awsListeners = new ArrayList<>();\n+        AwsLoadBalancerScheme scheme = AwsLoadBalancerScheme.valueOf(cloudLoadBalancer.getType().name());\n+        for (Map.Entry<Integer, Set<Group>> entry : cloudLoadBalancer.getPortToTargetGroupMapping().entrySet()) {\n+            List<CloudResource> lbTargetInstances = instances.stream()\n+                .filter(instance -> entry.getValue().stream().anyMatch(tg -> tg.getName().equals(instance.getGroup())))\n+                .collect(Collectors.toList());\n+            List<String> instanceIds = lbTargetInstances.stream().map(CloudResource::getInstanceId).collect(Collectors.toList());\n+\n+            AwsTargetGroup targetGroup = new AwsTargetGroup(entry.getKey(), scheme, order++, instanceIds);\n+            awsListeners.add(new AwsListener(entry.getKey(), Collections.singletonList(targetGroup), scheme));\n+        }\n+        return new AwsLoadBalancer(scheme, awsListeners);\n+    }\n+\n+    private ListStackResourcesResult updateCloudFormationStack(AuthenticatedContext ac, CloudStack stack, ModelContext modelContext) {\n+        String cFStackName = cfStackUtil.getCfStackName(ac);\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonCloudFormationRetryClient cfRetryClient = awsClient.createCloudFormationRetryClient(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY5MzIwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532693204", "bodyText": "This is the logic that already existed, just moved to a new method. Since I didn't wrote it myself I'm not exactly sure how the logic of it works.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyOTUzOA=="}], "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\nindex 80cbdafbda..6e3d4b9d5a 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java\n\n@@ -163,20 +164,16 @@ public class AwsLaunchService {\n \n         awsTaggingService.tagRootVolumes(ac, amazonEC2Client, instances, stack.getTags());\n \n-        awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n+        awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, regionName, credentialView);\n \n-        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+        updateCloudformationWithLoadBalancers(ac, stack, resourceNotifier, modelContext, instances, regionName,\n+            amazonEC2Client, network, awsNetworkView, mapPublicIpOnLaunch);\n \n         return awsResourceConnector.check(ac, instances);\n     }\n \n-    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n-        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n-        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n-        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n-        Network network = stack.getNetwork();\n-        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n-        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            String regionName, AmazonEC2Client amazonEC2Client, Network network, AwsNetworkView awsNetworkView, boolean mapPublicIpOnLaunch) {\n \n         boolean existingVPC = awsNetworkView.isExistingVPC();\n         boolean existingSubnet = awsNetworkView.isExistingSubnet();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDQyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530030421", "bodyText": "isStackDeleted is also using waiters and retry / polling logic. Are we using double layer of retry intentionally?", "author": "enis", "createdAt": "2020-11-25T00:27:28Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsTerminateService.java", "diffHunk": "@@ -112,12 +112,9 @@ private void waitAndDeleteCloudformationStack(AuthenticatedContext ac, CloudStac\n         resumeAutoScalingPolicies(ac, stack);\n         LOGGER.debug(\"Delete cloudformation stack from resources\");\n         DeleteStackRequest deleteStackRequest = new DeleteStackRequest().withStackName(cFStackName);\n-        cfRetryClient.deleteStack(deleteStackRequest);\n-        Waiter<DescribeStacksRequest> stackDeleteCompleteWaiter = amazonCloudFormationClient.waiters().stackDeleteComplete();\n         try {\n-            WaiterParameters<DescribeStacksRequest> describeStacksRequestWaiterParameters = new WaiterParameters<>(describeStacksRequest)\n-                    .withPollingStrategy(getBackoffCancellablePollingStrategy(null));\n-            stackDeleteCompleteWaiter.run(describeStacksRequestWaiterParameters);\n+            retryService.testWith2SecDelayMax5Times(() -> isStackDeleted(cfRetryClient, amazonCloudFormationClient,", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY5NjYxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532696617", "bodyText": "It was intentional, yes. There are two things being retried. The cfRetryClient.deleteStack method is retrying the initiation of the request; if the initial request is rejected or fails immediately, it will retry up to 15 time to initiate it again. However, once it's successfully initiated, that retry is complete and there's nothing left to do. The purpose of the isStackDeleted method is to check the final state of the deletion, and allow us to retry if the final state is a failure. So one retry checks initialization state, and one checks the final state.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4OTQ3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535389479", "bodyText": "Talked this out with Tamas and added additional logging messages to make the logic of this section more cler.", "author": "hreeve-cloudera", "createdAt": "2020-12-03T16:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDQyMQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDg4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530030888", "bodyText": "great.", "author": "enis", "createdAt": "2020-11-25T00:28:57Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsListener.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsListener {\n+\n+    private static final String LISTENER_NAME_PREFIX = \"ListenerPort\";\n+\n+    private final int port;\n+\n+    private final List<AwsTargetGroup> targetGroups;\n+\n+    private final String name;\n+\n+    public AwsListener(int port, List<AwsTargetGroup> targetGroups, AwsLoadBalancerScheme scheme) {\n+        this.port = port;\n+        this.targetGroups = targetGroups;\n+        this.name = getListenerName(port, scheme);\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public List<AwsTargetGroup> getTargetGroups() {\n+        return targetGroups;\n+    }\n+\n+    public boolean areTargetGroupArnsSet() {\n+        return targetGroups.stream().noneMatch(t -> t.getArn() == null || t.getArn().isEmpty());\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    private static String getListenerName(int port, AwsLoadBalancerScheme scheme) {\n+        return LISTENER_NAME_PREFIX + port +", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTEwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530031109", "bodyText": "nit: shouldCreateListeners()", "author": "enis", "createdAt": "2020-11-25T00:29:35Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsLoadBalancer {\n+\n+    private static final String LOAD_BALANCER_NAME_PREFIX = \"LoadBalancer\";\n+\n+    private final AwsLoadBalancerScheme scheme;\n+\n+    private final String awsScheme;\n+\n+    private final List<AwsListener> listeners;\n+\n+    private final String name;\n+\n+    private String arn;\n+\n+    private boolean createListeners;\n+\n+    public AwsLoadBalancer(AwsLoadBalancerScheme scheme, List<AwsListener> listeners) {\n+        this.scheme = scheme;\n+        this.awsScheme = scheme.awsScheme();\n+        this.listeners = listeners;\n+        this.name = getLoadBalancerName(scheme);\n+        this.createListeners = false;\n+    }\n+\n+    public AwsLoadBalancerScheme getScheme() {\n+        return scheme;\n+    }\n+\n+    public List<AwsListener> getListeners() {\n+        return listeners;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getArn() {\n+        return arn;\n+    }\n+\n+    public void setArn(String arn) {\n+        this.arn = arn;\n+    }\n+\n+    public String getAwsScheme() {\n+        return awsScheme;\n+    }\n+\n+    public boolean isCreateListeners() {", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwMTI0MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532701240", "bodyText": "I can't actually change this getter name, because the template files fetch the class members using standardized getter names. If you use anything else, it can't fetch the value properly and the template won't be filled out.\nHowever, I did change it from createListeners to listenerConfigSet, so the method name sounds nicer.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTEwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java\nindex c1a19b245f..e68a19342a 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java\n\n@@ -18,14 +18,14 @@ public class AwsLoadBalancer {\n \n     private String arn;\n \n-    private boolean createListeners;\n+    private boolean listenerConfigSet;\n \n     public AwsLoadBalancer(AwsLoadBalancerScheme scheme, List<AwsListener> listeners) {\n         this.scheme = scheme;\n         this.awsScheme = scheme.awsScheme();\n         this.listeners = listeners;\n         this.name = getLoadBalancerName(scheme);\n-        this.createListeners = false;\n+        this.listenerConfigSet = false;\n     }\n \n     public AwsLoadBalancerScheme getScheme() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTM2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530031364", "bodyText": "This does not seem to be used.", "author": "enis", "createdAt": "2020-11-25T00:30:22Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsLoadBalancer {\n+\n+    private static final String LOAD_BALANCER_NAME_PREFIX = \"LoadBalancer\";\n+\n+    private final AwsLoadBalancerScheme scheme;\n+\n+    private final String awsScheme;\n+\n+    private final List<AwsListener> listeners;\n+\n+    private final String name;\n+\n+    private String arn;\n+\n+    private boolean createListeners;", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwMjczNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532702734", "bodyText": "It's used by the template files. See https://github.com/hortonworks/cloudbreak/pull/9475/files#diff-5b1a3ad86915b768282779a97322c280afd84febb377b395e1d274fbdebef237R288", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTM2NA=="}], "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java\nindex c1a19b245f..e68a19342a 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java\n\n@@ -18,14 +18,14 @@ public class AwsLoadBalancer {\n \n     private String arn;\n \n-    private boolean createListeners;\n+    private boolean listenerConfigSet;\n \n     public AwsLoadBalancer(AwsLoadBalancerScheme scheme, List<AwsListener> listeners) {\n         this.scheme = scheme;\n         this.awsScheme = scheme.awsScheme();\n         this.listeners = listeners;\n         this.name = getLoadBalancerName(scheme);\n-        this.createListeners = false;\n+        this.listenerConfigSet = false;\n     }\n \n     public AwsLoadBalancerScheme getScheme() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTU5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530031593", "bodyText": "I think this should match AWS's terminology.\nINTERNET_FACING(\"internet-facing\")\nINTERNAL(\"internal\")", "author": "enis", "createdAt": "2020-11-25T00:31:03Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancerScheme.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+public enum AwsLoadBalancerScheme {\n+    PUBLIC(\"internet-facing\"),", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwNDA0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532704046", "bodyText": "The purpose of using PUBLIC/PRIVATE here is so we can convert between the LoadBalalncerType class and this class. You can see this use in AwsLaunchService:\nAwsLoadBalancerScheme scheme = AwsLoadBalancerScheme.valueOf(cloudLoadBalancer.getType().name());", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTU5Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MjQ5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530042490", "bodyText": "maybe debug level?", "author": "enis", "createdAt": "2020-11-25T01:05:51Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\nindex c0dd8a7d99..d7741bd5ec 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n\n@@ -38,7 +38,7 @@ public class LoadBalancerConfigService {\n         if (cluster != null) {\n             CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n             Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();\n-            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            LOGGER.debug(\"Checking if Knox gateway is explicitly defined\");\n             groupNames = componentByHostGroup.entrySet().stream()\n                 .filter(entry -> isKnoxGatewayDefinedInServices(entry.getValue()))\n                 .map(Map.Entry::getKey)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0Mjk4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530042982", "bodyText": "I think the convention we should use is to follow AWS terminology. internet-facing load balancers do not have an \"external\" suffix, but internal load balancers have and \"-internal\" suffix.", "author": "enis", "createdAt": "2020-11-25T01:07:33Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwODA4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532708083", "bodyText": "I'm going to copy this comment to CB-9900. External subnets aren't going to be incorporated until that's done, so we can look at the naming then.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T16:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0Mjk4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\nindex c0dd8a7d99..d7741bd5ec 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n\n@@ -38,7 +38,7 @@ public class LoadBalancerConfigService {\n         if (cluster != null) {\n             CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n             Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();\n-            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            LOGGER.debug(\"Checking if Knox gateway is explicitly defined\");\n             groupNames = componentByHostGroup.entrySet().stream()\n                 .filter(entry -> isKnoxGatewayDefinedInServices(entry.getValue()))\n                 .map(Map.Entry::getKey)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MzE3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530043175", "bodyText": "is this the full stack name, or just the shortened one?", "author": "enis", "createdAt": "2020-11-25T01:08:16Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = componentByHostGroup.entrySet().stream()\n+                .filter(entry -> isKnoxGatewayDefinedInServices(entry.getValue()))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    private boolean isKnoxGatewayDefinedInServices(Set<ServiceComponent> serviceComponents) {\n+        return serviceComponents.stream()\n+            .anyMatch(serviceComponent -> KnoxRoles.KNOX_GATEWAY.equals(serviceComponent.getComponent()));\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        StringBuilder name = new StringBuilder()\n+            .append(stack.getName())", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwOTgwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532709809", "bodyText": "The shortened one. So if I name my datalake hreeve-cloudbreak-dl, that would be the stack name here, and the endpoint would be hreeve-cloudbreak-dl-gateway.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T16:04:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MzE3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\nindex c0dd8a7d99..d7741bd5ec 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n\n@@ -38,7 +38,7 @@ public class LoadBalancerConfigService {\n         if (cluster != null) {\n             CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n             Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();\n-            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            LOGGER.debug(\"Checking if Knox gateway is explicitly defined\");\n             groupNames = componentByHostGroup.entrySet().stream()\n                 .filter(entry -> isKnoxGatewayDefinedInServices(entry.getValue()))\n                 .map(Map.Entry::getKey)\n"}}, {"oid": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "url": "https://github.com/hortonworks/cloudbreak/commit/d9d43318f7d259946ff4c23f16bb184a1ea58424", "message": "Additional review comments and rebase.", "committedDate": "2020-11-30T19:12:39Z", "type": "forcePushed"}, {"oid": "38ef8055c8d7bdf17068665196206f3622b9a3bd", "url": "https://github.com/hortonworks/cloudbreak/commit/38ef8055c8d7bdf17068665196206f3622b9a3bd", "message": "Additional review comments and rebase.", "committedDate": "2020-11-30T20:37:55Z", "type": "forcePushed"}, {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "url": "https://github.com/hortonworks/cloudbreak/commit/91252020ce85e0bf097c4fcba5073697e46aa7e7", "message": "Defaulting mock entitlement to false and rebasing from master.", "committedDate": "2020-12-02T16:35:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NTY5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534495696", "bodyText": "This method should not be created as getGatewayInstanceMetadata or getPrimaryGatewayInstance could be used to do the same and I checked in IDEA it hasn't even used anywhere on this branch.", "author": "biharitomi", "createdAt": "2020-12-02T21:33:35Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java", "diffHunk": "@@ -574,6 +579,15 @@ public InstanceMetaData getPrimaryGatewayInstance() {\n         return metaData.orElse(null);\n     }\n \n+    public InstanceGroup getGatewayGroup() {", "originalCommit": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5MTM3Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535391372", "bodyText": "This method has been deleted. Thanks for the catch!", "author": "hreeve-cloudera", "createdAt": "2020-12-03T16:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NTY5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "chunk": "diff --git a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java\nindex aad82f6f53..2cd7948280 100644\n--- a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java\n+++ b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java\n\n@@ -579,15 +579,6 @@ public class Stack implements ProvisionEntity, WorkspaceAwareResource {\n         return metaData.orElse(null);\n     }\n \n-    public InstanceGroup getGatewayGroup() {\n-        for (InstanceGroup instanceGroup : instanceGroups) {\n-            if (InstanceGroupType.GATEWAY.equals(instanceGroup.getInstanceGroupType())) {\n-                return instanceGroup;\n-            }\n-        }\n-        return null;\n-    }\n-\n     public Network getNetwork() {\n         return network;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTE2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534501161", "bodyText": "The TargetGroupType enum could be used here and the values of the field would be more straightforward. CB has an enum converter logic which handles the conversion from enum to string and vice versa.\nAn example could be: com.sequenceiq.environment.parameters.dao.converter.CredentialTypeConverter", "author": "biharitomi", "createdAt": "2020-12-02T21:43:49Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import java.util.Set;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+\n+@Entity\n+public class TargetGroup implements ProvisionEntity {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"targetgroup_generator\")\n+    @SequenceGenerator(name = \"targetgroup_generator\", sequenceName = \"targetgroup_id_seq\", allocationSize = 1)\n+    private Long id;\n+\n+    private String type;", "originalCommit": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ1OTM2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535459367", "bodyText": "Done", "author": "hreeve-cloudera", "createdAt": "2020-12-03T18:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTE2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "chunk": "diff --git a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java\nindex 5d44d74b23..5f2436ee77 100644\n--- a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java\n+++ b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java\n\n@@ -1,8 +1,8 @@\n package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n \n-import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n import java.util.Set;\n \n+import javax.persistence.Convert;\n import javax.persistence.Entity;\n import javax.persistence.FetchType;\n import javax.persistence.GeneratedValue;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTcwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534501704", "bodyText": "The LoadBalancerType enum could be used here and the values of the field would be more straightforward. CB has an enum converter logic which handles the conversion from enum to string and vice versa.\nAn example could be: com.sequenceiq.environment.parameters.dao.converter.CredentialTypeConverter", "author": "biharitomi", "createdAt": "2020-12-02T21:44:45Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+\n+@Entity\n+public class LoadBalancer implements ProvisionEntity  {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"loadbalancer_generator\")\n+    @SequenceGenerator(name = \"loadbalancer_generator\", sequenceName = \"loadbalancer_id_seq\", allocationSize = 1)\n+    private Long id;\n+\n+    @ManyToOne\n+    private Stack stack;\n+\n+    private String dns;\n+\n+    private String hostedZoneId;\n+\n+    private String ip;\n+\n+    private String type;", "originalCommit": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ1OTI5NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535459295", "bodyText": "Done", "author": "hreeve-cloudera", "createdAt": "2020-12-03T18:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTcwNA=="}], "type": "inlineReview", "revised_code": {"commit": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "chunk": "diff --git a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java\nindex 95af1e12d2..48b1340671 100644\n--- a/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java\n+++ b/core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java\n\n@@ -4,6 +4,7 @@ import java.util.HashSet;\n import java.util.Set;\n \n import javax.persistence.CascadeType;\n+import javax.persistence.Convert;\n import javax.persistence.Entity;\n import javax.persistence.GeneratedValue;\n import javax.persistence.GenerationType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwOTI4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534509286", "bodyText": "Instead of this call and the next lambda filter the com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor#getHostGroupsWithComponent method could be used.", "author": "biharitomi", "createdAt": "2020-12-02T21:58:31Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();", "originalCommit": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ1OTIxNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535459215", "bodyText": "Well that's much easier. :)", "author": "hreeve-cloudera", "createdAt": "2020-12-03T18:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwOTI4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\nindex d7741bd5ec..41c1208e96 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java\n\n@@ -1,9 +1,7 @@\n package com.sequenceiq.cloudbreak.service;\n \n-import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n import java.util.Collections;\n import java.util.HashSet;\n-import java.util.Map;\n import java.util.Set;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMDk0OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534510948", "bodyText": "Using if-else instead of if-continue?", "author": "biharitomi", "createdAt": "2020-12-02T22:01:13Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/GatewayPublicEndpointManagementService.java", "diffHunk": "@@ -92,6 +101,41 @@ public String updateDnsEntry(Stack stack, String gatewayIp) {\n         return null;\n     }\n \n+    public void updateDnsEntryForLoadBalancers(Stack stack) {\n+        Set<LoadBalancer> loadBalancers = loadBalancerPersistenceService.findByStackId(stack.getId());\n+        if (loadBalancers.isEmpty()) {\n+            LOGGER.info(\"No load balancers in stack {}\", stack.getId());\n+            return;\n+        }\n+\n+        LOGGER.info(\"Update load balancer DNS entries\");\n+        String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n+        String accountId = ThreadBasedUserCrnProvider.getAccountId();\n+        DetailedEnvironmentResponse environment = environmentClientService.getByCrn(stack.getEnvironmentCrn());\n+\n+        for (LoadBalancer loadBalancer : loadBalancers) {\n+            Optional<String> endpoint = Optional.ofNullable(loadBalancer.getEndpoint());\n+            if (endpoint.isEmpty()) {\n+                LOGGER.error(\"No endpoint set for load balancer. Can't register domain.\");\n+                continue;", "originalCommit": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ1OTExNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535459114", "bodyText": "Done", "author": "hreeve-cloudera", "createdAt": "2020-12-03T18:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMDk0OA=="}], "type": "inlineReview", "revised_code": {"commit": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/GatewayPublicEndpointManagementService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/GatewayPublicEndpointManagementService.java\nindex 51440cbecb..c60c970711 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/GatewayPublicEndpointManagementService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/GatewayPublicEndpointManagementService.java\n\n@@ -117,21 +117,21 @@ public class GatewayPublicEndpointManagementService extends BasePublicEndpointMa\n             Optional<String> endpoint = Optional.ofNullable(loadBalancer.getEndpoint());\n             if (endpoint.isEmpty()) {\n                 LOGGER.error(\"No endpoint set for load balancer. Can't register domain.\");\n-                continue;\n-            }\n-            if (loadBalancer.getDns() != null && loadBalancer.getHostedZoneId() != null) {\n-                LOGGER.info(\"Creating load balancer DNS entry with endpoint name: '{}', environment name: '{}' and cloud DNS: '{}'\",\n-                    endpoint.get(), environment.getName(), loadBalancer.getDns());\n-                getDnsManagementService().createOrUpdateDnsEntryWithCloudDns(userCrn, accountId, endpoint.get(),\n-                    environment.getName(), loadBalancer.getDns(), loadBalancer.getHostedZoneId());\n-            } else if (loadBalancer.getIp() != null) {\n-                LOGGER.info(\"Creating load balancer DNS entry with endpoint name: '{}', environment name: '{}' and IP: '{}'\",\n-                    endpoint.get(), environment.getName(), loadBalancer.getIp());\n-                getDnsManagementService().createOrUpdateDnsEntryWithIp(userCrn, accountId, endpoint.get(),\n-                    environment.getName(), false, List.of(loadBalancer.getIp()));\n             } else {\n-                LOGGER.warn(\"Could not find IP or cloud DNS info for load balancer with endpoint {} .\" +\n-                    \"DNS registration will be skipped.\", loadBalancer.getEndpoint());\n+                if (loadBalancer.getDns() != null && loadBalancer.getHostedZoneId() != null) {\n+                    LOGGER.info(\"Creating load balancer DNS entry with endpoint name: '{}', environment name: '{}' and cloud DNS: '{}'\",\n+                        endpoint.get(), environment.getName(), loadBalancer.getDns());\n+                    getDnsManagementService().createOrUpdateDnsEntryWithCloudDns(userCrn, accountId, endpoint.get(),\n+                        environment.getName(), loadBalancer.getDns(), loadBalancer.getHostedZoneId());\n+                } else if (loadBalancer.getIp() != null) {\n+                    LOGGER.info(\"Creating load balancer DNS entry with endpoint name: '{}', environment name: '{}' and IP: '{}'\",\n+                        endpoint.get(), environment.getName(), loadBalancer.getIp());\n+                    getDnsManagementService().createOrUpdateDnsEntryWithIp(userCrn, accountId, endpoint.get(),\n+                        environment.getName(), false, List.of(loadBalancer.getIp()));\n+                } else {\n+                    LOGGER.warn(\"Could not find IP or cloud DNS info for load balancer with endpoint {} .\" +\n+                        \"DNS registration will be skipped.\", loadBalancer.getEndpoint());\n+                }\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMjM2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534512365", "bodyText": "No, https://github.com/hortonworks/cloudbreak/pull/9475/files#diff-7d0c14c28466a6ed89a04d3cc0a6c5973f30325dab017a4093173af0145e77dbR35 will do the job.", "author": "biharitomi", "createdAt": "2020-12-02T22:04:01Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/dns/BaseDnsEntryService.java", "diffHunk": "@@ -101,6 +101,7 @@\n         String accountId = ThreadBasedUserCrnProvider.getAccountId();\n         DetailedEnvironmentResponse environment = environmentClientService.getByCrn(environmentCrn);\n \n+        // TODO do we need to deregister the load balancer DNS here as well?", "originalCommit": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/dns/BaseDnsEntryService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/dns/BaseDnsEntryService.java\nindex 95a3c218be..4bc197daab 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/dns/BaseDnsEntryService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/dns/BaseDnsEntryService.java\n\n@@ -101,7 +101,6 @@ public abstract class BaseDnsEntryService extends BasePublicEndpointManagementSe\n         String accountId = ThreadBasedUserCrnProvider.getAccountId();\n         DetailedEnvironmentResponse environment = environmentClientService.getByCrn(environmentCrn);\n \n-        // TODO do we need to deregister the load balancer DNS here as well?\n         return ipsByFqdn\n                 .entrySet()\n                 .stream()\n"}}, {"oid": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "url": "https://github.com/hortonworks/cloudbreak/commit/33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "message": "CB-9241 Create an AWS load balancer in front of Knox on the data lake\n\nThis change adds a load balancer to the data lake that sits in front of Knox.\nIt is configured automatically during data lake creation for AWS environments.\nThis functionality is currently behind the CDP_DATA_LAKE_LOAD_BALANCER\nentitlement.\n\nThe load balancer is modeled in CB by having a series of targetGroups, which\ninclude the type of target (in this commit, only KNOX targets are supported),\nthe port to route data to, and links to the instance groups where the service\nruns. The load balancer will receive traffic on the defined port, and route it\nto the same port on the appropriate instances. The load balancer is created\nautomatically in front of all data lake that have a Knox gateway. If PEM is\nenabled, it is given a DNS entry under the endpoint \"<datalake name>-gateway\".\n\nThis change was tested with unit tests, and by running the Cloudbreak service\nlocally and verifying: 1) the LB is created in AWS, 2) the LB is configured\nwith the appropriate instance information, and 3) accessing the LB endpoint\ncorrectly routes the traffic to Knox.", "committedDate": "2020-12-03T17:49:16Z", "type": "commit"}, {"oid": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "url": "https://github.com/hortonworks/cloudbreak/commit/33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "message": "CB-9241 Create an AWS load balancer in front of Knox on the data lake\n\nThis change adds a load balancer to the data lake that sits in front of Knox.\nIt is configured automatically during data lake creation for AWS environments.\nThis functionality is currently behind the CDP_DATA_LAKE_LOAD_BALANCER\nentitlement.\n\nThe load balancer is modeled in CB by having a series of targetGroups, which\ninclude the type of target (in this commit, only KNOX targets are supported),\nthe port to route data to, and links to the instance groups where the service\nruns. The load balancer will receive traffic on the defined port, and route it\nto the same port on the appropriate instances. The load balancer is created\nautomatically in front of all data lake that have a Knox gateway. If PEM is\nenabled, it is given a DNS entry under the endpoint \"<datalake name>-gateway\".\n\nThis change was tested with unit tests, and by running the Cloudbreak service\nlocally and verifying: 1) the LB is created in AWS, 2) the LB is configured\nwith the appropriate instance information, and 3) accessing the LB endpoint\ncorrectly routes the traffic to Knox.", "committedDate": "2020-12-03T17:49:16Z", "type": "forcePushed"}]}