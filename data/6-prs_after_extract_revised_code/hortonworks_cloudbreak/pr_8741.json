{"pr_number": 8741, "pr_title": "CB-8328. Implemented service type tagging for DataHub", "pr_createdAt": "2020-08-06T17:02:31Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8741", "timeline": [{"oid": "524a5ef397c86b8574583223aabddd91d0a25f56", "url": "https://github.com/hortonworks/cloudbreak/commit/524a5ef397c86b8574583223aabddd91d0a25f56", "message": "CB-8328. Implemented service type provider interface for DataHub\n\ndetails:\n- add new cluster template related tag with name \"Cloudera-Service-Type\"\n- add a new service type resolver which is called during stack creation from stack request\n- tags can be used by other application in order to use  \"Cloudera-Service-Type\" (as desired service type)\n- sewrvice type resolver contins different ServiceTypeMatcher interfaces - run all custom logic on those\n- service types needs to be validated based on the matchers logic (input is the cmtemplate processor)\n- for adding a new provider -> add a new value for ServiceType enum and provide an implementation for ServiceTypeMatcher", "committedDate": "2020-08-06T17:21:01Z", "type": "forcePushed"}, {"oid": "bb35913e8a08eeaba02eee24fec779c17f680a7e", "url": "https://github.com/hortonworks/cloudbreak/commit/bb35913e8a08eeaba02eee24fec779c17f680a7e", "message": "CB-8328. Implemented service type provider interface for DataHub\n\ndetails:\n- add new cluster template related tag with name \"Cloudera-Service-Type\"\n- add a new service type resolver which is called during stack creation from stack request\n- tags can be used by other application in order to use  \"Cloudera-Service-Type\" (as desired service type)\n- sewrvice type resolver contins different ServiceTypeMatcher interfaces - run all custom logic on those\n- service types needs to be validated based on the matchers logic (input is the cmtemplate processor)\n- for adding a new provider -> add a new value for ServiceType enum and provide an implementation for ServiceTypeMatcher", "committedDate": "2020-08-06T20:21:15Z", "type": "forcePushed"}, {"oid": "ae4e33440085b5b7439d17d0b99e79ac1009d9f3", "url": "https://github.com/hortonworks/cloudbreak/commit/ae4e33440085b5b7439d17d0b99e79ac1009d9f3", "message": "CB-8328. Implemented service type provider interface for DataHub\n\ndetails:\n- add new cluster template related tag with name \"Cloudera-Service-Type\"\n- add a new service type resolver which is called during stack creation from stack request\n- tags can be used by other application in order to use  \"Cloudera-Service-Type\" (as desired service type)\n- sewrvice type resolver contins different ServiceTypeMatcher interfaces - run all custom logic on those\n- service types needs to be validated based on the matchers logic (input is the cmtemplate processor)\n- for adding a new provider -> add a new value for ServiceType enum and provide an implementation for ServiceTypeMatcher", "committedDate": "2020-08-07T07:22:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg3ODg3Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8741#discussion_r466878873", "bodyText": "maybe in case the user could not specify the servicetype then we should check the stack.type. What do you think?", "author": "doktoric", "createdAt": "2020-08-07T07:47:28Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/servicetype/ServiceTypeResolver.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package com.sequenceiq.cloudbreak.cmtemplate.servicetype;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+\n+@Component\n+public class ServiceTypeResolver {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceTypeResolver.class);\n+\n+    private final List<ServiceTypeMatcher> serviceTypeMatchers;\n+\n+    public ServiceTypeResolver(List<ServiceTypeMatcher> serviceTypeMatchers) {\n+        this.serviceTypeMatchers = serviceTypeMatchers;\n+    }\n+\n+    /**\n+     * Run all service type providers, in case of none of them will be applied, the default DATAHUB service type will be used.\n+     * If it will match multiple serviceTypes, that will fall back the default DATAHUB service type.\n+     * If there is a desired service type (provided by an another application) and the result won't be the same that will cause a runtime exception.\n+     * @param cmTemplateProcessor template processor that contains role and configuration data\n+     * @param desiredServiceType desired type service type that is provided by other service\n+     * @return resolved service type for the template\n+     */\n+    public String resolveServiceType(CmTemplateProcessor cmTemplateProcessor, String desiredServiceType) {\n+        Set<ServiceType> serviceTypes = new HashSet<>();\n+        ServiceType result = ServiceType.DATAHUB;\n+        if (StringUtils.isNotBlank(desiredServiceType) && !ServiceType.isValueValid(desiredServiceType)) {\n+            String errorMessage = String.format(\"'%s' is not a valid value for ServiceType enum.\", desiredServiceType);\n+            throw new BadRequestException(errorMessage);\n+        }\n+        if (CollectionUtils.isNotEmpty(serviceTypeMatchers)) {\n+            for (ServiceTypeMatcher serviceTypeMatcher : serviceTypeMatchers) {\n+                if (serviceTypeMatcher.match(cmTemplateProcessor)) {\n+                    serviceTypes.add(serviceTypeMatcher.getServiceType());\n+                }\n+            }\n+        }\n+        serviceTypes.remove(ServiceType.DATAHUB);\n+        if (serviceTypes.size() == 0) {\n+            LOGGER.debug(\"Service type only matched for dummy/default DataHub provider. Default DATAHUB service type will be used.\");\n+        } else if (serviceTypes.size() == 1) {\n+            result = serviceTypes.iterator().next();\n+            LOGGER.debug(\"The following service type will be selected based on the service type providers: {}\", result.value());\n+        } else {\n+            LOGGER.warn(\"You cannot match on multiple service types based on the service type providers. \" +", "originalCommit": "ae4e33440085b5b7439d17d0b99e79ac1009d9f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg4NTIyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8741#discussion_r466885223", "bodyText": "default service type is DATAHUB here, is the same as the stack type (that is not used for DATALAKE). metering v1 event supports only that. better to use that default enum (in case of DATAHUB name will change in the future or something), so i think it should be fine to use the default ServiceType enum instead of the stack type", "author": "oleewere", "createdAt": "2020-08-07T08:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg3ODg3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c4f7e2a6c99fc77b3b4fefbbe5fd47da46f9fd09", "chunk": "diff --git a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/servicetype/ServiceTypeResolver.java b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/servicetype/ServiceTypeResolver.java\nindex b09264e74a..62ff4f1084 100644\n--- a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/servicetype/ServiceTypeResolver.java\n+++ b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/servicetype/ServiceTypeResolver.java\n\n@@ -1,68 +1,90 @@\n package com.sequenceiq.cloudbreak.cmtemplate.servicetype;\n \n-import java.util.HashSet;\n+import java.io.IOException;\n+import java.util.ArrayList;\n import java.util.List;\n import java.util.Set;\n \n-import org.apache.commons.collections.CollectionUtils;\n-import org.apache.commons.lang3.StringUtils;\n+import javax.annotation.PostConstruct;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.core.io.ClassPathResource;\n import org.springframework.stereotype.Component;\n \n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n-import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.cloudbreak.util.FileReaderUtils;\n \n @Component\n public class ServiceTypeResolver {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(ServiceTypeResolver.class);\n \n-    private final List<ServiceTypeMatcher> serviceTypeMatchers;\n+    private static final String DEFAULT_SERVICE_TYPE = \"DATAHUB\";\n+\n+    private final String serviceTypeMapperLocation;\n+\n+    private List<ServiceTypeMapperDefinition> serviceTypeMapperDefinitions;\n \n-    public ServiceTypeResolver(List<ServiceTypeMatcher> serviceTypeMatchers) {\n-        this.serviceTypeMatchers = serviceTypeMatchers;\n+    public ServiceTypeResolver(@Value(\"${cb.cm.service.type.mapper.location:definitions/cm-service-type-mapping.json}\")\n+            String serviceTypeMapperLocation) {\n+        this.serviceTypeMapperLocation = serviceTypeMapperLocation;\n     }\n \n-    /**\n-     * Run all service type providers, in case of none of them will be applied, the default DATAHUB service type will be used.\n-     * If it will match multiple serviceTypes, that will fall back the default DATAHUB service type.\n-     * If there is a desired service type (provided by an another application) and the result won't be the same that will cause a runtime exception.\n+    /**.\n+     * Check that which service type should be used based on the CM template and a service type mapping definition file\n+     * At the moment it only do checks against services. In case of more specific requirements, this can be extended with\n+     * roles and configuration checks as well.\n      * @param cmTemplateProcessor template processor that contains role and configuration data\n-     * @param desiredServiceType desired type service type that is provided by other service\n      * @return resolved service type for the template\n      */\n-    public String resolveServiceType(CmTemplateProcessor cmTemplateProcessor, String desiredServiceType) {\n-        Set<ServiceType> serviceTypes = new HashSet<>();\n-        ServiceType result = ServiceType.DATAHUB;\n-        if (StringUtils.isNotBlank(desiredServiceType) && !ServiceType.isValueValid(desiredServiceType)) {\n-            String errorMessage = String.format(\"'%s' is not a valid value for ServiceType enum.\", desiredServiceType);\n-            throw new BadRequestException(errorMessage);\n-        }\n-        if (CollectionUtils.isNotEmpty(serviceTypeMatchers)) {\n-            for (ServiceTypeMatcher serviceTypeMatcher : serviceTypeMatchers) {\n-                if (serviceTypeMatcher.match(cmTemplateProcessor)) {\n-                    serviceTypes.add(serviceTypeMatcher.getServiceType());\n-                }\n-            }\n+    public String resolveServiceType(CmTemplateProcessor cmTemplateProcessor) {\n+        LOGGER.debug(\"Service type needs to be calculated as no provided application tag for it\");\n+        Set<ServiceComponent> serviceComponents = cmTemplateProcessor.getAllComponents();\n+        String result = this.serviceTypeMapperDefinitions\n+                .stream()\n+                .filter(serviceTypeMapperDefinition ->\n+                    serviceTypeMapperDefinition\n+                            .getRelatedServices()\n+                            .stream()\n+                            .allMatch(relatedService -> containsService(serviceComponents, relatedService))\n+                )\n+                .findFirst()\n+                .map(ServiceTypeMapperDefinition::getType)\n+                .orElse(DEFAULT_SERVICE_TYPE);\n+        LOGGER.debug(\"The resolved service type: {}\", result);\n+        return result;\n+    }\n+\n+    private boolean containsService(Set<ServiceComponent> serviceComponents, String service){\n+        return serviceComponents.stream().map(ServiceComponent::getService).anyMatch(service::equals);\n+    }\n+\n+    @PostConstruct\n+    public void init() {\n+        try {\n+            this.serviceTypeMapperDefinitions = loadServiceTypeDefinitions();\n+        } catch (IOException e) {\n+            LOGGER.warn(\"Static VM Log descriptors could not be initialized!\", e);\n         }\n-        serviceTypes.remove(ServiceType.DATAHUB);\n-        if (serviceTypes.size() == 0) {\n-            LOGGER.debug(\"Service type only matched for dummy/default DataHub provider. Default DATAHUB service type will be used.\");\n-        } else if (serviceTypes.size() == 1) {\n-            result = serviceTypes.iterator().next();\n-            LOGGER.debug(\"The following service type will be selected based on the service type providers: {}\", result.value());\n+    }\n+\n+    private List<ServiceTypeMapperDefinition> loadServiceTypeDefinitions() throws IOException {\n+        ClassPathResource classPathResource = new ClassPathResource(serviceTypeMapperLocation);\n+        if (classPathResource.exists()) {\n+            String json = FileReaderUtils.readFileFromClasspath(serviceTypeMapperLocation);\n+            ObjectMapper mapper = new ObjectMapper();\n+            return mapper.readValue(json, new TypeReference<>() {\n+            });\n         } else {\n-            LOGGER.warn(\"You cannot match on multiple service types based on the service type providers. \" +\n-                    \"Match on the following service types: {}, falling back to the default (DATAHUB) service type\",\n-                    StringUtils.join(serviceTypes, \",\"));\n-        }\n-        if (StringUtils.isNotBlank(desiredServiceType) && !result.value().equalsIgnoreCase(desiredServiceType)) {\n-            String errorMessage = String.format(\"Calculated service type is %s, desired service type was: %s\",\n-                    result.value(), desiredServiceType);\n-            throw new BadRequestException(errorMessage);\n+            LOGGER.debug(\"{} was not loaded successfully as thr definition file does not exist. \" +\n+                    \"Service type mapper definitions won't be used\", serviceTypeMapperLocation);\n+            return new ArrayList<>();\n         }\n-        return result.value();\n     }\n \n }\n"}}, {"oid": "c4f7e2a6c99fc77b3b4fefbbe5fd47da46f9fd09", "url": "https://github.com/hortonworks/cloudbreak/commit/c4f7e2a6c99fc77b3b4fefbbe5fd47da46f9fd09", "message": "CB-8328. Implemented service type provider interface for DataHub\n\ndetails:\n- add new cluster template related tag with name \"Cloudera-Service-Type\"\n- add a new service type resolver which is called during stack creation from stack request\n- service resolver will use a static json template where we can determine which service type should be used (based on only services for now, can be extended component/configurations later, but only if that will be needed)\n- service type resolver only called if no provided application tag\n- if application tag is not provided, the result service type from service type resolver will be used as the application tag, therefore we will have the information in the api response", "committedDate": "2020-08-07T11:15:18Z", "type": "forcePushed"}, {"oid": "2674138f06b9735a8ead6200914f9943c22de14f", "url": "https://github.com/hortonworks/cloudbreak/commit/2674138f06b9735a8ead6200914f9943c22de14f", "message": "CB-8328. Implemented service type provider interface for DataHub\n\ndetails:\n- add new cluster template related tag with name \"Cloudera-Service-Type\"\n- add a new service type resolver which is called during stack creation from stack request\n- service resolver will use a static json template where we can determine which service type should be used (based on only services for now, can be extended component/configurations later, but only if that will be needed)\n- service type resolver only called if no provided application tag\n- if application tag is not provided, the result service type from service type resolver will be used as the application tag, therefore we will have the information in the api response", "committedDate": "2020-08-07T11:27:31Z", "type": "forcePushed"}, {"oid": "f66188add812486b30331c120772802322840af7", "url": "https://github.com/hortonworks/cloudbreak/commit/f66188add812486b30331c120772802322840af7", "message": "CB-8328. Implemented service type provider interface for DataHub\n\ndetails:\n- add new cluster template related tag with name \"Cloudera-Service-Type\"\n- add a new service type resolver which is called during stack creation from stack request\n- service resolver will use a static json template where we can determine which service type should be used (based on only services for now, can be extended component/configurations later, but only if that will be needed)\n- service type resolver only called if no provided application tag\n- if application tag is not provided, the result service type from service type resolver will be used as the application tag, therefore we will have the information in the api response", "committedDate": "2020-08-07T11:30:31Z", "type": "forcePushed"}, {"oid": "e39f20f2d42410275b34f2370517dacb589254c2", "url": "https://github.com/hortonworks/cloudbreak/commit/e39f20f2d42410275b34f2370517dacb589254c2", "message": "CB-8328. Implemented service type provider interface for DataHub\n\ndetails:\n- add new cluster template related tag with name \"Cloudera-Service-Type\"\n- add a new service type resolver which is called during stack creation from stack request\n- service resolver will use a static json template where we can determine which service type should be used (based on only services for now, can be extended component/configurations later, but only if that will be needed)\n- service type resolver only called if no provided application tag\n- if application tag is not provided, the result service type from service type resolver will be used as the application tag, therefore we will have the information in the api response", "committedDate": "2020-08-07T12:25:26Z", "type": "forcePushed"}, {"oid": "86f5397b5a7823220ec88ef5f55750e2a086afc4", "url": "https://github.com/hortonworks/cloudbreak/commit/86f5397b5a7823220ec88ef5f55750e2a086afc4", "message": "CB-8328. Implemented service type provider interface for DataHub\n\ndetails:\n- add new cluster template related tag with name \"Cloudera-Service-Type\"\n- add a new service type resolver which is called during stack creation from stack request\n- service resolver will use a static json template where we can determine which service type should be used (based on only services for now, can be extended component/configurations later, but only if that will be needed)\n- service type resolver only called if no provided application tag\n- if application tag is not provided, the result service type from service type resolver will be used as the application tag, therefore we will have the information in the api response", "committedDate": "2020-08-07T13:37:04Z", "type": "forcePushed"}, {"oid": "cce3f0e21c515bf9b8157d5a5457a1057866a672", "url": "https://github.com/hortonworks/cloudbreak/commit/cce3f0e21c515bf9b8157d5a5457a1057866a672", "message": "CB-8328. Implemented service type provider interface for DataHub\n\ndetails:\n- add new cluster template related tag with name \"Cloudera-Service-Type\"\n- add a new service type resolver which is called during stack creation from stack request\n- service resolver will use a static json template where we can determine which service type should be used (based on only services for now, can be extended component/configurations later, but only if that will be needed)\n- service type resolver only called if no provided application tag\n- if application tag is not provided, the result service type from service type resolver will be used as the application tag, therefore we will have the information in the api response", "committedDate": "2020-08-07T14:45:52Z", "type": "commit"}, {"oid": "cce3f0e21c515bf9b8157d5a5457a1057866a672", "url": "https://github.com/hortonworks/cloudbreak/commit/cce3f0e21c515bf9b8157d5a5457a1057866a672", "message": "CB-8328. Implemented service type provider interface for DataHub\n\ndetails:\n- add new cluster template related tag with name \"Cloudera-Service-Type\"\n- add a new service type resolver which is called during stack creation from stack request\n- service resolver will use a static json template where we can determine which service type should be used (based on only services for now, can be extended component/configurations later, but only if that will be needed)\n- service type resolver only called if no provided application tag\n- if application tag is not provided, the result service type from service type resolver will be used as the application tag, therefore we will have the information in the api response", "committedDate": "2020-08-07T14:45:52Z", "type": "forcePushed"}]}