{"pr_number": 9294, "pr_title": "CB-9109 Freeipa launch crippled by missing storage account", "pr_createdAt": "2020-10-27T08:20:22Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9294", "timeline": [{"oid": "e5946d60d2767dd422ab629acc7b5ca586702a51", "url": "https://github.com/hortonworks/cloudbreak/commit/e5946d60d2767dd422ab629acc7b5ca586702a51", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, and 3) an finally azure managed image is created from the vhd file.\n\nIf an image already exists, then the whole process should be bypassed. However, if the storage account is deleted but the image exists an error is produced.\n\nIn this commit the bug is fixed by refactoring.", "committedDate": "2020-10-27T18:26:33Z", "type": "forcePushed"}, {"oid": "64f657e88470b9298b2c96357a0c03de93bb60ae", "url": "https://github.com/hortonworks/cloudbreak/commit/64f657e88470b9298b2c96357a0c03de93bb60ae", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, and 3) an finally azure managed image is created from the vhd file.\n\nIf an image already exists, then the whole process should be bypassed. However, if the storage account is deleted but the image exists an error is produced.\n\nBeyond the bugfix some refactoring:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class", "committedDate": "2020-10-27T21:25:33Z", "type": "forcePushed"}, {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "url": "https://github.com/hortonworks/cloudbreak/commit/3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class", "committedDate": "2020-10-28T07:17:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5MDM0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520390343", "bodyText": "Why haven't you extended AzureImage? It has multiple common fields, seems like it has the same purpose.", "author": "pdarvasi", "createdAt": "2020-11-10T08:53:46Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageDetails.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+public class AzureImageDetails {", "originalCommit": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2MTQ4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520461488", "bodyText": "While it's true they have common fields but there are some not in common, as well. They also serve slightly different purposes.\nI view it as:\ninput: AzureImageDetails. Grouping all the needed input parameters into one class\noutput: AzureImage. Tells, for example, if an image exists.\nI would keep it.", "author": "gergopapi2", "createdAt": "2020-11-10T10:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5MDM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ3ODQ4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520478489", "bodyText": "I renamed it to AzureImageInfo in hope to give it a better name.", "author": "gergopapi2", "createdAt": "2020-11-10T11:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5MDM0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a17775ddb155fd268caded09f35a807c89e4c311", "chunk": "diff --git a/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageDetails.java b/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageInfo.java\nsimilarity index 82%\nrename from cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageDetails.java\nrename to cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageInfo.java\nindex 6a611a450e..871d1b1c37 100644\n--- a/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageDetails.java\n+++ b/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageInfo.java\n\n@@ -1,6 +1,6 @@\n package com.sequenceiq.cloudbreak.cloud.azure.image;\n \n-public class AzureImageDetails {\n+public class AzureImageInfo {\n \n     private final String imageName;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyMTA3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520421075", "bodyText": "I'd still prefer isRequested as it check for current status \"REQUESTED\"", "author": "pdarvasi", "createdAt": "2020-11-10T09:39:54Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -135,7 +106,7 @@ public CloudResource buildCloudResource(String name, String id, CommonStatus sta\n                 .build();\n     }\n \n-    private boolean isRequested(String imageId) {\n-        return resourcePersistenceRetriever.notifyRetrieve(imageId, CommonStatus.REQUESTED, ResourceType.AZURE_MANAGED_IMAGE).isPresent();\n+    private boolean wasCreateRequested(AzureImageDetails azureImageDetails) {", "originalCommit": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a17775ddb155fd268caded09f35a807c89e4c311", "chunk": "diff --git a/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java b/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\nindex 76154e73c9..e0e42936b3 100644\n--- a/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\n+++ b/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\n\n@@ -106,7 +106,7 @@ public class AzureImageService {\n                 .build();\n     }\n \n-    private boolean wasCreateRequested(AzureImageDetails azureImageDetails) {\n-        return resourcePersistenceRetriever.notifyRetrieve(azureImageDetails.getImageId(), CommonStatus.REQUESTED, ResourceType.AZURE_MANAGED_IMAGE).isPresent();\n+    private boolean isCreateRequested(AzureImageInfo azureImageInfo) {\n+        return resourcePersistenceRetriever.notifyRetrieve(azureImageInfo.getImageId(), CommonStatus.REQUESTED, ResourceType.AZURE_MANAGED_IMAGE).isPresent();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjI3Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520426272", "bodyText": "Generally, I don't like the image --> customImage renames, as it is an Azure Java SDK only term, the object type is \"type\": \"Microsoft.Compute/images\" and in Portal, it is called \"Image\" in Azure Portal, too.\nFurthermore, the custom image term in Cloudbreak is used for a completely different concept. Pls. undo the renames.\nIt would be best to rename all occurrences, regardless of this PR.", "author": "pdarvasi", "createdAt": "2020-11-10T09:47:31Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -36,96 +33,70 @@\n     @Inject\n     private PersistenceNotifier persistenceNotifier;\n \n-    @Inject\n-    private AzureResourceIdProviderService azureResourceIdProviderService;\n-\n     @Inject\n     private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n \n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    @Inject\n-    private CustomVMImageNameProvider customVMImageNameProvider;\n-\n-    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n-        String region = getRegion(ac);\n-        String imageName = getImageName(region, fromVhdUri);\n-        String imageId = getImageId(resourceGroup, client, imageName);\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n-\n-        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n-            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n-            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-            return new AzureImage(imageId, imageName, true);\n-        } else {\n-            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n-            if (createIfNotFound) {\n-                saveImage(ac, imageName, imageId);\n-                Optional<VirtualMachineCustomImage> customImage;\n-                try {\n-                    customImage = Optional.of(client.createCustomImage(imageName, resourceGroup, fromVhdUri, region));\n-                } catch (CloudException e) {\n-                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n-                }\n-                return customImage\n-                        .map(image -> createNewAzureImageAndNotify(ac, image))\n-                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n-            } else {\n-                return null;\n-            }\n+    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n+        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+            return Optional.empty();\n         }\n+\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n+        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n     }\n \n-    private AzureImage createNewAzureImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {", "originalCommit": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2OTg5NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520469895", "bodyText": "You mean in AzureClient as well? Doing it.", "author": "gergopapi2", "createdAt": "2020-11-10T10:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjI3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a17775ddb155fd268caded09f35a807c89e4c311", "chunk": "diff --git a/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java b/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\nindex 76154e73c9..e0e42936b3 100644\n--- a/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\n+++ b/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\n\n@@ -39,59 +39,59 @@ public class AzureImageService {\n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n-        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+    public Optional<AzureImage> findImage(AzureImageInfo azureImageInfo, AzureClient client, AuthenticatedContext ac) {\n+        if (findImage(azureImageInfo, client).isEmpty() && !isCreateRequested(azureImageInfo)) {\n             return Optional.empty();\n         }\n \n-        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n-        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n-        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageInfo.getResourceGroup(), azureImageInfo.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageInfo, client));\n+        return Optional.of(new AzureImage(azureImageInfo.getImageId(), azureImageInfo.getImageName(), true));\n     }\n \n-    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n-        saveCustomImage(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId());\n+    public AzureImage createImage(AzureImageInfo azureImageInfo, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n+        saveImage(ac, azureImageInfo.getImageName(), azureImageInfo.getImageId());\n         Optional<VirtualMachineCustomImage> customImage;\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageDetails, client);\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageInfo, client);\n         try {\n             customImage = Optional.of(\n-                    client.createCustomImage(azureImageDetails.getImageName(), azureImageDetails.getResourceGroup(), fromVhdUri, azureImageDetails.getRegion()));\n+                    client.createImage(azureImageInfo.getImageName(), azureImageInfo.getResourceGroup(), fromVhdUri, azureImageInfo.getRegion()));\n         } catch (CloudException e) {\n-            customImage = handleCustomImageCreationException(azureImageDetails, ac, client, checkerContext, e);\n+            customImage = handleCustomImageCreationException(azureImageInfo, ac, client, checkerContext, e);\n         }\n         return customImage\n-                .map(image -> createCustomImageAndNotify(ac, image))\n+                .map(image -> createImageAndNotify(ac, image))\n                 .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n     }\n \n-    private AzureImage createCustomImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateCustomImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    private AzureImage createImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n+        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n         return new AzureImage(customImage.id(), customImage.name(), true);\n     }\n \n-    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageDetails azureImageDetails, AuthenticatedContext ac,\n+    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageInfo azureImageInfo, AuthenticatedContext ac,\n             AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n         Optional<VirtualMachineCustomImage> customImage;\n         azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-        customImage = findCustomImage(azureImageDetails, client);\n+        customImage = findImage(azureImageInfo, client);\n         if (customImage.isEmpty()) {\n             LOGGER.error(\"Failed to create custom image.\", e);\n-            updateCustomImageStatus(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId(), CommonStatus.FAILED);\n+            updateImageStatus(ac, azureImageInfo.getImageName(), azureImageInfo.getImageId(), CommonStatus.FAILED);\n             throw new CloudConnectorException(e);\n         }\n         return customImage;\n     }\n \n-    private Optional<VirtualMachineCustomImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client) {\n-        return azureManagedImageService.findVirtualMachineCustomImage(azureImageDetails, client);\n+    private Optional<VirtualMachineCustomImage> findImage(AzureImageInfo azureImageInfo, AzureClient client) {\n+        return azureManagedImageService.findVirtualMachineCustomImage(azureImageInfo, client);\n     }\n \n-    private void saveCustomImage(AuthenticatedContext ac, String imageName, String imageId) {\n+    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n         LOGGER.debug(\"Persisting image with REQUESTED status: {}\", imageId);\n         persistenceNotifier.notifyAllocation(buildCloudResource(imageName, imageId, CommonStatus.REQUESTED), ac.getCloudContext());\n     }\n \n-    private void updateCustomImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n+    private void updateImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n         LOGGER.debug(\"Updating image status to {}: {}\", commonStatus, imageId);\n         persistenceNotifier.notifyUpdate(buildCloudResource(imageName, imageId, commonStatus), ac.getCloudContext());\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjg5NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520426894", "bodyText": "same: pls. rename the rename", "author": "pdarvasi", "createdAt": "2020-11-10T09:48:30Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -36,96 +33,70 @@\n     @Inject\n     private PersistenceNotifier persistenceNotifier;\n \n-    @Inject\n-    private AzureResourceIdProviderService azureResourceIdProviderService;\n-\n     @Inject\n     private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n \n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    @Inject\n-    private CustomVMImageNameProvider customVMImageNameProvider;\n-\n-    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n-        String region = getRegion(ac);\n-        String imageName = getImageName(region, fromVhdUri);\n-        String imageId = getImageId(resourceGroup, client, imageName);\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n-\n-        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n-            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n-            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-            return new AzureImage(imageId, imageName, true);\n-        } else {\n-            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n-            if (createIfNotFound) {\n-                saveImage(ac, imageName, imageId);\n-                Optional<VirtualMachineCustomImage> customImage;\n-                try {\n-                    customImage = Optional.of(client.createCustomImage(imageName, resourceGroup, fromVhdUri, region));\n-                } catch (CloudException e) {\n-                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n-                }\n-                return customImage\n-                        .map(image -> createNewAzureImageAndNotify(ac, image))\n-                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n-            } else {\n-                return null;\n-            }\n+    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n+        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+            return Optional.empty();\n         }\n+\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n+        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n     }\n \n-    private AzureImage createNewAzureImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n+        saveCustomImage(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId());\n+        Optional<VirtualMachineCustomImage> customImage;\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageDetails, client);\n+        try {\n+            customImage = Optional.of(\n+                    client.createCustomImage(azureImageDetails.getImageName(), azureImageDetails.getResourceGroup(), fromVhdUri, azureImageDetails.getRegion()));\n+        } catch (CloudException e) {\n+            customImage = handleCustomImageCreationException(azureImageDetails, ac, client, checkerContext, e);\n+        }\n+        return customImage\n+                .map(image -> createCustomImageAndNotify(ac, image))\n+                .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n+    }\n+\n+    private AzureImage createCustomImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n+        updateCustomImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n         return new AzureImage(customImage.id(), customImage.name(), true);\n     }\n \n-    private Optional<VirtualMachineCustomImage> handleImageCreationException(String resourceGroup, AuthenticatedContext ac, AzureClient client,\n-            String imageName, String imageId, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n+    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageDetails azureImageDetails, AuthenticatedContext ac,\n+            AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n         Optional<VirtualMachineCustomImage> customImage;\n         azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-        customImage = getCustomImage(resourceGroup, client, imageName);\n+        customImage = findCustomImage(azureImageDetails, client);\n         if (customImage.isEmpty()) {\n             LOGGER.error(\"Failed to create custom image.\", e);\n-            updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+            updateCustomImageStatus(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId(), CommonStatus.FAILED);\n             throw new CloudConnectorException(e);\n         }\n         return customImage;\n     }\n \n-    private Optional<VirtualMachineCustomImage> getCustomImage(String resourceGroup, AzureClient client, String imageName) {\n-        return azureManagedImageService.findVirtualMachineCustomImage(resourceGroup, imageName, client);\n-    }\n-\n-    private String getImageName(String region, String fromVhdUri) {\n-        return customVMImageNameProvider.get(region, fromVhdUri);\n+    private Optional<VirtualMachineCustomImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client) {\n+        return azureManagedImageService.findVirtualMachineCustomImage(azureImageDetails, client);\n     }\n \n-    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n+    private void saveCustomImage(AuthenticatedContext ac, String imageName, String imageId) {", "originalCommit": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a17775ddb155fd268caded09f35a807c89e4c311", "chunk": "diff --git a/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java b/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\nindex 76154e73c9..e0e42936b3 100644\n--- a/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\n+++ b/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\n\n@@ -39,59 +39,59 @@ public class AzureImageService {\n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n-        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+    public Optional<AzureImage> findImage(AzureImageInfo azureImageInfo, AzureClient client, AuthenticatedContext ac) {\n+        if (findImage(azureImageInfo, client).isEmpty() && !isCreateRequested(azureImageInfo)) {\n             return Optional.empty();\n         }\n \n-        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n-        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n-        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageInfo.getResourceGroup(), azureImageInfo.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageInfo, client));\n+        return Optional.of(new AzureImage(azureImageInfo.getImageId(), azureImageInfo.getImageName(), true));\n     }\n \n-    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n-        saveCustomImage(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId());\n+    public AzureImage createImage(AzureImageInfo azureImageInfo, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n+        saveImage(ac, azureImageInfo.getImageName(), azureImageInfo.getImageId());\n         Optional<VirtualMachineCustomImage> customImage;\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageDetails, client);\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageInfo, client);\n         try {\n             customImage = Optional.of(\n-                    client.createCustomImage(azureImageDetails.getImageName(), azureImageDetails.getResourceGroup(), fromVhdUri, azureImageDetails.getRegion()));\n+                    client.createImage(azureImageInfo.getImageName(), azureImageInfo.getResourceGroup(), fromVhdUri, azureImageInfo.getRegion()));\n         } catch (CloudException e) {\n-            customImage = handleCustomImageCreationException(azureImageDetails, ac, client, checkerContext, e);\n+            customImage = handleCustomImageCreationException(azureImageInfo, ac, client, checkerContext, e);\n         }\n         return customImage\n-                .map(image -> createCustomImageAndNotify(ac, image))\n+                .map(image -> createImageAndNotify(ac, image))\n                 .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n     }\n \n-    private AzureImage createCustomImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateCustomImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    private AzureImage createImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n+        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n         return new AzureImage(customImage.id(), customImage.name(), true);\n     }\n \n-    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageDetails azureImageDetails, AuthenticatedContext ac,\n+    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageInfo azureImageInfo, AuthenticatedContext ac,\n             AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n         Optional<VirtualMachineCustomImage> customImage;\n         azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-        customImage = findCustomImage(azureImageDetails, client);\n+        customImage = findImage(azureImageInfo, client);\n         if (customImage.isEmpty()) {\n             LOGGER.error(\"Failed to create custom image.\", e);\n-            updateCustomImageStatus(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId(), CommonStatus.FAILED);\n+            updateImageStatus(ac, azureImageInfo.getImageName(), azureImageInfo.getImageId(), CommonStatus.FAILED);\n             throw new CloudConnectorException(e);\n         }\n         return customImage;\n     }\n \n-    private Optional<VirtualMachineCustomImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client) {\n-        return azureManagedImageService.findVirtualMachineCustomImage(azureImageDetails, client);\n+    private Optional<VirtualMachineCustomImage> findImage(AzureImageInfo azureImageInfo, AzureClient client) {\n+        return azureManagedImageService.findVirtualMachineCustomImage(azureImageInfo, client);\n     }\n \n-    private void saveCustomImage(AuthenticatedContext ac, String imageName, String imageId) {\n+    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n         LOGGER.debug(\"Persisting image with REQUESTED status: {}\", imageId);\n         persistenceNotifier.notifyAllocation(buildCloudResource(imageName, imageId, CommonStatus.REQUESTED), ac.getCloudContext());\n     }\n \n-    private void updateCustomImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n+    private void updateImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n         LOGGER.debug(\"Updating image status to {}: {}\", commonStatus, imageId);\n         persistenceNotifier.notifyUpdate(buildCloudResource(imageName, imageId, commonStatus), ac.getCloudContext());\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjk0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520426943", "bodyText": "same: pls. rename the rename", "author": "pdarvasi", "createdAt": "2020-11-10T09:48:36Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -36,96 +33,70 @@\n     @Inject\n     private PersistenceNotifier persistenceNotifier;\n \n-    @Inject\n-    private AzureResourceIdProviderService azureResourceIdProviderService;\n-\n     @Inject\n     private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n \n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    @Inject\n-    private CustomVMImageNameProvider customVMImageNameProvider;\n-\n-    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n-        String region = getRegion(ac);\n-        String imageName = getImageName(region, fromVhdUri);\n-        String imageId = getImageId(resourceGroup, client, imageName);\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n-\n-        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n-            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n-            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-            return new AzureImage(imageId, imageName, true);\n-        } else {\n-            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n-            if (createIfNotFound) {\n-                saveImage(ac, imageName, imageId);\n-                Optional<VirtualMachineCustomImage> customImage;\n-                try {\n-                    customImage = Optional.of(client.createCustomImage(imageName, resourceGroup, fromVhdUri, region));\n-                } catch (CloudException e) {\n-                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n-                }\n-                return customImage\n-                        .map(image -> createNewAzureImageAndNotify(ac, image))\n-                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n-            } else {\n-                return null;\n-            }\n+    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n+        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+            return Optional.empty();\n         }\n+\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n+        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n     }\n \n-    private AzureImage createNewAzureImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n+        saveCustomImage(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId());\n+        Optional<VirtualMachineCustomImage> customImage;\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageDetails, client);\n+        try {\n+            customImage = Optional.of(\n+                    client.createCustomImage(azureImageDetails.getImageName(), azureImageDetails.getResourceGroup(), fromVhdUri, azureImageDetails.getRegion()));\n+        } catch (CloudException e) {\n+            customImage = handleCustomImageCreationException(azureImageDetails, ac, client, checkerContext, e);\n+        }\n+        return customImage\n+                .map(image -> createCustomImageAndNotify(ac, image))\n+                .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n+    }\n+\n+    private AzureImage createCustomImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n+        updateCustomImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n         return new AzureImage(customImage.id(), customImage.name(), true);\n     }\n \n-    private Optional<VirtualMachineCustomImage> handleImageCreationException(String resourceGroup, AuthenticatedContext ac, AzureClient client,\n-            String imageName, String imageId, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n+    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageDetails azureImageDetails, AuthenticatedContext ac,\n+            AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n         Optional<VirtualMachineCustomImage> customImage;\n         azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-        customImage = getCustomImage(resourceGroup, client, imageName);\n+        customImage = findCustomImage(azureImageDetails, client);\n         if (customImage.isEmpty()) {\n             LOGGER.error(\"Failed to create custom image.\", e);\n-            updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+            updateCustomImageStatus(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId(), CommonStatus.FAILED);\n             throw new CloudConnectorException(e);\n         }\n         return customImage;\n     }\n \n-    private Optional<VirtualMachineCustomImage> getCustomImage(String resourceGroup, AzureClient client, String imageName) {\n-        return azureManagedImageService.findVirtualMachineCustomImage(resourceGroup, imageName, client);\n-    }\n-\n-    private String getImageName(String region, String fromVhdUri) {\n-        return customVMImageNameProvider.get(region, fromVhdUri);\n+    private Optional<VirtualMachineCustomImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client) {\n+        return azureManagedImageService.findVirtualMachineCustomImage(azureImageDetails, client);\n     }\n \n-    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n+    private void saveCustomImage(AuthenticatedContext ac, String imageName, String imageId) {\n         LOGGER.debug(\"Persisting image with REQUESTED status: {}\", imageId);\n         persistenceNotifier.notifyAllocation(buildCloudResource(imageName, imageId, CommonStatus.REQUESTED), ac.getCloudContext());\n     }\n \n-    private void updateImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n-        LOGGER.debug(\"Updating image status to {}: {}\", commonStatus.toString(), imageId);\n+    private void updateCustomImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {", "originalCommit": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a17775ddb155fd268caded09f35a807c89e4c311", "chunk": "diff --git a/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java b/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\nindex 76154e73c9..e0e42936b3 100644\n--- a/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\n+++ b/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\n\n@@ -39,59 +39,59 @@ public class AzureImageService {\n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n-        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+    public Optional<AzureImage> findImage(AzureImageInfo azureImageInfo, AzureClient client, AuthenticatedContext ac) {\n+        if (findImage(azureImageInfo, client).isEmpty() && !isCreateRequested(azureImageInfo)) {\n             return Optional.empty();\n         }\n \n-        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n-        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n-        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageInfo.getResourceGroup(), azureImageInfo.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageInfo, client));\n+        return Optional.of(new AzureImage(azureImageInfo.getImageId(), azureImageInfo.getImageName(), true));\n     }\n \n-    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n-        saveCustomImage(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId());\n+    public AzureImage createImage(AzureImageInfo azureImageInfo, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n+        saveImage(ac, azureImageInfo.getImageName(), azureImageInfo.getImageId());\n         Optional<VirtualMachineCustomImage> customImage;\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageDetails, client);\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageInfo, client);\n         try {\n             customImage = Optional.of(\n-                    client.createCustomImage(azureImageDetails.getImageName(), azureImageDetails.getResourceGroup(), fromVhdUri, azureImageDetails.getRegion()));\n+                    client.createImage(azureImageInfo.getImageName(), azureImageInfo.getResourceGroup(), fromVhdUri, azureImageInfo.getRegion()));\n         } catch (CloudException e) {\n-            customImage = handleCustomImageCreationException(azureImageDetails, ac, client, checkerContext, e);\n+            customImage = handleCustomImageCreationException(azureImageInfo, ac, client, checkerContext, e);\n         }\n         return customImage\n-                .map(image -> createCustomImageAndNotify(ac, image))\n+                .map(image -> createImageAndNotify(ac, image))\n                 .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n     }\n \n-    private AzureImage createCustomImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateCustomImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    private AzureImage createImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n+        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n         return new AzureImage(customImage.id(), customImage.name(), true);\n     }\n \n-    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageDetails azureImageDetails, AuthenticatedContext ac,\n+    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageInfo azureImageInfo, AuthenticatedContext ac,\n             AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n         Optional<VirtualMachineCustomImage> customImage;\n         azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-        customImage = findCustomImage(azureImageDetails, client);\n+        customImage = findImage(azureImageInfo, client);\n         if (customImage.isEmpty()) {\n             LOGGER.error(\"Failed to create custom image.\", e);\n-            updateCustomImageStatus(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId(), CommonStatus.FAILED);\n+            updateImageStatus(ac, azureImageInfo.getImageName(), azureImageInfo.getImageId(), CommonStatus.FAILED);\n             throw new CloudConnectorException(e);\n         }\n         return customImage;\n     }\n \n-    private Optional<VirtualMachineCustomImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client) {\n-        return azureManagedImageService.findVirtualMachineCustomImage(azureImageDetails, client);\n+    private Optional<VirtualMachineCustomImage> findImage(AzureImageInfo azureImageInfo, AzureClient client) {\n+        return azureManagedImageService.findVirtualMachineCustomImage(azureImageInfo, client);\n     }\n \n-    private void saveCustomImage(AuthenticatedContext ac, String imageName, String imageId) {\n+    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n         LOGGER.debug(\"Persisting image with REQUESTED status: {}\", imageId);\n         persistenceNotifier.notifyAllocation(buildCloudResource(imageName, imageId, CommonStatus.REQUESTED), ac.getCloudContext());\n     }\n \n-    private void updateCustomImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n+    private void updateImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n         LOGGER.debug(\"Updating image status to {}: {}\", commonStatus, imageId);\n         persistenceNotifier.notifyUpdate(buildCloudResource(imageName, imageId, commonStatus), ac.getCloudContext());\n     }\n"}}, {"oid": "a17775ddb155fd268caded09f35a807c89e4c311", "url": "https://github.com/hortonworks/cloudbreak/commit/a17775ddb155fd268caded09f35a807c89e4c311", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class", "committedDate": "2020-11-10T11:37:18Z", "type": "forcePushed"}, {"oid": "151b59310d37f3e18f5d0db0c0f2b82d4c16498a", "url": "https://github.com/hortonworks/cloudbreak/commit/151b59310d37f3e18f5d0db0c0f2b82d4c16498a", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class", "committedDate": "2020-11-17T20:57:17Z", "type": "commit"}, {"oid": "151b59310d37f3e18f5d0db0c0f2b82d4c16498a", "url": "https://github.com/hortonworks/cloudbreak/commit/151b59310d37f3e18f5d0db0c0f2b82d4c16498a", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class", "committedDate": "2020-11-17T20:57:17Z", "type": "forcePushed"}]}