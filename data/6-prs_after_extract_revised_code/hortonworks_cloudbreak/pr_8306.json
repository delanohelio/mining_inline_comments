{"pr_number": 8306, "pr_title": "CB-6329: Add recovery of the FreeIPA primary gateway", "pr_createdAt": "2020-06-17T02:54:08Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8306", "timeline": [{"oid": "f80a155dc97cfc0b0cb799ec2812f4a640f5c55e", "url": "https://github.com/hortonworks/cloudbreak/commit/f80a155dc97cfc0b0cb799ec2812f4a640f5c55e", "message": "CB-6329: Add recovery of the FreeIPA primary gateway\n\nAllow the FreeIPA primary gateway to be recovered.\n\nWhen recovering the primary gateway, the primary gateway is switched\nto a working instance. Then the old primary gateway is removed by\ndownscaling. A new FreeIPA master is created during upscale. Then the\nprimary gateway is switched back to the FreeIPA master.\n\nThe unused FreeIPA core instance metadata type was removed.\n\nThis was tested using the unit tests and it was manually tested using\na local instance of cloudbreak.", "committedDate": "2020-06-19T02:41:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc3MjcxMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8306#discussion_r442772711", "bodyText": "some nits:\n\nmaybe select instead of get would be better\ninstanceIdsToAvoid got me confused as I had to lookup the whole call chain to figure it out. Maybe we should rename this to something like instancesToRepair, as this is the reason we would like to avoid them if I'm not mistaken\nthis method got a little big. could you refactor out some bits into separate method, like  finding  Optional<String> freeIpaMasterInstanceId with stream", "author": "lacikaaa", "createdAt": "2020-06-19T10:53:58Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/ChangePrimaryGatewayService.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw;\n+\n+import static com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceMetadataType.GATEWAY;\n+import static com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceMetadataType.GATEWAY_PRIMARY;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.orchestrator.exception.CloudbreakOrchestratorException;\n+import com.sequenceiq.cloudbreak.orchestrator.host.HostOrchestrator;\n+import com.sequenceiq.cloudbreak.orchestrator.model.GatewayConfig;\n+import com.sequenceiq.freeipa.controller.exception.NotFoundException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.repository.InstanceMetaDataRepository;\n+import com.sequenceiq.freeipa.service.GatewayConfigService;\n+\n+@Service\n+public class ChangePrimaryGatewayService {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ChangePrimaryGatewayService.class);\n+\n+    @Inject\n+    private HostOrchestrator hostOrchestrator;\n+\n+    @Inject\n+    private GatewayConfigService gatewayConfigService;\n+\n+    @Inject\n+    private InstanceMetaDataRepository instanceMetaDataRepository;\n+\n+    public Optional<String> getPrimaryGatewayInstanceId(Stack stack) {\n+        Optional<String> primaryGatewayInstanceId = Optional.empty();\n+        try {\n+            primaryGatewayInstanceId = Optional.of(gatewayConfigService.getPrimaryGatewayConfig(stack).getInstanceId());\n+        } catch (NotFoundException e) {\n+            LOGGER.debug(\"No active primary gateway found\");\n+        }\n+        return primaryGatewayInstanceId;\n+    }\n+\n+    public String getNewPrimaryGatewayInstanceId(Stack stack, List<String> instanceIdsToAvoid) {", "originalCommit": "f80a155dc97cfc0b0cb799ec2812f4a640f5c55e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e3e2d863e7e6eb22380fb9dbf145f20030f78fd", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/ChangePrimaryGatewayService.java b/freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/ChangePrimaryGatewayService.java\nindex 9d360c0cb7..08f827bbc7 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/ChangePrimaryGatewayService.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/ChangePrimaryGatewayService.java\n\n@@ -46,30 +46,24 @@ public class ChangePrimaryGatewayService {\n         return primaryGatewayInstanceId;\n     }\n \n-    public String getNewPrimaryGatewayInstanceId(Stack stack, List<String> instanceIdsToAvoid) {\n+    public String selectNewPrimaryGatewayInstanceId(Stack stack, List<String> repairInstanceIds) {\n         String newPrimaryGatewayInstanceId;\n         try {\n             GatewayConfig currentPrimaryGatewayConfig = gatewayConfigService.getPrimaryGatewayConfig(stack);\n-            Optional<String> freeIpaMasterInstanceId = hostOrchestrator.getFreeIpaMasterHostname(currentPrimaryGatewayConfig).stream()\n-                    .flatMap(hostname ->\n-                                stack.getNotDeletedInstanceMetaDataList().stream()\n-                                        .filter(im -> hostname.equals(im.getDiscoveryFQDN()))\n-                                        .map(InstanceMetaData::getInstanceId)\n-                    )\n-                    .findFirst();\n-            if (freeIpaMasterInstanceId.isPresent() && !instanceIdsToAvoid.contains(freeIpaMasterInstanceId.get())) {\n+            Optional<String> freeIpaMasterInstanceId = findFreeIpaMasterInstanceId(stack, currentPrimaryGatewayConfig);\n+            if (freeIpaMasterInstanceId.isPresent() && !repairInstanceIds.contains(freeIpaMasterInstanceId.get())) {\n                 LOGGER.debug(\"Using the FreeIPA master as the new primary gateway\");\n                 newPrimaryGatewayInstanceId = freeIpaMasterInstanceId.get();\n             } else {\n                 newPrimaryGatewayInstanceId = currentPrimaryGatewayConfig.getInstanceId();\n-                if (instanceIdsToAvoid.contains(newPrimaryGatewayInstanceId)) {\n+                if (repairInstanceIds.contains(newPrimaryGatewayInstanceId)) {\n                     LOGGER.debug(\"The current primary gateway is on the list of to avoid, searching for a different primary gateway\");\n-                    newPrimaryGatewayInstanceId = assignNewPrimaryGatewayInstanceId(stack, instanceIdsToAvoid);\n+                    newPrimaryGatewayInstanceId = assignNewPrimaryGatewayInstanceId(stack, repairInstanceIds);\n                 }\n             }\n         } catch (NotFoundException e) {\n             LOGGER.debug(\"No primary gateway found, searching for an different primary gateway\");\n-            newPrimaryGatewayInstanceId = assignNewPrimaryGatewayInstanceId(stack, instanceIdsToAvoid);\n+            newPrimaryGatewayInstanceId = assignNewPrimaryGatewayInstanceId(stack, repairInstanceIds);\n         } catch (CloudbreakOrchestratorException e) {\n             LOGGER.debug(\"The orchestrator failed to identify the primary gateway node\", e);\n             throw new NotFoundException(\"No FreeIPA primary gateway could be selected\", e);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc3NTM3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8306#discussion_r442775376", "bodyText": "maybe logs some would be nice here just to see which branch is selected and which IDs are chosen", "author": "lacikaaa", "createdAt": "2020-06-19T10:59:59Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/action/ChangePrimaryGatewayActions.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.action;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.ChangePrimaryGatewayFlowEvent.CHANGE_PRIMARY_GATEWAY_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.ChangePrimaryGatewayFlowEvent.CHANGE_PRIMARY_GATEWAY_METADATA_FAILED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.ChangePrimaryGatewayFlowEvent.CHANGE_PRIMARY_GATEWAY_METADATA_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.ChangePrimaryGatewayFlowEvent.CHANGE_PRIMARY_GATEWAY_STARTING_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.ChangePrimaryGatewayFlowEvent.FAIL_HANDLED_EVENT;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.flow.core.PayloadConverter;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.DetailedStackStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.FailureDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.SuccessDetails;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.ChangePrimaryGatewayContext;\n+import com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.ChangePrimaryGatewayService;\n+import com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.event.ChangePrimaryGatewayEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.event.ChangePrimaryGatewayFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.event.selection.ChangePrimaryGatewaySelectionRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.event.selection.ChangePrimaryGatewaySelectionSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.failure.ClusterProxyUpdateRegistrationFailedToChangePrimaryGatewayFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+import com.sequenceiq.freeipa.service.stack.StackUpdater;\n+\n+@Configuration\n+public class ChangePrimaryGatewayActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ChangePrimaryGatewayActions.class);\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Bean(name = \"CHANGE_PRIMARY_GATEWAY_STATE_STARTING\")\n+    public Action<?, ?> startingAction() {\n+        return new AbstractChangePrimaryGatewayAction<>(ChangePrimaryGatewayEvent.class) {\n+            @Override\n+            protected void doExecute(ChangePrimaryGatewayContext context, ChangePrimaryGatewayEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                String operationId = payload.getOperationId();\n+                setOperationId(variables, operationId);\n+                setInstanceIds(variables, payload.getInstaceIds());\n+                setFinalChain(variables, payload.isFinalChain());\n+                LOGGER.info(\"Starting to change the primary gateway of stack {}\", stack.getId());\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.REPAIR_IN_PROGRESS, \"Starting to change the primary gateway\");\n+                sendEvent(context, CHANGE_PRIMARY_GATEWAY_STARTING_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"CHANGE_PRIMARY_GATEWAY_SELECTION\")\n+    public Action<?, ?> selectionAction() {\n+        return new AbstractChangePrimaryGatewayAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(ChangePrimaryGatewayContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.REPAIR_IN_PROGRESS, \"Selecting the primary gateway\");\n+\n+                List<String> instanceIds = getInstanceIds(variables);\n+                ChangePrimaryGatewaySelectionRequest request = new ChangePrimaryGatewaySelectionRequest(stack.getId(), instanceIds);\n+                sendEvent(context, request);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"CHANGE_PRIMARY_GATEWAY_METADATA_STATE\")\n+    public Action<?, ?> orchestrationAction() {\n+        return new AbstractChangePrimaryGatewayAction<>(ChangePrimaryGatewaySelectionSuccess.class) {\n+            @Inject\n+            private ChangePrimaryGatewayService changePrimaryGatewayService;\n+\n+            @Override\n+            protected void doExecute(ChangePrimaryGatewayContext context, ChangePrimaryGatewaySelectionSuccess payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.REPAIR_IN_PROGRESS, \"Changing the primary gateway metadata\");\n+\n+                try {\n+                    changePrimaryGatewayService.changePrimaryGatewayMetadata(stack, payload.getFormerPrimaryGatewayInstanceId(),\n+                            payload.getNewPrimaryGatewayInstanceId());\n+                    sendEvent(context, CHANGE_PRIMARY_GATEWAY_METADATA_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Failed to update the primary gateway metadata\", e);\n+                    sendEvent(context, CHANGE_PRIMARY_GATEWAY_METADATA_FAILED_EVENT.selector(),\n+                            new ChangePrimaryGatewayFailureEvent(stack.getId(), \"Updating metadata\", Set.of(), Map.of(), e));\n+\n+                }\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"CHANGE_PRIMARY_GATEWAY_CLUSTERPROXY_REGISTRATION_STATE\")\n+    public Action<?, ?> clusterProxyRegistrationAction() {\n+        return new AbstractChangePrimaryGatewayAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(ChangePrimaryGatewayContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.REPAIR_IN_PROGRESS,\n+                        \"Changing the primary gateway cluster proxy registration\");\n+\n+                List<String> instanceIds = getInstanceIds(variables);\n+                ClusterProxyUpdateRegistrationRequest request;\n+                if (Objects.nonNull(instanceIds)) {", "originalCommit": "f80a155dc97cfc0b0cb799ec2812f4a640f5c55e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e3e2d863e7e6eb22380fb9dbf145f20030f78fd", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/action/ChangePrimaryGatewayActions.java b/freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/action/ChangePrimaryGatewayActions.java\nindex 98fb2dd38e..b827c19123 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/action/ChangePrimaryGatewayActions.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/action/ChangePrimaryGatewayActions.java\n\n@@ -57,9 +57,9 @@ public class ChangePrimaryGatewayActions {\n                 Stack stack = context.getStack();\n                 String operationId = payload.getOperationId();\n                 setOperationId(variables, operationId);\n-                setInstanceIds(variables, payload.getInstaceIds());\n+                setInstanceIds(variables, payload.getRepairInstaceIds());\n                 setFinalChain(variables, payload.isFinalChain());\n-                LOGGER.info(\"Starting to change the primary gateway of stack {}\", stack.getId());\n+                LOGGER.info(\"Starting to change the primary gateway {}\", payload);\n                 stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.REPAIR_IN_PROGRESS, \"Starting to change the primary gateway\");\n                 sendEvent(context, CHANGE_PRIMARY_GATEWAY_STARTING_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc3NTk4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8306#discussion_r442775987", "bodyText": "could you add toString?", "author": "lacikaaa", "createdAt": "2020-06-19T11:01:27Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/event/ChangePrimaryGatewayEvent.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.event;\n+\n+import java.util.List;\n+\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+\n+public class ChangePrimaryGatewayEvent extends StackEvent {", "originalCommit": "f80a155dc97cfc0b0cb799ec2812f4a640f5c55e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e3e2d863e7e6eb22380fb9dbf145f20030f78fd", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/event/ChangePrimaryGatewayEvent.java b/freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/event/ChangePrimaryGatewayEvent.java\nindex 778fd50b63..95009d3709 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/event/ChangePrimaryGatewayEvent.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/repair/changeprimarygw/event/ChangePrimaryGatewayEvent.java\n\n@@ -2,24 +2,35 @@ package com.sequenceiq.freeipa.flow.freeipa.repair.changeprimarygw.event;\n \n import java.util.List;\n \n+import com.sequenceiq.cloudbreak.common.event.AcceptResult;\n import com.sequenceiq.freeipa.flow.stack.StackEvent;\n \n+import reactor.rx.Promise;\n+\n public class ChangePrimaryGatewayEvent extends StackEvent {\n     private final String operationId;\n \n     private final Boolean finalChain;\n \n-    private final List<String> instanceIds;\n+    private final List<String> repairInstanceIds;\n \n-    public ChangePrimaryGatewayEvent(String selector, Long stackId, List<String> instanceIds, Boolean finalChain, String operationId) {\n+    public ChangePrimaryGatewayEvent(String selector, Long stackId, List<String> repairInstanceIds, Boolean finalChain, String operationId) {\n         super(selector, stackId);\n-        this.instanceIds = instanceIds;\n+        this.repairInstanceIds = repairInstanceIds;\n         this.finalChain = finalChain;\n         this.operationId = operationId;\n     }\n \n-    public List<String> getInstaceIds() {\n-        return instanceIds;\n+    public ChangePrimaryGatewayEvent(String selector, Long stackId, List<String> repairInstanceIds, Boolean finalChain, String operationId,\n+            Promise<AcceptResult> accepted) {\n+        super(selector, stackId, accepted);\n+        this.repairInstanceIds = repairInstanceIds;\n+        this.finalChain = finalChain;\n+        this.operationId = operationId;\n+    }\n+\n+    public List<String> getRepairInstaceIds() {\n+        return repairInstanceIds;\n     }\n \n     public Boolean isFinalChain() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc3OTQyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8306#discussion_r442779428", "bodyText": "why do we have to call salt to find this out? shouldn't be this info available on java side?", "author": "lacikaaa", "createdAt": "2020-06-19T11:09:56Z", "path": "orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java", "diffHunk": "@@ -520,6 +553,31 @@ public void installFreeIPA(GatewayConfig primaryGateway, List<GatewayConfig> all\n         }\n     }\n \n+    @Override\n+    public Optional<String> getFreeIpaMasterHostname(GatewayConfig primaryGateway) throws CloudbreakOrchestratorException {", "originalCommit": "f80a155dc97cfc0b0cb799ec2812f4a640f5c55e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0NTk3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8306#discussion_r443845975", "bodyText": "In a normal situation, the FreeIPA primary gateway is the FreeIPA master. The primary gateway is stored in the FreeIPA database. During a repair of the primary gateway or after a failed repair of the primary gateway, it is likely that the FreeIPA primary gateway is a different node. As far as I can tell, FreeIPA doesn't store the salt roles in the database. I need to ensure that only a single node is identified as the primary FreeIPA instance (if multiple instances generate the CRLs it will be a problem), so I am querying FreeIPA.\nIf we add the FreeIPA roles into the database, this will be one more thing to synchronize and it will only be used during repair anyway.", "author": "jamisonbennett", "createdAt": "2020-06-22T21:50:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc3OTQyOA=="}], "type": "inlineReview", "revised_code": {"commit": "6e3e2d863e7e6eb22380fb9dbf145f20030f78fd", "chunk": "diff --git a/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java b/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java\nindex b4e1d0c7f9..b04b35c099 100644\n--- a/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java\n+++ b/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java\n\n@@ -553,6 +531,47 @@ public class SaltOrchestrator implements HostOrchestrator {\n         }\n     }\n \n+    private void installFreeIPAUpdateExistingReplicas(SaltConnector sc, Set<String> existingFreeIpaReplaceHostnames, Set<Node> allNodes,\n+            ExitCriteriaModel exitCriteriaModel) throws Exception {\n+        LOGGER.debug(\"Exsting Replica FreeIPAs: [{}]\", existingFreeIpaReplaceHostnames);\n+        // The existing replicas need to be serialized into high state. See the comments in CB-7335 for more details.\n+        for (String existingReplicaHostname : existingFreeIpaReplaceHostnames) {\n+            LOGGER.debug(\"Applying changes to FreeIPA replica {}\", existingReplicaHostname);\n+            runNewService(sc, new HighStateRunner(Set.of(existingReplicaHostname), allNodes), exitCriteriaModel);\n+        }\n+    }\n+\n+    private void installFreeIPAReplacas(SaltConnector sc, Set<String> newFreeIpaReplaceHostnames, Set<Node> allNodes, ExitCriteriaModel exitCriteriaModel)\n+            throws Exception {\n+        LOGGER.debug(\"New Replica FreeIPAs: [{}]\", newFreeIpaReplaceHostnames);\n+        if (!newFreeIpaReplaceHostnames.isEmpty()) {\n+            saltCommandRunner.runSaltCommand(sc, new GrainAddRunner(newFreeIpaReplaceHostnames, allNodes, FREEIPA_REPLICA_ROLE), exitCriteriaModel,\n+                    exitCriteria);\n+            runNewService(sc, new HighStateRunner(newFreeIpaReplaceHostnames, allNodes), exitCriteriaModel);\n+        }\n+    }\n+\n+    private Set<String> installFreeIPAPrimary(SaltConnector sc, GatewayConfig primaryGateway, Set<String> freeIpaMasterHostname, Set<String> unassignedHostnames,\n+            Set<String> existingFreeIpaReplaceHostnames, Set<Node> allNodes, ExitCriteriaModel exitCriteriaModel) throws Exception {\n+        freeIpaMasterHostname = new HashSet<>(freeIpaMasterHostname);\n+        if (!freeIpaMasterHostname.isEmpty()) {\n+            LOGGER.debug(\"Existing primary FreeIPA: {}\", freeIpaMasterHostname);\n+        } else if (existingFreeIpaReplaceHostnames.isEmpty()) {\n+            freeIpaMasterHostname.add(primaryGateway.getHostname());\n+            LOGGER.debug(\"Initial primary FreeIPA: {}\", freeIpaMasterHostname);\n+            saltCommandRunner.runSaltCommand(sc, new GrainAddRunner(freeIpaMasterHostname, allNodes, FREEIPA_MASTER_ROLE), exitCriteriaModel, exitCriteria);\n+        } else {\n+            freeIpaMasterHostname.add(unassignedHostnames.stream().findFirst()\n+                    .orElseThrow(() ->\n+                            new NotFoundException(\"A primary FreeIPA instance is requried and there are no unassigned roles to assign as a primary\")));\n+            LOGGER.debug(\"Replacement primary FreeIPA: {}\", freeIpaMasterHostname);\n+            saltCommandRunner.runSaltCommand(sc,\n+                    new GrainAddRunner(freeIpaMasterHostname, allNodes, FREEIPA_MASTER_REPLACEMENT_ROLE), exitCriteriaModel, exitCriteria);\n+        }\n+        runNewService(sc, new HighStateRunner(freeIpaMasterHostname, allNodes), exitCriteriaModel);\n+        return freeIpaMasterHostname;\n+    }\n+\n     @Override\n     public Optional<String> getFreeIpaMasterHostname(GatewayConfig primaryGateway) throws CloudbreakOrchestratorException {\n         return getHostnamesForRoles(primaryGateway, Set.of(FREEIPA_MASTER_ROLE, FREEIPA_MASTER_REPLACEMENT_ROLE)).stream().findFirst();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc3OTgxMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8306#discussion_r442779811", "bodyText": "this method got really big, could you refactor to smaller bits", "author": "lacikaaa", "createdAt": "2020-06-19T11:10:52Z", "path": "orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java", "diffHunk": "@@ -489,22 +497,47 @@ public void changePrimaryGateway(GatewayConfig formerGateway, GatewayConfig newP\n     @Override\n     public void installFreeIPA(GatewayConfig primaryGateway, List<GatewayConfig> allGatewayConfigs, Set<Node> allNodes,", "originalCommit": "f80a155dc97cfc0b0cb799ec2812f4a640f5c55e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e3e2d863e7e6eb22380fb9dbf145f20030f78fd", "chunk": "diff --git a/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java b/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java\nindex b4e1d0c7f9..b04b35c099 100644\n--- a/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java\n+++ b/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java\n\n@@ -508,35 +508,13 @@ public class SaltOrchestrator implements HostOrchestrator {\n \n         try (SaltConnector sc = createSaltConnector(primaryGateway, saltErrorResolver)) {\n \n-            LOGGER.debug(\"Exsting Replica FreeIPAs: [{}]\", existingFreeIpaReplaceHostnames);\n-            // The existing replicas need to be serialized into high state. See the comments in CB-7335 for more details.\n-            for (String existingReplicaHostname : existingFreeIpaReplaceHostnames) {\n-                LOGGER.debug(\"Applying changes to FreeIPA replica {}\", existingReplicaHostname);\n-                runNewService(sc, new HighStateRunner(Set.of(existingReplicaHostname), allNodes), exitCriteriaModel);\n-            }\n+            installFreeIPAUpdateExistingReplicas(sc, existingFreeIpaReplaceHostnames, allNodes, exitCriteriaModel);\n \n-            if (!freeIpaMasterHostname.isEmpty()) {\n-                LOGGER.debug(\"Existing primary FreeIPA: {}\", freeIpaMasterHostname);\n-            } else if (existingFreeIpaReplaceHostnames.isEmpty()) {\n-                freeIpaMasterHostname.add(primaryGateway.getHostname());\n-                LOGGER.debug(\"Initial primary FreeIPA: {}\", freeIpaMasterHostname);\n-                saltCommandRunner.runSaltCommand(sc, new GrainAddRunner(freeIpaMasterHostname, allNodes, FREEIPA_MASTER_ROLE), exitCriteriaModel, exitCriteria);\n-            } else {\n-                freeIpaMasterHostname.add(unassignedHostnames.stream().findFirst()\n-                        .orElseThrow(() ->\n-                                new NotFoundException(\"A primary FreeIPA instance is requried and there are no unassigned roles to assign as a primary\")));\n-                LOGGER.debug(\"Replacement primary FreeIPA: {}\", freeIpaMasterHostname);\n-                saltCommandRunner.runSaltCommand(sc,\n-                        new GrainAddRunner(freeIpaMasterHostname, allNodes, FREEIPA_MASTER_REPLACEMENT_ROLE), exitCriteriaModel, exitCriteria);\n-            }\n-            unassignedHostnames.removeAll(freeIpaMasterHostname);\n-            runNewService(sc, new HighStateRunner(freeIpaMasterHostname, allNodes), exitCriteriaModel);\n+            unassignedHostnames.removeAll(installFreeIPAPrimary(sc, primaryGateway, freeIpaMasterHostname, unassignedHostnames, existingFreeIpaReplaceHostnames,\n+                    allNodes, exitCriteriaModel));\n+\n+            installFreeIPAReplacas(sc, unassignedHostnames, allNodes, exitCriteriaModel);\n \n-            LOGGER.debug(\"New Replica FreeIPAs: [{}]\", unassignedHostnames);\n-            if (!unassignedHostnames.isEmpty()) {\n-                saltCommandRunner.runSaltCommand(sc, new GrainAddRunner(unassignedHostnames, allNodes, FREEIPA_REPLICA_ROLE), exitCriteriaModel, exitCriteria);\n-                runNewService(sc, new HighStateRunner(unassignedHostnames, allNodes), exitCriteriaModel);\n-            }\n             LOGGER.debug(\"Completed installing FreeIPA\");\n         } catch (CloudbreakOrchestratorException e) {\n             LOGGER.warn(\"CloudbreakOrchestratorException occurred during FreeIPA installation\", e);\n"}}, {"oid": "6e3e2d863e7e6eb22380fb9dbf145f20030f78fd", "url": "https://github.com/hortonworks/cloudbreak/commit/6e3e2d863e7e6eb22380fb9dbf145f20030f78fd", "message": "CB-6329: Add recovery of the FreeIPA primary gateway\n\nAllow the FreeIPA primary gateway to be recovered.\n\nWhen recovering the primary gateway, the primary gateway is switched\nto a working instance. Then the old primary gateway is removed by\ndownscaling. A new FreeIPA master is created during upscale. Then the\nprimary gateway is switched back to the FreeIPA master.\n\nThe unused FreeIPA core instance metadata type was removed.\n\nThis was tested using the unit tests, integration tests, and it was\nmanually tested using a local instance of cloudbreak.", "committedDate": "2020-06-22T21:08:30Z", "type": "forcePushed"}, {"oid": "8357e9748d6a446716355ddf59657920ae8be7de", "url": "https://github.com/hortonworks/cloudbreak/commit/8357e9748d6a446716355ddf59657920ae8be7de", "message": "CB-6329: Add recovery of the FreeIPA primary gateway\n\nAllow the FreeIPA primary gateway to be recovered.\n\nWhen recovering the primary gateway, the primary gateway is switched\nto a working instance. Then the old primary gateway is removed by\ndownscaling. A new FreeIPA master is created during upscale. Then the\nprimary gateway is switched back to the FreeIPA master.\n\nThe unused FreeIPA core instance metadata type was removed.\n\nThis was tested using the unit tests, integration tests, and it was\nmanually tested using a local instance of cloudbreak.", "committedDate": "2020-06-23T12:29:31Z", "type": "forcePushed"}, {"oid": "7e29ac84e6d0967fa88d6a400d9ea3e76baf4009", "url": "https://github.com/hortonworks/cloudbreak/commit/7e29ac84e6d0967fa88d6a400d9ea3e76baf4009", "message": "CB-6329: Add recovery of the FreeIPA primary gateway\n\nAllow the FreeIPA primary gateway to be recovered.\n\nWhen recovering the primary gateway, the primary gateway is switched\nto a working instance. Then the old primary gateway is removed by\ndownscaling. A new FreeIPA master is created during upscale. Then the\nprimary gateway is switched back to the FreeIPA master.\n\nThe unused FreeIPA core instance metadata type was removed.\n\nThis was tested using the unit tests, integration tests, and it was\nmanually tested using a local instance of cloudbreak.", "committedDate": "2020-06-23T14:42:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI5NDY2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8306#discussion_r444294668", "bodyText": "so I'm just dropping it here, but I noticed somewhere else also. We used everywhere FreeIpa until now (at least I hope so), and not FreeIPA. Could you rename methods, classes to match this?\nof course FreeIPA in logs and messages is fine", "author": "lacikaaa", "createdAt": "2020-06-23T15:02:45Z", "path": "orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java", "diffHunk": "@@ -489,22 +497,25 @@ public void changePrimaryGateway(GatewayConfig formerGateway, GatewayConfig newP\n     @Override\n     public void installFreeIPA(GatewayConfig primaryGateway, List<GatewayConfig> allGatewayConfigs, Set<Node> allNodes,\n             ExitCriteriaModel exitCriteriaModel) throws CloudbreakOrchestratorException {\n-        Set<String> primaryServerHostname = Collections.singleton(primaryGateway.getHostname());\n+        Set<String> freeIpaMasterHostname = new HashSet<>(getHostnamesForRoles(primaryGateway, Set.of(FREEIPA_MASTER_ROLE, FREEIPA_MASTER_REPLACEMENT_ROLE)));\n+        Set<String> existingFreeIpaReplaceHostnames = new HashSet<>(getHostnamesForRoles(primaryGateway, Set.of(FREEIPA_REPLICA_ROLE)));\n \n-        Set<String> replicaServersHostnames = allGatewayConfigs.stream()\n-                .filter(gwc -> !gwc.getHostname().equals(primaryGateway.getHostname()))\n-                .map(GatewayConfig::getHostname).collect(Collectors.toSet());\n+        Set<String> unassignedHostnames = allGatewayConfigs.stream()\n+                .map(GatewayConfig::getHostname)\n+                .filter(hostname -> !freeIpaMasterHostname.contains(hostname))\n+                .filter(hostname -> !existingFreeIpaReplaceHostnames.contains(hostname))\n+                .collect(Collectors.toCollection(HashSet::new));\n \n         try (SaltConnector sc = createSaltConnector(primaryGateway, saltErrorResolver)) {\n-            LOGGER.debug(\"Set primary FreeIPA: {}\", primaryServerHostname);\n-            saltCommandRunner.runSaltCommand(sc, new GrainAddRunner(primaryServerHostname, allNodes, \"freeipa_primary\"), exitCriteriaModel, exitCriteria);\n-            runNewService(sc, new HighStateRunner(primaryServerHostname, allNodes), exitCriteriaModel);\n-\n-            LOGGER.debug(\"Set replica FreeIPA: {}\", replicaServersHostnames);\n-            if (!replicaServersHostnames.isEmpty()) {\n-                saltCommandRunner.runSaltCommand(sc, new GrainAddRunner(replicaServersHostnames, allNodes, \"freeipa_replica\"), exitCriteriaModel, exitCriteria);\n-                runNewService(sc, new HighStateRunner(replicaServersHostnames, allNodes), exitCriteriaModel);\n-            }\n+\n+            installFreeIPAUpdateExistingReplicas(sc, existingFreeIpaReplaceHostnames, allNodes, exitCriteriaModel);", "originalCommit": "7e29ac84e6d0967fa88d6a400d9ea3e76baf4009", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM1ODY5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8306#discussion_r444358690", "bodyText": "I fixed this one....but I will put the others in a separate PR. There are quite a few capitalization changes (19 files and their associated classes).", "author": "jamisonbennett", "createdAt": "2020-06-23T16:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI5NDY2OA=="}], "type": "inlineReview", "revised_code": {"commit": "912b31444a0d5878170d16ba46fdffe150ff6508", "chunk": "diff --git a/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java b/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java\nindex b04b35c099..b93121f63a 100644\n--- a/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java\n+++ b/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java\n\n@@ -495,7 +495,7 @@ public class SaltOrchestrator implements HostOrchestrator {\n \n     @SuppressFBWarnings(\"REC_CATCH_EXCEPTION\")\n     @Override\n-    public void installFreeIPA(GatewayConfig primaryGateway, List<GatewayConfig> allGatewayConfigs, Set<Node> allNodes,\n+    public void installFreeIpa(GatewayConfig primaryGateway, List<GatewayConfig> allGatewayConfigs, Set<Node> allNodes,\n             ExitCriteriaModel exitCriteriaModel) throws CloudbreakOrchestratorException {\n         Set<String> freeIpaMasterHostname = new HashSet<>(getHostnamesForRoles(primaryGateway, Set.of(FREEIPA_MASTER_ROLE, FREEIPA_MASTER_REPLACEMENT_ROLE)));\n         Set<String> existingFreeIpaReplaceHostnames = new HashSet<>(getHostnamesForRoles(primaryGateway, Set.of(FREEIPA_REPLICA_ROLE)));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI5Njg5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8306#discussion_r444296896", "bodyText": "typo: installFreeIPAReplacas", "author": "lacikaaa", "createdAt": "2020-06-23T15:05:50Z", "path": "orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java", "diffHunk": "@@ -520,6 +531,72 @@ public void installFreeIPA(GatewayConfig primaryGateway, List<GatewayConfig> all\n         }\n     }\n \n+    private void installFreeIPAUpdateExistingReplicas(SaltConnector sc, Set<String> existingFreeIpaReplaceHostnames, Set<Node> allNodes,\n+            ExitCriteriaModel exitCriteriaModel) throws Exception {\n+        LOGGER.debug(\"Exsting Replica FreeIPAs: [{}]\", existingFreeIpaReplaceHostnames);\n+        // The existing replicas need to be serialized into high state. See the comments in CB-7335 for more details.\n+        for (String existingReplicaHostname : existingFreeIpaReplaceHostnames) {\n+            LOGGER.debug(\"Applying changes to FreeIPA replica {}\", existingReplicaHostname);\n+            runNewService(sc, new HighStateRunner(Set.of(existingReplicaHostname), allNodes), exitCriteriaModel);\n+        }\n+    }\n+\n+    private void installFreeIPAReplacas(SaltConnector sc, Set<String> newFreeIpaReplaceHostnames, Set<Node> allNodes, ExitCriteriaModel exitCriteriaModel)", "originalCommit": "7e29ac84e6d0967fa88d6a400d9ea3e76baf4009", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "912b31444a0d5878170d16ba46fdffe150ff6508", "chunk": "diff --git a/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java b/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java\nindex b04b35c099..b93121f63a 100644\n--- a/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java\n+++ b/orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java\n\n@@ -531,7 +531,7 @@ public class SaltOrchestrator implements HostOrchestrator {\n         }\n     }\n \n-    private void installFreeIPAUpdateExistingReplicas(SaltConnector sc, Set<String> existingFreeIpaReplaceHostnames, Set<Node> allNodes,\n+    private void installFreeIpaUpdateExistingReplicas(SaltConnector sc, Set<String> existingFreeIpaReplaceHostnames, Set<Node> allNodes,\n             ExitCriteriaModel exitCriteriaModel) throws Exception {\n         LOGGER.debug(\"Exsting Replica FreeIPAs: [{}]\", existingFreeIpaReplaceHostnames);\n         // The existing replicas need to be serialized into high state. See the comments in CB-7335 for more details.\n"}}, {"oid": "912b31444a0d5878170d16ba46fdffe150ff6508", "url": "https://github.com/hortonworks/cloudbreak/commit/912b31444a0d5878170d16ba46fdffe150ff6508", "message": "CB-6329: Add recovery of the FreeIPA primary gateway\n\nAllow the FreeIPA primary gateway to be recovered.\n\nWhen recovering the primary gateway, the primary gateway is switched\nto a working instance. Then the old primary gateway is removed by\ndownscaling. A new FreeIPA master is created during upscale. Then the\nprimary gateway is switched back to the FreeIPA master.\n\nThe unused FreeIPA core instance metadata type was removed.\n\nThis was tested using the unit tests, integration tests, and it was\nmanually tested using a local instance of cloudbreak.", "committedDate": "2020-06-23T16:34:08Z", "type": "commit"}, {"oid": "912b31444a0d5878170d16ba46fdffe150ff6508", "url": "https://github.com/hortonworks/cloudbreak/commit/912b31444a0d5878170d16ba46fdffe150ff6508", "message": "CB-6329: Add recovery of the FreeIPA primary gateway\n\nAllow the FreeIPA primary gateway to be recovered.\n\nWhen recovering the primary gateway, the primary gateway is switched\nto a working instance. Then the old primary gateway is removed by\ndownscaling. A new FreeIPA master is created during upscale. Then the\nprimary gateway is switched back to the FreeIPA master.\n\nThe unused FreeIPA core instance metadata type was removed.\n\nThis was tested using the unit tests, integration tests, and it was\nmanually tested using a local instance of cloudbreak.", "committedDate": "2020-06-23T16:34:08Z", "type": "forcePushed"}]}