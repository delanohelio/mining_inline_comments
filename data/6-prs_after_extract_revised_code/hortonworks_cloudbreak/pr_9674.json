{"pr_number": 9674, "pr_title": "CB-9182 Add Support for CCMV2", "pr_createdAt": "2020-12-21T15:15:20Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9674", "timeline": [{"oid": "8ae8085c2193cdabce84b24a418ac004d4d462eb", "url": "https://github.com/hortonworks/cloudbreak/commit/8ae8085c2193cdabce84b24a418ac004d4d462eb", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2020-12-22T16:52:15Z", "type": "forcePushed"}, {"oid": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "url": "https://github.com/hortonworks/cloudbreak/commit/e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-04T04:34:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNjAxMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551216010", "bodyText": "while this is a compact form I would prefer if you could split this into multiple lines and log the value of grpcCcmV2Client.getOrCreateInvertingProxy. This way we would be able to tell if it is null or the state is wrong", "author": "lacikaaa", "createdAt": "2021-01-04T09:57:21Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.ccmv2;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.backoff.FixedBackOffPolicy;\n+import org.springframework.retry.policy.TimeoutRetryPolicy;\n+import org.springframework.retry.support.RetryTemplate;\n+import org.springframework.stereotype.Component;\n+\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.UnregisterAgentResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxy;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxyAgent;\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+import com.sequenceiq.cloudbreak.ccmimpl.ccmv2.config.GrpcCcmV2Config;\n+\n+@Component\n+public class CcmV2ManagementClient {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CcmV2ManagementClient.class);\n+\n+    @Inject\n+    private GrpcCcmV2Client grpcCcmV2Client;\n+\n+    @Inject\n+    private GrpcCcmV2Config grpcCcmV2Config;\n+\n+    public InvertingProxy awaitReadyInvertingProxyForAccount(String requestId, String accountId) {\n+        return getRetryTemplate().execute(\n+                retryContext -> {\n+                    LOGGER.debug(\"Retrieving InvertingProxy Config for accountId '{}'\", accountId);\n+                    return Optional.ofNullable(grpcCcmV2Client.getOrCreateInvertingProxy(requestId, accountId, ThreadBasedUserCrnProvider.getUserCrn()))\n+                            .filter(invertingProxy -> InvertingProxy.Status.READY.equals(invertingProxy.getStatus()))", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwNzY0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552507641", "bodyText": "I used the compact form but proto3 does not return null. To support logging returned state I split it into multiple lines as suggested.", "author": "smaniraju", "createdAt": "2021-01-06T10:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNjAxMA=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java\nindex 9473995cfd..dad5f7bc41 100644\n--- a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java\n+++ b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java\n\n@@ -1,7 +1,5 @@\n package com.sequenceiq.cloudbreak.ccmimpl.ccmv2;\n \n-import java.util.Optional;\n-\n import javax.inject.Inject;\n \n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNjI5OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551216298", "bodyText": "could you introduce a new exception for this? (and the others)\nalso I'm not sure if RuntimeException is the right way to go here. Shouldn't we enforce the handling of these expected exception on the callers side?", "author": "lacikaaa", "createdAt": "2021-01-04T09:57:58Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.ccmv2;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.backoff.FixedBackOffPolicy;\n+import org.springframework.retry.policy.TimeoutRetryPolicy;\n+import org.springframework.retry.support.RetryTemplate;\n+import org.springframework.stereotype.Component;\n+\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.UnregisterAgentResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxy;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxyAgent;\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+import com.sequenceiq.cloudbreak.ccmimpl.ccmv2.config.GrpcCcmV2Config;\n+\n+@Component\n+public class CcmV2ManagementClient {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CcmV2ManagementClient.class);\n+\n+    @Inject\n+    private GrpcCcmV2Client grpcCcmV2Client;\n+\n+    @Inject\n+    private GrpcCcmV2Config grpcCcmV2Config;\n+\n+    public InvertingProxy awaitReadyInvertingProxyForAccount(String requestId, String accountId) {\n+        return getRetryTemplate().execute(\n+                retryContext -> {\n+                    LOGGER.debug(\"Retrieving InvertingProxy Config for accountId '{}'\", accountId);\n+                    return Optional.ofNullable(grpcCcmV2Client.getOrCreateInvertingProxy(requestId, accountId, ThreadBasedUserCrnProvider.getUserCrn()))\n+                            .filter(invertingProxy -> InvertingProxy.Status.READY.equals(invertingProxy.getStatus()))\n+                            .orElseThrow(() -> new RuntimeException(String.format(\"InvertingProxy not found in ready state for accountId '%s'\", accountId)));", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwODI0NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552508245", "bodyText": "Ok introduced new exception. But there is not much handling the caller can do after ccm retry fails, the caller just rethrows the exception and stack creation is marked failure because of CCM issue. This behaviour is consistent with CCMV1.", "author": "smaniraju", "createdAt": "2021-01-06T11:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNjI5OA=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java\nindex 9473995cfd..dad5f7bc41 100644\n--- a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java\n+++ b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java\n\n@@ -1,7 +1,5 @@\n package com.sequenceiq.cloudbreak.ccmimpl.ccmv2;\n \n-import java.util.Optional;\n-\n import javax.inject.Inject;\n \n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyMjc5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551222796", "bodyText": "please add unit test", "author": "lacikaaa", "createdAt": "2021-01-04T10:10:33Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.ccmv2;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.backoff.FixedBackOffPolicy;\n+import org.springframework.retry.policy.TimeoutRetryPolicy;\n+import org.springframework.retry.support.RetryTemplate;\n+import org.springframework.stereotype.Component;\n+\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.UnregisterAgentResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxy;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxyAgent;\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+import com.sequenceiq.cloudbreak.ccmimpl.ccmv2.config.GrpcCcmV2Config;\n+\n+@Component\n+public class CcmV2ManagementClient {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwODU2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552508562", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyMjc5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java\nindex 9473995cfd..dad5f7bc41 100644\n--- a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java\n+++ b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java\n\n@@ -1,7 +1,5 @@\n package com.sequenceiq.cloudbreak.ccmimpl.ccmv2;\n \n-import java.util.Optional;\n-\n import javax.inject.Inject;\n \n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyNjkzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551226933", "bodyText": "shall we log the requests here before calling the service?", "author": "lacikaaa", "createdAt": "2021-01-04T10:18:19Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/GrpcCcmV2Client.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.ccmv2;\n+\n+import static io.grpc.internal.GrpcUtil.DEFAULT_MAX_MESSAGE_SIZE;\n+\n+import javax.inject.Inject;\n+import org.springframework.stereotype.Component;\n+\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Grpc;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Grpc.ClusterConnectivityManagementV2BlockingStub;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.UnregisterAgentResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.CreateOrGetInvertingProxyRequest;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.CreateOrGetInvertingProxyResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxy;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxyAgent;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.RegisterAgentRequest;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.RegisterAgentResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.RemoveInvertingProxyResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.RemoveInvertingProxyRequest;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.UnregisterAgentRequest;\n+import com.sequenceiq.cloudbreak.ccmimpl.ccmv2.config.GrpcCcmV2Config;\n+import com.sequenceiq.cloudbreak.grpc.ManagedChannelWrapper;\n+import com.sequenceiq.cloudbreak.grpc.altus.AltusMetadataInterceptor;\n+import com.sequenceiq.cloudbreak.grpc.util.GrpcUtil;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentracing.Tracer;\n+\n+@Component\n+public class GrpcCcmV2Client {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwODc0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552508743", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyNjkzMw=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/GrpcCcmV2Client.java b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/GrpcCcmV2Client.java\nindex f888bc5c0d..55883bb3c7 100644\n--- a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/GrpcCcmV2Client.java\n+++ b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/GrpcCcmV2Client.java\n\n@@ -3,20 +3,21 @@ package com.sequenceiq.cloudbreak.ccmimpl.ccmv2;\n import static io.grpc.internal.GrpcUtil.DEFAULT_MAX_MESSAGE_SIZE;\n \n import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Component;\n \n import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Grpc;\n import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Grpc.ClusterConnectivityManagementV2BlockingStub;\n-import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.UnregisterAgentResponse;\n import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.CreateOrGetInvertingProxyRequest;\n import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.CreateOrGetInvertingProxyResponse;\n import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxy;\n import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxyAgent;\n import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.RegisterAgentRequest;\n import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.RegisterAgentResponse;\n-import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.RemoveInvertingProxyResponse;\n-import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.RemoveInvertingProxyRequest;\n import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.UnregisterAgentRequest;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.UnregisterAgentResponse;\n import com.sequenceiq.cloudbreak.ccmimpl.ccmv2.config.GrpcCcmV2Config;\n import com.sequenceiq.cloudbreak.grpc.ManagedChannelWrapper;\n import com.sequenceiq.cloudbreak.grpc.altus.AltusMetadataInterceptor;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyNzk0OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551227949", "bodyText": "the intent of @Configuration annotation is to define beans. You should use @Component here", "author": "lacikaaa", "createdAt": "2021-01-04T10:20:16Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/config/GrpcCcmV2Config.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.ccmv2.config;\n+\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Configuration;\n+\n+@Configuration", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwODgyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552508827", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyNzk0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/config/GrpcCcmV2Config.java b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/config/GrpcCcmV2Config.java\nindex 97593b3100..e71159e7a4 100644\n--- a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/config/GrpcCcmV2Config.java\n+++ b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/config/GrpcCcmV2Config.java\n\n@@ -1,9 +1,9 @@\n package com.sequenceiq.cloudbreak.ccmimpl.ccmv2.config;\n \n import org.springframework.beans.factory.annotation.Value;\n-import org.springframework.context.annotation.Configuration;\n+import org.springframework.stereotype.Component;\n \n-@Configuration\n+@Component\n public class GrpcCcmV2Config {\n \n     @Value(\"${altus.ccmv2mgmt.host:thunderhead-clusterconnectivitymanagementv2.thunderhead-clusterconnectivitymanagementv2.svc.cluster.local}\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNDI4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551234283", "bodyText": "could you move these validations to a separate method? thanks", "author": "lacikaaa", "createdAt": "2021-01-04T10:32:02Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/cloudinit/DefaultCcmV2ParameterSupplier.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.cloudinit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.annotation.Nonnull;\n+import javax.inject.Inject;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxy;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxyAgent;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmV2ParameterSupplier;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmV2Parameters;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.DefaultCcmV2Parameters;\n+import com.sequenceiq.cloudbreak.ccmimpl.ccmv2.CcmV2ManagementClient;\n+import com.sequenceiq.cloudbreak.logger.LoggerContextKey;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+\n+@Component\n+public class DefaultCcmV2ParameterSupplier implements CcmV2ParameterSupplier {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultCcmV2ParameterSupplier.class);\n+\n+    @Inject\n+    private CcmV2ManagementClient ccmV2Client;\n+\n+    public CcmV2Parameters getCcmV2Parameters(@Nonnull String accountId, @Nonnull String clusterGatewayDomain, @Nonnull String agentKeyId) {\n+        String requestId = Optional.ofNullable(MDCBuilder.getMdcContextMap().get(LoggerContextKey.REQUEST_ID.toString())).orElse(UUID.randomUUID().toString());\n+        MDCBuilder.addRequestId(requestId);\n+\n+        InvertingProxy invertingProxy = ccmV2Client.awaitReadyInvertingProxyForAccount(requestId, accountId);\n+        InvertingProxyAgent invertingProxyAgent = ccmV2Client.registerInvertingProxyAgent(requestId, accountId, clusterGatewayDomain, agentKeyId);\n+\n+        checkArgument(StringUtils.isNotEmpty(invertingProxy.getHostname()), \"InvertingProxy Hostname is not initialized.\");\n+        checkArgument(StringUtils.isNotEmpty(invertingProxy.getCertificate()), \"InvertingProxy Certificate is not initialized.\");\n+        checkArgument(StringUtils.isNotEmpty(invertingProxyAgent.getAgentCrn()), \"InvertingProxyAgent Crn is not initialized.\");\n+        checkArgument(StringUtils.isNotEmpty(invertingProxyAgent.getEncipheredPrivateKey()), \"InvertingProxyAgent Enciphered Key is not initialized.\");\n+        checkArgument(StringUtils.isNotEmpty(invertingProxyAgent.getCertificate()), \"InvertingProxyAgent Certificate is not initialized.\");", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwOTMyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552509322", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNDI4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/cloudinit/DefaultCcmV2ParameterSupplier.java b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/cloudinit/DefaultCcmV2ParameterSupplier.java\nindex 48782d15ea..b1129d7a18 100644\n--- a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/cloudinit/DefaultCcmV2ParameterSupplier.java\n+++ b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/cloudinit/DefaultCcmV2ParameterSupplier.java\n\n@@ -2,9 +2,6 @@ package com.sequenceiq.cloudbreak.ccmimpl.cloudinit;\n \n import static com.google.common.base.Preconditions.checkArgument;\n \n-import java.util.Optional;\n-import java.util.UUID;\n-\n import javax.annotation.Nonnull;\n import javax.inject.Inject;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNTM4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551235388", "bodyText": "this seems to be a duplication of the code already in DefaultCcmV2ParameterSupplier. I think this could be moved to MDCBuilder", "author": "lacikaaa", "createdAt": "2021-01-04T10:34:13Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/termination/DefaultCcmV2AgentTerminationListener.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.termination;\n+\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.ccm.termination.CcmV2AgentTerminationListener;\n+import com.sequenceiq.cloudbreak.ccmimpl.ccmv2.CcmV2ManagementClient;\n+import com.sequenceiq.cloudbreak.logger.LoggerContextKey;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+\n+@Component\n+public class DefaultCcmV2AgentTerminationListener implements CcmV2AgentTerminationListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultCcmV2AgentTerminationListener.class);\n+\n+    @Inject\n+    private CcmV2ManagementClient ccmV2Client;\n+\n+    @Override\n+    public void deregisterInvertingProxyAgent(String ccmV2AgentCrn) {\n+        if (ccmV2AgentCrn != null) {\n+            String requestId = Optional.ofNullable(MDCBuilder.getMdcContextMap()\n+                    .get(LoggerContextKey.REQUEST_ID.toString())).orElse(UUID.randomUUID().toString());\n+            MDCBuilder.addRequestId(requestId);", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwOTI3Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552509273", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:03:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNTM4OA=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/termination/DefaultCcmV2AgentTerminationListener.java b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/termination/DefaultCcmV2AgentTerminationListener.java\nindex 640ff837f3..cc7413e8cf 100644\n--- a/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/termination/DefaultCcmV2AgentTerminationListener.java\n+++ b/ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/termination/DefaultCcmV2AgentTerminationListener.java\n\n@@ -1,8 +1,5 @@\n package com.sequenceiq.cloudbreak.ccmimpl.termination;\n \n-import java.util.Optional;\n-import java.util.UUID;\n-\n import javax.inject.Inject;\n \n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0MzEwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551243106", "bodyText": "domain is a bit misleading here, as it's actually the gateway node's FQDN", "author": "lacikaaa", "createdAt": "2021-01-04T10:48:22Z", "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/HostDiscoveryService.java", "diffHunk": "@@ -48,6 +50,10 @@ public String generateHostname(String customHostnamePrefix, String instanceGroup\n         return getHostname(customHostnamePrefix, instanceGroupName).replaceAll(\"_\", \"\") + privateId;\n     }\n \n+    public String determineDefaultDomainForStack(String gatewayHostName, String stackDomain) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwOTczMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552509732", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0MzEwNg=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/HostDiscoveryService.java b/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/HostDiscoveryService.java\nindex 3ea69df564..4092e695fb 100644\n--- a/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/HostDiscoveryService.java\n+++ b/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/HostDiscoveryService.java\n\n@@ -50,7 +50,7 @@ public class HostDiscoveryService {\n         return getHostname(customHostnamePrefix, instanceGroupName).replaceAll(\"_\", \"\") + privateId;\n     }\n \n-    public String determineDefaultDomainForStack(String gatewayHostName, String stackDomain) {\n+    public String determineGatewayFqdn(String gatewayHostName, String stackDomain) {\n         return gatewayHostName + DOMAIN_PART_DELIMITER + stackDomain;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0NDc0Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551244742", "bodyText": "is there any particular reason the json field name is different from the java field name?", "author": "lacikaaa", "createdAt": "2021-01-04T10:51:39Z", "path": "cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/CcmV2Config.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.sequenceiq.cloudbreak.clusterproxy;\n+\n+import java.util.Objects;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+public class CcmV2Config {\n+\n+    @JsonProperty(\"agentCrn\")\n+    private String agentCrn;\n+\n+    @JsonProperty(\"backendId\")\n+    private String backendId;\n+\n+    @JsonProperty(\"host\")\n+    private String gatewayHost;\n+\n+    @JsonProperty(\"port\")\n+    private int gatewayPort;", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMDE4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552510183", "bodyText": "ccmv2 team wants these fieldnames as host and port. But in CB just host and port does not give any context, hence the java field name is as per CB context.", "author": "smaniraju", "createdAt": "2021-01-06T11:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0NDc0Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0Nzc2Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551247766", "bodyText": "instead of instanceof it should be handled by catching this type of exception and add the logic there", "author": "lacikaaa", "createdAt": "2021-01-04T10:57:25Z", "path": "cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/ClusterProxyRegistrationClient.java", "diffHunk": "@@ -115,4 +116,11 @@ public ReadConfigResponse readConfig(String clusterIdentifier) {\n         headers.setContentType(MediaType.APPLICATION_JSON);\n         return new HttpEntity<>(JsonUtil.writeValueAsString(proxyConfigRequest), headers);\n     }\n+\n+    private void logErrorWithResponseBody(String message, Exception ex) {\n+        if (ex instanceof RestClientResponseException) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMDIyMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552510220", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:05:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0Nzc2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/ClusterProxyRegistrationClient.java b/cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/ClusterProxyRegistrationClient.java\nindex 954b9c03a3..400819348c 100644\n--- a/cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/ClusterProxyRegistrationClient.java\n+++ b/cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/ClusterProxyRegistrationClient.java\n\n@@ -116,11 +136,4 @@ public class ClusterProxyRegistrationClient {\n         headers.setContentType(MediaType.APPLICATION_JSON);\n         return new HttpEntity<>(JsonUtil.writeValueAsString(proxyConfigRequest), headers);\n     }\n-\n-    private void logErrorWithResponseBody(String message, Exception ex) {\n-        if (ex instanceof RestClientResponseException) {\n-            message += \" ,Error Response Body : \" + ((RestClientResponseException) ex).getResponseBodyAsString();\n-        }\n-        LOGGER.error(message, ex);\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0ODM1NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551248355", "bodyText": "modifying a method parameter is usually a bad practice and should be avoided if possible", "author": "lacikaaa", "createdAt": "2021-01-04T10:58:41Z", "path": "cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/ClusterProxyRegistrationClient.java", "diffHunk": "@@ -115,4 +116,11 @@ public ReadConfigResponse readConfig(String clusterIdentifier) {\n         headers.setContentType(MediaType.APPLICATION_JSON);\n         return new HttpEntity<>(JsonUtil.writeValueAsString(proxyConfigRequest), headers);\n     }\n+\n+    private void logErrorWithResponseBody(String message, Exception ex) {\n+        if (ex instanceof RestClientResponseException) {\n+            message += \" ,Error Response Body : \" + ((RestClientResponseException) ex).getResponseBodyAsString();", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMDc2MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552510760", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0ODM1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/ClusterProxyRegistrationClient.java b/cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/ClusterProxyRegistrationClient.java\nindex 954b9c03a3..400819348c 100644\n--- a/cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/ClusterProxyRegistrationClient.java\n+++ b/cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/ClusterProxyRegistrationClient.java\n\n@@ -116,11 +136,4 @@ public class ClusterProxyRegistrationClient {\n         headers.setContentType(MediaType.APPLICATION_JSON);\n         return new HttpEntity<>(JsonUtil.writeValueAsString(proxyConfigRequest), headers);\n     }\n-\n-    private void logErrorWithResponseBody(String message, Exception ex) {\n-        if (ex instanceof RestClientResponseException) {\n-            message += \" ,Error Response Body : \" + ((RestClientResponseException) ex).getResponseBodyAsString();\n-        }\n-        LOGGER.error(message, ex);\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1NDY4NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551254685", "bodyText": "I think this should be replaced with the default constructor, without parameter and that should set connectivity mode to NONE. So it would be obvious you can't define CCMv2 mode without passing the related parameters.", "author": "lacikaaa", "createdAt": "2021-01-04T11:12:39Z", "path": "common/src/main/java/com/sequenceiq/cloudbreak/ccm/cloudinit/CcmConnectivityParameters.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.sequenceiq.cloudbreak.ccm.cloudinit;\n+\n+public class CcmConnectivityParameters {\n+\n+    private CcmParameters ccmParameters;\n+\n+    private CcmV2Parameters ccmV2Parameters;\n+\n+    private CcmConnectivityMode connectivityMode;\n+\n+    public CcmConnectivityParameters(CcmParameters ccmParameters) {\n+        this.ccmParameters = ccmParameters;\n+        this.connectivityMode = CcmConnectivityMode.CCMV1;\n+    }\n+\n+    public CcmConnectivityParameters(CcmV2Parameters ccmV2Parameters) {\n+        this.ccmV2Parameters = ccmV2Parameters;\n+        this.connectivityMode = CcmConnectivityMode.CCMV2;\n+    }\n+\n+    public CcmConnectivityParameters(CcmConnectivityMode connectivityMode) {\n+        this.connectivityMode = connectivityMode;\n+    }", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMTMwOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552511308", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1NDY4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/common/src/main/java/com/sequenceiq/cloudbreak/ccm/cloudinit/CcmConnectivityParameters.java b/common/src/main/java/com/sequenceiq/cloudbreak/ccm/cloudinit/CcmConnectivityParameters.java\nindex ae4ec639be..5bfbddb97b 100644\n--- a/common/src/main/java/com/sequenceiq/cloudbreak/ccm/cloudinit/CcmConnectivityParameters.java\n+++ b/common/src/main/java/com/sequenceiq/cloudbreak/ccm/cloudinit/CcmConnectivityParameters.java\n\n@@ -6,20 +6,15 @@ public class CcmConnectivityParameters {\n \n     private CcmV2Parameters ccmV2Parameters;\n \n-    private CcmConnectivityMode connectivityMode;\n-\n     public CcmConnectivityParameters(CcmParameters ccmParameters) {\n         this.ccmParameters = ccmParameters;\n-        this.connectivityMode = CcmConnectivityMode.CCMV1;\n     }\n \n     public CcmConnectivityParameters(CcmV2Parameters ccmV2Parameters) {\n         this.ccmV2Parameters = ccmV2Parameters;\n-        this.connectivityMode = CcmConnectivityMode.CCMV2;\n     }\n \n-    public CcmConnectivityParameters(CcmConnectivityMode connectivityMode) {\n-        this.connectivityMode = connectivityMode;\n+    public CcmConnectivityParameters() {\n     }\n \n     public CcmParameters getCcmParameters() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MDE2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551260168", "bodyText": "I think the tunnel should have a new value, CCMv2 and only if that is chosen should we go with CCMv2. This would ensure that old envs with CCMv1 would still start datahubs with it, even if the account has v2 enabled. It would be a bad idea to mix CCM versions in environments on the first run", "author": "lacikaaa", "createdAt": "2021-01-04T11:24:35Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java", "diffHunk": "@@ -99,7 +106,9 @@ public boolean isCreateConfigForClusterProxy(Stack stack) {\n     }\n \n     private void registerGateway(Stack stack) {\n-        ConfigUpdateRequest request = new ConfigUpdateRequest(stack.getResourceCrn(), knoxUrl(stack));\n+        String knoxUrl = stack.getTunnel().useCcm() && entitlementService.ccmV2Enabled(getAccountId(stack)) ?", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMjQwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552512404", "bodyText": "agree . have made this change throughout. only while creating environment if \"enableTunnel\" is chosen, based on account entitlement CCMV1 or CCMV2 is initialized for environment. In all other places only tunnel value CCMV1 or CCMV2 is used.", "author": "smaniraju", "createdAt": "2021-01-06T11:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MDE2OA=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java b/core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java\nindex 0ecd08de69..f67f0a797f 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java\n\n@@ -106,8 +102,7 @@ public class ClusterProxyService {\n     }\n \n     private void registerGateway(Stack stack) {\n-        String knoxUrl = stack.getTunnel().useCcm() && entitlementService.ccmV2Enabled(getAccountId(stack)) ?\n-                knoxUrlForCcmV2(stack) : knoxUrl(stack);\n+        String knoxUrl = stack.getTunnel().useCcmV2() ? knoxUrlForCcmV2(stack) : knoxUrl(stack);\n         ConfigUpdateRequest request = new ConfigUpdateRequest(stack.getResourceCrn(), knoxUrl);\n         clusterProxyRegistrationClient.updateConfig(request);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MTkxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551261912", "bodyText": "CcmKeyDeregisterRequest should have Tunnel field instead of the boolean as it's already deprecated. The logic should depend on this value here", "author": "lacikaaa", "createdAt": "2021-01-04T11:28:20Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/recipe/CcmKeyDeregisterHandler.java", "diffHunk": "@@ -34,24 +36,32 @@\n     @Inject\n     private CcmResourceTerminationListener ccmResourceTerminationListener;\n \n+    @Inject\n+    private CcmV2AgentTerminationListener ccmV2AgentTerminationListener;\n+\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n     @Override\n     public void accept(Event<CcmKeyDeregisterRequest> requestEvent) {\n         CcmKeyDeregisterRequest request = requestEvent.getData();\n         Selectable result;\n         try {\n             Stack stack = stackService.getByIdWithListsInTransaction(request.getResourceId());\n             if (Boolean.TRUE.equals(request.getUseCcm())) {\n-                LOGGER.debug(\"De-registering key from CCM. Cluster CRN: {}\",\n-                        stack.getResourceCrn());\n+                LOGGER.debug(\"De-registering key from CCM. Cluster CRN: {}\", stack.getResourceCrn());\n                 try {\n-                    ccmResourceTerminationListener.deregisterCcmSshTunnelingKey(request.getActorCrn(), request.getAccountId(), request.getKeyId(),\n-                            stack.getMinaSshdServiceId());\n+                    if (!entitlementService.ccmV2Enabled(request.getAccountId())) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/recipe/CcmKeyDeregisterHandler.java b/core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/recipe/CcmKeyDeregisterHandler.java\nindex 4506c08f2e..60094d11df 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/recipe/CcmKeyDeregisterHandler.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/recipe/CcmKeyDeregisterHandler.java\n\n@@ -39,29 +38,27 @@ public class CcmKeyDeregisterHandler implements EventHandler<CcmKeyDeregisterReq\n     @Inject\n     private CcmV2AgentTerminationListener ccmV2AgentTerminationListener;\n \n-    @Inject\n-    private EntitlementService entitlementService;\n-\n     @Override\n     public void accept(Event<CcmKeyDeregisterRequest> requestEvent) {\n         CcmKeyDeregisterRequest request = requestEvent.getData();\n         Selectable result;\n         try {\n             Stack stack = stackService.getByIdWithListsInTransaction(request.getResourceId());\n-            if (Boolean.TRUE.equals(request.getUseCcm())) {\n-                LOGGER.debug(\"De-registering key from CCM. Cluster CRN: {}\", stack.getResourceCrn());\n-                try {\n-                    if (!entitlementService.ccmV2Enabled(request.getAccountId())) {\n-                        ccmResourceTerminationListener.deregisterCcmSshTunnelingKey(request.getActorCrn(), request.getAccountId(), request.getKeyId(),\n-                                stack.getMinaSshdServiceId());\n-                    } else {\n-                        ccmV2AgentTerminationListener.deregisterInvertingProxyAgent(stack.getCcmV2AgentCrn());\n-                    }\n-                } catch (Exception ex) {\n-                    LOGGER.warn(\"CCM key deregistration failed\", ex);\n+            try {\n+                if (request.getTunnel().useCcmV1()) {\n+                    LOGGER.debug(\"De-registering MinaSshdServiceId '{}' from CCM. Cluster CRN: {}\", stack.getMinaSshdServiceId(), stack.getResourceCrn());\n+                    ccmResourceTerminationListener.deregisterCcmSshTunnelingKey(request.getActorCrn(), request.getAccountId(), request.getKeyId(),\n+                            stack.getMinaSshdServiceId());\n+                    LOGGER.debug(\"De-registered MinaSshdServiceId '{}' from CCM. Cluster CRN: {}\", stack.getMinaSshdServiceId(), stack.getResourceCrn());\n+                } else if (request.getTunnel().useCcmV2()) {\n+                    LOGGER.debug(\"De-registering CcmV2AgentCrn '{}' from CCM. Cluster CRN: {}\", stack.getCcmV2AgentCrn(), stack.getResourceCrn());\n+                    ccmV2AgentTerminationListener.deregisterInvertingProxyAgent(stack.getCcmV2AgentCrn());\n+                    LOGGER.debug(\"De-registered CcmV2AgentCrn '{}' from CCM. Cluster CRN: {}\", stack.getCcmV2AgentCrn(), stack.getResourceCrn());\n+                } else {\n+                    LOGGER.debug(\"CCM is DISABLED, skipping de-registering of key from CCM. Cluster CRN: {}\", stack.getResourceCrn());\n                 }\n-            } else {\n-                LOGGER.info(\"CCM is DISABLED, skipping de-registering of key from CCM. Cluster CRN: {}\", stack.getResourceCrn());\n+            } catch (Exception ex) {\n+                LOGGER.warn(\"CCM key deregistration failed\", ex);\n             }\n             result = new CcmKeyDeregisterSuccess(stack.getId());\n         } catch (Exception ex) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MzUyNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551263526", "bodyText": "this would change the current behavior, as we set CcmParameterConstants.CCM_ENABLED_KEY to false if CCM is not enabled, but with this change we won't set it anymore. Are you sure it won't break anything?", "author": "lacikaaa", "createdAt": "2021-01-04T11:32:04Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataBuilder.java", "diffHunk": "@@ -61,11 +64,19 @@ private String build(InstanceGroupType type, Platform cloudPlatform, byte[] cbSs\n         model.put(\"customUserData\", userDataBuilderParams.getCustomData());\n         model.put(\"saltBootPassword\", saltBootPassword);\n         model.put(\"cbCert\", cbCert);\n-        CcmParameters.addToTemplateModel(type, ccmParameters, model);\n+        extendModelWithCcmConnectivity(type, ccmConnectivityParameters, model);\n         extendModelWithProxyParams(type, proxyConfig, model);\n         return build(model);\n     }\n \n+    private void extendModelWithCcmConnectivity(InstanceGroupType type, CcmConnectivityParameters ccmConnectivityParameters, Map<String, Object> model) {\n+        if (CcmConnectivityMode.CCMV1.equals(ccmConnectivityParameters.getConnectivityMode())) {\n+            CcmParameters.addToTemplateModel(type, ccmConnectivityParameters.getCcmParameters(), model);\n+        } else if (CcmConnectivityMode.CCMV2.equals(ccmConnectivityParameters.getConnectivityMode())) {\n+            CcmV2Parameters.addToTemplateModel(type, ccmConnectivityParameters.getCcmV2Parameters(), model);\n+        }", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMzg0Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552513842", "bodyText": "Yes the ftl templates only initialize CCM variables if CCM_ENABLED_KEY is initialized to true and not null. There is already a unit test in UserDataBuilder for this. But for clarity I also added CCM_ENABLED_KEY and CCM_V2_ENABLED_KEY as false when CCM is not enabled.", "author": "smaniraju", "createdAt": "2021-01-06T11:13:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MzUyNg=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataBuilder.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataBuilder.java\nindex 3ecf5ce715..c4bcfdb254 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataBuilder.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataBuilder.java\n\n@@ -74,6 +76,9 @@ public class UserDataBuilder {\n             CcmParameters.addToTemplateModel(type, ccmConnectivityParameters.getCcmParameters(), model);\n         } else if (CcmConnectivityMode.CCMV2.equals(ccmConnectivityParameters.getConnectivityMode())) {\n             CcmV2Parameters.addToTemplateModel(type, ccmConnectivityParameters.getCcmV2Parameters(), model);\n+        } else {\n+            model.put(CcmParameterConstants.CCM_ENABLED_KEY, Boolean.FALSE);\n+            model.put(CcmV2ParameterConstants.CCM_V2_ENABLED_KEY, Boolean.FALSE);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2NzA5NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551267094", "bodyText": "these should ensure that the parameters are not null so we can be sure later if we have eg CCMV1 set, then ccmParameters can't be null. The other way around, if we don't store CcmConnectivityMode, but the getter would calculate it from the fields. If none set then it's NONE, etc.", "author": "lacikaaa", "createdAt": "2021-01-04T11:39:56Z", "path": "common/src/main/java/com/sequenceiq/cloudbreak/ccm/cloudinit/CcmConnectivityParameters.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.sequenceiq.cloudbreak.ccm.cloudinit;\n+\n+public class CcmConnectivityParameters {\n+\n+    private CcmParameters ccmParameters;\n+\n+    private CcmV2Parameters ccmV2Parameters;\n+\n+    private CcmConnectivityMode connectivityMode;\n+\n+    public CcmConnectivityParameters(CcmParameters ccmParameters) {\n+        this.ccmParameters = ccmParameters;\n+        this.connectivityMode = CcmConnectivityMode.CCMV1;\n+    }\n+\n+    public CcmConnectivityParameters(CcmV2Parameters ccmV2Parameters) {\n+        this.ccmV2Parameters = ccmV2Parameters;\n+        this.connectivityMode = CcmConnectivityMode.CCMV2;\n+    }", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMTIzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552511237", "bodyText": "ok updated code to not store CcmConnectivityMode and calculate it from fields", "author": "smaniraju", "createdAt": "2021-01-06T11:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2NzA5NA=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/common/src/main/java/com/sequenceiq/cloudbreak/ccm/cloudinit/CcmConnectivityParameters.java b/common/src/main/java/com/sequenceiq/cloudbreak/ccm/cloudinit/CcmConnectivityParameters.java\nindex ae4ec639be..5bfbddb97b 100644\n--- a/common/src/main/java/com/sequenceiq/cloudbreak/ccm/cloudinit/CcmConnectivityParameters.java\n+++ b/common/src/main/java/com/sequenceiq/cloudbreak/ccm/cloudinit/CcmConnectivityParameters.java\n\n@@ -6,20 +6,15 @@ public class CcmConnectivityParameters {\n \n     private CcmV2Parameters ccmV2Parameters;\n \n-    private CcmConnectivityMode connectivityMode;\n-\n     public CcmConnectivityParameters(CcmParameters ccmParameters) {\n         this.ccmParameters = ccmParameters;\n-        this.connectivityMode = CcmConnectivityMode.CCMV1;\n     }\n \n     public CcmConnectivityParameters(CcmV2Parameters ccmV2Parameters) {\n         this.ccmV2Parameters = ccmV2Parameters;\n-        this.connectivityMode = CcmConnectivityMode.CCMV2;\n     }\n \n-    public CcmConnectivityParameters(CcmConnectivityMode connectivityMode) {\n-        this.connectivityMode = connectivityMode;\n+    public CcmConnectivityParameters() {\n     }\n \n     public CcmParameters getCcmParameters() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2ODM5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551268391", "bodyText": "this method should be moved to a separate class and refactored into smaller ones, as it's pretty big, and already needs the @VisibleForTesting annotation", "author": "lacikaaa", "createdAt": "2021-01-04T11:43:13Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java", "diffHunk": "@@ -88,45 +105,71 @@ public void createUserData(Long stackId) throws CloudbreakImageNotFoundException\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            if (ccmParameters != null) {\n-                String minaSshdServiceId = ccmParameters.getServerParameters().getMinaSshdServiceId();\n-                if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                    LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                    stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-                }\n-            }\n+            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n \n-    private CcmParameters fetchCcmParameters(Stack stack) {\n-        CcmParameters ccmParameters = null;\n-        if ((ccmParameterSupplier != null) && stack.getTunnel().useCcm()) {\n-            ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n-            int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-            builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-\n-            // Optionally configure a tunnel for (nginx fronting) Knox\n-            if (stack.getCluster().getGateway() != null) {\n-                // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n-                builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n-            }\n-\n-            Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n-\n+    @VisibleForTesting\n+    CcmConnectivityParameters fetchCcmParameters(Stack stack) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxNDAxMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552514013", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2ODM5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\nindex eb833d89b7..52e20ca453 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\n\n@@ -105,71 +80,14 @@ public class UserDataService {\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = ccmUserDataService.fetchAndSaveCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n-\n-    @VisibleForTesting\n-    CcmConnectivityParameters fetchCcmParameters(Stack stack) {\n-        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters(CcmConnectivityMode.NONE);\n-        if (stack.getTunnel().useCcm()) {\n-            String accountId = ThreadBasedUserCrnProvider.getAccountId();\n-            String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n-            String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n-            String actorCrn = Objects.requireNonNull(userCrn, \"userCrn is null\");\n-\n-            if (!entitlementService.ccmV2Enabled(accountId)) {\n-                ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n-                int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-                builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-\n-                // Optionally configure a tunnel for (nginx fronting) Knox\n-                if (stack.getCluster().getGateway() != null) {\n-                    // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n-                    builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n-                }\n-\n-                Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n-                CcmParameters ccmV1Parameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n-                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n-            } else {\n-                String gatewayHostName = hostDiscoveryService.generateHostname(stack.getCustomHostname(),\n-                        stack.getGatewayHostGroup().map(InstanceGroup::getGroupName).orElse(\"\"), 0L,\n-                        stack.isClusterNameAsSubdomain());\n-                String stackDomain = hostDiscoveryService.determineDomain(stack.getCustomDomain(), stack.getName(), stack.isClusterNameAsSubdomain());\n-                String generatedClusterDomain = hostDiscoveryService.determineDefaultDomainForStack(gatewayHostName, stackDomain);\n-\n-                CcmV2Parameters ccmV2Parameters = ccmV2ParameterSupplier.getCcmV2Parameters(accountId, generatedClusterDomain, keyId);\n-                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV2Parameters);\n-            }\n-        }\n-        return ccmConnectivityParameters;\n-    }\n-\n-    @VisibleForTesting\n-    void saveStackCCMParameters(Stack stack, CcmConnectivityParameters ccmConnectivityParameters) {\n-        long stackId = stack.getId();\n-        if (CcmConnectivityMode.CCMV1.equals(ccmConnectivityParameters.getConnectivityMode())\n-                && ccmConnectivityParameters.getCcmParameters() != null) {\n-            String minaSshdServiceId = ccmConnectivityParameters.getCcmParameters().getServerParameters().getMinaSshdServiceId();\n-            if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-            }\n-        } else if (CcmConnectivityMode.CCMV2.equals(ccmConnectivityParameters.getConnectivityMode())\n-                && ccmConnectivityParameters.getCcmV2Parameters() != null) {\n-            CcmV2Parameters ccmV2Parameters = ccmConnectivityParameters.getCcmV2Parameters();\n-            stackService.setCcmV2AgentCrnByStackId(stackId, ccmV2Parameters.getAgentCrn());\n-        } else {\n-            LOGGER.debug(\"CCM not configured for stack '{}'\", stack.getResourceCrn());\n-        }\n-    }\n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2ODcwOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551268708", "bodyText": "logic should be handled here by tunnel type and not by entitlement", "author": "lacikaaa", "createdAt": "2021-01-04T11:43:56Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java", "diffHunk": "@@ -88,45 +105,71 @@ public void createUserData(Long stackId) throws CloudbreakImageNotFoundException\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            if (ccmParameters != null) {\n-                String minaSshdServiceId = ccmParameters.getServerParameters().getMinaSshdServiceId();\n-                if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                    LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                    stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-                }\n-            }\n+            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n \n-    private CcmParameters fetchCcmParameters(Stack stack) {\n-        CcmParameters ccmParameters = null;\n-        if ((ccmParameterSupplier != null) && stack.getTunnel().useCcm()) {\n-            ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n-            int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-            builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-\n-            // Optionally configure a tunnel for (nginx fronting) Knox\n-            if (stack.getCluster().getGateway() != null) {\n-                // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n-                builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n-            }\n-\n-            Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n-\n+    @VisibleForTesting\n+    CcmConnectivityParameters fetchCcmParameters(Stack stack) {\n+        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters(CcmConnectivityMode.NONE);\n+        if (stack.getTunnel().useCcm()) {\n             String accountId = ThreadBasedUserCrnProvider.getAccountId();\n             String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n             String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n             String actorCrn = Objects.requireNonNull(userCrn, \"userCrn is null\");\n-            ccmParameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n+\n+            if (!entitlementService.ccmV2Enabled(accountId)) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxNTk1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552515953", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:18:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2ODcwOA=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\nindex eb833d89b7..52e20ca453 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\n\n@@ -105,71 +80,14 @@ public class UserDataService {\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = ccmUserDataService.fetchAndSaveCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n-\n-    @VisibleForTesting\n-    CcmConnectivityParameters fetchCcmParameters(Stack stack) {\n-        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters(CcmConnectivityMode.NONE);\n-        if (stack.getTunnel().useCcm()) {\n-            String accountId = ThreadBasedUserCrnProvider.getAccountId();\n-            String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n-            String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n-            String actorCrn = Objects.requireNonNull(userCrn, \"userCrn is null\");\n-\n-            if (!entitlementService.ccmV2Enabled(accountId)) {\n-                ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n-                int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-                builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-\n-                // Optionally configure a tunnel for (nginx fronting) Knox\n-                if (stack.getCluster().getGateway() != null) {\n-                    // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n-                    builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n-                }\n-\n-                Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n-                CcmParameters ccmV1Parameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n-                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n-            } else {\n-                String gatewayHostName = hostDiscoveryService.generateHostname(stack.getCustomHostname(),\n-                        stack.getGatewayHostGroup().map(InstanceGroup::getGroupName).orElse(\"\"), 0L,\n-                        stack.isClusterNameAsSubdomain());\n-                String stackDomain = hostDiscoveryService.determineDomain(stack.getCustomDomain(), stack.getName(), stack.isClusterNameAsSubdomain());\n-                String generatedClusterDomain = hostDiscoveryService.determineDefaultDomainForStack(gatewayHostName, stackDomain);\n-\n-                CcmV2Parameters ccmV2Parameters = ccmV2ParameterSupplier.getCcmV2Parameters(accountId, generatedClusterDomain, keyId);\n-                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV2Parameters);\n-            }\n-        }\n-        return ccmConnectivityParameters;\n-    }\n-\n-    @VisibleForTesting\n-    void saveStackCCMParameters(Stack stack, CcmConnectivityParameters ccmConnectivityParameters) {\n-        long stackId = stack.getId();\n-        if (CcmConnectivityMode.CCMV1.equals(ccmConnectivityParameters.getConnectivityMode())\n-                && ccmConnectivityParameters.getCcmParameters() != null) {\n-            String minaSshdServiceId = ccmConnectivityParameters.getCcmParameters().getServerParameters().getMinaSshdServiceId();\n-            if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-            }\n-        } else if (CcmConnectivityMode.CCMV2.equals(ccmConnectivityParameters.getConnectivityMode())\n-                && ccmConnectivityParameters.getCcmV2Parameters() != null) {\n-            CcmV2Parameters ccmV2Parameters = ccmConnectivityParameters.getCcmV2Parameters();\n-            stackService.setCcmV2AgentCrnByStackId(stackId, ccmV2Parameters.getAgentCrn());\n-        } else {\n-            LOGGER.debug(\"CCM not configured for stack '{}'\", stack.getResourceCrn());\n-        }\n-    }\n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2OTE5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551269197", "bodyText": "stack id should be enough here as that's the only part you use. Crn is already should be added to MdcContext, logging it again is not necessary.", "author": "lacikaaa", "createdAt": "2021-01-04T11:45:04Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java", "diffHunk": "@@ -88,45 +105,71 @@ public void createUserData(Long stackId) throws CloudbreakImageNotFoundException\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            if (ccmParameters != null) {\n-                String minaSshdServiceId = ccmParameters.getServerParameters().getMinaSshdServiceId();\n-                if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                    LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                    stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-                }\n-            }\n+            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n \n-    private CcmParameters fetchCcmParameters(Stack stack) {\n-        CcmParameters ccmParameters = null;\n-        if ((ccmParameterSupplier != null) && stack.getTunnel().useCcm()) {\n-            ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n-            int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-            builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-\n-            // Optionally configure a tunnel for (nginx fronting) Knox\n-            if (stack.getCluster().getGateway() != null) {\n-                // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n-                builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n-            }\n-\n-            Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n-\n+    @VisibleForTesting\n+    CcmConnectivityParameters fetchCcmParameters(Stack stack) {\n+        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters(CcmConnectivityMode.NONE);\n+        if (stack.getTunnel().useCcm()) {\n             String accountId = ThreadBasedUserCrnProvider.getAccountId();\n             String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n             String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n             String actorCrn = Objects.requireNonNull(userCrn, \"userCrn is null\");\n-            ccmParameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n+\n+            if (!entitlementService.ccmV2Enabled(accountId)) {\n+                ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n+                int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n+                builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n+\n+                // Optionally configure a tunnel for (nginx fronting) Knox\n+                if (stack.getCluster().getGateway() != null) {\n+                    // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n+                    builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n+                }\n+\n+                Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n+                CcmParameters ccmV1Parameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n+                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n+            } else {\n+                String gatewayHostName = hostDiscoveryService.generateHostname(stack.getCustomHostname(),\n+                        stack.getGatewayHostGroup().map(InstanceGroup::getGroupName).orElse(\"\"), 0L,\n+                        stack.isClusterNameAsSubdomain());\n+                String stackDomain = hostDiscoveryService.determineDomain(stack.getCustomDomain(), stack.getName(), stack.isClusterNameAsSubdomain());\n+                String generatedClusterDomain = hostDiscoveryService.determineDefaultDomainForStack(gatewayHostName, stackDomain);\n+\n+                CcmV2Parameters ccmV2Parameters = ccmV2ParameterSupplier.getCcmV2Parameters(accountId, generatedClusterDomain, keyId);\n+                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV2Parameters);\n+            }\n+        }\n+        return ccmConnectivityParameters;\n+    }\n+\n+    @VisibleForTesting\n+    void saveStackCCMParameters(Stack stack, CcmConnectivityParameters ccmConnectivityParameters) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxNjExNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552516114", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2OTE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\nindex eb833d89b7..52e20ca453 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\n\n@@ -105,71 +80,14 @@ public class UserDataService {\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = ccmUserDataService.fetchAndSaveCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n-\n-    @VisibleForTesting\n-    CcmConnectivityParameters fetchCcmParameters(Stack stack) {\n-        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters(CcmConnectivityMode.NONE);\n-        if (stack.getTunnel().useCcm()) {\n-            String accountId = ThreadBasedUserCrnProvider.getAccountId();\n-            String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n-            String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n-            String actorCrn = Objects.requireNonNull(userCrn, \"userCrn is null\");\n-\n-            if (!entitlementService.ccmV2Enabled(accountId)) {\n-                ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n-                int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-                builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-\n-                // Optionally configure a tunnel for (nginx fronting) Knox\n-                if (stack.getCluster().getGateway() != null) {\n-                    // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n-                    builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n-                }\n-\n-                Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n-                CcmParameters ccmV1Parameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n-                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n-            } else {\n-                String gatewayHostName = hostDiscoveryService.generateHostname(stack.getCustomHostname(),\n-                        stack.getGatewayHostGroup().map(InstanceGroup::getGroupName).orElse(\"\"), 0L,\n-                        stack.isClusterNameAsSubdomain());\n-                String stackDomain = hostDiscoveryService.determineDomain(stack.getCustomDomain(), stack.getName(), stack.isClusterNameAsSubdomain());\n-                String generatedClusterDomain = hostDiscoveryService.determineDefaultDomainForStack(gatewayHostName, stackDomain);\n-\n-                CcmV2Parameters ccmV2Parameters = ccmV2ParameterSupplier.getCcmV2Parameters(accountId, generatedClusterDomain, keyId);\n-                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV2Parameters);\n-            }\n-        }\n-        return ccmConnectivityParameters;\n-    }\n-\n-    @VisibleForTesting\n-    void saveStackCCMParameters(Stack stack, CcmConnectivityParameters ccmConnectivityParameters) {\n-        long stackId = stack.getId();\n-        if (CcmConnectivityMode.CCMV1.equals(ccmConnectivityParameters.getConnectivityMode())\n-                && ccmConnectivityParameters.getCcmParameters() != null) {\n-            String minaSshdServiceId = ccmConnectivityParameters.getCcmParameters().getServerParameters().getMinaSshdServiceId();\n-            if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-            }\n-        } else if (CcmConnectivityMode.CCMV2.equals(ccmConnectivityParameters.getConnectivityMode())\n-                && ccmConnectivityParameters.getCcmV2Parameters() != null) {\n-            CcmV2Parameters ccmV2Parameters = ccmConnectivityParameters.getCcmV2Parameters();\n-            stackService.setCcmV2AgentCrnByStackId(stackId, ccmV2Parameters.getAgentCrn());\n-        } else {\n-            LOGGER.debug(\"CCM not configured for stack '{}'\", stack.getResourceCrn());\n-        }\n-    }\n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2OTY5OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551269698", "bodyText": "if you modify the CcmConnectivityParameters implementation (and ensure it via unit tests) you could skip null check here", "author": "lacikaaa", "createdAt": "2021-01-04T11:46:10Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java", "diffHunk": "@@ -88,45 +105,71 @@ public void createUserData(Long stackId) throws CloudbreakImageNotFoundException\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            if (ccmParameters != null) {\n-                String minaSshdServiceId = ccmParameters.getServerParameters().getMinaSshdServiceId();\n-                if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                    LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                    stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-                }\n-            }\n+            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n \n-    private CcmParameters fetchCcmParameters(Stack stack) {\n-        CcmParameters ccmParameters = null;\n-        if ((ccmParameterSupplier != null) && stack.getTunnel().useCcm()) {\n-            ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n-            int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-            builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-\n-            // Optionally configure a tunnel for (nginx fronting) Knox\n-            if (stack.getCluster().getGateway() != null) {\n-                // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n-                builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n-            }\n-\n-            Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n-\n+    @VisibleForTesting\n+    CcmConnectivityParameters fetchCcmParameters(Stack stack) {\n+        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters(CcmConnectivityMode.NONE);\n+        if (stack.getTunnel().useCcm()) {\n             String accountId = ThreadBasedUserCrnProvider.getAccountId();\n             String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n             String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n             String actorCrn = Objects.requireNonNull(userCrn, \"userCrn is null\");\n-            ccmParameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n+\n+            if (!entitlementService.ccmV2Enabled(accountId)) {\n+                ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n+                int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n+                builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n+\n+                // Optionally configure a tunnel for (nginx fronting) Knox\n+                if (stack.getCluster().getGateway() != null) {\n+                    // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n+                    builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n+                }\n+\n+                Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n+                CcmParameters ccmV1Parameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n+                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n+            } else {\n+                String gatewayHostName = hostDiscoveryService.generateHostname(stack.getCustomHostname(),\n+                        stack.getGatewayHostGroup().map(InstanceGroup::getGroupName).orElse(\"\"), 0L,\n+                        stack.isClusterNameAsSubdomain());\n+                String stackDomain = hostDiscoveryService.determineDomain(stack.getCustomDomain(), stack.getName(), stack.isClusterNameAsSubdomain());\n+                String generatedClusterDomain = hostDiscoveryService.determineDefaultDomainForStack(gatewayHostName, stackDomain);\n+\n+                CcmV2Parameters ccmV2Parameters = ccmV2ParameterSupplier.getCcmV2Parameters(accountId, generatedClusterDomain, keyId);\n+                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV2Parameters);\n+            }\n+        }\n+        return ccmConnectivityParameters;\n+    }\n+\n+    @VisibleForTesting\n+    void saveStackCCMParameters(Stack stack, CcmConnectivityParameters ccmConnectivityParameters) {\n+        long stackId = stack.getId();\n+        if (CcmConnectivityMode.CCMV1.equals(ccmConnectivityParameters.getConnectivityMode())\n+                && ccmConnectivityParameters.getCcmParameters() != null) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxNzA3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552517074", "bodyText": "removed null check and added unit tests", "author": "smaniraju", "createdAt": "2021-01-06T11:21:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2OTY5OA=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\nindex eb833d89b7..52e20ca453 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\n\n@@ -105,71 +80,14 @@ public class UserDataService {\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = ccmUserDataService.fetchAndSaveCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n-\n-    @VisibleForTesting\n-    CcmConnectivityParameters fetchCcmParameters(Stack stack) {\n-        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters(CcmConnectivityMode.NONE);\n-        if (stack.getTunnel().useCcm()) {\n-            String accountId = ThreadBasedUserCrnProvider.getAccountId();\n-            String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n-            String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n-            String actorCrn = Objects.requireNonNull(userCrn, \"userCrn is null\");\n-\n-            if (!entitlementService.ccmV2Enabled(accountId)) {\n-                ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n-                int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-                builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-\n-                // Optionally configure a tunnel for (nginx fronting) Knox\n-                if (stack.getCluster().getGateway() != null) {\n-                    // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n-                    builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n-                }\n-\n-                Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n-                CcmParameters ccmV1Parameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n-                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n-            } else {\n-                String gatewayHostName = hostDiscoveryService.generateHostname(stack.getCustomHostname(),\n-                        stack.getGatewayHostGroup().map(InstanceGroup::getGroupName).orElse(\"\"), 0L,\n-                        stack.isClusterNameAsSubdomain());\n-                String stackDomain = hostDiscoveryService.determineDomain(stack.getCustomDomain(), stack.getName(), stack.isClusterNameAsSubdomain());\n-                String generatedClusterDomain = hostDiscoveryService.determineDefaultDomainForStack(gatewayHostName, stackDomain);\n-\n-                CcmV2Parameters ccmV2Parameters = ccmV2ParameterSupplier.getCcmV2Parameters(accountId, generatedClusterDomain, keyId);\n-                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV2Parameters);\n-            }\n-        }\n-        return ccmConnectivityParameters;\n-    }\n-\n-    @VisibleForTesting\n-    void saveStackCCMParameters(Stack stack, CcmConnectivityParameters ccmConnectivityParameters) {\n-        long stackId = stack.getId();\n-        if (CcmConnectivityMode.CCMV1.equals(ccmConnectivityParameters.getConnectivityMode())\n-                && ccmConnectivityParameters.getCcmParameters() != null) {\n-            String minaSshdServiceId = ccmConnectivityParameters.getCcmParameters().getServerParameters().getMinaSshdServiceId();\n-            if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-            }\n-        } else if (CcmConnectivityMode.CCMV2.equals(ccmConnectivityParameters.getConnectivityMode())\n-                && ccmConnectivityParameters.getCcmV2Parameters() != null) {\n-            CcmV2Parameters ccmV2Parameters = ccmConnectivityParameters.getCcmV2Parameters();\n-            stackService.setCcmV2AgentCrnByStackId(stackId, ccmV2Parameters.getAgentCrn());\n-        } else {\n-            LOGGER.debug(\"CCM not configured for stack '{}'\", stack.getResourceCrn());\n-        }\n-    }\n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MTMxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551271317", "bodyText": "if you move the save next to the fetch, they might be moved out together and handled together. Also you might save some if condition regarding checking if it's CCMv1 or v2", "author": "lacikaaa", "createdAt": "2021-01-04T11:49:53Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java", "diffHunk": "@@ -88,45 +105,71 @@ public void createUserData(Long stackId) throws CloudbreakImageNotFoundException\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            if (ccmParameters != null) {\n-                String minaSshdServiceId = ccmParameters.getServerParameters().getMinaSshdServiceId();\n-                if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                    LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                    stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-                }\n-            }\n+            saveStackCCMParameters(stack, ccmParameters);", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMzk2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552513964", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MTMxNw=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\nindex eb833d89b7..52e20ca453 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java\n\n@@ -105,71 +80,14 @@ public class UserDataService {\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = ccmUserDataService.fetchAndSaveCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n-\n-    @VisibleForTesting\n-    CcmConnectivityParameters fetchCcmParameters(Stack stack) {\n-        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters(CcmConnectivityMode.NONE);\n-        if (stack.getTunnel().useCcm()) {\n-            String accountId = ThreadBasedUserCrnProvider.getAccountId();\n-            String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n-            String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n-            String actorCrn = Objects.requireNonNull(userCrn, \"userCrn is null\");\n-\n-            if (!entitlementService.ccmV2Enabled(accountId)) {\n-                ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n-                int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-                builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-\n-                // Optionally configure a tunnel for (nginx fronting) Knox\n-                if (stack.getCluster().getGateway() != null) {\n-                    // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n-                    builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n-                }\n-\n-                Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n-                CcmParameters ccmV1Parameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n-                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n-            } else {\n-                String gatewayHostName = hostDiscoveryService.generateHostname(stack.getCustomHostname(),\n-                        stack.getGatewayHostGroup().map(InstanceGroup::getGroupName).orElse(\"\"), 0L,\n-                        stack.isClusterNameAsSubdomain());\n-                String stackDomain = hostDiscoveryService.determineDomain(stack.getCustomDomain(), stack.getName(), stack.isClusterNameAsSubdomain());\n-                String generatedClusterDomain = hostDiscoveryService.determineDefaultDomainForStack(gatewayHostName, stackDomain);\n-\n-                CcmV2Parameters ccmV2Parameters = ccmV2ParameterSupplier.getCcmV2Parameters(accountId, generatedClusterDomain, keyId);\n-                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV2Parameters);\n-            }\n-        }\n-        return ccmConnectivityParameters;\n-    }\n-\n-    @VisibleForTesting\n-    void saveStackCCMParameters(Stack stack, CcmConnectivityParameters ccmConnectivityParameters) {\n-        long stackId = stack.getId();\n-        if (CcmConnectivityMode.CCMV1.equals(ccmConnectivityParameters.getConnectivityMode())\n-                && ccmConnectivityParameters.getCcmParameters() != null) {\n-            String minaSshdServiceId = ccmConnectivityParameters.getCcmParameters().getServerParameters().getMinaSshdServiceId();\n-            if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-            }\n-        } else if (CcmConnectivityMode.CCMV2.equals(ccmConnectivityParameters.getConnectivityMode())\n-                && ccmConnectivityParameters.getCcmV2Parameters() != null) {\n-            CcmV2Parameters ccmV2Parameters = ccmConnectivityParameters.getCcmV2Parameters();\n-            stackService.setCcmV2AgentCrnByStackId(stackId, ccmV2Parameters.getAgentCrn());\n-        } else {\n-            LOGGER.debug(\"CCM not configured for stack '{}'\", stack.getResourceCrn());\n-        }\n-    }\n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MzQyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551273421", "bodyText": "the same for this request, include tunnel instead if boolean", "author": "lacikaaa", "createdAt": "2021-01-04T11:54:44Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/stack/termination/event/ccm/CcmKeyDeregistrationRequest.java", "diffHunk": "@@ -17,14 +17,18 @@\n \n     private final String minaSshdServiceId;\n \n+    private final String ccmV2AgentCrn;\n+\n+    @SuppressWarnings(\"ExecutableStatementCount\")\n     public CcmKeyDeregistrationRequest(Long stackId, Boolean forced, String actorCrn, String accountId, String keyId, Boolean useCcm,\n-            String minaSshdServiceId) {\n+            String minaSshdServiceId, String ccmV2AgentCrn) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUyMjQxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552522417", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MzQyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/flow/stack/termination/event/ccm/CcmKeyDeregistrationRequest.java b/freeipa/src/main/java/com/sequenceiq/freeipa/flow/stack/termination/event/ccm/CcmKeyDeregistrationRequest.java\nindex f9407f4f70..5f7f89daeb 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/flow/stack/termination/event/ccm/CcmKeyDeregistrationRequest.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/flow/stack/termination/event/ccm/CcmKeyDeregistrationRequest.java\n\n@@ -13,20 +14,20 @@ public class CcmKeyDeregistrationRequest extends TerminationEvent {\n \n     private final String keyId;\n \n-    private final Boolean useCcm;\n+    private final Tunnel tunnel;\n \n     private final String minaSshdServiceId;\n \n     private final String ccmV2AgentCrn;\n \n     @SuppressWarnings(\"ExecutableStatementCount\")\n-    public CcmKeyDeregistrationRequest(Long stackId, Boolean forced, String actorCrn, String accountId, String keyId, Boolean useCcm,\n+    public CcmKeyDeregistrationRequest(Long stackId, Boolean forced, String actorCrn, String accountId, String keyId, Tunnel tunnel,\n             String minaSshdServiceId, String ccmV2AgentCrn) {\n         super(EventSelectorUtil.selector(CcmKeyDeregistrationRequest.class), stackId, forced);\n         this.actorCrn = Objects.requireNonNull(actorCrn, \"actorCrn is null\");\n         this.accountId = Objects.requireNonNull(accountId, \"accountId is null\");\n         this.keyId = Objects.requireNonNull(keyId, \"keyId is null\");\n-        this.useCcm = useCcm;\n+        this.tunnel = tunnel;\n         this.minaSshdServiceId = minaSshdServiceId;\n         this.ccmV2AgentCrn = ccmV2AgentCrn;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MzU3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551273575", "bodyText": "same for this handler. depend on tunnel, not on the entitlement", "author": "lacikaaa", "createdAt": "2021-01-04T11:55:09Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/stack/termination/handler/CcmKeyDeregistrationHandler.java", "diffHunk": "@@ -27,15 +29,25 @@\n     @Inject\n     private EventBus eventBus;\n \n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    @Inject\n+    private CcmV2AgentTerminationListener ccmV2AgentTerminationListener;\n+\n     @Override\n     public void accept(Event<CcmKeyDeregistrationRequest> requestEvent) {\n \n         CcmKeyDeregistrationRequest request = requestEvent.getData();\n         if (Boolean.TRUE.equals(request.getUseCcm())) {\n             LOGGER.debug(\"De-registering CCM key for freeipa stack {}\", request.getResourceId());\n             try {\n-                ccmResourceTerminationListener.deregisterCcmSshTunnelingKey(request.getActorCrn(), request.getAccountId(), request.getKeyId(),\n-                        request.getMinaSshdServiceId());\n+                if (!entitlementService.ccmV2Enabled(request.getAccountId())) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUyMTUxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552521517", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:32:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MzU3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/flow/stack/termination/handler/CcmKeyDeregistrationHandler.java b/freeipa/src/main/java/com/sequenceiq/freeipa/flow/stack/termination/handler/CcmKeyDeregistrationHandler.java\nindex 27bd78e866..98a8b144d0 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/flow/stack/termination/handler/CcmKeyDeregistrationHandler.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/flow/stack/termination/handler/CcmKeyDeregistrationHandler.java\n\n@@ -29,31 +28,27 @@ public class CcmKeyDeregistrationHandler implements EventHandler<CcmKeyDeregistr\n     @Inject\n     private EventBus eventBus;\n \n-    @Inject\n-    private EntitlementService entitlementService;\n-\n     @Inject\n     private CcmV2AgentTerminationListener ccmV2AgentTerminationListener;\n \n     @Override\n     public void accept(Event<CcmKeyDeregistrationRequest> requestEvent) {\n-\n         CcmKeyDeregistrationRequest request = requestEvent.getData();\n-        if (Boolean.TRUE.equals(request.getUseCcm())) {\n-            LOGGER.debug(\"De-registering CCM key for freeipa stack {}\", request.getResourceId());\n-            try {\n-                if (!entitlementService.ccmV2Enabled(request.getAccountId())) {\n-                    ccmResourceTerminationListener.deregisterCcmSshTunnelingKey(request.getActorCrn(), request.getAccountId(), request.getKeyId(),\n-                            request.getMinaSshdServiceId());\n-                } else {\n-                    ccmV2AgentTerminationListener.deregisterInvertingProxyAgent(request.getCcmV2AgentCrn());\n-                }\n-            } catch (Exception ex) {\n-                LOGGER.warn(\"CCM key de-registration failed\", ex);\n+        try {\n+            if (request.getTunnel().useCcmV1()) {\n+                LOGGER.debug(\"De-registering CCM key '{}' for freeipa stack '{}'\", request.getMinaSshdServiceId(), request.getResourceId());\n+                ccmResourceTerminationListener.deregisterCcmSshTunnelingKey(request.getActorCrn(), request.getAccountId(), request.getKeyId(),\n+                        request.getMinaSshdServiceId());\n+                LOGGER.debug(\"De-registered CCM key '{}' for freeipa stack '{}'\", request.getMinaSshdServiceId(), request.getResourceId());\n+            } else if (request.getTunnel().useCcmV2()) {\n+                LOGGER.debug(\"De-registering CCM V2 key '{}' for freeipa stack {}\", request.getCcmV2AgentCrn(), request.getResourceId());\n+                ccmV2AgentTerminationListener.deregisterInvertingProxyAgent(request.getCcmV2AgentCrn());\n+                LOGGER.debug(\"De-registered CCM V2 key '{}' for freeipa stack {}\", request.getCcmV2AgentCrn(), request.getResourceId());\n+            } else {\n+                LOGGER.debug(\"CCM is DISABLED, skipping de-registering of key from CCM. FreeIPA stack: {}\", request.getResourceId());\n             }\n-        } else {\n-            LOGGER.info(\"CCM is DISABLED, skipping de-registering of key from CCM. FreeIPA stack: {}\",\n-                    request.getResourceId());\n+        } catch (Exception ex) {\n+            LOGGER.warn(\"CCM key de-registration failed\", ex);\n         }\n \n         Selectable result = new CcmKeyDeregistrationFinished(request.getResourceId(), request.getForced());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3Mzk3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551273977", "bodyText": "the same question, would it break anything if you don't add CCMv1 false to the model?", "author": "lacikaaa", "createdAt": "2021-01-04T11:56:04Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/UserDataBuilder.java", "diffHunk": "@@ -56,11 +60,19 @@ private String build(Platform cloudPlatform, byte[] cbSshKeyDer, String sshUser,\n         model.put(\"customUserData\", userDataBuilderParams.getCustomData());\n         model.put(\"saltBootPassword\", saltBootPassword);\n         model.put(\"cbCert\", cbCert);\n-        CcmParameters.addToTemplateModel(InstanceGroupType.GATEWAY, ccmParameters, model);\n+        extendModelWithCcmConnectivity(InstanceGroupType.GATEWAY, ccmConnectivityParameters, model);\n         extendModelWithProxyParams(proxyConfig, model);\n         return build(model);\n     }\n \n+    private void extendModelWithCcmConnectivity(InstanceGroupType type, CcmConnectivityParameters ccmConnectivityParameters, Map<String, Object> model) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUyMjU5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552522593", "bodyText": "answered above and made same change here.", "author": "smaniraju", "createdAt": "2021-01-06T11:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3Mzk3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/UserDataBuilder.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/UserDataBuilder.java\nindex 06fddae434..c803ece5d5 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/UserDataBuilder.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/UserDataBuilder.java\n\n@@ -70,6 +72,9 @@ public class UserDataBuilder {\n             CcmParameters.addToTemplateModel(type, ccmConnectivityParameters.getCcmParameters(), model);\n         } else if (CcmConnectivityMode.CCMV2.equals(ccmConnectivityParameters.getConnectivityMode())) {\n             CcmV2Parameters.addToTemplateModel(type, ccmConnectivityParameters.getCcmV2Parameters(), model);\n+        } else {\n+            model.put(CcmParameterConstants.CCM_ENABLED_KEY, Boolean.FALSE);\n+            model.put(CcmV2ParameterConstants.CCM_V2_ENABLED_KEY, Boolean.FALSE);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3NDQyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551274423", "bodyText": "just a note to keep this in sync with the other after refactor", "author": "lacikaaa", "createdAt": "2021-01-04T11:56:59Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/UserDataService.java", "diffHunk": "@@ -88,34 +109,62 @@ public void createUserData(Long stackId) {\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             String userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer, sshUser, platformParameters,\n                     saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            if (ccmParameters != null) {\n-                String minaSshdServiceId = ccmParameters.getServerParameters().getMinaSshdServiceId();\n-                if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                    LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                    stack.setMinaSshdServiceId(minaSshdServiceId);\n-                    stackService.save(stack);\n-                }\n-            }\n+            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n \n-    private CcmParameters fetchCcmParameters(Stack stack) {\n-        CcmParameters ccmParameters = null;\n-        if ((ccmParameterSupplier != null) && stack.getTunnel().useCcm()) {\n+    @VisibleForTesting\n+    CcmConnectivityParameters fetchCcmParameters(Stack stack) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUyMjgyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552522821", "bodyText": "refactored here as done in other place.", "author": "smaniraju", "createdAt": "2021-01-06T11:35:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3NDQyMw=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/UserDataService.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/UserDataService.java\nindex 335b18d65a..098f764482 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/UserDataService.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/UserDataService.java\n\n@@ -109,62 +96,14 @@ public class UserDataService {\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = ccmUserDataService.fetchAndSaveCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             String userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer, sshUser, platformParameters,\n                     saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n-\n-    @VisibleForTesting\n-    CcmConnectivityParameters fetchCcmParameters(Stack stack) {\n-        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters(CcmConnectivityMode.NONE);\n-        if (stack.getTunnel().useCcm()) {\n-            int gatewayPort = Optional.ofNullable(stack.getGatewayport()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-            Map<KnownServiceIdentifier, Integer> tunneledServicePorts = Collections.singletonMap(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-            String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n-            String actorCrn = Objects.requireNonNull(crnService.getUserCrn(), \"userCrn is null\");\n-\n-            if (!entitlementService.ccmV2Enabled(stack.getAccountId())) {\n-                CcmParameters ccmV1Parameters = ccmParameterSupplier\n-                        .getCcmParameters(actorCrn, stack.getAccountId(), keyId, tunneledServicePorts)\n-                        .orElse(null);\n-                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n-            } else {\n-                FreeIpa freeIpa = freeIpaService.findByStack(stack);\n-                String gatewayHostName = hostDiscoveryService.generateHostname(freeIpa.getHostname(), null, 0, false);\n-                String generatedClusterDomain = hostDiscoveryService.determineDefaultDomainForStack(gatewayHostName, freeIpa.getDomain());\n-\n-                CcmV2Parameters ccmV2Parameters = ccmV2ParameterSupplier.getCcmV2Parameters(stack.getAccountId(), generatedClusterDomain, keyId);\n-                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV2Parameters);\n-            }\n-        }\n-        return ccmConnectivityParameters;\n-    }\n-\n-    @VisibleForTesting\n-    void saveStackCCMParameters(Stack stack, CcmConnectivityParameters ccmConnectivityParameters) {\n-        if (CcmConnectivityMode.CCMV1.equals(ccmConnectivityParameters.getConnectivityMode())\n-                && ccmConnectivityParameters.getCcmParameters() != null) {\n-            String minaSshdServiceId = ccmConnectivityParameters.getCcmParameters().getServerParameters().getMinaSshdServiceId();\n-            if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                stack.setMinaSshdServiceId(minaSshdServiceId);\n-                stackService.save(stack);\n-            }\n-        } else if (CcmConnectivityMode.CCMV2.equals(ccmConnectivityParameters.getConnectivityMode())\n-                && ccmConnectivityParameters.getCcmV2Parameters() != null) {\n-            CcmV2Parameters ccmV2Parameters = ccmConnectivityParameters.getCcmV2Parameters();\n-            LOGGER.debug(\"Add CcmV2AgentCrn [{}] to stack [{}]\", ccmV2Parameters.getAgentCrn(), stack.getResourceCrn());\n-            stack.setCcmV2AgentCrn(ccmV2Parameters.getAgentCrn());\n-            stackService.save(stack);\n-        } else {\n-            LOGGER.debug(\"CCM not configured for stack '{}'\", stack.getResourceCrn());\n-        }\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3NDY2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551274662", "bodyText": "depend on tunnel instead of entitlement", "author": "lacikaaa", "createdAt": "2021-01-04T11:57:33Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java", "diffHunk": "@@ -174,8 +181,14 @@\n \n         ConfigRegistrationRequestBuilder requestBuilder = new ConfigRegistrationRequestBuilder(stack.getResourceCrn())\n                 .withServices(serviceConfigs)\n-                .withTunnelEntries(createTunnelEntries(stack, tunnelGatewayConfigs))\n                 .withAccountId(stack.getAccountId());\n+        if (stack.getTunnel().useCcm()) {\n+            if (!entitlementService.ccmV2Enabled(stack.getAccountId())) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUyMjg4MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552522880", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3NDY2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "83e02a0069712a0d654c35d8020a277a65847256", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java\nindex 364b258ec8..aa595e431c 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java\n\n@@ -182,12 +178,10 @@ public class ClusterProxyService {\n         ConfigRegistrationRequestBuilder requestBuilder = new ConfigRegistrationRequestBuilder(stack.getResourceCrn())\n                 .withServices(serviceConfigs)\n                 .withAccountId(stack.getAccountId());\n-        if (stack.getTunnel().useCcm()) {\n-            if (!entitlementService.ccmV2Enabled(stack.getAccountId())) {\n-                requestBuilder.withTunnelEntries(createTunnelEntries(stack, tunnelGatewayConfigs));\n-            } else {\n-                requestBuilder.withCcmV2Entries(createCcmV2Configs(stack, tunnelGatewayConfigs));\n-            }\n+        if (stack.getTunnel().useCcmV1()) {\n+            requestBuilder.withTunnelEntries(createTunnelEntries(stack, tunnelGatewayConfigs));\n+        } else if (stack.getTunnel().useCcmV2()) {\n+            requestBuilder.withCcmV2Entries(createCcmV2Configs(stack, tunnelGatewayConfigs));\n         }\n         ConfigRegistrationRequest request = requestBuilder.build();\n         LOGGER.debug(\"Registring cluser proxy configuration [{}]\", request);\n"}}, {"oid": "83e02a0069712a0d654c35d8020a277a65847256", "url": "https://github.com/hortonworks/cloudbreak/commit/83e02a0069712a0d654c35d8020a277a65847256", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-06T11:48:26Z", "type": "forcePushed"}, {"oid": "8ff0cca20c3ba25f80a737a2d8b829f5a7e91676", "url": "https://github.com/hortonworks/cloudbreak/commit/8ff0cca20c3ba25f80a737a2d8b829f5a7e91676", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-06T13:03:07Z", "type": "forcePushed"}, {"oid": "ccabf23d50823f81579a2cf07267c19b3f532c32", "url": "https://github.com/hortonworks/cloudbreak/commit/ccabf23d50823f81579a2cf07267c19b3f532c32", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-06T14:13:12Z", "type": "forcePushed"}, {"oid": "8fdb7b0364b984679eef912b35ed1f25d533c7da", "url": "https://github.com/hortonworks/cloudbreak/commit/8fdb7b0364b984679eef912b35ed1f25d533c7da", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-07T03:22:50Z", "type": "forcePushed"}, {"oid": "5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "url": "https://github.com/hortonworks/cloudbreak/commit/5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-07T07:55:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMTYzOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553321639", "bodyText": "for reregistration you add knox url to the request. Is it missing here on purpose?", "author": "lacikaaa", "createdAt": "2021-01-07T13:19:07Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java", "diffHunk": "@@ -111,17 +115,22 @@ public void deregisterCluster(Stack stack) {\n     private ConfigRegistrationRequest createProxyConfigRequest(Stack stack) {\n         ConfigRegistrationRequestBuilder requestBuilder = new ConfigRegistrationRequestBuilder(stack.getResourceCrn())\n                 .withAliases(singletonList(clusterId(stack.getCluster()))).withServices(serviceConfigs(stack));\n-        if (stack.getTunnel().useCcm()) {\n+        if (stack.getTunnel().useCcmV1()) {\n             requestBuilder.withAccountId(getAccountId(stack)).withTunnelEntries(tunnelEntries(stack));\n+        } else if (stack.getTunnel().useCcmV2()) {\n+            requestBuilder.withAccountId(getAccountId(stack)).withCcmV2Entries(ccmV2Configs(stack));", "originalCommit": "5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMTY5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553331699", "bodyText": "I have not made any changes in this flow, first createProxyConfigRequest is sent. then knoxUrl is registered with registerGateway call. But for createProxyConfigReRegisterRequest knoxUrl was always passed.", "author": "smaniraju", "createdAt": "2021-01-07T13:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMTYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM0MjA1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553342053", "bodyText": "ok, I see that now. thanks for clarification", "author": "lacikaaa", "createdAt": "2021-01-07T13:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMTYzOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMjkzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553322933", "bodyText": "If I remember well the decision was that there will be only one agent running of inverting proxy which would pass everything through nginx and it would mean we have to add a new context for knox in nginx. But in that case I don't think you need KNOX here.", "author": "lacikaaa", "createdAt": "2021-01-07T13:21:49Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java", "diffHunk": "@@ -147,6 +156,16 @@ private String getAccountId(Stack stack) {\n         return asList(gatewayTunnel, knoxTunnel);\n     }\n \n+    private List<CcmV2Config> ccmV2Configs(Stack stack) {\n+        InstanceMetaData primaryGateway = stack.getPrimaryGatewayInstance();\n+        return List.of(ServiceFamilies.GATEWAY.getDefaultPort(), ServiceFamilies.KNOX.getDefaultPort()).stream()", "originalCommit": "5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzNDM3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553334377", "bodyText": "yes that was the approach decided. But I have not made any changes to serviceConfig which was generated and it is being commonly generated for ccmv1 and ccmv2.  For ccmv1 there is a service config entry cmServiceConfig(stack, null, \"cloudera-manager\", clusterManagerUrl(stack)) , I was not sure if this is really not used for ccmv1.   Also ccmv2 is validating service host port against ccmv2 config entry so I have not removed KNOX", "author": "smaniraju", "createdAt": "2021-01-07T13:44:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM1MzUzMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553353532", "bodyText": "still, I think this won't work this way, as cluster proxy would try to connect to port 443, and that won't be available through CCMv2.\nI don't how cluster proxy matches service configs with tunnel entries / ccmv2 configs, but I suspect you would need only one ccmv2 config while multiple service config, but a different one then for ccmv1", "author": "lacikaaa", "createdAt": "2021-01-07T14:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM1NzM0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553357341", "bodyText": "while connecting to cluster CB uses cb-internal service endpoint which is mapped to 9443 port, so this doesnt break anything. For clarity I will create different service config for ccmv2.", "author": "smaniraju", "createdAt": "2021-01-07T14:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM2MDcwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553360705", "bodyText": "that's right, but other services depend on the other endpoint. Like ClouderaManagerProxiedClientFactory uses that connection inside CB.", "author": "lacikaaa", "createdAt": "2021-01-07T14:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4MjExNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553782115", "bodyText": "Removed KNOX from the config.", "author": "smaniraju", "createdAt": "2021-01-08T07:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMjkzMw=="}], "type": "inlineReview", "revised_code": {"commit": "a7e2e1bb1a7f368910b2cb9080d1b11955056a93", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java b/core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java\nindex f67f0a797f..ca3416438b 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java\n\n@@ -158,7 +158,7 @@ public class ClusterProxyService {\n \n     private List<CcmV2Config> ccmV2Configs(Stack stack) {\n         InstanceMetaData primaryGateway = stack.getPrimaryGatewayInstance();\n-        return List.of(ServiceFamilies.GATEWAY.getDefaultPort(), ServiceFamilies.KNOX.getDefaultPort()).stream()\n+        return List.of(ServiceFamilies.GATEWAY.getDefaultPort()).stream()\n                 .map(servicePort -> new CcmV2Config(stack.getCcmV2AgentCrn(),\n                         String.format(CCMV2_BACKEND_ID_FORMAT, stack.getCcmV2AgentCrn(), primaryGateway.getInstanceId()),\n                         primaryGateway.getPublicIpWrapper(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyOTYzNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553329635", "bodyText": "when could this happen: .orElse(\"\")? shouldn't we fail instead?\nI'm not sure how HA for SDX works, maybe with a single gateway, but would that 0L cause any problem?", "author": "lacikaaa", "createdAt": "2021-01-07T13:35:03Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/CcmUserDataService.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.sequenceiq.cloudbreak.service.image.userdata;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmConnectivityParameters;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmParameterSupplier;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmParameters;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmV2ParameterSupplier;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmV2Parameters;\n+import com.sequenceiq.cloudbreak.ccm.endpoint.KnownServiceIdentifier;\n+import com.sequenceiq.cloudbreak.ccm.endpoint.ServiceFamilies;\n+import com.sequenceiq.cloudbreak.ccm.key.CcmResourceUtil;\n+import com.sequenceiq.cloudbreak.common.service.HostDiscoveryService;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+\n+@Service\n+public class CcmUserDataService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CcmUserDataService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private HostDiscoveryService hostDiscoveryService;\n+\n+    @Autowired\n+    private CcmParameterSupplier ccmParameterSupplier;\n+\n+    @Autowired\n+    private CcmV2ParameterSupplier ccmV2ParameterSupplier;\n+\n+    public CcmConnectivityParameters fetchAndSaveCcmParameters(Stack stack) {\n+        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters();\n+        if (stack.getTunnel().useCcmV1()) {\n+            String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n+            String actorCrn = Objects.requireNonNull(userCrn, \"userCrn is null\");\n+\n+            ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n+            int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n+            builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n+\n+            // Optionally configure a tunnel for (nginx fronting) Knox\n+            if (stack.getCluster().getGateway() != null) {\n+                // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n+                builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n+            }\n+\n+            Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n+            CcmParameters ccmV1Parameters = ccmParameterSupplier.getCcmParameters(actorCrn, ThreadBasedUserCrnProvider.getAccountId(),\n+                    CcmResourceUtil.getKeyId(stack.getResourceCrn()), tunneledServicePorts).orElse(null);\n+            ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n+\n+            saveCcmV1Config(stack.getId(), ccmV1Parameters);\n+        } else if (stack.getTunnel().useCcmV2()) {\n+            String gatewayHostName = hostDiscoveryService.generateHostname(stack.getCustomHostname(),\n+                    stack.getGatewayHostGroup().map(InstanceGroup::getGroupName).orElse(\"\"), 0L,", "originalCommit": "5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzNzQzMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553337430", "bodyText": "all the gateway nodes share the same mTLS cert so 0L would not cause any problem because mTLS doesnt validate client fqdn.\norElse(\"\")? would never happen because there are validations that atleast one hostGroup should be gatewayHostGroup.", "author": "smaniraju", "createdAt": "2021-01-07T13:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyOTYzNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMzQ4MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553333480", "bodyText": "won't this fix 0 cause problems for freeipa HA?", "author": "lacikaaa", "createdAt": "2021-01-07T13:42:26Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/CcmUserDataService.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.sequenceiq.freeipa.service.image.userdata;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmConnectivityParameters;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmParameterSupplier;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmParameters;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmV2ParameterSupplier;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmV2Parameters;\n+import com.sequenceiq.cloudbreak.ccm.endpoint.KnownServiceIdentifier;\n+import com.sequenceiq.cloudbreak.ccm.endpoint.ServiceFamilies;\n+import com.sequenceiq.cloudbreak.ccm.key.CcmResourceUtil;\n+import com.sequenceiq.cloudbreak.common.service.HostDiscoveryService;\n+import com.sequenceiq.freeipa.entity.FreeIpa;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.FreeIpaService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+import com.sequenceiq.freeipa.util.CrnService;\n+\n+@Service\n+public class CcmUserDataService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CcmUserDataService.class);\n+\n+    @Inject\n+    private CrnService crnService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private HostDiscoveryService hostDiscoveryService;\n+\n+    @Inject\n+    private FreeIpaService freeIpaService;\n+\n+    @Autowired\n+    private CcmParameterSupplier ccmParameterSupplier;\n+\n+    @Autowired\n+    private CcmV2ParameterSupplier ccmV2ParameterSupplier;\n+\n+    public CcmConnectivityParameters fetchAndSaveCcmParameters(Stack stack) {\n+        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters();\n+        String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n+\n+        if (stack.getTunnel().useCcmV1()) {\n+            String actorCrn = Objects.requireNonNull(crnService.getUserCrn(), \"userCrn is null\");\n+            int gatewayPort = Optional.ofNullable(stack.getGatewayport()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n+            Map<KnownServiceIdentifier, Integer> tunneledServicePorts = Collections.singletonMap(KnownServiceIdentifier.GATEWAY, gatewayPort);\n+\n+            CcmParameters ccmV1Parameters = ccmParameterSupplier\n+                    .getCcmParameters(actorCrn, stack.getAccountId(), keyId, tunneledServicePorts)\n+                    .orElse(null);\n+            ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n+            saveCcmV1Config(stack.getId(), ccmV1Parameters);\n+        } else if (stack.getTunnel().useCcmV2()) {\n+            FreeIpa freeIpa = freeIpaService.findByStack(stack);\n+            String gatewayHostName = hostDiscoveryService.generateHostname(freeIpa.getHostname(), null, 0, false);", "originalCommit": "5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzNzQ5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553337497", "bodyText": "all the gateway nodes share the same mTLS cert so 0L would not cause any problem because mTLS doesnt validate client fqdn.", "author": "smaniraju", "createdAt": "2021-01-07T13:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMzQ4MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzODU4MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553338581", "bodyText": "So you shouldn't overwrite CCM with CCMv2. You should check the request, if it contains CCMv2 but the entitlement is disabled you must throw a badrequestexception with a reason.\nIf CCM is sent in the request,it should be used, even if the entitlement is enabled. We don't want to force users with enabled entitlement to use CCMv2, do we?", "author": "lacikaaa", "createdAt": "2021-01-07T13:51:34Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java", "diffHunk": "@@ -123,6 +126,15 @@ private Environment initializeEnvironment(EnvironmentCreationDto creationDto) {\n         return environment;\n     }\n \n+    private void initializeEnvironmentTunnel(Environment environment) {\n+        Tunnel tunnel = environment.getExperimentalFeaturesJson().getTunnel();\n+        if (Tunnel.CCM == tunnel && entitlementService.ccmV2Enabled(environment.getAccountId())) {\n+            ExperimentalFeatures experimentalFeaturesJson = environment.getExperimentalFeaturesJson();\n+            experimentalFeaturesJson.setTunnel(Tunnel.CCMV2);\n+            environment.setExperimentalFeaturesJson(experimentalFeaturesJson);\n+        }\n+    }", "originalCommit": "5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM0MDAwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553340006", "bodyText": "yes I think that is expectation when entitlement is enabled only CCMv2 is to be used. Also CDP CLI only passes enableTunnel option there is no CCM or DIRECT option exposed to customers.", "author": "smaniraju", "createdAt": "2021-01-07T13:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzODU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM1OTYyNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553359624", "bodyText": "ok, I get it, but still, you should check that you accept CCMv2 only when the entitlement enabled. We can't rely on the logic present in other component. I think the UI eg communicates directly and sends CCM.", "author": "lacikaaa", "createdAt": "2021-01-07T14:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzODU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM2MDk4MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553360981", "bodyText": "But that would mean we will not able to create CCMv2 clusters via CDP CLI because it just as \"enableTunnel\", I think that would be a bigger issue.", "author": "smaniraju", "createdAt": "2021-01-07T14:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzODU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4MDQ2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553380469", "bodyText": "I mean you can leave this part, if CCM is received and entitlement enabled, turn it into CCMv2. so this part of the code is fine.\nBut you should add a validation before this, if CCMv2 is received and the entitlement is disabled then return a badrequest.", "author": "lacikaaa", "createdAt": "2021-01-07T14:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzODU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4MTk4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553781983", "bodyText": "Added validation if tunnel is CCMV2 and not entitled, badrequestexception is thrown.", "author": "smaniraju", "createdAt": "2021-01-08T07:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzODU4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "a7e2e1bb1a7f368910b2cb9080d1b11955056a93", "chunk": "diff --git a/environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java b/environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java\nindex 37e2fe90a5..82f28b650e 100644\n--- a/environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java\n+++ b/environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java\n\n@@ -128,10 +128,16 @@ public class EnvironmentCreationService {\n \n     private void initializeEnvironmentTunnel(Environment environment) {\n         Tunnel tunnel = environment.getExperimentalFeaturesJson().getTunnel();\n-        if (Tunnel.CCM == tunnel && entitlementService.ccmV2Enabled(environment.getAccountId())) {\n+        boolean ccmV2Enabled = entitlementService.ccmV2Enabled(environment.getAccountId());\n+        if (Tunnel.CCMV2 == tunnel && !ccmV2Enabled) {\n+            throw new BadRequestException(\"CCMV2 not enabled for account.\");\n+        } else if (Tunnel.CCM == tunnel && ccmV2Enabled) {\n             ExperimentalFeatures experimentalFeaturesJson = environment.getExperimentalFeaturesJson();\n             experimentalFeaturesJson.setTunnel(Tunnel.CCMV2);\n             environment.setExperimentalFeaturesJson(experimentalFeaturesJson);\n+            LOGGER.info(\"Environment is initialized with CCMV2 tunnel.\");\n+        } else {\n+            LOGGER.info(\"Environment is initialized with Direct tunnel.\");\n         }\n     }\n \n"}}, {"oid": "a7e2e1bb1a7f368910b2cb9080d1b11955056a93", "url": "https://github.com/hortonworks/cloudbreak/commit/a7e2e1bb1a7f368910b2cb9080d1b11955056a93", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-08T07:24:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3MzY3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553873674", "bodyText": "that's not true, it could be cluster proxied. although customer won't start that kind of cluster", "author": "lacikaaa", "createdAt": "2021-01-08T10:49:11Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java", "diffHunk": "@@ -123,6 +126,21 @@ private Environment initializeEnvironment(EnvironmentCreationDto creationDto) {\n         return environment;\n     }\n \n+    private void initializeEnvironmentTunnel(Environment environment) {\n+        Tunnel tunnel = environment.getExperimentalFeaturesJson().getTunnel();\n+        boolean ccmV2Enabled = entitlementService.ccmV2Enabled(environment.getAccountId());\n+        if (Tunnel.CCMV2 == tunnel && !ccmV2Enabled) {\n+            throw new BadRequestException(\"CCMV2 not enabled for account.\");\n+        } else if (Tunnel.CCM == tunnel && ccmV2Enabled) {\n+            ExperimentalFeatures experimentalFeaturesJson = environment.getExperimentalFeaturesJson();\n+            experimentalFeaturesJson.setTunnel(Tunnel.CCMV2);\n+            environment.setExperimentalFeaturesJson(experimentalFeaturesJson);\n+            LOGGER.info(\"Environment is initialized with CCMV2 tunnel.\");\n+        } else {\n+            LOGGER.info(\"Environment is initialized with Direct tunnel.\");", "originalCommit": "a7e2e1bb1a7f368910b2cb9080d1b11955056a93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3Mzg0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553873843", "bodyText": "you could fix this in a followup pr", "author": "lacikaaa", "createdAt": "2021-01-08T10:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3MzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3NTM4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553875387", "bodyText": "ccm is different from cluster proxy right ? I mean all requests go through clusterproxy but which tunnel used would be diffferent.", "author": "smaniraju", "createdAt": "2021-01-08T10:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3MzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg4NTI2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553885269", "bodyText": "talked about in private, but to have it here also. CB can connect with:\n\nDIRECT (no cluster proxy)\ncluster proxy, but without initializing tunnel via CCM, which means cluster proxy is connecting directly\nCCM, which means CB will initialize, configure cluster proxy with tunnel, and then use cluster proxy for communication", "author": "lacikaaa", "createdAt": "2021-01-08T11:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3MzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg4NjA3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553886074", "bodyText": "Updated log statement.", "author": "smaniraju", "createdAt": "2021-01-08T11:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3MzY3NA=="}], "type": "inlineReview", "revised_code": {"commit": "7d9c1e6db3780f3138e89e4a64d9745ce174f35c", "chunk": "diff --git a/environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java b/environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java\nindex 82f28b650e..667f205126 100644\n--- a/environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java\n+++ b/environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java\n\n@@ -137,7 +137,7 @@ public class EnvironmentCreationService {\n             environment.setExperimentalFeaturesJson(experimentalFeaturesJson);\n             LOGGER.info(\"Environment is initialized with CCMV2 tunnel.\");\n         } else {\n-            LOGGER.info(\"Environment is initialized with Direct tunnel.\");\n+            LOGGER.info(\"Environment is initialized with [{}] tunnel.\", tunnel);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3NDEzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553874133", "bodyText": "as this is a single item, the stream and list is an overkill here", "author": "lacikaaa", "createdAt": "2021-01-08T10:50:15Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java", "diffHunk": "@@ -147,6 +156,16 @@ private String getAccountId(Stack stack) {\n         return asList(gatewayTunnel, knoxTunnel);\n     }\n \n+    private List<CcmV2Config> ccmV2Configs(Stack stack) {\n+        InstanceMetaData primaryGateway = stack.getPrimaryGatewayInstance();\n+        return List.of(ServiceFamilies.GATEWAY.getDefaultPort()).stream()", "originalCommit": "a7e2e1bb1a7f368910b2cb9080d1b11955056a93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3ODg1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553878850", "bodyText": "CcmV2 Api expects List of CCMV2 Config, I will remove stream though in a follow up PR.", "author": "smaniraju", "createdAt": "2021-01-08T11:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3NDEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg4NjE1Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553886152", "bodyText": "Removed stream.", "author": "smaniraju", "createdAt": "2021-01-08T11:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3NDEzMw=="}], "type": "inlineReview", "revised_code": {"commit": "7d9c1e6db3780f3138e89e4a64d9745ce174f35c", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java b/core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java\nindex ca3416438b..429884c3da 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java\n\n@@ -158,12 +157,10 @@ public class ClusterProxyService {\n \n     private List<CcmV2Config> ccmV2Configs(Stack stack) {\n         InstanceMetaData primaryGateway = stack.getPrimaryGatewayInstance();\n-        return List.of(ServiceFamilies.GATEWAY.getDefaultPort()).stream()\n-                .map(servicePort -> new CcmV2Config(stack.getCcmV2AgentCrn(),\n-                        String.format(CCMV2_BACKEND_ID_FORMAT, stack.getCcmV2AgentCrn(), primaryGateway.getInstanceId()),\n-                        primaryGateway.getPublicIpWrapper(),\n-                        servicePort))\n-                .collect(Collectors.toList());\n+        return List.of(new CcmV2Config(stack.getCcmV2AgentCrn(),\n+                String.format(CCMV2_BACKEND_ID_FORMAT, stack.getCcmV2AgentCrn(), primaryGateway.getInstanceId()),\n+                primaryGateway.getPublicIpWrapper(),\n+                ServiceFamilies.GATEWAY.getDefaultPort()));\n     }\n \n     private ClusterServiceConfig cmServiceConfig(Stack stack, ClientCertificate clientCertificate, String serviceName, String clusterManagerUrl) {\n"}}, {"oid": "7d9c1e6db3780f3138e89e4a64d9745ce174f35c", "url": "https://github.com/hortonworks/cloudbreak/commit/7d9c1e6db3780f3138e89e4a64d9745ce174f35c", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-08T11:14:03Z", "type": "commit"}, {"oid": "7d9c1e6db3780f3138e89e4a64d9745ce174f35c", "url": "https://github.com/hortonworks/cloudbreak/commit/7d9c1e6db3780f3138e89e4a64d9745ce174f35c", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-08T11:14:03Z", "type": "forcePushed"}]}