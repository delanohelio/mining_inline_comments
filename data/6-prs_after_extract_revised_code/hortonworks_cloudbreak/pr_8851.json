{"pr_number": 8851, "pr_title": "CDPCP-2822. Ensure datalake is running before triggerring OID sync", "pr_createdAt": "2020-08-25T07:11:42Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8851", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3ODg5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8851#discussion_r476678892", "bodyText": "this is a duplicate of the getRangerCloudIdentitySyncStatus. could you refactor this to a common part to reduce code duplication?", "author": "lacikaaa", "createdAt": "2020-08-25T19:14:31Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/RangerCloudIdentityService.java", "diffHunk": "@@ -64,11 +70,20 @@ private RangerCloudIdentitySyncStatus setAzureCloudIdentityMapping(String envCrn\n         return Optional.of(Iterables.getOnlyElement(sdxClusters));\n     }\n \n+    private boolean isDatalakeRunning(SdxCluster sdxCluster) {\n+        SdxStatusEntity sdxStatusEntity = sdxStatusService.getActualStatusForSdx(sdxCluster);\n+        LOGGER.debug(\"SDX status = {}\", sdxStatusEntity.getStatus());\n+        return sdxStatusEntity.getStatus().equals(DatalakeStatusEnum.RUNNING);\n+    }\n+\n     public RangerCloudIdentitySyncStatus setAzureCloudIdentityMapping(String envCrn, Map<String, String> azureUserMapping) {\n         Optional<SdxCluster> sdxCluster = getSdxCluster(envCrn);\n         if (sdxCluster.isEmpty()) {\n             return newSyncStatus(RangerCloudIdentitySyncState.NOT_APPLICABLE, \"No datalakes associated with the environment.\");\n         }\n+        if (!isDatalakeRunning(sdxCluster.get())) {\n+            return newSyncStatus(RangerCloudIdentitySyncState.NOT_APPLICABLE, \"Datalake is not running for the environment.\");\n+        }", "originalCommit": "e1d344f9c4ca8e7ef37cfb57416a72d4ec32b2a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcwNjI4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8851#discussion_r476706284", "bodyText": "Thanks, I've added the else if branches as per your chat suggestion. I think making it more DRY would require wrapping the operation in a functional interface (see below example) which seemed less readable to me, so I didn't go for it. Let me know if that's okay, or if you had some other idea.\npublic RangerCloudIdentitySyncStatus runCloudIdSyncOperation(String envCrn, Function<SdxCluster, RangerCloudIdentitySyncStatus> operation) {\n    Optional<SdxCluster> sdxCluster = getSdxCluster(envCrn);\n    if (sdxCluster.isEmpty()) {\n        return newSyncStatus(RangerCloudIdentitySyncState.NOT_APPLICABLE, \"No datalakes associated with the environment.\");\n    } else if (!isDatalakeRunning(sdxCluster.get())) {\n        return newSyncStatus(RangerCloudIdentitySyncState.NOT_APPLICABLE, \"Datalake is not running for the environment.\");\n    } else {\n        return operation.apply(sdxCluster.get());\n    }\n}\n\npublic RangerCloudIdentitySyncStatus setAzureCloudIdentityMapping(String envCrn, Map<String, String> azureUserMapping) {\n    return runCloudIdSyncOperation(envCrn, sdxCluster -> setAzureCloudIdentityMapping(envCrn, sdxCluster, azureUserMapping));\n}\n\npublic RangerCloudIdentitySyncStatus getRangerCloudIdentitySyncStatus(String envCrn, long commandId) {\n    return runCloudIdSyncOperation(envCrn, sdxCluster -> {\n        try {\n            ApiCommand apiCommand = clouderaManagerRangerUtil.getApiCommand(sdxCluster.getStackCrn(), commandId);\n            return toRangerCloudIdentitySyncStatus(apiCommand);\n        } catch (ApiException e) {\n            LOGGER.error(\"Encountered cloudera manager api exception\", e);\n            return newSyncStatus(RangerCloudIdentitySyncState.FAILED, \"Encountered cloudera manager api exception\");\n        }\n    });\n}", "author": "aarman-cloudera", "createdAt": "2020-08-25T20:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3ODg5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "8c3c32544029f77e5b98c4faf0bda0b7d0a3b403", "chunk": "diff --git a/datalake/src/main/java/com/sequenceiq/datalake/cm/RangerCloudIdentityService.java b/datalake/src/main/java/com/sequenceiq/datalake/cm/RangerCloudIdentityService.java\nindex de976ebd7f..2a413a2061 100644\n--- a/datalake/src/main/java/com/sequenceiq/datalake/cm/RangerCloudIdentityService.java\n+++ b/datalake/src/main/java/com/sequenceiq/datalake/cm/RangerCloudIdentityService.java\n\n@@ -80,27 +80,27 @@ public class RangerCloudIdentityService {\n         Optional<SdxCluster> sdxCluster = getSdxCluster(envCrn);\n         if (sdxCluster.isEmpty()) {\n             return newSyncStatus(RangerCloudIdentitySyncState.NOT_APPLICABLE, \"No datalakes associated with the environment.\");\n-        }\n-        if (!isDatalakeRunning(sdxCluster.get())) {\n+        } else if (!isDatalakeRunning(sdxCluster.get())) {\n             return newSyncStatus(RangerCloudIdentitySyncState.NOT_APPLICABLE, \"Datalake is not running for the environment.\");\n+        } else {\n+            return setAzureCloudIdentityMapping(envCrn, sdxCluster.get(), azureUserMapping);\n         }\n-        return setAzureCloudIdentityMapping(envCrn, sdxCluster.get(), azureUserMapping);\n     }\n \n     public RangerCloudIdentitySyncStatus getRangerCloudIdentitySyncStatus(String envCrn, long commandId) {\n         Optional<SdxCluster> sdxCluster = getSdxCluster(envCrn);\n         if (sdxCluster.isEmpty()) {\n             return newSyncStatus(RangerCloudIdentitySyncState.NOT_APPLICABLE, \"No datalakes associated with the environment.\");\n-        }\n-        if (!isDatalakeRunning(sdxCluster.get())) {\n+        } else if (!isDatalakeRunning(sdxCluster.get())) {\n             return newSyncStatus(RangerCloudIdentitySyncState.NOT_APPLICABLE, \"Datalake is not running for the environment.\");\n-        }\n-        try {\n-            ApiCommand apiCommand = clouderaManagerRangerUtil.getApiCommand(sdxCluster.get().getStackCrn(), commandId);\n-            return toRangerCloudIdentitySyncStatus(apiCommand);\n-        } catch (ApiException e) {\n-            LOGGER.error(\"Encountered cloudera manager api exception\", e);\n-            return newSyncStatus(RangerCloudIdentitySyncState.FAILED, \"Encountered cloudera manager api exception\");\n+        } else {\n+            try {\n+                ApiCommand apiCommand = clouderaManagerRangerUtil.getApiCommand(sdxCluster.get().getStackCrn(), commandId);\n+                return toRangerCloudIdentitySyncStatus(apiCommand);\n+            } catch (ApiException e) {\n+                LOGGER.error(\"Encountered cloudera manager api exception\", e);\n+                return newSyncStatus(RangerCloudIdentitySyncState.FAILED, \"Encountered cloudera manager api exception\");\n+            }\n         }\n     }\n \n"}}, {"oid": "8c3c32544029f77e5b98c4faf0bda0b7d0a3b403", "url": "https://github.com/hortonworks/cloudbreak/commit/8c3c32544029f77e5b98c4faf0bda0b7d0a3b403", "message": "CDPCP-2822. Ensure datalake is running before triggerring OID sync\n\nThis ensures that we only make the CM api calls to set cloud\nidentity configs on CM's that are running.", "committedDate": "2020-08-25T19:58:28Z", "type": "forcePushed"}, {"oid": "c869a6b654a33b3401e5f78b7eb47ebc1c3eb9c2", "url": "https://github.com/hortonworks/cloudbreak/commit/c869a6b654a33b3401e5f78b7eb47ebc1c3eb9c2", "message": "CDPCP-2822. Ensure datalake is running before triggerring OID sync\n\nThis ensures that we only make the CM api calls to set cloud\nidentity configs on CM's that are running.", "committedDate": "2020-08-26T08:22:26Z", "type": "commit"}, {"oid": "c869a6b654a33b3401e5f78b7eb47ebc1c3eb9c2", "url": "https://github.com/hortonworks/cloudbreak/commit/c869a6b654a33b3401e5f78b7eb47ebc1c3eb9c2", "message": "CDPCP-2822. Ensure datalake is running before triggerring OID sync\n\nThis ensures that we only make the CM api calls to set cloud\nidentity configs on CM's that are running.", "committedDate": "2020-08-26T08:22:26Z", "type": "forcePushed"}]}