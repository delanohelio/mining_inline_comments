{"pr_number": 7808, "pr_title": "CB-6338 Refactor wait for instance states at WaitUtil", "pr_createdAt": "2020-04-15T19:10:00Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/7808", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAyMDk4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7808#discussion_r412020984", "bodyText": "I don't really like the Idea that the return type of this method was changed to void.\nBreaks the flow in the testcase.", "author": "lnardai", "createdAt": "2020-04-21T09:22:01Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/testcase/e2e/distrox/DistroXImagesTests.java", "diffHunk": "@@ -96,7 +96,8 @@ public void testDistroXWithBaseImageCanBeCreatedSuccessfully(TestContext testCon\n                 .when(distroXTestClient.create(), key(distrox))\n                 .await(STACK_AVAILABLE)\n                 .then((tc, testDto, client) -> {\n-                    return waitUtil.waitForDistroxInstancesStatus(testDto, client, instancesHealthy);\n+                    waitUtil.waitForDistroxInstanceStatus(testDto.getResponse().getName(), tc, instancesHealthy);", "originalCommit": "8ab7c65519457d83d3416c0f58d8389532ebaaca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4MTY2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7808#discussion_r412181669", "bodyText": "I could revert this change only for here (for waitForDistroxInstancesStatus method). In case of waitForSdxInstancesStatus this was part of the required change.", "author": "aszegedi", "createdAt": "2020-04-21T13:25:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAyMDk4NA=="}], "type": "inlineReview", "revised_code": {"commit": "972c14a32c7a4b77f04e44db39194a4d5af5b9be", "chunk": "diff --git a/integration-test/src/main/java/com/sequenceiq/it/cloudbreak/testcase/e2e/distrox/DistroXImagesTests.java b/integration-test/src/main/java/com/sequenceiq/it/cloudbreak/testcase/e2e/distrox/DistroXImagesTests.java\nindex fee7834397..2417c46cfc 100644\n--- a/integration-test/src/main/java/com/sequenceiq/it/cloudbreak/testcase/e2e/distrox/DistroXImagesTests.java\n+++ b/integration-test/src/main/java/com/sequenceiq/it/cloudbreak/testcase/e2e/distrox/DistroXImagesTests.java\n\n@@ -95,10 +95,7 @@ public class DistroXImagesTests extends AbstractE2ETest {\n                 .given(distrox, DistroXTestDto.class).withImageSettings(imageSettings)\n                 .when(distroXTestClient.create(), key(distrox))\n                 .await(STACK_AVAILABLE)\n-                .then((tc, testDto, client) -> {\n-                    waitUtil.waitForDistroxInstanceStatus(testDto.getResponse().getName(), tc, instancesHealthy);\n-                    return testDto;\n-                })\n+                .then((tc, testDto, client) -> waitUtil.waitForDistroxInstanceStatus(testDto, tc, instancesHealthy))\n                 .then((tc, dto, client) -> {\n                     Log.log(LOGGER, format(\" Image Catalog Name: %s \", dto.getResponse().getImage().getCatalogName()));\n                     Log.log(LOGGER, format(\" Image Catalog URL: %s \", dto.getResponse().getImage().getCatalogUrl()));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAyNzk0OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7808#discussion_r412027948", "bodyText": "This method got even more complicated.\nThe status and reason reason field always set together, please refactor that to a separate method.\nAlso a lot of \"freeIpaResponse.getStatusReason() != null ?\", This could be incorporated to that method as a default value or it could be set by default.", "author": "lnardai", "createdAt": "2020-04-21T09:31:27Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/WaitUtil.java", "diffHunk": "@@ -321,27 +336,36 @@ private boolean checkFailedStatuses(EnvironmentStatus currentStatus) {\n             com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status desiredStatus, long pollingInterval) {\n         Map<String, String> errors = new HashMap<>();\n         WaitResult waitResult = WaitResult.SUCCESSFUL;\n+        String status = \"\";\n+        String reason = \"\";\n+        DescribeFreeIpaResponse freeIpaResponse;\n         for (int retryBecauseOfWrongStatusHandlingInCB = 0; retryBecauseOfWrongStatusHandlingInCB < 3; retryBecauseOfWrongStatusHandlingInCB++) {\n             waitResult = waitForStatuses(freeIPAClient, name, desiredStatus);\n         }\n         if (waitResult == WaitResult.FAILED) {\n-            StringBuilder builder = new StringBuilder(\"The stack has failed: \").append(System.lineSeparator());\n-            DescribeFreeIpaResponse freeIpaResponse = getFreeIPAResponse(freeIPAClient, name);\n-            if (freeIpaResponse != null && freeIpaResponse.getStatus() != null) {\n-                builder.append(\"statusReason: \").append(freeIpaResponse.getStatusReason());\n-            }\n+            StringBuilder builder = new StringBuilder(\"FreeIPA has failed: \").append(System.lineSeparator());", "originalCommit": "8ab7c65519457d83d3416c0f58d8389532ebaaca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4Mzk2Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7808#discussion_r412183966", "bodyText": "Original methods were tidied up. Supporting methods were placed here as well.", "author": "aszegedi", "createdAt": "2020-04-21T13:28:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAyNzk0OA=="}], "type": "inlineReview", "revised_code": {"commit": "972c14a32c7a4b77f04e44db39194a4d5af5b9be", "chunk": "diff --git a/integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/WaitUtil.java b/integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/WaitUtil.java\nindex bff265ddb2..09ae6d7d7d 100644\n--- a/integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/WaitUtil.java\n+++ b/integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/WaitUtil.java\n\n@@ -295,161 +296,43 @@ public class WaitUtil {\n \n     public Map<String, String> waitAndCheckStatuses(RedbeamsClient redbeamsClient, String crn,\n             Status desiredStatus, long pollingInterval) {\n-        Map<String, String> errors = new HashMap<>();\n         WaitResult waitResult = WaitResult.SUCCESSFUL;\n-        String status = \"\";\n-        String reason = \"\";\n-        DatabaseServerV4Response databaseServerResponse;\n         for (int retryBecauseOfWrongStatusHandlingInCB = 0; retryBecauseOfWrongStatusHandlingInCB < 3; retryBecauseOfWrongStatusHandlingInCB++) {\n             waitResult = waitForStatuses(redbeamsClient, crn, desiredStatus);\n         }\n-        if (waitResult == WaitResult.FAILED) {\n-            StringBuilder builder = new StringBuilder(\"RedBeams has failed: \").append(System.lineSeparator());\n-            databaseServerResponse = getDatabaseServerResponse(redbeamsClient, crn);\n-            status = databaseServerResponse.getStatus().name();\n-            reason = databaseServerResponse.getStatusReason() != null ? databaseServerResponse.getStatusReason()\n-                    : \"RedBeams Status Reason is not available\";\n-            builder.append(\"statusReason: \").append(reason);\n-            LOGGER.error(builder.toString());\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (waitResult == WaitResult.TIMEOUT) {\n-            databaseServerResponse = getDatabaseServerResponse(redbeamsClient, crn);\n-            status = databaseServerResponse.getStatus().name();\n-            reason = databaseServerResponse.getStatusReason() != null ? databaseServerResponse.getStatusReason()\n-                    : \"RedBeams Status Reason is not available\";\n-            LOGGER.error(\"Timeout happened while waiting for {} status at {}, the current status is {} with reason: {}\", desiredStatus.name(), crn,\n-                    status, reason);\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (Status.DELETE_COMPLETED != desiredStatus) {\n-            databaseServerResponse = getDatabaseServerResponse(redbeamsClient, crn);\n-            if (databaseServerResponse != null) {\n-                status = databaseServerResponse.getStatus().name();\n-                reason = databaseServerResponse.getStatusReason() != null ? databaseServerResponse.getStatusReason()\n-                        : \"RedBeams Status Reason is not available\";\n-                errors = Map.of(\"status\", status, \"reason\", reason);\n-            }\n-        }\n-        return errors;\n+        return getDatabaseServerErrors(redbeamsClient, desiredStatus, waitResult, crn);\n     }\n \n     public Map<String, String> waitAndCheckStatuses(FreeIPAClient freeIPAClient, String name,\n             com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status desiredStatus, long pollingInterval) {\n-        Map<String, String> errors = new HashMap<>();\n         WaitResult waitResult = WaitResult.SUCCESSFUL;\n-        String status = \"\";\n-        String reason = \"\";\n-        DescribeFreeIpaResponse freeIpaResponse;\n         for (int retryBecauseOfWrongStatusHandlingInCB = 0; retryBecauseOfWrongStatusHandlingInCB < 3; retryBecauseOfWrongStatusHandlingInCB++) {\n             waitResult = waitForStatuses(freeIPAClient, name, desiredStatus);\n         }\n-        if (waitResult == WaitResult.FAILED) {\n-            StringBuilder builder = new StringBuilder(\"FreeIPA has failed: \").append(System.lineSeparator());\n-            freeIpaResponse = getFreeIPAResponse(freeIPAClient, name);\n-            status = freeIpaResponse.getStatus().name();\n-            reason = freeIpaResponse.getStatusReason() != null ? freeIpaResponse.getStatusReason()\n-                    : \"FreeIPA Status Reason is not available\";\n-            builder.append(\"statusReason: \").append(reason);\n-            LOGGER.error(builder.toString());\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (waitResult == WaitResult.TIMEOUT) {\n-            freeIpaResponse = getFreeIPAResponse(freeIPAClient, name);\n-            status = freeIpaResponse.getStatus().name();\n-            reason = freeIpaResponse.getStatusReason() != null ? freeIpaResponse.getStatusReason()\n-                    : \"FreeIPA Status Reason is not available\";\n-            LOGGER.error(\"Timeout happened while waiting for {} status at {}, the current status is {} with reason: {}\", desiredStatus.name(),\n-                    name, status, reason);\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status.DELETE_COMPLETED != desiredStatus) {\n-            freeIpaResponse = getFreeIPAResponse(freeIPAClient, name);\n-            if (freeIpaResponse != null) {\n-                status = freeIpaResponse.getStatus().name();\n-                reason = freeIpaResponse.getStatusReason() != null ? freeIpaResponse.getStatusReason()\n-                        : \"FreeIPA Status Reason is not available\";\n-                errors = Map.of(\"status\", status, \"reason\", reason);\n-            }\n-        }\n-        return errors;\n+        return getFreeIPAErrors(freeIPAClient, desiredStatus, waitResult, name);\n     }\n \n     public Map<String, String> waitAndCheckStatuses(EnvironmentClient environmentClient, String name,\n             EnvironmentStatus desiredStatus, long pollingInterval) {\n-        Map<String, String> errors = new HashMap<>();\n         WaitResult waitResult = WaitResult.SUCCESSFUL;\n-        String status = \"\";\n-        String reason = \"\";\n-        DetailedEnvironmentResponse environmentResponse;\n         for (int retryBecauseOfWrongStatusHandlingInCB = 0; retryBecauseOfWrongStatusHandlingInCB < 3; retryBecauseOfWrongStatusHandlingInCB++) {\n             waitResult = waitForStatuses(environmentClient, name, desiredStatus);\n         }\n-        if (waitResult == WaitResult.FAILED) {\n-            StringBuilder builder = new StringBuilder(\"Environment has failed: \").append(System.lineSeparator());\n-            environmentResponse = getEnvironmentResponse(environmentClient, name);\n-            status = environmentResponse.getEnvironmentStatus().name();\n-            reason = environmentResponse.getStatusReason() != null ? environmentResponse.getStatusReason()\n-                    : \"Environment Status Reason is not available\";\n-            builder.append(\"statusReason: \").append(reason);\n-            LOGGER.error(builder.toString());\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (waitResult == WaitResult.TIMEOUT) {\n-            environmentResponse = getEnvironmentResponse(environmentClient, name);\n-            status = environmentResponse.getEnvironmentStatus().name();\n-            reason = environmentResponse.getStatusReason() != null ? environmentResponse.getStatusReason()\n-                    : \"Environment Status Reason is not available\";\n-            LOGGER.error(\"Timeout happened while waiting for {} status at {}, the current status is {} with reason: {}\", desiredStatus.name(),\n-                    name, status, reason);\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (EnvironmentStatus.ARCHIVED != desiredStatus) {\n-            environmentResponse = getEnvironmentResponse(environmentClient, name);\n-            if (environmentResponse != null) {\n-                status = environmentResponse.getEnvironmentStatus().name();\n-                reason = environmentResponse.getStatusReason() != null ? environmentResponse.getStatusReason()\n-                        : \"Environment Status Reason is not available\";\n-                errors = Map.of(\"status\", status, \"reason\", reason);\n-            }\n-        }\n-        return errors;\n+        return getEnvironmentErrors(environmentClient, desiredStatus, waitResult, name);\n     }\n \n     public Map<String, String> waitAndCheckStatuses(SdxClient sdxClient, String name,\n             SdxClusterStatusResponse desiredStatus, long pollingInterval) {\n-        Map<String, String> errors = new HashMap<>();\n         WaitResult waitResult = WaitResult.SUCCESSFUL;\n-        String status = \"\";\n-        String reason = \"\";\n-        SdxClusterResponse sdxResponse;\n         for (int retryBecauseOfWrongStatusHandlingInCB = 0; retryBecauseOfWrongStatusHandlingInCB < 3; retryBecauseOfWrongStatusHandlingInCB++) {\n             waitResult = waitForStatuses(sdxClient, name, desiredStatus);\n         }\n-        if (waitResult == WaitResult.FAILED) {\n-            StringBuilder builder = new StringBuilder(\"SDX has failed: \").append(System.lineSeparator());\n-            sdxResponse = getSDXClusterResponse(sdxClient, name);\n-            status = sdxResponse.getStatus().name();\n-            reason = sdxResponse.getStatusReason() != null ? sdxResponse.getStatusReason()\n-                    : \"SDX Status Reason is not available\";\n-            builder.append(\"statusReason: \").append(reason);\n-            LOGGER.error(builder.toString());\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (waitResult == WaitResult.TIMEOUT) {\n-            sdxResponse = getSDXClusterResponse(sdxClient, name);\n-            status = sdxResponse.getStatus().name();\n-            reason = sdxResponse.getStatusReason() != null ? sdxResponse.getStatusReason()\n-                    : \"SDX Status Reason is not available\";\n-            LOGGER.error(\"Timeout happened while waiting for {} status at {}, the current status is {} with reason: {}\", desiredStatus.name(),\n-                    name, status, reason);\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (DELETED != desiredStatus) {\n-            sdxResponse = getSDXClusterResponse(sdxClient, name);\n-            if (sdxResponse != null) {\n-                status = sdxResponse.getStatus().name();\n-                reason = sdxResponse.getStatusReason() != null ? sdxResponse.getStatusReason()\n-                        : \"SDX Status Reason is not available\";\n-                errors = Map.of(\"status\", status, \"reason\", reason);\n-            }\n-        }\n-        return errors;\n+        return getSdxErrors(sdxClient, desiredStatus, waitResult, name);\n     }\n \n-    public void waitForDistroxInstanceStatus(String distroxName, TestContext testContext, Map<String, InstanceStatus> hostGroupsAndStates) {\n+    public DistroXTestDto waitForDistroxInstanceStatus(DistroXTestDto testDto, TestContext testContext, Map<String, InstanceStatus> hostGroupsAndStates) {\n+        String distroxName = testDto.getResponse().getName();\n+\n         hostGroupsAndStates.forEach((hostGroup, desiredState) -> {\n             int retryCount = 0;\n             long startTime = System.currentTimeMillis();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA0MzI1NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7808#discussion_r412043255", "bodyText": "By eliminating these methods the original ones got even more complex.", "author": "lnardai", "createdAt": "2020-04-21T09:53:36Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/WaitUtil.java", "diffHunk": "@@ -379,136 +414,130 @@ private boolean checkFailedStatuses(EnvironmentStatus currentStatus) {\n             SdxClusterStatusResponse desiredStatus, long pollingInterval) {\n         Map<String, String> errors = new HashMap<>();\n         WaitResult waitResult = WaitResult.SUCCESSFUL;\n+        String status = \"\";\n+        String reason = \"\";\n+        SdxClusterResponse sdxResponse;\n         for (int retryBecauseOfWrongStatusHandlingInCB = 0; retryBecauseOfWrongStatusHandlingInCB < 3; retryBecauseOfWrongStatusHandlingInCB++) {\n             waitResult = waitForStatuses(sdxClient, name, desiredStatus);\n         }\n         if (waitResult == WaitResult.FAILED) {\n-            StringBuilder builder = new StringBuilder(\"The stack has failed: \").append(System.lineSeparator());\n-            SdxClusterResponse sdxResponse = getSDXClusterResponse(sdxClient, name);\n-            if (sdxResponse != null && sdxResponse.getStatus() != null) {\n-                builder.append(\"statusReason: \").append(sdxResponse.getStatusReason());\n-            }\n+            StringBuilder builder = new StringBuilder(\"SDX has failed: \").append(System.lineSeparator());\n+            sdxResponse = getSDXClusterResponse(sdxClient, name);\n+            status = sdxResponse.getStatus().name();\n+            reason = sdxResponse.getStatusReason() != null ? sdxResponse.getStatusReason()\n+                    : \"SDX Status Reason is not available\";\n+            builder.append(\"statusReason: \").append(reason);\n             LOGGER.error(builder.toString());\n-            throw new TestFailException(builder.toString());\n+            errors = Map.of(\"status\", status, \"reason\", reason);\n         } else if (waitResult == WaitResult.TIMEOUT) {\n-            SdxClusterResponse sdxResponse = getSDXClusterResponse(sdxClient, name);\n-            LOGGER.error(\"Timeout happened while waiting for {} status at {}, the current status is {}\", desiredStatus.name(), name,\n-                    sdxResponse.getStatus().name());\n-            throw new TestFailException(\"Timeout happened while waiting for \" + desiredStatus.name() + \" status at \" + name + \", the current status is \"\n-                    + sdxResponse.getStatus().name());\n+            sdxResponse = getSDXClusterResponse(sdxClient, name);\n+            status = sdxResponse.getStatus().name();\n+            reason = sdxResponse.getStatusReason() != null ? sdxResponse.getStatusReason()\n+                    : \"SDX Status Reason is not available\";\n+            LOGGER.error(\"Timeout happened while waiting for {} status at {}, the current status is {} with reason: {}\", desiredStatus.name(),\n+                    name, status, reason);\n+            errors = Map.of(\"status\", status, \"reason\", reason);\n         } else if (DELETED != desiredStatus) {\n-            SdxClusterResponse sdxResponse = getSDXClusterResponse(sdxClient, name);\n+            sdxResponse = getSDXClusterResponse(sdxClient, name);\n             if (sdxResponse != null) {\n-                errors = Map.of(\"status\", sdxResponse.getStatus().name());\n+                status = sdxResponse.getStatus().name();\n+                reason = sdxResponse.getStatusReason() != null ? sdxResponse.getStatusReason()\n+                        : \"SDX Status Reason is not available\";\n+                errors = Map.of(\"status\", status, \"reason\", reason);\n             }\n         }\n         return errors;\n     }\n \n-    public SdxTestDto waitForSdxInstanceStatus(SdxTestDto sdxTestDto, SdxClient sdxClient, String hostGroup, InstanceStatus desiredState) {", "originalCommit": "8ab7c65519457d83d3416c0f58d8389532ebaaca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4NDY3Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7808#discussion_r412184673", "bodyText": "This change was required.", "author": "aszegedi", "createdAt": "2020-04-21T13:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA0MzI1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "972c14a32c7a4b77f04e44db39194a4d5af5b9be", "chunk": "diff --git a/integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/WaitUtil.java b/integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/WaitUtil.java\nindex bff265ddb2..09ae6d7d7d 100644\n--- a/integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/WaitUtil.java\n+++ b/integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/WaitUtil.java\n\n@@ -295,161 +296,43 @@ public class WaitUtil {\n \n     public Map<String, String> waitAndCheckStatuses(RedbeamsClient redbeamsClient, String crn,\n             Status desiredStatus, long pollingInterval) {\n-        Map<String, String> errors = new HashMap<>();\n         WaitResult waitResult = WaitResult.SUCCESSFUL;\n-        String status = \"\";\n-        String reason = \"\";\n-        DatabaseServerV4Response databaseServerResponse;\n         for (int retryBecauseOfWrongStatusHandlingInCB = 0; retryBecauseOfWrongStatusHandlingInCB < 3; retryBecauseOfWrongStatusHandlingInCB++) {\n             waitResult = waitForStatuses(redbeamsClient, crn, desiredStatus);\n         }\n-        if (waitResult == WaitResult.FAILED) {\n-            StringBuilder builder = new StringBuilder(\"RedBeams has failed: \").append(System.lineSeparator());\n-            databaseServerResponse = getDatabaseServerResponse(redbeamsClient, crn);\n-            status = databaseServerResponse.getStatus().name();\n-            reason = databaseServerResponse.getStatusReason() != null ? databaseServerResponse.getStatusReason()\n-                    : \"RedBeams Status Reason is not available\";\n-            builder.append(\"statusReason: \").append(reason);\n-            LOGGER.error(builder.toString());\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (waitResult == WaitResult.TIMEOUT) {\n-            databaseServerResponse = getDatabaseServerResponse(redbeamsClient, crn);\n-            status = databaseServerResponse.getStatus().name();\n-            reason = databaseServerResponse.getStatusReason() != null ? databaseServerResponse.getStatusReason()\n-                    : \"RedBeams Status Reason is not available\";\n-            LOGGER.error(\"Timeout happened while waiting for {} status at {}, the current status is {} with reason: {}\", desiredStatus.name(), crn,\n-                    status, reason);\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (Status.DELETE_COMPLETED != desiredStatus) {\n-            databaseServerResponse = getDatabaseServerResponse(redbeamsClient, crn);\n-            if (databaseServerResponse != null) {\n-                status = databaseServerResponse.getStatus().name();\n-                reason = databaseServerResponse.getStatusReason() != null ? databaseServerResponse.getStatusReason()\n-                        : \"RedBeams Status Reason is not available\";\n-                errors = Map.of(\"status\", status, \"reason\", reason);\n-            }\n-        }\n-        return errors;\n+        return getDatabaseServerErrors(redbeamsClient, desiredStatus, waitResult, crn);\n     }\n \n     public Map<String, String> waitAndCheckStatuses(FreeIPAClient freeIPAClient, String name,\n             com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status desiredStatus, long pollingInterval) {\n-        Map<String, String> errors = new HashMap<>();\n         WaitResult waitResult = WaitResult.SUCCESSFUL;\n-        String status = \"\";\n-        String reason = \"\";\n-        DescribeFreeIpaResponse freeIpaResponse;\n         for (int retryBecauseOfWrongStatusHandlingInCB = 0; retryBecauseOfWrongStatusHandlingInCB < 3; retryBecauseOfWrongStatusHandlingInCB++) {\n             waitResult = waitForStatuses(freeIPAClient, name, desiredStatus);\n         }\n-        if (waitResult == WaitResult.FAILED) {\n-            StringBuilder builder = new StringBuilder(\"FreeIPA has failed: \").append(System.lineSeparator());\n-            freeIpaResponse = getFreeIPAResponse(freeIPAClient, name);\n-            status = freeIpaResponse.getStatus().name();\n-            reason = freeIpaResponse.getStatusReason() != null ? freeIpaResponse.getStatusReason()\n-                    : \"FreeIPA Status Reason is not available\";\n-            builder.append(\"statusReason: \").append(reason);\n-            LOGGER.error(builder.toString());\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (waitResult == WaitResult.TIMEOUT) {\n-            freeIpaResponse = getFreeIPAResponse(freeIPAClient, name);\n-            status = freeIpaResponse.getStatus().name();\n-            reason = freeIpaResponse.getStatusReason() != null ? freeIpaResponse.getStatusReason()\n-                    : \"FreeIPA Status Reason is not available\";\n-            LOGGER.error(\"Timeout happened while waiting for {} status at {}, the current status is {} with reason: {}\", desiredStatus.name(),\n-                    name, status, reason);\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status.DELETE_COMPLETED != desiredStatus) {\n-            freeIpaResponse = getFreeIPAResponse(freeIPAClient, name);\n-            if (freeIpaResponse != null) {\n-                status = freeIpaResponse.getStatus().name();\n-                reason = freeIpaResponse.getStatusReason() != null ? freeIpaResponse.getStatusReason()\n-                        : \"FreeIPA Status Reason is not available\";\n-                errors = Map.of(\"status\", status, \"reason\", reason);\n-            }\n-        }\n-        return errors;\n+        return getFreeIPAErrors(freeIPAClient, desiredStatus, waitResult, name);\n     }\n \n     public Map<String, String> waitAndCheckStatuses(EnvironmentClient environmentClient, String name,\n             EnvironmentStatus desiredStatus, long pollingInterval) {\n-        Map<String, String> errors = new HashMap<>();\n         WaitResult waitResult = WaitResult.SUCCESSFUL;\n-        String status = \"\";\n-        String reason = \"\";\n-        DetailedEnvironmentResponse environmentResponse;\n         for (int retryBecauseOfWrongStatusHandlingInCB = 0; retryBecauseOfWrongStatusHandlingInCB < 3; retryBecauseOfWrongStatusHandlingInCB++) {\n             waitResult = waitForStatuses(environmentClient, name, desiredStatus);\n         }\n-        if (waitResult == WaitResult.FAILED) {\n-            StringBuilder builder = new StringBuilder(\"Environment has failed: \").append(System.lineSeparator());\n-            environmentResponse = getEnvironmentResponse(environmentClient, name);\n-            status = environmentResponse.getEnvironmentStatus().name();\n-            reason = environmentResponse.getStatusReason() != null ? environmentResponse.getStatusReason()\n-                    : \"Environment Status Reason is not available\";\n-            builder.append(\"statusReason: \").append(reason);\n-            LOGGER.error(builder.toString());\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (waitResult == WaitResult.TIMEOUT) {\n-            environmentResponse = getEnvironmentResponse(environmentClient, name);\n-            status = environmentResponse.getEnvironmentStatus().name();\n-            reason = environmentResponse.getStatusReason() != null ? environmentResponse.getStatusReason()\n-                    : \"Environment Status Reason is not available\";\n-            LOGGER.error(\"Timeout happened while waiting for {} status at {}, the current status is {} with reason: {}\", desiredStatus.name(),\n-                    name, status, reason);\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (EnvironmentStatus.ARCHIVED != desiredStatus) {\n-            environmentResponse = getEnvironmentResponse(environmentClient, name);\n-            if (environmentResponse != null) {\n-                status = environmentResponse.getEnvironmentStatus().name();\n-                reason = environmentResponse.getStatusReason() != null ? environmentResponse.getStatusReason()\n-                        : \"Environment Status Reason is not available\";\n-                errors = Map.of(\"status\", status, \"reason\", reason);\n-            }\n-        }\n-        return errors;\n+        return getEnvironmentErrors(environmentClient, desiredStatus, waitResult, name);\n     }\n \n     public Map<String, String> waitAndCheckStatuses(SdxClient sdxClient, String name,\n             SdxClusterStatusResponse desiredStatus, long pollingInterval) {\n-        Map<String, String> errors = new HashMap<>();\n         WaitResult waitResult = WaitResult.SUCCESSFUL;\n-        String status = \"\";\n-        String reason = \"\";\n-        SdxClusterResponse sdxResponse;\n         for (int retryBecauseOfWrongStatusHandlingInCB = 0; retryBecauseOfWrongStatusHandlingInCB < 3; retryBecauseOfWrongStatusHandlingInCB++) {\n             waitResult = waitForStatuses(sdxClient, name, desiredStatus);\n         }\n-        if (waitResult == WaitResult.FAILED) {\n-            StringBuilder builder = new StringBuilder(\"SDX has failed: \").append(System.lineSeparator());\n-            sdxResponse = getSDXClusterResponse(sdxClient, name);\n-            status = sdxResponse.getStatus().name();\n-            reason = sdxResponse.getStatusReason() != null ? sdxResponse.getStatusReason()\n-                    : \"SDX Status Reason is not available\";\n-            builder.append(\"statusReason: \").append(reason);\n-            LOGGER.error(builder.toString());\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (waitResult == WaitResult.TIMEOUT) {\n-            sdxResponse = getSDXClusterResponse(sdxClient, name);\n-            status = sdxResponse.getStatus().name();\n-            reason = sdxResponse.getStatusReason() != null ? sdxResponse.getStatusReason()\n-                    : \"SDX Status Reason is not available\";\n-            LOGGER.error(\"Timeout happened while waiting for {} status at {}, the current status is {} with reason: {}\", desiredStatus.name(),\n-                    name, status, reason);\n-            errors = Map.of(\"status\", status, \"reason\", reason);\n-        } else if (DELETED != desiredStatus) {\n-            sdxResponse = getSDXClusterResponse(sdxClient, name);\n-            if (sdxResponse != null) {\n-                status = sdxResponse.getStatus().name();\n-                reason = sdxResponse.getStatusReason() != null ? sdxResponse.getStatusReason()\n-                        : \"SDX Status Reason is not available\";\n-                errors = Map.of(\"status\", status, \"reason\", reason);\n-            }\n-        }\n-        return errors;\n+        return getSdxErrors(sdxClient, desiredStatus, waitResult, name);\n     }\n \n-    public void waitForDistroxInstanceStatus(String distroxName, TestContext testContext, Map<String, InstanceStatus> hostGroupsAndStates) {\n+    public DistroXTestDto waitForDistroxInstanceStatus(DistroXTestDto testDto, TestContext testContext, Map<String, InstanceStatus> hostGroupsAndStates) {\n+        String distroxName = testDto.getResponse().getName();\n+\n         hostGroupsAndStates.forEach((hostGroup, desiredState) -> {\n             int retryCount = 0;\n             long startTime = System.currentTimeMillis();\n"}}, {"oid": "972c14a32c7a4b77f04e44db39194a4d5af5b9be", "url": "https://github.com/hortonworks/cloudbreak/commit/972c14a32c7a4b77f04e44db39194a4d5af5b9be", "message": "CB-6338 Refactor wait for instance states at WaitUtil", "committedDate": "2020-04-21T14:28:57Z", "type": "forcePushed"}, {"oid": "3af1b7dbc4752dc33738e4525c03d636fb62e1fa", "url": "https://github.com/hortonworks/cloudbreak/commit/3af1b7dbc4752dc33738e4525c03d636fb62e1fa", "message": "CB-6338 Refactor wait for instance states at WaitUtil", "committedDate": "2020-04-21T16:39:14Z", "type": "forcePushed"}, {"oid": "d3cc714be63450cb983e402a3e3187d176afa896", "url": "https://github.com/hortonworks/cloudbreak/commit/d3cc714be63450cb983e402a3e3187d176afa896", "message": "CB-6338 Refactor wait for instance states at WaitUtil", "committedDate": "2020-04-21T20:29:25Z", "type": "commit"}, {"oid": "d3cc714be63450cb983e402a3e3187d176afa896", "url": "https://github.com/hortonworks/cloudbreak/commit/d3cc714be63450cb983e402a3e3187d176afa896", "message": "CB-6338 Refactor wait for instance states at WaitUtil", "committedDate": "2020-04-21T20:29:25Z", "type": "forcePushed"}, {"oid": "b33ae06f5ed1366f788a90ded4648e2fb9443d99", "url": "https://github.com/hortonworks/cloudbreak/commit/b33ae06f5ed1366f788a90ded4648e2fb9443d99", "message": "CB-6338 Refactor wait for instance states at WaitUtil", "committedDate": "2020-04-30T09:25:40Z", "type": "commit"}, {"oid": "85df03666a9a6d3eade3593d0a3b35236762cbd0", "url": "https://github.com/hortonworks/cloudbreak/commit/85df03666a9a6d3eade3593d0a3b35236762cbd0", "message": "Merge branch 'test-waitrefact' of github.com:hortonworks/cloudbreak into test-waitrefact", "committedDate": "2020-04-30T09:25:59Z", "type": "commit"}]}