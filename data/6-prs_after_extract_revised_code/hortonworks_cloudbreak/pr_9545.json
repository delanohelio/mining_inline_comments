{"pr_number": 9545, "pr_title": "CB-10029 Azure managed image creation error can potentially lock user\u2026", "pr_createdAt": "2020-12-01T13:24:26Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9545", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMjk5OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9545#discussion_r533622998", "bodyText": "is there a particular reason why you decided not to catch TimeoutException in a try... catch here?", "author": "pdarvasi", "createdAt": "2020-12-01T18:16:31Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -70,14 +72,18 @@ private AzureImage createImageAndNotify(AuthenticatedContext ac, VirtualMachineC\n     }\n \n     private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageInfo azureImageInfo, AuthenticatedContext ac,\n-            AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n+            AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException originalException) {\n         Optional<VirtualMachineCustomImage> customImage;\n-        azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+        Optional<Throwable> errorResult = azureManagedImageCreationPoller.startPolling(ac, checkerContext, false);\n         customImage = findImage(azureImageInfo, client);\n         if (customImage.isEmpty()) {\n-            LOGGER.error(\"Failed to create custom image.\", e);\n             updateImageStatus(ac, azureImageInfo.getImageNameWithRegion(), azureImageInfo.getImageId(), CommonStatus.FAILED);\n-            throw new CloudConnectorException(e);\n+            if (errorResult.isPresent() && !(errorResult.get() instanceof TimeoutException)) {", "originalCommit": "febcac0cf411fcc7ce9484c8d79fb1ab102ff975", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae80e5e46f7ffe472e9d952c79a5acfee7422f5f", "chunk": "diff --git a/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java b/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\nindex b2b5b3ba7c..d63d07f94f 100644\n--- a/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\n+++ b/cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java\n\n@@ -73,19 +78,24 @@ public class AzureImageService {\n \n     private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageInfo azureImageInfo, AuthenticatedContext ac,\n             AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException originalException) {\n-        Optional<VirtualMachineCustomImage> customImage;\n-        Optional<Throwable> errorResult = azureManagedImageCreationPoller.startPolling(ac, checkerContext, false);\n-        customImage = findImage(azureImageInfo, client);\n-        if (customImage.isEmpty()) {\n-            updateImageStatus(ac, azureImageInfo.getImageNameWithRegion(), azureImageInfo.getImageId(), CommonStatus.FAILED);\n-            if (errorResult.isPresent() && !(errorResult.get() instanceof TimeoutException)) {\n-                LOGGER.error(\"Failed to create custom image: \", errorResult.get());\n-                throw new CloudConnectorException(errorResult.get());\n+        Exception onError = originalException;\n+        try {\n+            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+        } catch (TimeoutException e) {\n+            LOGGER.warn(\"Timeout during polling for image creation: \", e);\n+        } catch (Exception e) {\n+            LOGGER.warn(\"Exception during polling for image creation: \", e);\n+            onError = e;\n+        } finally {\n+            Optional<VirtualMachineCustomImage> customImage;\n+            customImage = findImage(azureImageInfo, client);\n+            if (customImage.isEmpty()) {\n+                updateImageStatus(ac, azureImageInfo.getImageNameWithRegion(), azureImageInfo.getImageId(), CommonStatus.FAILED);\n+                LOGGER.error(\"Failed to create custom image, throwing: \", onError);\n+                throw new CloudConnectorException(onError);\n             }\n-            LOGGER.error(\"Failed to create custom image: \", originalException);\n-            throw new CloudConnectorException(originalException);\n+            return customImage;\n         }\n-        return customImage;\n     }\n \n     private Optional<VirtualMachineCustomImage> findImage(AzureImageInfo azureImageInfo, AzureClient client) {\n"}}, {"oid": "ae80e5e46f7ffe472e9d952c79a5acfee7422f5f", "url": "https://github.com/hortonworks/cloudbreak/commit/ae80e5e46f7ffe472e9d952c79a5acfee7422f5f", "message": "CB-10029 Azure managed image creation error can potentially lock user out from using its single RG or subscription\n\nThe problem: when a user wants to use a new image, it needs to be copied to its storage account and then a managed image is created from it. The first step in image creation is to persist an image resource to database with status REQUESTED. If an exception comes during image creation then a polling is done. If after the polling the image is still not present then the exception is re-thrown and the user is notified.\nHowever, unbeknownst to the developers, the poller throws an exception on timeout - the code that would set image status to FAILED is not run any more. An image in REQUESTED state would then block the usage of that image forever, it is a trap state.\n\nSolution: the poller after image creation does not throw an exception on any error but lets the calling code decide what to do.", "committedDate": "2020-12-07T08:46:14Z", "type": "forcePushed"}, {"oid": "03130ce87eeb6ebf05ce09c44e7b6b4d039ea9e2", "url": "https://github.com/hortonworks/cloudbreak/commit/03130ce87eeb6ebf05ce09c44e7b6b4d039ea9e2", "message": "CB-10029 Azure managed image creation error can potentially lock user out from using its single RG or subscription\n\nThe problem: when a user wants to use a new image, it needs to be copied to its storage account and then a managed image is created from it. The first step in image creation is to persist an image resource to database with status REQUESTED. If an exception comes during image creation then a polling is done. If after the polling the image is still not present then the exception is re-thrown and the user is notified.\nHowever, unbeknownst to the developers, the poller throws an exception on timeout - the code that would set image status to FAILED is not run any more. An image in REQUESTED state would then block the usage of that image forever, it is a trap state.\n\nSolution: the poller after image creation does not throw an exception on any error but lets the calling code decide what to do.", "committedDate": "2020-12-07T14:54:21Z", "type": "commit"}, {"oid": "03130ce87eeb6ebf05ce09c44e7b6b4d039ea9e2", "url": "https://github.com/hortonworks/cloudbreak/commit/03130ce87eeb6ebf05ce09c44e7b6b4d039ea9e2", "message": "CB-10029 Azure managed image creation error can potentially lock user out from using its single RG or subscription\n\nThe problem: when a user wants to use a new image, it needs to be copied to its storage account and then a managed image is created from it. The first step in image creation is to persist an image resource to database with status REQUESTED. If an exception comes during image creation then a polling is done. If after the polling the image is still not present then the exception is re-thrown and the user is notified.\nHowever, unbeknownst to the developers, the poller throws an exception on timeout - the code that would set image status to FAILED is not run any more. An image in REQUESTED state would then block the usage of that image forever, it is a trap state.\n\nSolution: the poller after image creation does not throw an exception on any error but lets the calling code decide what to do.", "committedDate": "2020-12-07T14:54:21Z", "type": "forcePushed"}]}