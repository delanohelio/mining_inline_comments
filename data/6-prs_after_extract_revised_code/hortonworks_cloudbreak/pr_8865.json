{"pr_number": 8865, "pr_title": "CB-7040 Upgrade salt states during Datalake upgrade", "pr_createdAt": "2020-08-26T09:43:46Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8865", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIzMTM3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8865#discussion_r477231377", "bodyText": "Why is this commented out?", "author": "keyki", "createdAt": "2020-08-26T11:33:03Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/api/event/cluster/upgrade/ClusterUpgradeRequest.java", "diffHunk": "@@ -7,9 +7,4 @@\n     public ClusterUpgradeRequest(Long stackId) {\n         super(stackId);\n     }\n-\n-//    @Override", "originalCommit": "4029a34609c2af10224c32c7c35556fe62c880ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIzMjIxOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8865#discussion_r477232219", "bodyText": "it's not commented. the commented code is deleted", "author": "lacikaaa", "createdAt": "2020-08-26T11:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIzMTM3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b99163bcc04c9e4f6848b2e4ecbbd53ee99cbda9", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/reactor/api/event/cluster/upgrade/ClusterUpgradeRequest.java b/core/src/main/java/com/sequenceiq/cloudbreak/reactor/api/event/cluster/upgrade/ClusterUpgradeRequest.java\nindex c41709d298..4f46ffd2d2 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/reactor/api/event/cluster/upgrade/ClusterUpgradeRequest.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/reactor/api/event/cluster/upgrade/ClusterUpgradeRequest.java\n\n@@ -4,7 +4,14 @@ import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n \n public class ClusterUpgradeRequest extends StackEvent {\n \n-    public ClusterUpgradeRequest(Long stackId) {\n+    private final boolean patchUpgrade;\n+\n+    public ClusterUpgradeRequest(Long stackId, boolean patchUpgrade) {\n         super(stackId);\n+        this.patchUpgrade = patchUpgrade;\n+    }\n+\n+    public boolean isPatchUpgrade() {\n+        return patchUpgrade;\n     }\n }\n"}}, {"oid": "498f97a1e6b1b499d2374fbe70e7a201452684a7", "url": "https://github.com/hortonworks/cloudbreak/commit/498f97a1e6b1b499d2374fbe70e7a201452684a7", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running", "committedDate": "2020-08-26T13:05:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5MjEyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8865#discussion_r477292122", "bodyText": "Can you please rename it to getSupportedOperatingSystems?", "author": "foldik", "createdAt": "2020-08-26T13:17:36Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/ImageService.java", "diffHunk": "@@ -208,7 +155,8 @@ private StatedImage checkIfBasePermitted(StatedImage image, boolean baseImageEna\n         return image;\n     }\n \n-    private Set<String> getSupportedOperationSystems(Long workspaceId, ImageSettingsV4Request imageSettings, String clusterVersion, String platform) throws Exception {\n+    private Set<String> getSupportedOperationSystems(Long workspaceId, ImageSettingsV4Request imageSettings, String clusterVersion, String platform)", "originalCommit": "498f97a1e6b1b499d2374fbe70e7a201452684a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5NzM3MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8865#discussion_r477297370", "bodyText": "sure", "author": "lacikaaa", "createdAt": "2020-08-26T13:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5MjEyMg=="}], "type": "inlineReview", "revised_code": {"commit": "700cf1a8d9d679fe472dcd5cf715b3a1ed1ced17", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/ImageService.java b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/ImageService.java\nindex 8b9cdd81be..31861bf4ab 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/service/image/ImageService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/service/image/ImageService.java\n\n@@ -155,7 +155,7 @@ public class ImageService {\n         return image;\n     }\n \n-    private Set<String> getSupportedOperationSystems(Long workspaceId, ImageSettingsV4Request imageSettings, String clusterVersion, String platform)\n+    private Set<String> getSupportedOperatingSystems(Long workspaceId, ImageSettingsV4Request imageSettings, String clusterVersion, String platform)\n             throws Exception {\n         String imageCatalogName = imageSettings != null ? imageSettings.getCatalog() : null;\n         Set<String> operatingSystems = stackMatrixService.getSupportedOperatingSystems(workspaceId, clusterVersion, platform, imageCatalogName);\n"}}, {"oid": "700cf1a8d9d679fe472dcd5cf715b3a1ed1ced17", "url": "https://github.com/hortonworks/cloudbreak/commit/700cf1a8d9d679fe472dcd5cf715b3a1ed1ced17", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running", "committedDate": "2020-08-26T13:29:45Z", "type": "forcePushed"}, {"oid": "1533efdfc97bd9b41803ab6f2a8ff9428b2408db", "url": "https://github.com/hortonworks/cloudbreak/commit/1533efdfc97bd9b41803ab6f2a8ff9428b2408db", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running", "committedDate": "2020-08-26T14:49:46Z", "type": "forcePushed"}, {"oid": "7d2fca79de60b80078f150e56558936e3653577f", "url": "https://github.com/hortonworks/cloudbreak/commit/7d2fca79de60b80078f150e56558936e3653577f", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running", "committedDate": "2020-08-26T20:28:29Z", "type": "forcePushed"}, {"oid": "b99163bcc04c9e4f6848b2e4ecbbd53ee99cbda9", "url": "https://github.com/hortonworks/cloudbreak/commit/b99163bcc04c9e4f6848b2e4ecbbd53ee99cbda9", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running", "committedDate": "2020-08-26T20:33:41Z", "type": "forcePushed"}, {"oid": "6b7272cc8c5454cfb03b11c477f92d8b59f115c1", "url": "https://github.com/hortonworks/cloudbreak/commit/6b7272cc8c5454cfb03b11c477f92d8b59f115c1", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running", "committedDate": "2020-08-27T06:44:50Z", "type": "forcePushed"}, {"oid": "a2606ef0fd9ca94372562c374b86b0a6539ce63e", "url": "https://github.com/hortonworks/cloudbreak/commit/a2606ef0fd9ca94372562c374b86b0a6539ce63e", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running", "committedDate": "2020-08-27T07:22:17Z", "type": "forcePushed"}, {"oid": "ccf08f00af354317cb877359d9dd8ebb5ba72eef", "url": "https://github.com/hortonworks/cloudbreak/commit/ccf08f00af354317cb877359d9dd8ebb5ba72eef", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running", "committedDate": "2020-08-27T11:09:36Z", "type": "commit"}, {"oid": "ccf08f00af354317cb877359d9dd8ebb5ba72eef", "url": "https://github.com/hortonworks/cloudbreak/commit/ccf08f00af354317cb877359d9dd8ebb5ba72eef", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running", "committedDate": "2020-08-27T11:09:36Z", "type": "forcePushed"}]}