{"pr_number": 7856, "pr_title": "CB-6613 Fix OS upgrade for lauch templates", "pr_createdAt": "2020-04-21T15:05:31Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/7856", "timeline": [{"oid": "e512ea78b0cfcc3dd6e81def2ec37604dfb4caca", "url": "https://github.com/hortonworks/cloudbreak/commit/e512ea78b0cfcc3dd6e81def2ec37604dfb4caca", "message": "CB-6613 Fix OS upgrade for lauch templates", "committedDate": "2020-04-22T13:39:10Z", "type": "commit"}, {"oid": "e512ea78b0cfcc3dd6e81def2ec37604dfb4caca", "url": "https://github.com/hortonworks/cloudbreak/commit/e512ea78b0cfcc3dd6e81def2ec37604dfb4caca", "message": "CB-6613 Fix OS upgrade for lauch templates", "committedDate": "2020-04-22T13:39:10Z", "type": "forcePushed"}, {"oid": "fcda9ed06f2a2cc13f185fe165c2f1d2c44d4d95", "url": "https://github.com/hortonworks/cloudbreak/commit/fcda9ed06f2a2cc13f185fe165c2f1d2c44d4d95", "message": "CB-6613 Fix freeIpaSpotPercentage nullability", "committedDate": "2020-04-22T20:58:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY3MDAzNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7856#discussion_r413670034", "bodyText": "refactor into a method like getTemplateBody", "author": "lacikaaa", "createdAt": "2020-04-23T09:42:27Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java", "diffHunk": "@@ -43,17 +49,33 @@\n     @Inject\n     private AutoScalingGroupHandler autoScalingGroupHandler;\n \n+    @Inject\n+    private AwsStackRequestHelper awsStackRequestHelper;\n+\n     public void updateImage(AuthenticatedContext authenticatedContext, CloudStack stack, CloudResource cfResource) {\n         AwsCredentialView credentialView = new AwsCredentialView(authenticatedContext.getCloudCredential());\n         String regionName = authenticatedContext.getCloudContext().getLocation().getRegion().getRegionName();\n         AmazonCloudFormationClient cloudFormationClient = awsClient.createCloudFormationClient(credentialView, regionName);\n         AmazonAutoScalingClient autoScalingClient = awsClient.createAutoScalingClient(credentialView, regionName);\n \n-        Map<AutoScalingGroup, String> scalingGroups = autoScalingGroupHandler.getAutoScalingGroups(cloudFormationClient, autoScalingClient, cfResource);\n-        List<LaunchConfiguration> oldLaunchConfigurations = launchConfigurationHandler.getLaunchConfigurations(autoScalingClient, scalingGroups.keySet());\n+        String cfStackName = cfResource.getName();\n+        GetTemplateResult template = cloudFormationClient.getTemplate(new GetTemplateRequest().withStackName(cfStackName));\n+        String templateBody = template.getTemplateBody();", "originalCommit": "fcda9ed06f2a2cc13f185fe165c2f1d2c44d4d95", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cb86db259bf03e12097cd24500cacb2a0d225298", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java\nindex 3a3fa7bcd1..a6b9f888d5 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java\n\n@@ -1,134 +1,31 @@\n package com.sequenceiq.cloudbreak.cloud.aws;\n \n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.NoSuchElementException;\n-import java.util.stream.Collectors;\n-\n import javax.inject.Inject;\n \n import org.apache.commons.lang3.NotImplementedException;\n-import org.apache.commons.lang3.StringUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n \n-import com.amazonaws.services.autoscaling.AmazonAutoScalingClient;\n-import com.amazonaws.services.autoscaling.model.AutoScalingGroup;\n-import com.amazonaws.services.autoscaling.model.LaunchConfiguration;\n-import com.amazonaws.services.cloudformation.AmazonCloudFormationClient;\n-import com.amazonaws.services.cloudformation.model.GetTemplateRequest;\n-import com.amazonaws.services.cloudformation.model.GetTemplateResult;\n-import com.amazonaws.services.cloudformation.model.UpdateStackRequest;\n-import com.sequenceiq.cloudbreak.cloud.aws.encryption.EncryptedImageCopyService;\n-import com.sequenceiq.cloudbreak.cloud.aws.view.AwsCredentialView;\n-import com.sequenceiq.cloudbreak.cloud.aws.view.AwsGroupView;\n import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n-import com.sequenceiq.cloudbreak.cloud.notification.ResourceNotifier;\n-import com.sequenceiq.cloudbreak.common.json.Json;\n \n @Service\n public class AwsImageUpdateService {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(AwsImageUpdateService.class);\n-\n-    @Inject\n-    private AwsClient awsClient;\n-\n-    @Inject\n-    private ResourceNotifier resourceNotifier;\n-\n-    @Inject\n-    private EncryptedImageCopyService encryptedImageCopyService;\n \n     @Inject\n-    private LaunchConfigurationHandler launchConfigurationHandler;\n+    private AwsLaunchConfigurationImageUpdateService awsLaunchConfigurationImageUpdateService;\n \n     @Inject\n-    private AutoScalingGroupHandler autoScalingGroupHandler;\n-\n-    @Inject\n-    private AwsStackRequestHelper awsStackRequestHelper;\n+    private AwsLaunchTemplateImageUpdateService awsLaunchTemplateImageUpdateService;\n \n     public void updateImage(AuthenticatedContext authenticatedContext, CloudStack stack, CloudResource cfResource) {\n-        AwsCredentialView credentialView = new AwsCredentialView(authenticatedContext.getCloudCredential());\n-        String regionName = authenticatedContext.getCloudContext().getLocation().getRegion().getRegionName();\n-        AmazonCloudFormationClient cloudFormationClient = awsClient.createCloudFormationClient(credentialView, regionName);\n-        AmazonAutoScalingClient autoScalingClient = awsClient.createAutoScalingClient(credentialView, regionName);\n-\n-        String cfStackName = cfResource.getName();\n-        GetTemplateResult template = cloudFormationClient.getTemplate(new GetTemplateRequest().withStackName(cfStackName));\n-        String templateBody = template.getTemplateBody();\n-\n-        Map<String, String> encryptedImages = getEncryptedImagesMappedByAutoscalingGroupName(authenticatedContext, stack);\n-        if (templateBody.contains(\"AWS::AutoScaling::LaunchConfiguration\")) {\n-            updateImagesInLaunchConfigurations(authenticatedContext, stack, autoScalingClient, encryptedImages, cloudFormationClient, cfResource);\n-        } else if (templateBody.contains(\"AWS::EC2::LaunchTemplate\")) {\n-            updateImagesInCloudFormationTemplate(authenticatedContext, cloudFormationClient, cfResource, encryptedImages, stack, templateBody);\n+        String cfTemplate = stack.getTemplate();\n+        if (cfTemplate.contains(\"AWS::AutoScaling::LaunchConfiguration\")) {\n+            awsLaunchConfigurationImageUpdateService.updateImage(authenticatedContext, stack, cfResource);\n+        } else if (cfTemplate.contains(\"AWS::EC2::LaunchTemplate\")) {\n+            awsLaunchTemplateImageUpdateService.updateImage(authenticatedContext, stack, cfResource);\n         } else {\n-            throw new NotImplementedException(\"Image update for CF template is not implemented yet.\");\n-        }\n-    }\n-\n-    private void updateImagesInLaunchConfigurations(AuthenticatedContext authenticatedContext, CloudStack stack, AmazonAutoScalingClient autoScalingClient,\n-            Map<String, String> encryptedImages, AmazonCloudFormationClient cloudFormationClient, CloudResource cfResource) {\n-        Map<AutoScalingGroup, String> scalingGroups = autoScalingGroupHandler.getAutoScalingGroups(cloudFormationClient, autoScalingClient, cfResource);\n-        List<LaunchConfiguration> oldLaunchConfigurations = launchConfigurationHandler.getLaunchConfigurations(autoScalingClient, scalingGroups.keySet());\n-        for (LaunchConfiguration oldLaunchConfiguration : oldLaunchConfigurations) {\n-            changeImageInAutoscalingGroup(authenticatedContext, stack, autoScalingClient, scalingGroups, encryptedImages, oldLaunchConfiguration);\n+            throw new NotImplementedException(\"Image update for stack template is not implemented yet.\");\n         }\n     }\n-\n-    private void changeImageInAutoscalingGroup(AuthenticatedContext authenticatedContext, CloudStack stack, AmazonAutoScalingClient autoScalingClient,\n-            Map<AutoScalingGroup, String> scalingGroups, Map<String, String> encryptedImages, LaunchConfiguration oldLaunchConfiguration) {\n-\n-        Entry<AutoScalingGroup, String> autoScalingGroup = getAutoScalingGroupForLaunchConfiguration(scalingGroups, oldLaunchConfiguration);\n-\n-        String encryptedImageName = encryptedImages.get(autoScalingGroup.getValue());\n-        String launchConfigurationName = launchConfigurationHandler.createNewLaunchConfiguration(\n-                stack.getImage().getImageName(), autoScalingClient, oldLaunchConfiguration, authenticatedContext.getCloudContext(), encryptedImageName);\n-\n-        autoScalingGroupHandler.updateAutoScalingGroupWithLaunchConfiguration(autoScalingClient, autoScalingGroup.getKey().getAutoScalingGroupName(),\n-                oldLaunchConfiguration, launchConfigurationName);\n-\n-        launchConfigurationHandler.removeOldLaunchConfiguration(oldLaunchConfiguration, autoScalingClient, authenticatedContext.getCloudContext());\n-    }\n-\n-    private Entry<AutoScalingGroup, String> getAutoScalingGroupForLaunchConfiguration(Map<AutoScalingGroup, String> scalingGroups,\n-            LaunchConfiguration oldLaunchConfiguration) {\n-        return scalingGroups.entrySet().stream()\n-                    .filter(entry -> entry.getKey().getLaunchConfigurationName()\n-                            .equalsIgnoreCase(oldLaunchConfiguration.getLaunchConfigurationName()))\n-                    .findFirst().orElseThrow(() -> new NoSuchElementException(\"Launch configuration not found for: \"\n-                        + oldLaunchConfiguration.getLaunchConfigurationName()));\n-    }\n-\n-    private Map<String, String> getEncryptedImagesMappedByAutoscalingGroupName(AuthenticatedContext authenticatedContext, CloudStack stack) {\n-        return encryptedImageCopyService.createEncryptedImages(authenticatedContext, stack, resourceNotifier).entrySet()\n-                    .stream().collect(Collectors.toMap(entry -> AwsGroupView.getAutoScalingGroupName(entry.getKey()), Entry::getValue));\n-    }\n-\n-    private void updateImagesInCloudFormationTemplate(AuthenticatedContext authenticatedContext, AmazonCloudFormationClient cloudFormationClient,\n-            CloudResource cfResource, Map<String, String> encryptedImages, CloudStack stack, String templateBody) {\n-        String imageName = stack.getImage().getImageName();\n-        String cfStackName = cfResource.getName();\n-        Json templateJson = new Json(templateBody);\n-\n-        stack.getGroups().forEach(group -> {\n-            String imageIdPath = String.format(\"Resources.%s.Properties.LaunchTemplateData.ImageId\", AwsGroupView.getLaunchTemplateName(group.getName()));\n-            Object oldImageId = templateJson.getValue(imageIdPath);\n-            if (!\"{\\\"Ref\\\":\\\"AMI\\\"}\".equals(oldImageId.toString())) {\n-                String autoScalingGroupName = AwsGroupView.getAutoScalingGroupName(group.getName());\n-                String encryptedImageName = encryptedImages.get(autoScalingGroupName);\n-                String selectedImageName = StringUtils.isBlank(encryptedImageName) ? imageName : encryptedImageName;\n-                templateJson.replaceValue(imageIdPath, selectedImageName);\n-            }\n-        });\n-\n-        String newTemplateBody = templateJson.getValue();\n-        UpdateStackRequest updateStackRequest = awsStackRequestHelper.createUpdateStackRequest(authenticatedContext, stack, cfStackName, newTemplateBody);\n-        cloudFormationClient.updateStack(updateStackRequest);\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY3OTI3MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7856#discussion_r413679271", "bodyText": "could you refactor it into a method like updateImageInGroup?", "author": "lacikaaa", "createdAt": "2020-04-23T09:56:06Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java", "diffHunk": "@@ -87,4 +109,26 @@ private void changeImageInAutoscalingGroup(AuthenticatedContext authenticatedCon\n         return encryptedImageCopyService.createEncryptedImages(authenticatedContext, stack, resourceNotifier).entrySet()\n                     .stream().collect(Collectors.toMap(entry -> AwsGroupView.getAutoScalingGroupName(entry.getKey()), Entry::getValue));\n     }\n+\n+    private void updateImagesInCloudFormationTemplate(AuthenticatedContext authenticatedContext, AmazonCloudFormationClient cloudFormationClient,\n+            CloudResource cfResource, Map<String, String> encryptedImages, CloudStack stack, String templateBody) {\n+        String imageName = stack.getImage().getImageName();\n+        String cfStackName = cfResource.getName();\n+        Json templateJson = new Json(templateBody);\n+\n+        stack.getGroups().forEach(group -> {\n+            String imageIdPath = String.format(\"Resources.%s.Properties.LaunchTemplateData.ImageId\", AwsGroupView.getLaunchTemplateName(group.getName()));\n+            Object oldImageId = templateJson.getValue(imageIdPath);\n+            if (!\"{\\\"Ref\\\":\\\"AMI\\\"}\".equals(oldImageId.toString())) {\n+                String autoScalingGroupName = AwsGroupView.getAutoScalingGroupName(group.getName());\n+                String encryptedImageName = encryptedImages.get(autoScalingGroupName);\n+                String selectedImageName = StringUtils.isBlank(encryptedImageName) ? imageName : encryptedImageName;\n+                templateJson.replaceValue(imageIdPath, selectedImageName);", "originalCommit": "fcda9ed06f2a2cc13f185fe165c2f1d2c44d4d95", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cb86db259bf03e12097cd24500cacb2a0d225298", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java\nindex 3a3fa7bcd1..a6b9f888d5 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java\n\n@@ -1,134 +1,31 @@\n package com.sequenceiq.cloudbreak.cloud.aws;\n \n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.NoSuchElementException;\n-import java.util.stream.Collectors;\n-\n import javax.inject.Inject;\n \n import org.apache.commons.lang3.NotImplementedException;\n-import org.apache.commons.lang3.StringUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n \n-import com.amazonaws.services.autoscaling.AmazonAutoScalingClient;\n-import com.amazonaws.services.autoscaling.model.AutoScalingGroup;\n-import com.amazonaws.services.autoscaling.model.LaunchConfiguration;\n-import com.amazonaws.services.cloudformation.AmazonCloudFormationClient;\n-import com.amazonaws.services.cloudformation.model.GetTemplateRequest;\n-import com.amazonaws.services.cloudformation.model.GetTemplateResult;\n-import com.amazonaws.services.cloudformation.model.UpdateStackRequest;\n-import com.sequenceiq.cloudbreak.cloud.aws.encryption.EncryptedImageCopyService;\n-import com.sequenceiq.cloudbreak.cloud.aws.view.AwsCredentialView;\n-import com.sequenceiq.cloudbreak.cloud.aws.view.AwsGroupView;\n import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n-import com.sequenceiq.cloudbreak.cloud.notification.ResourceNotifier;\n-import com.sequenceiq.cloudbreak.common.json.Json;\n \n @Service\n public class AwsImageUpdateService {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(AwsImageUpdateService.class);\n-\n-    @Inject\n-    private AwsClient awsClient;\n-\n-    @Inject\n-    private ResourceNotifier resourceNotifier;\n-\n-    @Inject\n-    private EncryptedImageCopyService encryptedImageCopyService;\n \n     @Inject\n-    private LaunchConfigurationHandler launchConfigurationHandler;\n+    private AwsLaunchConfigurationImageUpdateService awsLaunchConfigurationImageUpdateService;\n \n     @Inject\n-    private AutoScalingGroupHandler autoScalingGroupHandler;\n-\n-    @Inject\n-    private AwsStackRequestHelper awsStackRequestHelper;\n+    private AwsLaunchTemplateImageUpdateService awsLaunchTemplateImageUpdateService;\n \n     public void updateImage(AuthenticatedContext authenticatedContext, CloudStack stack, CloudResource cfResource) {\n-        AwsCredentialView credentialView = new AwsCredentialView(authenticatedContext.getCloudCredential());\n-        String regionName = authenticatedContext.getCloudContext().getLocation().getRegion().getRegionName();\n-        AmazonCloudFormationClient cloudFormationClient = awsClient.createCloudFormationClient(credentialView, regionName);\n-        AmazonAutoScalingClient autoScalingClient = awsClient.createAutoScalingClient(credentialView, regionName);\n-\n-        String cfStackName = cfResource.getName();\n-        GetTemplateResult template = cloudFormationClient.getTemplate(new GetTemplateRequest().withStackName(cfStackName));\n-        String templateBody = template.getTemplateBody();\n-\n-        Map<String, String> encryptedImages = getEncryptedImagesMappedByAutoscalingGroupName(authenticatedContext, stack);\n-        if (templateBody.contains(\"AWS::AutoScaling::LaunchConfiguration\")) {\n-            updateImagesInLaunchConfigurations(authenticatedContext, stack, autoScalingClient, encryptedImages, cloudFormationClient, cfResource);\n-        } else if (templateBody.contains(\"AWS::EC2::LaunchTemplate\")) {\n-            updateImagesInCloudFormationTemplate(authenticatedContext, cloudFormationClient, cfResource, encryptedImages, stack, templateBody);\n+        String cfTemplate = stack.getTemplate();\n+        if (cfTemplate.contains(\"AWS::AutoScaling::LaunchConfiguration\")) {\n+            awsLaunchConfigurationImageUpdateService.updateImage(authenticatedContext, stack, cfResource);\n+        } else if (cfTemplate.contains(\"AWS::EC2::LaunchTemplate\")) {\n+            awsLaunchTemplateImageUpdateService.updateImage(authenticatedContext, stack, cfResource);\n         } else {\n-            throw new NotImplementedException(\"Image update for CF template is not implemented yet.\");\n-        }\n-    }\n-\n-    private void updateImagesInLaunchConfigurations(AuthenticatedContext authenticatedContext, CloudStack stack, AmazonAutoScalingClient autoScalingClient,\n-            Map<String, String> encryptedImages, AmazonCloudFormationClient cloudFormationClient, CloudResource cfResource) {\n-        Map<AutoScalingGroup, String> scalingGroups = autoScalingGroupHandler.getAutoScalingGroups(cloudFormationClient, autoScalingClient, cfResource);\n-        List<LaunchConfiguration> oldLaunchConfigurations = launchConfigurationHandler.getLaunchConfigurations(autoScalingClient, scalingGroups.keySet());\n-        for (LaunchConfiguration oldLaunchConfiguration : oldLaunchConfigurations) {\n-            changeImageInAutoscalingGroup(authenticatedContext, stack, autoScalingClient, scalingGroups, encryptedImages, oldLaunchConfiguration);\n+            throw new NotImplementedException(\"Image update for stack template is not implemented yet.\");\n         }\n     }\n-\n-    private void changeImageInAutoscalingGroup(AuthenticatedContext authenticatedContext, CloudStack stack, AmazonAutoScalingClient autoScalingClient,\n-            Map<AutoScalingGroup, String> scalingGroups, Map<String, String> encryptedImages, LaunchConfiguration oldLaunchConfiguration) {\n-\n-        Entry<AutoScalingGroup, String> autoScalingGroup = getAutoScalingGroupForLaunchConfiguration(scalingGroups, oldLaunchConfiguration);\n-\n-        String encryptedImageName = encryptedImages.get(autoScalingGroup.getValue());\n-        String launchConfigurationName = launchConfigurationHandler.createNewLaunchConfiguration(\n-                stack.getImage().getImageName(), autoScalingClient, oldLaunchConfiguration, authenticatedContext.getCloudContext(), encryptedImageName);\n-\n-        autoScalingGroupHandler.updateAutoScalingGroupWithLaunchConfiguration(autoScalingClient, autoScalingGroup.getKey().getAutoScalingGroupName(),\n-                oldLaunchConfiguration, launchConfigurationName);\n-\n-        launchConfigurationHandler.removeOldLaunchConfiguration(oldLaunchConfiguration, autoScalingClient, authenticatedContext.getCloudContext());\n-    }\n-\n-    private Entry<AutoScalingGroup, String> getAutoScalingGroupForLaunchConfiguration(Map<AutoScalingGroup, String> scalingGroups,\n-            LaunchConfiguration oldLaunchConfiguration) {\n-        return scalingGroups.entrySet().stream()\n-                    .filter(entry -> entry.getKey().getLaunchConfigurationName()\n-                            .equalsIgnoreCase(oldLaunchConfiguration.getLaunchConfigurationName()))\n-                    .findFirst().orElseThrow(() -> new NoSuchElementException(\"Launch configuration not found for: \"\n-                        + oldLaunchConfiguration.getLaunchConfigurationName()));\n-    }\n-\n-    private Map<String, String> getEncryptedImagesMappedByAutoscalingGroupName(AuthenticatedContext authenticatedContext, CloudStack stack) {\n-        return encryptedImageCopyService.createEncryptedImages(authenticatedContext, stack, resourceNotifier).entrySet()\n-                    .stream().collect(Collectors.toMap(entry -> AwsGroupView.getAutoScalingGroupName(entry.getKey()), Entry::getValue));\n-    }\n-\n-    private void updateImagesInCloudFormationTemplate(AuthenticatedContext authenticatedContext, AmazonCloudFormationClient cloudFormationClient,\n-            CloudResource cfResource, Map<String, String> encryptedImages, CloudStack stack, String templateBody) {\n-        String imageName = stack.getImage().getImageName();\n-        String cfStackName = cfResource.getName();\n-        Json templateJson = new Json(templateBody);\n-\n-        stack.getGroups().forEach(group -> {\n-            String imageIdPath = String.format(\"Resources.%s.Properties.LaunchTemplateData.ImageId\", AwsGroupView.getLaunchTemplateName(group.getName()));\n-            Object oldImageId = templateJson.getValue(imageIdPath);\n-            if (!\"{\\\"Ref\\\":\\\"AMI\\\"}\".equals(oldImageId.toString())) {\n-                String autoScalingGroupName = AwsGroupView.getAutoScalingGroupName(group.getName());\n-                String encryptedImageName = encryptedImages.get(autoScalingGroupName);\n-                String selectedImageName = StringUtils.isBlank(encryptedImageName) ? imageName : encryptedImageName;\n-                templateJson.replaceValue(imageIdPath, selectedImageName);\n-            }\n-        });\n-\n-        String newTemplateBody = templateJson.getValue();\n-        UpdateStackRequest updateStackRequest = awsStackRequestHelper.createUpdateStackRequest(authenticatedContext, stack, cfStackName, newTemplateBody);\n-        cloudFormationClient.updateStack(updateStackRequest);\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4MDAyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7856#discussion_r413680027", "bodyText": "I don't really get what we check here. Could you refactor the condition into a method and name it so it would be obvious what we check here?", "author": "lacikaaa", "createdAt": "2020-04-23T09:57:05Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java", "diffHunk": "@@ -87,4 +109,26 @@ private void changeImageInAutoscalingGroup(AuthenticatedContext authenticatedCon\n         return encryptedImageCopyService.createEncryptedImages(authenticatedContext, stack, resourceNotifier).entrySet()\n                     .stream().collect(Collectors.toMap(entry -> AwsGroupView.getAutoScalingGroupName(entry.getKey()), Entry::getValue));\n     }\n+\n+    private void updateImagesInCloudFormationTemplate(AuthenticatedContext authenticatedContext, AmazonCloudFormationClient cloudFormationClient,\n+            CloudResource cfResource, Map<String, String> encryptedImages, CloudStack stack, String templateBody) {\n+        String imageName = stack.getImage().getImageName();\n+        String cfStackName = cfResource.getName();\n+        Json templateJson = new Json(templateBody);\n+\n+        stack.getGroups().forEach(group -> {\n+            String imageIdPath = String.format(\"Resources.%s.Properties.LaunchTemplateData.ImageId\", AwsGroupView.getLaunchTemplateName(group.getName()));\n+            Object oldImageId = templateJson.getValue(imageIdPath);\n+            if (!\"{\\\"Ref\\\":\\\"AMI\\\"}\".equals(oldImageId.toString())) {", "originalCommit": "fcda9ed06f2a2cc13f185fe165c2f1d2c44d4d95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5MjI0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7856#discussion_r413692244", "bodyText": "and I think we don't have test for that case when we have to skip the if body", "author": "lacikaaa", "createdAt": "2020-04-23T10:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4MDAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcxNTQ3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7856#discussion_r413715475", "bodyText": "Encrypted images are inlined for each group, but if they are not encrypted it is just a template parameter. So I check if the imageId is a parameter.", "author": "Bajzathd", "createdAt": "2020-04-23T10:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4MDAyNw=="}], "type": "inlineReview", "revised_code": {"commit": "cb86db259bf03e12097cd24500cacb2a0d225298", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java\nindex 3a3fa7bcd1..a6b9f888d5 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java\n\n@@ -1,134 +1,31 @@\n package com.sequenceiq.cloudbreak.cloud.aws;\n \n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.NoSuchElementException;\n-import java.util.stream.Collectors;\n-\n import javax.inject.Inject;\n \n import org.apache.commons.lang3.NotImplementedException;\n-import org.apache.commons.lang3.StringUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n \n-import com.amazonaws.services.autoscaling.AmazonAutoScalingClient;\n-import com.amazonaws.services.autoscaling.model.AutoScalingGroup;\n-import com.amazonaws.services.autoscaling.model.LaunchConfiguration;\n-import com.amazonaws.services.cloudformation.AmazonCloudFormationClient;\n-import com.amazonaws.services.cloudformation.model.GetTemplateRequest;\n-import com.amazonaws.services.cloudformation.model.GetTemplateResult;\n-import com.amazonaws.services.cloudformation.model.UpdateStackRequest;\n-import com.sequenceiq.cloudbreak.cloud.aws.encryption.EncryptedImageCopyService;\n-import com.sequenceiq.cloudbreak.cloud.aws.view.AwsCredentialView;\n-import com.sequenceiq.cloudbreak.cloud.aws.view.AwsGroupView;\n import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n-import com.sequenceiq.cloudbreak.cloud.notification.ResourceNotifier;\n-import com.sequenceiq.cloudbreak.common.json.Json;\n \n @Service\n public class AwsImageUpdateService {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(AwsImageUpdateService.class);\n-\n-    @Inject\n-    private AwsClient awsClient;\n-\n-    @Inject\n-    private ResourceNotifier resourceNotifier;\n-\n-    @Inject\n-    private EncryptedImageCopyService encryptedImageCopyService;\n \n     @Inject\n-    private LaunchConfigurationHandler launchConfigurationHandler;\n+    private AwsLaunchConfigurationImageUpdateService awsLaunchConfigurationImageUpdateService;\n \n     @Inject\n-    private AutoScalingGroupHandler autoScalingGroupHandler;\n-\n-    @Inject\n-    private AwsStackRequestHelper awsStackRequestHelper;\n+    private AwsLaunchTemplateImageUpdateService awsLaunchTemplateImageUpdateService;\n \n     public void updateImage(AuthenticatedContext authenticatedContext, CloudStack stack, CloudResource cfResource) {\n-        AwsCredentialView credentialView = new AwsCredentialView(authenticatedContext.getCloudCredential());\n-        String regionName = authenticatedContext.getCloudContext().getLocation().getRegion().getRegionName();\n-        AmazonCloudFormationClient cloudFormationClient = awsClient.createCloudFormationClient(credentialView, regionName);\n-        AmazonAutoScalingClient autoScalingClient = awsClient.createAutoScalingClient(credentialView, regionName);\n-\n-        String cfStackName = cfResource.getName();\n-        GetTemplateResult template = cloudFormationClient.getTemplate(new GetTemplateRequest().withStackName(cfStackName));\n-        String templateBody = template.getTemplateBody();\n-\n-        Map<String, String> encryptedImages = getEncryptedImagesMappedByAutoscalingGroupName(authenticatedContext, stack);\n-        if (templateBody.contains(\"AWS::AutoScaling::LaunchConfiguration\")) {\n-            updateImagesInLaunchConfigurations(authenticatedContext, stack, autoScalingClient, encryptedImages, cloudFormationClient, cfResource);\n-        } else if (templateBody.contains(\"AWS::EC2::LaunchTemplate\")) {\n-            updateImagesInCloudFormationTemplate(authenticatedContext, cloudFormationClient, cfResource, encryptedImages, stack, templateBody);\n+        String cfTemplate = stack.getTemplate();\n+        if (cfTemplate.contains(\"AWS::AutoScaling::LaunchConfiguration\")) {\n+            awsLaunchConfigurationImageUpdateService.updateImage(authenticatedContext, stack, cfResource);\n+        } else if (cfTemplate.contains(\"AWS::EC2::LaunchTemplate\")) {\n+            awsLaunchTemplateImageUpdateService.updateImage(authenticatedContext, stack, cfResource);\n         } else {\n-            throw new NotImplementedException(\"Image update for CF template is not implemented yet.\");\n-        }\n-    }\n-\n-    private void updateImagesInLaunchConfigurations(AuthenticatedContext authenticatedContext, CloudStack stack, AmazonAutoScalingClient autoScalingClient,\n-            Map<String, String> encryptedImages, AmazonCloudFormationClient cloudFormationClient, CloudResource cfResource) {\n-        Map<AutoScalingGroup, String> scalingGroups = autoScalingGroupHandler.getAutoScalingGroups(cloudFormationClient, autoScalingClient, cfResource);\n-        List<LaunchConfiguration> oldLaunchConfigurations = launchConfigurationHandler.getLaunchConfigurations(autoScalingClient, scalingGroups.keySet());\n-        for (LaunchConfiguration oldLaunchConfiguration : oldLaunchConfigurations) {\n-            changeImageInAutoscalingGroup(authenticatedContext, stack, autoScalingClient, scalingGroups, encryptedImages, oldLaunchConfiguration);\n+            throw new NotImplementedException(\"Image update for stack template is not implemented yet.\");\n         }\n     }\n-\n-    private void changeImageInAutoscalingGroup(AuthenticatedContext authenticatedContext, CloudStack stack, AmazonAutoScalingClient autoScalingClient,\n-            Map<AutoScalingGroup, String> scalingGroups, Map<String, String> encryptedImages, LaunchConfiguration oldLaunchConfiguration) {\n-\n-        Entry<AutoScalingGroup, String> autoScalingGroup = getAutoScalingGroupForLaunchConfiguration(scalingGroups, oldLaunchConfiguration);\n-\n-        String encryptedImageName = encryptedImages.get(autoScalingGroup.getValue());\n-        String launchConfigurationName = launchConfigurationHandler.createNewLaunchConfiguration(\n-                stack.getImage().getImageName(), autoScalingClient, oldLaunchConfiguration, authenticatedContext.getCloudContext(), encryptedImageName);\n-\n-        autoScalingGroupHandler.updateAutoScalingGroupWithLaunchConfiguration(autoScalingClient, autoScalingGroup.getKey().getAutoScalingGroupName(),\n-                oldLaunchConfiguration, launchConfigurationName);\n-\n-        launchConfigurationHandler.removeOldLaunchConfiguration(oldLaunchConfiguration, autoScalingClient, authenticatedContext.getCloudContext());\n-    }\n-\n-    private Entry<AutoScalingGroup, String> getAutoScalingGroupForLaunchConfiguration(Map<AutoScalingGroup, String> scalingGroups,\n-            LaunchConfiguration oldLaunchConfiguration) {\n-        return scalingGroups.entrySet().stream()\n-                    .filter(entry -> entry.getKey().getLaunchConfigurationName()\n-                            .equalsIgnoreCase(oldLaunchConfiguration.getLaunchConfigurationName()))\n-                    .findFirst().orElseThrow(() -> new NoSuchElementException(\"Launch configuration not found for: \"\n-                        + oldLaunchConfiguration.getLaunchConfigurationName()));\n-    }\n-\n-    private Map<String, String> getEncryptedImagesMappedByAutoscalingGroupName(AuthenticatedContext authenticatedContext, CloudStack stack) {\n-        return encryptedImageCopyService.createEncryptedImages(authenticatedContext, stack, resourceNotifier).entrySet()\n-                    .stream().collect(Collectors.toMap(entry -> AwsGroupView.getAutoScalingGroupName(entry.getKey()), Entry::getValue));\n-    }\n-\n-    private void updateImagesInCloudFormationTemplate(AuthenticatedContext authenticatedContext, AmazonCloudFormationClient cloudFormationClient,\n-            CloudResource cfResource, Map<String, String> encryptedImages, CloudStack stack, String templateBody) {\n-        String imageName = stack.getImage().getImageName();\n-        String cfStackName = cfResource.getName();\n-        Json templateJson = new Json(templateBody);\n-\n-        stack.getGroups().forEach(group -> {\n-            String imageIdPath = String.format(\"Resources.%s.Properties.LaunchTemplateData.ImageId\", AwsGroupView.getLaunchTemplateName(group.getName()));\n-            Object oldImageId = templateJson.getValue(imageIdPath);\n-            if (!\"{\\\"Ref\\\":\\\"AMI\\\"}\".equals(oldImageId.toString())) {\n-                String autoScalingGroupName = AwsGroupView.getAutoScalingGroupName(group.getName());\n-                String encryptedImageName = encryptedImages.get(autoScalingGroupName);\n-                String selectedImageName = StringUtils.isBlank(encryptedImageName) ? imageName : encryptedImageName;\n-                templateJson.replaceValue(imageIdPath, selectedImageName);\n-            }\n-        });\n-\n-        String newTemplateBody = templateJson.getValue();\n-        UpdateStackRequest updateStackRequest = awsStackRequestHelper.createUpdateStackRequest(authenticatedContext, stack, cfStackName, newTemplateBody);\n-        cloudFormationClient.updateStack(updateStackRequest);\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4MTExMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7856#discussion_r413681111", "bodyText": "could you make 2 separate classes which contains only the methods related to the 2 different update type?", "author": "lacikaaa", "createdAt": "2020-04-23T09:58:45Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java", "diffHunk": "@@ -43,17 +49,33 @@\n     @Inject\n     private AutoScalingGroupHandler autoScalingGroupHandler;\n \n+    @Inject\n+    private AwsStackRequestHelper awsStackRequestHelper;\n+\n     public void updateImage(AuthenticatedContext authenticatedContext, CloudStack stack, CloudResource cfResource) {\n         AwsCredentialView credentialView = new AwsCredentialView(authenticatedContext.getCloudCredential());\n         String regionName = authenticatedContext.getCloudContext().getLocation().getRegion().getRegionName();\n         AmazonCloudFormationClient cloudFormationClient = awsClient.createCloudFormationClient(credentialView, regionName);\n         AmazonAutoScalingClient autoScalingClient = awsClient.createAutoScalingClient(credentialView, regionName);\n \n-        Map<AutoScalingGroup, String> scalingGroups = autoScalingGroupHandler.getAutoScalingGroups(cloudFormationClient, autoScalingClient, cfResource);\n-        List<LaunchConfiguration> oldLaunchConfigurations = launchConfigurationHandler.getLaunchConfigurations(autoScalingClient, scalingGroups.keySet());\n+        String cfStackName = cfResource.getName();\n+        GetTemplateResult template = cloudFormationClient.getTemplate(new GetTemplateRequest().withStackName(cfStackName));\n+        String templateBody = template.getTemplateBody();\n \n         Map<String, String> encryptedImages = getEncryptedImagesMappedByAutoscalingGroupName(authenticatedContext, stack);\n+        if (templateBody.contains(\"AWS::AutoScaling::LaunchConfiguration\")) {\n+            updateImagesInLaunchConfigurations(authenticatedContext, stack, autoScalingClient, encryptedImages, cloudFormationClient, cfResource);\n+        } else if (templateBody.contains(\"AWS::EC2::LaunchTemplate\")) {\n+            updateImagesInCloudFormationTemplate(authenticatedContext, cloudFormationClient, cfResource, encryptedImages, stack, templateBody);\n+        } else {", "originalCommit": "fcda9ed06f2a2cc13f185fe165c2f1d2c44d4d95", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cb86db259bf03e12097cd24500cacb2a0d225298", "chunk": "diff --git a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java\nindex 3a3fa7bcd1..a6b9f888d5 100644\n--- a/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java\n+++ b/cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsImageUpdateService.java\n\n@@ -1,134 +1,31 @@\n package com.sequenceiq.cloudbreak.cloud.aws;\n \n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.NoSuchElementException;\n-import java.util.stream.Collectors;\n-\n import javax.inject.Inject;\n \n import org.apache.commons.lang3.NotImplementedException;\n-import org.apache.commons.lang3.StringUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n \n-import com.amazonaws.services.autoscaling.AmazonAutoScalingClient;\n-import com.amazonaws.services.autoscaling.model.AutoScalingGroup;\n-import com.amazonaws.services.autoscaling.model.LaunchConfiguration;\n-import com.amazonaws.services.cloudformation.AmazonCloudFormationClient;\n-import com.amazonaws.services.cloudformation.model.GetTemplateRequest;\n-import com.amazonaws.services.cloudformation.model.GetTemplateResult;\n-import com.amazonaws.services.cloudformation.model.UpdateStackRequest;\n-import com.sequenceiq.cloudbreak.cloud.aws.encryption.EncryptedImageCopyService;\n-import com.sequenceiq.cloudbreak.cloud.aws.view.AwsCredentialView;\n-import com.sequenceiq.cloudbreak.cloud.aws.view.AwsGroupView;\n import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n-import com.sequenceiq.cloudbreak.cloud.notification.ResourceNotifier;\n-import com.sequenceiq.cloudbreak.common.json.Json;\n \n @Service\n public class AwsImageUpdateService {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(AwsImageUpdateService.class);\n-\n-    @Inject\n-    private AwsClient awsClient;\n-\n-    @Inject\n-    private ResourceNotifier resourceNotifier;\n-\n-    @Inject\n-    private EncryptedImageCopyService encryptedImageCopyService;\n \n     @Inject\n-    private LaunchConfigurationHandler launchConfigurationHandler;\n+    private AwsLaunchConfigurationImageUpdateService awsLaunchConfigurationImageUpdateService;\n \n     @Inject\n-    private AutoScalingGroupHandler autoScalingGroupHandler;\n-\n-    @Inject\n-    private AwsStackRequestHelper awsStackRequestHelper;\n+    private AwsLaunchTemplateImageUpdateService awsLaunchTemplateImageUpdateService;\n \n     public void updateImage(AuthenticatedContext authenticatedContext, CloudStack stack, CloudResource cfResource) {\n-        AwsCredentialView credentialView = new AwsCredentialView(authenticatedContext.getCloudCredential());\n-        String regionName = authenticatedContext.getCloudContext().getLocation().getRegion().getRegionName();\n-        AmazonCloudFormationClient cloudFormationClient = awsClient.createCloudFormationClient(credentialView, regionName);\n-        AmazonAutoScalingClient autoScalingClient = awsClient.createAutoScalingClient(credentialView, regionName);\n-\n-        String cfStackName = cfResource.getName();\n-        GetTemplateResult template = cloudFormationClient.getTemplate(new GetTemplateRequest().withStackName(cfStackName));\n-        String templateBody = template.getTemplateBody();\n-\n-        Map<String, String> encryptedImages = getEncryptedImagesMappedByAutoscalingGroupName(authenticatedContext, stack);\n-        if (templateBody.contains(\"AWS::AutoScaling::LaunchConfiguration\")) {\n-            updateImagesInLaunchConfigurations(authenticatedContext, stack, autoScalingClient, encryptedImages, cloudFormationClient, cfResource);\n-        } else if (templateBody.contains(\"AWS::EC2::LaunchTemplate\")) {\n-            updateImagesInCloudFormationTemplate(authenticatedContext, cloudFormationClient, cfResource, encryptedImages, stack, templateBody);\n+        String cfTemplate = stack.getTemplate();\n+        if (cfTemplate.contains(\"AWS::AutoScaling::LaunchConfiguration\")) {\n+            awsLaunchConfigurationImageUpdateService.updateImage(authenticatedContext, stack, cfResource);\n+        } else if (cfTemplate.contains(\"AWS::EC2::LaunchTemplate\")) {\n+            awsLaunchTemplateImageUpdateService.updateImage(authenticatedContext, stack, cfResource);\n         } else {\n-            throw new NotImplementedException(\"Image update for CF template is not implemented yet.\");\n-        }\n-    }\n-\n-    private void updateImagesInLaunchConfigurations(AuthenticatedContext authenticatedContext, CloudStack stack, AmazonAutoScalingClient autoScalingClient,\n-            Map<String, String> encryptedImages, AmazonCloudFormationClient cloudFormationClient, CloudResource cfResource) {\n-        Map<AutoScalingGroup, String> scalingGroups = autoScalingGroupHandler.getAutoScalingGroups(cloudFormationClient, autoScalingClient, cfResource);\n-        List<LaunchConfiguration> oldLaunchConfigurations = launchConfigurationHandler.getLaunchConfigurations(autoScalingClient, scalingGroups.keySet());\n-        for (LaunchConfiguration oldLaunchConfiguration : oldLaunchConfigurations) {\n-            changeImageInAutoscalingGroup(authenticatedContext, stack, autoScalingClient, scalingGroups, encryptedImages, oldLaunchConfiguration);\n+            throw new NotImplementedException(\"Image update for stack template is not implemented yet.\");\n         }\n     }\n-\n-    private void changeImageInAutoscalingGroup(AuthenticatedContext authenticatedContext, CloudStack stack, AmazonAutoScalingClient autoScalingClient,\n-            Map<AutoScalingGroup, String> scalingGroups, Map<String, String> encryptedImages, LaunchConfiguration oldLaunchConfiguration) {\n-\n-        Entry<AutoScalingGroup, String> autoScalingGroup = getAutoScalingGroupForLaunchConfiguration(scalingGroups, oldLaunchConfiguration);\n-\n-        String encryptedImageName = encryptedImages.get(autoScalingGroup.getValue());\n-        String launchConfigurationName = launchConfigurationHandler.createNewLaunchConfiguration(\n-                stack.getImage().getImageName(), autoScalingClient, oldLaunchConfiguration, authenticatedContext.getCloudContext(), encryptedImageName);\n-\n-        autoScalingGroupHandler.updateAutoScalingGroupWithLaunchConfiguration(autoScalingClient, autoScalingGroup.getKey().getAutoScalingGroupName(),\n-                oldLaunchConfiguration, launchConfigurationName);\n-\n-        launchConfigurationHandler.removeOldLaunchConfiguration(oldLaunchConfiguration, autoScalingClient, authenticatedContext.getCloudContext());\n-    }\n-\n-    private Entry<AutoScalingGroup, String> getAutoScalingGroupForLaunchConfiguration(Map<AutoScalingGroup, String> scalingGroups,\n-            LaunchConfiguration oldLaunchConfiguration) {\n-        return scalingGroups.entrySet().stream()\n-                    .filter(entry -> entry.getKey().getLaunchConfigurationName()\n-                            .equalsIgnoreCase(oldLaunchConfiguration.getLaunchConfigurationName()))\n-                    .findFirst().orElseThrow(() -> new NoSuchElementException(\"Launch configuration not found for: \"\n-                        + oldLaunchConfiguration.getLaunchConfigurationName()));\n-    }\n-\n-    private Map<String, String> getEncryptedImagesMappedByAutoscalingGroupName(AuthenticatedContext authenticatedContext, CloudStack stack) {\n-        return encryptedImageCopyService.createEncryptedImages(authenticatedContext, stack, resourceNotifier).entrySet()\n-                    .stream().collect(Collectors.toMap(entry -> AwsGroupView.getAutoScalingGroupName(entry.getKey()), Entry::getValue));\n-    }\n-\n-    private void updateImagesInCloudFormationTemplate(AuthenticatedContext authenticatedContext, AmazonCloudFormationClient cloudFormationClient,\n-            CloudResource cfResource, Map<String, String> encryptedImages, CloudStack stack, String templateBody) {\n-        String imageName = stack.getImage().getImageName();\n-        String cfStackName = cfResource.getName();\n-        Json templateJson = new Json(templateBody);\n-\n-        stack.getGroups().forEach(group -> {\n-            String imageIdPath = String.format(\"Resources.%s.Properties.LaunchTemplateData.ImageId\", AwsGroupView.getLaunchTemplateName(group.getName()));\n-            Object oldImageId = templateJson.getValue(imageIdPath);\n-            if (!\"{\\\"Ref\\\":\\\"AMI\\\"}\".equals(oldImageId.toString())) {\n-                String autoScalingGroupName = AwsGroupView.getAutoScalingGroupName(group.getName());\n-                String encryptedImageName = encryptedImages.get(autoScalingGroupName);\n-                String selectedImageName = StringUtils.isBlank(encryptedImageName) ? imageName : encryptedImageName;\n-                templateJson.replaceValue(imageIdPath, selectedImageName);\n-            }\n-        });\n-\n-        String newTemplateBody = templateJson.getValue();\n-        UpdateStackRequest updateStackRequest = awsStackRequestHelper.createUpdateStackRequest(authenticatedContext, stack, cfStackName, newTemplateBody);\n-        cloudFormationClient.updateStack(updateStackRequest);\n-    }\n }\n"}}, {"oid": "cb86db259bf03e12097cd24500cacb2a0d225298", "url": "https://github.com/hortonworks/cloudbreak/commit/cb86db259bf03e12097cd24500cacb2a0d225298", "message": "CB-6613 Refactor aws image update", "committedDate": "2020-04-23T12:42:45Z", "type": "commit"}]}