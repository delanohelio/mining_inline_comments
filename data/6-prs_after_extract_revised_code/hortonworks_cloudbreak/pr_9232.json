{"pr_number": 9232, "pr_title": "CB-8147. Make node specific metadata (hostGroup, YARN NM attributes)", "pr_createdAt": "2020-10-17T17:53:19Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9232", "timeline": [{"oid": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "url": "https://github.com/hortonworks/cloudbreak/commit/5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "message": "Fix test.", "committedDate": "2020-10-23T20:48:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3MTUwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527671502", "bodyText": "I don't think Node should contain this attributes map. It's used only to create a pillar. The main purpose of this class is to pass these data to SaltBootstrap installed on the instances to configure them.\nInstead of adding this info to the node you could calculate it when it's need in ClusterHostServiceRunner", "author": "lacikaaa", "createdAt": "2020-11-20T12:52:59Z", "path": "orchestrator-api/src/main/java/com/sequenceiq/cloudbreak/orchestrator/model/Node.java", "diffHunk": "@@ -23,19 +25,33 @@\n \n     private String uuids;\n \n+    // Used for generic attributes associated with the node. e.g. YARN attributes when running NMs, Spot vs non-spot, etc\n+    private Map<String, Map<String, String>> attributes;", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNDk0OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r528114949", "bodyText": "Will look into this as an option.", "author": "sidseth", "createdAt": "2020-11-21T07:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3MTUwMg=="}], "type": "inlineReview", "revised_code": {"commit": "6d8eff0171e7193f8244a88e2f45736ffa202b62", "chunk": "diff --git a/orchestrator-api/src/main/java/com/sequenceiq/cloudbreak/orchestrator/model/Node.java b/orchestrator-api/src/main/java/com/sequenceiq/cloudbreak/orchestrator/model/Node.java\nindex 2c9ad47073..dfb54552cd 100644\n--- a/orchestrator-api/src/main/java/com/sequenceiq/cloudbreak/orchestrator/model/Node.java\n+++ b/orchestrator-api/src/main/java/com/sequenceiq/cloudbreak/orchestrator/model/Node.java\n\n@@ -25,33 +23,19 @@ public class Node {\n \n     private String uuids;\n \n-    // Used for generic attributes associated with the node. e.g. YARN attributes when running NMs, Spot vs non-spot, etc\n-    private Map<String, Map<String, String>> attributes;\n-\n     public Node(String privateIp, String publicIp, String instanceId, String instanceType, String fqdn, String hostGroup) {\n         this(privateIp, publicIp, instanceId, instanceType, fqdn, null, hostGroup);\n     }\n \n-    public Node(String privateIp, String publicIp, String instanceId, String instanceType, String fqdn,\n-            String hostGroup, Map<String, Map<String, String>> attributes) {\n-        this(privateIp, publicIp, instanceId, instanceType, fqdn, null, hostGroup, attributes);\n-    }\n-\n     public Node(String privateIp, String publicIp, String instanceId, String instanceType, String fqdn, String hostGroup, String dataVolumes,\n             String serialIds, String fstab, String uuids) {\n-        this(privateIp, publicIp, instanceId, instanceType, fqdn, hostGroup);\n+        this(privateIp, publicIp, instanceId, instanceType, fqdn, null, hostGroup);\n         this.dataVolumes = dataVolumes;\n         this.serialIds = serialIds;\n         this.fstab = fstab;\n         this.uuids = uuids;\n     }\n \n-    public Node(String privateIp, String publicIp, String instanceId, String instanceType, String fqdn, String domain, String hostGroup,\n-            Map<String, Map<String, String>> attributes) {\n-        this(privateIp, publicIp, instanceId, instanceType, fqdn, domain, hostGroup);\n-        this.attributes = attributes;\n-    }\n-\n     public Node(String privateIp, String publicIp, String instanceId, String instanceType, String fqdn, String domain, String hostGroup) {\n         this(privateIp, publicIp, instanceId, instanceType);\n         hostname = fqdn;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3OTI2MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527679260", "bodyText": "it would be nicer with stream:\nMap<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n                .filter(this::isYarnNodemanager)\n                .collect(toMap(Entry::getKey, Entry::getValue));\n\nprivate boolean isYarnNodemanager(Entry<String, Set<ServiceComponent>> entry) {\n        return entry.getValue().stream().anyMatch(sc -> YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n                && YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n    }", "author": "lacikaaa", "createdAt": "2020-11-20T13:08:27Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n+        // The only attributes required at the moment relate to the YARN NodeManager.\n+        // This functionality can be moved to an interface / separated if additional components\n+        // need this functionality.\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n+        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n+            for (ServiceComponent sc : entry.getValue()) {\n+                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n+                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n+                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n+                    break;\n+                }\n+            }\n+        }", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNTUyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r528115527", "bodyText": "I don't like using Java streams (not as easy to read). If that's the pattern that is generally used, I can switch it over. (Applies to other comments related to streams)", "author": "sidseth", "createdAt": "2020-11-21T07:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3OTI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "6d8eff0171e7193f8244a88e2f45736ffa202b62", "chunk": "diff --git a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\nindex 5c278e8372..ff09df14b2 100644\n--- a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n+++ b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n\n@@ -313,50 +313,45 @@ public class CmTemplateProcessor implements BlueprintTextProcessor {\n \n     @Override\n     public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n-        // The only attributes required at the moment relate to the YARN NodeManager.\n-        // This functionality can be moved to an interface / separated if additional components\n-        // need this functionality.\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n-        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n-            for (ServiceComponent sc : entry.getValue()) {\n-                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n-                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n-                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n-                    break;\n-                }\n-            }\n-        }\n-        // We have the hostGroups without GATEWAY components with YARN NodeManagers\n-        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n-                .stream().collect(\n-                        toMap(\n-                                Entry::getKey,\n-                                e -> e.getValue().stream()\n-                                .map(ServiceComponent::getComponent)\n-                                .collect(Collectors.toUnmodifiableSet())\n-                ));\n-        // Re-using the current LoadBasedAutoScaling recommendation along with the above YARN filter.\n+        Map<String, Set<String>> componentsByHostGroup = collectComponentsByHostGroup();\n+\n+        // Re-using the current LoadBasedAutoScaling recommendation to determine hostGroups which can\n+        // be autoscaled and marked as YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n         Set<String> computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\n                 true, componentsByHostGroup);\n \n         Map<String, Map<String, ServiceAttributes>> result = new HashMap<>();\n \n         for (String hg : componentsByHostGroup.keySet()) {\n-            Map<String, ServiceAttributes> m;\n-            if (computeHostGroups.contains(hg)) {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE)));\n-            } else {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER)));\n-            }\n-            result.put(hg, m);\n+            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n+                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n+\n+            result.put(hg, Collections.singletonMap(YarnRoles.YARN,\n+                    new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n+                            Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType))));\n         }\n         LOGGER.debug(\"ServiceAttributes: {}\", result);\n         return result;\n     }\n \n+    private Map<String, Set<String>> collectComponentsByHostGroup() {\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n+                .filter(e -> isYarnNodemanager(e.getValue()))\n+                .collect(toMap(Entry::getKey, Entry::getValue));\n+        return hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n+                .stream().collect(toMap(e -> e.getKey(), e -> collectComponents(e.getValue())));\n+    }\n+\n+    private boolean isYarnNodemanager(Set<ServiceComponent> serviceComponents) {\n+        return serviceComponents.stream().anyMatch(sc -> YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n+            && YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n+    }\n+\n+    private Set<String> collectComponents(Set<ServiceComponent> serviceComponentSet) {\n+        return serviceComponentSet.stream().map(ServiceComponent::getComponent).collect(Collectors.toUnmodifiableSet());\n+    }\n+\n     @Override\n     public List<String> getHostTemplateNames() {\n         return Optional.ofNullable(cmTemplate.getHostTemplates())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3OTQxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527679414", "bodyText": "doesn't seem relevant, could you drop these?", "author": "lacikaaa", "createdAt": "2020-11-20T13:08:46Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n+        // The only attributes required at the moment relate to the YARN NodeManager.\n+        // This functionality can be moved to an interface / separated if additional components\n+        // need this functionality.", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNTkzMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r528115931", "bodyText": "Sure. This was a comment to indicate potential future changes.", "author": "sidseth", "createdAt": "2020-11-21T07:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3OTQxNA=="}], "type": "inlineReview", "revised_code": {"commit": "6d8eff0171e7193f8244a88e2f45736ffa202b62", "chunk": "diff --git a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\nindex 5c278e8372..ff09df14b2 100644\n--- a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n+++ b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n\n@@ -313,50 +313,45 @@ public class CmTemplateProcessor implements BlueprintTextProcessor {\n \n     @Override\n     public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n-        // The only attributes required at the moment relate to the YARN NodeManager.\n-        // This functionality can be moved to an interface / separated if additional components\n-        // need this functionality.\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n-        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n-            for (ServiceComponent sc : entry.getValue()) {\n-                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n-                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n-                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n-                    break;\n-                }\n-            }\n-        }\n-        // We have the hostGroups without GATEWAY components with YARN NodeManagers\n-        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n-                .stream().collect(\n-                        toMap(\n-                                Entry::getKey,\n-                                e -> e.getValue().stream()\n-                                .map(ServiceComponent::getComponent)\n-                                .collect(Collectors.toUnmodifiableSet())\n-                ));\n-        // Re-using the current LoadBasedAutoScaling recommendation along with the above YARN filter.\n+        Map<String, Set<String>> componentsByHostGroup = collectComponentsByHostGroup();\n+\n+        // Re-using the current LoadBasedAutoScaling recommendation to determine hostGroups which can\n+        // be autoscaled and marked as YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n         Set<String> computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\n                 true, componentsByHostGroup);\n \n         Map<String, Map<String, ServiceAttributes>> result = new HashMap<>();\n \n         for (String hg : componentsByHostGroup.keySet()) {\n-            Map<String, ServiceAttributes> m;\n-            if (computeHostGroups.contains(hg)) {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE)));\n-            } else {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER)));\n-            }\n-            result.put(hg, m);\n+            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n+                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n+\n+            result.put(hg, Collections.singletonMap(YarnRoles.YARN,\n+                    new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n+                            Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType))));\n         }\n         LOGGER.debug(\"ServiceAttributes: {}\", result);\n         return result;\n     }\n \n+    private Map<String, Set<String>> collectComponentsByHostGroup() {\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n+                .filter(e -> isYarnNodemanager(e.getValue()))\n+                .collect(toMap(Entry::getKey, Entry::getValue));\n+        return hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n+                .stream().collect(toMap(e -> e.getKey(), e -> collectComponents(e.getValue())));\n+    }\n+\n+    private boolean isYarnNodemanager(Set<ServiceComponent> serviceComponents) {\n+        return serviceComponents.stream().anyMatch(sc -> YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n+            && YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n+    }\n+\n+    private Set<String> collectComponents(Set<ServiceComponent> serviceComponentSet) {\n+        return serviceComponentSet.stream().map(ServiceComponent::getComponent).collect(Collectors.toUnmodifiableSet());\n+    }\n+\n     @Override\n     public List<String> getHostTemplateNames() {\n         return Optional.ofNullable(cmTemplate.getHostTemplates())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MDY5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527680692", "bodyText": "this part should be moved out and named in a separate method", "author": "lacikaaa", "createdAt": "2020-11-20T13:11:13Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n+        // The only attributes required at the moment relate to the YARN NodeManager.\n+        // This functionality can be moved to an interface / separated if additional components\n+        // need this functionality.\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n+        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n+            for (ServiceComponent sc : entry.getValue()) {\n+                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n+                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n+                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n+                    break;\n+                }\n+            }\n+        }\n+        // We have the hostGroups without GATEWAY components with YARN NodeManagers\n+        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n+                .stream().collect(\n+                        toMap(\n+                                Entry::getKey,\n+                                e -> e.getValue().stream()\n+                                .map(ServiceComponent::getComponent)\n+                                .collect(Collectors.toUnmodifiableSet())", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d8eff0171e7193f8244a88e2f45736ffa202b62", "chunk": "diff --git a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\nindex 5c278e8372..ff09df14b2 100644\n--- a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n+++ b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n\n@@ -313,50 +313,45 @@ public class CmTemplateProcessor implements BlueprintTextProcessor {\n \n     @Override\n     public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n-        // The only attributes required at the moment relate to the YARN NodeManager.\n-        // This functionality can be moved to an interface / separated if additional components\n-        // need this functionality.\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n-        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n-            for (ServiceComponent sc : entry.getValue()) {\n-                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n-                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n-                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n-                    break;\n-                }\n-            }\n-        }\n-        // We have the hostGroups without GATEWAY components with YARN NodeManagers\n-        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n-                .stream().collect(\n-                        toMap(\n-                                Entry::getKey,\n-                                e -> e.getValue().stream()\n-                                .map(ServiceComponent::getComponent)\n-                                .collect(Collectors.toUnmodifiableSet())\n-                ));\n-        // Re-using the current LoadBasedAutoScaling recommendation along with the above YARN filter.\n+        Map<String, Set<String>> componentsByHostGroup = collectComponentsByHostGroup();\n+\n+        // Re-using the current LoadBasedAutoScaling recommendation to determine hostGroups which can\n+        // be autoscaled and marked as YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n         Set<String> computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\n                 true, componentsByHostGroup);\n \n         Map<String, Map<String, ServiceAttributes>> result = new HashMap<>();\n \n         for (String hg : componentsByHostGroup.keySet()) {\n-            Map<String, ServiceAttributes> m;\n-            if (computeHostGroups.contains(hg)) {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE)));\n-            } else {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER)));\n-            }\n-            result.put(hg, m);\n+            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n+                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n+\n+            result.put(hg, Collections.singletonMap(YarnRoles.YARN,\n+                    new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n+                            Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType))));\n         }\n         LOGGER.debug(\"ServiceAttributes: {}\", result);\n         return result;\n     }\n \n+    private Map<String, Set<String>> collectComponentsByHostGroup() {\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n+                .filter(e -> isYarnNodemanager(e.getValue()))\n+                .collect(toMap(Entry::getKey, Entry::getValue));\n+        return hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n+                .stream().collect(toMap(e -> e.getKey(), e -> collectComponents(e.getValue())));\n+    }\n+\n+    private boolean isYarnNodemanager(Set<ServiceComponent> serviceComponents) {\n+        return serviceComponents.stream().anyMatch(sc -> YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n+            && YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n+    }\n+\n+    private Set<String> collectComponents(Set<ServiceComponent> serviceComponentSet) {\n+        return serviceComponentSet.stream().map(ServiceComponent::getComponent).collect(Collectors.toUnmodifiableSet());\n+    }\n+\n     @Override\n     public List<String> getHostTemplateNames() {\n         return Optional.ofNullable(cmTemplate.getHostTemplates())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MTE2MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527681160", "bodyText": "instead of comment could you use variable and methods name reflecting the same?", "author": "lacikaaa", "createdAt": "2020-11-20T13:12:10Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n+        // The only attributes required at the moment relate to the YARN NodeManager.\n+        // This functionality can be moved to an interface / separated if additional components\n+        // need this functionality.\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n+        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n+            for (ServiceComponent sc : entry.getValue()) {\n+                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n+                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n+                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n+                    break;\n+                }\n+            }\n+        }\n+        // We have the hostGroups without GATEWAY components with YARN NodeManagers", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNjYyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r528116628", "bodyText": "Think this is very specific to CB code style? I think comments in the code can be quite helpful.", "author": "sidseth", "createdAt": "2020-11-21T07:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY3MDc5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r528670797", "bodyText": "comments tends to be outdated, misleading. Usually indicates the code is not \"clean\", doesn't speak for itself which could be improved by refactoring, like breaking into methods with good names, etc\nWe generally avoid them as much as possible and leave comments where it's really necessary.", "author": "lacikaaa", "createdAt": "2020-11-23T12:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MTE2MA=="}], "type": "inlineReview", "revised_code": {"commit": "6d8eff0171e7193f8244a88e2f45736ffa202b62", "chunk": "diff --git a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\nindex 5c278e8372..ff09df14b2 100644\n--- a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n+++ b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n\n@@ -313,50 +313,45 @@ public class CmTemplateProcessor implements BlueprintTextProcessor {\n \n     @Override\n     public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n-        // The only attributes required at the moment relate to the YARN NodeManager.\n-        // This functionality can be moved to an interface / separated if additional components\n-        // need this functionality.\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n-        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n-            for (ServiceComponent sc : entry.getValue()) {\n-                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n-                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n-                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n-                    break;\n-                }\n-            }\n-        }\n-        // We have the hostGroups without GATEWAY components with YARN NodeManagers\n-        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n-                .stream().collect(\n-                        toMap(\n-                                Entry::getKey,\n-                                e -> e.getValue().stream()\n-                                .map(ServiceComponent::getComponent)\n-                                .collect(Collectors.toUnmodifiableSet())\n-                ));\n-        // Re-using the current LoadBasedAutoScaling recommendation along with the above YARN filter.\n+        Map<String, Set<String>> componentsByHostGroup = collectComponentsByHostGroup();\n+\n+        // Re-using the current LoadBasedAutoScaling recommendation to determine hostGroups which can\n+        // be autoscaled and marked as YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n         Set<String> computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\n                 true, componentsByHostGroup);\n \n         Map<String, Map<String, ServiceAttributes>> result = new HashMap<>();\n \n         for (String hg : componentsByHostGroup.keySet()) {\n-            Map<String, ServiceAttributes> m;\n-            if (computeHostGroups.contains(hg)) {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE)));\n-            } else {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER)));\n-            }\n-            result.put(hg, m);\n+            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n+                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n+\n+            result.put(hg, Collections.singletonMap(YarnRoles.YARN,\n+                    new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n+                            Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType))));\n         }\n         LOGGER.debug(\"ServiceAttributes: {}\", result);\n         return result;\n     }\n \n+    private Map<String, Set<String>> collectComponentsByHostGroup() {\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n+                .filter(e -> isYarnNodemanager(e.getValue()))\n+                .collect(toMap(Entry::getKey, Entry::getValue));\n+        return hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n+                .stream().collect(toMap(e -> e.getKey(), e -> collectComponents(e.getValue())));\n+    }\n+\n+    private boolean isYarnNodemanager(Set<ServiceComponent> serviceComponents) {\n+        return serviceComponents.stream().anyMatch(sc -> YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n+            && YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n+    }\n+\n+    private Set<String> collectComponents(Set<ServiceComponent> serviceComponentSet) {\n+        return serviceComponentSet.stream().map(ServiceComponent::getComponent).collect(Collectors.toUnmodifiableSet());\n+    }\n+\n     @Override\n     public List<String> getHostTemplateNames() {\n         return Optional.ofNullable(cmTemplate.getHostTemplates())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MjIwMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527682203", "bodyText": "this comment also seems unnecessary or I'm missing something", "author": "lacikaaa", "createdAt": "2020-11-20T13:14:23Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n+        // The only attributes required at the moment relate to the YARN NodeManager.\n+        // This functionality can be moved to an interface / separated if additional components\n+        // need this functionality.\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n+        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n+            for (ServiceComponent sc : entry.getValue()) {\n+                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n+                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n+                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n+                    break;\n+                }\n+            }\n+        }\n+        // We have the hostGroups without GATEWAY components with YARN NodeManagers\n+        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n+                .stream().collect(\n+                        toMap(\n+                                Entry::getKey,\n+                                e -> e.getValue().stream()\n+                                .map(ServiceComponent::getComponent)\n+                                .collect(Collectors.toUnmodifiableSet())\n+                ));\n+        // Re-using the current LoadBasedAutoScaling recommendation along with the above YARN filter.", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NTk4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r535865982", "bodyText": "Goign to modify this comment a bit. It is relevant in the sense that determining a node as 'compute' means that it can be AutoScaled, and so it is important to re-use the autoscale recommendation logic.", "author": "sidseth", "createdAt": "2020-12-04T06:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MjIwMw=="}], "type": "inlineReview", "revised_code": {"commit": "6d8eff0171e7193f8244a88e2f45736ffa202b62", "chunk": "diff --git a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\nindex 5c278e8372..ff09df14b2 100644\n--- a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n+++ b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n\n@@ -313,50 +313,45 @@ public class CmTemplateProcessor implements BlueprintTextProcessor {\n \n     @Override\n     public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n-        // The only attributes required at the moment relate to the YARN NodeManager.\n-        // This functionality can be moved to an interface / separated if additional components\n-        // need this functionality.\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n-        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n-            for (ServiceComponent sc : entry.getValue()) {\n-                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n-                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n-                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n-                    break;\n-                }\n-            }\n-        }\n-        // We have the hostGroups without GATEWAY components with YARN NodeManagers\n-        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n-                .stream().collect(\n-                        toMap(\n-                                Entry::getKey,\n-                                e -> e.getValue().stream()\n-                                .map(ServiceComponent::getComponent)\n-                                .collect(Collectors.toUnmodifiableSet())\n-                ));\n-        // Re-using the current LoadBasedAutoScaling recommendation along with the above YARN filter.\n+        Map<String, Set<String>> componentsByHostGroup = collectComponentsByHostGroup();\n+\n+        // Re-using the current LoadBasedAutoScaling recommendation to determine hostGroups which can\n+        // be autoscaled and marked as YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n         Set<String> computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\n                 true, componentsByHostGroup);\n \n         Map<String, Map<String, ServiceAttributes>> result = new HashMap<>();\n \n         for (String hg : componentsByHostGroup.keySet()) {\n-            Map<String, ServiceAttributes> m;\n-            if (computeHostGroups.contains(hg)) {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE)));\n-            } else {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER)));\n-            }\n-            result.put(hg, m);\n+            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n+                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n+\n+            result.put(hg, Collections.singletonMap(YarnRoles.YARN,\n+                    new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n+                            Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType))));\n         }\n         LOGGER.debug(\"ServiceAttributes: {}\", result);\n         return result;\n     }\n \n+    private Map<String, Set<String>> collectComponentsByHostGroup() {\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n+                .filter(e -> isYarnNodemanager(e.getValue()))\n+                .collect(toMap(Entry::getKey, Entry::getValue));\n+        return hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n+                .stream().collect(toMap(e -> e.getKey(), e -> collectComponents(e.getValue())));\n+    }\n+\n+    private boolean isYarnNodemanager(Set<ServiceComponent> serviceComponents) {\n+        return serviceComponents.stream().anyMatch(sc -> YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n+            && YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n+    }\n+\n+    private Set<String> collectComponents(Set<ServiceComponent> serviceComponentSet) {\n+        return serviceComponentSet.stream().map(ServiceComponent::getComponent).collect(Collectors.toUnmodifiableSet());\n+    }\n+\n     @Override\n     public List<String> getHostTemplateNames() {\n         return Optional.ofNullable(cmTemplate.getHostTemplates())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4NzA5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527687091", "bodyText": "for (String hg : componentsByHostGroup.keySet()) {\n            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n            Map<String, ServiceAttributes> m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n                    Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType)));\n            result.put(hg, m);\n        }\n\nseems a bit readable this way and could be moved to a separate method also", "author": "lacikaaa", "createdAt": "2020-11-20T13:23:37Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n+        // The only attributes required at the moment relate to the YARN NodeManager.\n+        // This functionality can be moved to an interface / separated if additional components\n+        // need this functionality.\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n+        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n+            for (ServiceComponent sc : entry.getValue()) {\n+                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n+                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n+                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n+                    break;\n+                }\n+            }\n+        }\n+        // We have the hostGroups without GATEWAY components with YARN NodeManagers\n+        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n+                .stream().collect(\n+                        toMap(\n+                                Entry::getKey,\n+                                e -> e.getValue().stream()\n+                                .map(ServiceComponent::getComponent)\n+                                .collect(Collectors.toUnmodifiableSet())\n+                ));\n+        // Re-using the current LoadBasedAutoScaling recommendation along with the above YARN filter.\n+        Set<String> computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\n+                true, componentsByHostGroup);\n+\n+        Map<String, Map<String, ServiceAttributes>> result = new HashMap<>();\n+\n+        for (String hg : componentsByHostGroup.keySet()) {\n+            Map<String, ServiceAttributes> m;\n+            if (computeHostGroups.contains(hg)) {\n+                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n+                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE)));\n+            } else {\n+                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n+                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER)));\n+            }\n+            result.put(hg, m);\n+        }\n+        LOGGER.debug(\"ServiceAttributes: {}\", result);", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4NzgyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527687823", "bodyText": "Also m is not a good variable name, please rename it to something more helpful", "author": "lacikaaa", "createdAt": "2020-11-20T13:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4NzA5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6d8eff0171e7193f8244a88e2f45736ffa202b62", "chunk": "diff --git a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\nindex 5c278e8372..ff09df14b2 100644\n--- a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n+++ b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n\n@@ -313,50 +313,45 @@ public class CmTemplateProcessor implements BlueprintTextProcessor {\n \n     @Override\n     public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n-        // The only attributes required at the moment relate to the YARN NodeManager.\n-        // This functionality can be moved to an interface / separated if additional components\n-        // need this functionality.\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n-        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n-            for (ServiceComponent sc : entry.getValue()) {\n-                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n-                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n-                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n-                    break;\n-                }\n-            }\n-        }\n-        // We have the hostGroups without GATEWAY components with YARN NodeManagers\n-        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n-                .stream().collect(\n-                        toMap(\n-                                Entry::getKey,\n-                                e -> e.getValue().stream()\n-                                .map(ServiceComponent::getComponent)\n-                                .collect(Collectors.toUnmodifiableSet())\n-                ));\n-        // Re-using the current LoadBasedAutoScaling recommendation along with the above YARN filter.\n+        Map<String, Set<String>> componentsByHostGroup = collectComponentsByHostGroup();\n+\n+        // Re-using the current LoadBasedAutoScaling recommendation to determine hostGroups which can\n+        // be autoscaled and marked as YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n         Set<String> computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\n                 true, componentsByHostGroup);\n \n         Map<String, Map<String, ServiceAttributes>> result = new HashMap<>();\n \n         for (String hg : componentsByHostGroup.keySet()) {\n-            Map<String, ServiceAttributes> m;\n-            if (computeHostGroups.contains(hg)) {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE)));\n-            } else {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER)));\n-            }\n-            result.put(hg, m);\n+            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n+                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n+\n+            result.put(hg, Collections.singletonMap(YarnRoles.YARN,\n+                    new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n+                            Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType))));\n         }\n         LOGGER.debug(\"ServiceAttributes: {}\", result);\n         return result;\n     }\n \n+    private Map<String, Set<String>> collectComponentsByHostGroup() {\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n+                .filter(e -> isYarnNodemanager(e.getValue()))\n+                .collect(toMap(Entry::getKey, Entry::getValue));\n+        return hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n+                .stream().collect(toMap(e -> e.getKey(), e -> collectComponents(e.getValue())));\n+    }\n+\n+    private boolean isYarnNodemanager(Set<ServiceComponent> serviceComponents) {\n+        return serviceComponents.stream().anyMatch(sc -> YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n+            && YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n+    }\n+\n+    private Set<String> collectComponents(Set<ServiceComponent> serviceComponentSet) {\n+        return serviceComponentSet.stream().map(ServiceComponent::getComponent).collect(Collectors.toUnmodifiableSet());\n+    }\n+\n     @Override\n     public List<String> getHostTemplateNames() {\n         return Optional.ofNullable(cmTemplate.getHostTemplates())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY5MTAyNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527691025", "bodyText": "I ended up with this, but the method and variable names should be changed with more meaningful one I think. This is just an example:\n\t@Override\n    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n        Map<String, Set<String>> componentsByHostGroup = collectComponentsByHostrgoup();\n        Set<String> computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\n                true, componentsByHostGroup);\n        Map<String, Map<String, ServiceAttributes>> result = createServiceAttributeMap(componentsByHostGroup, computeHostGroups);\n        LOGGER.debug(\"ServiceAttributes: {}\", result);\n        return result;\n    }\n\n    private Map<String, Map<String, ServiceAttributes>> createServiceAttributeMap(Map<String, Set<String>> componentsByHostGroup, Set<String> computeHostGroups) {\n        Map<String, Map<String, ServiceAttributes>> result = new HashMap<>();\n        for (String hg : componentsByHostGroup.keySet()) {\n            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n            Map<String, ServiceAttributes> m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n                    Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType)));\n            result.put(hg, m);\n        }\n        return result;\n    }\n\n    private Map<String, Set<String>> collectComponentsByHostrgoup() {\n        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n                .filter(this::isYarnNodemanager)\n                .collect(toMap(Entry::getKey, Entry::getValue));\n        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n                .stream().collect(toMap(Entry::getKey, this::collectComponents));\n        return componentsByHostGroup;\n    }\n\n    private Set<String> collectComponents(Entry<String, Set<ServiceComponent>> e) {\n        return e.getValue().stream()\n                .map(ServiceComponent::getComponent)\n                .collect(Collectors.toUnmodifiableSet());\n    }\n\n    private boolean isYarnNodemanager(Entry<String, Set<ServiceComponent>> entry) {\n        return entry.getValue().stream().anyMatch(sc -> YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n                && YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n    }", "author": "lacikaaa", "createdAt": "2020-11-20T13:30:12Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2ODI1Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r535868256", "bodyText": "Thanks for the suggestions. Have broken up the method a bit, and made some other changes.", "author": "sidseth", "createdAt": "2020-12-04T06:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY5MTAyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "6d8eff0171e7193f8244a88e2f45736ffa202b62", "chunk": "diff --git a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\nindex 5c278e8372..ff09df14b2 100644\n--- a/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n+++ b/template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java\n\n@@ -313,50 +313,45 @@ public class CmTemplateProcessor implements BlueprintTextProcessor {\n \n     @Override\n     public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n-        // The only attributes required at the moment relate to the YARN NodeManager.\n-        // This functionality can be moved to an interface / separated if additional components\n-        // need this functionality.\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n-        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n-        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n-            for (ServiceComponent sc : entry.getValue()) {\n-                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n-                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n-                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n-                    break;\n-                }\n-            }\n-        }\n-        // We have the hostGroups without GATEWAY components with YARN NodeManagers\n-        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n-                .stream().collect(\n-                        toMap(\n-                                Entry::getKey,\n-                                e -> e.getValue().stream()\n-                                .map(ServiceComponent::getComponent)\n-                                .collect(Collectors.toUnmodifiableSet())\n-                ));\n-        // Re-using the current LoadBasedAutoScaling recommendation along with the above YARN filter.\n+        Map<String, Set<String>> componentsByHostGroup = collectComponentsByHostGroup();\n+\n+        // Re-using the current LoadBasedAutoScaling recommendation to determine hostGroups which can\n+        // be autoscaled and marked as YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n         Set<String> computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\n                 true, componentsByHostGroup);\n \n         Map<String, Map<String, ServiceAttributes>> result = new HashMap<>();\n \n         for (String hg : componentsByHostGroup.keySet()) {\n-            Map<String, ServiceAttributes> m;\n-            if (computeHostGroups.contains(hg)) {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE)));\n-            } else {\n-                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n-                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER)));\n-            }\n-            result.put(hg, m);\n+            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n+                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n+\n+            result.put(hg, Collections.singletonMap(YarnRoles.YARN,\n+                    new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n+                            Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType))));\n         }\n         LOGGER.debug(\"ServiceAttributes: {}\", result);\n         return result;\n     }\n \n+    private Map<String, Set<String>> collectComponentsByHostGroup() {\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n+                .filter(e -> isYarnNodemanager(e.getValue()))\n+                .collect(toMap(Entry::getKey, Entry::getValue));\n+        return hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n+                .stream().collect(toMap(e -> e.getKey(), e -> collectComponents(e.getValue())));\n+    }\n+\n+    private boolean isYarnNodemanager(Set<ServiceComponent> serviceComponents) {\n+        return serviceComponents.stream().anyMatch(sc -> YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n+            && YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n+    }\n+\n+    private Set<String> collectComponents(Set<ServiceComponent> serviceComponentSet) {\n+        return serviceComponentSet.stream().map(ServiceComponent::getComponent).collect(Collectors.toUnmodifiableSet());\n+    }\n+\n     @Override\n     public List<String> getHostTemplateNames() {\n         return Optional.ofNullable(cmTemplate.getHostTemplates())\n"}}, {"oid": "6d8eff0171e7193f8244a88e2f45736ffa202b62", "url": "https://github.com/hortonworks/cloudbreak/commit/6d8eff0171e7193f8244a88e2f45736ffa202b62", "message": "CB-8147. Make node specific metadata (hostGroup, YARN NM attributes)\navailable on cluster nodes.\n\n- New metadata file created under /opt/metadata/node.json on cluster\nnodes, which contains the hostGroup name, and service specific\nattributes.\n- The service specific attributes introduced in this PR are for YARN,\nand specify whether a node is a compute or worker based on the services\nrunning on the node (instead of relying on the hostGroup name).", "committedDate": "2020-12-04T06:56:44Z", "type": "forcePushed"}, {"oid": "b892b6d11bce5c14d61158af64d45257dabbc7a9", "url": "https://github.com/hortonworks/cloudbreak/commit/b892b6d11bce5c14d61158af64d45257dabbc7a9", "message": "CB-8147. Make node specific metadata (hostGroup, YARN NM attributes)\navailable on cluster nodes.\n\n- New metadata file created under /opt/metadata/node.json on cluster\nnodes, which contains the hostGroup name, and service specific\nattributes.\n- The service specific attributes introduced in this PR are for YARN,\nand specify whether a node is a compute or worker based on the services\nrunning on the node (instead of relying on the hostGroup name).", "committedDate": "2020-12-05T04:39:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1ODI0NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r540358245", "bodyText": "I think this should be moved to a separate class together with getAttributesForHostGroup.\nAnd this method should return with a map, like:\nMap.of(\"hostattrs\", new SaltPillarProperties(\"/nodes/hostattrs.sls\", singletonMap(\"hostattrs\", attributes)))\nAnd in line 303 you would need only:\nservicePillar.putAll(createHostAttributes(..));\nI know there is a lot of code here (even written by me) where we add stuff to this map by passing it around but honestly it's not the best solution.\nMoving this method out would make @VisibleForTesting unnecessary which is already a sign that it should be in a separate class.", "author": "lacikaaa", "createdAt": "2020-12-10T17:28:01Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/bootstrap/service/host/ClusterHostServiceRunner.java", "diffHunk": "@@ -323,6 +331,26 @@ private SaltConfig createSaltConfig(Stack stack, Cluster cluster, GatewayConfig\n         return new SaltConfig(servicePillar, grainPropertiesService.createGrainProperties(gatewayConfigs, cluster, nodes));\n     }\n \n+    @VisibleForTesting\n+    void addHostAttributes(Stack stack, Map<String, SaltPillarProperties> servicePillar, Set<Node> nodes) {", "originalCommit": "b892b6d11bce5c14d61158af64d45257dabbc7a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NDEyNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r540574126", "bodyText": "Moving this into a HostAttributeDecorator, and having that set the PillarProperties instead of returning a map.\nI'm going to ask you to make changes to return a map if you feel strongly about that / other code style changes. Given I don't write a lot of CB patches - was avoiding any kind of re-structuring and following existing patterns as much as possible.", "author": "sidseth", "createdAt": "2020-12-10T23:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1ODI0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "ec73d2cb416eb99a8d763667d69b0300b4b0619b", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/core/bootstrap/service/host/ClusterHostServiceRunner.java b/core/src/main/java/com/sequenceiq/cloudbreak/core/bootstrap/service/host/ClusterHostServiceRunner.java\nindex 41edb34a6f..18fdf37e6c 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/core/bootstrap/service/host/ClusterHostServiceRunner.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/core/bootstrap/service/host/ClusterHostServiceRunner.java\n\n@@ -331,26 +328,6 @@ public class ClusterHostServiceRunner {\n         return new SaltConfig(servicePillar, grainPropertiesService.createGrainProperties(gatewayConfigs, cluster, nodes));\n     }\n \n-    @VisibleForTesting\n-    void addHostAttributes(Stack stack, Map<String, SaltPillarProperties> servicePillar, Set<Node> nodes) {\n-        BlueprintTextProcessor blueprintTextProcessor = cmTemplateProcessorFactory.get(stack.getCluster().getBlueprint().getBlueprintText());\n-        Map<String, Map<String, ServiceAttributes>> serviceAttributes = blueprintTextProcessor.getHostGroupBasedServiceAttributes();\n-\n-        Map<String, Map<String, Object>> attributes = new HashMap<>();\n-        for (Node node : nodes) {\n-            Map<String, Map<String, String>> hgAttributes = getAttributesForHostGroup(node.getHostGroup(), serviceAttributes);\n-            Map<String, Object> hostAttributes = new HashMap<>();\n-\n-            hostAttributes.put(\"attributes\", hgAttributes);\n-\n-            if (node.getHostGroup() != null) {\n-                hostAttributes.put(\"hostGroup\", node.getHostGroup());\n-            }\n-            attributes.put(node.getHostname(), hostAttributes);\n-        }\n-        servicePillar.put(\"hostattrs\", new SaltPillarProperties(\"/nodes/hostattrs.sls\", singletonMap(\"hostattrs\", attributes)));\n-    }\n-\n     private void addKerberosConfig(Map<String, SaltPillarProperties> servicePillar, KerberosConfig kerberosConfig) throws IOException {\n         if (isKerberosNeeded(kerberosConfig)) {\n             Map<String, String> kerberosPillarConf = new HashMap<>();\n"}}, {"oid": "ec73d2cb416eb99a8d763667d69b0300b4b0619b", "url": "https://github.com/hortonworks/cloudbreak/commit/ec73d2cb416eb99a8d763667d69b0300b4b0619b", "message": "CB-8147. Make node specific metadata (hostGroup, YARN NM attributes)\navailable on cluster nodes.\n\n- New metadata file created under /opt/metadata/node.json on cluster\nnodes, which contains the hostGroup name, and service specific\nattributes.\n- The service specific attributes introduced in this PR are for YARN,\nand specify whether a node is a compute or worker based on the services\nrunning on the node (instead of relying on the hostGroup name).", "committedDate": "2020-12-10T23:45:38Z", "type": "forcePushed"}, {"oid": "e015b220c1541d5b8658a647f383c8956b4977e3", "url": "https://github.com/hortonworks/cloudbreak/commit/e015b220c1541d5b8658a647f383c8956b4977e3", "message": "CB-8147. Make node specific metadata (hostGroup, YARN NM attributes)\navailable on cluster nodes.\n\n- New metadata file created under /opt/metadata/node.json on cluster\nnodes, which contains the hostGroup name, and service specific\nattributes.\n- The service specific attributes introduced in this PR are for YARN,\nand specify whether a node is a compute or worker based on the services\nrunning on the node (instead of relying on the hostGroup name).", "committedDate": "2020-12-11T08:24:34Z", "type": "commit"}, {"oid": "e015b220c1541d5b8658a647f383c8956b4977e3", "url": "https://github.com/hortonworks/cloudbreak/commit/e015b220c1541d5b8658a647f383c8956b4977e3", "message": "CB-8147. Make node specific metadata (hostGroup, YARN NM attributes)\navailable on cluster nodes.\n\n- New metadata file created under /opt/metadata/node.json on cluster\nnodes, which contains the hostGroup name, and service specific\nattributes.\n- The service specific attributes introduced in this PR are for YARN,\nand specify whether a node is a compute or worker based on the services\nrunning on the node (instead of relying on the hostGroup name).", "committedDate": "2020-12-11T08:24:34Z", "type": "forcePushed"}]}