{"pr_number": 9010, "pr_title": "CDPCP-2990. User sync uses bulk UMS api ", "pr_createdAt": "2020-09-14T20:44:42Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9010", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MzgzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488273837", "bodyText": "This doc string isn't correct.", "author": "aarman-cloudera", "createdAt": "2020-09-14T22:37:38Z", "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/GrpcUmsClient.java", "diffHunk": "@@ -779,6 +781,24 @@ public GetEventGenerationIdsResponse getEventGenerationIds(String actorCrn, Stri\n         }\n     }\n \n+    /**\n+     * Retrieves user sync state model from UMS.\n+     *\n+     * @param accountId        the account Id\n+     * @param requestId        an optional request Id\n+     * @param rightsChecksList list of mapping from resources to lists of rights to check. Lists are used to\n+     *                         preserve order.\n+     * @return the user associated with this user CRN", "originalCommit": "2099a2d2e3fd0f709bc491ac167110d297567c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4Nzg2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488787861", "bodyText": "fixed", "author": "handavid", "createdAt": "2020-09-15T16:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MzgzNw=="}], "type": "inlineReview", "revised_code": {"commit": "73d6dc30ed172b314b02349317c6ab811980703c", "chunk": "diff --git a/auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/GrpcUmsClient.java b/auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/GrpcUmsClient.java\nindex 26a6cdc2b3..1886800856 100644\n--- a/auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/GrpcUmsClient.java\n+++ b/auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/GrpcUmsClient.java\n\n@@ -786,16 +785,17 @@ public class GrpcUmsClient {\n      *\n      * @param accountId        the account Id\n      * @param requestId        an optional request Id\n-     * @param rightsChecksList list of mapping from resources to lists of rights to check. Lists are used to\n-     *                         preserve order.\n-     * @return the user associated with this user CRN\n+     * @param rightsChecks     list of rights checks for resources. a List is used to preserve order.\n+     * @return the user sync state for this account and rights checks\n      */\n     public GetUserSyncStateModelResponse getUserSyncStateModel(\n-            String actorCrn, String accountId, List<Pair<String, List<String>>> rightsChecksList, Optional<String> requestId) {\n+            String actorCrn, String accountId,\n+            List<UserManagementProto.RightsCheck> rightsChecks, Optional<String> requestId) {\n         try (ManagedChannelWrapper channelWrapper = makeWrapper()) {\n             UmsClient client = makeClient(channelWrapper.getChannel(), actorCrn);\n             LOGGER.debug(\"Retrieving user sync state model for account {} using request ID {}\", accountId, requestId);\n-            return client.getUserSyncStateModel(requestId.orElse(UUID.randomUUID().toString()), accountId, rightsChecksList);\n+\n+            return client.getUserSyncStateModel(requestId.orElse(UUID.randomUUID().toString()), accountId, rightsChecks);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3NDUyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488274522", "bodyText": "List<Pair<String, List<String>>> is a bit hard to read, maybe turn this into\nList<RightsCheck> (adding a new RightsCheck class)?", "author": "aarman-cloudera", "createdAt": "2020-09-14T22:38:32Z", "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/UmsClient.java", "diffHunk": "@@ -783,4 +787,29 @@ public String getIdentityProviderMetadataXml(String requestId, String accountId)\n         }\n         return assignee.build();\n     }\n+\n+    /**\n+     * Retrieves user sync state model from the UMS.\n+     *\n+     * @param requestId          the request ID for the request\n+     * @param accountId          the account ID\n+     * @param rightsChecksList   list of mapping from resources to lists of rights to check. Lists are used to\n+     *                           preserve order.\n+     * @return the user sync state model\n+     */\n+    public GetUserSyncStateModelResponse getUserSyncStateModel(\n+            String requestId, String accountId, List<Pair<String, List<String>>> rightsChecksList) {", "originalCommit": "2099a2d2e3fd0f709bc491ac167110d297567c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgwNTIzNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488805236", "bodyText": "We already have some UserManagementProto classes in the GrpcUmsClient. I'll just expose the RightsCheck class all the way out.", "author": "handavid", "createdAt": "2020-09-15T16:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3NDUyMg=="}], "type": "inlineReview", "revised_code": {"commit": "73d6dc30ed172b314b02349317c6ab811980703c", "chunk": "diff --git a/auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/UmsClient.java b/auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/UmsClient.java\nindex 1590d0e5de..9dc27f2639 100644\n--- a/auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/UmsClient.java\n+++ b/auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/UmsClient.java\n\n@@ -793,19 +791,11 @@ public class UmsClient {\n      *\n      * @param requestId          the request ID for the request\n      * @param accountId          the account ID\n-     * @param rightsChecksList   list of mapping from resources to lists of rights to check. Lists are used to\n-     *                           preserve order.\n+     * @param rightsChecks       list of rights checks for resources. A List is used to preserve order.\n      * @return the user sync state model\n      */\n     public GetUserSyncStateModelResponse getUserSyncStateModel(\n-            String requestId, String accountId, List<Pair<String, List<String>>> rightsChecksList) {\n-        List<RightsCheck> rightsChecks = rightsChecksList.stream()\n-                .map(pair ->\n-                    RightsCheck.newBuilder()\n-                            .setResourceCrn(pair.getKey())\n-                            .addAllRight(pair.getValue())\n-                            .build())\n-                .collect(Collectors.toList());\n+            String requestId, String accountId, List<RightsCheck> rightsChecks) {\n         GetUserSyncStateModelRequest request = GetUserSyncStateModelRequest.newBuilder()\n                 .setAccountId(accountId)\n                 .addAllRightsCheck(rightsChecks)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3NjE2Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488276163", "bodyText": "nit: Any reason getUmsUsersStateMapBulk and getUmsUsersStateMap needs to\nreturn a Builder instead of the built UmsUserState?", "author": "aarman-cloudera", "createdAt": "2020-09-14T22:40:37Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -54,92 +77,232 @@\n     @Inject\n     private UmsRightProvider umsRightProvider;\n \n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(String accountId, String actorCrn, Set<String> environmentCrns,\n-        Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n         try {\n             LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n \n-            Map<String, UmsUsersState> envUsersStateMap = new HashMap<>();\n-\n             boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n \n-            List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-\n-            List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-            Map<String, FmsGroup> crnToFmsGroup = grpcUmsClient.listGroups(actorCrn, accountId, List.of(), requestIdOptional).stream()\n-                    .collect(Collectors.toMap(Group::getCrn, this::umsGroupToGroup));\n-\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags = grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional)\n-                    .stream()\n-                    .collect(Collectors.toMap(wag -> wag, wag -> nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-            environmentCrns.forEach(environmentCrn -> {\n-                UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                        .setWorkloadAdministrationGroups(wags.values());\n-\n-                UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-                Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-\n-                crnToFmsGroup.values().forEach(usersStateBuilder::addGroup);\n-\n-                // Only add workload admin groups that belong to this environment.\n-                // At the same time, build a set of workload admin groups that are\n-                // associated with other environments so we can filter these out in\n-                // the per-user group listing in handleUser.\n-                wags.entrySet().forEach(wagEntry -> {\n-                    WorkloadAdministrationGroup wag = wagEntry.getKey();\n-                    String groupName = wag.getWorkloadAdministrationGroupName();\n-                    if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                        usersStateBuilder.addGroup(wagEntry.getValue());\n-                    } else {\n-                        Crn resourceCrn = getCrn(wag);\n-                        if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                                && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                            wagNamesForOtherEnvironments.add(groupName);\n-                        }\n-                    }\n-                });\n+            Map<String, UmsUsersState.Builder> envUsersStateMap;", "originalCommit": "2099a2d2e3fd0f709bc491ac167110d297567c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4ODE3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488788177", "bodyText": "nope. fixed", "author": "handavid", "createdAt": "2020-09-15T16:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3NjE2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "73d6dc30ed172b314b02349317c6ab811980703c", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java\nindex 086a210135..1f8e097001 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java\n\n@@ -88,7 +88,7 @@ public class UmsUsersStateProvider {\n \n             boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n \n-            Map<String, UmsUsersState.Builder> envUsersStateMap;\n+            Map<String, UmsUsersState> envUsersStateMap;\n             if (fullSync && entitlementService.umsUserSyncModelGenerationEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n                 envUsersStateMap = getUmsUsersStateMapBulk(accountId, environmentCrns, requestIdOptional);\n             } else {\n"}}, {"oid": "73d6dc30ed172b314b02349317c6ab811980703c", "url": "https://github.com/hortonworks/cloudbreak/commit/73d6dc30ed172b314b02349317c6ab811980703c", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests", "committedDate": "2020-09-17T22:24:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzMDM2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490930361", "bodyText": "please remove static", "author": "lacikaaa", "createdAt": "2020-09-18T12:57:29Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentAccessChecker.java", "diffHunk": "@@ -74,4 +67,18 @@ public EnvironmentAccessRights hasAccess(String memberCrn, Optional<String> requ\n \n         }\n     }\n+\n+    @VisibleForTesting\n+    static List<RightCheck> createRightCheck(UmsRightProvider umsRightProvider, String environmentCrn) {", "originalCommit": "73d6dc30ed172b314b02349317c6ab811980703c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MDc2Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492160763", "bodyText": "refactored into separate class", "author": "handavid", "createdAt": "2020-09-21T15:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzMDM2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentAccessChecker.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/EnvironmentAccessChecker.java\nsimilarity index 70%\nrename from freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentAccessChecker.java\nrename to freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/EnvironmentAccessChecker.java\nindex aa137feddd..61af63d6d3 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentAccessChecker.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/EnvironmentAccessChecker.java\n\n@@ -67,18 +67,4 @@ public class EnvironmentAccessChecker {\n \n         }\n     }\n-\n-    @VisibleForTesting\n-    static List<RightCheck> createRightCheck(UmsRightProvider umsRightProvider, String environmentCrn) {\n-        String accountId = Crn.safeFromString(environmentCrn).getAccountId();\n-\n-        return List.of(\n-                RightCheck.newBuilder()\n-                        .setRight(umsRightProvider.getRight(AuthorizationResourceAction.ACCESS_ENVIRONMENT, INTERNAL_ACTOR_CRN, accountId))\n-                        .setResource(environmentCrn)\n-                        .build(),\n-                RightCheck.newBuilder()\n-                        .setRight(umsRightProvider.getRight(AuthorizationResourceAction.ADMIN_FREEIPA, INTERNAL_ACTOR_CRN, accountId))\n-                        .build());\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzNjAyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490936028", "bodyText": "please refactor this class:\n\ninstead of static use @Component annotation and @Inject where you use it\nslice into 3 separate class for: FmsUser, FmsGroup and WorkloadCredential so each would have it's own responsibility", "author": "lacikaaa", "createdAt": "2020-09-18T13:07:12Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/Conversions.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.model;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+public class Conversions {", "originalCommit": "73d6dc30ed172b314b02349317c6ab811980703c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MDgzNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492160835", "bodyText": "done", "author": "handavid", "createdAt": "2020-09-21T15:40:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzNjAyOA=="}], "type": "inlineReview", "revised_code": {"commit": "c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/Conversions.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/Conversions.java\ndeleted file mode 100644\nindex f3e7e327d4..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/Conversions.java\n+++ /dev/null\n\n@@ -1,85 +0,0 @@\n-package com.sequenceiq.freeipa.service.freeipa.user.model;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Strings;\n-\n-import java.time.Instant;\n-import java.util.Optional;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-\n-public class Conversions {\n-\n-    @VisibleForTesting\n-    static final String NONE_STRING = \"None\";\n-\n-    private Conversions() {\n-    }\n-\n-    public static FmsUser toFmsUser(UserManagementProto.User umsUser) {\n-        return createFmsUser(umsUser.getWorkloadUsername(),\n-                umsUser.getFirstName(),\n-                umsUser.getLastName());\n-    }\n-\n-    public static FmsUser toFmsUser(UserManagementProto.MachineUser umsMachineUser) {\n-        // Machine users don't have a first and last name.\n-        // Store the machine user name and id instead.\n-        return createFmsUser(umsMachineUser.getWorkloadUsername(),\n-                umsMachineUser.getMachineUserName(),\n-                umsMachineUser.getMachineUserId());\n-    }\n-\n-    public static FmsUser toFmsUser(\n-            UserManagementProto.UserSyncActorDetails actorDetails) {\n-        return createFmsUser(actorDetails.getWorkloadUsername(),\n-                actorDetails.getFirstName(),\n-                actorDetails.getLastName());\n-    }\n-\n-    private static FmsUser createFmsUser(String workloadUsername, String firstName, String lastName) {\n-        checkArgument(!Strings.isNullOrEmpty(workloadUsername));\n-        FmsUser fmsUser = new FmsUser();\n-        fmsUser.withName(workloadUsername);\n-        fmsUser.withFirstName(orDefault(firstName, NONE_STRING));\n-        fmsUser.withLastName(orDefault(lastName, NONE_STRING));\n-        return fmsUser;\n-    }\n-\n-    public static FmsGroup umsGroupToGroup(UserManagementProto.Group umsGroup) {\n-        return nameToGroup(umsGroup.getGroupName());\n-    }\n-\n-    public static FmsGroup nameToGroup(String name) {\n-        checkArgument(!Strings.isNullOrEmpty(name));\n-        FmsGroup fmsGroup = new FmsGroup();\n-        fmsGroup.withName(name);\n-        return fmsGroup;\n-    }\n-\n-    private static String orDefault(String value, String other) {\n-        return (value == null || value.isBlank()) ? other : value;\n-    }\n-\n-    public static WorkloadCredential toWorkloadCredential(\n-            UserManagementProto.ActorWorkloadCredentials actorWorkloadCredentials) {\n-        return new WorkloadCredential(actorWorkloadCredentials.getPasswordHash(),\n-                actorWorkloadCredentials.getKerberosKeysList(),\n-                toOptionalInstant(actorWorkloadCredentials.getPasswordHashExpirationDate()),\n-                actorWorkloadCredentials.getSshPublicKeyList());\n-    }\n-\n-    public static WorkloadCredential toWorkloadCredential(\n-            UserManagementProto.GetActorWorkloadCredentialsResponse actorWorkloadCredentials) {\n-        return new WorkloadCredential(actorWorkloadCredentials.getPasswordHash(),\n-                actorWorkloadCredentials.getKerberosKeysList(),\n-                toOptionalInstant(actorWorkloadCredentials.getPasswordHashExpirationDate()),\n-                actorWorkloadCredentials.getSshPublicKeyList());\n-    }\n-\n-    private static Optional<Instant> toOptionalInstant(long epochMillis) {\n-        return epochMillis == 0 ?\n-                Optional.empty() : Optional.of(Instant.ofEpochMilli(epochMillis));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzNjYwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490936606", "bodyText": "this could be replaced with StringUtils.defaultIfBlank(final T str, final T defaultStr) from apache commons lang3", "author": "lacikaaa", "createdAt": "2020-09-18T13:08:12Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/Conversions.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.model;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+public class Conversions {\n+\n+    @VisibleForTesting\n+    static final String NONE_STRING = \"None\";\n+\n+    private Conversions() {\n+    }\n+\n+    public static FmsUser toFmsUser(UserManagementProto.User umsUser) {\n+        return createFmsUser(umsUser.getWorkloadUsername(),\n+                umsUser.getFirstName(),\n+                umsUser.getLastName());\n+    }\n+\n+    public static FmsUser toFmsUser(UserManagementProto.MachineUser umsMachineUser) {\n+        // Machine users don't have a first and last name.\n+        // Store the machine user name and id instead.\n+        return createFmsUser(umsMachineUser.getWorkloadUsername(),\n+                umsMachineUser.getMachineUserName(),\n+                umsMachineUser.getMachineUserId());\n+    }\n+\n+    public static FmsUser toFmsUser(\n+            UserManagementProto.UserSyncActorDetails actorDetails) {\n+        return createFmsUser(actorDetails.getWorkloadUsername(),\n+                actorDetails.getFirstName(),\n+                actorDetails.getLastName());\n+    }\n+\n+    private static FmsUser createFmsUser(String workloadUsername, String firstName, String lastName) {\n+        checkArgument(!Strings.isNullOrEmpty(workloadUsername));\n+        FmsUser fmsUser = new FmsUser();\n+        fmsUser.withName(workloadUsername);\n+        fmsUser.withFirstName(orDefault(firstName, NONE_STRING));\n+        fmsUser.withLastName(orDefault(lastName, NONE_STRING));\n+        return fmsUser;\n+    }\n+\n+    public static FmsGroup umsGroupToGroup(UserManagementProto.Group umsGroup) {\n+        return nameToGroup(umsGroup.getGroupName());\n+    }\n+\n+    public static FmsGroup nameToGroup(String name) {\n+        checkArgument(!Strings.isNullOrEmpty(name));\n+        FmsGroup fmsGroup = new FmsGroup();\n+        fmsGroup.withName(name);\n+        return fmsGroup;\n+    }\n+\n+    private static String orDefault(String value, String other) {\n+        return (value == null || value.isBlank()) ? other : value;\n+    }", "originalCommit": "73d6dc30ed172b314b02349317c6ab811980703c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1MzY0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r491153641", "bodyText": "done", "author": "handavid", "createdAt": "2020-09-18T19:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzNjYwNg=="}], "type": "inlineReview", "revised_code": {"commit": "c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/Conversions.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/Conversions.java\ndeleted file mode 100644\nindex f3e7e327d4..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/Conversions.java\n+++ /dev/null\n\n@@ -1,85 +0,0 @@\n-package com.sequenceiq.freeipa.service.freeipa.user.model;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Strings;\n-\n-import java.time.Instant;\n-import java.util.Optional;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-\n-public class Conversions {\n-\n-    @VisibleForTesting\n-    static final String NONE_STRING = \"None\";\n-\n-    private Conversions() {\n-    }\n-\n-    public static FmsUser toFmsUser(UserManagementProto.User umsUser) {\n-        return createFmsUser(umsUser.getWorkloadUsername(),\n-                umsUser.getFirstName(),\n-                umsUser.getLastName());\n-    }\n-\n-    public static FmsUser toFmsUser(UserManagementProto.MachineUser umsMachineUser) {\n-        // Machine users don't have a first and last name.\n-        // Store the machine user name and id instead.\n-        return createFmsUser(umsMachineUser.getWorkloadUsername(),\n-                umsMachineUser.getMachineUserName(),\n-                umsMachineUser.getMachineUserId());\n-    }\n-\n-    public static FmsUser toFmsUser(\n-            UserManagementProto.UserSyncActorDetails actorDetails) {\n-        return createFmsUser(actorDetails.getWorkloadUsername(),\n-                actorDetails.getFirstName(),\n-                actorDetails.getLastName());\n-    }\n-\n-    private static FmsUser createFmsUser(String workloadUsername, String firstName, String lastName) {\n-        checkArgument(!Strings.isNullOrEmpty(workloadUsername));\n-        FmsUser fmsUser = new FmsUser();\n-        fmsUser.withName(workloadUsername);\n-        fmsUser.withFirstName(orDefault(firstName, NONE_STRING));\n-        fmsUser.withLastName(orDefault(lastName, NONE_STRING));\n-        return fmsUser;\n-    }\n-\n-    public static FmsGroup umsGroupToGroup(UserManagementProto.Group umsGroup) {\n-        return nameToGroup(umsGroup.getGroupName());\n-    }\n-\n-    public static FmsGroup nameToGroup(String name) {\n-        checkArgument(!Strings.isNullOrEmpty(name));\n-        FmsGroup fmsGroup = new FmsGroup();\n-        fmsGroup.withName(name);\n-        return fmsGroup;\n-    }\n-\n-    private static String orDefault(String value, String other) {\n-        return (value == null || value.isBlank()) ? other : value;\n-    }\n-\n-    public static WorkloadCredential toWorkloadCredential(\n-            UserManagementProto.ActorWorkloadCredentials actorWorkloadCredentials) {\n-        return new WorkloadCredential(actorWorkloadCredentials.getPasswordHash(),\n-                actorWorkloadCredentials.getKerberosKeysList(),\n-                toOptionalInstant(actorWorkloadCredentials.getPasswordHashExpirationDate()),\n-                actorWorkloadCredentials.getSshPublicKeyList());\n-    }\n-\n-    public static WorkloadCredential toWorkloadCredential(\n-            UserManagementProto.GetActorWorkloadCredentialsResponse actorWorkloadCredentials) {\n-        return new WorkloadCredential(actorWorkloadCredentials.getPasswordHash(),\n-                actorWorkloadCredentials.getKerberosKeysList(),\n-                toOptionalInstant(actorWorkloadCredentials.getPasswordHashExpirationDate()),\n-                actorWorkloadCredentials.getSshPublicKeyList());\n-    }\n-\n-    private static Optional<Instant> toOptionalInstant(long epochMillis) {\n-        return epochMillis == 0 ?\n-                Optional.empty() : Optional.of(Instant.ofEpochMilli(epochMillis));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk0MzE4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490943183", "bodyText": "why not stream environmentCrnList and collect the result into a map in the end?", "author": "lacikaaa", "createdAt": "2020-09-18T13:19:10Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -54,92 +77,233 @@\n     @Inject\n     private UmsRightProvider umsRightProvider;\n \n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(String accountId, String actorCrn, Set<String> environmentCrns,\n-        Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n         try {\n             LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n \n-            Map<String, UmsUsersState> envUsersStateMap = new HashMap<>();\n-\n             boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n \n-            List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-\n-            List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-            Map<String, FmsGroup> crnToFmsGroup = grpcUmsClient.listGroups(actorCrn, accountId, List.of(), requestIdOptional).stream()\n-                    .collect(Collectors.toMap(Group::getCrn, this::umsGroupToGroup));\n-\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags = grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional)\n-                    .stream()\n-                    .collect(Collectors.toMap(wag -> wag, wag -> nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-            environmentCrns.forEach(environmentCrn -> {\n-                UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                        .setWorkloadAdministrationGroups(wags.values());\n-\n-                UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-                Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-\n-                crnToFmsGroup.values().forEach(usersStateBuilder::addGroup);\n-\n-                // Only add workload admin groups that belong to this environment.\n-                // At the same time, build a set of workload admin groups that are\n-                // associated with other environments so we can filter these out in\n-                // the per-user group listing in handleUser.\n-                wags.entrySet().forEach(wagEntry -> {\n-                    WorkloadAdministrationGroup wag = wagEntry.getKey();\n-                    String groupName = wag.getWorkloadAdministrationGroupName();\n-                    if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                        usersStateBuilder.addGroup(wagEntry.getValue());\n-                    } else {\n-                        Crn resourceCrn = getCrn(wag);\n-                        if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                                && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                            wagNamesForOtherEnvironments.add(groupName);\n-                        }\n-                    }\n-                });\n+            Map<String, UmsUsersState> envUsersStateMap;\n+            if (fullSync && entitlementService.umsUserSyncModelGenerationEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n+                envUsersStateMap = getUmsUsersStateMapBulk(accountId, environmentCrns, requestIdOptional);\n+            } else {\n+                envUsersStateMap = getUmsUsersStateMap(\n+                        accountId, actorCrn,\n+                        environmentCrns, userCrns, machineUserCrns,\n+                        requestIdOptional, fullSync);\n+            }\n \n-                // Add internal usersync group for each environment\n-                usersStateBuilder.addGroup(nameToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP));\n+            return envUsersStateMap;\n+        } catch (RuntimeException e) {\n+            throw new UmsOperationException(String.format(\"Error during UMS operation: '%s'\", e.getLocalizedMessage()), e);\n+        }\n+    }\n \n-                EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+    @VisibleForTesting\n+    Map<String, UmsUsersState> getUmsUsersStateMapBulk(\n+            String accountId, Collection<String> environmentCrns, Optional<String> requestIdOptional) {\n+\n+        List<String> environmentCrnList = List.copyOf(environmentCrns);\n+        GetUserSyncStateModelResponse userSyncStateModel = grpcUmsClient.getUserSyncStateModel(\n+                INTERNAL_ACTOR_CRN,\n+                accountId,\n+                generateRightsChecksForEnvironments(environmentCrnList),\n+                requestIdOptional);\n+\n+        Map<String, FmsGroup> groups = convertGroupsToFmsGroups(userSyncStateModel.getGroupList());\n+        Map<WorkloadAdministrationGroup, FmsGroup> wags =\n+                convertWagsToFmsGroups(userSyncStateModel.getWorkloadAdministrationGroupList());\n+        List<String> requestedWorkloadUsernames = userSyncStateModel.getActorList().stream()\n+                .map(UserManagementProto.UserSyncActor::getActorDetails)\n+                .map(UserManagementProto.UserSyncActorDetails::getWorkloadUsername)\n+                .collect(Collectors.toList());\n+\n+        Map<String, UmsUsersState> umsUsersStateMap = Maps.newHashMap();\n+        IntStream.range(0, environmentCrnList.size())\n+                .forEach(environmentIndex -> {", "originalCommit": "73d6dc30ed172b314b02349317c6ab811980703c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1MzM3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r491153376", "bodyText": "I need the index in the environmentCrnList to associate the RightsCheckResults to the correct environment. The bulk request includes a list of rights checks so we can potentially obtain the state for multiple environments at once. Using lists reduces the size of the response compared to using a map of environmentcrn to RightsCheckResults for each actor (i.e., omitting 1000s of the same environment crn string)", "author": "handavid", "createdAt": "2020-09-18T19:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk0MzE4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java\ndeleted file mode 100644\nindex 1f8e097001..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java\n+++ /dev/null\n\n@@ -1,409 +0,0 @@\n-package com.sequenceiq.freeipa.service.freeipa.user;\n-\n-import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n-import javax.inject.Inject;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Maps;\n-import com.google.common.collect.Streams;\n-import com.sequenceiq.authorization.resource.AuthorizationResourceAction;\n-import com.sequenceiq.cloudbreak.auth.altus.EntitlementService;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.Conversions;\n-import org.apache.logging.log4j.util.TriConsumer;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Service;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.CloudIdentity;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetUserSyncStateModelResponse;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.Group;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.MachineUser;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.RightsCheck;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.RightsCheckResult;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ServicePrincipalCloudIdentities;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.User;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.WorkloadAdministrationGroup;\n-import com.sequenceiq.authorization.service.UmsRightProvider;\n-import com.sequenceiq.cloudbreak.auth.altus.Crn;\n-import com.sequenceiq.cloudbreak.auth.altus.Crn.ResourceType;\n-import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n-import com.sequenceiq.cloudbreak.auth.altus.exception.UmsOperationException;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.EnvironmentAccessRights;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.UsersState;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.WorkloadCredential;\n-\n-import io.grpc.Status;\n-import io.grpc.StatusRuntimeException;\n-\n-@Service\n-public class UmsUsersStateProvider {\n-    @VisibleForTesting\n-    static final boolean INCLUDE_INTERNAL_MACHINE_USERS = true;\n-\n-    @VisibleForTesting\n-    static final List<String> RIGHTS = ImmutableList.of(\n-            AuthorizationResourceAction.ACCESS_ENVIRONMENT.getRight(),\n-            AuthorizationResourceAction.ADMIN_FREEIPA.getRight());\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(UmsUsersStateProvider.class);\n-\n-    private static final FmsGroup USERSYNC_INTERNAL_GROUP =\n-            Conversions.nameToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP);\n-\n-    @Inject\n-    private GrpcUmsClient grpcUmsClient;\n-\n-    @Inject\n-    private UmsCredentialProvider umsCredentialProvider;\n-\n-    @Inject\n-    private UmsRightProvider umsRightProvider;\n-\n-    @Inject\n-    private EntitlementService entitlementService;\n-\n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n-            String accountId, String actorCrn, Collection<String> environmentCrns,\n-            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n-        try {\n-            LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n-\n-            boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n-\n-            Map<String, UmsUsersState> envUsersStateMap;\n-            if (fullSync && entitlementService.umsUserSyncModelGenerationEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n-                envUsersStateMap = getUmsUsersStateMapBulk(accountId, environmentCrns, requestIdOptional);\n-            } else {\n-                envUsersStateMap = getUmsUsersStateMap(\n-                        accountId, actorCrn,\n-                        environmentCrns, userCrns, machineUserCrns,\n-                        requestIdOptional, fullSync);\n-            }\n-\n-            return envUsersStateMap;\n-        } catch (RuntimeException e) {\n-            throw new UmsOperationException(String.format(\"Error during UMS operation: '%s'\", e.getLocalizedMessage()), e);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    Map<String, UmsUsersState> getUmsUsersStateMapBulk(\n-            String accountId, Collection<String> environmentCrns, Optional<String> requestIdOptional) {\n-\n-        List<String> environmentCrnList = List.copyOf(environmentCrns);\n-        GetUserSyncStateModelResponse userSyncStateModel = grpcUmsClient.getUserSyncStateModel(\n-                INTERNAL_ACTOR_CRN,\n-                accountId,\n-                generateRightsChecksForEnvironments(environmentCrnList),\n-                requestIdOptional);\n-\n-        Map<String, FmsGroup> groups = convertGroupsToFmsGroups(userSyncStateModel.getGroupList());\n-        Map<WorkloadAdministrationGroup, FmsGroup> wags =\n-                convertWagsToFmsGroups(userSyncStateModel.getWorkloadAdministrationGroupList());\n-        List<String> requestedWorkloadUsernames = userSyncStateModel.getActorList().stream()\n-                .map(UserManagementProto.UserSyncActor::getActorDetails)\n-                .map(UserManagementProto.UserSyncActorDetails::getWorkloadUsername)\n-                .collect(Collectors.toList());\n-\n-        Map<String, UmsUsersState> umsUsersStateMap = Maps.newHashMap();\n-        IntStream.range(0, environmentCrnList.size())\n-                .forEach(environmentIndex -> {\n-                    String environmentCrn = environmentCrnList.get(environmentIndex);\n-                    UmsUsersState.Builder umsUsersStateBuilder = UmsUsersState.newBuilder()\n-                            .setWorkloadAdministrationGroups(wags.values());\n-                    UsersState.Builder usersStateBuilder = UsersState.newBuilder();\n-                    addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n-                    addGroupsToUsersStateBuilder(usersStateBuilder, groups.values());\n-                    Set<String> wagNamesForOtherEnvironments =\n-                            addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n-                    addActorsToUmsUsersStateBuilder(\n-                            umsUsersStateBuilder,\n-                            usersStateBuilder,\n-                            environmentIndex,\n-                            userSyncStateModel,\n-                            groups,\n-                            wagNamesForOtherEnvironments);\n-                    addServicePrinciplesCloudIdentities(\n-                            accountId, environmentCrn, umsUsersStateBuilder, requestIdOptional);\n-                    umsUsersStateBuilder.setUsersState(usersStateBuilder.build());\n-                    umsUsersStateMap.put(environmentCrn, umsUsersStateBuilder.build());\n-                });\n-        return umsUsersStateMap;\n-    }\n-\n-    @VisibleForTesting\n-    Map<String, UmsUsersState> getUmsUsersStateMap(\n-            String accountId, String actorCrn, Collection<String> environmentCrns,\n-            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional,\n-            boolean fullSync) {\n-        List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-        List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-        Map<String, FmsGroup> crnToFmsGroup = convertGroupsToFmsGroups(\n-                grpcUmsClient.listAllGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n-        Map<WorkloadAdministrationGroup, FmsGroup> wags = convertWagsToFmsGroups(\n-                grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n-        List<String> requestedWorkloadUsernames = Streams.concat(\n-                users.stream().map(User::getWorkloadUsername),\n-                machineUsers.stream().map(MachineUser::getWorkloadUsername))\n-                .collect(Collectors.toList());\n-\n-        Map<String, UmsUsersState> umsUsersStateMap = new HashMap<>();\n-        environmentCrns.forEach(environmentCrn -> {\n-            UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                    .setWorkloadAdministrationGroups(wags.values());\n-            UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-            addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n-            addGroupsToUsersStateBuilder(usersStateBuilder, crnToFmsGroup.values());\n-            Set<String> wagNamesForOtherEnvironments =\n-                    addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n-\n-            EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n-            TriConsumer<String, FmsUser, List<CloudIdentity>> actorHandler =\n-                    (memberCrn, fmsUser, cloudIdentityList) -> {\n-                        try {\n-                            handleActor(umsUsersStateBuilder,\n-                                    usersStateBuilder,\n-                                    environmentAccessChecker.hasAccess(memberCrn, requestIdOptional),\n-                                    crnToFmsGroup,\n-                                    wagNamesForOtherEnvironments,\n-                                    fmsUser,\n-                                    () -> grpcUmsClient.listGroupsForMember(\n-                                            INTERNAL_ACTOR_CRN, accountId, memberCrn, requestIdOptional),\n-                                    () -> grpcUmsClient.listWorkloadAdministrationGroupsForMember(\n-                                            INTERNAL_ACTOR_CRN, memberCrn, requestIdOptional),\n-                                    () -> umsCredentialProvider.getCredentials(memberCrn, requestIdOptional),\n-                                    cloudIdentityList);\n-                        } catch (StatusRuntimeException e) {\n-                            // NOT_FOUND errors indicate that a user/machineUser has been deleted after we have\n-                            // retrieved the list of users/machineUsers from the UMS. Interrupt calculation of group\n-                            // membership.\n-                            if (e.getStatus().getCode() == Status.Code.NOT_FOUND) {\n-                                LOGGER.warn(\"Member CRN {} not found in UMS. Member will not be added to the UMS Users State. {}\",\n-                                        memberCrn, e.getLocalizedMessage());\n-                            } else {\n-                                throw e;\n-                            }\n-                        }\n-                    };\n-            users.forEach(u -> actorHandler.accept(u.getCrn(), Conversions.toFmsUser(u), u.getCloudIdentitiesList()));\n-            machineUsers.forEach(mu -> actorHandler.accept(mu.getCrn(), Conversions.toFmsUser(mu), mu.getCloudIdentitiesList()));\n-\n-            addServicePrinciplesCloudIdentities(\n-                    accountId, environmentCrn, umsUsersStateBuilder, requestIdOptional);\n-\n-            umsUsersStateBuilder.setUsersState(usersStateBuilder.build());\n-            umsUsersStateMap.put(environmentCrn, umsUsersStateBuilder.build());\n-        });\n-        return umsUsersStateMap;\n-    }\n-\n-    private void addActorsToUmsUsersStateBuilder(\n-            UmsUsersState.Builder umsUsersStateBuilder,\n-            UsersState.Builder usersStateBuilder,\n-            int environmentIndex,\n-            GetUserSyncStateModelResponse userSyncStateModel,\n-            Map<String, FmsGroup> crnToFmsGroup,\n-            Set<String> wagNamesForOtherEnvironments) {\n-\n-        // process actors - users and machine users are combined in the actor list\n-        userSyncStateModel.getActorList().stream().forEach(actor -> {\n-            RightsCheckResult rightsCheckResult = actor.getRightsCheckResult(environmentIndex);\n-            EnvironmentAccessRights environmentAccessRights = new EnvironmentAccessRights(\n-                    rightsCheckResult.getHasRight(0),\n-                    rightsCheckResult.getHasRight(1));\n-\n-            handleActor(umsUsersStateBuilder,\n-                    usersStateBuilder,\n-                    environmentAccessRights,\n-                    crnToFmsGroup,\n-                    wagNamesForOtherEnvironments,\n-                    Conversions.toFmsUser(actor.getActorDetails()),\n-                    () -> actor.getGroupIndexList().stream()\n-                            .map(groupIndex ->\n-                                    userSyncStateModel.getGroupList().get(groupIndex).getCrn())\n-                            .collect(Collectors.toList()),\n-                    () -> actor.getWorkloadAdministrationGroupIndexList().stream()\n-                            .map(wagIndex ->\n-                                    userSyncStateModel.getWorkloadAdministrationGroupList()\n-                                            .get(wagIndex).getWorkloadAdministrationGroupName())\n-                            .collect(Collectors.toList()),\n-                    () -> Conversions.toWorkloadCredential(actor.getCredentials()),\n-                    actor.getActorDetails().getCloudIdentityList());\n-        });\n-\n-    }\n-\n-    private void addRequestedWorkloadUsernames(\n-            UmsUsersState.Builder umsUsersStateBuilder, List<String> requestedWorkloadUsernames) {\n-        umsUsersStateBuilder.addAllRequestedWorkloadUsernames(requestedWorkloadUsernames);\n-    }\n-\n-    private void addGroupsToUsersStateBuilder(UsersState.Builder builder, Collection<FmsGroup> groups) {\n-        groups.forEach(builder::addGroup);\n-        // Add internal usersync group for each environment\n-        builder.addGroup(USERSYNC_INTERNAL_GROUP);\n-    }\n-\n-    private Set<String> addWagsToUsersStateBuilder(\n-            UsersState.Builder builder,\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags,\n-            String environmentCrn) {\n-        Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-        // Only add workload admin groups that belong to this environment.\n-        // At the same time, build a set of workload admin groups that are\n-        // associated with other environments so we can filter these out in\n-        // the per-user group listing in handleUser.\n-        wags.entrySet().forEach(wagEntry -> {\n-            WorkloadAdministrationGroup wag = wagEntry.getKey();\n-            String groupName = wag.getWorkloadAdministrationGroupName();\n-            if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                builder.addGroup(wagEntry.getValue());\n-            } else {\n-                Crn resourceCrn = getCrn(wag);\n-                if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                        && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                    wagNamesForOtherEnvironments.add(groupName);\n-                }\n-            }\n-        });\n-        return wagNamesForOtherEnvironments;\n-    }\n-\n-    private Map<String, FmsGroup> convertGroupsToFmsGroups(List<Group> groups) {\n-        return groups.stream().collect(Collectors.toMap(Group::getCrn, Conversions::umsGroupToGroup));\n-    }\n-\n-    private Map<WorkloadAdministrationGroup, FmsGroup> convertWagsToFmsGroups(List<WorkloadAdministrationGroup> wags) {\n-        return wags.stream()\n-                .collect(Collectors.toMap(wag -> wag, wag -> Conversions.nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-    }\n-\n-    private List<RightsCheck> generateRightsChecksForEnvironments(Collection<String> environmentCrns) {\n-        return environmentCrns.stream()\n-                .map(crn -> RightsCheck.newBuilder()\n-                        .setResourceCrn(crn)\n-                        .addAllRight(RIGHTS)\n-                        .build())\n-                .collect(Collectors.toList());\n-    }\n-\n-    private List<User> getUsers(String actorCrn, String accountId, Optional<String> requestIdOptional, boolean fullSync, Set<String> userCrns) {\n-        if (fullSync) {\n-            return grpcUmsClient.listAllUsers(actorCrn, accountId, requestIdOptional);\n-        } else if (!userCrns.isEmpty()) {\n-            return grpcUmsClient.listUsers(actorCrn, accountId, List.copyOf(userCrns), requestIdOptional);\n-        } else {\n-            return List.of();\n-        }\n-    }\n-\n-    private List<MachineUser> getMachineUsers(String actorCrn, String accountId, Optional<String> requestIdOptional,\n-        boolean fullSync, Set<String> machineUserCrns) {\n-        if (fullSync) {\n-            return grpcUmsClient.listAllMachineUsers(actorCrn, accountId,\n-                    INCLUDE_INTERNAL_MACHINE_USERS, requestIdOptional);\n-        } else if (!machineUserCrns.isEmpty()) {\n-            return grpcUmsClient.listMachineUsers(actorCrn, accountId, List.copyOf(machineUserCrns),\n-                    INCLUDE_INTERNAL_MACHINE_USERS, requestIdOptional);\n-        } else {\n-            return List.of();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"ParameterNumber\")\n-    private void handleActor(\n-            UmsUsersState.Builder umsUsersStateBuilder,\n-            UsersState.Builder usersStateBuilder,\n-            EnvironmentAccessRights environmentAccessRights,\n-            Map<String, FmsGroup> crnToFmsGroup,\n-            Set<String> wagNamesForOtherEnvironments,\n-            FmsUser fmsUser,\n-            Supplier<Collection<String>> groupCrnMembershipSupplier,\n-            Supplier<Collection<String>> wagMembershipSupplier,\n-            Supplier<WorkloadCredential> workloadCredentialSupplier,\n-            List<CloudIdentity> cloudIdentityList) {\n-\n-        if (environmentAccessRights.hasEnvironmentAccessRight()) {\n-            String workloadUsername = fmsUser.getName();\n-\n-            // Retrieve all information from UMS before modifying to the UmsUsersState or UsersState. This is so that\n-            // we don't partially modify the state if the member has been deleted after we started the sync\n-            Collection<String> groupCrnsForMember = groupCrnMembershipSupplier.get();\n-            Collection<String> workloadAdministrationGroupsForMember = wagMembershipSupplier.get();\n-            WorkloadCredential workloadCredential = workloadCredentialSupplier.get();\n-\n-            groupCrnsForMember.forEach(gcrn -> {\n-                FmsGroup group = crnToFmsGroup.get(gcrn);\n-                // If the group is null, then there has been a group membership change after we started the sync\n-                // the group and group membership will be updated on the next sync\n-                if (group != null) {\n-                    usersStateBuilder.addMemberToGroup(group.getName(), workloadUsername);\n-                } else {\n-                    LOGGER.warn(\"{} is a member of unexpected group {}. Group must have been added after UMS state calculation started\",\n-                            workloadUsername, gcrn);\n-                }\n-            });\n-            workloadAdministrationGroupsForMember.stream()\n-                    .filter(wagName -> !wagNamesForOtherEnvironments.contains(wagName))\n-                    .forEach(wagName -> {\n-                        usersStateBuilder.addGroup(Conversions.nameToGroup(wagName));\n-                        usersStateBuilder.addMemberToGroup(wagName, workloadUsername);\n-                    });\n-\n-            addMemberToInternalTrackingGroup(usersStateBuilder, workloadUsername);\n-            if (environmentAccessRights.hasAdminFreeIpaRight()) {\n-                usersStateBuilder.addMemberToGroup(UserSyncConstants.ADMINS_GROUP, workloadUsername);\n-            }\n-\n-            umsUsersStateBuilder.addWorkloadCredentials(workloadUsername, workloadCredential);\n-            umsUsersStateBuilder.addUserCloudIdentities(workloadUsername, cloudIdentityList);\n-            usersStateBuilder.addUser(fmsUser);\n-        }\n-    }\n-\n-    private void addServicePrinciplesCloudIdentities(\n-            String accountId, String environmentCrn,\n-            UmsUsersState.Builder builder, Optional<String> requestIdOptional) {\n-        List<ServicePrincipalCloudIdentities> servicePrincipalCloudIdentities =\n-                grpcUmsClient.listServicePrincipalCloudIdentities(INTERNAL_ACTOR_CRN, accountId, environmentCrn, requestIdOptional);\n-        builder.addServicePrincipalCloudIdentities(servicePrincipalCloudIdentities);\n-    }\n-\n-    private void addMemberToInternalTrackingGroup(UsersState.Builder usersStateBuilder, String username) {\n-        usersStateBuilder.addMemberToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP, username);\n-    }\n-\n-    private EnvironmentAccessChecker createEnvironmentAccessChecker(String environmentCrn) {\n-        requireNonNull(environmentCrn, \"environmentCrn is null\");\n-        return new EnvironmentAccessChecker(grpcUmsClient, umsRightProvider, environmentCrn);\n-    }\n-\n-    private Crn getCrn(WorkloadAdministrationGroup wag) {\n-        Crn resourceCrn = null;\n-        try {\n-            resourceCrn = Crn.fromString(wag.getResource());\n-        } catch (Exception e) {\n-            LOGGER.debug(\"Invalid resource is assigned to workload admin group: {}\", e.getMessage());\n-        }\n-        return resourceCrn;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4NDg1NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490984854", "bodyText": "could you break this up into smaller ones? maybe move them to a separate class", "author": "lacikaaa", "createdAt": "2020-09-18T14:22:22Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -54,92 +77,233 @@\n     @Inject\n     private UmsRightProvider umsRightProvider;\n \n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(String accountId, String actorCrn, Set<String> environmentCrns,\n-        Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n         try {\n             LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n \n-            Map<String, UmsUsersState> envUsersStateMap = new HashMap<>();\n-\n             boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n \n-            List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-\n-            List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-            Map<String, FmsGroup> crnToFmsGroup = grpcUmsClient.listGroups(actorCrn, accountId, List.of(), requestIdOptional).stream()\n-                    .collect(Collectors.toMap(Group::getCrn, this::umsGroupToGroup));\n-\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags = grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional)\n-                    .stream()\n-                    .collect(Collectors.toMap(wag -> wag, wag -> nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-            environmentCrns.forEach(environmentCrn -> {\n-                UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                        .setWorkloadAdministrationGroups(wags.values());\n-\n-                UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-                Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-\n-                crnToFmsGroup.values().forEach(usersStateBuilder::addGroup);\n-\n-                // Only add workload admin groups that belong to this environment.\n-                // At the same time, build a set of workload admin groups that are\n-                // associated with other environments so we can filter these out in\n-                // the per-user group listing in handleUser.\n-                wags.entrySet().forEach(wagEntry -> {\n-                    WorkloadAdministrationGroup wag = wagEntry.getKey();\n-                    String groupName = wag.getWorkloadAdministrationGroupName();\n-                    if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                        usersStateBuilder.addGroup(wagEntry.getValue());\n-                    } else {\n-                        Crn resourceCrn = getCrn(wag);\n-                        if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                                && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                            wagNamesForOtherEnvironments.add(groupName);\n-                        }\n-                    }\n-                });\n+            Map<String, UmsUsersState> envUsersStateMap;\n+            if (fullSync && entitlementService.umsUserSyncModelGenerationEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n+                envUsersStateMap = getUmsUsersStateMapBulk(accountId, environmentCrns, requestIdOptional);\n+            } else {\n+                envUsersStateMap = getUmsUsersStateMap(\n+                        accountId, actorCrn,\n+                        environmentCrns, userCrns, machineUserCrns,\n+                        requestIdOptional, fullSync);\n+            }\n \n-                // Add internal usersync group for each environment\n-                usersStateBuilder.addGroup(nameToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP));\n+            return envUsersStateMap;\n+        } catch (RuntimeException e) {\n+            throw new UmsOperationException(String.format(\"Error during UMS operation: '%s'\", e.getLocalizedMessage()), e);\n+        }\n+    }\n \n-                EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+    @VisibleForTesting\n+    Map<String, UmsUsersState> getUmsUsersStateMapBulk(", "originalCommit": "73d6dc30ed172b314b02349317c6ab811980703c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MjA0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492162046", "bodyText": "done.\nI created the UmsUsersStateProviderDispatcher that directs the request to either the bulk or default implementations. Common functionality is moved to a Base class and an ActorHandler was pulled out to a separate class.", "author": "handavid", "createdAt": "2020-09-21T15:42:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4NDg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java\ndeleted file mode 100644\nindex 1f8e097001..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java\n+++ /dev/null\n\n@@ -1,409 +0,0 @@\n-package com.sequenceiq.freeipa.service.freeipa.user;\n-\n-import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n-import javax.inject.Inject;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Maps;\n-import com.google.common.collect.Streams;\n-import com.sequenceiq.authorization.resource.AuthorizationResourceAction;\n-import com.sequenceiq.cloudbreak.auth.altus.EntitlementService;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.Conversions;\n-import org.apache.logging.log4j.util.TriConsumer;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Service;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.CloudIdentity;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetUserSyncStateModelResponse;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.Group;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.MachineUser;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.RightsCheck;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.RightsCheckResult;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ServicePrincipalCloudIdentities;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.User;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.WorkloadAdministrationGroup;\n-import com.sequenceiq.authorization.service.UmsRightProvider;\n-import com.sequenceiq.cloudbreak.auth.altus.Crn;\n-import com.sequenceiq.cloudbreak.auth.altus.Crn.ResourceType;\n-import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n-import com.sequenceiq.cloudbreak.auth.altus.exception.UmsOperationException;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.EnvironmentAccessRights;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.UsersState;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.WorkloadCredential;\n-\n-import io.grpc.Status;\n-import io.grpc.StatusRuntimeException;\n-\n-@Service\n-public class UmsUsersStateProvider {\n-    @VisibleForTesting\n-    static final boolean INCLUDE_INTERNAL_MACHINE_USERS = true;\n-\n-    @VisibleForTesting\n-    static final List<String> RIGHTS = ImmutableList.of(\n-            AuthorizationResourceAction.ACCESS_ENVIRONMENT.getRight(),\n-            AuthorizationResourceAction.ADMIN_FREEIPA.getRight());\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(UmsUsersStateProvider.class);\n-\n-    private static final FmsGroup USERSYNC_INTERNAL_GROUP =\n-            Conversions.nameToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP);\n-\n-    @Inject\n-    private GrpcUmsClient grpcUmsClient;\n-\n-    @Inject\n-    private UmsCredentialProvider umsCredentialProvider;\n-\n-    @Inject\n-    private UmsRightProvider umsRightProvider;\n-\n-    @Inject\n-    private EntitlementService entitlementService;\n-\n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n-            String accountId, String actorCrn, Collection<String> environmentCrns,\n-            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n-        try {\n-            LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n-\n-            boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n-\n-            Map<String, UmsUsersState> envUsersStateMap;\n-            if (fullSync && entitlementService.umsUserSyncModelGenerationEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n-                envUsersStateMap = getUmsUsersStateMapBulk(accountId, environmentCrns, requestIdOptional);\n-            } else {\n-                envUsersStateMap = getUmsUsersStateMap(\n-                        accountId, actorCrn,\n-                        environmentCrns, userCrns, machineUserCrns,\n-                        requestIdOptional, fullSync);\n-            }\n-\n-            return envUsersStateMap;\n-        } catch (RuntimeException e) {\n-            throw new UmsOperationException(String.format(\"Error during UMS operation: '%s'\", e.getLocalizedMessage()), e);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    Map<String, UmsUsersState> getUmsUsersStateMapBulk(\n-            String accountId, Collection<String> environmentCrns, Optional<String> requestIdOptional) {\n-\n-        List<String> environmentCrnList = List.copyOf(environmentCrns);\n-        GetUserSyncStateModelResponse userSyncStateModel = grpcUmsClient.getUserSyncStateModel(\n-                INTERNAL_ACTOR_CRN,\n-                accountId,\n-                generateRightsChecksForEnvironments(environmentCrnList),\n-                requestIdOptional);\n-\n-        Map<String, FmsGroup> groups = convertGroupsToFmsGroups(userSyncStateModel.getGroupList());\n-        Map<WorkloadAdministrationGroup, FmsGroup> wags =\n-                convertWagsToFmsGroups(userSyncStateModel.getWorkloadAdministrationGroupList());\n-        List<String> requestedWorkloadUsernames = userSyncStateModel.getActorList().stream()\n-                .map(UserManagementProto.UserSyncActor::getActorDetails)\n-                .map(UserManagementProto.UserSyncActorDetails::getWorkloadUsername)\n-                .collect(Collectors.toList());\n-\n-        Map<String, UmsUsersState> umsUsersStateMap = Maps.newHashMap();\n-        IntStream.range(0, environmentCrnList.size())\n-                .forEach(environmentIndex -> {\n-                    String environmentCrn = environmentCrnList.get(environmentIndex);\n-                    UmsUsersState.Builder umsUsersStateBuilder = UmsUsersState.newBuilder()\n-                            .setWorkloadAdministrationGroups(wags.values());\n-                    UsersState.Builder usersStateBuilder = UsersState.newBuilder();\n-                    addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n-                    addGroupsToUsersStateBuilder(usersStateBuilder, groups.values());\n-                    Set<String> wagNamesForOtherEnvironments =\n-                            addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n-                    addActorsToUmsUsersStateBuilder(\n-                            umsUsersStateBuilder,\n-                            usersStateBuilder,\n-                            environmentIndex,\n-                            userSyncStateModel,\n-                            groups,\n-                            wagNamesForOtherEnvironments);\n-                    addServicePrinciplesCloudIdentities(\n-                            accountId, environmentCrn, umsUsersStateBuilder, requestIdOptional);\n-                    umsUsersStateBuilder.setUsersState(usersStateBuilder.build());\n-                    umsUsersStateMap.put(environmentCrn, umsUsersStateBuilder.build());\n-                });\n-        return umsUsersStateMap;\n-    }\n-\n-    @VisibleForTesting\n-    Map<String, UmsUsersState> getUmsUsersStateMap(\n-            String accountId, String actorCrn, Collection<String> environmentCrns,\n-            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional,\n-            boolean fullSync) {\n-        List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-        List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-        Map<String, FmsGroup> crnToFmsGroup = convertGroupsToFmsGroups(\n-                grpcUmsClient.listAllGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n-        Map<WorkloadAdministrationGroup, FmsGroup> wags = convertWagsToFmsGroups(\n-                grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n-        List<String> requestedWorkloadUsernames = Streams.concat(\n-                users.stream().map(User::getWorkloadUsername),\n-                machineUsers.stream().map(MachineUser::getWorkloadUsername))\n-                .collect(Collectors.toList());\n-\n-        Map<String, UmsUsersState> umsUsersStateMap = new HashMap<>();\n-        environmentCrns.forEach(environmentCrn -> {\n-            UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                    .setWorkloadAdministrationGroups(wags.values());\n-            UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-            addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n-            addGroupsToUsersStateBuilder(usersStateBuilder, crnToFmsGroup.values());\n-            Set<String> wagNamesForOtherEnvironments =\n-                    addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n-\n-            EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n-            TriConsumer<String, FmsUser, List<CloudIdentity>> actorHandler =\n-                    (memberCrn, fmsUser, cloudIdentityList) -> {\n-                        try {\n-                            handleActor(umsUsersStateBuilder,\n-                                    usersStateBuilder,\n-                                    environmentAccessChecker.hasAccess(memberCrn, requestIdOptional),\n-                                    crnToFmsGroup,\n-                                    wagNamesForOtherEnvironments,\n-                                    fmsUser,\n-                                    () -> grpcUmsClient.listGroupsForMember(\n-                                            INTERNAL_ACTOR_CRN, accountId, memberCrn, requestIdOptional),\n-                                    () -> grpcUmsClient.listWorkloadAdministrationGroupsForMember(\n-                                            INTERNAL_ACTOR_CRN, memberCrn, requestIdOptional),\n-                                    () -> umsCredentialProvider.getCredentials(memberCrn, requestIdOptional),\n-                                    cloudIdentityList);\n-                        } catch (StatusRuntimeException e) {\n-                            // NOT_FOUND errors indicate that a user/machineUser has been deleted after we have\n-                            // retrieved the list of users/machineUsers from the UMS. Interrupt calculation of group\n-                            // membership.\n-                            if (e.getStatus().getCode() == Status.Code.NOT_FOUND) {\n-                                LOGGER.warn(\"Member CRN {} not found in UMS. Member will not be added to the UMS Users State. {}\",\n-                                        memberCrn, e.getLocalizedMessage());\n-                            } else {\n-                                throw e;\n-                            }\n-                        }\n-                    };\n-            users.forEach(u -> actorHandler.accept(u.getCrn(), Conversions.toFmsUser(u), u.getCloudIdentitiesList()));\n-            machineUsers.forEach(mu -> actorHandler.accept(mu.getCrn(), Conversions.toFmsUser(mu), mu.getCloudIdentitiesList()));\n-\n-            addServicePrinciplesCloudIdentities(\n-                    accountId, environmentCrn, umsUsersStateBuilder, requestIdOptional);\n-\n-            umsUsersStateBuilder.setUsersState(usersStateBuilder.build());\n-            umsUsersStateMap.put(environmentCrn, umsUsersStateBuilder.build());\n-        });\n-        return umsUsersStateMap;\n-    }\n-\n-    private void addActorsToUmsUsersStateBuilder(\n-            UmsUsersState.Builder umsUsersStateBuilder,\n-            UsersState.Builder usersStateBuilder,\n-            int environmentIndex,\n-            GetUserSyncStateModelResponse userSyncStateModel,\n-            Map<String, FmsGroup> crnToFmsGroup,\n-            Set<String> wagNamesForOtherEnvironments) {\n-\n-        // process actors - users and machine users are combined in the actor list\n-        userSyncStateModel.getActorList().stream().forEach(actor -> {\n-            RightsCheckResult rightsCheckResult = actor.getRightsCheckResult(environmentIndex);\n-            EnvironmentAccessRights environmentAccessRights = new EnvironmentAccessRights(\n-                    rightsCheckResult.getHasRight(0),\n-                    rightsCheckResult.getHasRight(1));\n-\n-            handleActor(umsUsersStateBuilder,\n-                    usersStateBuilder,\n-                    environmentAccessRights,\n-                    crnToFmsGroup,\n-                    wagNamesForOtherEnvironments,\n-                    Conversions.toFmsUser(actor.getActorDetails()),\n-                    () -> actor.getGroupIndexList().stream()\n-                            .map(groupIndex ->\n-                                    userSyncStateModel.getGroupList().get(groupIndex).getCrn())\n-                            .collect(Collectors.toList()),\n-                    () -> actor.getWorkloadAdministrationGroupIndexList().stream()\n-                            .map(wagIndex ->\n-                                    userSyncStateModel.getWorkloadAdministrationGroupList()\n-                                            .get(wagIndex).getWorkloadAdministrationGroupName())\n-                            .collect(Collectors.toList()),\n-                    () -> Conversions.toWorkloadCredential(actor.getCredentials()),\n-                    actor.getActorDetails().getCloudIdentityList());\n-        });\n-\n-    }\n-\n-    private void addRequestedWorkloadUsernames(\n-            UmsUsersState.Builder umsUsersStateBuilder, List<String> requestedWorkloadUsernames) {\n-        umsUsersStateBuilder.addAllRequestedWorkloadUsernames(requestedWorkloadUsernames);\n-    }\n-\n-    private void addGroupsToUsersStateBuilder(UsersState.Builder builder, Collection<FmsGroup> groups) {\n-        groups.forEach(builder::addGroup);\n-        // Add internal usersync group for each environment\n-        builder.addGroup(USERSYNC_INTERNAL_GROUP);\n-    }\n-\n-    private Set<String> addWagsToUsersStateBuilder(\n-            UsersState.Builder builder,\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags,\n-            String environmentCrn) {\n-        Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-        // Only add workload admin groups that belong to this environment.\n-        // At the same time, build a set of workload admin groups that are\n-        // associated with other environments so we can filter these out in\n-        // the per-user group listing in handleUser.\n-        wags.entrySet().forEach(wagEntry -> {\n-            WorkloadAdministrationGroup wag = wagEntry.getKey();\n-            String groupName = wag.getWorkloadAdministrationGroupName();\n-            if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                builder.addGroup(wagEntry.getValue());\n-            } else {\n-                Crn resourceCrn = getCrn(wag);\n-                if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                        && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                    wagNamesForOtherEnvironments.add(groupName);\n-                }\n-            }\n-        });\n-        return wagNamesForOtherEnvironments;\n-    }\n-\n-    private Map<String, FmsGroup> convertGroupsToFmsGroups(List<Group> groups) {\n-        return groups.stream().collect(Collectors.toMap(Group::getCrn, Conversions::umsGroupToGroup));\n-    }\n-\n-    private Map<WorkloadAdministrationGroup, FmsGroup> convertWagsToFmsGroups(List<WorkloadAdministrationGroup> wags) {\n-        return wags.stream()\n-                .collect(Collectors.toMap(wag -> wag, wag -> Conversions.nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-    }\n-\n-    private List<RightsCheck> generateRightsChecksForEnvironments(Collection<String> environmentCrns) {\n-        return environmentCrns.stream()\n-                .map(crn -> RightsCheck.newBuilder()\n-                        .setResourceCrn(crn)\n-                        .addAllRight(RIGHTS)\n-                        .build())\n-                .collect(Collectors.toList());\n-    }\n-\n-    private List<User> getUsers(String actorCrn, String accountId, Optional<String> requestIdOptional, boolean fullSync, Set<String> userCrns) {\n-        if (fullSync) {\n-            return grpcUmsClient.listAllUsers(actorCrn, accountId, requestIdOptional);\n-        } else if (!userCrns.isEmpty()) {\n-            return grpcUmsClient.listUsers(actorCrn, accountId, List.copyOf(userCrns), requestIdOptional);\n-        } else {\n-            return List.of();\n-        }\n-    }\n-\n-    private List<MachineUser> getMachineUsers(String actorCrn, String accountId, Optional<String> requestIdOptional,\n-        boolean fullSync, Set<String> machineUserCrns) {\n-        if (fullSync) {\n-            return grpcUmsClient.listAllMachineUsers(actorCrn, accountId,\n-                    INCLUDE_INTERNAL_MACHINE_USERS, requestIdOptional);\n-        } else if (!machineUserCrns.isEmpty()) {\n-            return grpcUmsClient.listMachineUsers(actorCrn, accountId, List.copyOf(machineUserCrns),\n-                    INCLUDE_INTERNAL_MACHINE_USERS, requestIdOptional);\n-        } else {\n-            return List.of();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"ParameterNumber\")\n-    private void handleActor(\n-            UmsUsersState.Builder umsUsersStateBuilder,\n-            UsersState.Builder usersStateBuilder,\n-            EnvironmentAccessRights environmentAccessRights,\n-            Map<String, FmsGroup> crnToFmsGroup,\n-            Set<String> wagNamesForOtherEnvironments,\n-            FmsUser fmsUser,\n-            Supplier<Collection<String>> groupCrnMembershipSupplier,\n-            Supplier<Collection<String>> wagMembershipSupplier,\n-            Supplier<WorkloadCredential> workloadCredentialSupplier,\n-            List<CloudIdentity> cloudIdentityList) {\n-\n-        if (environmentAccessRights.hasEnvironmentAccessRight()) {\n-            String workloadUsername = fmsUser.getName();\n-\n-            // Retrieve all information from UMS before modifying to the UmsUsersState or UsersState. This is so that\n-            // we don't partially modify the state if the member has been deleted after we started the sync\n-            Collection<String> groupCrnsForMember = groupCrnMembershipSupplier.get();\n-            Collection<String> workloadAdministrationGroupsForMember = wagMembershipSupplier.get();\n-            WorkloadCredential workloadCredential = workloadCredentialSupplier.get();\n-\n-            groupCrnsForMember.forEach(gcrn -> {\n-                FmsGroup group = crnToFmsGroup.get(gcrn);\n-                // If the group is null, then there has been a group membership change after we started the sync\n-                // the group and group membership will be updated on the next sync\n-                if (group != null) {\n-                    usersStateBuilder.addMemberToGroup(group.getName(), workloadUsername);\n-                } else {\n-                    LOGGER.warn(\"{} is a member of unexpected group {}. Group must have been added after UMS state calculation started\",\n-                            workloadUsername, gcrn);\n-                }\n-            });\n-            workloadAdministrationGroupsForMember.stream()\n-                    .filter(wagName -> !wagNamesForOtherEnvironments.contains(wagName))\n-                    .forEach(wagName -> {\n-                        usersStateBuilder.addGroup(Conversions.nameToGroup(wagName));\n-                        usersStateBuilder.addMemberToGroup(wagName, workloadUsername);\n-                    });\n-\n-            addMemberToInternalTrackingGroup(usersStateBuilder, workloadUsername);\n-            if (environmentAccessRights.hasAdminFreeIpaRight()) {\n-                usersStateBuilder.addMemberToGroup(UserSyncConstants.ADMINS_GROUP, workloadUsername);\n-            }\n-\n-            umsUsersStateBuilder.addWorkloadCredentials(workloadUsername, workloadCredential);\n-            umsUsersStateBuilder.addUserCloudIdentities(workloadUsername, cloudIdentityList);\n-            usersStateBuilder.addUser(fmsUser);\n-        }\n-    }\n-\n-    private void addServicePrinciplesCloudIdentities(\n-            String accountId, String environmentCrn,\n-            UmsUsersState.Builder builder, Optional<String> requestIdOptional) {\n-        List<ServicePrincipalCloudIdentities> servicePrincipalCloudIdentities =\n-                grpcUmsClient.listServicePrincipalCloudIdentities(INTERNAL_ACTOR_CRN, accountId, environmentCrn, requestIdOptional);\n-        builder.addServicePrincipalCloudIdentities(servicePrincipalCloudIdentities);\n-    }\n-\n-    private void addMemberToInternalTrackingGroup(UsersState.Builder usersStateBuilder, String username) {\n-        usersStateBuilder.addMemberToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP, username);\n-    }\n-\n-    private EnvironmentAccessChecker createEnvironmentAccessChecker(String environmentCrn) {\n-        requireNonNull(environmentCrn, \"environmentCrn is null\");\n-        return new EnvironmentAccessChecker(grpcUmsClient, umsRightProvider, environmentCrn);\n-    }\n-\n-    private Crn getCrn(WorkloadAdministrationGroup wag) {\n-        Crn resourceCrn = null;\n-        try {\n-            resourceCrn = Crn.fromString(wag.getResource());\n-        } catch (Exception e) {\n-            LOGGER.debug(\"Invalid resource is assigned to workload admin group: {}\", e.getMessage());\n-        }\n-        return resourceCrn;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAxNTQyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r491015423", "bodyText": "I have to say this class is getting more and more complex, the methods are getting more complex and bigger. It's pretty hard to understand and review it actually. I would like to kindly ask you to refactor this before/while putting these new bulk sync logic into it.\neg this actorHandler might be a separate class as it has a try-catch, which invokes a method with 10 parameters, 3 of them are lambdas", "author": "lacikaaa", "createdAt": "2020-09-18T15:09:58Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -54,92 +77,233 @@\n     @Inject\n     private UmsRightProvider umsRightProvider;\n \n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(String accountId, String actorCrn, Set<String> environmentCrns,\n-        Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n         try {\n             LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n \n-            Map<String, UmsUsersState> envUsersStateMap = new HashMap<>();\n-\n             boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n \n-            List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-\n-            List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-            Map<String, FmsGroup> crnToFmsGroup = grpcUmsClient.listGroups(actorCrn, accountId, List.of(), requestIdOptional).stream()\n-                    .collect(Collectors.toMap(Group::getCrn, this::umsGroupToGroup));\n-\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags = grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional)\n-                    .stream()\n-                    .collect(Collectors.toMap(wag -> wag, wag -> nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-            environmentCrns.forEach(environmentCrn -> {\n-                UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                        .setWorkloadAdministrationGroups(wags.values());\n-\n-                UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-                Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-\n-                crnToFmsGroup.values().forEach(usersStateBuilder::addGroup);\n-\n-                // Only add workload admin groups that belong to this environment.\n-                // At the same time, build a set of workload admin groups that are\n-                // associated with other environments so we can filter these out in\n-                // the per-user group listing in handleUser.\n-                wags.entrySet().forEach(wagEntry -> {\n-                    WorkloadAdministrationGroup wag = wagEntry.getKey();\n-                    String groupName = wag.getWorkloadAdministrationGroupName();\n-                    if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                        usersStateBuilder.addGroup(wagEntry.getValue());\n-                    } else {\n-                        Crn resourceCrn = getCrn(wag);\n-                        if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                                && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                            wagNamesForOtherEnvironments.add(groupName);\n-                        }\n-                    }\n-                });\n+            Map<String, UmsUsersState> envUsersStateMap;\n+            if (fullSync && entitlementService.umsUserSyncModelGenerationEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n+                envUsersStateMap = getUmsUsersStateMapBulk(accountId, environmentCrns, requestIdOptional);\n+            } else {\n+                envUsersStateMap = getUmsUsersStateMap(\n+                        accountId, actorCrn,\n+                        environmentCrns, userCrns, machineUserCrns,\n+                        requestIdOptional, fullSync);\n+            }\n \n-                // Add internal usersync group for each environment\n-                usersStateBuilder.addGroup(nameToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP));\n+            return envUsersStateMap;\n+        } catch (RuntimeException e) {\n+            throw new UmsOperationException(String.format(\"Error during UMS operation: '%s'\", e.getLocalizedMessage()), e);\n+        }\n+    }\n \n-                EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+    @VisibleForTesting\n+    Map<String, UmsUsersState> getUmsUsersStateMapBulk(\n+            String accountId, Collection<String> environmentCrns, Optional<String> requestIdOptional) {\n+\n+        List<String> environmentCrnList = List.copyOf(environmentCrns);\n+        GetUserSyncStateModelResponse userSyncStateModel = grpcUmsClient.getUserSyncStateModel(\n+                INTERNAL_ACTOR_CRN,\n+                accountId,\n+                generateRightsChecksForEnvironments(environmentCrnList),\n+                requestIdOptional);\n+\n+        Map<String, FmsGroup> groups = convertGroupsToFmsGroups(userSyncStateModel.getGroupList());\n+        Map<WorkloadAdministrationGroup, FmsGroup> wags =\n+                convertWagsToFmsGroups(userSyncStateModel.getWorkloadAdministrationGroupList());\n+        List<String> requestedWorkloadUsernames = userSyncStateModel.getActorList().stream()\n+                .map(UserManagementProto.UserSyncActor::getActorDetails)\n+                .map(UserManagementProto.UserSyncActorDetails::getWorkloadUsername)\n+                .collect(Collectors.toList());\n+\n+        Map<String, UmsUsersState> umsUsersStateMap = Maps.newHashMap();\n+        IntStream.range(0, environmentCrnList.size())\n+                .forEach(environmentIndex -> {\n+                    String environmentCrn = environmentCrnList.get(environmentIndex);\n+                    UmsUsersState.Builder umsUsersStateBuilder = UmsUsersState.newBuilder()\n+                            .setWorkloadAdministrationGroups(wags.values());\n+                    UsersState.Builder usersStateBuilder = UsersState.newBuilder();\n+                    addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n+                    addGroupsToUsersStateBuilder(usersStateBuilder, groups.values());\n+                    Set<String> wagNamesForOtherEnvironments =\n+                            addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n+                    addActorsToUmsUsersStateBuilder(\n+                            umsUsersStateBuilder,\n+                            usersStateBuilder,\n+                            environmentIndex,\n+                            userSyncStateModel,\n+                            groups,\n+                            wagNamesForOtherEnvironments);\n+                    addServicePrinciplesCloudIdentities(\n+                            accountId, environmentCrn, umsUsersStateBuilder, requestIdOptional);\n+                    umsUsersStateBuilder.setUsersState(usersStateBuilder.build());\n+                    umsUsersStateMap.put(environmentCrn, umsUsersStateBuilder.build());\n+                });\n+        return umsUsersStateMap;\n+    }\n \n-                users.forEach(u -> {\n-                    FmsUser fmsUser = umsUserToUser(u);\n-                    // add workload username for each user. This will be helpful in getting users from IPA.\n-                    umsUsersStateBuilder.addRequestedWorkloadUsers(fmsUser);\n+    @VisibleForTesting\n+    Map<String, UmsUsersState> getUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional,\n+            boolean fullSync) {\n+        List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n+        List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n+\n+        Map<String, FmsGroup> crnToFmsGroup = convertGroupsToFmsGroups(\n+                grpcUmsClient.listAllGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n+        Map<WorkloadAdministrationGroup, FmsGroup> wags = convertWagsToFmsGroups(\n+                grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n+        List<String> requestedWorkloadUsernames = Streams.concat(\n+                users.stream().map(User::getWorkloadUsername),\n+                machineUsers.stream().map(MachineUser::getWorkloadUsername))\n+                .collect(Collectors.toList());\n+\n+        Map<String, UmsUsersState> umsUsersStateMap = new HashMap<>();\n+        environmentCrns.forEach(environmentCrn -> {\n+            UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n+                    .setWorkloadAdministrationGroups(wags.values());\n+            UsersState.Builder usersStateBuilder = new UsersState.Builder();\n+            addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n+            addGroupsToUsersStateBuilder(usersStateBuilder, crnToFmsGroup.values());\n+            Set<String> wagNamesForOtherEnvironments =\n+                    addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n+\n+            EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+            TriConsumer<String, FmsUser, List<CloudIdentity>> actorHandler =", "originalCommit": "73d6dc30ed172b314b02349317c6ab811980703c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MzU0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492163546", "bodyText": "refactored.\nI pulled out the common functionality between the bulk and default implementations into an ActorHandler and this TriConsumer to a separate method", "author": "handavid", "createdAt": "2020-09-21T15:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAxNTQyMw=="}], "type": "inlineReview", "revised_code": {"commit": "c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java\ndeleted file mode 100644\nindex 1f8e097001..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java\n+++ /dev/null\n\n@@ -1,409 +0,0 @@\n-package com.sequenceiq.freeipa.service.freeipa.user;\n-\n-import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n-import javax.inject.Inject;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Maps;\n-import com.google.common.collect.Streams;\n-import com.sequenceiq.authorization.resource.AuthorizationResourceAction;\n-import com.sequenceiq.cloudbreak.auth.altus.EntitlementService;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.Conversions;\n-import org.apache.logging.log4j.util.TriConsumer;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Service;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.CloudIdentity;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetUserSyncStateModelResponse;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.Group;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.MachineUser;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.RightsCheck;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.RightsCheckResult;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ServicePrincipalCloudIdentities;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.User;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.WorkloadAdministrationGroup;\n-import com.sequenceiq.authorization.service.UmsRightProvider;\n-import com.sequenceiq.cloudbreak.auth.altus.Crn;\n-import com.sequenceiq.cloudbreak.auth.altus.Crn.ResourceType;\n-import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n-import com.sequenceiq.cloudbreak.auth.altus.exception.UmsOperationException;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.EnvironmentAccessRights;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.UsersState;\n-import com.sequenceiq.freeipa.service.freeipa.user.model.WorkloadCredential;\n-\n-import io.grpc.Status;\n-import io.grpc.StatusRuntimeException;\n-\n-@Service\n-public class UmsUsersStateProvider {\n-    @VisibleForTesting\n-    static final boolean INCLUDE_INTERNAL_MACHINE_USERS = true;\n-\n-    @VisibleForTesting\n-    static final List<String> RIGHTS = ImmutableList.of(\n-            AuthorizationResourceAction.ACCESS_ENVIRONMENT.getRight(),\n-            AuthorizationResourceAction.ADMIN_FREEIPA.getRight());\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(UmsUsersStateProvider.class);\n-\n-    private static final FmsGroup USERSYNC_INTERNAL_GROUP =\n-            Conversions.nameToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP);\n-\n-    @Inject\n-    private GrpcUmsClient grpcUmsClient;\n-\n-    @Inject\n-    private UmsCredentialProvider umsCredentialProvider;\n-\n-    @Inject\n-    private UmsRightProvider umsRightProvider;\n-\n-    @Inject\n-    private EntitlementService entitlementService;\n-\n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n-            String accountId, String actorCrn, Collection<String> environmentCrns,\n-            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n-        try {\n-            LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n-\n-            boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n-\n-            Map<String, UmsUsersState> envUsersStateMap;\n-            if (fullSync && entitlementService.umsUserSyncModelGenerationEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n-                envUsersStateMap = getUmsUsersStateMapBulk(accountId, environmentCrns, requestIdOptional);\n-            } else {\n-                envUsersStateMap = getUmsUsersStateMap(\n-                        accountId, actorCrn,\n-                        environmentCrns, userCrns, machineUserCrns,\n-                        requestIdOptional, fullSync);\n-            }\n-\n-            return envUsersStateMap;\n-        } catch (RuntimeException e) {\n-            throw new UmsOperationException(String.format(\"Error during UMS operation: '%s'\", e.getLocalizedMessage()), e);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    Map<String, UmsUsersState> getUmsUsersStateMapBulk(\n-            String accountId, Collection<String> environmentCrns, Optional<String> requestIdOptional) {\n-\n-        List<String> environmentCrnList = List.copyOf(environmentCrns);\n-        GetUserSyncStateModelResponse userSyncStateModel = grpcUmsClient.getUserSyncStateModel(\n-                INTERNAL_ACTOR_CRN,\n-                accountId,\n-                generateRightsChecksForEnvironments(environmentCrnList),\n-                requestIdOptional);\n-\n-        Map<String, FmsGroup> groups = convertGroupsToFmsGroups(userSyncStateModel.getGroupList());\n-        Map<WorkloadAdministrationGroup, FmsGroup> wags =\n-                convertWagsToFmsGroups(userSyncStateModel.getWorkloadAdministrationGroupList());\n-        List<String> requestedWorkloadUsernames = userSyncStateModel.getActorList().stream()\n-                .map(UserManagementProto.UserSyncActor::getActorDetails)\n-                .map(UserManagementProto.UserSyncActorDetails::getWorkloadUsername)\n-                .collect(Collectors.toList());\n-\n-        Map<String, UmsUsersState> umsUsersStateMap = Maps.newHashMap();\n-        IntStream.range(0, environmentCrnList.size())\n-                .forEach(environmentIndex -> {\n-                    String environmentCrn = environmentCrnList.get(environmentIndex);\n-                    UmsUsersState.Builder umsUsersStateBuilder = UmsUsersState.newBuilder()\n-                            .setWorkloadAdministrationGroups(wags.values());\n-                    UsersState.Builder usersStateBuilder = UsersState.newBuilder();\n-                    addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n-                    addGroupsToUsersStateBuilder(usersStateBuilder, groups.values());\n-                    Set<String> wagNamesForOtherEnvironments =\n-                            addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n-                    addActorsToUmsUsersStateBuilder(\n-                            umsUsersStateBuilder,\n-                            usersStateBuilder,\n-                            environmentIndex,\n-                            userSyncStateModel,\n-                            groups,\n-                            wagNamesForOtherEnvironments);\n-                    addServicePrinciplesCloudIdentities(\n-                            accountId, environmentCrn, umsUsersStateBuilder, requestIdOptional);\n-                    umsUsersStateBuilder.setUsersState(usersStateBuilder.build());\n-                    umsUsersStateMap.put(environmentCrn, umsUsersStateBuilder.build());\n-                });\n-        return umsUsersStateMap;\n-    }\n-\n-    @VisibleForTesting\n-    Map<String, UmsUsersState> getUmsUsersStateMap(\n-            String accountId, String actorCrn, Collection<String> environmentCrns,\n-            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional,\n-            boolean fullSync) {\n-        List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-        List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-        Map<String, FmsGroup> crnToFmsGroup = convertGroupsToFmsGroups(\n-                grpcUmsClient.listAllGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n-        Map<WorkloadAdministrationGroup, FmsGroup> wags = convertWagsToFmsGroups(\n-                grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n-        List<String> requestedWorkloadUsernames = Streams.concat(\n-                users.stream().map(User::getWorkloadUsername),\n-                machineUsers.stream().map(MachineUser::getWorkloadUsername))\n-                .collect(Collectors.toList());\n-\n-        Map<String, UmsUsersState> umsUsersStateMap = new HashMap<>();\n-        environmentCrns.forEach(environmentCrn -> {\n-            UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                    .setWorkloadAdministrationGroups(wags.values());\n-            UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-            addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n-            addGroupsToUsersStateBuilder(usersStateBuilder, crnToFmsGroup.values());\n-            Set<String> wagNamesForOtherEnvironments =\n-                    addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n-\n-            EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n-            TriConsumer<String, FmsUser, List<CloudIdentity>> actorHandler =\n-                    (memberCrn, fmsUser, cloudIdentityList) -> {\n-                        try {\n-                            handleActor(umsUsersStateBuilder,\n-                                    usersStateBuilder,\n-                                    environmentAccessChecker.hasAccess(memberCrn, requestIdOptional),\n-                                    crnToFmsGroup,\n-                                    wagNamesForOtherEnvironments,\n-                                    fmsUser,\n-                                    () -> grpcUmsClient.listGroupsForMember(\n-                                            INTERNAL_ACTOR_CRN, accountId, memberCrn, requestIdOptional),\n-                                    () -> grpcUmsClient.listWorkloadAdministrationGroupsForMember(\n-                                            INTERNAL_ACTOR_CRN, memberCrn, requestIdOptional),\n-                                    () -> umsCredentialProvider.getCredentials(memberCrn, requestIdOptional),\n-                                    cloudIdentityList);\n-                        } catch (StatusRuntimeException e) {\n-                            // NOT_FOUND errors indicate that a user/machineUser has been deleted after we have\n-                            // retrieved the list of users/machineUsers from the UMS. Interrupt calculation of group\n-                            // membership.\n-                            if (e.getStatus().getCode() == Status.Code.NOT_FOUND) {\n-                                LOGGER.warn(\"Member CRN {} not found in UMS. Member will not be added to the UMS Users State. {}\",\n-                                        memberCrn, e.getLocalizedMessage());\n-                            } else {\n-                                throw e;\n-                            }\n-                        }\n-                    };\n-            users.forEach(u -> actorHandler.accept(u.getCrn(), Conversions.toFmsUser(u), u.getCloudIdentitiesList()));\n-            machineUsers.forEach(mu -> actorHandler.accept(mu.getCrn(), Conversions.toFmsUser(mu), mu.getCloudIdentitiesList()));\n-\n-            addServicePrinciplesCloudIdentities(\n-                    accountId, environmentCrn, umsUsersStateBuilder, requestIdOptional);\n-\n-            umsUsersStateBuilder.setUsersState(usersStateBuilder.build());\n-            umsUsersStateMap.put(environmentCrn, umsUsersStateBuilder.build());\n-        });\n-        return umsUsersStateMap;\n-    }\n-\n-    private void addActorsToUmsUsersStateBuilder(\n-            UmsUsersState.Builder umsUsersStateBuilder,\n-            UsersState.Builder usersStateBuilder,\n-            int environmentIndex,\n-            GetUserSyncStateModelResponse userSyncStateModel,\n-            Map<String, FmsGroup> crnToFmsGroup,\n-            Set<String> wagNamesForOtherEnvironments) {\n-\n-        // process actors - users and machine users are combined in the actor list\n-        userSyncStateModel.getActorList().stream().forEach(actor -> {\n-            RightsCheckResult rightsCheckResult = actor.getRightsCheckResult(environmentIndex);\n-            EnvironmentAccessRights environmentAccessRights = new EnvironmentAccessRights(\n-                    rightsCheckResult.getHasRight(0),\n-                    rightsCheckResult.getHasRight(1));\n-\n-            handleActor(umsUsersStateBuilder,\n-                    usersStateBuilder,\n-                    environmentAccessRights,\n-                    crnToFmsGroup,\n-                    wagNamesForOtherEnvironments,\n-                    Conversions.toFmsUser(actor.getActorDetails()),\n-                    () -> actor.getGroupIndexList().stream()\n-                            .map(groupIndex ->\n-                                    userSyncStateModel.getGroupList().get(groupIndex).getCrn())\n-                            .collect(Collectors.toList()),\n-                    () -> actor.getWorkloadAdministrationGroupIndexList().stream()\n-                            .map(wagIndex ->\n-                                    userSyncStateModel.getWorkloadAdministrationGroupList()\n-                                            .get(wagIndex).getWorkloadAdministrationGroupName())\n-                            .collect(Collectors.toList()),\n-                    () -> Conversions.toWorkloadCredential(actor.getCredentials()),\n-                    actor.getActorDetails().getCloudIdentityList());\n-        });\n-\n-    }\n-\n-    private void addRequestedWorkloadUsernames(\n-            UmsUsersState.Builder umsUsersStateBuilder, List<String> requestedWorkloadUsernames) {\n-        umsUsersStateBuilder.addAllRequestedWorkloadUsernames(requestedWorkloadUsernames);\n-    }\n-\n-    private void addGroupsToUsersStateBuilder(UsersState.Builder builder, Collection<FmsGroup> groups) {\n-        groups.forEach(builder::addGroup);\n-        // Add internal usersync group for each environment\n-        builder.addGroup(USERSYNC_INTERNAL_GROUP);\n-    }\n-\n-    private Set<String> addWagsToUsersStateBuilder(\n-            UsersState.Builder builder,\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags,\n-            String environmentCrn) {\n-        Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-        // Only add workload admin groups that belong to this environment.\n-        // At the same time, build a set of workload admin groups that are\n-        // associated with other environments so we can filter these out in\n-        // the per-user group listing in handleUser.\n-        wags.entrySet().forEach(wagEntry -> {\n-            WorkloadAdministrationGroup wag = wagEntry.getKey();\n-            String groupName = wag.getWorkloadAdministrationGroupName();\n-            if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                builder.addGroup(wagEntry.getValue());\n-            } else {\n-                Crn resourceCrn = getCrn(wag);\n-                if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                        && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                    wagNamesForOtherEnvironments.add(groupName);\n-                }\n-            }\n-        });\n-        return wagNamesForOtherEnvironments;\n-    }\n-\n-    private Map<String, FmsGroup> convertGroupsToFmsGroups(List<Group> groups) {\n-        return groups.stream().collect(Collectors.toMap(Group::getCrn, Conversions::umsGroupToGroup));\n-    }\n-\n-    private Map<WorkloadAdministrationGroup, FmsGroup> convertWagsToFmsGroups(List<WorkloadAdministrationGroup> wags) {\n-        return wags.stream()\n-                .collect(Collectors.toMap(wag -> wag, wag -> Conversions.nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-    }\n-\n-    private List<RightsCheck> generateRightsChecksForEnvironments(Collection<String> environmentCrns) {\n-        return environmentCrns.stream()\n-                .map(crn -> RightsCheck.newBuilder()\n-                        .setResourceCrn(crn)\n-                        .addAllRight(RIGHTS)\n-                        .build())\n-                .collect(Collectors.toList());\n-    }\n-\n-    private List<User> getUsers(String actorCrn, String accountId, Optional<String> requestIdOptional, boolean fullSync, Set<String> userCrns) {\n-        if (fullSync) {\n-            return grpcUmsClient.listAllUsers(actorCrn, accountId, requestIdOptional);\n-        } else if (!userCrns.isEmpty()) {\n-            return grpcUmsClient.listUsers(actorCrn, accountId, List.copyOf(userCrns), requestIdOptional);\n-        } else {\n-            return List.of();\n-        }\n-    }\n-\n-    private List<MachineUser> getMachineUsers(String actorCrn, String accountId, Optional<String> requestIdOptional,\n-        boolean fullSync, Set<String> machineUserCrns) {\n-        if (fullSync) {\n-            return grpcUmsClient.listAllMachineUsers(actorCrn, accountId,\n-                    INCLUDE_INTERNAL_MACHINE_USERS, requestIdOptional);\n-        } else if (!machineUserCrns.isEmpty()) {\n-            return grpcUmsClient.listMachineUsers(actorCrn, accountId, List.copyOf(machineUserCrns),\n-                    INCLUDE_INTERNAL_MACHINE_USERS, requestIdOptional);\n-        } else {\n-            return List.of();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"ParameterNumber\")\n-    private void handleActor(\n-            UmsUsersState.Builder umsUsersStateBuilder,\n-            UsersState.Builder usersStateBuilder,\n-            EnvironmentAccessRights environmentAccessRights,\n-            Map<String, FmsGroup> crnToFmsGroup,\n-            Set<String> wagNamesForOtherEnvironments,\n-            FmsUser fmsUser,\n-            Supplier<Collection<String>> groupCrnMembershipSupplier,\n-            Supplier<Collection<String>> wagMembershipSupplier,\n-            Supplier<WorkloadCredential> workloadCredentialSupplier,\n-            List<CloudIdentity> cloudIdentityList) {\n-\n-        if (environmentAccessRights.hasEnvironmentAccessRight()) {\n-            String workloadUsername = fmsUser.getName();\n-\n-            // Retrieve all information from UMS before modifying to the UmsUsersState or UsersState. This is so that\n-            // we don't partially modify the state if the member has been deleted after we started the sync\n-            Collection<String> groupCrnsForMember = groupCrnMembershipSupplier.get();\n-            Collection<String> workloadAdministrationGroupsForMember = wagMembershipSupplier.get();\n-            WorkloadCredential workloadCredential = workloadCredentialSupplier.get();\n-\n-            groupCrnsForMember.forEach(gcrn -> {\n-                FmsGroup group = crnToFmsGroup.get(gcrn);\n-                // If the group is null, then there has been a group membership change after we started the sync\n-                // the group and group membership will be updated on the next sync\n-                if (group != null) {\n-                    usersStateBuilder.addMemberToGroup(group.getName(), workloadUsername);\n-                } else {\n-                    LOGGER.warn(\"{} is a member of unexpected group {}. Group must have been added after UMS state calculation started\",\n-                            workloadUsername, gcrn);\n-                }\n-            });\n-            workloadAdministrationGroupsForMember.stream()\n-                    .filter(wagName -> !wagNamesForOtherEnvironments.contains(wagName))\n-                    .forEach(wagName -> {\n-                        usersStateBuilder.addGroup(Conversions.nameToGroup(wagName));\n-                        usersStateBuilder.addMemberToGroup(wagName, workloadUsername);\n-                    });\n-\n-            addMemberToInternalTrackingGroup(usersStateBuilder, workloadUsername);\n-            if (environmentAccessRights.hasAdminFreeIpaRight()) {\n-                usersStateBuilder.addMemberToGroup(UserSyncConstants.ADMINS_GROUP, workloadUsername);\n-            }\n-\n-            umsUsersStateBuilder.addWorkloadCredentials(workloadUsername, workloadCredential);\n-            umsUsersStateBuilder.addUserCloudIdentities(workloadUsername, cloudIdentityList);\n-            usersStateBuilder.addUser(fmsUser);\n-        }\n-    }\n-\n-    private void addServicePrinciplesCloudIdentities(\n-            String accountId, String environmentCrn,\n-            UmsUsersState.Builder builder, Optional<String> requestIdOptional) {\n-        List<ServicePrincipalCloudIdentities> servicePrincipalCloudIdentities =\n-                grpcUmsClient.listServicePrincipalCloudIdentities(INTERNAL_ACTOR_CRN, accountId, environmentCrn, requestIdOptional);\n-        builder.addServicePrincipalCloudIdentities(servicePrincipalCloudIdentities);\n-    }\n-\n-    private void addMemberToInternalTrackingGroup(UsersState.Builder usersStateBuilder, String username) {\n-        usersStateBuilder.addMemberToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP, username);\n-    }\n-\n-    private EnvironmentAccessChecker createEnvironmentAccessChecker(String environmentCrn) {\n-        requireNonNull(environmentCrn, \"environmentCrn is null\");\n-        return new EnvironmentAccessChecker(grpcUmsClient, umsRightProvider, environmentCrn);\n-    }\n-\n-    private Crn getCrn(WorkloadAdministrationGroup wag) {\n-        Crn resourceCrn = null;\n-        try {\n-            resourceCrn = Crn.fromString(wag.getResource());\n-        } catch (Exception e) {\n-            LOGGER.debug(\"Invalid resource is assigned to workload admin group: {}\", e.getMessage());\n-        }\n-        return resourceCrn;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"oid": "c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "url": "https://github.com/hortonworks/cloudbreak/commit/c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "message": "refactored ums users state provider into smaller pieces", "committedDate": "2020-09-21T15:32:59Z", "type": "forcePushed"}, {"oid": "4dff6ce4c28f7723eb8f4e50e4fcede872847d06", "url": "https://github.com/hortonworks/cloudbreak/commit/4dff6ce4c28f7723eb8f4e50e4fcede872847d06", "message": "refactored ums users state provider into smaller pieces", "committedDate": "2020-09-21T16:13:07Z", "type": "forcePushed"}, {"oid": "0927c027c9a1887a66f65822e2ea1c20c82a461d", "url": "https://github.com/hortonworks/cloudbreak/commit/0927c027c9a1887a66f65822e2ea1c20c82a461d", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement. The class has also been divided into\n  smaller, more focused classes.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests", "committedDate": "2020-09-22T05:51:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgwODg2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492808865", "bodyText": "so there is a EnvironmentRightChecksFactory, and I'm a bit confused at first blink which is which and why.", "author": "lacikaaa", "createdAt": "2020-09-22T15:03:10Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/EnvironmentsRightsChecksFactory.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.ums;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.sequenceiq.freeipa.service.freeipa.user.UserSyncConstants;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class EnvironmentsRightsChecksFactory {", "originalCommit": "0927c027c9a1887a66f65822e2ea1c20c82a461d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1NjAwNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492856007", "bodyText": "The two providers use different mechanisms to determine rights.\nThe default provider uses the RightChecks model to call the authorization service.\nthe bulk provider uses the RightsChecks model to call the user management service.\nIt's unfortunate that the two are not the same, and even more unfortunate that they are so similarly named.\nI can rename these classes to better indicate the auth vs ums difference.", "author": "handavid", "createdAt": "2020-09-22T16:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgwODg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkwNjYyNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492906624", "bodyText": "renamed to AuthorizationRightChecksFactory and UmsRightsChecksFactory", "author": "handavid", "createdAt": "2020-09-22T17:20:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgwODg2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "ec901f5240fce7cf22f5b20421fab4616dee6a69", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/EnvironmentsRightsChecksFactory.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/UmsRightsChecksFactory.java\nsimilarity index 93%\nrename from freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/EnvironmentsRightsChecksFactory.java\nrename to freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/UmsRightsChecksFactory.java\nindex 4146f804ed..f54ef48451 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/EnvironmentsRightsChecksFactory.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/UmsRightsChecksFactory.java\n\n@@ -8,7 +8,7 @@ import java.util.List;\n import java.util.stream.Collectors;\n \n @Component\n-public class EnvironmentsRightsChecksFactory {\n+public class UmsRightsChecksFactory {\n     public List<UserManagementProto.RightsCheck> get(List<String> environmentCrnsList) {\n         return environmentCrnsList.stream()\n                 .map(crn -> UserManagementProto.RightsCheck.newBuilder()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMTk3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492821977", "bodyText": "I don't think you need inject on constructor", "author": "lacikaaa", "createdAt": "2020-09-22T15:17:52Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/BulkUmsUsersStateProvider.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.ums;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.collect.Maps;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsGroupConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsUserConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.WorkloadCredentialConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.EnvironmentAccessRights;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.WorkloadCredential;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n+\n+@Component\n+public class BulkUmsUsersStateProvider extends BaseUmsUsersStateProvider {\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private EnvironmentsRightsChecksFactory environmentsRightsChecksFactory;\n+\n+    @Inject\n+    private FmsUserConverter fmsUserConverter;\n+\n+    @Inject\n+    private WorkloadCredentialConverter workloadCredentialConverter;\n+\n+    @Inject", "originalCommit": "0927c027c9a1887a66f65822e2ea1c20c82a461d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1NjMwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492856309", "bodyText": "ok. I'll try to inject directly into the base class.", "author": "handavid", "createdAt": "2020-09-22T16:02:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMTk3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ec901f5240fce7cf22f5b20421fab4616dee6a69", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/BulkUmsUsersStateProvider.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/BulkUmsUsersStateProvider.java\nindex ffc360f19d..9880b64f7d 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/BulkUmsUsersStateProvider.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/BulkUmsUsersStateProvider.java\n\n@@ -3,7 +3,6 @@ package com.sequenceiq.freeipa.service.freeipa.user.ums;\n import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n import com.google.common.collect.Maps;\n import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n-import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsGroupConverter;\n import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsUserConverter;\n import com.sequenceiq.freeipa.service.freeipa.user.conversion.WorkloadCredentialConverter;\n import com.sequenceiq.freeipa.service.freeipa.user.model.EnvironmentAccessRights;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMjYxNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492822616", "bodyText": "same here", "author": "lacikaaa", "createdAt": "2020-09-22T15:18:44Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.ums;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsGroupConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsUserConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.WorkloadCredential;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import org.apache.logging.log4j.util.TriConsumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n+import static java.util.Objects.requireNonNull;\n+\n+@Component\n+public class DefaultUmsUsersStateProvider extends BaseUmsUsersStateProvider {\n+    @VisibleForTesting\n+    static final boolean INCLUDE_INTERNAL_MACHINE_USERS = true;\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultUmsUsersStateProvider.class);\n+\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private EnvironmentAccessCheckerFactory environmentAccessCheckerFactory;\n+\n+    @Inject\n+    private UmsCredentialProvider umsCredentialProvider;\n+\n+    @Inject\n+    private FmsUserConverter fmsUserConverter;\n+\n+    @Inject", "originalCommit": "0927c027c9a1887a66f65822e2ea1c20c82a461d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkwNjczMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492906732", "bodyText": "done", "author": "handavid", "createdAt": "2020-09-22T17:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMjYxNg=="}], "type": "inlineReview", "revised_code": {"commit": "ec901f5240fce7cf22f5b20421fab4616dee6a69", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java\nindex 427dce834c..fef72e27db 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java\n\n@@ -4,7 +4,6 @@ import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.Streams;\n import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n-import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsGroupConverter;\n import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsUserConverter;\n import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMzgxOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492823819", "bodyText": "it's a bit strange to depend on something from a logging library which is not log related", "author": "lacikaaa", "createdAt": "2020-09-22T15:20:15Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.ums;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsGroupConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsUserConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.WorkloadCredential;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import org.apache.logging.log4j.util.TriConsumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n+import static java.util.Objects.requireNonNull;\n+\n+@Component\n+public class DefaultUmsUsersStateProvider extends BaseUmsUsersStateProvider {\n+    @VisibleForTesting\n+    static final boolean INCLUDE_INTERNAL_MACHINE_USERS = true;\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultUmsUsersStateProvider.class);\n+\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private EnvironmentAccessCheckerFactory environmentAccessCheckerFactory;\n+\n+    @Inject\n+    private UmsCredentialProvider umsCredentialProvider;\n+\n+    @Inject\n+    private FmsUserConverter fmsUserConverter;\n+\n+    @Inject\n+    public DefaultUmsUsersStateProvider(FmsGroupConverter fmsGroupConverter) {\n+        super(fmsGroupConverter);\n+    }\n+\n+    public Map<String, UmsUsersState> get(\n+            String accountId, String actorCrn,\n+            Collection<String> environmentCrns, Set<String> userCrns, Set<String> machineUserCrns,\n+            Optional<String> requestIdOptional, boolean fullSync) {\n+        List<UserManagementProto.User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n+        List<UserManagementProto.MachineUser> machineUsers =\n+                getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n+\n+        Map<String, FmsGroup> crnToFmsGroup = convertGroupsToFmsGroups(\n+                grpcUmsClient.listAllGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n+        Map<UserManagementProto.WorkloadAdministrationGroup, FmsGroup> wags = convertWagsToFmsGroups(\n+                grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n+        List<String> requestedWorkloadUsernames = Streams.concat(\n+                users.stream().map(UserManagementProto.User::getWorkloadUsername),\n+                machineUsers.stream().map(UserManagementProto.MachineUser::getWorkloadUsername))\n+                .collect(Collectors.toList());\n+\n+        Map<String, UmsUsersState> umsUsersStateMap = new HashMap<>();\n+        environmentCrns.forEach(environmentCrn -> {\n+            UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n+                    .setWorkloadAdministrationGroups(wags.values());\n+            UsersState.Builder usersStateBuilder = new UsersState.Builder();\n+\n+            addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n+            addGroupsToUsersStateBuilder(usersStateBuilder, crnToFmsGroup.values());\n+            Set<String> wagNamesForOtherEnvironments =\n+                    addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n+\n+            ActorHandler actorHandler = ActorHandler.newBuilder()\n+                    .withFmsGroupConverter(getFmsGroupConverter())\n+                    .withUmsUsersStateBuilder(umsUsersStateBuilder)\n+                    .withUsersStateBuilder(usersStateBuilder)\n+                    .withCrnToFmsGroup(crnToFmsGroup)\n+                    .withWagNamesForOtherEnvironments(wagNamesForOtherEnvironments)\n+                    .build();\n+            EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+            TriConsumer<String, FmsUser, List<UserManagementProto.CloudIdentity>> actorConsumer =\n+                    createActorConsumer(accountId, environmentAccessChecker, actorHandler, requestIdOptional);\n+            users.forEach(u -> actorConsumer.accept(u.getCrn(), fmsUserConverter.toFmsUser(u), u.getCloudIdentitiesList()));\n+            machineUsers.forEach(mu -> actorConsumer.accept(mu.getCrn(), fmsUserConverter.toFmsUser(mu), mu.getCloudIdentitiesList()));\n+\n+            addServicePrincipalsCloudIdentities(\n+                    umsUsersStateBuilder,\n+                    grpcUmsClient.listServicePrincipalCloudIdentities(\n+                            INTERNAL_ACTOR_CRN, accountId, environmentCrn, requestIdOptional));\n+\n+            umsUsersStateBuilder.setUsersState(usersStateBuilder.build());\n+            umsUsersStateMap.put(environmentCrn, umsUsersStateBuilder.build());\n+        });\n+        return umsUsersStateMap;\n+    }\n+\n+    private TriConsumer<String, FmsUser, List<UserManagementProto.CloudIdentity>> createActorConsumer(", "originalCommit": "0927c027c9a1887a66f65822e2ea1c20c82a461d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1NjczOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492856738", "bodyText": "I'll look for a replacement", "author": "handavid", "createdAt": "2020-09-22T16:03:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMzgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkwODEzMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492908132", "bodyText": "moved this into a addActorsToUmsUsersStateBuilder method to match the Bulk provider.\nI had this TriConsumer so that I could apply the same consumer to both the user and machine users. I switched it around and concat the users and machine users streams so I don't have to save the lambda.", "author": "handavid", "createdAt": "2020-09-22T17:23:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMzgxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ec901f5240fce7cf22f5b20421fab4616dee6a69", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java\nindex 427dce834c..fef72e27db 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java\n\n@@ -4,7 +4,6 @@ import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.Streams;\n import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n-import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsGroupConverter;\n import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsUserConverter;\n import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n"}}, {"oid": "ec901f5240fce7cf22f5b20421fab4616dee6a69", "url": "https://github.com/hortonworks/cloudbreak/commit/ec901f5240fce7cf22f5b20421fab4616dee6a69", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement. The class has also been divided into\n  smaller, more focused classes.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests", "committedDate": "2020-09-22T17:02:58Z", "type": "commit"}, {"oid": "ec901f5240fce7cf22f5b20421fab4616dee6a69", "url": "https://github.com/hortonworks/cloudbreak/commit/ec901f5240fce7cf22f5b20421fab4616dee6a69", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement. The class has also been divided into\n  smaller, more focused classes.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests", "committedDate": "2020-09-22T17:02:58Z", "type": "forcePushed"}]}