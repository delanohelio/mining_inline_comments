{"pr_number": 7345, "pr_title": "CDPCP-1291. Add support for retrieving a keytab in FMS", "pr_createdAt": "2020-02-20T21:34:01Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/7345", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMDg5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383500893", "bodyText": "I'm not too fond of the location of this file. I'd prefer it to reside closer to the service that will actually use it.", "author": "handavid", "createdAt": "2020-02-24T20:38:22Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcyNTEyMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383725120", "bodyText": "this definitely smells, please look for a better place", "author": "lacikaaa", "createdAt": "2020-02-25T08:34:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMDg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2NDI1NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384164254", "bodyText": "Ah sure let me find a better place (I've placed it here because KrbKeySetEncoder is here which plays an analogous role). I think we want to expose this as part of UserV1Endpoint and maybe add a UserKeytabGenService.", "author": "aarman-cloudera", "createdAt": "2020-02-25T22:26:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMDg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQxODY5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384418690", "bodyText": "that class is in a wrong package also IMHO", "author": "lacikaaa", "createdAt": "2020-02-26T10:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMDg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyODk4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384728987", "bodyText": "I gree that KrbKeySetEncoder is also in the wrong spot. I suggest com.sequenceiq.freeipa.service.freeipa.user.krb or com.sequenceiq.freeipa.service.freeipa.user.util", "author": "handavid", "createdAt": "2020-02-26T19:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMDg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NzUwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384767509", "bodyText": "Thanks, I'll move both of them.", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMDg5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java b/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\ndeleted file mode 100644\nindex 15c91da3d0..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\n+++ /dev/null\n\n@@ -1,54 +0,0 @@\n-package com.sequenceiq.freeipa.util;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n-import com.sequenceiq.cloudbreak.common.service.Clock;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n-import org.apache.directory.shared.kerberos.KerberosTime;\n-import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n-import org.apache.directory.shared.kerberos.components.EncryptionKey;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Component;\n-\n-import javax.inject.Inject;\n-import java.util.Base64;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-@Component\n-public final class KrbKeytabGenerator {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n-\n-    private static final int PRINCIPAL_TYPE_1 = 1;\n-\n-    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n-\n-    private static final byte KEY_VERSION_NUMBER_ZERO = 0;\n-\n-    @Inject\n-    private Clock clock;\n-\n-    private KeytabEntry toKeytabEntry(String user, String realm, ActorKerberosKey actorKerberosKey) {\n-        String principalName = user + '@' + realm;\n-\n-        EncryptionType encryptionType = EncryptionType.getTypeByValue(actorKerberosKey.getKeyType());\n-        byte[] key = Base64.getDecoder().decode(actorKerberosKey.getKeyValue());\n-        EncryptionKey encryptionKey = new EncryptionKey(encryptionType, key);\n-\n-        KerberosTime time = new KerberosTime(clock.getCurrentTimeMillis());\n-\n-        return new KeytabEntry(principalName, PRINCIPAL_TYPE_1, time, KEY_VERSION_NUMBER_ZERO, encryptionKey);\n-    }\n-\n-    public String generateKeytabBase64(String workloadUserName, String realm, List<ActorKerberosKey> actorKerberosKeys) {\n-        LOGGER.info(\"Generating keytab for workloadUserName = {} with realm = {}\", workloadUserName, realm);\n-        List<KeytabEntry> keytabEntries = actorKerberosKeys.stream()\n-                .map(key -> toKeytabEntry(workloadUserName, realm, key))\n-                .collect(Collectors.toList());\n-        KeytabEncoder writer = new KeytabEncoder();\n-        byte[] keytabBytes = writer.write(KEYTAB_VERSION_0X502, keytabEntries).array();\n-        return Base64.getEncoder().encodeToString(keytabBytes);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4OTg4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383589886", "bodyText": "verify/assert parameters?", "author": "giladwolff", "createdAt": "2020-02-25T00:14:04Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n+import org.apache.directory.shared.kerberos.KerberosTime;\n+import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n+import org.apache.directory.shared.kerberos.components.EncryptionKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public final class KrbKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n+\n+    private static final int PRINCIPAL_TYPE_1 = 1;\n+\n+    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n+\n+    private static final byte KEY_VERSION_NUMBER_ZERO = 0;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    private KeytabEntry toKeytabEntry(String user, String realm, ActorKerberosKey actorKerberosKey) {\n+        String principalName = user + '@' + realm;", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java b/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\ndeleted file mode 100644\nindex 15c91da3d0..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\n+++ /dev/null\n\n@@ -1,54 +0,0 @@\n-package com.sequenceiq.freeipa.util;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n-import com.sequenceiq.cloudbreak.common.service.Clock;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n-import org.apache.directory.shared.kerberos.KerberosTime;\n-import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n-import org.apache.directory.shared.kerberos.components.EncryptionKey;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Component;\n-\n-import javax.inject.Inject;\n-import java.util.Base64;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-@Component\n-public final class KrbKeytabGenerator {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n-\n-    private static final int PRINCIPAL_TYPE_1 = 1;\n-\n-    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n-\n-    private static final byte KEY_VERSION_NUMBER_ZERO = 0;\n-\n-    @Inject\n-    private Clock clock;\n-\n-    private KeytabEntry toKeytabEntry(String user, String realm, ActorKerberosKey actorKerberosKey) {\n-        String principalName = user + '@' + realm;\n-\n-        EncryptionType encryptionType = EncryptionType.getTypeByValue(actorKerberosKey.getKeyType());\n-        byte[] key = Base64.getDecoder().decode(actorKerberosKey.getKeyValue());\n-        EncryptionKey encryptionKey = new EncryptionKey(encryptionType, key);\n-\n-        KerberosTime time = new KerberosTime(clock.getCurrentTimeMillis());\n-\n-        return new KeytabEntry(principalName, PRINCIPAL_TYPE_1, time, KEY_VERSION_NUMBER_ZERO, encryptionKey);\n-    }\n-\n-    public String generateKeytabBase64(String workloadUserName, String realm, List<ActorKerberosKey> actorKerberosKeys) {\n-        LOGGER.info(\"Generating keytab for workloadUserName = {} with realm = {}\", workloadUserName, realm);\n-        List<KeytabEntry> keytabEntries = actorKerberosKeys.stream()\n-                .map(key -> toKeytabEntry(workloadUserName, realm, key))\n-                .collect(Collectors.toList());\n-        KeytabEncoder writer = new KeytabEncoder();\n-        byte[] keytabBytes = writer.write(KEYTAB_VERSION_0X502, keytabEntries).array();\n-        return Base64.getEncoder().encodeToString(keytabBytes);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MDEyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383590128", "bodyText": "This is the kvno? Add a comment?", "author": "giladwolff", "createdAt": "2020-02-25T00:14:55Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n+import org.apache.directory.shared.kerberos.KerberosTime;\n+import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n+import org.apache.directory.shared.kerberos.components.EncryptionKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public final class KrbKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n+\n+    private static final int PRINCIPAL_TYPE_1 = 1;\n+\n+    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n+\n+    private static final byte KEY_VERSION_NUMBER_ZERO = 0;", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3Njg4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384776887", "bodyText": "Added", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MDEyOA=="}], "type": "inlineReview", "revised_code": {"commit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java b/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\ndeleted file mode 100644\nindex 15c91da3d0..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\n+++ /dev/null\n\n@@ -1,54 +0,0 @@\n-package com.sequenceiq.freeipa.util;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n-import com.sequenceiq.cloudbreak.common.service.Clock;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n-import org.apache.directory.shared.kerberos.KerberosTime;\n-import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n-import org.apache.directory.shared.kerberos.components.EncryptionKey;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Component;\n-\n-import javax.inject.Inject;\n-import java.util.Base64;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-@Component\n-public final class KrbKeytabGenerator {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n-\n-    private static final int PRINCIPAL_TYPE_1 = 1;\n-\n-    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n-\n-    private static final byte KEY_VERSION_NUMBER_ZERO = 0;\n-\n-    @Inject\n-    private Clock clock;\n-\n-    private KeytabEntry toKeytabEntry(String user, String realm, ActorKerberosKey actorKerberosKey) {\n-        String principalName = user + '@' + realm;\n-\n-        EncryptionType encryptionType = EncryptionType.getTypeByValue(actorKerberosKey.getKeyType());\n-        byte[] key = Base64.getDecoder().decode(actorKerberosKey.getKeyValue());\n-        EncryptionKey encryptionKey = new EncryptionKey(encryptionType, key);\n-\n-        KerberosTime time = new KerberosTime(clock.getCurrentTimeMillis());\n-\n-        return new KeytabEntry(principalName, PRINCIPAL_TYPE_1, time, KEY_VERSION_NUMBER_ZERO, encryptionKey);\n-    }\n-\n-    public String generateKeytabBase64(String workloadUserName, String realm, List<ActorKerberosKey> actorKerberosKeys) {\n-        LOGGER.info(\"Generating keytab for workloadUserName = {} with realm = {}\", workloadUserName, realm);\n-        List<KeytabEntry> keytabEntries = actorKerberosKeys.stream()\n-                .map(key -> toKeytabEntry(workloadUserName, realm, key))\n-                .collect(Collectors.toList());\n-        KeytabEncoder writer = new KeytabEncoder();\n-        byte[] keytabBytes = writer.write(KEYTAB_VERSION_0X502, keytabEntries).array();\n-        return Base64.getEncoder().encodeToString(keytabBytes);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MDE5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383590192", "bodyText": "What is this principal type?", "author": "giladwolff", "createdAt": "2020-02-25T00:15:09Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n+import org.apache.directory.shared.kerberos.KerberosTime;\n+import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n+import org.apache.directory.shared.kerberos.components.EncryptionKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public final class KrbKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n+\n+    private static final int PRINCIPAL_TYPE_1 = 1;", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MTk2Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384771966", "bodyText": "This is goes away in my upcoming change that uses kerby-util package. Internally it will still set a name type of 1 meaning NT-PRINCIPAL, which is what we want I believe.\nI'm not sure how important this field is either ways, as per https://tools.ietf.org/html/rfc4120\n\"The name-type SHOULD be treated only as a hint to interpreting the meaning of a name.  It is not significant when checking for equivalence. Principal names that differ only in the name-type identify the same principal.\"", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:18:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MDE5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java b/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\ndeleted file mode 100644\nindex 15c91da3d0..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\n+++ /dev/null\n\n@@ -1,54 +0,0 @@\n-package com.sequenceiq.freeipa.util;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n-import com.sequenceiq.cloudbreak.common.service.Clock;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n-import org.apache.directory.shared.kerberos.KerberosTime;\n-import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n-import org.apache.directory.shared.kerberos.components.EncryptionKey;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Component;\n-\n-import javax.inject.Inject;\n-import java.util.Base64;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-@Component\n-public final class KrbKeytabGenerator {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n-\n-    private static final int PRINCIPAL_TYPE_1 = 1;\n-\n-    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n-\n-    private static final byte KEY_VERSION_NUMBER_ZERO = 0;\n-\n-    @Inject\n-    private Clock clock;\n-\n-    private KeytabEntry toKeytabEntry(String user, String realm, ActorKerberosKey actorKerberosKey) {\n-        String principalName = user + '@' + realm;\n-\n-        EncryptionType encryptionType = EncryptionType.getTypeByValue(actorKerberosKey.getKeyType());\n-        byte[] key = Base64.getDecoder().decode(actorKerberosKey.getKeyValue());\n-        EncryptionKey encryptionKey = new EncryptionKey(encryptionType, key);\n-\n-        KerberosTime time = new KerberosTime(clock.getCurrentTimeMillis());\n-\n-        return new KeytabEntry(principalName, PRINCIPAL_TYPE_1, time, KEY_VERSION_NUMBER_ZERO, encryptionKey);\n-    }\n-\n-    public String generateKeytabBase64(String workloadUserName, String realm, List<ActorKerberosKey> actorKerberosKeys) {\n-        LOGGER.info(\"Generating keytab for workloadUserName = {} with realm = {}\", workloadUserName, realm);\n-        List<KeytabEntry> keytabEntries = actorKerberosKeys.stream()\n-                .map(key -> toKeytabEntry(workloadUserName, realm, key))\n-                .collect(Collectors.toList());\n-        KeytabEncoder writer = new KeytabEncoder();\n-        byte[] keytabBytes = writer.write(KEYTAB_VERSION_0X502, keytabEntries).array();\n-        return Base64.getEncoder().encodeToString(keytabBytes);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MDM5NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383590395", "bodyText": "verify/assert parameters?", "author": "giladwolff", "createdAt": "2020-02-25T00:15:36Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n+import org.apache.directory.shared.kerberos.KerberosTime;\n+import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n+import org.apache.directory.shared.kerberos.components.EncryptionKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public final class KrbKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n+\n+    private static final int PRINCIPAL_TYPE_1 = 1;\n+\n+    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n+\n+    private static final byte KEY_VERSION_NUMBER_ZERO = 0;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    private KeytabEntry toKeytabEntry(String user, String realm, ActorKerberosKey actorKerberosKey) {\n+        String principalName = user + '@' + realm;\n+\n+        EncryptionType encryptionType = EncryptionType.getTypeByValue(actorKerberosKey.getKeyType());\n+        byte[] key = Base64.getDecoder().decode(actorKerberosKey.getKeyValue());\n+        EncryptionKey encryptionKey = new EncryptionKey(encryptionType, key);\n+\n+        KerberosTime time = new KerberosTime(clock.getCurrentTimeMillis());\n+\n+        return new KeytabEntry(principalName, PRINCIPAL_TYPE_1, time, KEY_VERSION_NUMBER_ZERO, encryptionKey);\n+    }\n+\n+    public String generateKeytabBase64(String workloadUserName, String realm, List<ActorKerberosKey> actorKerberosKeys) {\n+        LOGGER.info(\"Generating keytab for workloadUserName = {} with realm = {}\", workloadUserName, realm);", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java b/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\ndeleted file mode 100644\nindex 15c91da3d0..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\n+++ /dev/null\n\n@@ -1,54 +0,0 @@\n-package com.sequenceiq.freeipa.util;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n-import com.sequenceiq.cloudbreak.common.service.Clock;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n-import org.apache.directory.shared.kerberos.KerberosTime;\n-import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n-import org.apache.directory.shared.kerberos.components.EncryptionKey;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Component;\n-\n-import javax.inject.Inject;\n-import java.util.Base64;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-@Component\n-public final class KrbKeytabGenerator {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n-\n-    private static final int PRINCIPAL_TYPE_1 = 1;\n-\n-    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n-\n-    private static final byte KEY_VERSION_NUMBER_ZERO = 0;\n-\n-    @Inject\n-    private Clock clock;\n-\n-    private KeytabEntry toKeytabEntry(String user, String realm, ActorKerberosKey actorKerberosKey) {\n-        String principalName = user + '@' + realm;\n-\n-        EncryptionType encryptionType = EncryptionType.getTypeByValue(actorKerberosKey.getKeyType());\n-        byte[] key = Base64.getDecoder().decode(actorKerberosKey.getKeyValue());\n-        EncryptionKey encryptionKey = new EncryptionKey(encryptionType, key);\n-\n-        KerberosTime time = new KerberosTime(clock.getCurrentTimeMillis());\n-\n-        return new KeytabEntry(principalName, PRINCIPAL_TYPE_1, time, KEY_VERSION_NUMBER_ZERO, encryptionKey);\n-    }\n-\n-    public String generateKeytabBase64(String workloadUserName, String realm, List<ActorKerberosKey> actorKerberosKeys) {\n-        LOGGER.info(\"Generating keytab for workloadUserName = {} with realm = {}\", workloadUserName, realm);\n-        List<KeytabEntry> keytabEntries = actorKerberosKeys.stream()\n-                .map(key -> toKeytabEntry(workloadUserName, realm, key))\n-                .collect(Collectors.toList());\n-        KeytabEncoder writer = new KeytabEncoder();\n-        byte[] keytabBytes = writer.write(KEYTAB_VERSION_0X502, keytabEntries).array();\n-        return Base64.getEncoder().encodeToString(keytabBytes);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjAxNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383592015", "bodyText": "Are there any meaningful tests you want to bring from apache.directory?", "author": "giladwolff", "createdAt": "2020-02-25T00:21:08Z", "path": "freeipa/src/test/java/com/sequenceiq/freeipa/util/KrbKeyTabGeneratorTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MjgwMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384772803", "bodyText": "No longer needed.", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjAxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "chunk": "diff --git a/freeipa/src/test/java/com/sequenceiq/freeipa/util/KrbKeyTabGeneratorTest.java b/freeipa/src/test/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeyTabGeneratorTest.java\nsimilarity index 93%\nrename from freeipa/src/test/java/com/sequenceiq/freeipa/util/KrbKeyTabGeneratorTest.java\nrename to freeipa/src/test/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeyTabGeneratorTest.java\nindex aa14cb2cae..df0826ba11 100644\n--- a/freeipa/src/test/java/com/sequenceiq/freeipa/util/KrbKeyTabGeneratorTest.java\n+++ b/freeipa/src/test/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeyTabGeneratorTest.java\n\n@@ -1,4 +1,4 @@\n-package com.sequenceiq.freeipa.util;\n+package com.sequenceiq.freeipa.service.freeipa.user.krb;\n \n import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n import com.sequenceiq.cloudbreak.common.service.Clock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjMwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383592302", "bodyText": "So what is the apache license? Can we copy the code and use it/modify it as long as we have the copyright statement?", "author": "giladwolff", "createdAt": "2020-02-25T00:22:02Z", "path": "freeipa/src/main/java/org/apache/directory/shared/kerberos/components/EncryptionKey.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one\n+ *  or more contributor license agreements.  See the NOTICE file\n+ *  distributed with this work for additional information\n+ *  regarding copyright ownership.  The ASF licenses this file\n+ *  to you under the Apache License, Version 2.0 (the", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjYzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383592638", "bodyText": "I think I answered my own question by doing a git grep on thunderhead git repo. I think it's fine.", "author": "giladwolff", "createdAt": "2020-02-25T00:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MzM4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384773383", "bodyText": "Cool. I think all we need to do is just include the original license, and if we've modified the code we just put some Cloudera modification header.", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjMwMg=="}], "type": "inlineReview", "revised_code": {"commit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "chunk": "diff --git a/freeipa/src/main/java/org/apache/directory/shared/kerberos/components/EncryptionKey.java b/freeipa/src/main/java/org/apache/directory/shared/kerberos/components/EncryptionKey.java\ndeleted file mode 100644\nindex a3d6307f92..0000000000\n--- a/freeipa/src/main/java/org/apache/directory/shared/kerberos/components/EncryptionKey.java\n+++ /dev/null\n\n@@ -1,330 +0,0 @@\n-/*\n- *  Licensed to the Apache Software Foundation (ASF) under one\n- *  or more contributor license agreements.  See the NOTICE file\n- *  distributed with this work for additional information\n- *  regarding copyright ownership.  The ASF licenses this file\n- *  to you under the Apache License, Version 2.0 (the\n- *  \"License\"); you may not use this file except in compliance\n- *  with the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing,\n- *  software distributed under the License is distributed on an\n- *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- *  KIND, either express or implied.  See the License for the\n- *  specific language governing permissions and limitations\n- *  under the License.\n- *\n- */\n-package org.apache.directory.shared.kerberos.components;\n-\n-\n-import java.nio.BufferOverflowException;\n-import java.nio.ByteBuffer;\n-import java.security.MessageDigest;\n-import java.util.Arrays;\n-\n-import org.apache.directory.api.asn1.Asn1Object;\n-import org.apache.directory.api.asn1.EncoderException;\n-import org.apache.directory.api.asn1.ber.tlv.BerValue;\n-import org.apache.directory.api.asn1.ber.tlv.TLV;\n-import org.apache.directory.api.asn1.ber.tlv.UniversalTag;\n-import org.apache.directory.api.util.Strings;\n-import org.apache.directory.server.i18n.I18n;\n-import org.apache.directory.shared.kerberos.KerberosConstants;\n-import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-\n-/**\n- * A Kerberos symmetric encryption key, which includes metadata support for\n- * the associated key type and key version number.\n- *\n- * The ASN.1 description for this structure is :\n- * <pre>\n- * EncryptionKey   ::= SEQUENCE {\n- *       keytype         [0] Int32 -- actually encryption type --,\n- *       keyvalue        [1] OCTET STRING\n- * }\n- * </pre>\n- * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n- */\n-public class EncryptionKey implements Asn1Object\n-{\n-    /** The logger */\n-    private static final Logger log = LoggerFactory.getLogger( EncryptionKey.class );\n-\n-    /** Speedup for logs */\n-    private static final boolean IS_DEBUG = log.isDebugEnabled();\n-\n-    /** The encryption type */\n-    private EncryptionType keyType;\n-\n-    /** The encrypted value */\n-    private byte[] keyValue;\n-\n-    /** The key version */\n-    private int keyVersion;\n-\n-    // Storage for computed lengths\n-    private int keyTypeLength;\n-    private int keyValueLength;\n-    private int encryptionKeyLength;\n-\n-\n-    /**\n-     * Creates a new instance of EncryptionKey.\n-     */\n-    public EncryptionKey()\n-    {\n-    }\n-\n-\n-    /**\n-     * Creates a new instance of EncryptionKey.\n-     *\n-     * @param keyType The encryptionType\n-     * @param keyValue The value\n-     */\n-    public EncryptionKey( EncryptionType keyType, byte[] keyValue )\n-    {\n-        this.keyType = keyType;\n-        this.keyValue = keyValue;\n-    }\n-\n-\n-    /**\n-     * Creates a new instance of EncryptionKey.\n-     *\n-     * @param keyType The encryptionType\n-     * @param keyValue The value\n-     * @param keyVersion ???\n-     */\n-    public EncryptionKey( EncryptionType keyType, byte[] keyValue, int keyVersion )\n-    {\n-        this.keyType = keyType;\n-        this.keyValue = keyValue;\n-        this.keyVersion = keyVersion;\n-    }\n-\n-\n-    /**\n-     * Destroys this key by overwriting the symmetric key material with zeros.\n-     */\n-    public synchronized void destroy()\n-    {\n-        if ( keyValue != null )\n-        {\n-            Arrays.fill( keyValue, ( byte ) 0x00 );\n-        }\n-    }\n-\n-\n-    /**\n-     * Returns the key type.\n-     *\n-     * @return The key type.\n-     */\n-    public EncryptionType getKeyType()\n-    {\n-        return keyType;\n-    }\n-\n-\n-    /**\n-     * Set the encryption type\n-     * @param keyType The encryption type\n-     */\n-    public void setKeyType( EncryptionType keyType )\n-    {\n-        this.keyType = keyType;\n-    }\n-\n-\n-    /**\n-     * Returns the key value.\n-     *\n-     * @return The key value.\n-     */\n-    public byte[] getKeyValue()\n-    {\n-        return keyValue;\n-    }\n-\n-\n-    /**\n-     * Returns the key version.\n-     *\n-     * @return The key version.\n-     */\n-    public int getKeyVersion()\n-    {\n-        return keyVersion;\n-    }\n-\n-\n-    /**\n-     * Set the key value\n-     * @param keyVersion The key version\n-     */\n-    public void setKeyVersion( int keyVersion )\n-    {\n-        this.keyVersion = keyVersion;\n-    }\n-\n-\n-    /**\n-     * Set the key value\n-     * @param keyValue The key value\n-     */\n-    public void setKeyValue( byte[] keyValue )\n-    {\n-        this.keyValue = keyValue;\n-    }\n-\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public int hashCode()\n-    {\n-        int hash = 37;\n-        hash = hash * 17 + keyType.hashCode();\n-        hash = hash * 17 + Arrays.hashCode( keyValue );\n-\n-        return hash;\n-    }\n-\n-\n-    /**\n-     * @see Object#equals(Object)\n-     */\n-    @Override\n-    public boolean equals( Object o )\n-    {\n-        if ( this == o )\n-        {\n-            return true;\n-        }\n-\n-        if ( !( o instanceof EncryptionKey ) )\n-        {\n-            return false;\n-        }\n-\n-        EncryptionKey that = ( EncryptionKey ) o;\n-        return ( this.keyType == that.keyType ) && ( MessageDigest.isEqual( this.keyValue, that.keyValue ) );\n-    }\n-\n-\n-    /**\n-     * Compute the EncryptionKey length\n-     * <pre>\n-     * EncryptionKey :\n-     *\n-     * 0x30 L1 EncryptionKey\n-     *  |\n-     *  +--&gt; 0xA0 L2 keyType tag\n-     *  |     |\n-     *  |     +--&gt; 0x02 L2-1 keyType (int)\n-     *  |\n-     *  +--&gt; 0xA1 L3 keyValue tag\n-     *        |\n-     *        +--&gt; 0x04 L3-1 keyValue (OCTET STRING)\n-     *\n-     *  where L1 = L2 + lenght(0xA0) + length(L2) +\n-     *             L3 + lenght(0xA1) + length(L3)\n-     *  and\n-     *  L2 = L2-1 + length(0x02) + length( L2-1)\n-     *  L3 = L3-1 + length(0x04) + length( L3-1)\n-     *  </pre>\n-     */\n-    public int computeLength()\n-    {\n-        // Compute the keyType. The Length will always be cobntained in 1 byte\n-        keyTypeLength = 1 + 1 + BerValue.getNbBytes( keyType.getValue() );\n-        encryptionKeyLength = 1 + TLV.getNbBytes( keyTypeLength ) + keyTypeLength;\n-\n-        // Compute the keyValue\n-        if ( keyValue == null )\n-        {\n-            keyValueLength = 1 + 1;\n-        }\n-        else\n-        {\n-            keyValueLength = 1 + TLV.getNbBytes( keyValue.length ) + keyValue.length;\n-        }\n-\n-        encryptionKeyLength += 1 + TLV.getNbBytes( keyValueLength ) + keyValueLength;\n-\n-        // Compute the whole sequence length\n-        return 1 + BerValue.getNbBytes( encryptionKeyLength ) + encryptionKeyLength;\n-    }\n-\n-\n-    /**\n-     * Encode the EncryptionKey message to a PDU.\n-     * <pre>\n-     * EncryptionKey :\n-     *\n-     * 0x30 LL\n-     *   0xA0 LL\n-     *     0x02 0x01 keyType\n-     *   0xA1 LL\n-     *     0x04 LL keyValue\n-     * </pre>\n-     * @param buffer The buffer where to put the PDU. It should have been allocated\n-     * before, with the right size.\n-     * @return The constructed PDU.\n-     */\n-    public ByteBuffer encode( ByteBuffer buffer ) throws EncoderException\n-    {\n-        if ( buffer == null )\n-        {\n-            throw new EncoderException( I18n.err( I18n.ERR_148 ) );\n-        }\n-\n-        try\n-        {\n-            // The EncryptionKey SEQ Tag\n-            buffer.put( UniversalTag.SEQUENCE.getValue() );\n-            buffer.put( TLV.getBytes( encryptionKeyLength ) );\n-\n-            // The keyType, first the tag, then the value\n-            buffer.put( ( byte ) KerberosConstants.ENCRYPTION_KEY_TYPE_TAG );\n-            buffer.put( TLV.getBytes( keyTypeLength ) );\n-            BerValue.encode( buffer, keyType.getValue() );\n-\n-            // The keyValue, first the tag, then the value\n-            buffer.put( ( byte ) KerberosConstants.ENCRYPTION_KEY_VALUE_TAG );\n-            buffer.put( TLV.getBytes( keyValueLength ) );\n-            BerValue.encode( buffer, keyValue );\n-        }\n-        catch ( BufferOverflowException boe )\n-        {\n-            log.error( I18n.err( I18n.ERR_142, 1 + TLV.getNbBytes( encryptionKeyLength )\n-                    + encryptionKeyLength, buffer.capacity() ) );\n-            throw new EncoderException( I18n.err( I18n.ERR_138 ), boe );\n-        }\n-\n-        if ( IS_DEBUG )\n-        {\n-            log.debug( \"EncryptionKey encoding : {}\", Strings.dumpBytes( buffer.array() ) );\n-            log.debug( \"EncryptionKey initial value : {}\", this );\n-        }\n-\n-        return buffer;\n-    }\n-\n-\n-    /**\n-     * @see Object#toString()\n-     */\n-    public String toString()\n-    {\n-        return keyType.toString() + \" (\" + keyType.getValue() + \")\";\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcyNTIxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383725218", "bodyText": "where is this class used?", "author": "lacikaaa", "createdAt": "2020-02-25T08:34:24Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n+import org.apache.directory.shared.kerberos.KerberosTime;\n+import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n+import org.apache.directory.shared.kerberos.components.EncryptionKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public final class KrbKeytabGenerator {", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3Mzc4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384773783", "bodyText": "The functionality will be exposed as a public endpoint in a follow-on commit.", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcyNTIxOA=="}], "type": "inlineReview", "revised_code": {"commit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java b/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\ndeleted file mode 100644\nindex 15c91da3d0..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\n+++ /dev/null\n\n@@ -1,54 +0,0 @@\n-package com.sequenceiq.freeipa.util;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n-import com.sequenceiq.cloudbreak.common.service.Clock;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n-import org.apache.directory.shared.kerberos.KerberosTime;\n-import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n-import org.apache.directory.shared.kerberos.components.EncryptionKey;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Component;\n-\n-import javax.inject.Inject;\n-import java.util.Base64;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-@Component\n-public final class KrbKeytabGenerator {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n-\n-    private static final int PRINCIPAL_TYPE_1 = 1;\n-\n-    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n-\n-    private static final byte KEY_VERSION_NUMBER_ZERO = 0;\n-\n-    @Inject\n-    private Clock clock;\n-\n-    private KeytabEntry toKeytabEntry(String user, String realm, ActorKerberosKey actorKerberosKey) {\n-        String principalName = user + '@' + realm;\n-\n-        EncryptionType encryptionType = EncryptionType.getTypeByValue(actorKerberosKey.getKeyType());\n-        byte[] key = Base64.getDecoder().decode(actorKerberosKey.getKeyValue());\n-        EncryptionKey encryptionKey = new EncryptionKey(encryptionType, key);\n-\n-        KerberosTime time = new KerberosTime(clock.getCurrentTimeMillis());\n-\n-        return new KeytabEntry(principalName, PRINCIPAL_TYPE_1, time, KEY_VERSION_NUMBER_ZERO, encryptionKey);\n-    }\n-\n-    public String generateKeytabBase64(String workloadUserName, String realm, List<ActorKerberosKey> actorKerberosKeys) {\n-        LOGGER.info(\"Generating keytab for workloadUserName = {} with realm = {}\", workloadUserName, realm);\n-        List<KeytabEntry> keytabEntries = actorKerberosKeys.stream()\n-                .map(key -> toKeytabEntry(workloadUserName, realm, key))\n-                .collect(Collectors.toList());\n-        KeytabEncoder writer = new KeytabEncoder();\n-        byte[] keytabBytes = writer.write(KEYTAB_VERSION_0X502, keytabEntries).array();\n-        return Base64.getEncoder().encodeToString(keytabBytes);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcyNTcwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383725701", "bodyText": "these variables need more meaningful name, or if it's really necessary add comments please", "author": "lacikaaa", "createdAt": "2020-02-25T08:35:24Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n+import org.apache.directory.shared.kerberos.KerberosTime;\n+import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n+import org.apache.directory.shared.kerberos.components.EncryptionKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public final class KrbKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n+\n+    private static final int PRINCIPAL_TYPE_1 = 1;\n+\n+    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n+\n+    private static final byte KEY_VERSION_NUMBER_ZERO = 0;", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NDM3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384774379", "bodyText": "Next commit gets rid of some of these variables (internally they still get these values). I've added a comment about key version number.", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcyNTcwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java b/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\ndeleted file mode 100644\nindex 15c91da3d0..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java\n+++ /dev/null\n\n@@ -1,54 +0,0 @@\n-package com.sequenceiq.freeipa.util;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n-import com.sequenceiq.cloudbreak.common.service.Clock;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n-import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n-import org.apache.directory.shared.kerberos.KerberosTime;\n-import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n-import org.apache.directory.shared.kerberos.components.EncryptionKey;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Component;\n-\n-import javax.inject.Inject;\n-import java.util.Base64;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-@Component\n-public final class KrbKeytabGenerator {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n-\n-    private static final int PRINCIPAL_TYPE_1 = 1;\n-\n-    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n-\n-    private static final byte KEY_VERSION_NUMBER_ZERO = 0;\n-\n-    @Inject\n-    private Clock clock;\n-\n-    private KeytabEntry toKeytabEntry(String user, String realm, ActorKerberosKey actorKerberosKey) {\n-        String principalName = user + '@' + realm;\n-\n-        EncryptionType encryptionType = EncryptionType.getTypeByValue(actorKerberosKey.getKeyType());\n-        byte[] key = Base64.getDecoder().decode(actorKerberosKey.getKeyValue());\n-        EncryptionKey encryptionKey = new EncryptionKey(encryptionType, key);\n-\n-        KerberosTime time = new KerberosTime(clock.getCurrentTimeMillis());\n-\n-        return new KeytabEntry(principalName, PRINCIPAL_TYPE_1, time, KEY_VERSION_NUMBER_ZERO, encryptionKey);\n-    }\n-\n-    public String generateKeytabBase64(String workloadUserName, String realm, List<ActorKerberosKey> actorKerberosKeys) {\n-        LOGGER.info(\"Generating keytab for workloadUserName = {} with realm = {}\", workloadUserName, realm);\n-        List<KeytabEntry> keytabEntries = actorKerberosKeys.stream()\n-                .map(key -> toKeytabEntry(workloadUserName, realm, key))\n-                .collect(Collectors.toList());\n-        KeytabEncoder writer = new KeytabEncoder();\n-        byte[] keytabBytes = writer.write(KEYTAB_VERSION_0X502, keytabEntries).array();\n-        return Base64.getEncoder().encodeToString(keytabBytes);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzczOTQ0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383739444", "bodyText": "it looks like to me there is only 1 happy path tested. Are you sure there isn't anything which can go wrong here? Like a parameter is wrong", "author": "lacikaaa", "createdAt": "2020-02-25T09:02:08Z", "path": "freeipa/src/test/java/com/sequenceiq/freeipa/util/KrbKeyTabGeneratorTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class KrbKeyTabGeneratorTest {\n+\n+    private static final long MOCK_TIME = 1576171731141L;\n+\n+    @InjectMocks\n+    KrbKeytabGenerator underTest;\n+\n+    @Mock\n+    private Clock clock;\n+\n+    @Test\n+    void testGenerateKeytabBase64() {", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NDk4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384774989", "bodyText": "I think there's some more validation (i.e. has to be a valid workload user) we can add, but it might be at a higher level.", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzczOTQ0NA=="}], "type": "inlineReview", "revised_code": {"commit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "chunk": "diff --git a/freeipa/src/test/java/com/sequenceiq/freeipa/util/KrbKeyTabGeneratorTest.java b/freeipa/src/test/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeyTabGeneratorTest.java\nsimilarity index 93%\nrename from freeipa/src/test/java/com/sequenceiq/freeipa/util/KrbKeyTabGeneratorTest.java\nrename to freeipa/src/test/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeyTabGeneratorTest.java\nindex aa14cb2cae..df0826ba11 100644\n--- a/freeipa/src/test/java/com/sequenceiq/freeipa/util/KrbKeyTabGeneratorTest.java\n+++ b/freeipa/src/test/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeyTabGeneratorTest.java\n\n@@ -1,4 +1,4 @@\n-package com.sequenceiq.freeipa.util;\n+package com.sequenceiq.freeipa.service.freeipa.user.krb;\n \n import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n import com.sequenceiq.cloudbreak.common.service.Clock;\n"}}, {"oid": "aff2bd274d662265b21fcb38d535f03b3930f67e", "url": "https://github.com/hortonworks/cloudbreak/commit/aff2bd274d662265b21fcb38d535f03b3930f67e", "message": "CDPCP-1522. Add support for generating keytab from actor kerberos key\n\nA KrbKeytabGenerator class has been added that allows generating\na kerberos keytab by using the keys within ActorKerberosKey's.\nThis pulls in kerb-utils dependency from the Apache Kerby project\nwhich contains the classes needed to encode the principal and\nkeys into the keytab format. In addition KrbKeySetEncoder which\ndoes something similar has been moved under the same package.\n\nThis functionality of this class will be exposed as an api endpoint\nin a follow-on commit.", "committedDate": "2020-02-26T21:04:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNDg3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385004875", "bodyText": "Not a big deal, but could you drop krb in favor of kerberos? I think the package should be user.kerberos and the class name UserKeytabGenerator. This would reflect more of it's purpose in my opinion.", "author": "lacikaaa", "createdAt": "2020-02-27T09:29:29Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.krb;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.kerby.kerberos.kerb.keytab.Keytab;\n+import org.apache.kerby.kerberos.kerb.keytab.KeytabEntry;\n+import org.apache.kerby.kerberos.kerb.type.KerberosTime;\n+import org.apache.kerby.kerberos.kerb.type.base.EncryptionKey;\n+import org.apache.kerby.kerberos.kerb.type.base.EncryptionType;\n+import org.apache.kerby.kerberos.kerb.type.base.PrincipalName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Kerberos keytab generator - This class is repsonsible for generating a keytab using existing keys\n+ * belonging to an actor in User Management Service.\n+ */\n+@Component\n+public final class KrbKeytabGenerator {", "originalCommit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3ODI1Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385978257", "bodyText": "Done.", "author": "aarman-cloudera", "createdAt": "2020-02-29T00:17:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNDg3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "a754e4a9b0330ce3840214f1babed1e87c1de9a9", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeytabGenerator.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/UserKeytabGenerator.java\nsimilarity index 91%\nrename from freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeytabGenerator.java\nrename to freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/UserKeytabGenerator.java\nindex 3c6fb62696..d15acb078b 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeytabGenerator.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/UserKeytabGenerator.java\n\n@@ -1,4 +1,4 @@\n-package com.sequenceiq.freeipa.service.freeipa.user.krb;\n+package com.sequenceiq.freeipa.service.freeipa.user.kerberos;\n \n import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n import com.sequenceiq.cloudbreak.common.service.Clock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNjMzNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385006334", "bodyText": "I see one try without catch, so my concern is if something goes wrong in this code, maybe we would like to convert it to a custom exception a propagate it upwards in that format. What do you think about it?", "author": "lacikaaa", "createdAt": "2020-02-27T09:32:04Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.krb;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.kerby.kerberos.kerb.keytab.Keytab;\n+import org.apache.kerby.kerberos.kerb.keytab.KeytabEntry;\n+import org.apache.kerby.kerberos.kerb.type.KerberosTime;\n+import org.apache.kerby.kerberos.kerb.type.base.EncryptionKey;\n+import org.apache.kerby.kerberos.kerb.type.base.EncryptionType;\n+import org.apache.kerby.kerberos.kerb.type.base.PrincipalName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Kerberos keytab generator - This class is repsonsible for generating a keytab using existing keys\n+ * belonging to an actor in User Management Service.\n+ */\n+@Component\n+public final class KrbKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n+\n+    // For the key version number (kvno) in the keytab entries, we use a value of 0. Based on\n+    // expirementiation we've found that for user principles, keytab entries with kvno of zero\n+    // works fine, regardless of what the actual key versions are set in the KDC / Directory Server.\n+    private static final int KEY_VERSION_NUMBER_ZERO = 0;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    private KeytabEntry toKeytabEntry(String user, String realm, ActorKerberosKey actorKerberosKey) {\n+        requireNonNull(user, \"user must not be null\");\n+        requireNonNull(realm, \"realm must not be null\");\n+        requireNonNull(actorKerberosKey, \"actorKerberosKey must not be null\");\n+\n+        PrincipalName principalName = new PrincipalName(user + '@' + realm);\n+\n+        EncryptionType encryptionType = EncryptionType.fromValue(actorKerberosKey.getKeyType());\n+        byte[] key = Base64.getDecoder().decode(actorKerberosKey.getKeyValue());\n+        EncryptionKey encryptionKey = new EncryptionKey(encryptionType, key);\n+\n+        KerberosTime time = new KerberosTime(clock.getCurrentTimeMillis());\n+\n+        return new KeytabEntry(principalName, time, KEY_VERSION_NUMBER_ZERO, encryptionKey);\n+    }\n+\n+    public String generateKeytabBase64(String username, String realm, List<ActorKerberosKey> actorKerberosKeys) throws IOException {", "originalCommit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3ODIwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385978206", "bodyText": "That catch for this would be an IOException. I highly doubt we hit the exception here since it's not actually doing file / network IO. I have added a check for this in the service that calls this function, see updated PR.", "author": "aarman-cloudera", "createdAt": "2020-02-29T00:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNjMzNA=="}], "type": "inlineReview", "revised_code": {"commit": "a754e4a9b0330ce3840214f1babed1e87c1de9a9", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeytabGenerator.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/UserKeytabGenerator.java\nsimilarity index 91%\nrename from freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeytabGenerator.java\nrename to freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/UserKeytabGenerator.java\nindex 3c6fb62696..d15acb078b 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeytabGenerator.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/UserKeytabGenerator.java\n\n@@ -1,4 +1,4 @@\n-package com.sequenceiq.freeipa.service.freeipa.user.krb;\n+package com.sequenceiq.freeipa.service.freeipa.user.kerberos;\n \n import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n import com.sequenceiq.cloudbreak.common.service.Clock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwODAzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385008038", "bodyText": "I think we need test for those non null checks at least.\nCould you come up with any scenario where other part of the code breaks? I mean a lot static calls are used so this is not easy to test, but what if ActorKerberosKey holds wrong value, or the username holds the whole principal. I think we should cover some unhappy path here.", "author": "lacikaaa", "createdAt": "2020-02-27T09:35:08Z", "path": "freeipa/src/test/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeyTabGeneratorTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.krb;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class KrbKeyTabGeneratorTest {", "originalCommit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3ODQ0Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385978447", "bodyText": "Added some null tests and a test for empty key list. As for the other unhappy paths, I don't think it's worth testing at this layer. A user won't provide any of these inputs directly. We pull the keys and username off of UMS and the realm will be pulled from kerberos config. I've updated the PR with the actual service that uses this component. Please see updated PR.", "author": "aarman-cloudera", "createdAt": "2020-02-29T00:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwODAzOA=="}], "type": "inlineReview", "revised_code": {"commit": "a754e4a9b0330ce3840214f1babed1e87c1de9a9", "chunk": "diff --git a/freeipa/src/test/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeyTabGeneratorTest.java b/freeipa/src/test/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeyTabGeneratorTest.java\ndeleted file mode 100644\nindex df0826ba11..0000000000\n--- a/freeipa/src/test/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeyTabGeneratorTest.java\n+++ /dev/null\n\n@@ -1,57 +0,0 @@\n-package com.sequenceiq.freeipa.service.freeipa.user.krb;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n-import com.sequenceiq.cloudbreak.common.service.Clock;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import org.mockito.InjectMocks;\n-import org.mockito.Mock;\n-import org.mockito.junit.jupiter.MockitoExtension;\n-\n-import java.io.IOException;\n-import java.util.List;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.mockito.Mockito.when;\n-\n-@ExtendWith(MockitoExtension.class)\n-public class KrbKeyTabGeneratorTest {\n-\n-    private static final long MOCK_TIME = 1576171731141L;\n-\n-    @InjectMocks\n-    KrbKeytabGenerator underTest;\n-\n-    @Mock\n-    private Clock clock;\n-\n-    @Test\n-    void testGenerateKeytabBase64() throws IOException {\n-        String userName = \"csso_testuser\";\n-        String realm = \"TESTREALM-AWS.XCU2-8Y8X.DEV.CLDR.WORK\";\n-\n-        ActorKerberosKey key17 = ActorKerberosKey.newBuilder()\n-                .setKeyType(17)\n-                .setKeyValue(\"fRq3DlywzqVgH/zbJDXuXw==\")\n-                .setSaltType(4)\n-                .setSaltValue(\"HfSH3pSI7Sw8OzZK\")\n-                .build();\n-        ActorKerberosKey key18 = ActorKerberosKey.newBuilder()\n-                .setKeyType(18)\n-                .setKeyValue(\"613hgEgwn5f/9bH29FGOT4lBc6bCs9XBStAeBHeJB+w=\")\n-                .setSaltType(4)\n-                .setSaltValue(\"x5Ffi1dg2KGeCBPX\")\n-                .build();\n-\n-        when(clock.getCurrentTimeMillis()).thenReturn(MOCK_TIME);\n-\n-        String keytabBase64 = underTest.generateKeytabBase64(userName, realm, List.of(key17, key18));\n-\n-        String expectedKeytab = \"BQIAAABVAAEAJVRFU1RSRUFMTS1BV1MuWENVMi04WThYLkRFVi5DTERSLldPUksADWNz\" +\n-                \"c29fdGVzdHVzZXIAAAABXfJ40wAAEQAQfRq3DlywzqVgH/zbJDXuXwAAAGUAAQAlVEVTVFJFQUxNLUFXUy5Y\" +\n-                \"Q1UyLThZOFguREVWLkNMRFIuV09SSwANY3Nzb190ZXN0dXNlcgAAAAFd8njTAAASACDrXeGASDCfl//1sfb0\" +\n-                \"UY5PiUFzpsKz1cFK0B4Ed4kH7A==\";\n-\n-        assertEquals(expectedKeytab, keytabBase64);\n-    }\n-}\n"}}, {"oid": "a754e4a9b0330ce3840214f1babed1e87c1de9a9", "url": "https://github.com/hortonworks/cloudbreak/commit/a754e4a9b0330ce3840214f1babed1e87c1de9a9", "message": "CDPCP-1539. Expose api endpoint to retrieve / generate keys for an actor\n\nThis exposes a new endpoint in FreeIPA service to retrieve a keytab\nfor an actor under an environment.", "committedDate": "2020-02-29T00:11:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NjM4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385986384", "bodyText": "'the calling has' -> 'the calling user has'", "author": "aarman-cloudera", "createdAt": "2020-02-29T01:13:50Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -98,6 +102,19 @@ public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    public String getKeytab(@NotNull String environmentCrn, String targetUserCrn) {\n+        String callerUserCrn = checkUserCrn();\n+        LOGGER.debug(\"getKeytab() request for environmentCrn={}, callerUserCrn={}, targetUserCrn={}\", environmentCrn, callerUserCrn, targetUserCrn);\n+        // TODO For now, we ignore the optional targetUserCrn and only allow retrieving keytab for the calling user. When\n+        //      we later enable this, we need to make sure that the calling has the necessary authorization / right to get", "originalCommit": "a754e4a9b0330ce3840214f1babed1e87c1de9a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00189074cc3555868cda818d9d3e1a80764ceab8", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java b/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\nindex 54fc39344c..31cdc4598f 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\n\n@@ -107,9 +116,9 @@ public class UserV1Controller implements UserV1Endpoint {\n         String callerUserCrn = checkUserCrn();\n         LOGGER.debug(\"getKeytab() request for environmentCrn={}, callerUserCrn={}, targetUserCrn={}\", environmentCrn, callerUserCrn, targetUserCrn);\n         // TODO For now, we ignore the optional targetUserCrn and only allow retrieving keytab for the calling user. When\n-        //      we later enable this, we need to make sure that the calling has the necessary authorization / right to get\n+        //      we later enable this, we need to make sure that the calling user has the necessary authorization / right to get\n         //      keytab for another user.\n-        if (targetUserCrn != null) {\n+        if (targetUserCrn != null && !callerUserCrn.equals(targetUserCrn)) {\n             throw new BadRequestException(\"Retrieving a keytab for another user is not yet supported\");\n         }\n         return userKeytabService.getKeytabBase64(callerUserCrn, environmentCrn);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r386863709", "bodyText": "I think this should be in KerberosMgmtV1Endpoint. What do you think @handavid ?", "author": "lacikaaa", "createdAt": "2020-03-03T08:33:33Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/UserV1Endpoint.java", "diffHunk": "@@ -52,4 +52,11 @@\n     @ApiOperation(value = UserOperationDescriptions.SYNC_OPERATION_STATUS, notes = UserNotes.USER_NOTES, produces = MediaType.APPLICATION_JSON,\n             nickname = \"getSyncOperationStatusV1\")\n     SyncOperationStatus getSyncOperationStatus(@NotNull @QueryParam(\"operationId\") String operationId);\n+\n+    @GET\n+    @Path(\"getKeytab\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = UserOperationDescriptions.GET_KEYTAB, notes = UserNotes.USER_NOTES, produces = MediaType.APPLICATION_JSON,\n+            nickname = \"getKeytabV1\")\n+    String getKeytab(@NotNull @QueryParam(\"environment\") String environment, @QueryParam(\"user\") String user);", "originalCommit": "a754e4a9b0330ce3840214f1babed1e87c1de9a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkwMDY3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r386900679", "bodyText": "@jamisonbennett", "author": "lacikaaa", "createdAt": "2020-03-03T09:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxMzYwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r387313600", "bodyText": "Since this endpoint is tied to user in ums, I think this place is fine too. Happy to change if I'm outvoted though :)", "author": "aarman-cloudera", "createdAt": "2020-03-03T21:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMzM4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388603382", "bodyText": "Thanks for making these contributions, I have a couple of thoughts on this which you may have already considered. Sorry for the lengthy comment.\nFirst, its cool how this is an HTTP get. It looks like you have lots of logic that creates a keytab without using the public FreeIPA API to retrieve the keytab. I am quite intrigued at how you were able to do this. I think the public FreeIPA get keytab API for user principals updates the KVNO every time. \ud83d\ude04\nAs an aside, avoiding incrementing the KVNO for users is one of the features the TGT generator provides. The TGT generator creates service principals for users. For example, principal myuser/cluster1.cloudera.site@CLOUDERA.SITE will be used rather than myuser@CLOUDERA.SITE. In both cases, the principal will be mapped hadoop user myuser. This was done because only service principals could be retrieved without invalidating prior keytabs. I am not sure if this is something that would be useful to know more about but reach out to me if it is and I can provide you with the design documentation.\nSecond, although this only is able to retrieve the keytab for a specific user, I think the KerberosMgmtV1Endpoint is a more logical location for the code. That endpoint already handles keytabs for service principals and host principals. At some point, we may have a need for user principals.\nThrid, I think the other keytab API calls returned a vault path with the principal and the keytab. Vault should probably be used. The data in vault was base64 encoded.", "author": "jamisonbennett", "createdAt": "2020-03-05T22:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwODkxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388708918", "bodyText": "I'll defer to Jamison here regarding keytab generation. Based on his comments, I think that this API probably belongs next to the other keytab APIs", "author": "handavid", "createdAt": "2020-03-06T04:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ2NDQ3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r389464474", "bodyText": "We do not use the public FreeIPA APIs. We have the password hashes in the control plane and we just package them in a keytab format. We use kvno 0 which works with an arbitrary kvno in the kdc. Asif did a POC before sending this out.", "author": "giladwolff", "createdAt": "2020-03-09T05:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMzk1OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390003959", "bodyText": "Thanks for looking Jamison. I've moved it to KerberosMgmtV1Endpoint As mentioned this work is heavily tied with 'syncing password hash' feature that others have worked on in the past. Some more details about this approach can be found on the design doc here:\nhttps://docs.google.com/document/d/1-M9-WD0SGBNMsnJbZtXTMmrh0EHRG8tGVYUlIR64byg\nCan we use a string and not a vault path, for now at least? This will be exposed as a public endpoint in environments2 api service in thunderhead and we don't have vault integration there yet. I can file jira to look into it, but I'd rather do it as a follow up.", "author": "aarman-cloudera", "createdAt": "2020-03-09T22:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "chunk": "diff --git a/freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/UserV1Endpoint.java b/freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/UserV1Endpoint.java\nindex a48529ddf7..65a8af2f13 100644\n--- a/freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/UserV1Endpoint.java\n+++ b/freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/UserV1Endpoint.java\n\n@@ -52,11 +52,4 @@ public interface UserV1Endpoint {\n     @ApiOperation(value = UserOperationDescriptions.SYNC_OPERATION_STATUS, notes = UserNotes.USER_NOTES, produces = MediaType.APPLICATION_JSON,\n             nickname = \"getSyncOperationStatusV1\")\n     SyncOperationStatus getSyncOperationStatus(@NotNull @QueryParam(\"operationId\") String operationId);\n-\n-    @GET\n-    @Path(\"getKeytab\")\n-    @Produces(MediaType.APPLICATION_JSON)\n-    @ApiOperation(value = UserOperationDescriptions.GET_KEYTAB, notes = UserNotes.USER_NOTES, produces = MediaType.APPLICATION_JSON,\n-            nickname = \"getKeytabV1\")\n-    String getKeytab(@NotNull @QueryParam(\"environment\") String environment, @QueryParam(\"user\") String user);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2NTY5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r386865690", "bodyText": "We might take of that targetUserCrn from the API and add it when we support it, as it won't be a breaking change. If we keep this way I think we should not throw an exception when target and caller crn are the same.", "author": "lacikaaa", "createdAt": "2020-03-03T08:37:51Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -98,6 +102,19 @@ public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    public String getKeytab(@NotNull String environmentCrn, String targetUserCrn) {\n+        String callerUserCrn = checkUserCrn();\n+        LOGGER.debug(\"getKeytab() request for environmentCrn={}, callerUserCrn={}, targetUserCrn={}\", environmentCrn, callerUserCrn, targetUserCrn);\n+        // TODO For now, we ignore the optional targetUserCrn and only allow retrieving keytab for the calling user. When\n+        //      we later enable this, we need to make sure that the calling has the necessary authorization / right to get\n+        //      keytab for another user.\n+        if (targetUserCrn != null) {\n+            throw new BadRequestException(\"Retrieving a keytab for another user is not yet supported\");\n+        }", "originalCommit": "a754e4a9b0330ce3840214f1babed1e87c1de9a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxMjQ4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r387312484", "bodyText": "Good point, I've updated to not throw when target is same.", "author": "aarman-cloudera", "createdAt": "2020-03-03T21:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2NTY5MA=="}], "type": "inlineReview", "revised_code": {"commit": "00189074cc3555868cda818d9d3e1a80764ceab8", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java b/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\nindex 54fc39344c..31cdc4598f 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\n\n@@ -107,9 +116,9 @@ public class UserV1Controller implements UserV1Endpoint {\n         String callerUserCrn = checkUserCrn();\n         LOGGER.debug(\"getKeytab() request for environmentCrn={}, callerUserCrn={}, targetUserCrn={}\", environmentCrn, callerUserCrn, targetUserCrn);\n         // TODO For now, we ignore the optional targetUserCrn and only allow retrieving keytab for the calling user. When\n-        //      we later enable this, we need to make sure that the calling has the necessary authorization / right to get\n+        //      we later enable this, we need to make sure that the calling user has the necessary authorization / right to get\n         //      keytab for another user.\n-        if (targetUserCrn != null) {\n+        if (targetUserCrn != null && !callerUserCrn.equals(targetUserCrn)) {\n             throw new BadRequestException(\"Retrieving a keytab for another user is not yet supported\");\n         }\n         return userKeytabService.getKeytabBase64(callerUserCrn, environmentCrn);\n"}}, {"oid": "00189074cc3555868cda818d9d3e1a80764ceab8", "url": "https://github.com/hortonworks/cloudbreak/commit/00189074cc3555868cda818d9d3e1a80764ceab8", "message": "CDPCP-1539. Expose api endpoint to retrieve / generate keys for an actor\n\nThis exposes a new endpoint in FreeIPA service to retrieve a keytab\nfor an actor under an environment.", "committedDate": "2020-03-03T21:42:16Z", "type": "forcePushed"}, {"oid": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "url": "https://github.com/hortonworks/cloudbreak/commit/96f885d6c58bf64599edb274845fd2f2ea4b2de0", "message": "CDPCP-1539. Expose api endpoint to retrieve / generate keys for an actor\n\nThis exposes a new endpoint in FreeIPA service to retrieve a keytab\nfor an actor under an environment.", "committedDate": "2020-03-04T00:06:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMzg0Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388603847", "bodyText": "You should also probably mention that the data is base64 encoded and that is is a vault path (assuming you make the vault change).", "author": "jamisonbennett", "createdAt": "2020-03-05T22:27:30Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/doc/UserOperationDescriptions.java", "diffHunk": "@@ -5,6 +5,7 @@\n     public static final String SYNC_ALL = \"Synchronizes Groups and Users to the FreeIPA servers\";\n     public static final String SET_PASSWORD = \"Sets the user's password in the FreeIPA servers\";\n     public static final String SYNC_OPERATION_STATUS = \"Gets the status of a sync operation\";\n+    public static final String GET_KEYTAB = \"Gets a keytab as a base64 encoded string for a User under a specified Environment\";", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNDMyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390004322", "bodyText": "As mentioned, I'd like to not go with vault path for now and just return the base64 string directly.", "author": "aarman-cloudera", "createdAt": "2020-03-09T22:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMzg0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "chunk": "diff --git a/freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/doc/UserOperationDescriptions.java b/freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/doc/UserOperationDescriptions.java\nindex f84b759448..2fd96a4c7a 100644\n--- a/freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/doc/UserOperationDescriptions.java\n+++ b/freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/doc/UserOperationDescriptions.java\n\n@@ -5,7 +5,6 @@ public final class UserOperationDescriptions {\n     public static final String SYNC_ALL = \"Synchronizes Groups and Users to the FreeIPA servers\";\n     public static final String SET_PASSWORD = \"Sets the user's password in the FreeIPA servers\";\n     public static final String SYNC_OPERATION_STATUS = \"Gets the status of a sync operation\";\n-    public static final String GET_KEYTAB = \"Gets a keytab as a base64 encoded string for a User under a specified Environment\";\n \n     private UserOperationDescriptions() {\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwNTEzMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388605130", "bodyText": "nit: \"yet\" is probably not needed.", "author": "jamisonbennett", "createdAt": "2020-03-05T22:30:53Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -107,6 +111,19 @@ public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    public String getKeytab(@NotNull String environmentCrn, String targetUserCrn) {\n+        String callerUserCrn = checkUserCrn();\n+        LOGGER.debug(\"getKeytab() request for environmentCrn={}, callerUserCrn={}, targetUserCrn={}\", environmentCrn, callerUserCrn, targetUserCrn);\n+        // TODO For now, we ignore the optional targetUserCrn and only allow retrieving keytab for the calling user. When\n+        //      we later enable this, we need to make sure that the calling user has the necessary authorization / right to get\n+        //      keytab for another user.\n+        if (targetUserCrn != null && !callerUserCrn.equals(targetUserCrn)) {\n+            throw new BadRequestException(\"Retrieving a keytab for another user is not yet supported\");", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java b/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\nindex 31cdc4598f..8a217a8de3 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\n\n@@ -111,19 +107,6 @@ public class UserV1Controller implements UserV1Endpoint {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n-    @Override\n-    public String getKeytab(@NotNull String environmentCrn, String targetUserCrn) {\n-        String callerUserCrn = checkUserCrn();\n-        LOGGER.debug(\"getKeytab() request for environmentCrn={}, callerUserCrn={}, targetUserCrn={}\", environmentCrn, callerUserCrn, targetUserCrn);\n-        // TODO For now, we ignore the optional targetUserCrn and only allow retrieving keytab for the calling user. When\n-        //      we later enable this, we need to make sure that the calling user has the necessary authorization / right to get\n-        //      keytab for another user.\n-        if (targetUserCrn != null && !callerUserCrn.equals(targetUserCrn)) {\n-            throw new BadRequestException(\"Retrieving a keytab for another user is not yet supported\");\n-        }\n-        return userKeytabService.getKeytabBase64(callerUserCrn, environmentCrn);\n-    }\n-\n     private SyncOperationStatus checkOperationRejected(SyncOperationStatus syncOperationStatus) {\n         if (syncOperationStatus.getStatus() == SynchronizationStatus.REJECTED) {\n             throw new SyncOperationAlreadyRunningException(syncOperationStatus.getError());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwNTQ3OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388605478", "bodyText": "I am glad to see you using the IAM service here rather than FREEIPA. I had to make a similar correction today \ud83d\ude04", "author": "jamisonbennett", "createdAt": "2020-03-05T22:31:51Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetActorWorkloadCredentialsResponse;\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfig;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfigRepository;\n+import com.sequenceiq.freeipa.service.freeipa.user.kerberos.UserKeytabGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static com.sequenceiq.freeipa.controller.exception.NotFoundException.notFound;\n+\n+@Service\n+public class UserKeytabService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabService.class);\n+\n+    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwOTkwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388709905", "bodyText": "we had a talk ;)", "author": "handavid", "createdAt": "2020-03-06T04:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwNTQ3OA=="}], "type": "inlineReview", "revised_code": {"commit": "42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java\ndeleted file mode 100644\nindex a7aadd1f13..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java\n+++ /dev/null\n\n@@ -1,72 +0,0 @@\n-package com.sequenceiq.freeipa.service.freeipa.user;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetActorWorkloadCredentialsResponse;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n-import com.sequenceiq.cloudbreak.auth.altus.Crn;\n-import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n-import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n-import com.sequenceiq.cloudbreak.logger.MDCUtils;\n-import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n-import com.sequenceiq.freeipa.kerberos.KerberosConfig;\n-import com.sequenceiq.freeipa.kerberos.KerberosConfigRepository;\n-import com.sequenceiq.freeipa.service.freeipa.user.kerberos.UserKeytabGenerator;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Service;\n-\n-import javax.inject.Inject;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static com.sequenceiq.freeipa.controller.exception.NotFoundException.notFound;\n-\n-@Service\n-public class UserKeytabService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabService.class);\n-\n-    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();\n-\n-    @Inject\n-    private KerberosConfigRepository kerberosConfigRepository;\n-\n-    @Inject\n-    private GrpcUmsClient grpcUmsClient;\n-\n-    @Inject\n-    private UserKeytabGenerator userKeytabGenerator;\n-\n-    private String getKerberosRealm(String accountId, String environmentCrn) {\n-        KerberosConfig krbConfig =  kerberosConfigRepository\n-                .findByAccountIdAndEnvironmentCrnAndClusterNameIsNull(accountId, environmentCrn)\n-                .orElseThrow(notFound(\"KerberosConfig for environment\", environmentCrn));\n-        return krbConfig.getRealm();\n-    }\n-\n-    private void validateSameAccount(String userAccountId, String environmentCrn) {\n-        String environmentCrnAccountId = Objects.requireNonNull(Crn.fromString(environmentCrn)).getAccountId();\n-        if (!environmentCrnAccountId.equals(userAccountId)) {\n-            throw new BadRequestException(\"User and Environment must be in the same account\");\n-        }\n-    }\n-\n-    public String getKeytabBase64(String userCrn, String environmentCrn) {\n-        String userAccountId = Objects.requireNonNull(Crn.fromString(userCrn)).getAccountId();\n-        validateSameAccount(userAccountId, environmentCrn);\n-\n-        String realm = getKerberosRealm(userAccountId, environmentCrn);\n-\n-        GetActorWorkloadCredentialsResponse getActorWorkloadCredentialsResponse =\n-                grpcUmsClient.getActorWorkloadCredentials(IAM_INTERNAL_ACTOR_CRN, userCrn, MDCUtils.getRequestId());\n-        String workloadUsername = getActorWorkloadCredentialsResponse.getWorkloadUsername();\n-        List<ActorKerberosKey> actorKerberosKeys = getActorWorkloadCredentialsResponse.getKerberosKeysList();\n-\n-        try {\n-            return userKeytabGenerator.generateKeytabBase64(workloadUsername, realm, actorKerberosKeys);\n-        } catch (IOException e) {\n-            throw new RuntimeException(\"Failed to generate keytab\", e);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYxNzM2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388617364", "bodyText": "This is interesting that the value of 0 always works.\nAt one point, I had tested the kvno and every time the public FreeIPA API was called to get a user keytab, the KVNO incremented and the old keytab would stop working. Maybe the first KVNO that is issued by the public FreeIPA API is 1 and thus 0 can still be treated specially. You might want to double check this to ensure the user's keytab can't be invalidated (although I suppose we are not calling that API today so maybe its a don't care).\nI believe that at one point @toddlipcon worked on a way to get user keytabs without invalidating them. Is this the same process? I am pretty curious about this.", "author": "jamisonbennett", "createdAt": "2020-03-05T23:02:52Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/UserKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.kerberos;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.kerby.kerberos.kerb.keytab.Keytab;\n+import org.apache.kerby.kerberos.kerb.keytab.KeytabEntry;\n+import org.apache.kerby.kerberos.kerb.type.KerberosTime;\n+import org.apache.kerby.kerberos.kerb.type.base.EncryptionKey;\n+import org.apache.kerby.kerberos.kerb.type.base.EncryptionType;\n+import org.apache.kerby.kerberos.kerb.type.base.PrincipalName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Kerberos keytab generator - This class is repsonsible for generating a keytab using existing keys\n+ * belonging to an actor in User Management Service.\n+ */\n+@Component\n+public class UserKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabGenerator.class);\n+\n+    // For the key version number (kvno) in the keytab entries, we use a value of 0. Based on\n+    // expirementiation we've found that for user principles, keytab entries with kvno of zero\n+    // works fine, regardless of what the actual key versions are set in the KDC / Directory Server.", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2MDYzNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r389060635", "bodyText": "I think you might have already gotten the answer elsewhere, but yea, this builds on work that Gilad (I think) did in the UMS which can produce keytabs for users. That work, in turn, builds on the stuff we worked on a few months back where the UMS stores the hashed password and kerberos principal keys for users locally for password sync purposes. Given that the UMS has the kerberos principal keys, it's just a file formatting exercise to embed those keys into a keytab file, with no FreeIPA instance in the loop at all. (in fact this API should work even if there is no environment created)", "author": "toddlipcon", "createdAt": "2020-03-06T18:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYxNzM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNTgzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390005837", "bodyText": "Just a bit more info, my original comment on kvno = 0 here maybe a bit misleading. As per my testing, the key version number didn't matter and I don't think 0 is special. Setting this to an arbitrary number like 42 would probably still work (though a bulk of my testing was using kvno = 0).\nUsing FreeIPA API is get keytab for user principles, generates new keys and updates the KDC with the new keys and increments the key version number (even if you use the same password; new random salts get used, resulting in different keys). So the older keytab getting invalidated is due to keys not matching and nothing to do with key version numbers. As Todd mentioned since we have keys already in UMS we use those as the basis for the keytab.\nAnother thing to note, based on above; any keytab a user gets using this api will still get invalidated if the user were to later call ipa-getkeytab directly (but would start working again after user sync occurs). So we should discourage any user from using this ipa-getkeytab or trying to get the keytab by other means outside the api we provide.", "author": "aarman-cloudera", "createdAt": "2020-03-09T22:56:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYxNzM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNjg3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390006874", "bodyText": "Also, this API still requires an environment, because we need the realm inside the keytab. In order to generate the keytab, we perform a lookup of the realm based on environment.", "author": "aarman-cloudera", "createdAt": "2020-03-09T22:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYxNzM2NA=="}], "type": "inlineReview", "revised_code": {"commit": "42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/UserKeytabGenerator.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/UserKeytabGenerator.java\nindex d15acb078b..4abd9a0bbd 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/UserKeytabGenerator.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/UserKeytabGenerator.java\n\n@@ -26,7 +26,7 @@ import static java.util.Objects.requireNonNull;\n  * belonging to an actor in User Management Service.\n  */\n @Component\n-public class UserKeytabGenerator {\n+public final class UserKeytabGenerator {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabGenerator.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwOTAzMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388709030", "bodyText": "if the query params are CRNs, then let's include CRN in the names. e.g., environmentCrn", "author": "handavid", "createdAt": "2020-03-06T04:33:57Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/UserV1Endpoint.java", "diffHunk": "@@ -52,4 +52,11 @@\n     @ApiOperation(value = UserOperationDescriptions.SYNC_OPERATION_STATUS, notes = UserNotes.USER_NOTES, produces = MediaType.APPLICATION_JSON,\n             nickname = \"getSyncOperationStatusV1\")\n     SyncOperationStatus getSyncOperationStatus(@NotNull @QueryParam(\"operationId\") String operationId);\n+\n+    @GET\n+    @Path(\"getKeytab\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = UserOperationDescriptions.GET_KEYTAB, notes = UserNotes.USER_NOTES, produces = MediaType.APPLICATION_JSON,\n+            nickname = \"getKeytabV1\")\n+    String getKeytab(@NotNull @QueryParam(\"environment\") String environment, @QueryParam(\"user\") String user);", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "chunk": "diff --git a/freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/UserV1Endpoint.java b/freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/UserV1Endpoint.java\nindex a48529ddf7..65a8af2f13 100644\n--- a/freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/UserV1Endpoint.java\n+++ b/freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/UserV1Endpoint.java\n\n@@ -52,11 +52,4 @@ public interface UserV1Endpoint {\n     @ApiOperation(value = UserOperationDescriptions.SYNC_OPERATION_STATUS, notes = UserNotes.USER_NOTES, produces = MediaType.APPLICATION_JSON,\n             nickname = \"getSyncOperationStatusV1\")\n     SyncOperationStatus getSyncOperationStatus(@NotNull @QueryParam(\"operationId\") String operationId);\n-\n-    @GET\n-    @Path(\"getKeytab\")\n-    @Produces(MediaType.APPLICATION_JSON)\n-    @ApiOperation(value = UserOperationDescriptions.GET_KEYTAB, notes = UserNotes.USER_NOTES, produces = MediaType.APPLICATION_JSON,\n-            nickname = \"getKeytabV1\")\n-    String getKeytab(@NotNull @QueryParam(\"environment\") String environment, @QueryParam(\"user\") String user);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwOTc5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388709792", "bodyText": "based on the expected future use-case, we should require the targetUserCrn field. i.e., mark it @NotNull.\nAs a design principle, we do not want to pull request arguments out of the actor or other metadata. All required information should be in the request itself. (yes, a bunch of the other APIs violate this but I'll fix this in the v2 API)\ncan we rename callerUserCrn to actorCrn?\nwe can keep the actorCrn.equals(targetUserCrn) check as a faux authorization check for now.", "author": "handavid", "createdAt": "2020-03-06T04:38:28Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -107,6 +111,19 @@ public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    public String getKeytab(@NotNull String environmentCrn, String targetUserCrn) {", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTE5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390011192", "bodyText": "Done. I've also renamed to actorCrn (I wonder if we should rename ThreadBasedUserCrnProvider -> ThreadBasedActorrCrnProvider).", "author": "aarman-cloudera", "createdAt": "2020-03-09T23:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwOTc5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java b/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\nindex 31cdc4598f..8a217a8de3 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\n\n@@ -111,19 +107,6 @@ public class UserV1Controller implements UserV1Endpoint {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n-    @Override\n-    public String getKeytab(@NotNull String environmentCrn, String targetUserCrn) {\n-        String callerUserCrn = checkUserCrn();\n-        LOGGER.debug(\"getKeytab() request for environmentCrn={}, callerUserCrn={}, targetUserCrn={}\", environmentCrn, callerUserCrn, targetUserCrn);\n-        // TODO For now, we ignore the optional targetUserCrn and only allow retrieving keytab for the calling user. When\n-        //      we later enable this, we need to make sure that the calling user has the necessary authorization / right to get\n-        //      keytab for another user.\n-        if (targetUserCrn != null && !callerUserCrn.equals(targetUserCrn)) {\n-            throw new BadRequestException(\"Retrieving a keytab for another user is not yet supported\");\n-        }\n-        return userKeytabService.getKeytabBase64(callerUserCrn, environmentCrn);\n-    }\n-\n     private SyncOperationStatus checkOperationRejected(SyncOperationStatus syncOperationStatus) {\n         if (syncOperationStatus.getStatus() == SynchronizationStatus.REJECTED) {\n             throw new SyncOperationAlreadyRunningException(syncOperationStatus.getError());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMDQ0Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388710447", "bodyText": "call this with the targetUserCrn rather than the actorCrn. The actorCrn will be available to other code in through the ThreadBasedUserCrnProvider (I think I remembered that correctly)", "author": "handavid", "createdAt": "2020-03-06T04:42:10Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -107,6 +111,19 @@ public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    public String getKeytab(@NotNull String environmentCrn, String targetUserCrn) {\n+        String callerUserCrn = checkUserCrn();\n+        LOGGER.debug(\"getKeytab() request for environmentCrn={}, callerUserCrn={}, targetUserCrn={}\", environmentCrn, callerUserCrn, targetUserCrn);\n+        // TODO For now, we ignore the optional targetUserCrn and only allow retrieving keytab for the calling user. When\n+        //      we later enable this, we need to make sure that the calling user has the necessary authorization / right to get\n+        //      keytab for another user.\n+        if (targetUserCrn != null && !callerUserCrn.equals(targetUserCrn)) {\n+            throw new BadRequestException(\"Retrieving a keytab for another user is not yet supported\");\n+        }\n+        return userKeytabService.getKeytabBase64(callerUserCrn, environmentCrn);", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java b/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\nindex 31cdc4598f..8a217a8de3 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java\n\n@@ -111,19 +107,6 @@ public class UserV1Controller implements UserV1Endpoint {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n-    @Override\n-    public String getKeytab(@NotNull String environmentCrn, String targetUserCrn) {\n-        String callerUserCrn = checkUserCrn();\n-        LOGGER.debug(\"getKeytab() request for environmentCrn={}, callerUserCrn={}, targetUserCrn={}\", environmentCrn, callerUserCrn, targetUserCrn);\n-        // TODO For now, we ignore the optional targetUserCrn and only allow retrieving keytab for the calling user. When\n-        //      we later enable this, we need to make sure that the calling user has the necessary authorization / right to get\n-        //      keytab for another user.\n-        if (targetUserCrn != null && !callerUserCrn.equals(targetUserCrn)) {\n-            throw new BadRequestException(\"Retrieving a keytab for another user is not yet supported\");\n-        }\n-        return userKeytabService.getKeytabBase64(callerUserCrn, environmentCrn);\n-    }\n-\n     private SyncOperationStatus checkOperationRejected(SyncOperationStatus syncOperationStatus) {\n         if (syncOperationStatus.getStatus() == SynchronizationStatus.REJECTED) {\n             throw new SyncOperationAlreadyRunningException(syncOperationStatus.getError());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMDc2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388710768", "bodyText": "Crn.safeFromString instead of Objects.requireNonNull", "author": "handavid", "createdAt": "2020-03-06T04:43:52Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetActorWorkloadCredentialsResponse;\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfig;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfigRepository;\n+import com.sequenceiq.freeipa.service.freeipa.user.kerberos.UserKeytabGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static com.sequenceiq.freeipa.controller.exception.NotFoundException.notFound;\n+\n+@Service\n+public class UserKeytabService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabService.class);\n+\n+    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();\n+\n+    @Inject\n+    private KerberosConfigRepository kerberosConfigRepository;\n+\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private UserKeytabGenerator userKeytabGenerator;\n+\n+    private String getKerberosRealm(String accountId, String environmentCrn) {\n+        KerberosConfig krbConfig =  kerberosConfigRepository\n+                .findByAccountIdAndEnvironmentCrnAndClusterNameIsNull(accountId, environmentCrn)\n+                .orElseThrow(notFound(\"KerberosConfig for environment\", environmentCrn));\n+        return krbConfig.getRealm();\n+    }\n+\n+    private void validateSameAccount(String userAccountId, String environmentCrn) {\n+        String environmentCrnAccountId = Objects.requireNonNull(Crn.fromString(environmentCrn)).getAccountId();", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java\ndeleted file mode 100644\nindex a7aadd1f13..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java\n+++ /dev/null\n\n@@ -1,72 +0,0 @@\n-package com.sequenceiq.freeipa.service.freeipa.user;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetActorWorkloadCredentialsResponse;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n-import com.sequenceiq.cloudbreak.auth.altus.Crn;\n-import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n-import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n-import com.sequenceiq.cloudbreak.logger.MDCUtils;\n-import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n-import com.sequenceiq.freeipa.kerberos.KerberosConfig;\n-import com.sequenceiq.freeipa.kerberos.KerberosConfigRepository;\n-import com.sequenceiq.freeipa.service.freeipa.user.kerberos.UserKeytabGenerator;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Service;\n-\n-import javax.inject.Inject;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static com.sequenceiq.freeipa.controller.exception.NotFoundException.notFound;\n-\n-@Service\n-public class UserKeytabService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabService.class);\n-\n-    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();\n-\n-    @Inject\n-    private KerberosConfigRepository kerberosConfigRepository;\n-\n-    @Inject\n-    private GrpcUmsClient grpcUmsClient;\n-\n-    @Inject\n-    private UserKeytabGenerator userKeytabGenerator;\n-\n-    private String getKerberosRealm(String accountId, String environmentCrn) {\n-        KerberosConfig krbConfig =  kerberosConfigRepository\n-                .findByAccountIdAndEnvironmentCrnAndClusterNameIsNull(accountId, environmentCrn)\n-                .orElseThrow(notFound(\"KerberosConfig for environment\", environmentCrn));\n-        return krbConfig.getRealm();\n-    }\n-\n-    private void validateSameAccount(String userAccountId, String environmentCrn) {\n-        String environmentCrnAccountId = Objects.requireNonNull(Crn.fromString(environmentCrn)).getAccountId();\n-        if (!environmentCrnAccountId.equals(userAccountId)) {\n-            throw new BadRequestException(\"User and Environment must be in the same account\");\n-        }\n-    }\n-\n-    public String getKeytabBase64(String userCrn, String environmentCrn) {\n-        String userAccountId = Objects.requireNonNull(Crn.fromString(userCrn)).getAccountId();\n-        validateSameAccount(userAccountId, environmentCrn);\n-\n-        String realm = getKerberosRealm(userAccountId, environmentCrn);\n-\n-        GetActorWorkloadCredentialsResponse getActorWorkloadCredentialsResponse =\n-                grpcUmsClient.getActorWorkloadCredentials(IAM_INTERNAL_ACTOR_CRN, userCrn, MDCUtils.getRequestId());\n-        String workloadUsername = getActorWorkloadCredentialsResponse.getWorkloadUsername();\n-        List<ActorKerberosKey> actorKerberosKeys = getActorWorkloadCredentialsResponse.getKerberosKeysList();\n-\n-        try {\n-            return userKeytabGenerator.generateKeytabBase64(workloadUsername, realm, actorKerberosKeys);\n-        } catch (IOException e) {\n-            throw new RuntimeException(\"Failed to generate keytab\", e);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMDgxMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388710813", "bodyText": "Crn.safeFromString instead of Objects.requireNonNull", "author": "handavid", "createdAt": "2020-03-06T04:44:09Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetActorWorkloadCredentialsResponse;\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfig;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfigRepository;\n+import com.sequenceiq.freeipa.service.freeipa.user.kerberos.UserKeytabGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static com.sequenceiq.freeipa.controller.exception.NotFoundException.notFound;\n+\n+@Service\n+public class UserKeytabService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabService.class);\n+\n+    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();\n+\n+    @Inject\n+    private KerberosConfigRepository kerberosConfigRepository;\n+\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private UserKeytabGenerator userKeytabGenerator;\n+\n+    private String getKerberosRealm(String accountId, String environmentCrn) {\n+        KerberosConfig krbConfig =  kerberosConfigRepository\n+                .findByAccountIdAndEnvironmentCrnAndClusterNameIsNull(accountId, environmentCrn)\n+                .orElseThrow(notFound(\"KerberosConfig for environment\", environmentCrn));\n+        return krbConfig.getRealm();\n+    }\n+\n+    private void validateSameAccount(String userAccountId, String environmentCrn) {\n+        String environmentCrnAccountId = Objects.requireNonNull(Crn.fromString(environmentCrn)).getAccountId();\n+        if (!environmentCrnAccountId.equals(userAccountId)) {\n+            throw new BadRequestException(\"User and Environment must be in the same account\");\n+        }\n+    }\n+\n+    public String getKeytabBase64(String userCrn, String environmentCrn) {\n+        String userAccountId = Objects.requireNonNull(Crn.fromString(userCrn)).getAccountId();", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java\ndeleted file mode 100644\nindex a7aadd1f13..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java\n+++ /dev/null\n\n@@ -1,72 +0,0 @@\n-package com.sequenceiq.freeipa.service.freeipa.user;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetActorWorkloadCredentialsResponse;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n-import com.sequenceiq.cloudbreak.auth.altus.Crn;\n-import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n-import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n-import com.sequenceiq.cloudbreak.logger.MDCUtils;\n-import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n-import com.sequenceiq.freeipa.kerberos.KerberosConfig;\n-import com.sequenceiq.freeipa.kerberos.KerberosConfigRepository;\n-import com.sequenceiq.freeipa.service.freeipa.user.kerberos.UserKeytabGenerator;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Service;\n-\n-import javax.inject.Inject;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static com.sequenceiq.freeipa.controller.exception.NotFoundException.notFound;\n-\n-@Service\n-public class UserKeytabService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabService.class);\n-\n-    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();\n-\n-    @Inject\n-    private KerberosConfigRepository kerberosConfigRepository;\n-\n-    @Inject\n-    private GrpcUmsClient grpcUmsClient;\n-\n-    @Inject\n-    private UserKeytabGenerator userKeytabGenerator;\n-\n-    private String getKerberosRealm(String accountId, String environmentCrn) {\n-        KerberosConfig krbConfig =  kerberosConfigRepository\n-                .findByAccountIdAndEnvironmentCrnAndClusterNameIsNull(accountId, environmentCrn)\n-                .orElseThrow(notFound(\"KerberosConfig for environment\", environmentCrn));\n-        return krbConfig.getRealm();\n-    }\n-\n-    private void validateSameAccount(String userAccountId, String environmentCrn) {\n-        String environmentCrnAccountId = Objects.requireNonNull(Crn.fromString(environmentCrn)).getAccountId();\n-        if (!environmentCrnAccountId.equals(userAccountId)) {\n-            throw new BadRequestException(\"User and Environment must be in the same account\");\n-        }\n-    }\n-\n-    public String getKeytabBase64(String userCrn, String environmentCrn) {\n-        String userAccountId = Objects.requireNonNull(Crn.fromString(userCrn)).getAccountId();\n-        validateSameAccount(userAccountId, environmentCrn);\n-\n-        String realm = getKerberosRealm(userAccountId, environmentCrn);\n-\n-        GetActorWorkloadCredentialsResponse getActorWorkloadCredentialsResponse =\n-                grpcUmsClient.getActorWorkloadCredentials(IAM_INTERNAL_ACTOR_CRN, userCrn, MDCUtils.getRequestId());\n-        String workloadUsername = getActorWorkloadCredentialsResponse.getWorkloadUsername();\n-        List<ActorKerberosKey> actorKerberosKeys = getActorWorkloadCredentialsResponse.getKerberosKeysList();\n-\n-        try {\n-            return userKeytabGenerator.generateKeytabBase64(workloadUsername, realm, actorKerberosKeys);\n-        } catch (IOException e) {\n-            throw new RuntimeException(\"Failed to generate keytab\", e);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMTE0OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388711148", "bodyText": "can you throw a more meaningful exception? perhaps make a custom exception so that we can map it to a response code in the api layer", "author": "handavid", "createdAt": "2020-03-06T04:46:03Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetActorWorkloadCredentialsResponse;\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfig;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfigRepository;\n+import com.sequenceiq.freeipa.service.freeipa.user.kerberos.UserKeytabGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static com.sequenceiq.freeipa.controller.exception.NotFoundException.notFound;\n+\n+@Service\n+public class UserKeytabService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabService.class);\n+\n+    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();\n+\n+    @Inject\n+    private KerberosConfigRepository kerberosConfigRepository;\n+\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private UserKeytabGenerator userKeytabGenerator;\n+\n+    private String getKerberosRealm(String accountId, String environmentCrn) {\n+        KerberosConfig krbConfig =  kerberosConfigRepository\n+                .findByAccountIdAndEnvironmentCrnAndClusterNameIsNull(accountId, environmentCrn)\n+                .orElseThrow(notFound(\"KerberosConfig for environment\", environmentCrn));\n+        return krbConfig.getRealm();\n+    }\n+\n+    private void validateSameAccount(String userAccountId, String environmentCrn) {\n+        String environmentCrnAccountId = Objects.requireNonNull(Crn.fromString(environmentCrn)).getAccountId();\n+        if (!environmentCrnAccountId.equals(userAccountId)) {\n+            throw new BadRequestException(\"User and Environment must be in the same account\");\n+        }\n+    }\n+\n+    public String getKeytabBase64(String userCrn, String environmentCrn) {\n+        String userAccountId = Objects.requireNonNull(Crn.fromString(userCrn)).getAccountId();\n+        validateSameAccount(userAccountId, environmentCrn);\n+\n+        String realm = getKerberosRealm(userAccountId, environmentCrn);\n+\n+        GetActorWorkloadCredentialsResponse getActorWorkloadCredentialsResponse =\n+                grpcUmsClient.getActorWorkloadCredentials(IAM_INTERNAL_ACTOR_CRN, userCrn, MDCUtils.getRequestId());\n+        String workloadUsername = getActorWorkloadCredentialsResponse.getWorkloadUsername();\n+        List<ActorKerberosKey> actorKerberosKeys = getActorWorkloadCredentialsResponse.getKerberosKeysList();\n+\n+        try {\n+            return userKeytabGenerator.generateKeytabBase64(workloadUsername, realm, actorKerberosKeys);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to generate keytab\", e);", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzM3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390013377", "bodyText": "I've moved the exception handling into UserKeytabGenerator. I don't see how the IOException will ever trigger since we're passing our own ByteArrayOutputStream rather than doing file i/o. So I don't think a custom exception here is warranted.", "author": "aarman-cloudera", "createdAt": "2020-03-09T23:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMTE0OA=="}], "type": "inlineReview", "revised_code": {"commit": "42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java\ndeleted file mode 100644\nindex a7aadd1f13..0000000000\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java\n+++ /dev/null\n\n@@ -1,72 +0,0 @@\n-package com.sequenceiq.freeipa.service.freeipa.user;\n-\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetActorWorkloadCredentialsResponse;\n-import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n-import com.sequenceiq.cloudbreak.auth.altus.Crn;\n-import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n-import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n-import com.sequenceiq.cloudbreak.logger.MDCUtils;\n-import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n-import com.sequenceiq.freeipa.kerberos.KerberosConfig;\n-import com.sequenceiq.freeipa.kerberos.KerberosConfigRepository;\n-import com.sequenceiq.freeipa.service.freeipa.user.kerberos.UserKeytabGenerator;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.stereotype.Service;\n-\n-import javax.inject.Inject;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static com.sequenceiq.freeipa.controller.exception.NotFoundException.notFound;\n-\n-@Service\n-public class UserKeytabService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabService.class);\n-\n-    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();\n-\n-    @Inject\n-    private KerberosConfigRepository kerberosConfigRepository;\n-\n-    @Inject\n-    private GrpcUmsClient grpcUmsClient;\n-\n-    @Inject\n-    private UserKeytabGenerator userKeytabGenerator;\n-\n-    private String getKerberosRealm(String accountId, String environmentCrn) {\n-        KerberosConfig krbConfig =  kerberosConfigRepository\n-                .findByAccountIdAndEnvironmentCrnAndClusterNameIsNull(accountId, environmentCrn)\n-                .orElseThrow(notFound(\"KerberosConfig for environment\", environmentCrn));\n-        return krbConfig.getRealm();\n-    }\n-\n-    private void validateSameAccount(String userAccountId, String environmentCrn) {\n-        String environmentCrnAccountId = Objects.requireNonNull(Crn.fromString(environmentCrn)).getAccountId();\n-        if (!environmentCrnAccountId.equals(userAccountId)) {\n-            throw new BadRequestException(\"User and Environment must be in the same account\");\n-        }\n-    }\n-\n-    public String getKeytabBase64(String userCrn, String environmentCrn) {\n-        String userAccountId = Objects.requireNonNull(Crn.fromString(userCrn)).getAccountId();\n-        validateSameAccount(userAccountId, environmentCrn);\n-\n-        String realm = getKerberosRealm(userAccountId, environmentCrn);\n-\n-        GetActorWorkloadCredentialsResponse getActorWorkloadCredentialsResponse =\n-                grpcUmsClient.getActorWorkloadCredentials(IAM_INTERNAL_ACTOR_CRN, userCrn, MDCUtils.getRequestId());\n-        String workloadUsername = getActorWorkloadCredentialsResponse.getWorkloadUsername();\n-        List<ActorKerberosKey> actorKerberosKeys = getActorWorkloadCredentialsResponse.getKerberosKeysList();\n-\n-        try {\n-            return userKeytabGenerator.generateKeytabBase64(workloadUsername, realm, actorKerberosKeys);\n-        } catch (IOException e) {\n-            throw new RuntimeException(\"Failed to generate keytab\", e);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMTI2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388711267", "bodyText": "thank you!", "author": "handavid", "createdAt": "2020-03-06T04:46:36Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/KrbKeySetEncoder.java", "diffHunk": "@@ -1,4 +1,4 @@\n-package com.sequenceiq.freeipa.util;\n+package com.sequenceiq.freeipa.service.freeipa.user.kerberos;", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzQzMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390013431", "bodyText": "np! :)", "author": "aarman-cloudera", "createdAt": "2020-03-09T23:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMTI2Nw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "url": "https://github.com/hortonworks/cloudbreak/commit/42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "message": "CDPCP-1522. Add support for generating keytab from actor kerberos key\n\nA UserKeytabGenerator class has been added that allows generating\na kerberos keytab by using the keys within ActorKerberosKey's.\nThis pulls in kerb-utils dependency from the Apache Kerby project\nwhich contains the classes needed to encode the principal and\nkeys into the keytab format. In addition KrbKeySetEncoder which\ndoes something similar has been moved under the same package.\n\nThis functionality of this class will be exposed as an api endpoint\nin a follow-on commit.", "committedDate": "2020-03-09T18:18:36Z", "type": "commit"}, {"oid": "2aec23deb736b71b80caf2c119ca1ae5dd276dd6", "url": "https://github.com/hortonworks/cloudbreak/commit/2aec23deb736b71b80caf2c119ca1ae5dd276dd6", "message": "CDPCP-1291. Update UMS client to include workload username in actor workload credentials\n\nThis will make it easier to generate keytab from actor workload credentials.", "committedDate": "2020-03-09T18:18:36Z", "type": "commit"}, {"oid": "9854b39fed1500670ec79362d22084e72c8a6b6a", "url": "https://github.com/hortonworks/cloudbreak/commit/9854b39fed1500670ec79362d22084e72c8a6b6a", "message": "CDPCP-1539. Expose api endpoint to retrieve / generate keys for an actor\n\nThis exposes a new endpoint in FreeIPA service to retrieve a keytab\nfor an actor under an environment.", "committedDate": "2020-03-09T22:37:46Z", "type": "forcePushed"}, {"oid": "cc7f766029d25bd7a7cce8c87f067d5dbf44c8c7", "url": "https://github.com/hortonworks/cloudbreak/commit/cc7f766029d25bd7a7cce8c87f067d5dbf44c8c7", "message": "CDPCP-1539. Expose api endpoint to retrieve / generate keys for an actor\n\nThis exposes a new endpoint in FreeIPA service to retrieve a keytab\nfor an actor under an environment.", "committedDate": "2020-03-09T23:24:33Z", "type": "commit"}, {"oid": "cc7f766029d25bd7a7cce8c87f067d5dbf44c8c7", "url": "https://github.com/hortonworks/cloudbreak/commit/cc7f766029d25bd7a7cce8c87f067d5dbf44c8c7", "message": "CDPCP-1539. Expose api endpoint to retrieve / generate keys for an actor\n\nThis exposes a new endpoint in FreeIPA service to retrieve a keytab\nfor an actor under an environment.", "committedDate": "2020-03-09T23:24:33Z", "type": "forcePushed"}]}