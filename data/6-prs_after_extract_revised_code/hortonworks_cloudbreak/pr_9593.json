{"pr_number": 9593, "pr_title": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services to a new version what we burned into the new image.", "pr_createdAt": "2020-12-07T16:38:07Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9593", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2NzA2Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537667063", "bodyText": "We should call the method argument to services as well. We're mixing the product and services variables and it's hard to track.", "author": "keyki", "createdAt": "2020-12-07T16:58:03Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcels(components);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getServices(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhServices(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhServices(services, cdhServiceName);\n+        installServices(nonCdhServices, parcelResourceApi);\n+    }\n+\n+    private void installServices(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi) throws ApiException, CloudbreakException {\n+        downloadParcel(products, parcelResourceApi);\n+        distributeParcel(products, parcelResourceApi);\n+        activateParcel(products, parcelResourceApi);\n+    }\n+\n+    private ClouderaManagerProduct getCdhService(Set<ClouderaManagerProduct> products) {\n+        return products.stream()\n+                .filter(product -> product.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n                 .findFirst()\n                 .orElseThrow(() -> new NotFoundException(\"Runtime component not found!\"));\n     }\n \n+    private Set<ClouderaManagerProduct> getNonCdhServices(Set<ClouderaManagerProduct> products, String cdhProductName) {\n+        return products.stream()\n+                .filter(product -> !product.getName().equals(cdhProductName))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private ClouderaManagerProduct getClouderaManagerProduct(ClusterComponent clusterComponent) {\n+        try {\n+            return clusterComponent.getAttributes().get(ClouderaManagerProduct.class);\n+        } catch (IOException e) {\n+            LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n+            throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n+        }\n+    }\n+\n+    private void checkParcelApiAvailability() throws CloudbreakException {\n+        clouderaManagerParcelManagementService.checkParcelApiAvailability(stack, apiClient);\n+    }\n+\n+    private void setParcelRepo(Set<ClouderaManagerProduct> products, ClouderaManagerResourceApi clouderaManagerResourceApi) throws ApiException {", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "176893e061c21dd44a353a348bce4af3755e8033", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\nindex 97d6712ee5..987ad5e67f 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n\n@@ -183,13 +183,13 @@ public class ClouderaManagerModificationService implements ClusterModificationSe\n             checkParcelApiAvailability();\n \n             Set<ClouderaManagerProduct> services = getServices(components);\n-            ClouderaManagerProduct cdhService = getCdhService(services);\n             setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n             if (patchUpgrade) {\n-                installServices(services, parcelResourceApi);\n+                downloadAndActivateParcels(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n+                ClouderaManagerProduct cdhService = getCdhService(services);\n                 upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n                 upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY3MDc3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537670774", "bodyText": "This line can be moved to the else branch as it's only used there.", "author": "keyki", "createdAt": "2020-12-07T17:02:45Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "176893e061c21dd44a353a348bce4af3755e8033", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\nindex 97d6712ee5..987ad5e67f 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n\n@@ -183,13 +183,13 @@ public class ClouderaManagerModificationService implements ClusterModificationSe\n             checkParcelApiAvailability();\n \n             Set<ClouderaManagerProduct> services = getServices(components);\n-            ClouderaManagerProduct cdhService = getCdhService(services);\n             setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n             if (patchUpgrade) {\n-                installServices(services, parcelResourceApi);\n+                downloadAndActivateParcels(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n+                ClouderaManagerProduct cdhService = getCdhService(services);\n                 upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n                 upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY3Nzg2MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537677860", "bodyText": "We should figure out a better method name. Maybe downloadAndActivateParcels ?", "author": "keyki", "createdAt": "2020-12-07T17:12:11Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcels(components);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getServices(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhServices(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhServices(services, cdhServiceName);\n+        installServices(nonCdhServices, parcelResourceApi);\n+    }\n+\n+    private void installServices(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi) throws ApiException, CloudbreakException {", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "176893e061c21dd44a353a348bce4af3755e8033", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\nindex 97d6712ee5..987ad5e67f 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n\n@@ -183,13 +183,13 @@ public class ClouderaManagerModificationService implements ClusterModificationSe\n             checkParcelApiAvailability();\n \n             Set<ClouderaManagerProduct> services = getServices(components);\n-            ClouderaManagerProduct cdhService = getCdhService(services);\n             setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n             if (patchUpgrade) {\n-                installServices(services, parcelResourceApi);\n+                downloadAndActivateParcels(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n+                ClouderaManagerProduct cdhService = getCdhService(services);\n                 upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n                 upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY3ODM5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537678390", "bodyText": "Similarly use services instead of products.", "author": "keyki", "createdAt": "2020-12-07T17:12:54Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcels(components);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getServices(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhServices(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhServices(services, cdhServiceName);\n+        installServices(nonCdhServices, parcelResourceApi);\n+    }\n+\n+    private void installServices(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi) throws ApiException, CloudbreakException {", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "176893e061c21dd44a353a348bce4af3755e8033", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\nindex 97d6712ee5..987ad5e67f 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n\n@@ -183,13 +183,13 @@ public class ClouderaManagerModificationService implements ClusterModificationSe\n             checkParcelApiAvailability();\n \n             Set<ClouderaManagerProduct> services = getServices(components);\n-            ClouderaManagerProduct cdhService = getCdhService(services);\n             setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n             if (patchUpgrade) {\n-                installServices(services, parcelResourceApi);\n+                downloadAndActivateParcels(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n+                ClouderaManagerProduct cdhService = getCdhService(services);\n                 upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n                 upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY3OTQzMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537679430", "bodyText": "services", "author": "keyki", "createdAt": "2020-12-07T17:14:24Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcels(components);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getServices(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhServices(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhServices(services, cdhServiceName);\n+        installServices(nonCdhServices, parcelResourceApi);\n+    }\n+\n+    private void installServices(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi) throws ApiException, CloudbreakException {\n+        downloadParcel(products, parcelResourceApi);\n+        distributeParcel(products, parcelResourceApi);\n+        activateParcel(products, parcelResourceApi);\n+    }\n+\n+    private ClouderaManagerProduct getCdhService(Set<ClouderaManagerProduct> products) {", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "176893e061c21dd44a353a348bce4af3755e8033", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\nindex 97d6712ee5..987ad5e67f 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n\n@@ -183,13 +183,13 @@ public class ClouderaManagerModificationService implements ClusterModificationSe\n             checkParcelApiAvailability();\n \n             Set<ClouderaManagerProduct> services = getServices(components);\n-            ClouderaManagerProduct cdhService = getCdhService(services);\n             setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n             if (patchUpgrade) {\n-                installServices(services, parcelResourceApi);\n+                downloadAndActivateParcels(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n+                ClouderaManagerProduct cdhService = getCdhService(services);\n                 upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n                 upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY3OTUxMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537679511", "bodyText": "services", "author": "keyki", "createdAt": "2020-12-07T17:14:32Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcels(components);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getServices(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhServices(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhServices(services, cdhServiceName);\n+        installServices(nonCdhServices, parcelResourceApi);\n+    }\n+\n+    private void installServices(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi) throws ApiException, CloudbreakException {\n+        downloadParcel(products, parcelResourceApi);\n+        distributeParcel(products, parcelResourceApi);\n+        activateParcel(products, parcelResourceApi);\n+    }\n+\n+    private ClouderaManagerProduct getCdhService(Set<ClouderaManagerProduct> products) {\n+        return products.stream()\n+                .filter(product -> product.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n                 .findFirst()\n                 .orElseThrow(() -> new NotFoundException(\"Runtime component not found!\"));\n     }\n \n+    private Set<ClouderaManagerProduct> getNonCdhServices(Set<ClouderaManagerProduct> products, String cdhProductName) {", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "176893e061c21dd44a353a348bce4af3755e8033", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\nindex 97d6712ee5..987ad5e67f 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n\n@@ -183,13 +183,13 @@ public class ClouderaManagerModificationService implements ClusterModificationSe\n             checkParcelApiAvailability();\n \n             Set<ClouderaManagerProduct> services = getServices(components);\n-            ClouderaManagerProduct cdhService = getCdhService(services);\n             setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n             if (patchUpgrade) {\n-                installServices(services, parcelResourceApi);\n+                downloadAndActivateParcels(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n+                ClouderaManagerProduct cdhService = getCdhService(services);\n                 upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n                 upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY4MDQxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537680412", "bodyText": "services", "author": "keyki", "createdAt": "2020-12-07T17:15:39Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcels(components);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getServices(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhServices(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhServices(services, cdhServiceName);\n+        installServices(nonCdhServices, parcelResourceApi);\n+    }\n+\n+    private void installServices(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi) throws ApiException, CloudbreakException {\n+        downloadParcel(products, parcelResourceApi);\n+        distributeParcel(products, parcelResourceApi);\n+        activateParcel(products, parcelResourceApi);\n+    }\n+\n+    private ClouderaManagerProduct getCdhService(Set<ClouderaManagerProduct> products) {\n+        return products.stream()\n+                .filter(product -> product.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n                 .findFirst()\n                 .orElseThrow(() -> new NotFoundException(\"Runtime component not found!\"));\n     }\n \n+    private Set<ClouderaManagerProduct> getNonCdhServices(Set<ClouderaManagerProduct> products, String cdhProductName) {\n+        return products.stream()\n+                .filter(product -> !product.getName().equals(cdhProductName))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private ClouderaManagerProduct getClouderaManagerProduct(ClusterComponent clusterComponent) {\n+        try {\n+            return clusterComponent.getAttributes().get(ClouderaManagerProduct.class);\n+        } catch (IOException e) {\n+            LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n+            throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n+        }\n+    }\n+\n+    private void checkParcelApiAvailability() throws CloudbreakException {\n+        clouderaManagerParcelManagementService.checkParcelApiAvailability(stack, apiClient);\n+    }\n+\n+    private void setParcelRepo(Set<ClouderaManagerProduct> products, ClouderaManagerResourceApi clouderaManagerResourceApi) throws ApiException {", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "176893e061c21dd44a353a348bce4af3755e8033", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\nindex 97d6712ee5..987ad5e67f 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n\n@@ -183,13 +183,13 @@ public class ClouderaManagerModificationService implements ClusterModificationSe\n             checkParcelApiAvailability();\n \n             Set<ClouderaManagerProduct> services = getServices(components);\n-            ClouderaManagerProduct cdhService = getCdhService(services);\n             setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n             if (patchUpgrade) {\n-                installServices(services, parcelResourceApi);\n+                downloadAndActivateParcels(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n+                ClouderaManagerProduct cdhService = getCdhService(services);\n                 upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n                 upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyNjE1Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537826152", "bodyText": "What does this list contain on a Data Lake?", "author": "keyki", "createdAt": "2020-12-07T20:55:33Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIwNTc3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r538205774", "bodyText": "Discussed offline.", "author": "keyki", "createdAt": "2020-12-08T10:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyNjE1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "176893e061c21dd44a353a348bce4af3755e8033", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\nindex 97d6712ee5..987ad5e67f 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n\n@@ -183,13 +183,13 @@ public class ClouderaManagerModificationService implements ClusterModificationSe\n             checkParcelApiAvailability();\n \n             Set<ClouderaManagerProduct> services = getServices(components);\n-            ClouderaManagerProduct cdhService = getCdhService(services);\n             setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n             if (patchUpgrade) {\n-                installServices(services, parcelResourceApi);\n+                downloadAndActivateParcels(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n+                ClouderaManagerProduct cdhService = getCdhService(services);\n                 upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n                 upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyNjU2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537826568", "bodyText": "We need to skip this part for a DL completely.", "author": "keyki", "createdAt": "2020-12-07T20:56:17Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "176893e061c21dd44a353a348bce4af3755e8033", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\nindex 97d6712ee5..987ad5e67f 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n\n@@ -183,13 +183,13 @@ public class ClouderaManagerModificationService implements ClusterModificationSe\n             checkParcelApiAvailability();\n \n             Set<ClouderaManagerProduct> services = getServices(components);\n-            ClouderaManagerProduct cdhService = getCdhService(services);\n             setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n             if (patchUpgrade) {\n-                installServices(services, parcelResourceApi);\n+                downloadAndActivateParcels(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n+                ClouderaManagerProduct cdhService = getCdhService(services);\n                 upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n                 upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n"}}, {"oid": "176893e061c21dd44a353a348bce4af3755e8033", "url": "https://github.com/hortonworks/cloudbreak/commit/176893e061c21dd44a353a348bce4af3755e8033", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services to a new version what we burned into the new image.", "committedDate": "2020-12-08T07:04:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEwNzU3OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r538107578", "bodyText": "We should use services instead of products in these methods.", "author": "keyki", "createdAt": "2020-12-08T07:45:20Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelManagementService.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.sequenceiq.cloudbreak.cm;\n+\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isExited;\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isTimeout;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.cloudera.api.swagger.ClouderaManagerResourceApi;\n+import com.cloudera.api.swagger.ParcelResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.sequenceiq.cloudbreak.cloud.model.ClouderaManagerProduct;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.CancellationException;\n+import com.sequenceiq.cloudbreak.cm.model.ParcelResource;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollingServiceProvider;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+\n+@Service\n+class ClouderaManagerParcelManagementService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelManagementService.class);\n+\n+    @Inject\n+    private ClouderaManagerPollingServiceProvider clouderaManagerPollingServiceProvider;\n+\n+    void setParcelRepo(Set<ClouderaManagerProduct> products, ClouderaManagerResourceApi clouderaManagerResourceApi) throws ApiException {\n+        Set<String> stackProductParcels = products.stream()\n+                .map(ClouderaManagerProduct::getParcel)\n+                .collect(Collectors.toSet());\n+        LOGGER.info(\"Setting parcel repo to {}\", stackProductParcels);\n+        ApiConfigList apiConfigList = new ApiConfigList()\n+                .addItemsItem(new ApiConfig()\n+                        .name(\"remote_parcel_repo_urls\")\n+                        .value(String.join(\",\", stackProductParcels)));\n+        clouderaManagerResourceApi.updateConfig(\"Updated configurations.\", apiConfigList);\n+    }\n+\n+    void refreshParcelRepos(ClouderaManagerResourceApi clouderaManagerResourceApi, Stack stack, ApiClient apiClient) {\n+        try {\n+            ApiCommand apiCommand = clouderaManagerResourceApi.refreshParcelRepos();\n+            clouderaManagerPollingServiceProvider.startPollingCmParcelRepositoryRefresh(stack, apiClient, apiCommand.getId());\n+        } catch (ApiException e) {\n+            LOGGER.info(\"Unable to refresh parcel repo\", e);\n+            throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n+        }\n+    }\n+\n+    void downloadParcel(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi, Stack stack, ApiClient apiClient)", "originalCommit": "176893e061c21dd44a353a348bce4af3755e8033", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "63da714d3f5763b900212c30eff8b488d40eddc3", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelManagementService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelManagementService.java\nindex 3b0090d899..047fa81b58 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelManagementService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelManagementService.java\n\n@@ -35,8 +35,8 @@ class ClouderaManagerParcelManagementService {\n     @Inject\n     private ClouderaManagerPollingServiceProvider clouderaManagerPollingServiceProvider;\n \n-    void setParcelRepo(Set<ClouderaManagerProduct> products, ClouderaManagerResourceApi clouderaManagerResourceApi) throws ApiException {\n-        Set<String> stackProductParcels = products.stream()\n+    void setParcelRepo(Set<ClouderaManagerProduct> services, ClouderaManagerResourceApi clouderaManagerResourceApi) throws ApiException {\n+        Set<String> stackProductParcels = services.stream()\n                 .map(ClouderaManagerProduct::getParcel)\n                 .collect(Collectors.toSet());\n         LOGGER.info(\"Setting parcel repo to {}\", stackProductParcels);\n"}}, {"oid": "63da714d3f5763b900212c30eff8b488d40eddc3", "url": "https://github.com/hortonworks/cloudbreak/commit/63da714d3f5763b900212c30eff8b488d40eddc3", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services to a new version what we burned into the new image.", "committedDate": "2020-12-08T07:58:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODExNjk1MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r538116951", "bodyText": "Unfortunately, using the components is not going to work now. In the case of Data Lake, it will try to re-activate all parcels that are on the images and that doesn't work.", "author": "keyki", "createdAt": "2020-12-08T08:02:38Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);", "originalCommit": "63da714d3f5763b900212c30eff8b488d40eddc3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c6b677a4017dcf37718e1aa75814bb48a2b98054", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\nindex 987ad5e67f..be7113df7f 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n\n@@ -176,25 +176,24 @@ public class ClouderaManagerModificationService implements ClusterModificationSe\n         try {\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n-            MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n             startClouderaManager();\n             checkParcelApiAvailability();\n \n-            Set<ClouderaManagerProduct> services = getServices(components);\n-            setParcelRepo(services, clouderaManagerResourceApi);\n+            Set<ClouderaManagerProduct> products = getProducts(components);\n+            setParcelRepo(products, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n             if (patchUpgrade) {\n-                downloadAndActivateParcels(services, parcelResourceApi);\n+                downloadAndActivateParcels(products, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                ClouderaManagerProduct cdhService = getCdhService(services);\n-                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n-                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n-                restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n+                ClouderaManagerProduct cdhProduct = getCdhProducts(products);\n+                upgradeNonCdhProducts(products, cdhProduct.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhProduct);\n+                restartStaleServices(clustersResourceApi);\n             }\n-            removeUnusedParcels(components);\n+            removeUnusedParcelVersions(parcelResourceApi, products);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n         } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n"}}, {"oid": "c6b677a4017dcf37718e1aa75814bb48a2b98054", "url": "https://github.com/hortonworks/cloudbreak/commit/c6b677a4017dcf37718e1aa75814bb48a2b98054", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services to a new version what we burned into the new image.", "committedDate": "2020-12-08T13:55:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQyODk3MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r538428971", "bodyText": "Can you extend these with log messages? An else branch can be introduced to log that we're skipping non-cdh based activaten. On the other case we can log what are the parcel names that we are going to activate.", "author": "keyki", "createdAt": "2020-12-08T14:24:21Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,125 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n-            MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> products = getProducts(components);\n+            setParcelRepo(products, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                downloadAndActivateParcels(products, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n-                restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n+                ClouderaManagerProduct cdhProduct = getCdhProducts(products);\n+                upgradeNonCdhProducts(products, cdhProduct.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhProduct);\n+                restartStaleServices(clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcelVersions(parcelResourceApi, products);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcels(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcels(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getProducts(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhProducts(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhProducts(services, cdhServiceName);\n+        if (!nonCdhServices.isEmpty()) {", "originalCommit": "c6b677a4017dcf37718e1aa75814bb48a2b98054", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3dd2e3743b309a7d2b9ee6625d9824d692de3d5a", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\nindex be7113df7f..77044fe2f6 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n\n@@ -174,6 +174,7 @@ public class ClouderaManagerModificationService implements ClusterModificationSe\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n+            LOGGER.info(\"Starting to upgrade cluster runtimes. Patch upgrade: {}\", patchUpgrade);\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQyOTE1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r538429153", "bodyText": "services -> products", "author": "keyki", "createdAt": "2020-12-08T14:24:30Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,125 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n-            MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> products = getProducts(components);\n+            setParcelRepo(products, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                downloadAndActivateParcels(products, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n-                restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n+                ClouderaManagerProduct cdhProduct = getCdhProducts(products);\n+                upgradeNonCdhProducts(products, cdhProduct.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhProduct);\n+                restartStaleServices(clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcelVersions(parcelResourceApi, products);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcels(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcels(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getProducts(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhProducts(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)", "originalCommit": "c6b677a4017dcf37718e1aa75814bb48a2b98054", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3dd2e3743b309a7d2b9ee6625d9824d692de3d5a", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\nindex be7113df7f..77044fe2f6 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java\n\n@@ -174,6 +174,7 @@ public class ClouderaManagerModificationService implements ClusterModificationSe\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n+            LOGGER.info(\"Starting to upgrade cluster runtimes. Patch upgrade: {}\", patchUpgrade);\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ1NzU3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r538457577", "bodyText": "Can you please add a log message that we're skipping the CSD update because it's a Data Lake", "author": "keyki", "createdAt": "2020-12-08T14:51:17Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/cluster/ClusterManagerUpgradeService.java", "diffHunk": "@@ -98,12 +99,19 @@ private void startClusterServices(Stack stack) throws CloudbreakException {\n         clusterApiConnectors.getConnector(stack).startCluster();\n     }\n \n-    private SaltConfig createSaltConfig(Cluster cluster) {\n+    private SaltConfig createSaltConfig(Long stackId, StackType stackType, Cluster cluster) {\n         Map<String, SaltPillarProperties> servicePillar = new HashMap<>();\n         ClouderaManagerRepo clouderaManagerRepo = clusterComponentConfigProvider.getClouderaManagerRepoDetails(cluster.getId());\n-        Optional<String> license = clusterHostServiceRunner.decoratePillarWithClouderaManagerLicense(cluster.getStack().getId(), servicePillar);\n+        Optional<String> license = clusterHostServiceRunner.decoratePillarWithClouderaManagerLicense(stackId, servicePillar);\n         clusterHostServiceRunner.decoratePillarWithClouderaManagerRepo(clouderaManagerRepo, servicePillar, license);\n         clusterHostServiceRunner.decoratePillarWithClouderaManagerSettings(servicePillar, clouderaManagerRepo);\n+        decorateWorkloadClusterPillarWithCsdDownloader(stackType, cluster, servicePillar);\n         return new SaltConfig(servicePillar);\n     }\n+\n+    private void decorateWorkloadClusterPillarWithCsdDownloader(StackType stackType, Cluster cluster, Map<String, SaltPillarProperties> servicePillar) {\n+        if (StackType.WORKLOAD.equals(stackType)) {", "originalCommit": "c6b677a4017dcf37718e1aa75814bb48a2b98054", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3dd2e3743b309a7d2b9ee6625d9824d692de3d5a", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/core/cluster/ClusterManagerUpgradeService.java b/core/src/main/java/com/sequenceiq/cloudbreak/core/cluster/ClusterManagerUpgradeService.java\nindex d27673027b..93b7dfb33f 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/core/cluster/ClusterManagerUpgradeService.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/core/cluster/ClusterManagerUpgradeService.java\n\n@@ -112,6 +112,8 @@ public class ClusterManagerUpgradeService {\n     private void decorateWorkloadClusterPillarWithCsdDownloader(StackType stackType, Cluster cluster, Map<String, SaltPillarProperties> servicePillar) {\n         if (StackType.WORKLOAD.equals(stackType)) {\n             clusterHostServiceRunner.decoratePillarWithClouderaManagerCsds(cluster, servicePillar);\n+        } else {\n+            LOGGER.debug(\"Skipping the CSD downloading because the stack type is {}\", stackType);\n         }\n     }\n }\n"}}, {"oid": "3dd2e3743b309a7d2b9ee6625d9824d692de3d5a", "url": "https://github.com/hortonworks/cloudbreak/commit/3dd2e3743b309a7d2b9ee6625d9824d692de3d5a", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services.\n\nIn this commit we've introduced some changes in connection with Data Hub upgrade:\n- CSD downloading: To upgrade a non-CDH service may require the same version of the CSD what the new version is. By default the old CSD files are already present in the image, therefore we need to download the new ones. This process is handled by a shell script that we add to the host at the beginning of the upgrade process.\n  In the case of Data Lake upgrade, we don't need to download the new CSD files because we're not upgrading the non-CDH services.\n\n- Upgrading the non-CDH services (Spark, Nifi, etc...) has a different flow than the regular CDH runtime upgrade. We need to download, distribute, and activate the new parcels, then restart the affected services. There is no upgrade command to call.\n  After the non-CDH services have been upgraded the flow continues with upgrading the CDH runtime. This whole process does not affect to the Data Lake upgrade flow. We just upgrade only the CDH version like before.", "committedDate": "2020-12-09T13:16:35Z", "type": "forcePushed"}, {"oid": "ea33bf51fad282def4ee059698c8eb1fabda08da", "url": "https://github.com/hortonworks/cloudbreak/commit/ea33bf51fad282def4ee059698c8eb1fabda08da", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services.\n\nIn this commit we've introduced some changes in connection with Data Hub upgrade:\n- CSD downloading: To upgrade a non-CDH service may require the same version of the CSD what the new version is. By default the old CSD files are already present in the image, therefore we need to download the new ones. This process is handled by a shell script that we add to the host at the beginning of the upgrade process.\n  In the case of Data Lake upgrade, we don't need to download the new CSD files because we're not upgrading the non-CDH services.\n\n- Upgrading the non-CDH services (Spark, Nifi, etc...) has a different flow than the regular CDH runtime upgrade. We need to download, distribute, and activate the new parcels, then restart the affected services. There is no upgrade command to call.\n  After the non-CDH services have been upgraded the flow continues with upgrading the CDH runtime. This whole process does not affect to the Data Lake upgrade flow. We just upgrade only the CDH version like before.", "committedDate": "2020-12-09T14:06:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4ODEwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r539388101", "bodyText": "Can you please cover this part with a unit test to make sure we don't update the CSDs in the case of Data Lake. If we break this then the complete Data Lake upgrade will be broken as the CSDs are not downloadable outside of Cloudera.", "author": "keyki", "createdAt": "2020-12-09T15:11:35Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/cluster/ClusterManagerUpgradeService.java", "diffHunk": "@@ -98,12 +99,21 @@ private void startClusterServices(Stack stack) throws CloudbreakException {\n         clusterApiConnectors.getConnector(stack).startCluster();\n     }\n \n-    private SaltConfig createSaltConfig(Cluster cluster) {\n+    private SaltConfig createSaltConfig(Long stackId, StackType stackType, Cluster cluster) {\n         Map<String, SaltPillarProperties> servicePillar = new HashMap<>();\n         ClouderaManagerRepo clouderaManagerRepo = clusterComponentConfigProvider.getClouderaManagerRepoDetails(cluster.getId());\n-        Optional<String> license = clusterHostServiceRunner.decoratePillarWithClouderaManagerLicense(cluster.getStack().getId(), servicePillar);\n+        Optional<String> license = clusterHostServiceRunner.decoratePillarWithClouderaManagerLicense(stackId, servicePillar);\n         clusterHostServiceRunner.decoratePillarWithClouderaManagerRepo(clouderaManagerRepo, servicePillar, license);\n         clusterHostServiceRunner.decoratePillarWithClouderaManagerSettings(servicePillar, clouderaManagerRepo);\n+        decorateWorkloadClusterPillarWithCsdDownloader(stackType, cluster, servicePillar);\n         return new SaltConfig(servicePillar);\n     }\n+\n+    private void decorateWorkloadClusterPillarWithCsdDownloader(StackType stackType, Cluster cluster, Map<String, SaltPillarProperties> servicePillar) {\n+        if (StackType.WORKLOAD.equals(stackType)) {", "originalCommit": "ea33bf51fad282def4ee059698c8eb1fabda08da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQxMTYyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r539411628", "bodyText": "Also, this could be improved that only update the CSDs if needed and those CSDs that are needed. But this does not need to be part of this PR.  (Filed a jira for this one CB-10265)", "author": "keyki", "createdAt": "2020-12-09T15:38:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4ODEwMQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "dec7e013ca68fa7597188952d5bb435ffea70d9d", "url": "https://github.com/hortonworks/cloudbreak/commit/dec7e013ca68fa7597188952d5bb435ffea70d9d", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services.\n\nIn this commit we've introduced some changes in connection with Data Hub upgrade:\n- CSD downloading: To upgrade a non-CDH service may require the same version of the CSD what the new version is. By default the old CSD files are already present in the image, therefore we need to download the new ones. This process is handled by a shell script that we add to the host at the beginning of the upgrade process.\n  In the case of Data Lake upgrade, we don't need to download the new CSD files because we're not upgrading the non-CDH services.\n\n- Upgrading the non-CDH services (Spark, Nifi, etc...) has a different flow than the regular CDH runtime upgrade. We need to download, distribute, and activate the new parcels, then restart the affected services. There is no upgrade command to call.\n  After the non-CDH services have been upgraded the flow continues with upgrading the CDH runtime. This whole process does not affect to the Data Lake upgrade flow. We just upgrade only the CDH version like before.", "committedDate": "2020-12-09T17:03:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA1ODY4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r540058684", "bodyText": "this part is duplicated a few times, message maybe different a bit, but that could be a parameter", "author": "lacikaaa", "createdAt": "2020-12-10T10:36:26Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelManagementService.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package com.sequenceiq.cloudbreak.cm;\n+\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isExited;\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isTimeout;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.cloudera.api.swagger.ClouderaManagerResourceApi;\n+import com.cloudera.api.swagger.ParcelResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.sequenceiq.cloudbreak.cloud.model.ClouderaManagerProduct;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.CancellationException;\n+import com.sequenceiq.cloudbreak.cm.model.ParcelResource;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollingServiceProvider;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+\n+@Service\n+class ClouderaManagerParcelManagementService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelManagementService.class);\n+\n+    @Inject\n+    private ClouderaManagerPollingServiceProvider clouderaManagerPollingServiceProvider;\n+\n+    void setParcelRepos(Set<ClouderaManagerProduct> products, ClouderaManagerResourceApi clouderaManagerResourceApi) throws ApiException {\n+        Set<String> stackProductParcels = products.stream()\n+                .map(ClouderaManagerProduct::getParcel)\n+                .collect(Collectors.toSet());\n+        LOGGER.info(\"Setting parcel repo to {}\", stackProductParcels);\n+        ApiConfigList apiConfigList = new ApiConfigList()\n+                .addItemsItem(new ApiConfig()\n+                        .name(\"remote_parcel_repo_urls\")\n+                        .value(String.join(\",\", stackProductParcels)));\n+        clouderaManagerResourceApi.updateConfig(\"Updated configurations.\", apiConfigList);\n+    }\n+\n+    void refreshParcelRepos(ClouderaManagerResourceApi clouderaManagerResourceApi, Stack stack, ApiClient apiClient) {\n+        try {\n+            LOGGER.info(\"Refreshing parcel repos.\");\n+            ApiCommand apiCommand = clouderaManagerResourceApi.refreshParcelRepos();\n+            clouderaManagerPollingServiceProvider.startPollingCmParcelRepositoryRefresh(stack, apiClient, apiCommand.getId());\n+        } catch (ApiException e) {\n+            LOGGER.info(\"Unable to refresh parcel repo\", e);\n+            throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n+        }\n+    }\n+\n+    void downloadParcels(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi, Stack stack, ApiClient apiClient)\n+            throws ApiException, CloudbreakException {\n+        for (ClouderaManagerProduct product : products) {\n+            LOGGER.info(\"Downloading {} parcel.\", product.getName());\n+            ApiCommand apiCommand = parcelResourceApi.startDownloadCommand(stack.getName(), product.getName(), product.getVersion());\n+            PollingResult pollingResult = clouderaManagerPollingServiceProvider.startPollingCdpRuntimeParcelDownload(\n+                    stack, apiClient, apiCommand.getId(), new ParcelResource(stack.getName(), product.getName(), product.getVersion()));\n+            if (isExited(pollingResult)) {\n+                throw new CancellationException(\"Cluster was terminated while waiting for CDP Runtime Parcel to be downloaded\");\n+            } else if (isTimeout(pollingResult)) {\n+                throw new CloudbreakException(\"Timeout during the updated CDP Runtime Parcel download.\");\n+            }", "originalCommit": "dec7e013ca68fa7597188952d5bb435ffea70d9d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "28319cc0f8cb174591627f8857853484f31208cd", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelManagementService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelManagementService.java\nindex 869b462d1b..bf25853a56 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelManagementService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelManagementService.java\n\n@@ -1,8 +1,5 @@\n package com.sequenceiq.cloudbreak.cm;\n \n-import static com.sequenceiq.cloudbreak.polling.PollingResult.isExited;\n-import static com.sequenceiq.cloudbreak.polling.PollingResult.isTimeout;\n-\n import java.util.Set;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA1OTkzOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r540059939", "bodyText": "it's kinda the same here, duplicating the same 5 lines, maybe it should be moved some util like thing or a component", "author": "lacikaaa", "createdAt": "2020-12-10T10:38:16Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerUpgradeService.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.cloudbreak.cm;\n+\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isExited;\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isTimeout;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiCdhUpgradeArgs;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiCommandList;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.CancellationException;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollingServiceProvider;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+\n+@Service\n+class ClouderaManagerUpgradeService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerUpgradeService.class);\n+\n+    private static final String SUMMARY = \"SUMMARY\";\n+\n+    @Inject\n+    private ClouderaManagerPollingServiceProvider clouderaManagerPollingServiceProvider;\n+\n+    void callUpgradeCdhCommand(String stackProductVersion, ClustersResourceApi clustersResourceApi, Stack stack, ApiClient apiClient)\n+            throws ApiException, CloudbreakException {\n+        LOGGER.info(\"Upgrading the CDP Runtime...\");\n+        Optional<ApiCommand> optionalUpgradeCommand = findUpgradeApiCommand(clustersResourceApi, stack);\n+        try {\n+            ApiCommand upgradeCommand;\n+            if (optionalUpgradeCommand.isPresent()) {\n+                upgradeCommand = optionalUpgradeCommand.get();\n+                LOGGER.debug(\"Upgrade of CDP Runtime is already running with id: [{}]\", upgradeCommand.getId());\n+            } else {\n+                ApiCdhUpgradeArgs upgradeArgs = new ApiCdhUpgradeArgs();\n+                upgradeArgs.setCdhParcelVersion(stackProductVersion);\n+                upgradeCommand = clustersResourceApi.upgradeCdhCommand(stack.getName(), upgradeArgs);\n+            }\n+            PollingResult pollingResult = clouderaManagerPollingServiceProvider.startPollingCdpRuntimeUpgrade(stack, apiClient, upgradeCommand.getId());\n+            if (isExited(pollingResult)) {\n+                throw new CancellationException(\"Cluster was terminated while waiting for CDP Runtime to be upgraded\");\n+            } else if (isTimeout(pollingResult)) {\n+                throw new CloudbreakException(\"Timeout during CDP Runtime upgrade.\");\n+            }", "originalCommit": "dec7e013ca68fa7597188952d5bb435ffea70d9d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "28319cc0f8cb174591627f8857853484f31208cd", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerUpgradeService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerUpgradeService.java\nindex cd05b7e252..7e81797a82 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerUpgradeService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerUpgradeService.java\n\n@@ -1,8 +1,5 @@\n package com.sequenceiq.cloudbreak.cm;\n \n-import static com.sequenceiq.cloudbreak.polling.PollingResult.isExited;\n-import static com.sequenceiq.cloudbreak.polling.PollingResult.isTimeout;\n-\n import java.util.Optional;\n \n import javax.inject.Inject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA2MDg0MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r540060840", "bodyText": "null check for response body?", "author": "lacikaaa", "createdAt": "2020-12-10T10:39:33Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerUpgradeService.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.cloudbreak.cm;\n+\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isExited;\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isTimeout;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiCdhUpgradeArgs;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiCommandList;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.CancellationException;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollingServiceProvider;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+\n+@Service\n+class ClouderaManagerUpgradeService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerUpgradeService.class);\n+\n+    private static final String SUMMARY = \"SUMMARY\";\n+\n+    @Inject\n+    private ClouderaManagerPollingServiceProvider clouderaManagerPollingServiceProvider;\n+\n+    void callUpgradeCdhCommand(String stackProductVersion, ClustersResourceApi clustersResourceApi, Stack stack, ApiClient apiClient)\n+            throws ApiException, CloudbreakException {\n+        LOGGER.info(\"Upgrading the CDP Runtime...\");\n+        Optional<ApiCommand> optionalUpgradeCommand = findUpgradeApiCommand(clustersResourceApi, stack);\n+        try {\n+            ApiCommand upgradeCommand;\n+            if (optionalUpgradeCommand.isPresent()) {\n+                upgradeCommand = optionalUpgradeCommand.get();\n+                LOGGER.debug(\"Upgrade of CDP Runtime is already running with id: [{}]\", upgradeCommand.getId());\n+            } else {\n+                ApiCdhUpgradeArgs upgradeArgs = new ApiCdhUpgradeArgs();\n+                upgradeArgs.setCdhParcelVersion(stackProductVersion);\n+                upgradeCommand = clustersResourceApi.upgradeCdhCommand(stack.getName(), upgradeArgs);\n+            }\n+            PollingResult pollingResult = clouderaManagerPollingServiceProvider.startPollingCdpRuntimeUpgrade(stack, apiClient, upgradeCommand.getId());\n+            if (isExited(pollingResult)) {\n+                throw new CancellationException(\"Cluster was terminated while waiting for CDP Runtime to be upgraded\");\n+            } else if (isTimeout(pollingResult)) {\n+                throw new CloudbreakException(\"Timeout during CDP Runtime upgrade.\");\n+            }\n+        } catch (ApiException ex) {\n+            if (ex.getResponseBody().contains(\"Cannot upgrade because the version is already CDH\")) {", "originalCommit": "dec7e013ca68fa7597188952d5bb435ffea70d9d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "28319cc0f8cb174591627f8857853484f31208cd", "chunk": "diff --git a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerUpgradeService.java b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerUpgradeService.java\nindex cd05b7e252..7e81797a82 100644\n--- a/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerUpgradeService.java\n+++ b/cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerUpgradeService.java\n\n@@ -1,8 +1,5 @@\n package com.sequenceiq.cloudbreak.cm;\n \n-import static com.sequenceiq.cloudbreak.polling.PollingResult.isExited;\n-import static com.sequenceiq.cloudbreak.polling.PollingResult.isTimeout;\n-\n import java.util.Optional;\n \n import javax.inject.Inject;\n"}}, {"oid": "28319cc0f8cb174591627f8857853484f31208cd", "url": "https://github.com/hortonworks/cloudbreak/commit/28319cc0f8cb174591627f8857853484f31208cd", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services.\n\nIn this commit we've introduced some changes in connection with Data Hub upgrade:\n- CSD downloading: To upgrade a non-CDH service may require the same version of the CSD what the new version is. By default the old CSD files are already present in the image, therefore we need to download the new ones. This process is handled by a shell script that we add to the host at the beginning of the upgrade process.\n  In the case of Data Lake upgrade, we don't need to download the new CSD files because we're not upgrading the non-CDH services.\n\n- Upgrading the non-CDH services (Spark, Nifi, etc...) has a different flow than the regular CDH runtime upgrade. We need to download, distribute, and activate the new parcels, then restart the affected services. There is no upgrade command to call.\n  After the non-CDH services have been upgraded the flow continues with upgrading the CDH runtime. This whole process does not affect to the Data Lake upgrade flow. We just upgrade only the CDH version like before.", "committedDate": "2020-12-10T16:59:43Z", "type": "commit"}, {"oid": "28319cc0f8cb174591627f8857853484f31208cd", "url": "https://github.com/hortonworks/cloudbreak/commit/28319cc0f8cb174591627f8857853484f31208cd", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services.\n\nIn this commit we've introduced some changes in connection with Data Hub upgrade:\n- CSD downloading: To upgrade a non-CDH service may require the same version of the CSD what the new version is. By default the old CSD files are already present in the image, therefore we need to download the new ones. This process is handled by a shell script that we add to the host at the beginning of the upgrade process.\n  In the case of Data Lake upgrade, we don't need to download the new CSD files because we're not upgrading the non-CDH services.\n\n- Upgrading the non-CDH services (Spark, Nifi, etc...) has a different flow than the regular CDH runtime upgrade. We need to download, distribute, and activate the new parcels, then restart the affected services. There is no upgrade command to call.\n  After the non-CDH services have been upgraded the flow continues with upgrading the CDH runtime. This whole process does not affect to the Data Lake upgrade flow. We just upgrade only the CDH version like before.", "committedDate": "2020-12-10T16:59:43Z", "type": "forcePushed"}]}