{"pr_number": 8188, "pr_title": "DISTX-399 DataHub Autoscaling", "pr_createdAt": "2020-06-01T18:30:56Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8188", "timeline": [{"oid": "f681883d1c0c19cfa91ecdd5ef869c12f8a0ebd4", "url": "https://github.com/hortonworks/cloudbreak/commit/f681883d1c0c19cfa91ecdd5ef869c12f8a0ebd4", "message": "DISTX-399 DataHub Autoscaling\n\n1.  Introduce DistroXAutoscale Endpoint for DataHub Autoscaling.\n2.  Disable unused AlertEndpoint.\n3.  Introduce Entitlements validation for DataHub Autoscaling.\n4.  Introduce YarnBased Autoscaling Evaluator and Monitor.\n5.  Introduce RemovableCluster Monitor to track and remove CB deleted clusters.\n6.  Introduce DistroXAutoscale endpoint tests.", "committedDate": "2020-06-02T07:29:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg4NDE5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r434884197", "bodyText": "May have asked this earlier; is this annotation required?", "author": "sidseth", "createdAt": "2020-06-03T22:06:00Z", "path": "autoscale/src/test/java/com/sequenceiq/periscope/modul/rejected/RejectedThreadContext.java", "diffHunk": "@@ -59,6 +60,7 @@\n     @MockBean({Clock.class, ClusterService.class, CloudbreakClientConfiguration.class,\n             MetricUtils.class, InternalCrnBuilder.class, FailedNodeRepository.class})\n     @EnableAsync\n+    @Profile(\"devtest\")", "originalCommit": "f681883d1c0c19cfa91ecdd5ef869c12f8a0ebd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA2NTcyNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435065725", "bodyText": "Nested SpringConfig in RejectedThreadContext is basically a TestContext.  Without the profile filter this would result in duplicate  bean definition for periscopeListeningScheduledExecutorService and fails integration endpoint tests which run tests against embedded tomcat and embedded db. Earlier there wasn't any service integration tests hence the missing annotation did not cause any issue.", "author": "smaniraju", "createdAt": "2020-06-04T08:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg4NDE5Nw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "url": "https://github.com/hortonworks/cloudbreak/commit/d8ee7e1c27320672da427a3b05c3bc5396700d34", "message": "DISTX-399 DataHub Autoscaling\n\n1.  Introduce DistroXAutoscale Endpoint for DataHub Autoscaling.\n2.  Disable unused AlertEndpoint.\n3.  Introduce Entitlements validation for DataHub Autoscaling.\n4.  Introduce YarnBased Autoscaling Evaluator and Monitor.\n5.  Introduce RemovableCluster Monitor to track and remove CB deleted clusters.\n6.  Introduce DistroXAutoscale endpoint tests.", "committedDate": "2020-06-04T07:20:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NjcyOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435186729", "bodyText": "our url patter is separated by _, please change to autoscale_config and the other URL as well", "author": "topolyai5", "createdAt": "2020-06-04T11:35:28Z", "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.sequenceiq.periscope.api.endpoint.v1;\n+\n+import static com.sequenceiq.periscope.doc.ApiDescription.CLUSTERS_DESCRIPTION;\n+\n+import java.util.List;\n+\n+import javax.validation.Valid;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import com.sequenceiq.periscope.api.endpoint.validator.ValidDistroXAutoscaleRequest;\n+import com.sequenceiq.periscope.api.model.AutoscaleClusterState;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterResponse;\n+import com.sequenceiq.periscope.doc.ApiDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.ClusterOpDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.DistroXClusterNotes;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+\n+@Path(\"/v1/distrox\")\n+@Consumes(MediaType.APPLICATION_JSON)\n+@Api(value = \"/v1/distrox\", description = CLUSTERS_DESCRIPTION, protocols = \"http,https\", consumes = MediaType.APPLICATION_JSON)\n+public interface DistroXAutoScaleClusterV1Endpoint {\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET_ALL, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    List<DistroXAutoscaleClusterResponse> getClusters();\n+\n+    @GET\n+    @Path(\"crn/{crn}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByCrn(@PathParam(\"crn\") String clusterCrn);\n+\n+    @GET\n+    @Path(\"name/{name}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByName(@PathParam(\"name\") String clusterName);\n+\n+    @POST\n+    @Path(\"crn/{crn}/autoscaleconfig\")", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0Njg3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435746874", "bodyText": "ok", "author": "smaniraju", "createdAt": "2020-06-05T07:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NjcyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "chunk": "diff --git a/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java b/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java\nindex 4664dd9f52..091ec9c75d 100644\n--- a/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java\n+++ b/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java\n\n@@ -48,14 +48,14 @@ public interface DistroXAutoScaleClusterV1Endpoint {\n     DistroXAutoscaleClusterResponse getClusterByName(@PathParam(\"name\") String clusterName);\n \n     @POST\n-    @Path(\"crn/{crn}/autoscaleconfig\")\n+    @Path(\"crn/{crn}/autoscale_config\")\n     @Produces(MediaType.APPLICATION_JSON)\n     @ApiOperation(value = ClusterOpDescription.CLUSTER_UPDATE_AUTOSCALE_CONFIG, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n     DistroXAutoscaleClusterResponse updateAutoscaleConfigByClusterCrn(@PathParam(\"crn\") String clusterCrn,\n             @ValidDistroXAutoscaleRequest @Valid DistroXAutoscaleClusterRequest autoscaleClusterRequest);\n \n     @POST\n-    @Path(\"name/{name}/autoscaleconfig\")\n+    @Path(\"name/{name}/autoscale_config\")\n     @Produces(MediaType.APPLICATION_JSON)\n     @ApiOperation(value = ClusterOpDescription.CLUSTER_UPDATE_AUTOSCALE_CONFIG, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n     DistroXAutoscaleClusterResponse updateAutoscaleConfigByClusterName(@PathParam(\"name\") String clusterName,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzM4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435187386", "bodyText": "separate by _", "author": "topolyai5", "createdAt": "2020-06-04T11:36:43Z", "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.sequenceiq.periscope.api.endpoint.v1;\n+\n+import static com.sequenceiq.periscope.doc.ApiDescription.CLUSTERS_DESCRIPTION;\n+\n+import java.util.List;\n+\n+import javax.validation.Valid;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import com.sequenceiq.periscope.api.endpoint.validator.ValidDistroXAutoscaleRequest;\n+import com.sequenceiq.periscope.api.model.AutoscaleClusterState;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterResponse;\n+import com.sequenceiq.periscope.doc.ApiDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.ClusterOpDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.DistroXClusterNotes;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+\n+@Path(\"/v1/distrox\")\n+@Consumes(MediaType.APPLICATION_JSON)\n+@Api(value = \"/v1/distrox\", description = CLUSTERS_DESCRIPTION, protocols = \"http,https\", consumes = MediaType.APPLICATION_JSON)\n+public interface DistroXAutoScaleClusterV1Endpoint {\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET_ALL, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    List<DistroXAutoscaleClusterResponse> getClusters();\n+\n+    @GET\n+    @Path(\"crn/{crn}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByCrn(@PathParam(\"crn\") String clusterCrn);\n+\n+    @GET\n+    @Path(\"name/{name}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByName(@PathParam(\"name\") String clusterName);\n+\n+    @POST\n+    @Path(\"crn/{crn}/autoscaleconfig\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_UPDATE_AUTOSCALE_CONFIG, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse updateAutoscaleConfigByClusterCrn(@PathParam(\"crn\") String clusterCrn,\n+            @ValidDistroXAutoscaleRequest @Valid DistroXAutoscaleClusterRequest autoscaleClusterRequest);\n+\n+    @POST\n+    @Path(\"name/{name}/autoscaleconfig\")", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0Njk0MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435746940", "bodyText": "ok", "author": "smaniraju", "createdAt": "2020-06-05T07:46:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzM4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "chunk": "diff --git a/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java b/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java\nindex 4664dd9f52..091ec9c75d 100644\n--- a/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java\n+++ b/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java\n\n@@ -48,14 +48,14 @@ public interface DistroXAutoScaleClusterV1Endpoint {\n     DistroXAutoscaleClusterResponse getClusterByName(@PathParam(\"name\") String clusterName);\n \n     @POST\n-    @Path(\"crn/{crn}/autoscaleconfig\")\n+    @Path(\"crn/{crn}/autoscale_config\")\n     @Produces(MediaType.APPLICATION_JSON)\n     @ApiOperation(value = ClusterOpDescription.CLUSTER_UPDATE_AUTOSCALE_CONFIG, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n     DistroXAutoscaleClusterResponse updateAutoscaleConfigByClusterCrn(@PathParam(\"crn\") String clusterCrn,\n             @ValidDistroXAutoscaleRequest @Valid DistroXAutoscaleClusterRequest autoscaleClusterRequest);\n \n     @POST\n-    @Path(\"name/{name}/autoscaleconfig\")\n+    @Path(\"name/{name}/autoscale_config\")\n     @Produces(MediaType.APPLICATION_JSON)\n     @ApiOperation(value = ClusterOpDescription.CLUSTER_UPDATE_AUTOSCALE_CONFIG, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n     DistroXAutoscaleClusterResponse updateAutoscaleConfigByClusterName(@PathParam(\"name\") String clusterName,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDA0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435190046", "bodyText": "why do you use fully qualified name?", "author": "topolyai5", "createdAt": "2020-06-04T11:42:02Z", "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package com.sequenceiq.periscope.api.endpoint.validator;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.ConstraintValidator;\n+import javax.validation.ConstraintValidatorContext;\n+\n+import com.sequenceiq.periscope.api.model.AdjustmentType;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+\n+public class DistroXAutoscaleRequestValidator\n+        implements ConstraintValidator<ValidDistroXAutoscaleRequest, DistroXAutoscaleClusterRequest> {\n+\n+    @Override\n+    public boolean isValid(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+\n+        if (!request.getLoadAlertRequests().isEmpty() &&\n+                !request.getTimeAlertRequests().isEmpty()) {\n+            String message = String.format(\"Cluster can be configured with only one type of autoscaling policies.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"autoscalingPolicy\")\n+                    .disableDefaultConstraintViolation();\n+            return false;\n+        }\n+\n+        if (!request.getLoadAlertRequests().isEmpty()) {\n+            return isValidLoadAlertRequests(request, context);\n+        }\n+\n+        return true;\n+    }\n+\n+    private Boolean isValidLoadAlertRequests(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+        Set<String> distinctLoadBasedHostGroups = new HashSet<>();\n+        Set<AdjustmentType> distinctLoadBasedAdjustmentTypes = new HashSet<>();\n+\n+        if (request.getLoadAlertRequests().size() > 1) {\n+            String message = String.format(\"LoadBased autoscaling currently supports a single HostGroup in a Cluster.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"loadAlertRequests\")", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0NzYxNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435747615", "bodyText": "fixed", "author": "smaniraju", "createdAt": "2020-06-05T07:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDA0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "chunk": "diff --git a/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java b/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java\nindex 3bde9965b3..6c91df0443 100644\n--- a/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java\n+++ b/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java\n\n@@ -7,6 +7,7 @@ import java.util.stream.Collectors;\n import javax.validation.ConstraintValidator;\n import javax.validation.ConstraintValidatorContext;\n \n+import com.sequenceiq.cloudbreak.validation.ValidatorUtil;\n import com.sequenceiq.periscope.api.model.AdjustmentType;\n import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDc2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435190762", "bodyText": "you can do this in the same map", "author": "topolyai5", "createdAt": "2020-06-04T11:43:25Z", "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package com.sequenceiq.periscope.api.endpoint.validator;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.ConstraintValidator;\n+import javax.validation.ConstraintValidatorContext;\n+\n+import com.sequenceiq.periscope.api.model.AdjustmentType;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+\n+public class DistroXAutoscaleRequestValidator\n+        implements ConstraintValidator<ValidDistroXAutoscaleRequest, DistroXAutoscaleClusterRequest> {\n+\n+    @Override\n+    public boolean isValid(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+\n+        if (!request.getLoadAlertRequests().isEmpty() &&\n+                !request.getTimeAlertRequests().isEmpty()) {\n+            String message = String.format(\"Cluster can be configured with only one type of autoscaling policies.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"autoscalingPolicy\")\n+                    .disableDefaultConstraintViolation();\n+            return false;\n+        }\n+\n+        if (!request.getLoadAlertRequests().isEmpty()) {\n+            return isValidLoadAlertRequests(request, context);\n+        }\n+\n+        return true;\n+    }\n+\n+    private Boolean isValidLoadAlertRequests(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+        Set<String> distinctLoadBasedHostGroups = new HashSet<>();\n+        Set<AdjustmentType> distinctLoadBasedAdjustmentTypes = new HashSet<>();\n+\n+        if (request.getLoadAlertRequests().size() > 1) {\n+            String message = String.format(\"LoadBased autoscaling currently supports a single HostGroup in a Cluster.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"loadAlertRequests\")\n+                    .disableDefaultConstraintViolation();\n+            return false;\n+        }\n+\n+        Set<String> duplicateHostGroups =\n+                request.getLoadAlertRequests().stream()\n+                        .map(loadAlertRequest -> loadAlertRequest.getScalingPolicy())\n+                        .map(scalingPolicyRequest -> {\n+                            distinctLoadBasedAdjustmentTypes.add(scalingPolicyRequest.getAdjustmentType());\n+                            return scalingPolicyRequest;\n+                        })\n+                        .map(scalingPolicyRequest -> scalingPolicyRequest.getHostGroup())", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0Nzc1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435747750", "bodyText": "ok", "author": "smaniraju", "createdAt": "2020-06-05T07:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDc2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "chunk": "diff --git a/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java b/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java\nindex 3bde9965b3..6c91df0443 100644\n--- a/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java\n+++ b/autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java\n\n@@ -7,6 +7,7 @@ import java.util.stream.Collectors;\n import javax.validation.ConstraintValidator;\n import javax.validation.ConstraintValidatorContext;\n \n+import com.sequenceiq.cloudbreak.validation.ValidatorUtil;\n import com.sequenceiq.periscope.api.model.AdjustmentType;\n import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4MTQ5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435281493", "bodyText": "You can use the DefaultEnumConverter", "author": "topolyai5", "createdAt": "2020-06-04T14:01:34Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/converter/db/StackTypeAttributeConverter.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.periscope.converter.db;\n+\n+import javax.persistence.AttributeConverter;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.StackType;\n+\n+public class StackTypeAttributeConverter implements AttributeConverter<StackType, String> {", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0ODc3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435748779", "bodyText": "ok", "author": "smaniraju", "createdAt": "2020-06-05T07:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4MTQ5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "chunk": "diff --git a/autoscale/src/main/java/com/sequenceiq/periscope/converter/db/StackTypeAttributeConverter.java b/autoscale/src/main/java/com/sequenceiq/periscope/converter/db/StackTypeAttributeConverter.java\nindex a39e4805a2..d6d8636a5c 100644\n--- a/autoscale/src/main/java/com/sequenceiq/periscope/converter/db/StackTypeAttributeConverter.java\n+++ b/autoscale/src/main/java/com/sequenceiq/periscope/converter/db/StackTypeAttributeConverter.java\n\n@@ -1,27 +1,12 @@\n package com.sequenceiq.periscope.converter.db;\n \n-import javax.persistence.AttributeConverter;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import com.sequenceiq.cloudbreak.api.endpoint.v4.common.StackType;\n+import com.sequenceiq.cloudbreak.converter.DefaultEnumConverter;\n \n-public class StackTypeAttributeConverter implements AttributeConverter<StackType, String> {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(StackTypeAttributeConverter.class);\n-\n-    @Override\n-    public String convertToDatabaseColumn(StackType attribute) {\n-        return attribute.name();\n-    }\n+public class StackTypeAttributeConverter extends DefaultEnumConverter<StackType> {\n \n     @Override\n-    public StackType convertToEntityAttribute(String dbData) {\n-        try {\n-            return StackType.valueOf(dbData);\n-        } catch (Exception e) {\n-            LOGGER.info(\"The StackType value is not backward compatible: {}\", dbData);\n-        }\n-        return StackType.DATALAKE;\n+    public StackType getDefault() {\n+        return StackType.TEMPLATE;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NDMwMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435284303", "bodyText": "why not null?", "author": "topolyai5", "createdAt": "2020-06-04T14:05:06Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package com.sequenceiq.periscope.monitor.evaluator.load;\n+\n+import static com.sequenceiq.periscope.monitor.evaluator.ScalingConstants.DEFAULT_MAX_SCALE_UP_STEP_SIZE;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.annotation.Nonnull;\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackV4Response;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.LoadAlert;\n+import com.sequenceiq.periscope.domain.LoadAlertConfiguration;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.DecommissionCandidate;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.NewNodeManagerCandidates;\n+import com.sequenceiq.periscope.monitor.client.YarnMetricsClient;\n+import com.sequenceiq.periscope.monitor.context.ClusterIdEvaluatorContext;\n+import com.sequenceiq.periscope.monitor.context.EvaluatorContext;\n+import com.sequenceiq.periscope.monitor.evaluator.EvaluatorExecutor;\n+import com.sequenceiq.periscope.monitor.evaluator.EventPublisher;\n+import com.sequenceiq.periscope.monitor.event.ScalingEvent;\n+import com.sequenceiq.periscope.monitor.event.UpdateFailedEvent;\n+import com.sequenceiq.periscope.monitor.handler.CloudbreakCommunicator;\n+import com.sequenceiq.periscope.repository.LoadAlertRepository;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.utils.StackResponseUtils;\n+\n+@Component(\"YarnLoadEvaluator\")\n+@Scope(\"prototype\")\n+public class YarnLoadEvaluator extends EvaluatorExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(YarnLoadEvaluator.class);\n+\n+    private static final String EVALUATOR_NAME = YarnLoadEvaluator.class.getName();\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoadAlertRepository alertRepository;\n+\n+    @Inject\n+    private EventPublisher eventPublisher;\n+\n+    @Inject\n+    private YarnMetricsClient yarnMetricsClient;\n+\n+    @Inject\n+    private StackResponseUtils stackResponseUtils;\n+\n+    @Inject\n+    private CloudbreakCommunicator cloudbreakCommunicator;\n+\n+    private long clusterId;\n+\n+    private Cluster cluster;\n+\n+    private LoadAlert loadAlert;\n+\n+    private LoadAlertConfiguration loadAlertConfiguration;\n+\n+    private String policyHostGroup;\n+\n+    @Nonnull\n+    @Override\n+    public EvaluatorContext getContext() {\n+        return new ClusterIdEvaluatorContext(clusterId);\n+    }\n+\n+    @Override\n+    public void setContext(EvaluatorContext context) {\n+        clusterId = (long) context.getData();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return EVALUATOR_NAME;\n+    }\n+\n+    @Override\n+    protected void execute() {\n+        long start = System.currentTimeMillis();\n+        String stackCrn = \"NotInitialized\";", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0ODg4NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435748885", "bodyText": "ok", "author": "smaniraju", "createdAt": "2020-06-05T07:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NDMwMw=="}], "type": "inlineReview", "revised_code": {"commit": "e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "chunk": "diff --git a/autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java b/autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java\nindex 65d76eeba8..8b6e5345c9 100644\n--- a/autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java\n+++ b/autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java\n\n@@ -6,7 +6,6 @@ import java.util.Comparator;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.Set;\n import java.util.stream.Collectors;\n import java.util.stream.IntStream;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NTcwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435285709", "bodyText": "can you break up smaller functions?", "author": "topolyai5", "createdAt": "2020-06-04T14:06:52Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package com.sequenceiq.periscope.monitor.evaluator.load;\n+\n+import static com.sequenceiq.periscope.monitor.evaluator.ScalingConstants.DEFAULT_MAX_SCALE_UP_STEP_SIZE;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.annotation.Nonnull;\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackV4Response;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.LoadAlert;\n+import com.sequenceiq.periscope.domain.LoadAlertConfiguration;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.DecommissionCandidate;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.NewNodeManagerCandidates;\n+import com.sequenceiq.periscope.monitor.client.YarnMetricsClient;\n+import com.sequenceiq.periscope.monitor.context.ClusterIdEvaluatorContext;\n+import com.sequenceiq.periscope.monitor.context.EvaluatorContext;\n+import com.sequenceiq.periscope.monitor.evaluator.EvaluatorExecutor;\n+import com.sequenceiq.periscope.monitor.evaluator.EventPublisher;\n+import com.sequenceiq.periscope.monitor.event.ScalingEvent;\n+import com.sequenceiq.periscope.monitor.event.UpdateFailedEvent;\n+import com.sequenceiq.periscope.monitor.handler.CloudbreakCommunicator;\n+import com.sequenceiq.periscope.repository.LoadAlertRepository;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.utils.StackResponseUtils;\n+\n+@Component(\"YarnLoadEvaluator\")\n+@Scope(\"prototype\")\n+public class YarnLoadEvaluator extends EvaluatorExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(YarnLoadEvaluator.class);\n+\n+    private static final String EVALUATOR_NAME = YarnLoadEvaluator.class.getName();\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoadAlertRepository alertRepository;\n+\n+    @Inject\n+    private EventPublisher eventPublisher;\n+\n+    @Inject\n+    private YarnMetricsClient yarnMetricsClient;\n+\n+    @Inject\n+    private StackResponseUtils stackResponseUtils;\n+\n+    @Inject\n+    private CloudbreakCommunicator cloudbreakCommunicator;\n+\n+    private long clusterId;\n+\n+    private Cluster cluster;\n+\n+    private LoadAlert loadAlert;\n+\n+    private LoadAlertConfiguration loadAlertConfiguration;\n+\n+    private String policyHostGroup;\n+\n+    @Nonnull\n+    @Override\n+    public EvaluatorContext getContext() {\n+        return new ClusterIdEvaluatorContext(clusterId);\n+    }\n+\n+    @Override\n+    public void setContext(EvaluatorContext context) {\n+        clusterId = (long) context.getData();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return EVALUATOR_NAME;\n+    }\n+\n+    @Override\n+    protected void execute() {\n+        long start = System.currentTimeMillis();\n+        String stackCrn = \"NotInitialized\";\n+        try {\n+            MDCBuilder.buildMdcContext(cluster);\n+            cluster = clusterService.findById(clusterId);\n+            stackCrn = cluster.getStackCrn();\n+            loadAlert = cluster.getLoadAlerts().stream().findFirst().get();\n+            loadAlertConfiguration = loadAlert.getLoadAlertConfiguration();\n+            policyHostGroup = loadAlert.getScalingPolicy().getHostGroup();\n+\n+            if (isCoolDownTimeElapsed(cluster.getStackCrn(), loadAlertConfiguration.getCoolDownMillis(),\n+                    cluster.getLastScalingActivity())) {\n+                pollYarnMetricsAndScaleCluster();\n+            }\n+        } catch (Exception ex) {\n+            LOGGER.info(\"Failed to process load alert for Cluster {}, exception {}\", stackCrn, ex);\n+            eventPublisher.publishEvent(new UpdateFailedEvent(clusterId));\n+        } finally {\n+            LOGGER.debug(\"Finished loadEvaluator for cluster {} in {} ms\", stackCrn, System.currentTimeMillis() - start);\n+        }\n+    }\n+\n+    protected void pollYarnMetricsAndScaleCluster() throws Exception {", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0OTEwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435749104", "bodyText": "done", "author": "smaniraju", "createdAt": "2020-06-05T07:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NTcwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "chunk": "diff --git a/autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java b/autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java\nindex 65d76eeba8..8b6e5345c9 100644\n--- a/autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java\n+++ b/autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java\n\n@@ -6,7 +6,6 @@ import java.util.Comparator;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.Set;\n import java.util.stream.Collectors;\n import java.util.stream.IntStream;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4ODY2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435288669", "bodyText": "can you create a list with the suspended statuses and check whether contains or not?", "author": "topolyai5", "createdAt": "2020-06-04T14:10:51Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/UpdateFailedHandler.java", "diffHunk": "@@ -43,57 +41,53 @@\n     @Inject\n     private CloudbreakCommunicator cloudbreakCommunicator;\n \n-    @Inject\n-    private FailedNodeRepository failedNodeRepository;\n-\n     private final Map<Long, Integer> updateFailures = new ConcurrentHashMap<>();\n \n     @Override\n     public void onApplicationEvent(UpdateFailedEvent event) {\n         long autoscaleClusterId = event.getClusterId();\n-        LOGGER.debug(\"Cluster {} failed\", autoscaleClusterId);\n         Cluster cluster = clusterService.findById(autoscaleClusterId);\n         if (cluster == null) {\n             return;\n         }\n         MDCBuilder.buildMdcContext(cluster);\n+        LOGGER.debug(\"Analysing Cluster Status '{}' \", cluster.getStackCrn());\n         StackV4Response stackResponse = getStackById(cluster.getStackCrn());\n-        if (stackResponse == null) {\n-            LOGGER.debug(\"Suspending cluster {}\", autoscaleClusterId);\n+        String stackStatus = getStackStatus(stackResponse);\n+        if (stackResponse == null || stackStatus.startsWith(STOPPED_STATUSES_PREFIX)) {", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MDU5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435750593", "bodyText": "Agree, replaced functionality to use inbuilt Status::isAvailable and also abstracted CBCluster state sync functionality out of UpdateFailedHandler since there was overlap functionality here in tracking failures and syncing cluster status. Also split the unit-tests to separate cluster sync and update failure tracking.", "author": "smaniraju", "createdAt": "2020-06-05T07:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4ODY2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "chunk": "diff --git a/autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/UpdateFailedHandler.java b/autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/UpdateFailedHandler.java\nindex e8b263278f..05af375fd2 100644\n--- a/autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/UpdateFailedHandler.java\n+++ b/autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/UpdateFailedHandler.java\n\n@@ -10,37 +11,22 @@ import org.slf4j.LoggerFactory;\n import org.springframework.context.ApplicationListener;\n import org.springframework.stereotype.Component;\n \n-import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n-import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackV4Response;\n import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n import com.sequenceiq.periscope.api.model.ClusterState;\n import com.sequenceiq.periscope.domain.Cluster;\n import com.sequenceiq.periscope.monitor.event.UpdateFailedEvent;\n import com.sequenceiq.periscope.service.ClusterService;\n-import com.sequenceiq.periscope.utils.StackResponseUtils;\n \n @Component\n public class UpdateFailedHandler implements ApplicationListener<UpdateFailedEvent> {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(UpdateFailedHandler.class);\n \n-    private static final String DELETE_STATUS = \"DELETE_COMPLETED\";\n-\n-    private static final String STOPPED_STATUSES_PREFIX = \"STOP\";\n-\n-    private static final String AVAILABLE = \"AVAILABLE\";\n-\n     private static final int RETRY_THRESHOLD = 5;\n \n     @Inject\n     private ClusterService clusterService;\n \n-    @Inject\n-    private StackResponseUtils stackResponseUtils;\n-\n-    @Inject\n-    private CloudbreakCommunicator cloudbreakCommunicator;\n-\n     private final Map<Long, Integer> updateFailures = new ConcurrentHashMap<>();\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI5MDg2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435290864", "bodyText": "It much better: ClusterPertain findByUserCrn(String userCrn) and should be work", "author": "topolyai5", "createdAt": "2020-06-04T14:13:49Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/repository/ClusterPertainRepository.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.sequenceiq.periscope.repository;\n+\n+import java.util.List;\n+\n+import org.springframework.data.domain.PageRequest;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.repository.query.Param;\n+\n+import com.sequenceiq.cloudbreak.workspace.repository.EntityType;\n+import com.sequenceiq.periscope.domain.ClusterPertain;\n+\n+@EntityType(entityClass = ClusterPertain.class)\n+public interface ClusterPertainRepository extends CrudRepository<ClusterPertain, Long> {\n+    List<ClusterPertain> findByUserCrn(@Param(\"userCrn\") String userCrn, Pageable page);\n+\n+    default List<ClusterPertain> findByUserCrn(String userCrn) {", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MTI0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435751244", "bodyText": "agree updated existing cluster->clusterpertain mapping to support ManyToOne and api to ClusterPertain findByUserCrn(String userCrn)", "author": "smaniraju", "createdAt": "2020-06-05T07:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI5MDg2NA=="}], "type": "inlineReview", "revised_code": {"commit": "e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "chunk": "diff --git a/autoscale/src/main/java/com/sequenceiq/periscope/repository/ClusterPertainRepository.java b/autoscale/src/main/java/com/sequenceiq/periscope/repository/ClusterPertainRepository.java\nindex d8ba8183f0..f1d8d8fcaf 100644\n--- a/autoscale/src/main/java/com/sequenceiq/periscope/repository/ClusterPertainRepository.java\n+++ b/autoscale/src/main/java/com/sequenceiq/periscope/repository/ClusterPertainRepository.java\n\n@@ -1,9 +1,7 @@\n package com.sequenceiq.periscope.repository;\n \n-import java.util.List;\n+import java.util.Optional;\n \n-import org.springframework.data.domain.PageRequest;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.data.repository.CrudRepository;\n import org.springframework.data.repository.query.Param;\n \n"}}, {"oid": "e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "url": "https://github.com/hortonworks/cloudbreak/commit/e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "message": "DISTX-399 DataHub Autoscaling\n\n1.  Introduce DistroXAutoscale Endpoint for DataHub Autoscaling.\n2.  Disable unused AlertEndpoint.\n3.  Introduce Entitlements validation for DataHub Autoscaling.\n4.  Introduce YarnBased Autoscaling Evaluator and Monitor.\n5.  Introduce RemovableCluster Monitor to track and remove CB deleted clusters.\n6.  Introduce DistroXAutoscale endpoint tests.", "committedDate": "2020-06-05T07:56:08Z", "type": "commit"}, {"oid": "e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "url": "https://github.com/hortonworks/cloudbreak/commit/e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "message": "DISTX-399 DataHub Autoscaling\n\n1.  Introduce DistroXAutoscale Endpoint for DataHub Autoscaling.\n2.  Disable unused AlertEndpoint.\n3.  Introduce Entitlements validation for DataHub Autoscaling.\n4.  Introduce YarnBased Autoscaling Evaluator and Monitor.\n5.  Introduce RemovableCluster Monitor to track and remove CB deleted clusters.\n6.  Introduce DistroXAutoscale endpoint tests.", "committedDate": "2020-06-05T07:56:08Z", "type": "forcePushed"}]}