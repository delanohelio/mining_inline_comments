{"pr_number": 7071, "pr_title": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack", "pr_createdAt": "2020-01-14T15:36:15Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/7071", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3NzA1Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366777056", "bodyText": "if we really need this log, it should be debug or trace", "author": "lacikaaa", "createdAt": "2020-01-15T09:41:51Z", "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java", "diffHunk": "@@ -75,26 +79,36 @@\n         return result;\n     }\n \n-    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform) {\n+    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform, String environmentName) {\n         Map<String, String> result = new HashMap<>();\n         result.put(transform(CDP_USER_NAME.key(), platform), transform(cbUser, platform));\n         result.put(transform(CDP_CB_VERSION.key(), platform), transform(cbVersion, platform));\n+        addEnvironmentNameToMapIfValueIsNotNullOrEmpty(result, environmentName, platform);\n         if (sourceMap == null || Strings.isNullOrEmpty(sourceMap.get(transform(OWNER.key(), platform)))) {\n             result.put(transform(OWNER.key(), platform), transform(cbUser, platform));\n         }\n         result.put(transform(CDP_CREATION_TIMESTAMP.key(), platform), transform(String.valueOf(clock.getCurrentInstant().getEpochSecond()), platform));\n         return result;\n     }\n \n-    private String transform(String value, String platform) {\n+    public void addEnvironmentNameToMapIfValueIsNotNullOrEmpty(Map<String, String> hereTo, String environmentName, String platform) {\n+        if (StringUtils.isNotEmpty(environmentName)) {\n+            hereTo.put(transform(ENVIRONMENT_NAME.key(), platform), environmentName);\n+        } else {\n+            LOGGER.info(\"Unable to add EnvironmentName - cost - tag to the resource's default tags because it's value is empty or null!\");", "originalCommit": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyNzgyNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366827826", "bodyText": "since it's cost-related warn, I think it should be on the info level", "author": "gregito", "createdAt": "2020-01-15T11:31:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3NzA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgzMDAzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366830033", "bodyText": "@doktoric @topolyai5 what do you think?", "author": "gregito", "createdAt": "2020-01-15T11:37:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3NzA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "549bc13f61d59ced302fd7b4d3ad57042e6a254b", "chunk": "diff --git a/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java b/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java\nindex 94946c5a11..e8783ba4c6 100644\n--- a/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java\n+++ b/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java\n\n@@ -79,6 +82,7 @@ public class DefaultCostTaggingService {\n         return result;\n     }\n \n+    @Override\n     public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform, String environmentName) {\n         Map<String, String> result = new HashMap<>();\n         result.put(transform(CDP_USER_NAME.key(), platform), transform(cbUser, platform));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MDE0OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366780149", "bodyText": "you should log the exception here", "author": "lacikaaa", "createdAt": "2020-01-15T09:48:13Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/EnvironmentServiceDecorator.java", "diffHunk": "@@ -84,4 +82,13 @@ public void prepareEnvironment(StackViewV4Response stackViewResponse) {\n         }\n     }\n \n+    public Optional<DetailedEnvironmentResponse> getEnvironmentByCrn(String crn) {\n+        try {\n+            return Optional.ofNullable(environmentClientService.getByCrn(crn));\n+        } catch (Exception e) {\n+            LOGGER.warn(\"Unable to fetch environment by crn: {}\", crn);", "originalCommit": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgzMDExMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366830112", "bodyText": "right, going to do it", "author": "gregito", "createdAt": "2020-01-15T11:37:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MDE0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/EnvironmentServiceDecorator.java b/core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/EnvironmentServiceDecorator.java\nindex 97285e5cc4..474d53550b 100644\n--- a/core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/EnvironmentServiceDecorator.java\n+++ b/core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/EnvironmentServiceDecorator.java\n\n@@ -82,13 +84,4 @@ public class EnvironmentServiceDecorator {\n         }\n     }\n \n-    public Optional<DetailedEnvironmentResponse> getEnvironmentByCrn(String crn) {\n-        try {\n-            return Optional.ofNullable(environmentClientService.getByCrn(crn));\n-        } catch (Exception e) {\n-            LOGGER.warn(\"Unable to fetch environment by crn: {}\", crn);\n-            return Optional.empty();\n-        }\n-    }\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MTU3OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366781578", "bodyText": "please do it then :)", "author": "lacikaaa", "createdAt": "2020-01-15T09:50:56Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaCreationService.java", "diffHunk": "@@ -108,7 +108,7 @@ public DescribeFreeIpaResponse launchFreeIpa(CreateFreeIpaRequest request, Strin\n         String userCrn = crnService.getUserCrn();\n         Future<User> userFuture = intermediateBuilderExecutor.submit(() -> umsClient.getUserDetails(userCrn, userCrn, MDCUtils.getRequestId()));\n         Credential credential = credentialService.getCredentialByEnvCrn(request.getEnvironmentCrn());\n-        Stack stack = stackConverter.convert(request, accountId, userFuture, credential.getCloudPlatform());\n+        Stack stack = stackConverter.convert(request, accountId, userFuture, credential.getCloudPlatform()); // TODO: 2020. 01. 10. add environment name as a new tag for applicationTag", "originalCommit": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyNzk2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366827968", "bodyText": "forgot to delete the comment :)", "author": "gregito", "createdAt": "2020-01-15T11:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MTU3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyODA3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366828077", "bodyText": "it was just a note for myself", "author": "gregito", "createdAt": "2020-01-15T11:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MTU3OA=="}], "type": "inlineReview", "revised_code": {"commit": "549bc13f61d59ced302fd7b4d3ad57042e6a254b", "chunk": "diff --git a/freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaCreationService.java b/freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaCreationService.java\nindex 1995b42504..e669df03f9 100644\n--- a/freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaCreationService.java\n+++ b/freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaCreationService.java\n\n@@ -108,7 +108,7 @@ public class FreeIpaCreationService {\n         String userCrn = crnService.getUserCrn();\n         Future<User> userFuture = intermediateBuilderExecutor.submit(() -> umsClient.getUserDetails(userCrn, userCrn, MDCUtils.getRequestId()));\n         Credential credential = credentialService.getCredentialByEnvCrn(request.getEnvironmentCrn());\n-        Stack stack = stackConverter.convert(request, accountId, userFuture, credential.getCloudPlatform()); // TODO: 2020. 01. 10. add environment name as a new tag for applicationTag\n+        Stack stack = stackConverter.convert(request, accountId, userFuture, credential.getCloudPlatform());\n         stack.setResourceCrn(crnService.createCrn(accountId, Crn.ResourceType.FREEIPA));\n         stack.setAppVersion(appVersion);\n         GetPlatformTemplateRequest getPlatformTemplateRequest = templateService.triggerGetTemplate(stack, credential);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MDgyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366780822", "bodyText": "I would make the name shorter, like addEnvironmentNameIfPresent", "author": "gergopapi2", "createdAt": "2020-01-15T09:49:29Z", "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java", "diffHunk": "@@ -75,26 +79,36 @@\n         return result;\n     }\n \n-    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform) {\n+    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform, String environmentName) {\n         Map<String, String> result = new HashMap<>();\n         result.put(transform(CDP_USER_NAME.key(), platform), transform(cbUser, platform));\n         result.put(transform(CDP_CB_VERSION.key(), platform), transform(cbVersion, platform));\n+        addEnvironmentNameToMapIfValueIsNotNullOrEmpty(result, environmentName, platform);", "originalCommit": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyODE4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366828183", "bodyText": "good point, going to change it", "author": "gregito", "createdAt": "2020-01-15T11:32:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MDgyMg=="}], "type": "inlineReview", "revised_code": {"commit": "549bc13f61d59ced302fd7b4d3ad57042e6a254b", "chunk": "diff --git a/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java b/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java\nindex 94946c5a11..e8783ba4c6 100644\n--- a/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java\n+++ b/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java\n\n@@ -79,6 +82,7 @@ public class DefaultCostTaggingService {\n         return result;\n     }\n \n+    @Override\n     public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform, String environmentName) {\n         Map<String, String> result = new HashMap<>();\n         result.put(transform(CDP_USER_NAME.key(), platform), transform(cbUser, platform));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4NDU5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366784597", "bodyText": "Most of the other tags do have cdp in their text. Question: does the env name not need the cdp prefix?", "author": "gergopapi2", "createdAt": "2020-01-15T09:56:37Z", "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/type/DefaultApplicationTag.java", "diffHunk": "@@ -5,6 +5,7 @@\n     OWNER(\"Owner\"),\n     CDP_USER_NAME(\"cdp-user-name\"),\n     CDP_CB_VERSION(\"cdp-cb-version\"),\n+    ENVIRONMENT_NAME(\"environment-name\"),", "originalCommit": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyOTAzNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366829036", "bodyText": "guess no since environment is a cloudbreak logical entity, it has nothing to do with the whole cdp, hence I didn't add this prefix to the actual value. but please correct me if I'm wrong.\n@lacikaaa what is your opinion about it?", "author": "gregito", "createdAt": "2020-01-15T11:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4NDU5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "chunk": "diff --git a/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/type/DefaultApplicationTag.java b/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/type/DefaultApplicationTag.java\nindex 661e71eb7a..2006658855 100644\n--- a/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/type/DefaultApplicationTag.java\n+++ b/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/type/DefaultApplicationTag.java\n\n@@ -5,10 +5,10 @@ public enum DefaultApplicationTag {\n     OWNER(\"Owner\"),\n     CDP_USER_NAME(\"cdp-user-name\"),\n     CDP_CB_VERSION(\"cdp-cb-version\"),\n-    ENVIRONMENT_NAME(\"environment-name\"),\n     CDP_ACOUNT_NAME(\"cdp-account-name\"),\n     CDP_RESOURCE_TYPE(\"cdp-resource-type\"),\n     CDP_CREATION_TIMESTAMP(\"cdp-creation-timestamp\"),\n+    ENVIRONMENT_NAME(\"Cloudera-Environment-Resource-Name\"),\n     CDP_CREATION_DATETIME_UTC(\"cdp-creation-datetime-utc\");\n \n     private final String key;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4NTcwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366785704", "bodyText": "In tests I would not reuse constants of the productive code, but rather redefine them. This would guard against accidental text change of ENVIRONMENT_NAME key.", "author": "gergopapi2", "createdAt": "2020-01-15T09:58:42Z", "path": "cloud-common/src/test/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingServiceTest.java", "diffHunk": "@@ -49,12 +46,13 @@ public void testPrepareDefaultTagsForAWSShouldReturnAllDefaultMap() {\n         long epochSeconds = 1526991986L;\n         when(clock.getCurrentInstant()).thenReturn(Instant.ofEpochSecond(epochSeconds));\n \n-        Map<String, String> result = underTest.prepareDefaultTags(CB_USER, new HashMap<>(), CloudConstants.AWS);\n+        Map<String, String> result = underTest.prepareDefaultTags(CB_USER, new HashMap<>(), CloudConstants.AWS, ENV_NAME);\n \n-        Assert.assertEquals(4L, result.size());\n+        Assert.assertEquals(5L, result.size());\n         Assert.assertEquals(\"apache1@apache.com\", result.get(DefaultApplicationTag.CDP_USER_NAME.key()));\n         Assert.assertEquals(\"2.2.0\", result.get(DefaultApplicationTag.CDP_CB_VERSION.key()));\n         Assert.assertEquals(\"apache1@apache.com\", result.get(DefaultApplicationTag.OWNER.key()));\n+        Assert.assertEquals(ENV_NAME, result.get(DefaultApplicationTag.ENVIRONMENT_NAME.key()));", "originalCommit": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "chunk": "diff --git a/cloud-common/src/test/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingServiceTest.java b/cloud-common/src/test/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingServiceTest.java\nindex 5c76672246..5907db1c41 100644\n--- a/cloud-common/src/test/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingServiceTest.java\n+++ b/cloud-common/src/test/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingServiceTest.java\n\n@@ -46,13 +54,13 @@ public class DefaultCostTaggingServiceTest {\n         long epochSeconds = 1526991986L;\n         when(clock.getCurrentInstant()).thenReturn(Instant.ofEpochSecond(epochSeconds));\n \n-        Map<String, String> result = underTest.prepareDefaultTags(CB_USER, new HashMap<>(), CloudConstants.AWS, ENV_NAME);\n+        Map<String, String> result = underTest.prepareDefaultTags(CB_USER, new HashMap<>(), CloudConstants.AWS, ENV_CRN);\n \n         Assert.assertEquals(5L, result.size());\n         Assert.assertEquals(\"apache1@apache.com\", result.get(DefaultApplicationTag.CDP_USER_NAME.key()));\n         Assert.assertEquals(\"2.2.0\", result.get(DefaultApplicationTag.CDP_CB_VERSION.key()));\n         Assert.assertEquals(\"apache1@apache.com\", result.get(DefaultApplicationTag.OWNER.key()));\n-        Assert.assertEquals(ENV_NAME, result.get(DefaultApplicationTag.ENVIRONMENT_NAME.key()));\n+        Assert.assertEquals(ENV_CRN, result.get(ENV_RES_TAG_NAME));\n         Assert.assertEquals(String.valueOf(epochSeconds), result.get(\"cdp-creation-timestamp\"));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4NzQ1OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366787458", "bodyText": "In this file there is no other change just the order of imports. I would exclude this change from this commit.", "author": "gergopapi2", "createdAt": "2020-01-15T10:02:02Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/v4/StackV4Controller.java", "diffHunk": "@@ -1,16 +1,5 @@\n package com.sequenceiq.cloudbreak.controller.v4;\n \n-import java.util.ArrayList;", "originalCommit": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "549bc13f61d59ced302fd7b4d3ad57042e6a254b", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/cloudbreak/controller/v4/StackV4Controller.java b/core/src/main/java/com/sequenceiq/cloudbreak/controller/v4/StackV4Controller.java\nindex 6e257ab325..945ce18a81 100644\n--- a/core/src/main/java/com/sequenceiq/cloudbreak/controller/v4/StackV4Controller.java\n+++ b/core/src/main/java/com/sequenceiq/cloudbreak/controller/v4/StackV4Controller.java\n\n@@ -1,8 +1,19 @@\n package com.sequenceiq.cloudbreak.controller.v4;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.validation.Valid;\n+import javax.validation.constraints.NotNull;\n+\n+import org.springframework.stereotype.Controller;\n+\n import com.sequenceiq.cloudbreak.api.endpoint.v4.common.StackType;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.dto.ResourceAccessDto.ResourceAccessDtoBuilder;\n import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.StackV4Endpoint;\n-import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.dto.StackAccessDto;\n import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.ClusterRepairV4Request;\n import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.MaintenanceModeV4Request;\n import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.StackImageChangeV4Request;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5MzA0MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366793040", "bodyText": "I would put this method into EnvironmentClientService", "author": "gergopapi2", "createdAt": "2020-01-15T10:13:23Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/EnvironmentServiceDecorator.java", "diffHunk": "@@ -84,4 +82,13 @@ public void prepareEnvironment(StackViewV4Response stackViewResponse) {\n         }\n     }\n \n+    public Optional<DetailedEnvironmentResponse> getEnvironmentByCrn(String crn) {", "originalCommit": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/EnvironmentServiceDecorator.java b/core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/EnvironmentServiceDecorator.java\nindex 97285e5cc4..474d53550b 100644\n--- a/core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/EnvironmentServiceDecorator.java\n+++ b/core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/EnvironmentServiceDecorator.java\n\n@@ -82,13 +84,4 @@ public class EnvironmentServiceDecorator {\n         }\n     }\n \n-    public Optional<DetailedEnvironmentResponse> getEnvironmentByCrn(String crn) {\n-        try {\n-            return Optional.ofNullable(environmentClientService.getByCrn(crn));\n-        } catch (Exception e) {\n-            LOGGER.warn(\"Unable to fetch environment by crn: {}\", crn);\n-            return Optional.empty();\n-        }\n-    }\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5MzU2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366793564", "bodyText": "The only change in this file is this blank line, I would exclude it from the changes.", "author": "gergopapi2", "createdAt": "2020-01-15T10:14:26Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -346,4 +346,5 @@ private void validateAccessDto(StackAccessDto dto) {\n             throw new BadRequestException(\"A stack name or crn must be provided. One and only one of them.\");\n         }\n     }\n+", "originalCommit": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyOTY1Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366829652", "bodyText": "It just hurts my eyes when the last method has no trailing enter :)", "author": "gregito", "createdAt": "2020-01-15T11:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5MzU2NA=="}], "type": "inlineReview", "revised_code": {"commit": "549bc13f61d59ced302fd7b4d3ad57042e6a254b", "chunk": "diff --git a/core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java b/core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java\nindex de27b312e1..a414a46e30 100644\n--- a/core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java\n+++ b/core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java\n\n@@ -340,11 +342,4 @@ public class StackOperations {\n         return stackCommonService.getRetryableFlows(name, workspaceId);\n     }\n \n-    private void validateAccessDto(StackAccessDto dto) {\n-        throwIfNull(dto, () -> new IllegalArgumentException(\"StackAccessDto should not be null.\"));\n-        if (dto.isNotValid()) {\n-            throw new BadRequestException(\"A stack name or crn must be provided. One and only one of them.\");\n-        }\n-    }\n-\n }\n"}}, {"oid": "549bc13f61d59ced302fd7b4d3ad57042e6a254b", "url": "https://github.com/hortonworks/cloudbreak/commit/549bc13f61d59ced302fd7b4d3ad57042e6a254b", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack", "committedDate": "2020-01-15T11:29:57Z", "type": "forcePushed"}, {"oid": "5ffd882f2f538d477319ed5eef22e9ac52a33e23", "url": "https://github.com/hortonworks/cloudbreak/commit/5ffd882f2f538d477319ed5eef22e9ac52a33e23", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack", "committedDate": "2020-01-15T11:38:44Z", "type": "forcePushed"}, {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "url": "https://github.com/hortonworks/cloudbreak/commit/214703601ab8ec56163dfb18b07d5a3108eb3c5f", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack", "committedDate": "2020-01-16T10:57:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg2MDkwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367860900", "bodyText": "this is not in sync with parameter name", "author": "lacikaaa", "createdAt": "2020-01-17T10:14:15Z", "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java", "diffHunk": "@@ -75,26 +82,39 @@\n         return result;\n     }\n \n-    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform) {\n+    @Override\n+    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform, String environmentName) {\n+        LOGGER.debug(\"About to prepare default tag(s)...\");\n         Map<String, String> result = new HashMap<>();\n         result.put(transform(CDP_USER_NAME.key(), platform), transform(cbUser, platform));\n         result.put(transform(CDP_CB_VERSION.key(), platform), transform(cbVersion, platform));\n+        addEnvironmentCrnIfPresent(result, environmentName, platform);\n         if (sourceMap == null || Strings.isNullOrEmpty(sourceMap.get(transform(OWNER.key(), platform)))) {\n             result.put(transform(OWNER.key(), platform), transform(cbUser, platform));\n         }\n         result.put(transform(CDP_CREATION_TIMESTAMP.key(), platform), transform(String.valueOf(clock.getCurrentInstant().getEpochSecond()), platform));\n+        LOGGER.debug(\"The following default tag(s) has prepared: {}\", result);\n         return result;\n     }\n \n-    private String transform(String value, String platform) {\n+    public void addEnvironmentCrnIfPresent(Map<String, String> hereTo, String environmentCrn, String platform) {", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16f4ccb6d7a32c19b20e4a2ac9f9599bed12451a", "chunk": "diff --git a/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java b/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java\nindex 5b061ce27c..de1394ba2d 100644\n--- a/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java\n+++ b/cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java\n\n@@ -83,12 +83,12 @@ public class DefaultCostTaggingService implements CostTagging {\n     }\n \n     @Override\n-    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform, String environmentName) {\n+    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform, String environmentCrn) {\n         LOGGER.debug(\"About to prepare default tag(s)...\");\n         Map<String, String> result = new HashMap<>();\n         result.put(transform(CDP_USER_NAME.key(), platform), transform(cbUser, platform));\n         result.put(transform(CDP_CB_VERSION.key(), platform), transform(cbVersion, platform));\n-        addEnvironmentCrnIfPresent(result, environmentName, platform);\n+        addEnvironmentCrnIfPresent(result, environmentCrn, platform);\n         if (sourceMap == null || Strings.isNullOrEmpty(sourceMap.get(transform(OWNER.key(), platform)))) {\n             result.put(transform(OWNER.key(), platform), transform(cbUser, platform));\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0MzkyNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367843926", "bodyText": "Nuance thing: I would name this variable defaultTagMap instead of result.", "author": "gergopapi2", "createdAt": "2020-01-17T09:36:52Z", "path": "cloud-common/src/test/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingServiceTest.java", "diffHunk": "@@ -49,12 +54,13 @@ public void testPrepareDefaultTagsForAWSShouldReturnAllDefaultMap() {\n         long epochSeconds = 1526991986L;\n         when(clock.getCurrentInstant()).thenReturn(Instant.ofEpochSecond(epochSeconds));\n \n-        Map<String, String> result = underTest.prepareDefaultTags(CB_USER, new HashMap<>(), CloudConstants.AWS);\n+        Map<String, String> result = underTest.prepareDefaultTags(CB_USER, new HashMap<>(), CloudConstants.AWS, ENV_CRN);", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg2Njk5NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367866995", "bodyText": "I would add the valid() call here. Otherwise the valid call has to be made every time, that is error-prone.", "author": "gergopapi2", "createdAt": "2020-01-17T10:29:11Z", "path": "core-api/src/main/java/com/sequenceiq/cloudbreak/api/endpoint/v4/dto/ResourceAccessDto.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.sequenceiq.cloudbreak.api.endpoint.v4.dto;\n+\n+import static com.sequenceiq.cloudbreak.util.NullUtil.throwIfNull;\n+import static org.apache.commons.lang3.StringUtils.isNotEmpty;\n+\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+\n+public class ResourceAccessDto {\n+\n+    public static final String NULL_DTO_EXCEPTION_MESSAGE = \"AccessDto should not be null\";\n+\n+    public static final String INVALID_RESOURCE_ACCESS_DTO_EXCEPTION_MESSAGE = \"One and only one value of the crn and name should be filled!\";\n+\n+    private final String name;\n+\n+    private final String crn;\n+\n+    protected ResourceAccessDto(String name, String crn) {\n+        this.name = name;\n+        this.crn = crn;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getCrn() {\n+        return crn;\n+    }\n+\n+    public static void validate(ResourceAccessDto dto) {\n+        throwIfNull(dto, () -> new IllegalArgumentException(NULL_DTO_EXCEPTION_MESSAGE));\n+        if (dto.isNotValid()) {\n+            throw new BadRequestException(INVALID_RESOURCE_ACCESS_DTO_EXCEPTION_MESSAGE);\n+        }\n+    }\n+\n+    public boolean isNotValid() {\n+        return !isValid();\n+    }\n+\n+    public boolean isValid() {\n+        return isNotEmpty(name) ^ isNotEmpty(crn);\n+    }\n+\n+    public static class ResourceAccessDtoBuilder {\n+\n+        private String name;\n+\n+        private String crn;\n+\n+        public static ResourceAccessDtoBuilder aResourceAccessDtoBuilder() {\n+            return new ResourceAccessDtoBuilder();\n+        }\n+\n+        public ResourceAccessDtoBuilder withName(String name) {\n+            if (isNotEmpty(name)) {\n+                this.name = name;\n+            }\n+            return this;\n+        }\n+\n+        public ResourceAccessDtoBuilder withCrn(String crn) {\n+            if (isNotEmpty(crn)) {\n+                this.crn = crn;\n+            }\n+            return this;\n+        }\n+\n+        public ResourceAccessDto build() {\n+            return new ResourceAccessDto(name, crn);\n+        }", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4MDA4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367880086", "bodyText": "I think this in a different way. The object itself does not require any validation. It's valid since it does nothing with the containing data. Tha validation depends on what the developer want to do with an already existing dto, but on the other hand you've got some point on the error-proneness", "author": "gregito", "createdAt": "2020-01-17T10:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg2Njk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg5MTkxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367891918", "bodyText": "I agree partially: yes, the users of this class should decide what they do with the data. On the other hand, we do not want to use dto-s that have invalid data in them, our paradigm is to send an HTTP error code and error message back to the user whenever we have invalid data. Under this paradigm I think it does make sense to add the validate() to the build method.\nThere could be cases when we are happy to have invalid dto-s: in that case I would add another builder method, withNoValidation(), that would disable validation. But I think there is no use-case for that now.", "author": "gergopapi2", "createdAt": "2020-01-17T11:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg2Njk5NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3MTAyNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367871025", "bodyText": "I would refactor this and the stackCommonService.deleteMultipleInstances... method: I would pass both name and crn and would merge the byName and byCrn methods, they just differ in one line.\nAlso, I would do this for the other methods like putStop, putStart, etc. Those are even larger methods, differing also in just 1 line.", "author": "gergopapi2", "createdAt": "2020-01-17T10:38:33Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4MDYwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367880609", "bodyText": "this is out of scope for this pr. if it really hurts you please raise a jira for this refactor and we'll make it in the future", "author": "gregito", "createdAt": "2020-01-17T11:00:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3MTAyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4MTI4NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367881285", "bodyText": "I do not quite agree: in this way refactoring will be a second class citizen.", "author": "gergopapi2", "createdAt": "2020-01-17T11:01:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3MTAyNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3MjEzOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367872139", "bodyText": "I would make just one call, as syncInWorkspace handles the either name or crn case.", "author": "gergopapi2", "createdAt": "2020-01-17T10:41:09Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4MTAzMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367881032", "bodyText": "also refactor topic, not related to this specific fix", "author": "gregito", "createdAt": "2020-01-17T11:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3MjEzOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3MjU0Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367872542", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "author": "gergopapi2", "createdAt": "2020-01-17T10:42:09Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3MjU4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367872586", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "author": "gergopapi2", "createdAt": "2020-01-17T10:42:15Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3Mjc2MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367872760", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "author": "gergopapi2", "createdAt": "2020-01-17T10:42:39Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStartInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStartInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStartInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putScaling(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n-        stackCommonService.putScalingInWorkspace(stackAccessDto.getName(), workspaceId, updateRequest);\n+    public void putScaling(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n+        stackCommonService.putScalingInWorkspace(resourceAccessDto.getName(), workspaceId, updateRequest);\n     }\n \n-    public void repairCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.repairClusterByName(workspaceId, stackAccessDto.getName(), clusterRepairRequest);\n+    public void repairCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NDM1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367874353", "bodyText": "Refactor as indicated in deleteInstances method (see comments there).", "author": "gergopapi2", "createdAt": "2020-01-17T10:46:22Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStartInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStartInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStartInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putScaling(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n-        stackCommonService.putScalingInWorkspace(stackAccessDto.getName(), workspaceId, updateRequest);\n+    public void putScaling(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n+        stackCommonService.putScalingInWorkspace(resourceAccessDto.getName(), workspaceId, updateRequest);\n     }\n \n-    public void repairCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.repairClusterByName(workspaceId, stackAccessDto.getName(), clusterRepairRequest);\n+    public void repairCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.repairClusterByName(workspaceId, resourceAccessDto.getName(), clusterRepairRequest);\n         } else {\n-            stackCommonService.repairClusterByCrn(workspaceId, stackAccessDto.getCrn(), clusterRepairRequest);\n+            stackCommonService.repairClusterByCrn(workspaceId, resourceAccessDto.getCrn(), clusterRepairRequest);\n         }\n     }\n \n-    public void upgradeCluster(StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            upgradeService.upgradeByStackName(workspaceId, stackAccessDto.getName());\n+    public void upgradeCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            upgradeService.upgradeByStackName(workspaceId, resourceAccessDto.getName());\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public UpgradeOptionV4Response checkForUpgrade(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public UpgradeOptionV4Response checkForUpgrade(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return upgradeService.getUpgradeOptionByStackName(workspaceId, stackAccessDto.getName(), user);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return upgradeService.getUpgradeOptionByStackName(workspaceId, resourceAccessDto.getName(), user);\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public GeneratedBlueprintV4Response postStackForBlueprint(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n+    public GeneratedBlueprintV4Response postStackForBlueprint(ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n         return stackCommonService.postStackForBlueprint(stackRequest);\n     }\n \n-    public void changeImage(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.changeImageByNameInWorkspace(stackAccessDto.getName(), workspaceId, stackImageChangeRequest);\n+    public void changeImage(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NDQzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367874437", "bodyText": "Refactor as indicated in deleteInstances method (see comments there).", "author": "gergopapi2", "createdAt": "2020-01-17T10:46:33Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStartInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStartInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStartInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putScaling(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n-        stackCommonService.putScalingInWorkspace(stackAccessDto.getName(), workspaceId, updateRequest);\n+    public void putScaling(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n+        stackCommonService.putScalingInWorkspace(resourceAccessDto.getName(), workspaceId, updateRequest);\n     }\n \n-    public void repairCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.repairClusterByName(workspaceId, stackAccessDto.getName(), clusterRepairRequest);\n+    public void repairCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.repairClusterByName(workspaceId, resourceAccessDto.getName(), clusterRepairRequest);\n         } else {\n-            stackCommonService.repairClusterByCrn(workspaceId, stackAccessDto.getCrn(), clusterRepairRequest);\n+            stackCommonService.repairClusterByCrn(workspaceId, resourceAccessDto.getCrn(), clusterRepairRequest);\n         }\n     }\n \n-    public void upgradeCluster(StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            upgradeService.upgradeByStackName(workspaceId, stackAccessDto.getName());\n+    public void upgradeCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            upgradeService.upgradeByStackName(workspaceId, resourceAccessDto.getName());\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public UpgradeOptionV4Response checkForUpgrade(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public UpgradeOptionV4Response checkForUpgrade(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return upgradeService.getUpgradeOptionByStackName(workspaceId, stackAccessDto.getName(), user);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return upgradeService.getUpgradeOptionByStackName(workspaceId, resourceAccessDto.getName(), user);\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public GeneratedBlueprintV4Response postStackForBlueprint(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n+    public GeneratedBlueprintV4Response postStackForBlueprint(ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n         return stackCommonService.postStackForBlueprint(stackRequest);\n     }\n \n-    public void changeImage(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.changeImageByNameInWorkspace(stackAccessDto.getName(), workspaceId, stackImageChangeRequest);\n+    public void changeImage(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.changeImageByNameInWorkspace(resourceAccessDto.getName(), workspaceId, stackImageChangeRequest);\n         } else {\n-            stackCommonService.changeImageByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n+            stackCommonService.changeImageByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n         }\n     }\n \n-    public void delete(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced) {\n-        validateAccessDto(stackAccessDto);\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteWithKerberosByNameInWorkspace(stackAccessDto.getName(), workspaceId, forced);\n+    public void delete(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced) {\n+        ResourceAccessDto.validate(resourceAccessDto);", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NDUxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367874518", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "author": "gergopapi2", "createdAt": "2020-01-17T10:46:44Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStartInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStartInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStartInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putScaling(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n-        stackCommonService.putScalingInWorkspace(stackAccessDto.getName(), workspaceId, updateRequest);\n+    public void putScaling(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n+        stackCommonService.putScalingInWorkspace(resourceAccessDto.getName(), workspaceId, updateRequest);\n     }\n \n-    public void repairCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.repairClusterByName(workspaceId, stackAccessDto.getName(), clusterRepairRequest);\n+    public void repairCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.repairClusterByName(workspaceId, resourceAccessDto.getName(), clusterRepairRequest);\n         } else {\n-            stackCommonService.repairClusterByCrn(workspaceId, stackAccessDto.getCrn(), clusterRepairRequest);\n+            stackCommonService.repairClusterByCrn(workspaceId, resourceAccessDto.getCrn(), clusterRepairRequest);\n         }\n     }\n \n-    public void upgradeCluster(StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            upgradeService.upgradeByStackName(workspaceId, stackAccessDto.getName());\n+    public void upgradeCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            upgradeService.upgradeByStackName(workspaceId, resourceAccessDto.getName());\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public UpgradeOptionV4Response checkForUpgrade(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public UpgradeOptionV4Response checkForUpgrade(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return upgradeService.getUpgradeOptionByStackName(workspaceId, stackAccessDto.getName(), user);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return upgradeService.getUpgradeOptionByStackName(workspaceId, resourceAccessDto.getName(), user);\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public GeneratedBlueprintV4Response postStackForBlueprint(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n+    public GeneratedBlueprintV4Response postStackForBlueprint(ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n         return stackCommonService.postStackForBlueprint(stackRequest);\n     }\n \n-    public void changeImage(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.changeImageByNameInWorkspace(stackAccessDto.getName(), workspaceId, stackImageChangeRequest);\n+    public void changeImage(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.changeImageByNameInWorkspace(resourceAccessDto.getName(), workspaceId, stackImageChangeRequest);\n         } else {\n-            stackCommonService.changeImageByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n+            stackCommonService.changeImageByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n         }\n     }\n \n-    public void delete(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced) {\n-        validateAccessDto(stackAccessDto);\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteWithKerberosByNameInWorkspace(stackAccessDto.getName(), workspaceId, forced);\n+    public void delete(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteWithKerberosByNameInWorkspace(resourceAccessDto.getName(), workspaceId, forced);\n         } else {\n-            stackCommonService.deleteWithKerberosByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, forced);\n+            stackCommonService.deleteWithKerberosByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, forced);\n         }\n     }\n \n-    public StackV4Request getRequest(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return stackService.getStackRequestByNameInWorkspaceId(stackAccessDto.getName(), workspaceId);\n+    public StackV4Request getRequest(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NTE2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367875168", "bodyText": "Refactor as indicated in deleteInstances method (see comments there).", "author": "gergopapi2", "createdAt": "2020-01-17T10:48:22Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStartInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStartInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStartInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putScaling(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n-        stackCommonService.putScalingInWorkspace(stackAccessDto.getName(), workspaceId, updateRequest);\n+    public void putScaling(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n+        stackCommonService.putScalingInWorkspace(resourceAccessDto.getName(), workspaceId, updateRequest);\n     }\n \n-    public void repairCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.repairClusterByName(workspaceId, stackAccessDto.getName(), clusterRepairRequest);\n+    public void repairCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.repairClusterByName(workspaceId, resourceAccessDto.getName(), clusterRepairRequest);\n         } else {\n-            stackCommonService.repairClusterByCrn(workspaceId, stackAccessDto.getCrn(), clusterRepairRequest);\n+            stackCommonService.repairClusterByCrn(workspaceId, resourceAccessDto.getCrn(), clusterRepairRequest);\n         }\n     }\n \n-    public void upgradeCluster(StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            upgradeService.upgradeByStackName(workspaceId, stackAccessDto.getName());\n+    public void upgradeCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            upgradeService.upgradeByStackName(workspaceId, resourceAccessDto.getName());\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public UpgradeOptionV4Response checkForUpgrade(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public UpgradeOptionV4Response checkForUpgrade(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return upgradeService.getUpgradeOptionByStackName(workspaceId, stackAccessDto.getName(), user);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return upgradeService.getUpgradeOptionByStackName(workspaceId, resourceAccessDto.getName(), user);\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public GeneratedBlueprintV4Response postStackForBlueprint(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n+    public GeneratedBlueprintV4Response postStackForBlueprint(ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n         return stackCommonService.postStackForBlueprint(stackRequest);\n     }\n \n-    public void changeImage(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.changeImageByNameInWorkspace(stackAccessDto.getName(), workspaceId, stackImageChangeRequest);\n+    public void changeImage(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.changeImageByNameInWorkspace(resourceAccessDto.getName(), workspaceId, stackImageChangeRequest);\n         } else {\n-            stackCommonService.changeImageByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n+            stackCommonService.changeImageByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n         }\n     }\n \n-    public void delete(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced) {\n-        validateAccessDto(stackAccessDto);\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteWithKerberosByNameInWorkspace(stackAccessDto.getName(), workspaceId, forced);\n+    public void delete(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteWithKerberosByNameInWorkspace(resourceAccessDto.getName(), workspaceId, forced);\n         } else {\n-            stackCommonService.deleteWithKerberosByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, forced);\n+            stackCommonService.deleteWithKerberosByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, forced);\n         }\n     }\n \n-    public StackV4Request getRequest(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return stackService.getStackRequestByNameInWorkspaceId(stackAccessDto.getName(), workspaceId);\n+    public StackV4Request getRequest(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return stackService.getStackRequestByNameInWorkspaceId(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            return stackService.getStackRequestByCrnInWorkspaceId(stackAccessDto.getCrn(), workspaceId);\n+            return stackService.getStackRequestByCrnInWorkspaceId(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public StackStatusV4Response getStatus(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public StackStatusV4Response getStatus(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NTU4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367875588", "bodyText": "Refactor as indicated in deleteInstances method (see comments there).", "author": "gergopapi2", "createdAt": "2020-01-17T10:49:21Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStartInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStartInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStartInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putScaling(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n-        stackCommonService.putScalingInWorkspace(stackAccessDto.getName(), workspaceId, updateRequest);\n+    public void putScaling(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n+        stackCommonService.putScalingInWorkspace(resourceAccessDto.getName(), workspaceId, updateRequest);\n     }\n \n-    public void repairCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.repairClusterByName(workspaceId, stackAccessDto.getName(), clusterRepairRequest);\n+    public void repairCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.repairClusterByName(workspaceId, resourceAccessDto.getName(), clusterRepairRequest);\n         } else {\n-            stackCommonService.repairClusterByCrn(workspaceId, stackAccessDto.getCrn(), clusterRepairRequest);\n+            stackCommonService.repairClusterByCrn(workspaceId, resourceAccessDto.getCrn(), clusterRepairRequest);\n         }\n     }\n \n-    public void upgradeCluster(StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            upgradeService.upgradeByStackName(workspaceId, stackAccessDto.getName());\n+    public void upgradeCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            upgradeService.upgradeByStackName(workspaceId, resourceAccessDto.getName());\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public UpgradeOptionV4Response checkForUpgrade(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public UpgradeOptionV4Response checkForUpgrade(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return upgradeService.getUpgradeOptionByStackName(workspaceId, stackAccessDto.getName(), user);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return upgradeService.getUpgradeOptionByStackName(workspaceId, resourceAccessDto.getName(), user);\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public GeneratedBlueprintV4Response postStackForBlueprint(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n+    public GeneratedBlueprintV4Response postStackForBlueprint(ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n         return stackCommonService.postStackForBlueprint(stackRequest);\n     }\n \n-    public void changeImage(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.changeImageByNameInWorkspace(stackAccessDto.getName(), workspaceId, stackImageChangeRequest);\n+    public void changeImage(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.changeImageByNameInWorkspace(resourceAccessDto.getName(), workspaceId, stackImageChangeRequest);\n         } else {\n-            stackCommonService.changeImageByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n+            stackCommonService.changeImageByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n         }\n     }\n \n-    public void delete(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced) {\n-        validateAccessDto(stackAccessDto);\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteWithKerberosByNameInWorkspace(stackAccessDto.getName(), workspaceId, forced);\n+    public void delete(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteWithKerberosByNameInWorkspace(resourceAccessDto.getName(), workspaceId, forced);\n         } else {\n-            stackCommonService.deleteWithKerberosByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, forced);\n+            stackCommonService.deleteWithKerberosByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, forced);\n         }\n     }\n \n-    public StackV4Request getRequest(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return stackService.getStackRequestByNameInWorkspaceId(stackAccessDto.getName(), workspaceId);\n+    public StackV4Request getRequest(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return stackService.getStackRequestByNameInWorkspaceId(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            return stackService.getStackRequestByCrnInWorkspaceId(stackAccessDto.getCrn(), workspaceId);\n+            return stackService.getStackRequestByCrnInWorkspaceId(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public StackStatusV4Response getStatus(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public StackStatusV4Response getStatus(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stack = stackService.getByNameInWorkspace(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stack = stackService.getByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId);\n+            stack = stackService.getByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId);\n         }\n         return converterUtil.convert(stack, StackStatusV4Response.class);\n     }\n \n-    public StackStatusV4Response getStatusByCrn(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public StackStatusV4Response getStatusByCrn(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NTkyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367875928", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "author": "gergopapi2", "createdAt": "2020-01-17T10:50:10Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -287,35 +289,35 @@ public StackStatusV4Response getStatus(@NotNull String crn) {\n         return converterUtil.convert(stack, StackStatusV4Response.class);\n     }\n \n-    public void putPassword(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid UserNamePasswordV4Request userNamePasswordJson) {\n+    public void putPassword(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid UserNamePasswordV4Request userNamePasswordJson) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NTk3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367875979", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "author": "gergopapi2", "createdAt": "2020-01-17T10:50:17Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -287,35 +289,35 @@ public StackStatusV4Response getStatus(@NotNull String crn) {\n         return converterUtil.convert(stack, StackStatusV4Response.class);\n     }\n \n-    public void putPassword(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid UserNamePasswordV4Request userNamePasswordJson) {\n+    public void putPassword(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid UserNamePasswordV4Request userNamePasswordJson) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stack = stackService.getByNameInWorkspace(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stack = stackService.getByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId);\n+            stack = stackService.getByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId);\n         }\n         UpdateClusterV4Request updateClusterJson = converterUtil.convert(userNamePasswordJson, UpdateClusterV4Request.class);\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n         Workspace workspace = workspaceService.get(restRequestThreadLocalService.getRequestedWorkspaceId(), user);\n         clusterCommonService.put(stack.getResourceCrn(), updateClusterJson, user, workspace);\n     }\n \n-    public void setClusterMaintenanceMode(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @NotNull MaintenanceModeV4Request maintenanceMode) {\n+    public void setClusterMaintenanceMode(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @NotNull MaintenanceModeV4Request maintenanceMode) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NjA0MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367876040", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "author": "gergopapi2", "createdAt": "2020-01-17T10:50:26Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -287,35 +289,35 @@ public StackStatusV4Response getStatus(@NotNull String crn) {\n         return converterUtil.convert(stack, StackStatusV4Response.class);\n     }\n \n-    public void putPassword(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid UserNamePasswordV4Request userNamePasswordJson) {\n+    public void putPassword(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid UserNamePasswordV4Request userNamePasswordJson) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stack = stackService.getByNameInWorkspace(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stack = stackService.getByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId);\n+            stack = stackService.getByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId);\n         }\n         UpdateClusterV4Request updateClusterJson = converterUtil.convert(userNamePasswordJson, UpdateClusterV4Request.class);\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n         Workspace workspace = workspaceService.get(restRequestThreadLocalService.getRequestedWorkspaceId(), user);\n         clusterCommonService.put(stack.getResourceCrn(), updateClusterJson, user, workspace);\n     }\n \n-    public void setClusterMaintenanceMode(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @NotNull MaintenanceModeV4Request maintenanceMode) {\n+    public void setClusterMaintenanceMode(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @NotNull MaintenanceModeV4Request maintenanceMode) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stack = stackService.getByNameInWorkspace(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stack = stackService.getByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId);\n+            stack = stackService.getByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId);\n         }\n         clusterCommonService.setMaintenanceMode(stack, maintenanceMode.getStatus());\n     }\n \n-    public void putCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid UpdateClusterV4Request updateJson) {\n+    public void putCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid UpdateClusterV4Request updateJson) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "originalCommit": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "16f4ccb6d7a32c19b20e4a2ac9f9599bed12451a", "url": "https://github.com/hortonworks/cloudbreak/commit/16f4ccb6d7a32c19b20e4a2ac9f9599bed12451a", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack", "committedDate": "2020-01-20T12:20:49Z", "type": "forcePushed"}, {"oid": "dec7e4d670c928825040136d8f73c213272929a3", "url": "https://github.com/hortonworks/cloudbreak/commit/dec7e4d670c928825040136d8f73c213272929a3", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack", "committedDate": "2020-01-20T12:49:45Z", "type": "commit"}, {"oid": "dec7e4d670c928825040136d8f73c213272929a3", "url": "https://github.com/hortonworks/cloudbreak/commit/dec7e4d670c928825040136d8f73c213272929a3", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack", "committedDate": "2020-01-20T12:49:45Z", "type": "forcePushed"}]}