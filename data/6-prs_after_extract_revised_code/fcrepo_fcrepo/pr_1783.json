{"pr_number": 1783, "pr_title": "Parallelize index rebuilding", "pr_createdAt": "2020-10-23T21:08:42Z", "pr_url": "https://github.com/fcrepo/fcrepo/pull/1783", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyMTI2Mg==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512621262", "bodyText": "Is there a reason this can't be wired and injected by spring?", "author": "pwinckles", "createdAt": "2020-10-27T11:43:07Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -120,148 +117,40 @@ private void rebuild() {\n         referenceService.reset();\n         membershipService.reset();\n \n-        final var txId = UUID.randomUUID().toString();\n+        final var reindexService = new ReindexService(persistentStorageSessionManager, objectSessionFactory, ocflIndex,", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\nindex 3f33224c25..8f584dccab 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n\n@@ -117,24 +112,30 @@ public class IndexBuilderImpl implements IndexBuilder {\n         referenceService.reset();\n         membershipService.reset();\n \n-        final var reindexService = new ReindexService(persistentStorageSessionManager, objectSessionFactory, ocflIndex,\n-                containmentIndex, searchIndex, referenceService, membershipService, membershipPageSize);\n-        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n-                true, reindexBatchSize);\n+        final var reindexService = new ReindexService(objectSessionFactory, ocflIndex, containmentIndex, searchIndex,\n+                referenceService, membershipService, membershipPageSize);\n+        final int availableProcessors = Runtime.getRuntime().availableProcessors();\n+        final int threads = availableProcessors > 1 ? availableProcessors - 1 : 1;\n+        final var executor = Executors.newFixedThreadPool(threads);\n+        final ReindexManager reindexManager = new ReindexManager(executor, reindexService);\n \n         LOGGER.debug(\"Reading object ids...\");\n         final var startTime = Instant.now();\n+\n+        try (final var ocflIds = ocflRepository.listObjectIds()) {\n+            ocflIds.forEach(reindexManager::submit);\n+        }\n+\n         try {\n-            reindexManager.start();\n-            reindexManager.commit();\n+            reindexManager.awaitCompletion();\n             LOGGER.info(\"Reindexing complete.\");\n+            reindexManager.shutdown();\n         } catch (final InterruptedException e) {\n+            Thread.currentThread().interrupt();\n             throw new RuntimeException(e);\n         }\n         final var endTime = Instant.now();\n-        final var count = reindexManager.getResultStates().keySet().size();\n-        LOGGER.info(\"Index rebuild complete {} objects in {} milliseconds\", count,\n-                Duration.between(startTime, endTime).toMillis());\n+        LOGGER.info(\"Index rebuild complete in {} milliseconds\", Duration.between(startTime, endTime).toMillis());\n     }\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyMTcwMg==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512621702", "bodyText": "Milliseconds might be an optimistic unit...", "author": "pwinckles", "createdAt": "2020-10-27T11:44:00Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -120,148 +117,40 @@ private void rebuild() {\n         referenceService.reset();\n         membershipService.reset();\n \n-        final var txId = UUID.randomUUID().toString();\n+        final var reindexService = new ReindexService(persistentStorageSessionManager, objectSessionFactory, ocflIndex,\n+                containmentIndex, searchIndex, referenceService, membershipService, membershipPageSize);\n+        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n+                true, reindexBatchSize);\n \n+        LOGGER.debug(\"Reading object ids...\");\n+        final var startTime = Instant.now();\n         try {\n-            LOGGER.debug(\"Reading object ids...\");\n-\n-            try (final var ocflIds = ocflRepository.listObjectIds()) {\n-                ocflIds.forEach(ocflId -> {\n-                    LOGGER.debug(\"Reading {}\", ocflId);\n-                    try (final var session = objectSessionFactory.newSession(ocflId)) {\n-                        indexOcflObject(ocflId, txId, session);\n-                    } catch (final Exception e) {\n-                        // The session's close method signature throws Exception\n-                        if (e instanceof RuntimeException) {\n-                            throw (RuntimeException) e;\n-                        }\n-                        throw new RuntimeException(e);\n-                    }\n-                });\n-            }\n-\n-            containmentIndex.commitTransaction(txId);\n-            ocflIndex.commit(txId);\n-            referenceService.commitTransaction(txId);\n-            indexMembership(txId);\n-            LOGGER.info(\"Index rebuild complete\");\n-        } catch (final RuntimeException e) {\n-            execQuietly(\"Failed to reset searchIndex\", () -> {\n-                searchIndex.reset();\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback containment index transaction \" + txId, () -> {\n-                containmentIndex.rollbackTransaction(txId);\n-                return null;\n-            });\n-            execQuietly(\"Failed to rollback OCFL index transaction \" + txId, () -> {\n-                ocflIndex.rollback(txId);\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback membership index transaction \" + txId, () -> {\n-                membershipService.rollbackTransaction(txId);\n-                return null;\n-            });\n-            throw e;\n+            reindexManager.start();\n+            reindexManager.commit();\n+            LOGGER.info(\"Reindexing complete.\");\n+        } catch (final InterruptedException e) {\n+            throw new RuntimeException(e);\n         }\n+        final var endTime = Instant.now();\n+        final var count = reindexManager.getResultStates().keySet().size();\n+        LOGGER.info(\"Index rebuild complete {} objects in {} milliseconds\", count,", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\nindex 3f33224c25..8f584dccab 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n\n@@ -117,24 +112,30 @@ public class IndexBuilderImpl implements IndexBuilder {\n         referenceService.reset();\n         membershipService.reset();\n \n-        final var reindexService = new ReindexService(persistentStorageSessionManager, objectSessionFactory, ocflIndex,\n-                containmentIndex, searchIndex, referenceService, membershipService, membershipPageSize);\n-        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n-                true, reindexBatchSize);\n+        final var reindexService = new ReindexService(objectSessionFactory, ocflIndex, containmentIndex, searchIndex,\n+                referenceService, membershipService, membershipPageSize);\n+        final int availableProcessors = Runtime.getRuntime().availableProcessors();\n+        final int threads = availableProcessors > 1 ? availableProcessors - 1 : 1;\n+        final var executor = Executors.newFixedThreadPool(threads);\n+        final ReindexManager reindexManager = new ReindexManager(executor, reindexService);\n \n         LOGGER.debug(\"Reading object ids...\");\n         final var startTime = Instant.now();\n+\n+        try (final var ocflIds = ocflRepository.listObjectIds()) {\n+            ocflIds.forEach(reindexManager::submit);\n+        }\n+\n         try {\n-            reindexManager.start();\n-            reindexManager.commit();\n+            reindexManager.awaitCompletion();\n             LOGGER.info(\"Reindexing complete.\");\n+            reindexManager.shutdown();\n         } catch (final InterruptedException e) {\n+            Thread.currentThread().interrupt();\n             throw new RuntimeException(e);\n         }\n         final var endTime = Instant.now();\n-        final var count = reindexManager.getResultStates().keySet().size();\n-        LOGGER.info(\"Index rebuild complete {} objects in {} milliseconds\", count,\n-                Duration.between(startTime, endTime).toMillis());\n+        LOGGER.info(\"Index rebuild complete in {} milliseconds\", Duration.between(startTime, endTime).toMillis());\n     }\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyMzk2Nw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512623967", "bodyText": "You should keep a handle to the id stream. The stream should be closed when you're done with it.", "author": "pwinckles", "createdAt": "2020-10-27T11:46:44Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.slf4j.Logger;\n+\n+/**\n+ * Class to coordinate the index rebuilding tasks.\n+ * @author whikloj\n+ */\n+public class ReindexManager {\n+\n+    private static final Logger LOGGER = getLogger(ReindexManager.class);\n+\n+    private final String transactionId;\n+\n+    private final List<ReindexWorker> workers;\n+\n+    private final Iterator<String> ocflIter;\n+\n+    private final Map<String, String> resultStates = new HashMap<>();\n+\n+    private final ReindexService reindexService;\n+\n+    private final int batchSize;\n+\n+    /**\n+     * Basic constructor\n+     * @param ids stream of ocfl ids.\n+     * @param reindexService the reindexing service.\n+     * @param failOnError whether to have threads fail on an error or log and continue.\n+     * @param batchSize number of ids to distribute per request.\n+     */\n+    public ReindexManager(final Stream<String> ids, final ReindexService reindexService, final boolean failOnError,\n+                          final int batchSize) {\n+        this.ocflIter = ids.iterator();", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\nindex a8079e2dd9..3e098182d5 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\n\n@@ -19,13 +19,10 @@ package org.fcrepo.persistence.ocfl.impl;\n \n import static org.slf4j.LoggerFactory.getLogger;\n \n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n import java.util.UUID;\n-import java.util.stream.Stream;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import org.slf4j.Logger;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyNDgzNw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512624837", "bodyText": "This should be configurable. Are you planning on saving that for a different PR?", "author": "pwinckles", "createdAt": "2020-10-27T11:47:32Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.slf4j.Logger;\n+\n+/**\n+ * Class to coordinate the index rebuilding tasks.\n+ * @author whikloj\n+ */\n+public class ReindexManager {\n+\n+    private static final Logger LOGGER = getLogger(ReindexManager.class);\n+\n+    private final String transactionId;\n+\n+    private final List<ReindexWorker> workers;\n+\n+    private final Iterator<String> ocflIter;\n+\n+    private final Map<String, String> resultStates = new HashMap<>();\n+\n+    private final ReindexService reindexService;\n+\n+    private final int batchSize;\n+\n+    /**\n+     * Basic constructor\n+     * @param ids stream of ocfl ids.\n+     * @param reindexService the reindexing service.\n+     * @param failOnError whether to have threads fail on an error or log and continue.\n+     * @param batchSize number of ids to distribute per request.\n+     */\n+    public ReindexManager(final Stream<String> ids, final ReindexService reindexService, final boolean failOnError,\n+                          final int batchSize) {\n+        this.ocflIter = ids.iterator();\n+        this.reindexService = reindexService;\n+        this.batchSize = batchSize;\n+        transactionId = UUID.randomUUID().toString();\n+        workers = new ArrayList<>();\n+        final int availableProcessors = Runtime.getRuntime().availableProcessors();\n+        final int threads = availableProcessors > 1 ? availableProcessors - 1 : 1;", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjE1Ng==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515102156", "bodyText": "I can make this configurable but then what should be the default? Single threaded?", "author": "whikloj", "createdAt": "2020-10-30T13:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyNDgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTY2MA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515105660", "bodyText": "Also are you thinking this is specifically configurable w/r/t reindexing?", "author": "whikloj", "createdAt": "2020-10-30T13:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyNDgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNjI3Mg==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515106272", "bodyText": "You can have the default be exactly what you have here. There are a number of ways that you could write it. Probably the easiest is to write a static function that does the thread computation and then write something like this is in the config:\n@Value(\"${fcrepo.reindex.threads:\" + computeDefaultThreads() + \"}\")\nprivate int reindexThreads;", "author": "pwinckles", "createdAt": "2020-10-30T13:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyNDgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzM3Ng==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515107376", "bodyText": "Also are you thinking this is specifically configurable w/r/t reindexing?\n\nNot sure", "author": "pwinckles", "createdAt": "2020-10-30T13:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyNDgzNw=="}], "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\nindex a8079e2dd9..3e098182d5 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\n\n@@ -19,13 +19,10 @@ package org.fcrepo.persistence.ocfl.impl;\n \n import static org.slf4j.LoggerFactory.getLogger;\n \n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n import java.util.UUID;\n-import java.util.stream.Stream;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import org.slf4j.Logger;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyNjU2Mw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512626563", "bodyText": "Any reason to not just pass this into the worker in the constructor?", "author": "pwinckles", "createdAt": "2020-10-27T11:49:06Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.slf4j.Logger;\n+\n+/**\n+ * Class to coordinate the index rebuilding tasks.\n+ * @author whikloj\n+ */\n+public class ReindexManager {\n+\n+    private static final Logger LOGGER = getLogger(ReindexManager.class);\n+\n+    private final String transactionId;\n+\n+    private final List<ReindexWorker> workers;\n+\n+    private final Iterator<String> ocflIter;\n+\n+    private final Map<String, String> resultStates = new HashMap<>();\n+\n+    private final ReindexService reindexService;\n+\n+    private final int batchSize;\n+\n+    /**\n+     * Basic constructor\n+     * @param ids stream of ocfl ids.\n+     * @param reindexService the reindexing service.\n+     * @param failOnError whether to have threads fail on an error or log and continue.\n+     * @param batchSize number of ids to distribute per request.\n+     */\n+    public ReindexManager(final Stream<String> ids, final ReindexService reindexService, final boolean failOnError,\n+                          final int batchSize) {\n+        this.ocflIter = ids.iterator();\n+        this.reindexService = reindexService;\n+        this.batchSize = batchSize;\n+        transactionId = UUID.randomUUID().toString();\n+        workers = new ArrayList<>();\n+        final int availableProcessors = Runtime.getRuntime().availableProcessors();\n+        final int threads = availableProcessors > 1 ? availableProcessors - 1 : 1;\n+        for (var foo = 0; foo < threads; foo += 1) {\n+            workers.add(new ReindexWorker(this, this.reindexService, failOnError));\n+        }\n+    }\n+\n+    /**\n+     * Get the transaction id for the reindexing run.\n+     * @return the transaction id.\n+     */\n+    public String getTransactionId() {", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\nindex a8079e2dd9..3e098182d5 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\n\n@@ -19,13 +19,10 @@ package org.fcrepo.persistence.ocfl.impl;\n \n import static org.slf4j.LoggerFactory.getLogger;\n \n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n import java.util.UUID;\n-import java.util.stream.Stream;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import org.slf4j.Logger;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzNDc4NQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512634785", "bodyText": "This seems to be less of a state map and more of a map of errors, the successes have an empty value. It also has the potential to grow very large. How are we planning on using these results? For me, what makes sense is to have a count of the objects that were successfully processed, and either a collection or a map of exceptions that occurred during processing. Or, we could just keep a count of both and immediately log errors so that we do not need to collect them. I think keeping the counts is worth while because it will allow us to do periodic reporting during the processing.", "author": "pwinckles", "createdAt": "2020-10-27T12:00:48Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.slf4j.Logger;\n+\n+/**\n+ * Class to coordinate the index rebuilding tasks.\n+ * @author whikloj\n+ */\n+public class ReindexManager {\n+\n+    private static final Logger LOGGER = getLogger(ReindexManager.class);\n+\n+    private final String transactionId;\n+\n+    private final List<ReindexWorker> workers;\n+\n+    private final Iterator<String> ocflIter;\n+\n+    private final Map<String, String> resultStates = new HashMap<>();", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\nindex a8079e2dd9..3e098182d5 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\n\n@@ -19,13 +19,10 @@ package org.fcrepo.persistence.ocfl.impl;\n \n import static org.slf4j.LoggerFactory.getLogger;\n \n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n import java.util.UUID;\n-import java.util.stream.Stream;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import org.slf4j.Logger;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzNzgwNw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512637807", "bodyText": "What happens on failure? Isn't this going to leave the db transaction in place?", "author": "pwinckles", "createdAt": "2020-10-27T12:06:03Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -120,148 +117,40 @@ private void rebuild() {\n         referenceService.reset();\n         membershipService.reset();\n \n-        final var txId = UUID.randomUUID().toString();\n+        final var reindexService = new ReindexService(persistentStorageSessionManager, objectSessionFactory, ocflIndex,\n+                containmentIndex, searchIndex, referenceService, membershipService, membershipPageSize);\n+        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n+                true, reindexBatchSize);\n \n+        LOGGER.debug(\"Reading object ids...\");\n+        final var startTime = Instant.now();\n         try {\n-            LOGGER.debug(\"Reading object ids...\");\n-\n-            try (final var ocflIds = ocflRepository.listObjectIds()) {\n-                ocflIds.forEach(ocflId -> {\n-                    LOGGER.debug(\"Reading {}\", ocflId);\n-                    try (final var session = objectSessionFactory.newSession(ocflId)) {\n-                        indexOcflObject(ocflId, txId, session);\n-                    } catch (final Exception e) {\n-                        // The session's close method signature throws Exception\n-                        if (e instanceof RuntimeException) {\n-                            throw (RuntimeException) e;\n-                        }\n-                        throw new RuntimeException(e);\n-                    }\n-                });\n-            }\n-\n-            containmentIndex.commitTransaction(txId);\n-            ocflIndex.commit(txId);\n-            referenceService.commitTransaction(txId);\n-            indexMembership(txId);\n-            LOGGER.info(\"Index rebuild complete\");\n-        } catch (final RuntimeException e) {\n-            execQuietly(\"Failed to reset searchIndex\", () -> {\n-                searchIndex.reset();\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback containment index transaction \" + txId, () -> {\n-                containmentIndex.rollbackTransaction(txId);\n-                return null;\n-            });\n-            execQuietly(\"Failed to rollback OCFL index transaction \" + txId, () -> {\n-                ocflIndex.rollback(txId);\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback membership index transaction \" + txId, () -> {\n-                membershipService.rollbackTransaction(txId);\n-                return null;\n-            });\n-            throw e;\n+            reindexManager.start();\n+            reindexManager.commit();", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMzQ5Mw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515103493", "bodyText": "No, ReindexManager.commit() calls ReindexService.commit() which does the commit and rollback on failure work.", "author": "whikloj", "createdAt": "2020-10-30T13:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzNzgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODQyOA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515108428", "bodyText": "Right, but what happens if the call to reindexManager.start() throws an exception?", "author": "pwinckles", "createdAt": "2020-10-30T13:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzNzgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIwNDM4Mw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515204383", "bodyText": "Ok I see what you're saying the DB transaction would just sit there.", "author": "whikloj", "createdAt": "2020-10-30T15:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzNzgwNw=="}], "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\nindex 3f33224c25..8f584dccab 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n\n@@ -117,24 +112,30 @@ public class IndexBuilderImpl implements IndexBuilder {\n         referenceService.reset();\n         membershipService.reset();\n \n-        final var reindexService = new ReindexService(persistentStorageSessionManager, objectSessionFactory, ocflIndex,\n-                containmentIndex, searchIndex, referenceService, membershipService, membershipPageSize);\n-        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n-                true, reindexBatchSize);\n+        final var reindexService = new ReindexService(objectSessionFactory, ocflIndex, containmentIndex, searchIndex,\n+                referenceService, membershipService, membershipPageSize);\n+        final int availableProcessors = Runtime.getRuntime().availableProcessors();\n+        final int threads = availableProcessors > 1 ? availableProcessors - 1 : 1;\n+        final var executor = Executors.newFixedThreadPool(threads);\n+        final ReindexManager reindexManager = new ReindexManager(executor, reindexService);\n \n         LOGGER.debug(\"Reading object ids...\");\n         final var startTime = Instant.now();\n+\n+        try (final var ocflIds = ocflRepository.listObjectIds()) {\n+            ocflIds.forEach(reindexManager::submit);\n+        }\n+\n         try {\n-            reindexManager.start();\n-            reindexManager.commit();\n+            reindexManager.awaitCompletion();\n             LOGGER.info(\"Reindexing complete.\");\n+            reindexManager.shutdown();\n         } catch (final InterruptedException e) {\n+            Thread.currentThread().interrupt();\n             throw new RuntimeException(e);\n         }\n         final var endTime = Instant.now();\n-        final var count = reindexManager.getResultStates().keySet().size();\n-        LOGGER.info(\"Index rebuild complete {} objects in {} milliseconds\", count,\n-                Duration.between(startTime, endTime).toMillis());\n+        LOGGER.info(\"Index rebuild complete in {} milliseconds\", Duration.between(startTime, endTime).toMillis());\n     }\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzOTA0OQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512639049", "bodyText": "Indexing the membership does seem like a distinct operation from committing the db transactions. Perhaps there could be a method for committing the db transactions, one for rolling back the db transactions, and another that kicks of the membership indexing? I haven't looked at it in detail, but does the membership indexing use much of else that's in this class? It the surface it seems like it could easily go into its own class.", "author": "pwinckles", "createdAt": "2020-10-27T12:08:05Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.apache.jena.graph.NodeFactory.createURI;\n+import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;\n+import static org.fcrepo.kernel.api.RdfLexicon.NON_RDF_SOURCE;\n+import static org.fcrepo.persistence.ocfl.impl.OcflPersistentStorageUtils.getRdfFormat;\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.jena.rdf.model.Model;\n+import org.apache.jena.riot.RDFDataMgr;\n+import org.fcrepo.kernel.api.ContainmentIndex;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.ResourceHeaders;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+import org.fcrepo.kernel.api.services.ReferenceService;\n+import org.fcrepo.persistence.api.PersistentStorageSessionManager;\n+import org.fcrepo.persistence.ocfl.api.FedoraToOcflObjectIndex;\n+import org.fcrepo.search.api.Condition;\n+import org.fcrepo.search.api.InvalidQueryException;\n+import org.fcrepo.search.api.SearchIndex;\n+import org.fcrepo.search.api.SearchParameters;\n+import org.fcrepo.storage.ocfl.OcflObjectSessionFactory;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Service that does the reindexing for one OCFL object.\n+ * @author whikloj\n+ */\n+public class ReindexService {\n+\n+    private final PersistentStorageSessionManager persistentStorageSessionManager;\n+\n+    private final OcflObjectSessionFactory ocflObjectSessionFactory;\n+\n+    private final FedoraToOcflObjectIndex ocflIndex;\n+\n+    private final ContainmentIndex containmentIndex;\n+\n+    private final SearchIndex searchIndex;\n+\n+    private final ReferenceService referenceService;\n+\n+    private final MembershipService membershipService;\n+\n+    private static final Logger LOGGER = getLogger(ReindexService.class);\n+\n+    private final int membershipPageSize;\n+\n+    public ReindexService(final PersistentStorageSessionManager sessionManager,\n+                          final OcflObjectSessionFactory sessionFactory,\n+                          final FedoraToOcflObjectIndex fedoraToOcflObjectIndex,\n+                          final ContainmentIndex containmentIdx,\n+                          final SearchIndex searchIdx,\n+                          final ReferenceService referenceSrvc,\n+                          final MembershipService memberService,\n+                          final int membershipPageSize) {\n+        this.persistentStorageSessionManager = sessionManager;\n+        this.ocflObjectSessionFactory = sessionFactory;\n+        this.ocflIndex = fedoraToOcflObjectIndex;\n+        this.containmentIndex = containmentIdx;\n+        this.searchIndex = searchIdx;\n+        this.referenceService = referenceSrvc;\n+        this.membershipService = memberService;\n+        this.membershipPageSize = membershipPageSize;\n+    }\n+\n+    public void indexOcflObject(final String txId, final String ocflId) {\n+        LOGGER.debug(\"Indexing ocflId {} in transaction {}\", ocflId, txId);\n+        try (final var session = ocflObjectSessionFactory.newSession(ocflId)) {\n+            final var rootId = new AtomicReference<FedoraId>();\n+            final var fedoraIds = new ArrayList<FedoraId>();\n+            final var headersList = new ArrayList<ResourceHeaders>();\n+\n+            session.streamResourceHeaders().forEach(storageHeaders -> {\n+                final var headers = new ResourceHeadersAdapter(storageHeaders);\n+\n+                final var fedoraId = headers.getId();\n+                fedoraIds.add(fedoraId);\n+                if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                    rootId.set(fedoraId);\n+                }\n+\n+                if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n+\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(\n+                                    String.format(\"Resource %s must have a parent defined\", fedoraId.getFullId()));\n+                        }\n+                    }\n+                    if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n+                        final Optional<InputStream> content = session.readContent(fedoraId.getFullId())\n+                                .getContentStream();\n+                        if (content.isPresent()) {\n+                            final RdfStream rdf = parseRdf(fedoraId, content.get());\n+                            this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n+                        }\n+                    }\n+\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n+                }\n+            });\n+\n+            if (rootId.get() == null) {\n+                throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n+            }\n+\n+            fedoraIds.forEach(fedoraIdentifier -> {\n+                final var rootFedoraIdentifier = rootId.get();\n+                ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n+                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n+            });\n+\n+            headersList.forEach(headers -> {\n+                searchIndex.addUpdateIndex(txId, headers);\n+                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Remove persistent sessions for a transaction to avoid memory leaks.\n+     * @param transactionId the transaction id.\n+     */\n+    public void cleanupSession(final String transactionId) {\n+        persistentStorageSessionManager.removeSession(transactionId);\n+    }\n+\n+    /**\n+     * Commit the records added from transaction.\n+     * @param transactionId the id of the transaction.\n+     */\n+    public void commit(final String transactionId) {\n+        try {\n+            LOGGER.debug(\"Performing commit\");\n+            containmentIndex.commitTransaction(transactionId);\n+            ocflIndex.commit(transactionId);\n+            referenceService.commitTransaction(transactionId);\n+            indexMembership(transactionId);", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\nindex 50a3975f78..3384e388cc 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\n\n@@ -41,7 +41,6 @@ import org.fcrepo.kernel.api.models.ResourceHeaders;\n import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n import org.fcrepo.kernel.api.services.MembershipService;\n import org.fcrepo.kernel.api.services.ReferenceService;\n-import org.fcrepo.persistence.api.PersistentStorageSessionManager;\n import org.fcrepo.persistence.ocfl.api.FedoraToOcflObjectIndex;\n import org.fcrepo.search.api.Condition;\n import org.fcrepo.search.api.InvalidQueryException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY0MTQ0NA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512641444", "bodyText": "You should have a check in this loop to see if the thread should stop.", "author": "pwinckles", "createdAt": "2020-10-27T12:12:11Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * A reindexing worker thread.\n+ * @author whikloj\n+ */\n+public class ReindexWorker implements Runnable {\n+\n+    private Thread t;\n+    private ReindexManager manager;\n+    private ReindexService service;\n+    private boolean running = true;\n+    private boolean failOnError;\n+\n+    /**\n+     * Basic Constuctor\n+     * @param reindexManager the manager service.\n+     * @param reindexService the reindexing service.\n+     * @param failOnError whether the thread should fail on an error or log and continue.\n+     */\n+    public ReindexWorker(final ReindexManager reindexManager, final ReindexService reindexService,\n+                         final boolean failOnError) {\n+        manager = reindexManager;\n+        service = reindexService;\n+        this.failOnError = failOnError;\n+        t = new Thread(this, \"ReindexWorker\");\n+    }\n+\n+    /**\n+     * Join the thread.\n+     * @throws InterruptedException if the current thread is interrupted.\n+     */\n+    public void join() throws InterruptedException {\n+        t.join();\n+    }\n+\n+    /**\n+     * Start the thread with this Runnable\n+     */\n+    public void start() {\n+        t.start();\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (running) {\n+            final List<String> ids = manager.getIds();\n+            if (ids.isEmpty()) {\n+                stopThread();\n+                break;\n+            }\n+            final Map<String, String> states = new HashMap<>();\n+            for (final var id : ids) {", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java\ndeleted file mode 100644\nindex 6fd4bf0909..0000000000\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java\n+++ /dev/null\n\n@@ -1,98 +0,0 @@\n-/*\n- * Licensed to DuraSpace under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional information\n- * regarding copyright ownership.\n- *\n- * DuraSpace licenses this file to you under the Apache License,\n- * Version 2.0 (the \"License\"); you may not use this file except in\n- * compliance with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.fcrepo.persistence.ocfl.impl;\n-\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A reindexing worker thread.\n- * @author whikloj\n- */\n-public class ReindexWorker implements Runnable {\n-\n-    private Thread t;\n-    private ReindexManager manager;\n-    private ReindexService service;\n-    private boolean running = true;\n-    private boolean failOnError;\n-\n-    /**\n-     * Basic Constuctor\n-     * @param reindexManager the manager service.\n-     * @param reindexService the reindexing service.\n-     * @param failOnError whether the thread should fail on an error or log and continue.\n-     */\n-    public ReindexWorker(final ReindexManager reindexManager, final ReindexService reindexService,\n-                         final boolean failOnError) {\n-        manager = reindexManager;\n-        service = reindexService;\n-        this.failOnError = failOnError;\n-        t = new Thread(this, \"ReindexWorker\");\n-    }\n-\n-    /**\n-     * Join the thread.\n-     * @throws InterruptedException if the current thread is interrupted.\n-     */\n-    public void join() throws InterruptedException {\n-        t.join();\n-    }\n-\n-    /**\n-     * Start the thread with this Runnable\n-     */\n-    public void start() {\n-        t.start();\n-    }\n-\n-    @Override\n-    public void run() {\n-        while (running) {\n-            final List<String> ids = manager.getIds();\n-            if (ids.isEmpty()) {\n-                stopThread();\n-                break;\n-            }\n-            final Map<String, String> states = new HashMap<>();\n-            for (final var id : ids) {\n-                try {\n-                    service.indexOcflObject(manager.getTransactionId(), id);\n-                    states.put(id, \"\");\n-                } catch (final Exception e) {\n-                    states.put(id, e.getMessage());\n-                    if (failOnError) {\n-                        stopThread();\n-                        manager.updateComplete(states);\n-                        throw e;\n-                    }\n-                }\n-            }\n-            manager.updateComplete(states);\n-            service.cleanupSession(manager.getTransactionId());\n-        }\n-    }\n-\n-    /**\n-     * Stop this thread from running once it has completed its current batch.\n-     */\n-    public void stopThread() {\n-        this.running = false;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY0Mzk1NA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512643954", "bodyText": "The problem with this behavior is that it will only ever stop this thread on error. The rest of the threads will proceed. One solution to this problem is to change the status reporting, as previously discussed, and have the updateComplete method trigger stopping all of the threads when an error is reported and failOnError is true.", "author": "pwinckles", "createdAt": "2020-10-27T12:16:32Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * A reindexing worker thread.\n+ * @author whikloj\n+ */\n+public class ReindexWorker implements Runnable {\n+\n+    private Thread t;\n+    private ReindexManager manager;\n+    private ReindexService service;\n+    private boolean running = true;\n+    private boolean failOnError;\n+\n+    /**\n+     * Basic Constuctor\n+     * @param reindexManager the manager service.\n+     * @param reindexService the reindexing service.\n+     * @param failOnError whether the thread should fail on an error or log and continue.\n+     */\n+    public ReindexWorker(final ReindexManager reindexManager, final ReindexService reindexService,\n+                         final boolean failOnError) {\n+        manager = reindexManager;\n+        service = reindexService;\n+        this.failOnError = failOnError;\n+        t = new Thread(this, \"ReindexWorker\");\n+    }\n+\n+    /**\n+     * Join the thread.\n+     * @throws InterruptedException if the current thread is interrupted.\n+     */\n+    public void join() throws InterruptedException {\n+        t.join();\n+    }\n+\n+    /**\n+     * Start the thread with this Runnable\n+     */\n+    public void start() {\n+        t.start();\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (running) {\n+            final List<String> ids = manager.getIds();\n+            if (ids.isEmpty()) {\n+                stopThread();\n+                break;\n+            }\n+            final Map<String, String> states = new HashMap<>();\n+            for (final var id : ids) {\n+                try {\n+                    service.indexOcflObject(manager.getTransactionId(), id);\n+                    states.put(id, \"\");\n+                } catch (final Exception e) {\n+                    states.put(id, e.getMessage());\n+                    if (failOnError) {", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTA4MQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515105081", "bodyText": "Because each worker has a reference to the ReindexManager, I was just going to add a call to ReindexManager.stop() which stops all the threads. Do you see any problems there?", "author": "whikloj", "createdAt": "2020-10-30T13:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY0Mzk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTExMTU5Mg==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515111592", "bodyText": "Yes, that should be fine", "author": "pwinckles", "createdAt": "2020-10-30T13:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY0Mzk1NA=="}], "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java\ndeleted file mode 100644\nindex 6fd4bf0909..0000000000\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java\n+++ /dev/null\n\n@@ -1,98 +0,0 @@\n-/*\n- * Licensed to DuraSpace under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional information\n- * regarding copyright ownership.\n- *\n- * DuraSpace licenses this file to you under the Apache License,\n- * Version 2.0 (the \"License\"); you may not use this file except in\n- * compliance with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.fcrepo.persistence.ocfl.impl;\n-\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A reindexing worker thread.\n- * @author whikloj\n- */\n-public class ReindexWorker implements Runnable {\n-\n-    private Thread t;\n-    private ReindexManager manager;\n-    private ReindexService service;\n-    private boolean running = true;\n-    private boolean failOnError;\n-\n-    /**\n-     * Basic Constuctor\n-     * @param reindexManager the manager service.\n-     * @param reindexService the reindexing service.\n-     * @param failOnError whether the thread should fail on an error or log and continue.\n-     */\n-    public ReindexWorker(final ReindexManager reindexManager, final ReindexService reindexService,\n-                         final boolean failOnError) {\n-        manager = reindexManager;\n-        service = reindexService;\n-        this.failOnError = failOnError;\n-        t = new Thread(this, \"ReindexWorker\");\n-    }\n-\n-    /**\n-     * Join the thread.\n-     * @throws InterruptedException if the current thread is interrupted.\n-     */\n-    public void join() throws InterruptedException {\n-        t.join();\n-    }\n-\n-    /**\n-     * Start the thread with this Runnable\n-     */\n-    public void start() {\n-        t.start();\n-    }\n-\n-    @Override\n-    public void run() {\n-        while (running) {\n-            final List<String> ids = manager.getIds();\n-            if (ids.isEmpty()) {\n-                stopThread();\n-                break;\n-            }\n-            final Map<String, String> states = new HashMap<>();\n-            for (final var id : ids) {\n-                try {\n-                    service.indexOcflObject(manager.getTransactionId(), id);\n-                    states.put(id, \"\");\n-                } catch (final Exception e) {\n-                    states.put(id, e.getMessage());\n-                    if (failOnError) {\n-                        stopThread();\n-                        manager.updateComplete(states);\n-                        throw e;\n-                    }\n-                }\n-            }\n-            manager.updateComplete(states);\n-            service.cleanupSession(manager.getTransactionId());\n-        }\n-    }\n-\n-    /**\n-     * Stop this thread from running once it has completed its current batch.\n-     */\n-    public void stopThread() {\n-        this.running = false;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0NDM3OA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515944378", "bodyText": "Does it make sense to report the failure count here too?", "author": "pwinckles", "createdAt": "2020-11-02T12:41:34Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -114,154 +84,44 @@ public void rebuildIfNecessary() {\n     private void rebuild() {\n         LOGGER.info(\"Initiating index rebuild.\");\n \n-        ocflIndex.reset();\n-        containmentIndex.reset();\n-        searchIndex.reset();\n-        referenceService.reset();\n-        membershipService.reset();\n+        reindexService.reset();\n \n-        final var txId = UUID.randomUUID().toString();\n+        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n+                ocflPropsConfig);\n \n+        LOGGER.debug(\"Reading object ids...\");\n+        final var startTime = Instant.now();\n         try {\n-            LOGGER.debug(\"Reading object ids...\");\n-\n-            try (final var ocflIds = ocflRepository.listObjectIds()) {\n-                ocflIds.forEach(ocflId -> {\n-                    LOGGER.debug(\"Reading {}\", ocflId);\n-                    try (final var session = objectSessionFactory.newSession(ocflId)) {\n-                        indexOcflObject(ocflId, txId, session);\n-                    } catch (final Exception e) {\n-                        // The session's close method signature throws Exception\n-                        if (e instanceof RuntimeException) {\n-                            throw (RuntimeException) e;\n-                        }\n-                        throw new RuntimeException(e);\n-                    }\n-                });\n-            }\n-\n-            containmentIndex.commitTransaction(txId);\n-            ocflIndex.commit(txId);\n-            referenceService.commitTransaction(txId);\n-            indexMembership(txId);\n-            LOGGER.info(\"Index rebuild complete\");\n-        } catch (final RuntimeException e) {\n-            execQuietly(\"Failed to reset searchIndex\", () -> {\n-                searchIndex.reset();\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback containment index transaction \" + txId, () -> {\n-                containmentIndex.rollbackTransaction(txId);\n-                return null;\n-            });\n-            execQuietly(\"Failed to rollback OCFL index transaction \" + txId, () -> {\n-                ocflIndex.rollback(txId);\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback membership index transaction \" + txId, () -> {\n-                membershipService.rollbackTransaction(txId);\n-                return null;\n-            });\n-            throw e;\n+            reindexManager.start();\n+            reindexManager.commit();\n+            LOGGER.info(\"Reindexing complete.\");\n+        } catch (final InterruptedException e) {\n+            reindexManager.rollback();\n+            throw new RuntimeException(e);\n+        } finally {\n+            reindexManager.shutdown();\n         }\n+        final var endTime = Instant.now();\n+        final var count = reindexManager.getCompletedCount();\n+        LOGGER.info(\"Index rebuild complete {} objects in {} \", count,", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\nindex 1cfb6417d4..8f584dccab 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n\n@@ -84,44 +106,44 @@ public class IndexBuilderImpl implements IndexBuilder {\n     private void rebuild() {\n         LOGGER.info(\"Initiating index rebuild.\");\n \n-        reindexService.reset();\n+        ocflIndex.reset();\n+        containmentIndex.reset();\n+        searchIndex.reset();\n+        referenceService.reset();\n+        membershipService.reset();\n \n-        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n-                ocflPropsConfig);\n+        final var reindexService = new ReindexService(objectSessionFactory, ocflIndex, containmentIndex, searchIndex,\n+                referenceService, membershipService, membershipPageSize);\n+        final int availableProcessors = Runtime.getRuntime().availableProcessors();\n+        final int threads = availableProcessors > 1 ? availableProcessors - 1 : 1;\n+        final var executor = Executors.newFixedThreadPool(threads);\n+        final ReindexManager reindexManager = new ReindexManager(executor, reindexService);\n \n         LOGGER.debug(\"Reading object ids...\");\n         final var startTime = Instant.now();\n+\n+        try (final var ocflIds = ocflRepository.listObjectIds()) {\n+            ocflIds.forEach(reindexManager::submit);\n+        }\n+\n         try {\n-            reindexManager.start();\n-            reindexManager.commit();\n+            reindexManager.awaitCompletion();\n             LOGGER.info(\"Reindexing complete.\");\n+            reindexManager.shutdown();\n         } catch (final InterruptedException e) {\n-            reindexManager.rollback();\n+            Thread.currentThread().interrupt();\n             throw new RuntimeException(e);\n-        } finally {\n-            reindexManager.shutdown();\n         }\n         final var endTime = Instant.now();\n-        final var count = reindexManager.getCompletedCount();\n-        LOGGER.info(\"Index rebuild complete {} objects in {} \", count,\n-                getDurationMessage(Duration.between(startTime, endTime)));\n+        LOGGER.info(\"Index rebuild complete in {} milliseconds\", Duration.between(startTime, endTime).toMillis());\n     }\n \n \n     /**\n-     * Pass this along to the ReindexService\n      * @param pageSize number of results to use when querying for membership producing resources\n      */\n     public void setMembershipQueryPageSize(final int pageSize) {\n-        reindexService.setMembershipPageSize(pageSize);\n-    }\n-\n-    /**\n-     * Change the number of OCFL ids given out to workers at a time.\n-     * @param batchSize number of OCFL ids per batch.\n-     */\n-    public void setReindexBatchSize(final int batchSize) {\n-        this.reindexBatchSize = batchSize;\n+        this.membershipPageSize = pageSize;\n     }\n \n     private boolean shouldRebuild() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0NDY0OQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515944649", "bodyText": "Nice!", "author": "pwinckles", "createdAt": "2020-11-02T12:42:05Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -289,25 +149,14 @@ private boolean repoContainsObjects() {\n         return ocflRepository.listObjectIds().findFirst().isPresent();\n     }\n \n-    private static RdfStream parseRdf(final FedoraId fedoraIdentifier, final InputStream inputStream) {\n-        final Model model = createDefaultModel();\n-        RDFDataMgr.read(model, inputStream, getRdfFormat().getLang());\n-        final FedoraId topic = (fedoraIdentifier.isDescription() ? fedoraIdentifier.asBaseId() : fedoraIdentifier);\n-        return DefaultRdfStream.fromModel(createURI(topic.getFullId()), model);\n-    }\n-\n-    /**\n-     * Executes the closure, capturing all exceptions, and logging them as errors.\n-     *\n-     * @param failureMessage what to print if the closure fails\n-     * @param callable closure to execute\n-     */\n-    private void execQuietly(final String failureMessage, final Callable<Void> callable) {\n-        try {\n-            callable.call();\n-        } catch (final Exception e) {\n-            LOGGER.error(failureMessage, e);\n+    private String getDurationMessage(final Duration duration) {", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\nindex 1cfb6417d4..8f584dccab 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n\n@@ -149,14 +171,25 @@ public class IndexBuilderImpl implements IndexBuilder {\n         return ocflRepository.listObjectIds().findFirst().isPresent();\n     }\n \n-    private String getDurationMessage(final Duration duration) {\n-        String message = String.format(\"%d seconds\", duration.toSecondsPart());\n-        if (duration.getSeconds() > 60) {\n-            message = String.format(\"%d mins, \", duration.toMinutesPart()) + message;\n-        }\n-        if (duration.getSeconds() > 3600) {\n-            message = String.format(\"%d hours, \", duration.toHoursPart()) + message;\n+    private static RdfStream parseRdf(final FedoraId fedoraIdentifier, final InputStream inputStream) {\n+        final Model model = createDefaultModel();\n+        RDFDataMgr.read(model, inputStream, getRdfFormat().getLang());\n+        final FedoraId topic = (fedoraIdentifier.isDescription() ? fedoraIdentifier.asBaseId() : fedoraIdentifier);\n+        return DefaultRdfStream.fromModel(createURI(topic.getFullId()), model);\n+    }\n+\n+    /**\n+     * Executes the closure, capturing all exceptions, and logging them as errors.\n+     *\n+     * @param failureMessage what to print if the closure fails\n+     * @param callable closure to execute\n+     */\n+    private void execQuietly(final String failureMessage, final Callable<Void> callable) {\n+        try {\n+            callable.call();\n+        } catch (final Exception e) {\n+            LOGGER.error(failureMessage, e);\n         }\n-        return message;\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0NjYzOA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515946638", "bodyText": "Minor optimization, this list could be initialized to batchSize", "author": "pwinckles", "createdAt": "2020-11-02T12:46:00Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.fcrepo.config.OcflPropsConfig;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Class to coordinate the index rebuilding tasks.\n+ * @author whikloj\n+ * @since 6.0.0\n+ */\n+public class ReindexManager {\n+\n+    private static final Logger LOGGER = getLogger(ReindexManager.class);\n+\n+    private final String transactionId;\n+\n+    private final List<ReindexWorker> workers;\n+\n+    private final Iterator<String> ocflIter;\n+\n+    private final Stream<String> ocflStream;\n+\n+    private int completedCount;\n+\n+    private int errorCount;\n+\n+    private final ReindexService reindexService;\n+\n+    private final long batchSize;\n+\n+    private final boolean failOnError;\n+\n+    /**\n+     * Basic constructor\n+     * @param ids stream of ocfl ids.\n+     * @param reindexService the reindexing service.\n+     * @param config OCFL property config object.\n+     */\n+    public ReindexManager(final Stream<String> ids, final ReindexService reindexService, final OcflPropsConfig config) {\n+        this.ocflStream = ids;\n+        this.ocflIter = ocflStream.iterator();\n+        this.reindexService = reindexService;\n+        this.batchSize = config.getReindexBatchSize();\n+        this.failOnError = config.isReindexFailOnError();\n+        transactionId = UUID.randomUUID().toString();\n+        workers = new ArrayList<>();\n+        for (var foo = 0; foo < config.getReindexingThreads(); foo += 1) {\n+            workers.add(new ReindexWorker(this, this.reindexService, transactionId, this.failOnError));\n+        }\n+    }\n+\n+    /**\n+     * Start reindexing.\n+     * @throws InterruptedException on an indexing error in a thread.\n+     */\n+    public void start() throws InterruptedException {\n+        try {\n+            workers.forEach(ReindexWorker::start);\n+            for (final var worker : workers) {\n+                worker.join();\n+            }\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Error while rebuilding index\", e);\n+            stop();\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Stop all threads.\n+     */\n+    public void stop() {\n+        workers.forEach(ReindexWorker::stopThread);\n+    }\n+\n+    /**\n+     * Return a batch of OCFL ids to reindex.\n+     * @return list of OCFL ids.\n+     */\n+    public synchronized List<String> getIds() {\n+        int counter = 0;\n+        final List<String> ids = new ArrayList<>();", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\nindex deee2bf3f5..3e098182d5 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\n\n@@ -19,142 +19,107 @@ package org.fcrepo.persistence.ocfl.impl;\n \n import static org.slf4j.LoggerFactory.getLogger;\n \n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n import java.util.UUID;\n-import java.util.stream.Stream;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n \n-import org.fcrepo.config.OcflPropsConfig;\n import org.slf4j.Logger;\n \n /**\n  * Class to coordinate the index rebuilding tasks.\n  * @author whikloj\n- * @since 6.0.0\n  */\n public class ReindexManager {\n \n     private static final Logger LOGGER = getLogger(ReindexManager.class);\n \n-    private final String transactionId;\n-\n-    private final List<ReindexWorker> workers;\n-\n-    private final Iterator<String> ocflIter;\n-\n-    private final Stream<String> ocflStream;\n+    private final ExecutorService executorService;\n \n-    private int completedCount;\n+    private final ReindexService reindexService;\n \n-    private int errorCount;\n+    private final AtomicLong count;\n \n-    private final ReindexService reindexService;\n+    private final Object lock;\n \n-    private final long batchSize;\n+    private final AtomicLong complete;\n \n-    private final boolean failOnError;\n+    private final String transactionId;\n \n     /**\n      * Basic constructor\n-     * @param ids stream of ocfl ids.\n-     * @param reindexService the reindexing service.\n-     * @param config OCFL property config object.\n+     * @param execSrvc the executorservice\n+     * @param reindexSrvc the ReindexService.\n      */\n-    public ReindexManager(final Stream<String> ids, final ReindexService reindexService, final OcflPropsConfig config) {\n-        this.ocflStream = ids;\n-        this.ocflIter = ocflStream.iterator();\n-        this.reindexService = reindexService;\n-        this.batchSize = config.getReindexBatchSize();\n-        this.failOnError = config.isReindexFailOnError();\n+    public ReindexManager(final ExecutorService execSrvc, final ReindexService reindexSrvc) {\n+        executorService = execSrvc;\n+        reindexService = reindexSrvc;\n+        count = new AtomicLong(0);\n+        complete = new AtomicLong(0);\n+        lock = new Object();\n         transactionId = UUID.randomUUID().toString();\n-        workers = new ArrayList<>();\n-        for (var foo = 0; foo < config.getReindexingThreads(); foo += 1) {\n-            workers.add(new ReindexWorker(this, this.reindexService, transactionId, this.failOnError));\n-        }\n     }\n \n     /**\n-     * Start reindexing.\n-     * @throws InterruptedException on an indexing error in a thread.\n+     * Add a new task to the executor service.\n+     * @param id the OCFL id to reindex.\n      */\n-    public void start() throws InterruptedException {\n-        try {\n-            workers.forEach(ReindexWorker::start);\n-            for (final var worker : workers) {\n-                worker.join();\n+    public void submit(final String id) {\n+        final var task = new ReindexTask(transactionId, id, reindexService);\n+\n+        executorService.submit(() -> {\n+            try {\n+                task.run();\n+            } finally {\n+                count.decrementAndGet();\n+                complete.incrementAndGet();\n+                synchronized (lock) {\n+                    lock.notifyAll();\n+                }\n             }\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Error while rebuilding index\", e);\n-            stop();\n-            throw e;\n-        }\n-    }\n+        });\n \n-    /**\n-     * Stop all threads.\n-     */\n-    public void stop() {\n-        workers.forEach(ReindexWorker::stopThread);\n+        count.incrementAndGet();\n     }\n \n     /**\n-     * Return a batch of OCFL ids to reindex.\n-     * @return list of OCFL ids.\n+     * Blocks until all migration tasks are complete. Note, this does not prevent additional tasks from being submitted.\n+     * It simply waits until the queue is empty.\n+     *\n+     * @throws InterruptedException on interrupt\n      */\n-    public synchronized List<String> getIds() {\n-        int counter = 0;\n-        final List<String> ids = new ArrayList<>();\n-        while (ocflIter.hasNext() && counter < batchSize) {\n-            ids.add(ocflIter.next());\n-            counter += 1;\n+    public void awaitCompletion() throws InterruptedException {\n+        LOGGER.info(\"OCFL objects to index: {}\", count.get());\n+        if (count.get() == 0) {\n+            return;\n         }\n-        return ids;\n-    }\n-\n-    /**\n-     * Update the master list of reindexing states.\n-     * @param batchSuccessful how many items were completed successfully in the last batch.\n-     * @param batchErrors how many items had an error in the last batch.\n-     */\n-    public void updateComplete(final int batchSuccessful, final int batchErrors) {\n-        completedCount += batchSuccessful;\n-        errorCount += batchErrors;\n-    }\n-\n-    /**\n-     * @return the count of items that completed successfully.\n-     */\n-    public int getCompletedCount() {\n-        return completedCount;\n-    }\n \n-    /**\n-     * @return the count of items that had errors.\n-     */\n-    public int getErrorCount() {\n-        return errorCount;\n+        synchronized (lock) {\n+            while (count.get() > 0) {\n+                lock.wait();\n+            }\n+        }\n     }\n \n     /**\n-     * Commit the actions.\n+     * Commit the actions, shut down the executor and closes all resources.\n+     *\n+     * @throws InterruptedException on interrupt\n      */\n-    public void commit() {\n+    public void shutdown() throws InterruptedException {\n         reindexService.commit(transactionId);\n-        reindexService.indexMembership(transactionId);\n-    }\n-\n-    /**\n-     * Rollback the current transaction.\n-     */\n-    public void rollback() {\n-        reindexService.rollback(transactionId);\n+        executorService.shutdown();\n+        if (!executorService.awaitTermination(1, TimeUnit.MINUTES)) {\n+            LOGGER.error(\"Failed to shutdown executor service cleanly after 1 minute of waiting\");\n+            executorService.shutdownNow();\n+        }\n     }\n \n     /**\n-     * Close stream.\n+     * Get the number of completed ocfl objects rebuilt.\n+     * @return the completed count.\n      */\n-    public void shutdown() {\n-        ocflStream.close();\n+    public long getProcessed() {\n+        return complete.get();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0NzQyMA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515947420", "bodyText": "Either this method needs to be synchronized or the counts need to be Atomic", "author": "pwinckles", "createdAt": "2020-11-02T12:47:32Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.fcrepo.config.OcflPropsConfig;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Class to coordinate the index rebuilding tasks.\n+ * @author whikloj\n+ * @since 6.0.0\n+ */\n+public class ReindexManager {\n+\n+    private static final Logger LOGGER = getLogger(ReindexManager.class);\n+\n+    private final String transactionId;\n+\n+    private final List<ReindexWorker> workers;\n+\n+    private final Iterator<String> ocflIter;\n+\n+    private final Stream<String> ocflStream;\n+\n+    private int completedCount;\n+\n+    private int errorCount;\n+\n+    private final ReindexService reindexService;\n+\n+    private final long batchSize;\n+\n+    private final boolean failOnError;\n+\n+    /**\n+     * Basic constructor\n+     * @param ids stream of ocfl ids.\n+     * @param reindexService the reindexing service.\n+     * @param config OCFL property config object.\n+     */\n+    public ReindexManager(final Stream<String> ids, final ReindexService reindexService, final OcflPropsConfig config) {\n+        this.ocflStream = ids;\n+        this.ocflIter = ocflStream.iterator();\n+        this.reindexService = reindexService;\n+        this.batchSize = config.getReindexBatchSize();\n+        this.failOnError = config.isReindexFailOnError();\n+        transactionId = UUID.randomUUID().toString();\n+        workers = new ArrayList<>();\n+        for (var foo = 0; foo < config.getReindexingThreads(); foo += 1) {\n+            workers.add(new ReindexWorker(this, this.reindexService, transactionId, this.failOnError));\n+        }\n+    }\n+\n+    /**\n+     * Start reindexing.\n+     * @throws InterruptedException on an indexing error in a thread.\n+     */\n+    public void start() throws InterruptedException {\n+        try {\n+            workers.forEach(ReindexWorker::start);\n+            for (final var worker : workers) {\n+                worker.join();\n+            }\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Error while rebuilding index\", e);\n+            stop();\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Stop all threads.\n+     */\n+    public void stop() {\n+        workers.forEach(ReindexWorker::stopThread);\n+    }\n+\n+    /**\n+     * Return a batch of OCFL ids to reindex.\n+     * @return list of OCFL ids.\n+     */\n+    public synchronized List<String> getIds() {\n+        int counter = 0;\n+        final List<String> ids = new ArrayList<>();\n+        while (ocflIter.hasNext() && counter < batchSize) {\n+            ids.add(ocflIter.next());\n+            counter += 1;\n+        }\n+        return ids;\n+    }\n+\n+    /**\n+     * Update the master list of reindexing states.\n+     * @param batchSuccessful how many items were completed successfully in the last batch.\n+     * @param batchErrors how many items had an error in the last batch.\n+     */\n+    public void updateComplete(final int batchSuccessful, final int batchErrors) {", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\nindex deee2bf3f5..3e098182d5 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java\n\n@@ -19,142 +19,107 @@ package org.fcrepo.persistence.ocfl.impl;\n \n import static org.slf4j.LoggerFactory.getLogger;\n \n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n import java.util.UUID;\n-import java.util.stream.Stream;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n \n-import org.fcrepo.config.OcflPropsConfig;\n import org.slf4j.Logger;\n \n /**\n  * Class to coordinate the index rebuilding tasks.\n  * @author whikloj\n- * @since 6.0.0\n  */\n public class ReindexManager {\n \n     private static final Logger LOGGER = getLogger(ReindexManager.class);\n \n-    private final String transactionId;\n-\n-    private final List<ReindexWorker> workers;\n-\n-    private final Iterator<String> ocflIter;\n-\n-    private final Stream<String> ocflStream;\n+    private final ExecutorService executorService;\n \n-    private int completedCount;\n+    private final ReindexService reindexService;\n \n-    private int errorCount;\n+    private final AtomicLong count;\n \n-    private final ReindexService reindexService;\n+    private final Object lock;\n \n-    private final long batchSize;\n+    private final AtomicLong complete;\n \n-    private final boolean failOnError;\n+    private final String transactionId;\n \n     /**\n      * Basic constructor\n-     * @param ids stream of ocfl ids.\n-     * @param reindexService the reindexing service.\n-     * @param config OCFL property config object.\n+     * @param execSrvc the executorservice\n+     * @param reindexSrvc the ReindexService.\n      */\n-    public ReindexManager(final Stream<String> ids, final ReindexService reindexService, final OcflPropsConfig config) {\n-        this.ocflStream = ids;\n-        this.ocflIter = ocflStream.iterator();\n-        this.reindexService = reindexService;\n-        this.batchSize = config.getReindexBatchSize();\n-        this.failOnError = config.isReindexFailOnError();\n+    public ReindexManager(final ExecutorService execSrvc, final ReindexService reindexSrvc) {\n+        executorService = execSrvc;\n+        reindexService = reindexSrvc;\n+        count = new AtomicLong(0);\n+        complete = new AtomicLong(0);\n+        lock = new Object();\n         transactionId = UUID.randomUUID().toString();\n-        workers = new ArrayList<>();\n-        for (var foo = 0; foo < config.getReindexingThreads(); foo += 1) {\n-            workers.add(new ReindexWorker(this, this.reindexService, transactionId, this.failOnError));\n-        }\n     }\n \n     /**\n-     * Start reindexing.\n-     * @throws InterruptedException on an indexing error in a thread.\n+     * Add a new task to the executor service.\n+     * @param id the OCFL id to reindex.\n      */\n-    public void start() throws InterruptedException {\n-        try {\n-            workers.forEach(ReindexWorker::start);\n-            for (final var worker : workers) {\n-                worker.join();\n+    public void submit(final String id) {\n+        final var task = new ReindexTask(transactionId, id, reindexService);\n+\n+        executorService.submit(() -> {\n+            try {\n+                task.run();\n+            } finally {\n+                count.decrementAndGet();\n+                complete.incrementAndGet();\n+                synchronized (lock) {\n+                    lock.notifyAll();\n+                }\n             }\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Error while rebuilding index\", e);\n-            stop();\n-            throw e;\n-        }\n-    }\n+        });\n \n-    /**\n-     * Stop all threads.\n-     */\n-    public void stop() {\n-        workers.forEach(ReindexWorker::stopThread);\n+        count.incrementAndGet();\n     }\n \n     /**\n-     * Return a batch of OCFL ids to reindex.\n-     * @return list of OCFL ids.\n+     * Blocks until all migration tasks are complete. Note, this does not prevent additional tasks from being submitted.\n+     * It simply waits until the queue is empty.\n+     *\n+     * @throws InterruptedException on interrupt\n      */\n-    public synchronized List<String> getIds() {\n-        int counter = 0;\n-        final List<String> ids = new ArrayList<>();\n-        while (ocflIter.hasNext() && counter < batchSize) {\n-            ids.add(ocflIter.next());\n-            counter += 1;\n+    public void awaitCompletion() throws InterruptedException {\n+        LOGGER.info(\"OCFL objects to index: {}\", count.get());\n+        if (count.get() == 0) {\n+            return;\n         }\n-        return ids;\n-    }\n-\n-    /**\n-     * Update the master list of reindexing states.\n-     * @param batchSuccessful how many items were completed successfully in the last batch.\n-     * @param batchErrors how many items had an error in the last batch.\n-     */\n-    public void updateComplete(final int batchSuccessful, final int batchErrors) {\n-        completedCount += batchSuccessful;\n-        errorCount += batchErrors;\n-    }\n-\n-    /**\n-     * @return the count of items that completed successfully.\n-     */\n-    public int getCompletedCount() {\n-        return completedCount;\n-    }\n \n-    /**\n-     * @return the count of items that had errors.\n-     */\n-    public int getErrorCount() {\n-        return errorCount;\n+        synchronized (lock) {\n+            while (count.get() > 0) {\n+                lock.wait();\n+            }\n+        }\n     }\n \n     /**\n-     * Commit the actions.\n+     * Commit the actions, shut down the executor and closes all resources.\n+     *\n+     * @throws InterruptedException on interrupt\n      */\n-    public void commit() {\n+    public void shutdown() throws InterruptedException {\n         reindexService.commit(transactionId);\n-        reindexService.indexMembership(transactionId);\n-    }\n-\n-    /**\n-     * Rollback the current transaction.\n-     */\n-    public void rollback() {\n-        reindexService.rollback(transactionId);\n+        executorService.shutdown();\n+        if (!executorService.awaitTermination(1, TimeUnit.MINUTES)) {\n+            LOGGER.error(\"Failed to shutdown executor service cleanly after 1 minute of waiting\");\n+            executorService.shutdownNow();\n+        }\n     }\n \n     /**\n-     * Close stream.\n+     * Get the number of completed ocfl objects rebuilt.\n+     * @return the completed count.\n      */\n-    public void shutdown() {\n-        ocflStream.close();\n+    public long getProcessed() {\n+        return complete.get();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk1MDQxMg==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515950412", "bodyText": "I think the body of this method needs to be same as the catch block in the commit method. That is to say, each rollback needs to be called so that if it fails it doesn't prevent the subsequent rollbacks from executing.", "author": "pwinckles", "createdAt": "2020-11-02T12:53:01Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.apache.jena.graph.NodeFactory.createURI;\n+import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;\n+import static org.fcrepo.kernel.api.RdfLexicon.NON_RDF_SOURCE;\n+import static org.fcrepo.persistence.ocfl.impl.OcflPersistentStorageUtils.getRdfFormat;\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import javax.inject.Inject;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.jena.rdf.model.Model;\n+import org.apache.jena.riot.RDFDataMgr;\n+import org.fcrepo.kernel.api.ContainmentIndex;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.ResourceHeaders;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+import org.fcrepo.kernel.api.services.ReferenceService;\n+import org.fcrepo.persistence.api.PersistentStorageSessionManager;\n+import org.fcrepo.persistence.ocfl.api.FedoraToOcflObjectIndex;\n+import org.fcrepo.search.api.Condition;\n+import org.fcrepo.search.api.InvalidQueryException;\n+import org.fcrepo.search.api.SearchIndex;\n+import org.fcrepo.search.api.SearchParameters;\n+import org.fcrepo.storage.ocfl.OcflObjectSessionFactory;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * Service that does the reindexing for one OCFL object.\n+ * @author whikloj\n+ */\n+@Component\n+public class ReindexService {\n+\n+    @Inject\n+    private PersistentStorageSessionManager persistentStorageSessionManager;\n+\n+    @Inject\n+    private OcflObjectSessionFactory ocflObjectSessionFactory;\n+\n+    @Autowired\n+    @Qualifier(\"ocflIndex\")\n+    private FedoraToOcflObjectIndex ocflIndex;\n+\n+    @Autowired\n+    @Qualifier(\"containmentIndex\")\n+    private ContainmentIndex containmentIndex;\n+\n+    @Autowired\n+    @Qualifier(\"searchIndex\")\n+    private SearchIndex searchIndex;\n+\n+    @Autowired\n+    @Qualifier(\"referenceService\")\n+    private ReferenceService referenceService;\n+\n+    @Inject\n+    private MembershipService membershipService;\n+\n+    private static final Logger LOGGER = getLogger(ReindexService.class);\n+\n+    private int membershipPageSize = 500;\n+\n+    public void indexOcflObject(final String txId, final String ocflId) {\n+        LOGGER.debug(\"Indexing ocflId {} in transaction {}\", ocflId, txId);\n+        try (final var session = ocflObjectSessionFactory.newSession(ocflId)) {\n+            final var rootId = new AtomicReference<FedoraId>();\n+            final var fedoraIds = new ArrayList<FedoraId>();\n+            final var headersList = new ArrayList<ResourceHeaders>();\n+\n+            session.streamResourceHeaders().forEach(storageHeaders -> {\n+                final var headers = new ResourceHeadersAdapter(storageHeaders);\n+\n+                final var fedoraId = headers.getId();\n+                fedoraIds.add(fedoraId);\n+                if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                    rootId.set(fedoraId);\n+                }\n+\n+                if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n+\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(\n+                                    String.format(\"Resource %s must have a parent defined\", fedoraId.getFullId()));\n+                        }\n+                    }\n+                    if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n+                        final Optional<InputStream> content = session.readContent(fedoraId.getFullId())\n+                                .getContentStream();\n+                        if (content.isPresent()) {\n+                            final RdfStream rdf = parseRdf(fedoraId, content.get());\n+                            this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n+                        }\n+                    }\n+\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n+                }\n+            });\n+\n+            if (rootId.get() == null) {\n+                throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n+            }\n+\n+            fedoraIds.forEach(fedoraIdentifier -> {\n+                final var rootFedoraIdentifier = rootId.get();\n+                ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n+                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n+            });\n+\n+            headersList.forEach(headers -> {\n+                searchIndex.addUpdateIndex(txId, headers);\n+                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Remove persistent sessions for a transaction to avoid memory leaks.\n+     * @param transactionId the transaction id.\n+     */\n+    public void cleanupSession(final String transactionId) {\n+        persistentStorageSessionManager.removeSession(transactionId);\n+    }\n+\n+    /**\n+     * Set the membership page size.\n+     * @param pageSize the new page size.\n+     */\n+    public void setMembershipPageSize(final int pageSize) {\n+        membershipPageSize = pageSize;\n+    }\n+\n+    /**\n+     * Reset all the indexes.\n+     */\n+    public void reset() {\n+        ocflIndex.reset();\n+        containmentIndex.reset();\n+        searchIndex.reset();\n+        referenceService.reset();\n+        membershipService.reset();\n+    }\n+\n+    /**\n+     * Commit the records added from transaction.\n+     * @param transactionId the id of the transaction.\n+     */\n+    public void commit(final String transactionId) {\n+        try {\n+            LOGGER.debug(\"Performing commit\");\n+            containmentIndex.commitTransaction(transactionId);\n+            ocflIndex.commit(transactionId);\n+            referenceService.commitTransaction(transactionId);\n+            LOGGER.debug(\"Finished commit\");\n+        } catch (final RuntimeException e) {\n+            execQuietly(\"Failed to reset searchIndex\", () -> {\n+                searchIndex.reset();\n+                return null;\n+            });\n+\n+            execQuietly(\"Failed to rollback containment index transaction \" + transactionId, () -> {\n+                containmentIndex.rollbackTransaction(transactionId);\n+                return null;\n+            });\n+            execQuietly(\"Failed to rollback OCFL index transaction \" + transactionId, () -> {\n+                ocflIndex.rollback(transactionId);\n+                return null;\n+            });\n+\n+            execQuietly(\"Failed to rollback the reference index transaction \" + transactionId, () -> {\n+                referenceService.rollbackTransaction(transactionId);\n+                return null;\n+            });\n+\n+            execQuietly(\"Failed to rollback membership index transaction \" + transactionId, () -> {\n+                membershipService.rollbackTransaction(transactionId);\n+                return null;\n+            });\n+            throw e;\n+        }\n+    }\n+\n+    public void rollback(final String transactionId) {", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\nindex bfdb5b3304..3384e388cc 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\n\n@@ -23,8 +23,6 @@ import static org.fcrepo.kernel.api.RdfLexicon.NON_RDF_SOURCE;\n import static org.fcrepo.persistence.ocfl.impl.OcflPersistentStorageUtils.getRdfFormat;\n import static org.slf4j.LoggerFactory.getLogger;\n \n-import javax.inject.Inject;\n-\n import java.io.InputStream;\n import java.util.ArrayList;\n import java.util.List;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk1MTA4Mg==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515951082", "bodyText": "Maybe have a DEBUG log when the membership indexing starts?", "author": "pwinckles", "createdAt": "2020-11-02T12:54:14Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.apache.jena.graph.NodeFactory.createURI;\n+import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;\n+import static org.fcrepo.kernel.api.RdfLexicon.NON_RDF_SOURCE;\n+import static org.fcrepo.persistence.ocfl.impl.OcflPersistentStorageUtils.getRdfFormat;\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import javax.inject.Inject;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.jena.rdf.model.Model;\n+import org.apache.jena.riot.RDFDataMgr;\n+import org.fcrepo.kernel.api.ContainmentIndex;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.ResourceHeaders;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+import org.fcrepo.kernel.api.services.ReferenceService;\n+import org.fcrepo.persistence.api.PersistentStorageSessionManager;\n+import org.fcrepo.persistence.ocfl.api.FedoraToOcflObjectIndex;\n+import org.fcrepo.search.api.Condition;\n+import org.fcrepo.search.api.InvalidQueryException;\n+import org.fcrepo.search.api.SearchIndex;\n+import org.fcrepo.search.api.SearchParameters;\n+import org.fcrepo.storage.ocfl.OcflObjectSessionFactory;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * Service that does the reindexing for one OCFL object.\n+ * @author whikloj\n+ */\n+@Component\n+public class ReindexService {\n+\n+    @Inject\n+    private PersistentStorageSessionManager persistentStorageSessionManager;\n+\n+    @Inject\n+    private OcflObjectSessionFactory ocflObjectSessionFactory;\n+\n+    @Autowired\n+    @Qualifier(\"ocflIndex\")\n+    private FedoraToOcflObjectIndex ocflIndex;\n+\n+    @Autowired\n+    @Qualifier(\"containmentIndex\")\n+    private ContainmentIndex containmentIndex;\n+\n+    @Autowired\n+    @Qualifier(\"searchIndex\")\n+    private SearchIndex searchIndex;\n+\n+    @Autowired\n+    @Qualifier(\"referenceService\")\n+    private ReferenceService referenceService;\n+\n+    @Inject\n+    private MembershipService membershipService;\n+\n+    private static final Logger LOGGER = getLogger(ReindexService.class);\n+\n+    private int membershipPageSize = 500;\n+\n+    public void indexOcflObject(final String txId, final String ocflId) {\n+        LOGGER.debug(\"Indexing ocflId {} in transaction {}\", ocflId, txId);\n+        try (final var session = ocflObjectSessionFactory.newSession(ocflId)) {\n+            final var rootId = new AtomicReference<FedoraId>();\n+            final var fedoraIds = new ArrayList<FedoraId>();\n+            final var headersList = new ArrayList<ResourceHeaders>();\n+\n+            session.streamResourceHeaders().forEach(storageHeaders -> {\n+                final var headers = new ResourceHeadersAdapter(storageHeaders);\n+\n+                final var fedoraId = headers.getId();\n+                fedoraIds.add(fedoraId);\n+                if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                    rootId.set(fedoraId);\n+                }\n+\n+                if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n+\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(\n+                                    String.format(\"Resource %s must have a parent defined\", fedoraId.getFullId()));\n+                        }\n+                    }\n+                    if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n+                        final Optional<InputStream> content = session.readContent(fedoraId.getFullId())\n+                                .getContentStream();\n+                        if (content.isPresent()) {\n+                            final RdfStream rdf = parseRdf(fedoraId, content.get());\n+                            this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n+                        }\n+                    }\n+\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n+                }\n+            });\n+\n+            if (rootId.get() == null) {\n+                throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n+            }\n+\n+            fedoraIds.forEach(fedoraIdentifier -> {\n+                final var rootFedoraIdentifier = rootId.get();\n+                ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n+                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n+            });\n+\n+            headersList.forEach(headers -> {\n+                searchIndex.addUpdateIndex(txId, headers);\n+                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Remove persistent sessions for a transaction to avoid memory leaks.\n+     * @param transactionId the transaction id.\n+     */\n+    public void cleanupSession(final String transactionId) {\n+        persistentStorageSessionManager.removeSession(transactionId);\n+    }\n+\n+    /**\n+     * Set the membership page size.\n+     * @param pageSize the new page size.\n+     */\n+    public void setMembershipPageSize(final int pageSize) {\n+        membershipPageSize = pageSize;\n+    }\n+\n+    /**\n+     * Reset all the indexes.\n+     */\n+    public void reset() {\n+        ocflIndex.reset();\n+        containmentIndex.reset();\n+        searchIndex.reset();\n+        referenceService.reset();\n+        membershipService.reset();\n+    }\n+\n+    /**\n+     * Commit the records added from transaction.\n+     * @param transactionId the id of the transaction.\n+     */\n+    public void commit(final String transactionId) {\n+        try {\n+            LOGGER.debug(\"Performing commit\");\n+            containmentIndex.commitTransaction(transactionId);\n+            ocflIndex.commit(transactionId);\n+            referenceService.commitTransaction(transactionId);\n+            LOGGER.debug(\"Finished commit\");\n+        } catch (final RuntimeException e) {\n+            execQuietly(\"Failed to reset searchIndex\", () -> {\n+                searchIndex.reset();\n+                return null;\n+            });\n+\n+            execQuietly(\"Failed to rollback containment index transaction \" + transactionId, () -> {\n+                containmentIndex.rollbackTransaction(transactionId);\n+                return null;\n+            });\n+            execQuietly(\"Failed to rollback OCFL index transaction \" + transactionId, () -> {\n+                ocflIndex.rollback(transactionId);\n+                return null;\n+            });\n+\n+            execQuietly(\"Failed to rollback the reference index transaction \" + transactionId, () -> {\n+                referenceService.rollbackTransaction(transactionId);\n+                return null;\n+            });\n+\n+            execQuietly(\"Failed to rollback membership index transaction \" + transactionId, () -> {\n+                membershipService.rollbackTransaction(transactionId);\n+                return null;\n+            });\n+            throw e;\n+        }\n+    }\n+\n+    public void rollback(final String transactionId) {\n+        searchIndex.reset();\n+        containmentIndex.rollbackTransaction(transactionId);\n+        referenceService.rollbackTransaction(transactionId);\n+        ocflIndex.rollback(transactionId);\n+        membershipService.rollbackTransaction(transactionId);\n+    }\n+\n+    /**\n+     * Index all membership properties by querying for Direct containers, and then\n+     * trying population of the membership index for each one\n+     * @param txId the transaction id.\n+     */\n+    public void indexMembership(final String txId) {", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\nindex bfdb5b3304..3384e388cc 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\n\n@@ -23,8 +23,6 @@ import static org.fcrepo.kernel.api.RdfLexicon.NON_RDF_SOURCE;\n import static org.fcrepo.persistence.ocfl.impl.OcflPersistentStorageUtils.getRdfFormat;\n import static org.slf4j.LoggerFactory.getLogger;\n \n-import javax.inject.Inject;\n-\n import java.io.InputStream;\n import java.util.ArrayList;\n import java.util.List;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk1NTQ1NA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515955454", "bodyText": "If failOnError is not set, I think it might make sense to WARN/ERROR the exception here", "author": "pwinckles", "createdAt": "2020-11-02T13:01:56Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import java.util.List;\n+\n+/**\n+ * A reindexing worker thread.\n+ * @author whikloj\n+ */\n+public class ReindexWorker implements Runnable {\n+\n+    private Thread t;\n+    private ReindexManager manager;\n+    private ReindexService service;\n+    private String transactionId;\n+    private boolean running = true;\n+    private boolean failOnError;\n+\n+    /**\n+     * Basic Constuctor\n+     * @param reindexManager the manager service.\n+     * @param reindexService the reindexing service.\n+     * @param txId the transaction id.\n+     * @param failOnError whether the thread should fail on an error or log and continue.\n+     */\n+    public ReindexWorker(final ReindexManager reindexManager, final ReindexService reindexService,\n+                         final String txId, final boolean failOnError) {\n+        manager = reindexManager;\n+        service = reindexService;\n+        transactionId = txId;\n+        this.failOnError = failOnError;\n+        t = new Thread(this, \"ReindexWorker\");\n+    }\n+\n+    /**\n+     * Join the thread.\n+     * @throws InterruptedException if the current thread is interrupted.\n+     */\n+    public void join() throws InterruptedException {\n+        t.join();\n+    }\n+\n+    /**\n+     * Start the thread with this Runnable\n+     */\n+    public void start() {\n+        t.start();\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (running) {\n+            final List<String> ids = manager.getIds();\n+            if (ids.isEmpty()) {\n+                stopThread();\n+                break;\n+            }\n+            int completed = 0;\n+            int errors = 0;\n+            for (final var id : ids) {\n+                if (!running) {\n+                    break;\n+                }\n+                try {\n+                    service.indexOcflObject(transactionId, id);\n+                    completed += 1;\n+                } catch (final Exception e) {\n+                    errors += 1;\n+                    if (failOnError) {", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java\ndeleted file mode 100644\nindex 780935ed75..0000000000\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java\n+++ /dev/null\n\n@@ -1,105 +0,0 @@\n-/*\n- * Licensed to DuraSpace under one or more contributor license agreements.\n- * See the NOTICE file distributed with this work for additional information\n- * regarding copyright ownership.\n- *\n- * DuraSpace licenses this file to you under the Apache License,\n- * Version 2.0 (the \"License\"); you may not use this file except in\n- * compliance with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.fcrepo.persistence.ocfl.impl;\n-\n-import java.util.List;\n-\n-/**\n- * A reindexing worker thread.\n- * @author whikloj\n- */\n-public class ReindexWorker implements Runnable {\n-\n-    private Thread t;\n-    private ReindexManager manager;\n-    private ReindexService service;\n-    private String transactionId;\n-    private boolean running = true;\n-    private boolean failOnError;\n-\n-    /**\n-     * Basic Constuctor\n-     * @param reindexManager the manager service.\n-     * @param reindexService the reindexing service.\n-     * @param txId the transaction id.\n-     * @param failOnError whether the thread should fail on an error or log and continue.\n-     */\n-    public ReindexWorker(final ReindexManager reindexManager, final ReindexService reindexService,\n-                         final String txId, final boolean failOnError) {\n-        manager = reindexManager;\n-        service = reindexService;\n-        transactionId = txId;\n-        this.failOnError = failOnError;\n-        t = new Thread(this, \"ReindexWorker\");\n-    }\n-\n-    /**\n-     * Join the thread.\n-     * @throws InterruptedException if the current thread is interrupted.\n-     */\n-    public void join() throws InterruptedException {\n-        t.join();\n-    }\n-\n-    /**\n-     * Start the thread with this Runnable\n-     */\n-    public void start() {\n-        t.start();\n-    }\n-\n-    @Override\n-    public void run() {\n-        while (running) {\n-            final List<String> ids = manager.getIds();\n-            if (ids.isEmpty()) {\n-                stopThread();\n-                break;\n-            }\n-            int completed = 0;\n-            int errors = 0;\n-            for (final var id : ids) {\n-                if (!running) {\n-                    break;\n-                }\n-                try {\n-                    service.indexOcflObject(transactionId, id);\n-                    completed += 1;\n-                } catch (final Exception e) {\n-                    errors += 1;\n-                    if (failOnError) {\n-                        stopThread();\n-                        manager.updateComplete(completed, errors);\n-                        manager.stop();\n-                        service.cleanupSession(transactionId);\n-                        throw e;\n-                    }\n-                }\n-            }\n-            manager.updateComplete(completed, errors);\n-            service.cleanupSession(transactionId);\n-        }\n-    }\n-\n-    /**\n-     * Stop this thread from running once it has completed its current batch.\n-     */\n-    public void stopThread() {\n-        this.running = false;\n-    }\n-}\n"}}, {"oid": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "url": "https://github.com/fcrepo/fcrepo/commit/feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "message": "Parallelize index rebuilding", "committedDate": "2020-11-02T15:39:06Z", "type": "commit"}, {"oid": "b01c34d51c9300baaef7c023b4c6348da5dcaed0", "url": "https://github.com/fcrepo/fcrepo/commit/b01c34d51c9300baaef7c023b4c6348da5dcaed0", "message": "Make workers request ids from manager", "committedDate": "2020-11-02T15:39:06Z", "type": "commit"}, {"oid": "ddf0941f13992ad7205421dfdf74ad9dfd00113a", "url": "https://github.com/fcrepo/fcrepo/commit/ddf0941f13992ad7205421dfdf74ad9dfd00113a", "message": "Remove unneeded class and return state for each batch", "committedDate": "2020-11-02T15:39:06Z", "type": "commit"}, {"oid": "ce4779b94792265e6ae29db1f4d1d1d55e307890", "url": "https://github.com/fcrepo/fcrepo/commit/ce4779b94792265e6ae29db1f4d1d1d55e307890", "message": "Make reindex configurable, only track counts, rollback on error if failOnError=true", "committedDate": "2020-11-02T15:39:06Z", "type": "commit"}, {"oid": "25cc72fe7158bcc8e9e70839072cc9ce92782f43", "url": "https://github.com/fcrepo/fcrepo/commit/25cc72fe7158bcc8e9e70839072cc9ce92782f43", "message": "Code review", "committedDate": "2020-11-02T15:39:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2MTk1OQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516061959", "bodyText": "Can you change this to:\nLOGGER.error(\"Reindexing of OCFL id {} failed\", id, e);\nIt'll make it a lot easier to figure out what went wrong", "author": "pwinckles", "createdAt": "2020-11-02T15:43:20Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java", "diffHunk": "@@ -89,6 +94,7 @@ public void run() {\n                         service.cleanupSession(transactionId);\n                         throw e;\n                     }\n+                    LOGGER.error(\"Reindexing of OCFL id {} failed: {}\", id, e.getMessage());", "originalCommit": "1fe0c30fa7831993e150de5a3a0882e77f1a1f1c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3629680e291ce63441702130eb925b9f4448576f", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java\nindex e0f5ba0ec1..298a6cf7e1 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java\n\n@@ -94,7 +94,7 @@ public class ReindexWorker implements Runnable {\n                         service.cleanupSession(transactionId);\n                         throw e;\n                     }\n-                    LOGGER.error(\"Reindexing of OCFL id {} failed: {}\", id, e.getMessage());\n+                    LOGGER.error(\"Reindexing of OCFL id {} failed\", id, e);\n                 }\n             }\n             manager.updateComplete(completed, errors);\n"}}, {"oid": "25cc72fe7158bcc8e9e70839072cc9ce92782f43", "url": "https://github.com/fcrepo/fcrepo/commit/25cc72fe7158bcc8e9e70839072cc9ce92782f43", "message": "Code review", "committedDate": "2020-11-02T15:39:07Z", "type": "forcePushed"}, {"oid": "3629680e291ce63441702130eb925b9f4448576f", "url": "https://github.com/fcrepo/fcrepo/commit/3629680e291ce63441702130eb925b9f4448576f", "message": "Log full stacktrace", "committedDate": "2020-11-02T16:17:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjExMTUzOQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516111539", "bodyText": "We will need to either document these configuration elements in the wiki now, or as a follow-on ticket.", "author": "awoods", "createdAt": "2020-11-02T16:51:41Z", "path": "fcrepo-configs/src/main/java/org/fcrepo/config/OcflPropsConfig.java", "diffHunk": "@@ -92,12 +92,31 @@\n     @Value(\"${fcrepo.resource-header-cache.expire-after-seconds:600}\")\n     private long resourceHeadersCacheExpireAfterSeconds;\n \n+    @Value(\"${fcrepo.ocfl.reindex.threads:-1}\")", "originalCommit": "3629680e291ce63441702130eb925b9f4448576f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2MTM4MQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516161381", "bodyText": "Updated\nhttps://wiki.lyrasis.org/display/FEDORA6x/Configuration+Options+Inventory#ConfigurationOptionsInventory-RebuildfromOCFLpersistentstorage", "author": "whikloj", "createdAt": "2020-11-02T18:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjExMTUzOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2NDk2Ng==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516164966", "bodyText": "Is this method ever used?", "author": "awoods", "createdAt": "2020-11-02T18:11:37Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -114,154 +84,45 @@ public void rebuildIfNecessary() {\n     private void rebuild() {\n         LOGGER.info(\"Initiating index rebuild.\");\n \n-        ocflIndex.reset();\n-        containmentIndex.reset();\n-        searchIndex.reset();\n-        referenceService.reset();\n-        membershipService.reset();\n+        reindexService.reset();\n \n-        final var txId = UUID.randomUUID().toString();\n+        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n+                ocflPropsConfig);\n \n+        LOGGER.debug(\"Reading object ids...\");\n+        final var startTime = Instant.now();\n         try {\n-            LOGGER.debug(\"Reading object ids...\");\n-\n-            try (final var ocflIds = ocflRepository.listObjectIds()) {\n-                ocflIds.forEach(ocflId -> {\n-                    LOGGER.debug(\"Reading {}\", ocflId);\n-                    try (final var session = objectSessionFactory.newSession(ocflId)) {\n-                        indexOcflObject(ocflId, txId, session);\n-                    } catch (final Exception e) {\n-                        // The session's close method signature throws Exception\n-                        if (e instanceof RuntimeException) {\n-                            throw (RuntimeException) e;\n-                        }\n-                        throw new RuntimeException(e);\n-                    }\n-                });\n-            }\n-\n-            containmentIndex.commitTransaction(txId);\n-            ocflIndex.commit(txId);\n-            referenceService.commitTransaction(txId);\n-            indexMembership(txId);\n-            LOGGER.info(\"Index rebuild complete\");\n-        } catch (final RuntimeException e) {\n-            execQuietly(\"Failed to reset searchIndex\", () -> {\n-                searchIndex.reset();\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback containment index transaction \" + txId, () -> {\n-                containmentIndex.rollbackTransaction(txId);\n-                return null;\n-            });\n-            execQuietly(\"Failed to rollback OCFL index transaction \" + txId, () -> {\n-                ocflIndex.rollback(txId);\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback membership index transaction \" + txId, () -> {\n-                membershipService.rollbackTransaction(txId);\n-                return null;\n-            });\n-            throw e;\n+            reindexManager.start();\n+            reindexManager.commit();\n+            LOGGER.info(\"Reindexing complete.\");\n+        } catch (final InterruptedException e) {\n+            reindexManager.rollback();\n+            throw new RuntimeException(e);\n+        } finally {\n+            reindexManager.shutdown();\n         }\n+        final var endTime = Instant.now();\n+        final var count = reindexManager.getCompletedCount();\n+        final var errors = reindexManager.getErrorCount();\n+        LOGGER.info(\"Index rebuild completed {} objects successfully and {} objects had errors in {} \", count, errors,\n+                getDurationMessage(Duration.between(startTime, endTime)));\n     }\n \n-    private void indexOcflObject(final String ocflId, final String txId, final OcflObjectSession session) {\n-        final var rootId = new AtomicReference<FedoraId>();\n-        final var fedoraIds = new ArrayList<FedoraId>();\n-        final var headersList = new ArrayList<ResourceHeaders>();\n-\n-        session.streamResourceHeaders().forEach(storageHeaders -> {\n-            final var headers = new ResourceHeadersAdapter(storageHeaders);\n-\n-            final var fedoraId = headers.getId();\n-            fedoraIds.add(fedoraId);\n-            if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n-                rootId.set(fedoraId);\n-            }\n-\n-            if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n-                var parentId = headers.getParent();\n-\n-                if (headers.getParent() == null) {\n-                    if (headers.isObjectRoot()) {\n-                        parentId = FedoraId.getRepositoryRootId();\n-                    } else {\n-                        throw new IllegalStateException(String.format(\"Resource %s must have a parent defined\",\n-                                fedoraId.getFullId()));\n-                    }\n-                }\n-                if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n-                    final Optional<InputStream> content = session.readContent(fedoraId.getFullId()).getContentStream();\n-                    if (content.isPresent()) {\n-                        final RdfStream rdf = parseRdf(fedoraId, content.get());\n-                        this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n-                    }\n-                }\n-\n-                this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n-                headersList.add(headers.asKernelHeaders());\n-            }\n-        });\n-\n-        if (rootId.get() == null) {\n-            throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n-        }\n-\n-        fedoraIds.forEach(fedoraIdentifier -> {\n-            final var rootFedoraIdentifier = rootId.get();\n-            ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n-            LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n-        });\n-\n-        headersList.forEach(headers -> {\n-            searchIndex.addUpdateIndex(txId, headers);\n-            LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n-        });\n-    }\n \n     /**\n-     * Index all membership properties by querying for Direct containers, and then\n-     * trying population of the membership index for each one\n-     * @param txId\n+     * Pass this along to the ReindexService\n+     * @param pageSize number of results to use when querying for membership producing resources\n      */\n-    private void indexMembership(final String txId) {\n-        final var fields = List.of(Condition.Field.FEDORA_ID);\n-        final var conditions = List.of(Condition.fromEnums(Field.RDF_TYPE, Operator.EQ,\n-                RdfLexicon.DIRECT_CONTAINER.getURI()));\n-        int offset = 0;\n-\n-        try {\n-            int numResults = membershipPageSize;\n-            do {\n-                final var params = new SearchParameters(fields, conditions, membershipPageSize,\n-                        offset, Field.FEDORA_ID, \"asc\");\n-\n-                final var searchResult = searchIndex.doSearch(params);\n-                final var resultList = searchResult.getItems();\n-                numResults = resultList.size();\n-\n-                resultList.stream()\n-                    .map(entry -> FedoraId.create((String) entry.get(Condition.Field.FEDORA_ID.toString())))\n-                    .forEach(containerId -> membershipService.populateMembershipHistory(txId, containerId));\n-\n-                // Results are paged, so step through pages until we reach the last one\n-                offset += membershipPageSize;\n-            } while (numResults == membershipPageSize);\n-\n-        } catch (final InvalidQueryException e) {\n-            throw new RepositoryRuntimeException(\"Failed to repopulate membership history\", e);\n-        }\n-        membershipService.commitTransaction(txId);\n+    public void setMembershipQueryPageSize(final int pageSize) {", "originalCommit": "3629680e291ce63441702130eb925b9f4448576f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "023f69b2c776c563c07bfc24e039917ccac6618d", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\nindex 8d6bbc7e8e..cafef57098 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n\n@@ -108,23 +106,6 @@ public class IndexBuilderImpl implements IndexBuilder {\n                 getDurationMessage(Duration.between(startTime, endTime)));\n     }\n \n-\n-    /**\n-     * Pass this along to the ReindexService\n-     * @param pageSize number of results to use when querying for membership producing resources\n-     */\n-    public void setMembershipQueryPageSize(final int pageSize) {\n-        reindexService.setMembershipPageSize(pageSize);\n-    }\n-\n-    /**\n-     * Change the number of OCFL ids given out to workers at a time.\n-     * @param batchSize number of OCFL ids per batch.\n-     */\n-    public void setReindexBatchSize(final int batchSize) {\n-        this.reindexBatchSize = batchSize;\n-    }\n-\n     private boolean shouldRebuild() {\n         final var repoContainsObjects = repoContainsObjects();\n         final var repoRootMappingExists = repoRootMappingExists();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2NTA3Mw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516165073", "bodyText": "Is this method ever used?", "author": "awoods", "createdAt": "2020-11-02T18:11:49Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -114,154 +84,45 @@ public void rebuildIfNecessary() {\n     private void rebuild() {\n         LOGGER.info(\"Initiating index rebuild.\");\n \n-        ocflIndex.reset();\n-        containmentIndex.reset();\n-        searchIndex.reset();\n-        referenceService.reset();\n-        membershipService.reset();\n+        reindexService.reset();\n \n-        final var txId = UUID.randomUUID().toString();\n+        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n+                ocflPropsConfig);\n \n+        LOGGER.debug(\"Reading object ids...\");\n+        final var startTime = Instant.now();\n         try {\n-            LOGGER.debug(\"Reading object ids...\");\n-\n-            try (final var ocflIds = ocflRepository.listObjectIds()) {\n-                ocflIds.forEach(ocflId -> {\n-                    LOGGER.debug(\"Reading {}\", ocflId);\n-                    try (final var session = objectSessionFactory.newSession(ocflId)) {\n-                        indexOcflObject(ocflId, txId, session);\n-                    } catch (final Exception e) {\n-                        // The session's close method signature throws Exception\n-                        if (e instanceof RuntimeException) {\n-                            throw (RuntimeException) e;\n-                        }\n-                        throw new RuntimeException(e);\n-                    }\n-                });\n-            }\n-\n-            containmentIndex.commitTransaction(txId);\n-            ocflIndex.commit(txId);\n-            referenceService.commitTransaction(txId);\n-            indexMembership(txId);\n-            LOGGER.info(\"Index rebuild complete\");\n-        } catch (final RuntimeException e) {\n-            execQuietly(\"Failed to reset searchIndex\", () -> {\n-                searchIndex.reset();\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback containment index transaction \" + txId, () -> {\n-                containmentIndex.rollbackTransaction(txId);\n-                return null;\n-            });\n-            execQuietly(\"Failed to rollback OCFL index transaction \" + txId, () -> {\n-                ocflIndex.rollback(txId);\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback membership index transaction \" + txId, () -> {\n-                membershipService.rollbackTransaction(txId);\n-                return null;\n-            });\n-            throw e;\n+            reindexManager.start();\n+            reindexManager.commit();\n+            LOGGER.info(\"Reindexing complete.\");\n+        } catch (final InterruptedException e) {\n+            reindexManager.rollback();\n+            throw new RuntimeException(e);\n+        } finally {\n+            reindexManager.shutdown();\n         }\n+        final var endTime = Instant.now();\n+        final var count = reindexManager.getCompletedCount();\n+        final var errors = reindexManager.getErrorCount();\n+        LOGGER.info(\"Index rebuild completed {} objects successfully and {} objects had errors in {} \", count, errors,\n+                getDurationMessage(Duration.between(startTime, endTime)));\n     }\n \n-    private void indexOcflObject(final String ocflId, final String txId, final OcflObjectSession session) {\n-        final var rootId = new AtomicReference<FedoraId>();\n-        final var fedoraIds = new ArrayList<FedoraId>();\n-        final var headersList = new ArrayList<ResourceHeaders>();\n-\n-        session.streamResourceHeaders().forEach(storageHeaders -> {\n-            final var headers = new ResourceHeadersAdapter(storageHeaders);\n-\n-            final var fedoraId = headers.getId();\n-            fedoraIds.add(fedoraId);\n-            if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n-                rootId.set(fedoraId);\n-            }\n-\n-            if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n-                var parentId = headers.getParent();\n-\n-                if (headers.getParent() == null) {\n-                    if (headers.isObjectRoot()) {\n-                        parentId = FedoraId.getRepositoryRootId();\n-                    } else {\n-                        throw new IllegalStateException(String.format(\"Resource %s must have a parent defined\",\n-                                fedoraId.getFullId()));\n-                    }\n-                }\n-                if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n-                    final Optional<InputStream> content = session.readContent(fedoraId.getFullId()).getContentStream();\n-                    if (content.isPresent()) {\n-                        final RdfStream rdf = parseRdf(fedoraId, content.get());\n-                        this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n-                    }\n-                }\n-\n-                this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n-                headersList.add(headers.asKernelHeaders());\n-            }\n-        });\n-\n-        if (rootId.get() == null) {\n-            throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n-        }\n-\n-        fedoraIds.forEach(fedoraIdentifier -> {\n-            final var rootFedoraIdentifier = rootId.get();\n-            ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n-            LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n-        });\n-\n-        headersList.forEach(headers -> {\n-            searchIndex.addUpdateIndex(txId, headers);\n-            LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n-        });\n-    }\n \n     /**\n-     * Index all membership properties by querying for Direct containers, and then\n-     * trying population of the membership index for each one\n-     * @param txId\n+     * Pass this along to the ReindexService\n+     * @param pageSize number of results to use when querying for membership producing resources\n      */\n-    private void indexMembership(final String txId) {\n-        final var fields = List.of(Condition.Field.FEDORA_ID);\n-        final var conditions = List.of(Condition.fromEnums(Field.RDF_TYPE, Operator.EQ,\n-                RdfLexicon.DIRECT_CONTAINER.getURI()));\n-        int offset = 0;\n-\n-        try {\n-            int numResults = membershipPageSize;\n-            do {\n-                final var params = new SearchParameters(fields, conditions, membershipPageSize,\n-                        offset, Field.FEDORA_ID, \"asc\");\n-\n-                final var searchResult = searchIndex.doSearch(params);\n-                final var resultList = searchResult.getItems();\n-                numResults = resultList.size();\n-\n-                resultList.stream()\n-                    .map(entry -> FedoraId.create((String) entry.get(Condition.Field.FEDORA_ID.toString())))\n-                    .forEach(containerId -> membershipService.populateMembershipHistory(txId, containerId));\n-\n-                // Results are paged, so step through pages until we reach the last one\n-                offset += membershipPageSize;\n-            } while (numResults == membershipPageSize);\n-\n-        } catch (final InvalidQueryException e) {\n-            throw new RepositoryRuntimeException(\"Failed to repopulate membership history\", e);\n-        }\n-        membershipService.commitTransaction(txId);\n+    public void setMembershipQueryPageSize(final int pageSize) {\n+        reindexService.setMembershipPageSize(pageSize);\n     }\n \n     /**\n-     * @param pageSize number of results to use when querying for membership producing resources\n+     * Change the number of OCFL ids given out to workers at a time.\n+     * @param batchSize number of OCFL ids per batch.\n      */\n-    public void setMembershipQueryPageSize(final int pageSize) {\n-        this.membershipPageSize = pageSize;\n+    public void setReindexBatchSize(final int batchSize) {", "originalCommit": "3629680e291ce63441702130eb925b9f4448576f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "023f69b2c776c563c07bfc24e039917ccac6618d", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\nindex 8d6bbc7e8e..cafef57098 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java\n\n@@ -108,23 +106,6 @@ public class IndexBuilderImpl implements IndexBuilder {\n                 getDurationMessage(Duration.between(startTime, endTime)));\n     }\n \n-\n-    /**\n-     * Pass this along to the ReindexService\n-     * @param pageSize number of results to use when querying for membership producing resources\n-     */\n-    public void setMembershipQueryPageSize(final int pageSize) {\n-        reindexService.setMembershipPageSize(pageSize);\n-    }\n-\n-    /**\n-     * Change the number of OCFL ids given out to workers at a time.\n-     * @param batchSize number of OCFL ids per batch.\n-     */\n-    public void setReindexBatchSize(final int batchSize) {\n-        this.reindexBatchSize = batchSize;\n-    }\n-\n     private boolean shouldRebuild() {\n         final var repoContainsObjects = repoContainsObjects();\n         final var repoRootMappingExists = repoRootMappingExists();\n"}}, {"oid": "023f69b2c776c563c07bfc24e039917ccac6618d", "url": "https://github.com/fcrepo/fcrepo/commit/023f69b2c776c563c07bfc24e039917ccac6618d", "message": "Remove ununsed functions", "committedDate": "2020-11-02T18:23:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3MzQ5NQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516173495", "bodyText": "typo: 'Constuctor'", "author": "awoods", "createdAt": "2020-11-02T18:27:08Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.List;\n+\n+import org.slf4j.Logger;\n+\n+/**\n+ * A reindexing worker thread.\n+ * @author whikloj\n+ */\n+public class ReindexWorker implements Runnable {\n+\n+    private static final Logger LOGGER = getLogger(ReindexWorker.class);\n+    private Thread t;\n+    private ReindexManager manager;\n+    private ReindexService service;\n+    private String transactionId;\n+    private boolean running = true;\n+    private boolean failOnError;\n+\n+    /**\n+     * Basic Constuctor", "originalCommit": "3629680e291ce63441702130eb925b9f4448576f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee644d819c37026c2c6f45881bf22700285807c3", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java\nindex 298a6cf7e1..5939e897cc 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java\n\n@@ -38,7 +38,7 @@ public class ReindexWorker implements Runnable {\n     private boolean failOnError;\n \n     /**\n-     * Basic Constuctor\n+     * Basic Constructor\n      * @param reindexManager the manager service.\n      * @param reindexService the reindexing service.\n      * @param txId the transaction id.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3NDM5Ng==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516174396", "bodyText": "Maybe include the txnId in the log message?", "author": "awoods", "createdAt": "2020-11-02T18:28:44Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.apache.jena.graph.NodeFactory.createURI;\n+import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;\n+import static org.fcrepo.kernel.api.RdfLexicon.NON_RDF_SOURCE;\n+import static org.fcrepo.persistence.ocfl.impl.OcflPersistentStorageUtils.getRdfFormat;\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import javax.inject.Inject;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.jena.rdf.model.Model;\n+import org.apache.jena.riot.RDFDataMgr;\n+import org.fcrepo.kernel.api.ContainmentIndex;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.ResourceHeaders;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+import org.fcrepo.kernel.api.services.ReferenceService;\n+import org.fcrepo.persistence.api.PersistentStorageSessionManager;\n+import org.fcrepo.persistence.ocfl.api.FedoraToOcflObjectIndex;\n+import org.fcrepo.search.api.Condition;\n+import org.fcrepo.search.api.InvalidQueryException;\n+import org.fcrepo.search.api.SearchIndex;\n+import org.fcrepo.search.api.SearchParameters;\n+import org.fcrepo.storage.ocfl.OcflObjectSessionFactory;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * Service that does the reindexing for one OCFL object.\n+ * @author whikloj\n+ */\n+@Component\n+public class ReindexService {\n+\n+    @Inject\n+    private PersistentStorageSessionManager persistentStorageSessionManager;\n+\n+    @Inject\n+    private OcflObjectSessionFactory ocflObjectSessionFactory;\n+\n+    @Autowired\n+    @Qualifier(\"ocflIndex\")\n+    private FedoraToOcflObjectIndex ocflIndex;\n+\n+    @Autowired\n+    @Qualifier(\"containmentIndex\")\n+    private ContainmentIndex containmentIndex;\n+\n+    @Autowired\n+    @Qualifier(\"searchIndex\")\n+    private SearchIndex searchIndex;\n+\n+    @Autowired\n+    @Qualifier(\"referenceService\")\n+    private ReferenceService referenceService;\n+\n+    @Inject\n+    private MembershipService membershipService;\n+\n+    private static final Logger LOGGER = getLogger(ReindexService.class);\n+\n+    private int membershipPageSize = 500;\n+\n+    public void indexOcflObject(final String txId, final String ocflId) {\n+        LOGGER.debug(\"Indexing ocflId {} in transaction {}\", ocflId, txId);\n+        try (final var session = ocflObjectSessionFactory.newSession(ocflId)) {\n+            final var rootId = new AtomicReference<FedoraId>();\n+            final var fedoraIds = new ArrayList<FedoraId>();\n+            final var headersList = new ArrayList<ResourceHeaders>();\n+\n+            session.streamResourceHeaders().forEach(storageHeaders -> {\n+                final var headers = new ResourceHeadersAdapter(storageHeaders);\n+\n+                final var fedoraId = headers.getId();\n+                fedoraIds.add(fedoraId);\n+                if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                    rootId.set(fedoraId);\n+                }\n+\n+                if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n+\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(\n+                                    String.format(\"Resource %s must have a parent defined\", fedoraId.getFullId()));\n+                        }\n+                    }\n+                    if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n+                        final Optional<InputStream> content = session.readContent(fedoraId.getFullId())\n+                                .getContentStream();\n+                        if (content.isPresent()) {\n+                            final RdfStream rdf = parseRdf(fedoraId, content.get());\n+                            this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n+                        }\n+                    }\n+\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n+                }\n+            });\n+\n+            if (rootId.get() == null) {\n+                throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n+            }\n+\n+            fedoraIds.forEach(fedoraIdentifier -> {\n+                final var rootFedoraIdentifier = rootId.get();\n+                ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n+                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n+            });\n+\n+            headersList.forEach(headers -> {\n+                searchIndex.addUpdateIndex(txId, headers);\n+                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Remove persistent sessions for a transaction to avoid memory leaks.\n+     * @param transactionId the transaction id.\n+     */\n+    public void cleanupSession(final String transactionId) {\n+        persistentStorageSessionManager.removeSession(transactionId);\n+    }\n+\n+    /**\n+     * Set the membership page size.\n+     * @param pageSize the new page size.\n+     */\n+    public void setMembershipPageSize(final int pageSize) {\n+        membershipPageSize = pageSize;\n+    }\n+\n+    /**\n+     * Reset all the indexes.\n+     */\n+    public void reset() {\n+        ocflIndex.reset();\n+        containmentIndex.reset();\n+        searchIndex.reset();\n+        referenceService.reset();\n+        membershipService.reset();\n+    }\n+\n+    /**\n+     * Commit the records added from transaction.\n+     * @param transactionId the id of the transaction.\n+     */\n+    public void commit(final String transactionId) {\n+        try {\n+            LOGGER.debug(\"Performing commit\");", "originalCommit": "3629680e291ce63441702130eb925b9f4448576f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee644d819c37026c2c6f45881bf22700285807c3", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\nindex 9e28a60960..e437bab6ea 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\n\n@@ -182,11 +182,11 @@ public class ReindexService {\n      */\n     public void commit(final String transactionId) {\n         try {\n-            LOGGER.debug(\"Performing commit\");\n+            LOGGER.debug(\"Performing commit of transaction {}\", transactionId);\n             containmentIndex.commitTransaction(transactionId);\n             ocflIndex.commit(transactionId);\n             referenceService.commitTransaction(transactionId);\n-            LOGGER.debug(\"Finished commit\");\n+            LOGGER.debug(\"Finished commit of transaction {}\", transactionId);\n         } catch (final RuntimeException e) {\n             rollback(transactionId);\n             throw e;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3NDQ2MA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516174460", "bodyText": "Maybe include the txnId in the log message?", "author": "awoods", "createdAt": "2020-11-02T18:28:51Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.apache.jena.graph.NodeFactory.createURI;\n+import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;\n+import static org.fcrepo.kernel.api.RdfLexicon.NON_RDF_SOURCE;\n+import static org.fcrepo.persistence.ocfl.impl.OcflPersistentStorageUtils.getRdfFormat;\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import javax.inject.Inject;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.jena.rdf.model.Model;\n+import org.apache.jena.riot.RDFDataMgr;\n+import org.fcrepo.kernel.api.ContainmentIndex;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.ResourceHeaders;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+import org.fcrepo.kernel.api.services.ReferenceService;\n+import org.fcrepo.persistence.api.PersistentStorageSessionManager;\n+import org.fcrepo.persistence.ocfl.api.FedoraToOcflObjectIndex;\n+import org.fcrepo.search.api.Condition;\n+import org.fcrepo.search.api.InvalidQueryException;\n+import org.fcrepo.search.api.SearchIndex;\n+import org.fcrepo.search.api.SearchParameters;\n+import org.fcrepo.storage.ocfl.OcflObjectSessionFactory;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * Service that does the reindexing for one OCFL object.\n+ * @author whikloj\n+ */\n+@Component\n+public class ReindexService {\n+\n+    @Inject\n+    private PersistentStorageSessionManager persistentStorageSessionManager;\n+\n+    @Inject\n+    private OcflObjectSessionFactory ocflObjectSessionFactory;\n+\n+    @Autowired\n+    @Qualifier(\"ocflIndex\")\n+    private FedoraToOcflObjectIndex ocflIndex;\n+\n+    @Autowired\n+    @Qualifier(\"containmentIndex\")\n+    private ContainmentIndex containmentIndex;\n+\n+    @Autowired\n+    @Qualifier(\"searchIndex\")\n+    private SearchIndex searchIndex;\n+\n+    @Autowired\n+    @Qualifier(\"referenceService\")\n+    private ReferenceService referenceService;\n+\n+    @Inject\n+    private MembershipService membershipService;\n+\n+    private static final Logger LOGGER = getLogger(ReindexService.class);\n+\n+    private int membershipPageSize = 500;\n+\n+    public void indexOcflObject(final String txId, final String ocflId) {\n+        LOGGER.debug(\"Indexing ocflId {} in transaction {}\", ocflId, txId);\n+        try (final var session = ocflObjectSessionFactory.newSession(ocflId)) {\n+            final var rootId = new AtomicReference<FedoraId>();\n+            final var fedoraIds = new ArrayList<FedoraId>();\n+            final var headersList = new ArrayList<ResourceHeaders>();\n+\n+            session.streamResourceHeaders().forEach(storageHeaders -> {\n+                final var headers = new ResourceHeadersAdapter(storageHeaders);\n+\n+                final var fedoraId = headers.getId();\n+                fedoraIds.add(fedoraId);\n+                if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                    rootId.set(fedoraId);\n+                }\n+\n+                if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n+\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(\n+                                    String.format(\"Resource %s must have a parent defined\", fedoraId.getFullId()));\n+                        }\n+                    }\n+                    if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n+                        final Optional<InputStream> content = session.readContent(fedoraId.getFullId())\n+                                .getContentStream();\n+                        if (content.isPresent()) {\n+                            final RdfStream rdf = parseRdf(fedoraId, content.get());\n+                            this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n+                        }\n+                    }\n+\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n+                }\n+            });\n+\n+            if (rootId.get() == null) {\n+                throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n+            }\n+\n+            fedoraIds.forEach(fedoraIdentifier -> {\n+                final var rootFedoraIdentifier = rootId.get();\n+                ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n+                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n+            });\n+\n+            headersList.forEach(headers -> {\n+                searchIndex.addUpdateIndex(txId, headers);\n+                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Remove persistent sessions for a transaction to avoid memory leaks.\n+     * @param transactionId the transaction id.\n+     */\n+    public void cleanupSession(final String transactionId) {\n+        persistentStorageSessionManager.removeSession(transactionId);\n+    }\n+\n+    /**\n+     * Set the membership page size.\n+     * @param pageSize the new page size.\n+     */\n+    public void setMembershipPageSize(final int pageSize) {\n+        membershipPageSize = pageSize;\n+    }\n+\n+    /**\n+     * Reset all the indexes.\n+     */\n+    public void reset() {\n+        ocflIndex.reset();\n+        containmentIndex.reset();\n+        searchIndex.reset();\n+        referenceService.reset();\n+        membershipService.reset();\n+    }\n+\n+    /**\n+     * Commit the records added from transaction.\n+     * @param transactionId the id of the transaction.\n+     */\n+    public void commit(final String transactionId) {\n+        try {\n+            LOGGER.debug(\"Performing commit\");\n+            containmentIndex.commitTransaction(transactionId);\n+            ocflIndex.commit(transactionId);\n+            referenceService.commitTransaction(transactionId);\n+            LOGGER.debug(\"Finished commit\");", "originalCommit": "3629680e291ce63441702130eb925b9f4448576f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee644d819c37026c2c6f45881bf22700285807c3", "chunk": "diff --git a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\nindex 9e28a60960..e437bab6ea 100644\n--- a/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\n+++ b/fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java\n\n@@ -182,11 +182,11 @@ public class ReindexService {\n      */\n     public void commit(final String transactionId) {\n         try {\n-            LOGGER.debug(\"Performing commit\");\n+            LOGGER.debug(\"Performing commit of transaction {}\", transactionId);\n             containmentIndex.commitTransaction(transactionId);\n             ocflIndex.commit(transactionId);\n             referenceService.commitTransaction(transactionId);\n-            LOGGER.debug(\"Finished commit\");\n+            LOGGER.debug(\"Finished commit of transaction {}\", transactionId);\n         } catch (final RuntimeException e) {\n             rollback(transactionId);\n             throw e;\n"}}, {"oid": "ee644d819c37026c2c6f45881bf22700285807c3", "url": "https://github.com/fcrepo/fcrepo/commit/ee644d819c37026c2c6f45881bf22700285807c3", "message": "Code review", "committedDate": "2020-11-02T18:46:05Z", "type": "commit"}]}