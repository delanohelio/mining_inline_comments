{"pr_number": 3962, "pr_title": "remove ConcurrentMapChunkCache", "pr_createdAt": "2020-05-17T01:55:55Z", "pr_url": "https://github.com/MovingBlocks/Terasology/pull/3962", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0MzQ1OQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/3962#discussion_r504943459", "bodyText": "I guess this needs to be JOML-ified now?", "author": "skaldarnar", "createdAt": "2020-10-14T20:10:32Z", "path": "engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java", "diffHunk": "@@ -112,38 +111,23 @@\n \n     private BlockManager blockManager;\n     private ExtraBlockDataManager extraDataManager;\n-    private final ChunkCache chunkCache;\n-    private final Supplier<ChunkFinalizer> chunkFinalizerSupplier;\n+    private final Map<Vector3i, Chunk> chunkCache = Maps.newConcurrentMap();", "originalCommit": "a7d77d3c56dfd36cdc901ce0ed481635a53e8feb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "193d44f5670535b0245c90814dc7b56ed655c05f", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java b/engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java\nindex ea61129f0..1e6b492e4 100644\n--- a/engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java\n+++ b/engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java\n\n@@ -59,81 +47,99 @@\n import org.terasology.world.chunks.event.PurgeWorldEvent;\n import org.terasology.world.chunks.internal.ChunkImpl;\n import org.terasology.world.chunks.internal.ChunkRelevanceRegion;\n-import org.terasology.world.chunks.internal.GeneratingChunkProvider;\n-import org.terasology.world.chunks.internal.ReadyChunkInfo;\n-import org.terasology.world.chunks.pipeline.AbstractChunkTask;\n-import org.terasology.world.chunks.pipeline.ChunkGenerationPipeline;\n-import org.terasology.world.chunks.pipeline.ChunkTask;\n+import org.terasology.world.chunks.pipeline.ChunkProcessingPipeline;\n+import org.terasology.world.chunks.pipeline.stages.ChunkTaskProvider;\n import org.terasology.world.generation.impl.EntityBufferImpl;\n import org.terasology.world.generator.WorldGenerator;\n import org.terasology.world.internal.ChunkViewCore;\n import org.terasology.world.internal.ChunkViewCoreImpl;\n import org.terasology.world.propagation.light.InternalLightProcessor;\n+import org.terasology.world.propagation.light.LightMerger;\n \n-import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.locks.ReadWriteLock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.function.Supplier;\n+import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n \n /**\n+ * Provides chunks. Chunks placed in this JVM. Also generated Chunks if needed.\n+ * <p>\n+ * Loading/Unload chunks dependent on {@link RelevanceSystem}\n+ * <p/>\n+ * Produces events:\n+ * <p>\n+ * {@link OnChunkGenerated} when chunk was generated {@link WorldGenerator}\n+ * <p>\n+ * {@link OnChunkLoaded} when chunk was loaded from {@link StorageManager}\n+ * <p>\n+ * {@link OnActivatedBlocks} when load/generate chunk and chunk have blocks with lifecycle (?) {@see\n+ * https://github.com/MovingBlocks/Terasology/issues/3244}\n+ * <p>\n+ * {@link OnAddedBlocks} when load/generate chunk and chunk have blocks with lifecycle (?) {@see\n+ * https://github.com/MovingBlocks/Terasology/issues/3244}\n+ * <p>\n+ * {@link BeforeChunkUnload} when chunk ready to remove from provider.\n+ * <p>\n+ * {@link BeforeDeactivateBlocks} when chunk ready to remove and have block lifecycle.\n  */\n-public class LocalChunkProvider implements GeneratingChunkProvider {\n+public class LocalChunkProvider implements ChunkProvider {\n \n     private static final Logger logger = LoggerFactory.getLogger(LocalChunkProvider.class);\n     private static final int UNLOAD_PER_FRAME = 64;\n-    private static final Vector3i UNLOAD_LEEWAY = Vector3i.one();\n-\n-    private StorageManager storageManager;\n     private final EntityManager entityManager;\n-\n-    private ChunkGenerationPipeline pipeline;\n-    private TaskMaster<ChunkUnloadRequest> unloadRequestTaskMaster;\n-    private WorldGenerator generator;\n-\n-    private Map<EntityRef, ChunkRelevanceRegion> regions = Maps.newHashMap();\n-\n-    private final Set<Vector3i> preparingChunks = Sets.newHashSet();\n-    private final BlockingQueue<ReadyChunkInfo> readyChunks = Queues.newLinkedBlockingQueue();\n-    private List<ReadyChunkInfo> sortedReadyChunks = Lists.newArrayList();\n     private final BlockingQueue<TShortObjectMap<TIntList>> deactivateBlocksQueue = Queues.newLinkedBlockingQueue();\n+    private final Map<Vector3i, Chunk> chunkCache;\n \n-    private EntityRef worldEntity = EntityRef.NULL;\n-\n-    private ReadWriteLock regionLock = new ReentrantReadWriteLock();\n+    private final Map<org.joml.Vector3i, List<EntityStore>> generateQueuedEntities = new HashMap<>();\n \n-    private BlockManager blockManager;\n-    private ExtraBlockDataManager extraDataManager;\n-    private final Map<Vector3i, Chunk> chunkCache = Maps.newConcurrentMap();\n+    private final StorageManager storageManager;\n+    private final WorldGenerator generator;\n+    private final BlockManager blockManager;\n+    private final ExtraBlockDataManager extraDataManager;\n+    private ChunkProcessingPipeline loadingPipeline;\n+    private TaskMaster<ChunkUnloadRequest> unloadRequestTaskMaster;\n+    private EntityRef worldEntity = EntityRef.NULL;\n     private BlockEntityRegistry registry;\n \n-    //TODO: Michael Pollind -- if we have more then one finalizer use  Supplier<ChunkFinalizer[]> and ChunkFinalizer[]\n-    private final Supplier<ChunkFinalizer> chunkFinalizerSupplier;\n-    private ChunkFinalizer chunkFinalizer;\n+    private RelevanceSystem relevanceSystem;\n \n     public LocalChunkProvider(StorageManager storageManager, EntityManager entityManager, WorldGenerator generator,\n-                              BlockManager blockManager, ExtraBlockDataManager extraDataManager, Supplier<ChunkFinalizer> chunkFinalizerSupplier) {\n+                              BlockManager blockManager, ExtraBlockDataManager extraDataManager,\n+                              Map<Vector3i, Chunk> chunkCache) {\n         this.storageManager = storageManager;\n         this.entityManager = entityManager;\n         this.generator = generator;\n         this.blockManager = blockManager;\n         this.extraDataManager = extraDataManager;\n-        this.pipeline = new ChunkGenerationPipeline(new ChunkTaskRelevanceComparator());\n         this.unloadRequestTaskMaster = TaskMaster.createFIFOTaskMaster(\"Chunk-Unloader\", 4);\n-        this.chunkFinalizer = chunkFinalizerSupplier.get();\n-        chunkFinalizer.initialize(this);\n-        this.chunkFinalizerSupplier = chunkFinalizerSupplier;\n+        this.chunkCache = chunkCache;\n         ChunkMonitor.fireChunkProviderInitialized(this);\n     }\n \n \n+    protected Future<Chunk> createOrLoadChunk(Vector3i chunkPos) {\n+        return loadingPipeline.invokeGeneratorTask(\n+                JomlUtil.from(chunkPos),\n+                () -> {\n+                    ChunkStore chunkStore = storageManager.loadChunkStore(chunkPos);\n+                    Chunk chunk;\n+                    EntityBufferImpl buffer = new EntityBufferImpl();\n+                    if (chunkStore == null) {\n+                        chunk = new ChunkImpl(chunkPos, blockManager, extraDataManager);\n+                        generator.createChunk(chunk, buffer);\n+                        generateQueuedEntities.put(chunk.getPosition(new org.joml.Vector3i()), buffer.getAll());\n+                    } else {\n+                        chunk = chunkStore.getChunk();\n+                    }\n+                    return chunk;\n+                });\n+    }\n+\n     public void setBlockEntityRegistry(BlockEntityRegistry value) {\n         this.registry = value;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0NzE0Nw==", "url": "https://github.com/MovingBlocks/Terasology/pull/3962#discussion_r504947147", "bodyText": "when is the \"end of the chunk overhaul\"? \ud83e\udd14", "author": "skaldarnar", "createdAt": "2020-10-14T20:17:43Z", "path": "engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java", "diffHunk": "@@ -112,38 +111,23 @@\n \n     private BlockManager blockManager;\n     private ExtraBlockDataManager extraDataManager;\n-    private final ChunkCache chunkCache;\n-    private final Supplier<ChunkFinalizer> chunkFinalizerSupplier;\n+    private final Map<Vector3i, Chunk> chunkCache = Maps.newConcurrentMap();\n     private BlockEntityRegistry registry;\n \n+    //TODO: Michael Pollind -- if we have more then one finalizer use  Supplier<ChunkFinalizer[]> and ChunkFinalizer[]\n+    private final Supplier<ChunkFinalizer> chunkFinalizerSupplier;\n     private ChunkFinalizer chunkFinalizer;\n \n-    //TODO Remove this old constructor at the end of the chunk overhaul", "originalCommit": "a7d77d3c56dfd36cdc901ce0ed481635a53e8feb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "193d44f5670535b0245c90814dc7b56ed655c05f", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java b/engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java\nindex ea61129f0..1e6b492e4 100644\n--- a/engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java\n+++ b/engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java\n\n@@ -59,81 +47,99 @@\n import org.terasology.world.chunks.event.PurgeWorldEvent;\n import org.terasology.world.chunks.internal.ChunkImpl;\n import org.terasology.world.chunks.internal.ChunkRelevanceRegion;\n-import org.terasology.world.chunks.internal.GeneratingChunkProvider;\n-import org.terasology.world.chunks.internal.ReadyChunkInfo;\n-import org.terasology.world.chunks.pipeline.AbstractChunkTask;\n-import org.terasology.world.chunks.pipeline.ChunkGenerationPipeline;\n-import org.terasology.world.chunks.pipeline.ChunkTask;\n+import org.terasology.world.chunks.pipeline.ChunkProcessingPipeline;\n+import org.terasology.world.chunks.pipeline.stages.ChunkTaskProvider;\n import org.terasology.world.generation.impl.EntityBufferImpl;\n import org.terasology.world.generator.WorldGenerator;\n import org.terasology.world.internal.ChunkViewCore;\n import org.terasology.world.internal.ChunkViewCoreImpl;\n import org.terasology.world.propagation.light.InternalLightProcessor;\n+import org.terasology.world.propagation.light.LightMerger;\n \n-import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.locks.ReadWriteLock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.function.Supplier;\n+import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n \n /**\n+ * Provides chunks. Chunks placed in this JVM. Also generated Chunks if needed.\n+ * <p>\n+ * Loading/Unload chunks dependent on {@link RelevanceSystem}\n+ * <p/>\n+ * Produces events:\n+ * <p>\n+ * {@link OnChunkGenerated} when chunk was generated {@link WorldGenerator}\n+ * <p>\n+ * {@link OnChunkLoaded} when chunk was loaded from {@link StorageManager}\n+ * <p>\n+ * {@link OnActivatedBlocks} when load/generate chunk and chunk have blocks with lifecycle (?) {@see\n+ * https://github.com/MovingBlocks/Terasology/issues/3244}\n+ * <p>\n+ * {@link OnAddedBlocks} when load/generate chunk and chunk have blocks with lifecycle (?) {@see\n+ * https://github.com/MovingBlocks/Terasology/issues/3244}\n+ * <p>\n+ * {@link BeforeChunkUnload} when chunk ready to remove from provider.\n+ * <p>\n+ * {@link BeforeDeactivateBlocks} when chunk ready to remove and have block lifecycle.\n  */\n-public class LocalChunkProvider implements GeneratingChunkProvider {\n+public class LocalChunkProvider implements ChunkProvider {\n \n     private static final Logger logger = LoggerFactory.getLogger(LocalChunkProvider.class);\n     private static final int UNLOAD_PER_FRAME = 64;\n-    private static final Vector3i UNLOAD_LEEWAY = Vector3i.one();\n-\n-    private StorageManager storageManager;\n     private final EntityManager entityManager;\n-\n-    private ChunkGenerationPipeline pipeline;\n-    private TaskMaster<ChunkUnloadRequest> unloadRequestTaskMaster;\n-    private WorldGenerator generator;\n-\n-    private Map<EntityRef, ChunkRelevanceRegion> regions = Maps.newHashMap();\n-\n-    private final Set<Vector3i> preparingChunks = Sets.newHashSet();\n-    private final BlockingQueue<ReadyChunkInfo> readyChunks = Queues.newLinkedBlockingQueue();\n-    private List<ReadyChunkInfo> sortedReadyChunks = Lists.newArrayList();\n     private final BlockingQueue<TShortObjectMap<TIntList>> deactivateBlocksQueue = Queues.newLinkedBlockingQueue();\n+    private final Map<Vector3i, Chunk> chunkCache;\n \n-    private EntityRef worldEntity = EntityRef.NULL;\n-\n-    private ReadWriteLock regionLock = new ReentrantReadWriteLock();\n+    private final Map<org.joml.Vector3i, List<EntityStore>> generateQueuedEntities = new HashMap<>();\n \n-    private BlockManager blockManager;\n-    private ExtraBlockDataManager extraDataManager;\n-    private final Map<Vector3i, Chunk> chunkCache = Maps.newConcurrentMap();\n+    private final StorageManager storageManager;\n+    private final WorldGenerator generator;\n+    private final BlockManager blockManager;\n+    private final ExtraBlockDataManager extraDataManager;\n+    private ChunkProcessingPipeline loadingPipeline;\n+    private TaskMaster<ChunkUnloadRequest> unloadRequestTaskMaster;\n+    private EntityRef worldEntity = EntityRef.NULL;\n     private BlockEntityRegistry registry;\n \n-    //TODO: Michael Pollind -- if we have more then one finalizer use  Supplier<ChunkFinalizer[]> and ChunkFinalizer[]\n-    private final Supplier<ChunkFinalizer> chunkFinalizerSupplier;\n-    private ChunkFinalizer chunkFinalizer;\n+    private RelevanceSystem relevanceSystem;\n \n     public LocalChunkProvider(StorageManager storageManager, EntityManager entityManager, WorldGenerator generator,\n-                              BlockManager blockManager, ExtraBlockDataManager extraDataManager, Supplier<ChunkFinalizer> chunkFinalizerSupplier) {\n+                              BlockManager blockManager, ExtraBlockDataManager extraDataManager,\n+                              Map<Vector3i, Chunk> chunkCache) {\n         this.storageManager = storageManager;\n         this.entityManager = entityManager;\n         this.generator = generator;\n         this.blockManager = blockManager;\n         this.extraDataManager = extraDataManager;\n-        this.pipeline = new ChunkGenerationPipeline(new ChunkTaskRelevanceComparator());\n         this.unloadRequestTaskMaster = TaskMaster.createFIFOTaskMaster(\"Chunk-Unloader\", 4);\n-        this.chunkFinalizer = chunkFinalizerSupplier.get();\n-        chunkFinalizer.initialize(this);\n-        this.chunkFinalizerSupplier = chunkFinalizerSupplier;\n+        this.chunkCache = chunkCache;\n         ChunkMonitor.fireChunkProviderInitialized(this);\n     }\n \n \n+    protected Future<Chunk> createOrLoadChunk(Vector3i chunkPos) {\n+        return loadingPipeline.invokeGeneratorTask(\n+                JomlUtil.from(chunkPos),\n+                () -> {\n+                    ChunkStore chunkStore = storageManager.loadChunkStore(chunkPos);\n+                    Chunk chunk;\n+                    EntityBufferImpl buffer = new EntityBufferImpl();\n+                    if (chunkStore == null) {\n+                        chunk = new ChunkImpl(chunkPos, blockManager, extraDataManager);\n+                        generator.createChunk(chunk, buffer);\n+                        generateQueuedEntities.put(chunk.getPosition(new org.joml.Vector3i()), buffer.getAll());\n+                    } else {\n+                        chunk = chunkStore.getChunk();\n+                    }\n+                    return chunk;\n+                });\n+    }\n+\n     public void setBlockEntityRegistry(BlockEntityRegistry value) {\n         this.registry = value;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0ODA5Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/3962#discussion_r504948092", "bodyText": "What do we need to store the supplier as member here? When is it used?", "author": "skaldarnar", "createdAt": "2020-10-14T20:19:26Z", "path": "engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java", "diffHunk": "@@ -112,38 +111,23 @@\n \n     private BlockManager blockManager;\n     private ExtraBlockDataManager extraDataManager;\n-    private final ChunkCache chunkCache;\n-    private final Supplier<ChunkFinalizer> chunkFinalizerSupplier;\n+    private final Map<Vector3i, Chunk> chunkCache = Maps.newConcurrentMap();\n     private BlockEntityRegistry registry;\n \n+    //TODO: Michael Pollind -- if we have more then one finalizer use  Supplier<ChunkFinalizer[]> and ChunkFinalizer[]\n+    private final Supplier<ChunkFinalizer> chunkFinalizerSupplier;", "originalCommit": "a7d77d3c56dfd36cdc901ce0ed481635a53e8feb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "193d44f5670535b0245c90814dc7b56ed655c05f", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java b/engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java\nindex ea61129f0..1e6b492e4 100644\n--- a/engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java\n+++ b/engine/src/main/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProvider.java\n\n@@ -59,81 +47,99 @@\n import org.terasology.world.chunks.event.PurgeWorldEvent;\n import org.terasology.world.chunks.internal.ChunkImpl;\n import org.terasology.world.chunks.internal.ChunkRelevanceRegion;\n-import org.terasology.world.chunks.internal.GeneratingChunkProvider;\n-import org.terasology.world.chunks.internal.ReadyChunkInfo;\n-import org.terasology.world.chunks.pipeline.AbstractChunkTask;\n-import org.terasology.world.chunks.pipeline.ChunkGenerationPipeline;\n-import org.terasology.world.chunks.pipeline.ChunkTask;\n+import org.terasology.world.chunks.pipeline.ChunkProcessingPipeline;\n+import org.terasology.world.chunks.pipeline.stages.ChunkTaskProvider;\n import org.terasology.world.generation.impl.EntityBufferImpl;\n import org.terasology.world.generator.WorldGenerator;\n import org.terasology.world.internal.ChunkViewCore;\n import org.terasology.world.internal.ChunkViewCoreImpl;\n import org.terasology.world.propagation.light.InternalLightProcessor;\n+import org.terasology.world.propagation.light.LightMerger;\n \n-import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.locks.ReadWriteLock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.function.Supplier;\n+import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n \n /**\n+ * Provides chunks. Chunks placed in this JVM. Also generated Chunks if needed.\n+ * <p>\n+ * Loading/Unload chunks dependent on {@link RelevanceSystem}\n+ * <p/>\n+ * Produces events:\n+ * <p>\n+ * {@link OnChunkGenerated} when chunk was generated {@link WorldGenerator}\n+ * <p>\n+ * {@link OnChunkLoaded} when chunk was loaded from {@link StorageManager}\n+ * <p>\n+ * {@link OnActivatedBlocks} when load/generate chunk and chunk have blocks with lifecycle (?) {@see\n+ * https://github.com/MovingBlocks/Terasology/issues/3244}\n+ * <p>\n+ * {@link OnAddedBlocks} when load/generate chunk and chunk have blocks with lifecycle (?) {@see\n+ * https://github.com/MovingBlocks/Terasology/issues/3244}\n+ * <p>\n+ * {@link BeforeChunkUnload} when chunk ready to remove from provider.\n+ * <p>\n+ * {@link BeforeDeactivateBlocks} when chunk ready to remove and have block lifecycle.\n  */\n-public class LocalChunkProvider implements GeneratingChunkProvider {\n+public class LocalChunkProvider implements ChunkProvider {\n \n     private static final Logger logger = LoggerFactory.getLogger(LocalChunkProvider.class);\n     private static final int UNLOAD_PER_FRAME = 64;\n-    private static final Vector3i UNLOAD_LEEWAY = Vector3i.one();\n-\n-    private StorageManager storageManager;\n     private final EntityManager entityManager;\n-\n-    private ChunkGenerationPipeline pipeline;\n-    private TaskMaster<ChunkUnloadRequest> unloadRequestTaskMaster;\n-    private WorldGenerator generator;\n-\n-    private Map<EntityRef, ChunkRelevanceRegion> regions = Maps.newHashMap();\n-\n-    private final Set<Vector3i> preparingChunks = Sets.newHashSet();\n-    private final BlockingQueue<ReadyChunkInfo> readyChunks = Queues.newLinkedBlockingQueue();\n-    private List<ReadyChunkInfo> sortedReadyChunks = Lists.newArrayList();\n     private final BlockingQueue<TShortObjectMap<TIntList>> deactivateBlocksQueue = Queues.newLinkedBlockingQueue();\n+    private final Map<Vector3i, Chunk> chunkCache;\n \n-    private EntityRef worldEntity = EntityRef.NULL;\n-\n-    private ReadWriteLock regionLock = new ReentrantReadWriteLock();\n+    private final Map<org.joml.Vector3i, List<EntityStore>> generateQueuedEntities = new HashMap<>();\n \n-    private BlockManager blockManager;\n-    private ExtraBlockDataManager extraDataManager;\n-    private final Map<Vector3i, Chunk> chunkCache = Maps.newConcurrentMap();\n+    private final StorageManager storageManager;\n+    private final WorldGenerator generator;\n+    private final BlockManager blockManager;\n+    private final ExtraBlockDataManager extraDataManager;\n+    private ChunkProcessingPipeline loadingPipeline;\n+    private TaskMaster<ChunkUnloadRequest> unloadRequestTaskMaster;\n+    private EntityRef worldEntity = EntityRef.NULL;\n     private BlockEntityRegistry registry;\n \n-    //TODO: Michael Pollind -- if we have more then one finalizer use  Supplier<ChunkFinalizer[]> and ChunkFinalizer[]\n-    private final Supplier<ChunkFinalizer> chunkFinalizerSupplier;\n-    private ChunkFinalizer chunkFinalizer;\n+    private RelevanceSystem relevanceSystem;\n \n     public LocalChunkProvider(StorageManager storageManager, EntityManager entityManager, WorldGenerator generator,\n-                              BlockManager blockManager, ExtraBlockDataManager extraDataManager, Supplier<ChunkFinalizer> chunkFinalizerSupplier) {\n+                              BlockManager blockManager, ExtraBlockDataManager extraDataManager,\n+                              Map<Vector3i, Chunk> chunkCache) {\n         this.storageManager = storageManager;\n         this.entityManager = entityManager;\n         this.generator = generator;\n         this.blockManager = blockManager;\n         this.extraDataManager = extraDataManager;\n-        this.pipeline = new ChunkGenerationPipeline(new ChunkTaskRelevanceComparator());\n         this.unloadRequestTaskMaster = TaskMaster.createFIFOTaskMaster(\"Chunk-Unloader\", 4);\n-        this.chunkFinalizer = chunkFinalizerSupplier.get();\n-        chunkFinalizer.initialize(this);\n-        this.chunkFinalizerSupplier = chunkFinalizerSupplier;\n+        this.chunkCache = chunkCache;\n         ChunkMonitor.fireChunkProviderInitialized(this);\n     }\n \n \n+    protected Future<Chunk> createOrLoadChunk(Vector3i chunkPos) {\n+        return loadingPipeline.invokeGeneratorTask(\n+                JomlUtil.from(chunkPos),\n+                () -> {\n+                    ChunkStore chunkStore = storageManager.loadChunkStore(chunkPos);\n+                    Chunk chunk;\n+                    EntityBufferImpl buffer = new EntityBufferImpl();\n+                    if (chunkStore == null) {\n+                        chunk = new ChunkImpl(chunkPos, blockManager, extraDataManager);\n+                        generator.createChunk(chunk, buffer);\n+                        generateQueuedEntities.put(chunk.getPosition(new org.joml.Vector3i()), buffer.getAll());\n+                    } else {\n+                        chunk = chunkStore.getChunk();\n+                    }\n+                    return chunk;\n+                });\n+    }\n+\n     public void setBlockEntityRegistry(BlockEntityRegistry value) {\n         this.registry = value;\n     }\n"}}, {"oid": "193d44f5670535b0245c90814dc7b56ed655c05f", "url": "https://github.com/MovingBlocks/Terasology/commit/193d44f5670535b0245c90814dc7b56ed655c05f", "message": "remove ConcurrentMapChunkCache", "committedDate": "2020-10-15T04:35:41Z", "type": "commit"}, {"oid": "193d44f5670535b0245c90814dc7b56ed655c05f", "url": "https://github.com/MovingBlocks/Terasology/commit/193d44f5670535b0245c90814dc7b56ed655c05f", "message": "remove ConcurrentMapChunkCache", "committedDate": "2020-10-15T04:35:41Z", "type": "forcePushed"}]}