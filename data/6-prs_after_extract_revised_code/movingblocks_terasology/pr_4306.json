{"pr_number": 4306, "pr_title": "feat(JOML): Chunks Standardization ", "pr_createdAt": "2020-12-09T05:32:16Z", "pr_url": "https://github.com/MovingBlocks/Terasology/pull/4306", "timeline": [{"oid": "bc9e10356b86d93315257dff4ac98ac59f9349ad", "url": "https://github.com/MovingBlocks/Terasology/commit/bc9e10356b86d93315257dff4ac98ac59f9349ad", "message": "feature/joml-chunk-standardization", "committedDate": "2020-12-09T05:14:12Z", "type": "commit"}, {"oid": "912204ada366600a3f0ac7f16c5d20cc505a11a9", "url": "https://github.com/MovingBlocks/Terasology/commit/912204ada366600a3f0ac7f16c5d20cc505a11a9", "message": "update test cases", "committedDate": "2020-12-10T05:16:12Z", "type": "commit"}, {"oid": "5dde332c4765d9db21de9836d29c4fae260bd75f", "url": "https://github.com/MovingBlocks/Terasology/commit/5dde332c4765d9db21de9836d29c4fae260bd75f", "message": "update docs", "committedDate": "2020-12-10T05:28:05Z", "type": "commit"}, {"oid": "9e97bdced8298af309fd2ba87abe4068ddbb95be", "url": "https://github.com/MovingBlocks/Terasology/commit/9e97bdced8298af309fd2ba87abe4068ddbb95be", "message": "add test edge logic", "committedDate": "2020-12-11T05:29:01Z", "type": "commit"}, {"oid": "9f5e88d2c1401db970c264092ba5ae10b4e213c8", "url": "https://github.com/MovingBlocks/Terasology/commit/9f5e88d2c1401db970c264092ba5ae10b4e213c8", "message": "Merge branch 'develop' into feature/chunk-standardization", "committedDate": "2020-12-12T20:37:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3NjU5Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541776592", "bodyText": "\"This method\"? \ud83e\udd14", "author": "jdrueckert", "createdAt": "2020-12-12T20:39:49Z", "path": "engine/src/main/java/org/terasology/math/ChunkMath.java", "diffHunk": "@@ -28,8 +28,10 @@\n \n /**\n  * Collection of math functions.\n- *\n+ * @deprecated This method is scheduled for removal in an upcoming version.", "originalCommit": "9f5e88d2c1401db970c264092ba5ae10b4e213c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bcf1cde42c33101ba2e3f5bfafd9c450deb63858", "chunk": "diff --git a/engine/src/main/java/org/terasology/math/ChunkMath.java b/engine/src/main/java/org/terasology/math/ChunkMath.java\nindex f9a5bd232..2603ff705 100644\n--- a/engine/src/main/java/org/terasology/math/ChunkMath.java\n+++ b/engine/src/main/java/org/terasology/math/ChunkMath.java\n\n@@ -28,7 +28,7 @@\n \n /**\n  * Collection of math functions.\n- * @deprecated This method is scheduled for removal in an upcoming version.\n+ * @deprecated This class is scheduled for removal in an upcoming version.\n  *             Use the JOML implementation instead: {@link org.terasology.world.chunks.Chunks}.\n  */\n @Deprecated\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3Njg0MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541776840", "bodyText": "Is there a replacement yet? If so, please link it here.", "author": "jdrueckert", "createdAt": "2020-12-12T20:41:36Z", "path": "engine/src/main/java/org/terasology/math/ChunkMath.java", "diffHunk": "@@ -486,7 +488,9 @@ public static Region3i getChunkRegionAroundWorldPos(Vector3i pos, int extent) {\n      * @param pos the world position\n      * @param extent the extent\n      * @return chunk region\n+     *\n      */\n+    @Deprecated", "originalCommit": "9f5e88d2c1401db970c264092ba5ae10b4e213c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNzE3OA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541917178", "bodyText": "It is mentioned in the docstring. Probably the hidden part is that we don't offer a replacement for the exact signature but ask the caller to create a block region from center and extents:\nChunks.toChunkRegion(BlockRegions.createFromCenterAndExtents(pos, extent))\n(Writing this makes me thing whether we should rename createFrom... to just from... on BlockRegions \ud83e\udd14 )", "author": "skaldarnar", "createdAt": "2020-12-13T12:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3Njg0MA=="}], "type": "inlineReview", "revised_code": {"commit": "bcf1cde42c33101ba2e3f5bfafd9c450deb63858", "chunk": "diff --git a/engine/src/main/java/org/terasology/math/ChunkMath.java b/engine/src/main/java/org/terasology/math/ChunkMath.java\nindex f9a5bd232..2603ff705 100644\n--- a/engine/src/main/java/org/terasology/math/ChunkMath.java\n+++ b/engine/src/main/java/org/terasology/math/ChunkMath.java\n\n@@ -488,6 +488,8 @@ public static Region3i getChunkRegionAroundWorldPos(Vector3i pos, int extent) {\n      * @param pos the world position\n      * @param extent the extent\n      * @return chunk region\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link org.terasology.world.chunks.Chunks#toChunkRegion(BlockRegion, BlockRegion)}.\n      *\n      */\n     @Deprecated\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3Njk3Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541776976", "bodyText": "maybe:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public BlockRegion edge(Side side, BlockRegion dest) {\n          \n          \n            \n                public BlockRegion calculateEdge(Side side, BlockRegion dest) {\n          \n      \n    \n    \n  \n\nor\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public BlockRegion edge(Side side, BlockRegion dest) {\n          \n          \n            \n                public BlockRegion getEdge(Side side, BlockRegion dest) {", "author": "jdrueckert", "createdAt": "2020-12-12T20:42:19Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -802,6 +803,38 @@ public BlockRegion addExtents(float extentX, float extentY, float extentZ, Block\n         return dest;\n     }\n \n+    /**\n+     * calculates a 1 width region that borders the provided {@link Side} of a region\n+     *\n+     * @param side the side of the region\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion edge(Side side, BlockRegion dest) {", "originalCommit": "9f5e88d2c1401db970c264092ba5ae10b4e213c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc4MDA4MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541780081", "bodyText": "why calculate? when isn't it not doing calculation :?", "author": "pollend", "createdAt": "2020-12-12T21:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3Njk3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc4MDQyNA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541780424", "bodyText": "getEdge is fine too, only edge seems a bit blank though", "author": "jdrueckert", "createdAt": "2020-12-12T21:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3Njk3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc4NzQ4Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541787486", "bodyText": "that sounds better.", "author": "pollend", "createdAt": "2020-12-12T21:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3Njk3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc4ODQ0NQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541788445", "bodyText": "getBlockFace, getFace,", "author": "pollend", "createdAt": "2020-12-12T21:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3Njk3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "bcf1cde42c33101ba2e3f5bfafd9c450deb63858", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex c1196e360..57f52e980 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -810,7 +810,7 @@ public BlockRegion addExtents(float extentX, float extentY, float extentZ, Block\n      * @param dest will hold the result\n      * @return dest\n      */\n-    public BlockRegion edge(Side side, BlockRegion dest) {\n+    public BlockRegion blockFace(Side side, BlockRegion dest) {\n         switch (side) {\n             case TOP:\n                 return dest.setMin(this.getMinX(), this.getMaxY(), this.getMinZ()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3OTQxMA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541779410", "bodyText": "\"This method\"? \ud83e\udd14", "author": "jdrueckert", "createdAt": "2020-12-12T20:58:52Z", "path": "engine/src/main/java/org/terasology/world/chunks/ChunkConstants.java", "diffHunk": "@@ -22,9 +22,13 @@\n import org.terasology.math.geom.Vector3i;\n import org.terasology.module.sandbox.API;\n \n+\n /**\n+ * @deprecated This method is scheduled for removal in an upcoming version.", "originalCommit": "9f5e88d2c1401db970c264092ba5ae10b4e213c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkyMDUxOA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541920518", "bodyText": "I'm not sure this pure constants class should be deprecated. It is exactly that, a pure static class holding some constants, which are decoupled from Chunk or Chunks in general.\nOnly argument for merging this with ChunkMath into Chunks is that there is one file less to look at. Probably doesn't matter in the end \ud83e\udd37", "author": "skaldarnar", "createdAt": "2020-12-13T12:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3OTQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1Njc2Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r546256762", "bodyText": "ChunkaMath and ChunkConstants are coupled together so I thought it was simpler to just combine them.", "author": "pollend", "createdAt": "2020-12-19T16:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3OTQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA0MzU2Nw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r549043567", "bodyText": "They are coupled, but fortunately only in one direction - ChunkMath, as well as other classes, depends on ChunkConstants...\nI don't have a strong opinion here. @4Denthusiast, what do you think?", "author": "skaldarnar", "createdAt": "2020-12-26T23:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3OTQxMA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "bcf1cde42c33101ba2e3f5bfafd9c450deb63858", "url": "https://github.com/MovingBlocks/Terasology/commit/bcf1cde42c33101ba2e3f5bfafd9c450deb63858", "message": "update naming and updated javadocs", "committedDate": "2020-12-13T00:04:35Z", "type": "commit"}, {"oid": "f18fe748926d91de85b40615ff2d573ca1a5d01e", "url": "https://github.com/MovingBlocks/Terasology/commit/f18fe748926d91de85b40615ff2d573ca1a5d01e", "message": "Merge branch 'feature/chunk-standardization' of github.com:pollend/Terasology into feature/chunk-standardization", "committedDate": "2020-12-13T00:05:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNTc2MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541915761", "bodyText": "I think assertEquals takes the expected value as first argument, and the actual value as second argument. So I think these assertion arguments should be the other way around.", "author": "skaldarnar", "createdAt": "2020-12-13T12:29:32Z", "path": "engine-tests/src/test/java/org/terasology/math/BlockRegionTest.java", "diffHunk": "@@ -189,6 +189,23 @@ public void testCorrectBoundsFlip() {\n         assertEquals(max, region.getMax(new Vector3i()));\n     }\n \n+    @Test\n+    public void testEdge() {\n+        BlockRegion region = BlockRegions.createFromMinAndMax(new Vector3i(), new Vector3i(32, 32, 32));\n+        assertEquals(region.blockFace(Side.LEFT, new BlockRegion()), BlockRegions.createFromMinAndMax(new Vector3i(),\n+            new Vector3i(0, 32, 32)));\n+        assertEquals(region.blockFace(Side.RIGHT, new BlockRegion()), BlockRegions.createFromMinAndMax(new Vector3i(32, 0,\n+            0), new Vector3i(32, 32, 32)));\n+        assertEquals(region.blockFace(Side.FRONT, new BlockRegion()), BlockRegions.createFromMinAndMax(new Vector3i(0, 0,\n+            0), new Vector3i(32, 32, 0)));\n+        assertEquals(region.blockFace(Side.BACK, new BlockRegion()), BlockRegions.createFromMinAndMax(new Vector3i(0, 0,\n+            32), new Vector3i(32, 32, 32)));\n+        assertEquals(region.blockFace(Side.BOTTOM, new BlockRegion()), BlockRegions.createFromMinAndMax(new Vector3i(),\n+            new Vector3i(32, 0, 32)));\n+        assertEquals(region.blockFace(Side.TOP, new BlockRegion()), BlockRegions.createFromMinAndMax(new Vector3i(0, 32,\n+            0), new Vector3i(32, 32, 32)));", "originalCommit": "f18fe748926d91de85b40615ff2d573ca1a5d01e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0082e0d68163ec852624660434bc5dfa5d812f93", "chunk": "diff --git a/engine-tests/src/test/java/org/terasology/math/BlockRegionTest.java b/engine-tests/src/test/java/org/terasology/math/BlockRegionTest.java\nindex 7c348170e..3b1621ef0 100644\n--- a/engine-tests/src/test/java/org/terasology/math/BlockRegionTest.java\n+++ b/engine-tests/src/test/java/org/terasology/math/BlockRegionTest.java\n\n@@ -190,20 +190,20 @@ public void testCorrectBoundsFlip() {\n     }\n \n     @Test\n-    public void testEdge() {\n+    public void testFace() {\n         BlockRegion region = BlockRegions.createFromMinAndMax(new Vector3i(), new Vector3i(32, 32, 32));\n-        assertEquals(region.blockFace(Side.LEFT, new BlockRegion()), BlockRegions.createFromMinAndMax(new Vector3i(),\n-            new Vector3i(0, 32, 32)));\n-        assertEquals(region.blockFace(Side.RIGHT, new BlockRegion()), BlockRegions.createFromMinAndMax(new Vector3i(32, 0,\n-            0), new Vector3i(32, 32, 32)));\n-        assertEquals(region.blockFace(Side.FRONT, new BlockRegion()), BlockRegions.createFromMinAndMax(new Vector3i(0, 0,\n-            0), new Vector3i(32, 32, 0)));\n-        assertEquals(region.blockFace(Side.BACK, new BlockRegion()), BlockRegions.createFromMinAndMax(new Vector3i(0, 0,\n-            32), new Vector3i(32, 32, 32)));\n-        assertEquals(region.blockFace(Side.BOTTOM, new BlockRegion()), BlockRegions.createFromMinAndMax(new Vector3i(),\n-            new Vector3i(32, 0, 32)));\n-        assertEquals(region.blockFace(Side.TOP, new BlockRegion()), BlockRegions.createFromMinAndMax(new Vector3i(0, 32,\n-            0), new Vector3i(32, 32, 32)));\n+        assertEquals(BlockRegions.createFromMinAndMax(new Vector3i(),\n+            new Vector3i(0, 32, 32)), region.blockFace(Side.LEFT, new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(new Vector3i(32, 0,\n+            0), new Vector3i(32, 32, 32)), region.blockFace(Side.RIGHT, new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(new Vector3i(0, 0,\n+            0), new Vector3i(32, 32, 0)), region.blockFace(Side.FRONT, new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(new Vector3i(0, 0,\n+            32), new Vector3i(32, 32, 32)), region.blockFace(Side.BACK, new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(new Vector3i(),\n+            new Vector3i(32, 0, 32)), region.blockFace(Side.BOTTOM, new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(new Vector3i(0, 32,\n+            0), new Vector3i(32, 32, 32)), region.blockFace(Side.TOP, new BlockRegion()));\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNjE5Mw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541916193", "bodyText": "I think these tests should use the chunk constants instead of hard-coded numbers.", "author": "skaldarnar", "createdAt": "2020-12-13T12:32:07Z", "path": "engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java", "diffHunk": "@@ -15,105 +15,70 @@\n  */\n package org.terasology.math;\n \n+import org.joml.Vector3f;\n+import org.joml.Vector3i;\n import org.junit.jupiter.api.Test;\n import org.terasology.config.Config;\n import org.terasology.context.internal.ContextImpl;\n import org.terasology.context.internal.MockContext;\n-import org.terasology.math.geom.Vector3i;\n import org.terasology.registry.CoreRegistry;\n import org.terasology.world.block.BlockRegion;\n+import org.terasology.world.block.BlockRegions;\n+import org.terasology.world.chunks.Chunks;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n \n public class ChunkMathTest {\n \n-    @Test\n-    public void testGetEdgeRegion() {\n-        Region3i region = Region3i.createFromMinAndSize(new Vector3i(16, 0, 16), new Vector3i(16, 128, 16));\n-        assertEquals(Region3i.createFromMinMax(new Vector3i(16, 0, 16), new Vector3i(16, 127, 31)), ChunkMath.getEdgeRegion(region, Side.LEFT));\n-    }\n \n     @Test\n     public void testRegionPositions() {\n         CoreRegistry.setContext(new ContextImpl());\n         CoreRegistry.put(Config.class, new Config(new MockContext()));\n \n-        assertEquals(1, ChunkMath.calcChunkPos(Region3i.createFromMinMax(new Vector3i(0, 0, 0), new Vector3i(0, 0, 0))).length);\n-        assertEquals(1, ChunkMath.calcChunkPos(Region3i.createFromMinMax(new Vector3i(0, 0, 0), new Vector3i(31, 63, 31))).length);\n-        assertEquals(2, ChunkMath.calcChunkPos(Region3i.createFromMinMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 31))).length);\n-        assertEquals(4, ChunkMath.calcChunkPos(Region3i.createFromMinMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 32))).length);\n-        assertEquals(8, ChunkMath.calcChunkPos(Region3i.createFromMinMax(new Vector3i(0, 0, 0), new Vector3i(32, 64, 32))).length);\n-        assertEquals(12, ChunkMath.calcChunkPos(Region3i.createFromMinMax(new Vector3i(-1, 0, 0), new Vector3i(32, 64, 32))).length);\n+        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,0,0,0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(0, 0, 0)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,0,0,0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(31, 63, 31)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,1,0,0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 31)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,1,0,1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 32)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,1,1,1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 64, 32)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(-1,0,0,1,1,1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(-1, 0, 0), new Vector3i(32, 64, 32)), new BlockRegion()));", "originalCommit": "f18fe748926d91de85b40615ff2d573ca1a5d01e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1186eadd4ff7aa733d258eb5b7dad1c1f14b95ed", "chunk": "diff --git a/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java b/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java\nindex ae98adf21..87dbe805a 100644\n--- a/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java\n+++ b/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java\n\n@@ -29,20 +29,17 @@\n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n public class ChunkMathTest {\n-\n-\n     @Test\n     public void testRegionPositions() {\n         CoreRegistry.setContext(new ContextImpl());\n         CoreRegistry.put(Config.class, new Config(new MockContext()));\n \n-        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,0,0,0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(0, 0, 0)), new BlockRegion()));\n-        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,0,0,0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(31, 63, 31)), new BlockRegion()));\n-        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,1,0,0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 31)), new BlockRegion()));\n-        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,1,0,1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 32)), new BlockRegion()));\n-        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,1,1,1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 64, 32)), new BlockRegion()));\n-        assertEquals(BlockRegions.createFromMinAndMax(-1,0,0,1,1,1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(-1, 0, 0), new Vector3i(32, 64, 32)), new BlockRegion()));\n-\n+        assertEquals(BlockRegions.createFromMinAndMax(0, 0, 0, 0, 0, 0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(0, 0, 0)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0, 0, 0, 0, 0, 0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(31, 63, 31)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0, 0, 0, 1, 0, 0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 31)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0, 0, 0, 1, 0, 1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 32)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0, 0, 0, 1, 1, 1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 64, 32)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(-1, 0, 0, 1, 1, 1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(-1, 0, 0), new Vector3i(32, 64, 32)), new BlockRegion()));\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNjQwMg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541916402", "bodyText": "Swap the arguments (actual vs expected) around.", "author": "skaldarnar", "createdAt": "2020-12-13T12:33:20Z", "path": "engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java", "diffHunk": "@@ -15,105 +15,70 @@\n  */\n package org.terasology.math;\n \n+import org.joml.Vector3f;\n+import org.joml.Vector3i;\n import org.junit.jupiter.api.Test;\n import org.terasology.config.Config;\n import org.terasology.context.internal.ContextImpl;\n import org.terasology.context.internal.MockContext;\n-import org.terasology.math.geom.Vector3i;\n import org.terasology.registry.CoreRegistry;\n import org.terasology.world.block.BlockRegion;\n+import org.terasology.world.block.BlockRegions;\n+import org.terasology.world.chunks.Chunks;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n \n public class ChunkMathTest {\n \n-    @Test\n-    public void testGetEdgeRegion() {\n-        Region3i region = Region3i.createFromMinAndSize(new Vector3i(16, 0, 16), new Vector3i(16, 128, 16));\n-        assertEquals(Region3i.createFromMinMax(new Vector3i(16, 0, 16), new Vector3i(16, 127, 31)), ChunkMath.getEdgeRegion(region, Side.LEFT));\n-    }\n \n     @Test\n     public void testRegionPositions() {\n         CoreRegistry.setContext(new ContextImpl());\n         CoreRegistry.put(Config.class, new Config(new MockContext()));\n \n-        assertEquals(1, ChunkMath.calcChunkPos(Region3i.createFromMinMax(new Vector3i(0, 0, 0), new Vector3i(0, 0, 0))).length);\n-        assertEquals(1, ChunkMath.calcChunkPos(Region3i.createFromMinMax(new Vector3i(0, 0, 0), new Vector3i(31, 63, 31))).length);\n-        assertEquals(2, ChunkMath.calcChunkPos(Region3i.createFromMinMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 31))).length);\n-        assertEquals(4, ChunkMath.calcChunkPos(Region3i.createFromMinMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 32))).length);\n-        assertEquals(8, ChunkMath.calcChunkPos(Region3i.createFromMinMax(new Vector3i(0, 0, 0), new Vector3i(32, 64, 32))).length);\n-        assertEquals(12, ChunkMath.calcChunkPos(Region3i.createFromMinMax(new Vector3i(-1, 0, 0), new Vector3i(32, 64, 32))).length);\n+        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,0,0,0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(0, 0, 0)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,0,0,0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(31, 63, 31)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,1,0,0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 31)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,1,0,1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 32)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,1,1,1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 64, 32)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(-1,0,0,1,1,1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(-1, 0, 0), new Vector3i(32, 64, 32)), new BlockRegion()));\n \n-        Vector3i[] chunks = ChunkMath.calcChunkPos(Region3i.createFromMinMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 31)));\n-        assertEquals(new Vector3i(0, 0, 0), chunks[0]);\n-        assertEquals(new Vector3i(1, 0, 0), chunks[1]);\n     }\n \n     @Test\n     public void testCalcChunk() {\n-        assertEquals(0, ChunkMath.calcChunkPos(10, 6));\n-        assertEquals(-1, ChunkMath.calcChunkPos(-1, 6));\n-        assertEquals(1, ChunkMath.calcChunkPos(100, 6));\n-        assertEquals(3, ChunkMath.calcChunkPos(200, 6));\n-    }\n-\n-    @Test\n-    public void testCalcChunkPosX() {\n-        assertEquals(0, ChunkMath.calcChunkPosX(10));\n-        assertEquals(-1, ChunkMath.calcChunkPosX(-1));\n-        assertEquals(3, ChunkMath.calcChunkPosX(100));\n-        assertEquals(6, ChunkMath.calcChunkPosX(200));\n-        assertEquals(21, ChunkMath.calcChunkPosX(700));\n-    }\n-\n-    @Test\n-    public void testCalcChunkPosY() {\n-        assertEquals(0, ChunkMath.calcChunkPosY(10));\n-        assertEquals(-1, ChunkMath.calcChunkPosY(-1));\n-        assertEquals(1, ChunkMath.calcChunkPosY(100));\n-        assertEquals(3, ChunkMath.calcChunkPosY(200));\n-        assertEquals(10, ChunkMath.calcChunkPosY(700));\n-    }\n-\n-    @Test\n-    public void testCalcChunkPosZ() {\n-        assertEquals(0, ChunkMath.calcChunkPosZ(10));\n-        assertEquals(-1, ChunkMath.calcChunkPosZ(-1));\n-        assertEquals(6, ChunkMath.calcChunkPosZ(200));\n-        assertEquals(21, ChunkMath.calcChunkPosZ(700));\n+        assertEquals(0, Chunks.toChunkPos(10, 6));\n+        assertEquals(-1, Chunks.toChunkPos(-1, 6));\n+        assertEquals(1, Chunks.toChunkPos(100, 6));\n+        assertEquals(3, Chunks.toChunkPos(200, 6));\n     }\n \n     @Test\n     public void testCalcChunkPos() {\n         org.joml.Vector3i temp = new org.joml.Vector3i();\n-        assertTrue(ChunkMath.calcChunkPos(700, 700, 700, temp).equals(21, 10, 21));\n-        assertTrue(ChunkMath.calcChunkPos(200, 700, -1, temp).equals(6, 10, -1));\n-        assertTrue(ChunkMath.calcChunkPos(200, 200, 200, temp).equals(6, 3, 6));\n-        assertTrue(ChunkMath.calcChunkPos(10, 10, 10, temp).equals(0, 0, 0));\n-    }\n-\n-    @Test\n-    public void testChunkRegionAroundWorldPos() {\n-        assertEquals(ChunkMath.getChunkRegionAroundWorldPos(new org.joml.Vector3i(0, 0, 0), 100),\n-            new BlockRegion(-4, -2, -4, 3, 1, 3));\n-        assertEquals(ChunkMath.getChunkRegionAroundWorldPos(new org.joml.Vector3i(-30, -30, -30), 100),\n-            new BlockRegion(-5, -3, -5, 2, 1, 2));\n-        assertEquals(ChunkMath.getChunkRegionAroundWorldPos(new org.joml.Vector3i(0, 0, 0), 10),\n-            new BlockRegion(-1, -1, -1, 0, 0, 0));\n+        assertEquals(Chunks.toChunkPos(700, 700, 700, temp), new Vector3i(21, 10, 21));\n+        assertEquals(Chunks.toChunkPos(200, 700, -1, temp), new Vector3i(6, 10, -1));\n+        assertEquals(Chunks.toChunkPos(200, 200, 200, temp), new Vector3i(6, 3, 6));\n+        assertEquals(Chunks.toChunkPos(10, 10, 10, temp), new Vector3i(0, 0, 0));", "originalCommit": "f18fe748926d91de85b40615ff2d573ca1a5d01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNjQ5MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541916490", "bodyText": "We may also turn this into parameterized tests...", "author": "skaldarnar", "createdAt": "2020-12-13T12:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNjQwMg=="}], "type": "inlineReview", "revised_code": {"commit": "1186eadd4ff7aa733d258eb5b7dad1c1f14b95ed", "chunk": "diff --git a/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java b/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java\nindex ae98adf21..87dbe805a 100644\n--- a/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java\n+++ b/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java\n\n@@ -29,20 +29,17 @@\n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n public class ChunkMathTest {\n-\n-\n     @Test\n     public void testRegionPositions() {\n         CoreRegistry.setContext(new ContextImpl());\n         CoreRegistry.put(Config.class, new Config(new MockContext()));\n \n-        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,0,0,0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(0, 0, 0)), new BlockRegion()));\n-        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,0,0,0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(31, 63, 31)), new BlockRegion()));\n-        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,1,0,0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 31)), new BlockRegion()));\n-        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,1,0,1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 32)), new BlockRegion()));\n-        assertEquals(BlockRegions.createFromMinAndMax(0,0,0,1,1,1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 64, 32)), new BlockRegion()));\n-        assertEquals(BlockRegions.createFromMinAndMax(-1,0,0,1,1,1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(-1, 0, 0), new Vector3i(32, 64, 32)), new BlockRegion()));\n-\n+        assertEquals(BlockRegions.createFromMinAndMax(0, 0, 0, 0, 0, 0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(0, 0, 0)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0, 0, 0, 0, 0, 0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(31, 63, 31)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0, 0, 0, 1, 0, 0), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 31)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0, 0, 0, 1, 0, 1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 63, 32)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(0, 0, 0, 1, 1, 1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(0, 0, 0), new Vector3i(32, 64, 32)), new BlockRegion()));\n+        assertEquals(BlockRegions.createFromMinAndMax(-1, 0, 0, 1, 1, 1), Chunks.toChunkRegion(BlockRegions.createFromMinAndMax(new Vector3i(-1, 0, 0), new Vector3i(32, 64, 32)), new BlockRegion()));\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNzI1Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541917256", "bodyText": "Should this be on BlockRegion or BlockRegions (utility class)?", "author": "skaldarnar", "createdAt": "2020-12-13T12:38:39Z", "path": "engine/src/main/java/org/terasology/math/ChunkMath.java", "diffHunk": "@@ -569,7 +575,9 @@ public static Region3i getEdgeRegion(Region3i region, Side side) {\n      * @param side the side to border\n      * @param dest will hold the result\n      * @return dest\n+     * @deprecated use {@link BlockRegion#blockFace(Side, BlockRegion)}", "originalCommit": "f18fe748926d91de85b40615ff2d573ca1a5d01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2MDM5OA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r546260398", "bodyText": "I guess you could move it to the utility class but it seems more complicated. (source, Face) or (source, Face, Dest) if we want to be able to write it somewhere.", "author": "pollend", "createdAt": "2020-12-19T17:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNzI1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "21317aa8e5c6c68724b62ddf9996a09a3d3a5b8c", "chunk": "diff --git a/engine/src/main/java/org/terasology/math/ChunkMath.java b/engine/src/main/java/org/terasology/math/ChunkMath.java\nindex 2603ff705..85a851842 100644\n--- a/engine/src/main/java/org/terasology/math/ChunkMath.java\n+++ b/engine/src/main/java/org/terasology/math/ChunkMath.java\n\n@@ -578,73 +579,65 @@ public static Region3i getEdgeRegion(Region3i region, Side side) {\n      * @deprecated use {@link BlockRegion#blockFace(Side, BlockRegion)}\n      */\n     @Deprecated\n-    public static BlockRegion getEdgeRegion(BlockRegion region, Side side, BlockRegion dest) {\n+    public static BlockRegion getEdgeRegion(BlockRegionc region, Side side, BlockRegion dest) {\n         switch (side) {\n             case TOP:\n-                return dest.setMin(\n-                    region.getMinX(),\n-                    region.getMaxY(),\n-                    region.getMinZ()\n-                ).setMax(\n-                    region.getMaxX(),\n-                    region.getMaxY(),\n-                    region.getMaxZ());\n+                return dest.set(\n+                    region.minX(),\n+                    region.maxY(),\n+                    region.minZ(),\n+                    region.maxX(),\n+                    region.maxY(),\n+                    region.maxZ());\n             case BOTTOM:\n-                return dest.setMin(\n-                    region.getMinX(),\n-                    region.getMinY(),\n-                    region.getMinZ()\n-                ).setMax(\n-                    region.getMaxX(),\n-                    region.getMinY(),\n-                    region.getMaxZ());\n+                return dest.set(\n+                    region.minX(),\n+                    region.minY(),\n+                    region.minZ(),\n+                    region.maxX(),\n+                    region.minY(),\n+                    region.maxZ());\n             case LEFT:\n-                return dest.setMin(\n-                    region.getMinX(),\n-                    region.getMinY(),\n-                    region.getMinZ()\n-                ).setMax(\n-                    region.getMinX(),\n-                    region.getMaxY(),\n-                    region.getMaxZ());\n+                return dest.set(\n+                    region.minX(),\n+                    region.minY(),\n+                    region.minZ(),\n+                    region.minX(),\n+                    region.maxY(),\n+                    region.maxZ());\n             case RIGHT:\n-                return dest.setMin(\n-                    region.getMaxX(),\n-                    region.getMinY(),\n-                    region.getMinZ()\n-                ).setMax(\n-                    region.getMaxX(),\n-                    region.getMaxY(),\n-                    region.getMaxZ());\n+                return dest.set(\n+                    region.maxX(),\n+                    region.minY(),\n+                    region.minZ(),\n+                    region.maxX(),\n+                    region.maxY(),\n+                    region.maxZ());\n             case FRONT:\n-                return dest.setMin(\n-                    region.getMinX(),\n-                    region.getMinY(),\n-                    region.getMinZ()\n-                ).setMax(\n-                    region.getMaxX(),\n-                    region.getMaxY(),\n-                    region.getMinZ());\n+                return dest.set(\n+                    region.minX(),\n+                    region.minY(),\n+                    region.minZ(),\n+                    region.maxX(),\n+                    region.maxY(),\n+                    region.minZ());\n             case BACK:\n-                return dest.setMin(\n-                    region.getMinX(),\n-                    region.getMinY(),\n-                    region.getMaxZ()\n-                ).setMax(\n-                    region.getMaxX(),\n-                    region.getMaxY(),\n-                    region.getMaxZ());\n+                return dest.set(\n+                    region.minX(),\n+                    region.minY(),\n+                    region.maxZ(),\n+                    region.maxX(),\n+                    region.maxY(),\n+                    region.maxZ());\n             default:\n-                return dest.setMin(\n-                    region.getMinX(),\n-                    region.getMinY(),\n-                    region.getMinZ()\n-                ).setMax(\n-                    region.getMaxX(),\n-                    region.getMaxY(),\n-                    region.getMaxZ()\n+                return dest.set(\n+                    region.minX(),\n+                    region.minY(),\n+                    region.minZ(),\n+                    region.maxX(),\n+                    region.maxY(),\n+                    region.maxZ()\n                 );\n-\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNzM5Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541917396", "bodyText": "Should this be implemented on BlockRegion or BlockRegions (utility class)?", "author": "skaldarnar", "createdAt": "2020-12-13T12:39:26Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -802,6 +803,38 @@ public BlockRegion addExtents(float extentX, float extentY, float extentZ, Block\n         return dest;\n     }\n \n+    /**\n+     * calculates a 1 width region that borders the provided {@link Side} of a region\n+     *\n+     * @param side the side of the region\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion blockFace(Side side, BlockRegion dest) {", "originalCommit": "f18fe748926d91de85b40615ff2d573ca1a5d01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk0MzMyNQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541943325", "bodyText": "I think it should be fine as a base method. Any particular reason it needs be in the utility class.", "author": "pollend", "createdAt": "2020-12-13T15:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNzM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA0MzQwMQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r549043401", "bodyText": "This method with dest should be moved to BlockRegionc as default method.\nThe in-place variant BlockRegion::blockFace(Side side) should be added to BlockRegion itself.\n\nQuestion: is blockFace a good/the best name for it? Would getSide be better (but then it would not be clear that this would modify the region if we implement (2) from above \ud83e\udd14 )", "author": "skaldarnar", "createdAt": "2020-12-26T23:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNzM5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "21317aa8e5c6c68724b62ddf9996a09a3d3a5b8c", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 57f52e980..e9689467b 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -2,805 +2,492 @@\n // SPDX-License-Identifier: Apache-2.0\n package org.terasology.world.block;\n \n-import org.joml.AABBf;\n-import org.joml.AABBi;\n-import org.joml.Intersectionf;\n-import org.joml.LineSegmentf;\n+import com.google.common.base.Preconditions;\n import org.joml.Math;\n import org.joml.Matrix4fc;\n-import org.joml.Planef;\n-import org.joml.Rayf;\n import org.joml.RoundingMode;\n-import org.joml.Spheref;\n-import org.joml.Vector2f;\n-import org.joml.Vector3f;\n-import org.joml.Vector3fc;\n import org.joml.Vector3i;\n import org.joml.Vector3ic;\n-import org.terasology.entitySystem.entity.EntityRef;\n import org.terasology.math.Side;\n \n+import java.util.Iterator;\n+import java.util.Optional;\n+\n /**\n- * is a bounded box describing blocks contained within. A {@link BlockRegion} is described and backed by an {@link\n- * AABBi}\n+ * A mutable, bounded, axis-aligned volume in space denoting a collection of blocks contained within.\n  */\n-public class BlockRegion {\n+public class BlockRegion implements BlockRegionc {\n+\n+    public static final BlockRegionc INVALID = new BlockRegion();\n \n     /**\n-     * AABB region that backs a BlockRegion\n+     * The x coordinate of the minimum corner.\n      */\n-    public final AABBi aabb = new AABBi();\n-\n-    public BlockRegion() {\n-    }\n-\n-    public BlockRegion(BlockRegion source) {\n-        aabb.set(source.aabb);\n-    }\n-\n-    public BlockRegion(AABBi source) {\n-        aabb.set(source);\n-    }\n-\n+    private int minX = Integer.MAX_VALUE;\n     /**\n-     * Deprecated in favor of {@link org.terasology.world.block.BlockRegions#createFromMinAndMax(Vector3ic, Vector3ic)}\n+     * The y coordinate of the minimum corner.\n      */\n-    @Deprecated\n-    public BlockRegion(Vector3ic min, Vector3ic max) {\n-        this(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n-    }\n-\n+    private int minY = Integer.MAX_VALUE;\n     /**\n-     * Deprecated in favor of {@link org.terasology.world.block.BlockRegions#createFromMinAndMax(Vector3ic, Vector3ic)}\n+     * The z coordinate of the minimum corner.\n      */\n-    @Deprecated\n-    public BlockRegion(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n-        this.setMin(minX, minY, minZ).setMax(maxX, maxY, maxZ);\n-    }\n-\n-\n+    private int minZ = Integer.MAX_VALUE;\n     /**\n-     * get the minimum block coordinate\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n+     * The x coordinate of the maximum corner.\n      */\n-    public Vector3i getMin(Vector3i dest) {\n-        return dest.set(aabb.minX, aabb.minY, aabb.minZ);\n-    }\n-\n+    private int maxX = Integer.MIN_VALUE;\n     /**\n-     * get the maximum block coordinate\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n+     * The y coordinate of the maximum corner.\n      */\n-    public Vector3i getMax(Vector3i dest) {\n-        return dest.set(aabb.maxX - 1, aabb.maxY - 1, aabb.maxZ - 1);\n-    }\n+    private int maxY = Integer.MIN_VALUE;\n+    /**\n+     * The z coordinate of the maximum corner.\n+     */\n+    private int maxZ = Integer.MIN_VALUE;\n+\n+    // -- CONSTRUCTORS -----------------------------------------------------------------------------------------------//\n \n     /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n+     * INTERNAL: Creates an empty block region with invalid minimum/maximum corners.\n+     * <p>\n+     * {@link #isValid()} will return {@code false} for an empty block region created via this constructor.\n      */\n-    public int getMaxX() {\n-        return this.aabb.maxX - 1;\n+    BlockRegion() {\n     }\n \n     /**\n-     * the maximum coordinate of the second block y\n+     * Creates a new region spanning the smallest axis-aligned bounding box (AABB) containing both, min and max.\n+     * <p>\n+     * Note that each component of the minimum corner MUST be smaller or equal to the respective component of the\n+     * maximum corner. If a dimension of {@code min} is greater than the respective dimension of {@code max} an {@link\n+     * IllegalArgumentException} will be thrown.\n+     * <p>\n+     * Consider using {@link #union(Vector3ic)} as an alternative.\n      *\n-     * @return the minimum coordinate y\n+     * @throws IllegalArgumentException if any min component is greater than the corresponding max component\n      */\n-    public int getMaxY() {\n-        return this.aabb.maxY - 1;\n+    public BlockRegion(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        this.set(minX, minY, minZ, maxX, maxY, maxZ);\n     }\n \n     /**\n-     * the maximum coordinate of the second block z\n+     * Creates a new region spanning the smallest axis-aligned bounding box (AABB) containing both, min and max.\n+     * <p>\n+     * Note that each component of the minimum corner MUST be smaller or equal to the respective component of the\n+     * maximum corner. If a dimension of {@code min} is greater than the respective dimension of {@code max} an {@link\n+     * IllegalArgumentException} will be thrown.\n+     * <p>\n+     * Consider using {@link #union(Vector3ic)} as an alternative.\n      *\n-     * @return the minimum coordinate z\n+     * @throws IllegalArgumentException if any min component is greater than the corresponding max component\n      */\n-    public int getMaxZ() {\n-        return this.aabb.maxZ - 1;\n+    public BlockRegion(Vector3ic min, Vector3ic max) {\n+        this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n-     *\n-     * @return the minimum coordinate x\n+     * Creates a new region containing the single block given by the coordinates.\n      */\n-    public int getMinX() {\n-        return this.aabb.minX;\n+    public BlockRegion(int x, int y, int z) {\n+        this.set(x, y, z, x, y, z);\n     }\n \n     /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n+     * Creates a new region containing the single block given by the coordinates.\n      */\n-    public int getMinY() {\n-        return this.aabb.minY;\n+    public BlockRegion(Vector3ic block) {\n+        this(block.x(), block.y(), block.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block z\n+     * Create a new copy of the given block region {@code source}.\n      *\n-     * @return the minimum coordinate z\n+     * @param source the block region to copy.\n      */\n-    public int getMinZ() {\n-        return this.aabb.minZ;\n+    public BlockRegion(BlockRegionc source) {\n+        this.set(source);\n     }\n \n-    /**\n-     * set source to current region\n-     * @param source the source region\n-     * @return this\n-     */\n-    public BlockRegion set(BlockRegion source) {\n-        this.aabb.set(source.aabb);\n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n+    // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n+\n+    /**\n+     * Reset both the minimum and maximum corner of this region.\n+     *\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n+     */\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+        Preconditions.checkArgument(minZ <= maxZ || (minZ == INVALID.minZ() && maxZ == INVALID.maxZ()));\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n+\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n         return this;\n     }\n \n     /**\n-     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @param min the first coordinate of the first block\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion setMin(Vector3ic min) {\n-        this.aabb.setMin(min);\n-        return this;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * Sets the maximum coordinate of the second block for <code>this</code> {@link BlockRegion}\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @param max the second coordinate of the second block\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion setMax(Vector3ic max) {\n-        this.setMax(max.x(), max.y(), max.z());\n-        return this;\n+    public BlockRegion set(BlockRegionc source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * sets the maximum block for this {@link BlockRegion}\n-     *\n-     * @param maxX the x coordinate of the first block\n-     * @param maxY the y coordinate of the first block\n-     * @param maxZ the z coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMax(int maxX, int maxY, int maxZ) {\n-        this.aabb.setMax(maxX + 1, maxY + 1, maxZ + 1);\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * sets the minimum block for this {@link BlockRegion}\n-     *\n-     * @param minX the x coordinate of the first block\n-     * @param minY the y coordinate of the first block\n-     * @param minZ the z coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMin(int minX, int minY, int minZ) {\n-        aabb.setMin(minX, minY, minZ);\n-        return this;\n+    @Override\n+    public int minY() {\n+        return this.minY;\n     }\n \n-    /**\n-     * Set <code>this</code> to the union of <code>this</code> and the given {@link EntityRef} associated with a block\n-     * <code>p</code>.\n-     *\n-     * @param blockRef entityRef that describes a block\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockRegion union(EntityRef blockRef, BlockRegion dest) {\n-        BlockComponent component = blockRef.getComponent(BlockComponent.class);\n-        if (component != null) {\n-            return this.union(component.position.x(), component.position.y(), component.position.z(), dest);\n-        }\n-        return dest;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * Set <code>this</code> to the union of <code>this</code> and the given block <code>p</code>.\n-     *\n-     * @param p the position of the block\n-     * @return this\n-     */\n-    public BlockRegion union(Vector3ic p) {\n-        return union(p.x(), p.y(), p.z(), this);\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        return dest.set(x, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * Compute the union of <code>this</code> and the given block <code>(x, y, z)</code> and stores the result in\n-     * <code>dest</code>\n-     *\n-     * @param x the x coordinate of the block\n-     * @param y the y coordinate of the block\n-     * @param z the z coordinate of the block\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n-        // a block is (x,y,z) and (x + 1, y + 1, z + 1)\n-        dest.aabb.minX = Math.min(this.aabb.minX, x);\n-        dest.aabb.minY = Math.min(this.aabb.minY, y);\n-        dest.aabb.minZ = Math.min(this.aabb.minZ, z);\n-        dest.aabb.maxX = Math.max(this.aabb.maxX, (x + 1));\n-        dest.aabb.maxY = Math.max(this.aabb.maxY, (y + 1));\n-        dest.aabb.maxZ = Math.max(this.aabb.maxZ, (z + 1));\n-        return dest;\n+    public BlockRegion minX(int x) {\n+        return this.minX(x, this);\n     }\n \n-    /**\n-     * Compute the union of <code>this</code> and the given block <code>(x, y, z)</code> and store the result in\n-     * <code>dest</code>.\n-     *\n-     * @param pos the position of the block\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockRegion union(Vector3ic pos, BlockRegion dest) {\n-        return this.union(pos.x(), pos.y(), pos.z(), dest);\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n+        return dest.set(this.minX, y, this.minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n-     *\n-     * @param other {@link BlockRegion}\n-     * @return this\n-     */\n-    public BlockRegion union(BlockRegion other) {\n-        return this.union(other.aabb);\n+    public BlockRegion minY(int y) {\n+        return this.minY(y, this);\n     }\n \n-    /**\n-     * Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n-     *\n-     * @param other {@link AABBi}\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockRegion union(AABBi other, BlockRegion dest) {\n-        dest.union(other);\n-        return dest;\n+    @Override\n+    public BlockRegion minZ(int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, z, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n-     *\n-     * @param other the other {@link AABBi}\n-     * @return this\n-     */\n-    public BlockRegion union(AABBi other) {\n-        this.aabb.union(other);\n-        return this;\n+    public BlockRegion minZ(int z) {\n+        return this.minZ(z, this);\n     }\n \n-    /**\n-     * Ensure that the minimum coordinates are strictly less than or equal to the maximum coordinates by swapping them\n-     * if necessary.\n-     *\n-     * @return this\n-     */\n-    public BlockRegion correctBounds() {\n-        // NOTE: this is basically the same as AABBi#correctBounds, but adjusted for off-by-one semantics here in\n-        //       BlockRegion for the max value.\n-        int tmp;\n-        if (this.aabb.minX > this.aabb.maxX - 1) {\n-            tmp = this.aabb.minX;\n-            this.aabb.minX = this.aabb.maxX - 1;\n-            this.aabb.maxX = tmp + 1;\n-        }\n-        if (this.aabb.minY > this.aabb.maxY - 1) {\n-            tmp = this.aabb.minY;\n-            this.aabb.minY = this.aabb.maxY - 1;\n-            this.aabb.maxY = tmp + 1;\n-        }\n-        if (this.aabb.minZ > this.aabb.maxZ - 1) {\n-            tmp = this.aabb.minZ;\n-            this.aabb.minZ = this.aabb.maxZ - 1;\n-            this.aabb.maxZ = tmp + 1;\n-        }\n-        return this;\n+    @Override\n+    public BlockRegion setMin(int x, int y, int z, BlockRegion dest) {\n+        return dest.set(x, y, z, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * set the size of the block region from minimum.\n-     *\n-     * @param x the x coordinate to set the size\n-     * @param y the y coordinate to set the size\n-     * @param z the z coordinate to set the size\n-     * @return this\n-     */\n-    public BlockRegion setSize(int x, int y, int z) {\n-        this.aabb.maxX = this.aabb.minX + x;\n-        this.aabb.maxY = this.aabb.minY + y;\n-        this.aabb.maxZ = this.aabb.minZ + z;\n-        return this;\n+    public BlockRegion setMin(int x, int y, int z) {\n+        return this.setMin(x, y, z, this);\n     }\n \n-    /**\n-     * set the size of the block region from minimum.\n-     *\n-     * @param size the size to set the {@link BlockRegion}\n-     * @return this\n-     */\n-    public BlockRegion setSize(Vector3ic size) {\n-        return setSize(size.x(), size.y(), size.z());\n+    public BlockRegion setMin(Vector3ic min) {\n+        return this.setMin(min, this);\n     }\n \n-    /**\n-     * the number of blocks for the +x, +y, +z from the minimum to the maximum\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector3i getSize(Vector3i dest) {\n-        return dest.set(this.aabb.maxX - this.aabb.minX, this.aabb.maxY - this.aabb.minY,\n-                this.aabb.maxZ - this.aabb.minZ);\n+    public BlockRegion addToMin(int dx, int dy, int dz) {\n+        return this.addToMin(dx, dy, dz, this);\n     }\n \n-    /**\n-     * The number of blocks on the X axis\n-     *\n-     * @return number of blocks in the X axis\n-     */\n-    public int getSizeX() {\n-        return this.aabb.maxX - this.aabb.minX;\n+    public BlockRegion addToMin(Vector3ic dmin) {\n+        return this.addToMin(dmin, this);\n     }\n \n-    /**\n-     * The number of blocks on the Y axis\n-     *\n-     * @return number of blocks in the Y axis\n-     */\n-    public int getSizeY() {\n-        return this.aabb.maxY - this.aabb.minY;\n+\n+    // -- max --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int maxX() {\n+        return this.maxX;\n     }\n \n-    /**\n-     * The number of blocks on the Z axis\n-     *\n-     * @return number of blocks in the Z axis\n-     */\n-    public int getSizeZ() {\n-        return this.aabb.maxZ - this.aabb.minZ;\n+    @Override\n+    public int maxY() {\n+        return this.maxY;\n     }\n \n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param x the x coordinate to translate by\n-     * @param y the y coordinate to translate by\n-     * @param z the z coordinate to translate by\n-     * @return this\n-     */\n-    public BlockRegion translate(int x, int y, int z) {\n-        aabb.translate(x, y, z);\n-        return this;\n+    @Override\n+    public int maxZ() {\n+        return this.maxZ;\n     }\n \n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param xyz the vector to translate by\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockRegion translate(Vector3ic xyz, BlockRegion dest) {\n-        aabb.translate(xyz, dest.aabb);\n-        return dest;\n+    @Override\n+    public BlockRegion maxX(int x, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, x, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param xyz the vector to translate by\n-     * @return this\n-     */\n-    public BlockRegion translate(Vector3ic xyz) {\n-        this.aabb.translate(xyz);\n-        return this;\n+    public BlockRegion maxX(int x) {\n+        return this.maxX(x, this);\n     }\n \n-    /**\n-     * Apply the given {@link Matrix4fc#isAffine() affine} transformation to this {@link BlockRegion}.\n-     * <p>\n-     * The matrix in <code>m</code> <i>must</i> be {@link Matrix4fc#isAffine() affine}.\n-     *\n-     * @param m the affine transformation matrix\n-     * @return this\n-     */\n-    public BlockRegion transform(Matrix4fc m) {\n-        this.aabb.transform(m);\n-        return this;\n+    @Override\n+    public BlockRegion maxY(int y, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.maxX, y, this.maxZ);\n     }\n \n-    /**\n-     * Apply the given {@link Matrix4fc#isAffine() affine} transformation to this {@link BlockRegion}.\n-     * <p>\n-     * The matrix in <code>m</code> <i>must</i> be {@link Matrix4fc#isAffine() affine}.\n-     *\n-     * @param m the affine transformation matrix\n-     * @return this\n-     */\n-    public BlockRegion transform(Matrix4fc m, BlockRegion dest) {\n-        this.aabb.transform(m, dest.aabb);\n-        return dest;\n+    public BlockRegion maxY(int y) {\n+        return this.maxY(y, this);\n     }\n \n-    /**\n-     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param pos the coordinates of the block\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsBlock(Vector3ic pos) {\n-        return containsBlock(pos.x(), pos.y(), pos.z());\n+    @Override\n+    public BlockRegion maxZ(int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.maxX, this.maxY, z);\n     }\n \n-    /**\n-     * The center of the region if the region is valid, {@link Float#NaN} in all dimensions otherwise.\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector3f center(Vector3f dest) {\n-        if (!this.isValid()) {\n-            return dest.set(Float.NaN);\n-        }\n-        return dest.set(\n-                aabb.minX + ((aabb.maxX - aabb.minX) / 2.0f),\n-                aabb.minY + ((aabb.maxY - aabb.minY) / 2.0f),\n-                aabb.minZ + ((aabb.maxZ - aabb.minZ) / 2.0f)\n-        );\n+    public BlockRegion maxZ(int z) {\n+        return this.maxZ(z, this);\n     }\n \n-    /**\n-     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @param z the z coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsBlock(int x, int y, int z) {\n-        return x >= aabb.minX && y >= aabb.minY && z >= aabb.minZ && x < aabb.maxX && y < aabb.maxY && z < aabb.maxZ;\n+    @Override\n+    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, x, y, z);\n     }\n \n-    /**\n-     * Test whether the point <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @param z the z coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this BlockRegion; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(float x, float y, float z) {\n-        return this.aabb.containsPoint(x, y, z);\n+    public BlockRegion setMax(int x, int y, int z) {\n+        return this.setMax(x, y, z, this);\n     }\n \n-    /**\n-     * Test whether the point <code>(x, y, z)</code> lies inside this AABB.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @param z the z coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(int x, int y, int z) {\n-        return this.aabb.containsPoint(x, y, z);\n+    public BlockRegion setMax(Vector3ic max) {\n+        return this.setMax(max, this);\n     }\n \n-    /**\n-     * Test whether the given point lies inside this AABB.\n-     *\n-     * @param point the coordinates of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(Vector3ic point) {\n-        return this.aabb.containsPoint(point);\n+    public BlockRegion addToMax(int dx, int dy, int dz) {\n+        return this.addToMax(dx, dy, dz, this);\n     }\n \n-    /**\n-     * Test whether the given point lies inside this AABB.\n-     *\n-     * @param point the coordinates of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(Vector3fc point) {\n-        return this.aabb.containsPoint(point);\n+    public BlockRegion addToMax(Vector3ic dmax) {\n+        return this.addToMax(dmax, this);\n     }\n \n-    /**\n-     * Test whether the plane given via its plane equation <code>a*x + b*y + c*z + d = 0</code> intersects this AABB.\n-     * <p>\n-     * Reference:\n-     * <a href=\"http://www.lighthouse3d.com/tutorials/view-frustum-culling/geometric-approach-testing-boxes-ii/\">http://www.lighthouse3d.com</a>\n-     * (\"Geometric Approach - Testing Boxes II\")\n-     *\n-     * @param a the x factor in the plane equation\n-     * @param b the y factor in the plane equation\n-     * @param c the z factor in the plane equation\n-     * @param d the constant in the plane equation\n-     * @return <code>true</code> iff the plane intersects this AABB; <code>false</code> otherwise\n-     */\n-    public boolean intersectsPlane(float a, float b, float c, float d) {\n-        return this.aabb.intersectsPlane(a, b, c, d);\n+    // -- size -------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockRegion setSize(int x, int y, int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.minX + x - 1, this.minY + y - 1, this.minZ + z - 1);\n     }\n \n-    /**\n-     * Test whether the given plane intersects this AABB.\n-     * <p>\n-     * Reference:\n-     * <a href=\"http://www.lighthouse3d.com/tutorials/view-frustum-culling/geometric-approach-testing-boxes-ii/\">http://www.lighthouse3d.com</a>\n-     * (\"Geometric Approach - Testing Boxes II\")\n-     *\n-     * @param plane the plane\n-     * @return <code>true</code> iff the plane intersects this AABB; <code>false</code> otherwise\n-     */\n-    public boolean intersectsPlane(Planef plane) {\n-        return this.aabb.intersectsPlane(plane);\n+    public BlockRegion setSize(int x, int y, int z) {\n+        return this.setSize(x, y, z, this);\n     }\n \n-    /**\n-     * Test whether <code>this</code> and <code>other</code> intersect.\n-     *\n-     * @param other the other BlockRegion\n-     * @return <code>true</code> iff both AABBs intersect; <code>false</code> otherwise\n-     */\n-    public boolean intersectsBlockRegion(BlockRegion other) {\n-        return this.aabb.intersectsAABB(other.aabb);\n+    public BlockRegion setSize(Vector3ic size) {\n+        return setSize(size.x(), size.y(), size.z());\n     }\n \n-    /**\n-     * Test whether <code>this</code> and <code>other</code> intersect.\n-     *\n-     * @param other the other AABB\n-     * @return <code>true</code> iff both AABBs intersect; <code>false</code> otherwise\n-     */\n-    public boolean intersectsAABB(AABBi other) {\n-        return this.aabb.intersectsAABB(other);\n+    // -- IN-PLACE MUTATION ------------------------------------------------------------------------------------------//\n+    @Override\n+    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = Math.min(this.minX, x);\n+        dest.minY = Math.min(this.minY, y);\n+        dest.minZ = Math.min(this.minZ, z);\n+\n+        dest.maxX = Math.max(this.maxX, x);\n+        dest.maxY = Math.max(this.maxY, y);\n+        dest.maxZ = Math.max(this.maxZ, z);\n+        return dest;\n     }\n \n-    /**\n-     * Test whether <code>this</code> and <code>other</code> intersect.\n-     *\n-     * @param other the other AABB\n-     * @return <code>true</code> iff both AABBs intersect; <code>false</code> otherwise\n-     */\n-    public boolean intersectsAABB(AABBf other) {\n-        return this.aabb.intersectsAABB(other);\n+    public BlockRegion union(int x, int y, int z) {\n+        return this.union(x, y, z, this);\n     }\n \n-    /**\n-     * Test whether this AABB intersects the given sphere with equation\n-     * <code>(x - centerX)^2 + (y - centerY)^2 + (z - centerZ)^2 - radiusSquared = 0</code>.\n-     * <p>\n-     * Reference:\n-     * <a href=\"http://stackoverflow.com/questions/4578967/cube-sphere-intersection-test#answer-4579069\">http://stackoverflow.com</a>\n-     *\n-     * @param centerX the x coordinate of the center of the sphere\n-     * @param centerY the y coordinate of the center of the sphere\n-     * @param centerZ the z coordinate of the center of the sphere\n-     * @param radiusSquared the square radius of the sphere\n-     * @return <code>true</code> iff this AABB and the sphere intersect; <code>false</code> otherwise\n-     */\n-    public boolean intersectsSphere(float centerX, float centerY, float centerZ, float radiusSquared) {\n-        return Intersectionf.testAabSphere(aabb.minX, aabb.minY, aabb.minZ, aabb.maxX, aabb.maxY, aabb.maxZ, centerX,\n-                centerY, centerZ, radiusSquared);\n+    public BlockRegion union(Vector3ic pos) {\n+        return union(pos.x(), pos.y(), pos.z(), this);\n     }\n \n-    /**\n-     * Test whether this AABB intersects the given sphere.\n-     * <p>\n-     * Reference:\n-     * <a href=\"http://stackoverflow.com/questions/4578967/cube-sphere-intersection-test#answer-4579069\">http://stackoverflow.com</a>\n-     *\n-     * @param sphere the sphere\n-     * @return <code>true</code> iff this AABB and the sphere intersect; <code>false</code> otherwise\n-     */\n-    public boolean intersectsSphere(Spheref sphere) {\n-        return Intersectionf.testAabSphere(aabb, sphere);\n+    public BlockRegion union(BlockRegionc other) {\n+        return this.union(other, this);\n     }\n \n-    /**\n-     * Test whether the given ray with the origin <code>(originX, originY, originZ)</code> and direction <code>(dirX,\n-     * dirY, dirZ)</code> intersects this AABB.\n-     * <p>\n-     * This method returns <code>true</code> for a ray whose origin lies inside this AABB.\n-     * <p>\n-     * Reference: <a href=\"https://dl.acm.org/citation.cfm?id=1198748\">An Efficient and Robust Ray\u2013Box Intersection</a>\n-     *\n-     * @param originX the x coordinate of the ray's origin\n-     * @param originY the y coordinate of the ray's origin\n-     * @param originZ the z coordinate of the ray's origin\n-     * @param dirX the x coordinate of the ray's direction\n-     * @param dirY the y coordinate of the ray's direction\n-     * @param dirZ the z coordinate of the ray's direction\n-     * @return <code>true</code> if this AABB and the ray intersect; <code>false</code> otherwise\n-     */\n-    public boolean intersectsRay(float originX, float originY, float originZ, float dirX, float dirY, float dirZ) {\n-        return Intersectionf.testRayAab(originX, originY, originZ, dirX, dirY, dirZ, aabb.minX, aabb.minY, aabb.minZ,\n-                aabb.maxX, aabb.maxY, aabb.maxZ);\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Optional<BlockRegion> intersect(BlockRegionc other, BlockRegion dest) {\n+        dest.minX = Math.max(minX, other.minX());\n+        dest.minY = Math.max(minY, other.minY());\n+        dest.minZ = Math.max(minZ, other.minZ());\n+\n+        dest.maxX = Math.min(maxX, other.maxX());\n+        dest.maxY = Math.min(maxY, other.maxY());\n+        dest.maxZ = Math.min(maxZ, other.maxZ());\n+\n+        if (dest.isValid()) {\n+            return Optional.of(dest);\n+        } else {\n+            return Optional.empty();\n+        }\n     }\n \n-    /**\n-     * Test whether the given ray intersects this AABB.\n-     * <p>\n-     * This method returns <code>true</code> for a ray whose origin lies inside this AABB.\n-     * <p>\n-     * Reference: <a href=\"https://dl.acm.org/citation.cfm?id=1198748\">An Efficient and Robust Ray\u2013Box Intersection</a>\n-     *\n-     * @param ray the ray\n-     * @return <code>true</code> if this AABB and the ray intersect; <code>false</code> otherwise\n-     */\n-    public boolean intersectsRay(Rayf ray) {\n-        return Intersectionf.testRayAab(ray, aabb);\n+    public Optional<BlockRegion> intersect(BlockRegionc other) {\n+        return this.intersect(other, this);\n     }\n \n-    /**\n-     * Determine whether the undirected line segment with the end points <code>(p0X, p0Y, p0Z)</code> and <code>(p1X,\n-     * p1Y, p1Z)</code> intersects this AABB, and return the values of the parameter <i>t</i> in the ray equation\n-     * <i>p(t) = origin + p0 * (p1 - p0)</i> of the near and far point of intersection.\n-     * <p>\n-     * This method returns <code>true</code> for a line segment whose either end point lies inside this AABB.\n-     * <p>\n-     * Reference: <a href=\"https://dl.acm.org/citation.cfm?id=1198748\">An Efficient and Robust Ray\u2013Box Intersection</a>\n-     *\n-     * @param p0X the x coordinate of the line segment's first end point\n-     * @param p0Y the y coordinate of the line segment's first end point\n-     * @param p0Z the z coordinate of the line segment's first end point\n-     * @param p1X the x coordinate of the line segment's second end point\n-     * @param p1Y the y coordinate of the line segment's second end point\n-     * @param p1Z the z coordinate of the line segment's second end point\n-     * @param result a vector which will hold the resulting values of the parameter\n-     *         <i>t</i> in the ray equation <i>p(t) = p0 + t * (p1 - p0)</i> of the near and far point of intersection\n-     *         iff the line segment intersects this AABB\n-     * @return {@link Intersectionf#INSIDE} if the line segment lies completely inside of this AABB; or {@link\n-     *         Intersectionf#OUTSIDE} if the line segment lies completely outside of this AABB; or {@link\n-     *         Intersectionf#ONE_INTERSECTION} if one of the end points of the line segment lies inside of this AABB; or\n-     *         {@link Intersectionf#TWO_INTERSECTION} if the line segment intersects two sides of this AABB or lies on\n-     *         an edge or a side of this AABB\n-     */\n-    public int intersectLineSegment(float p0X, float p0Y, float p0Z, float p1X, float p1Y, float p1Z, Vector2f result) {\n-        return Intersectionf.intersectLineSegmentAab(p0X, p0Y, p0Z, p1X, p1Y, p1Z, aabb.minX, aabb.minY, aabb.minZ,\n-                aabb.maxX, aabb.maxY, aabb.maxZ, result);\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockRegion translate(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = this.minX + x;\n+        dest.minY = this.minY + y;\n+        dest.minZ = this.minZ + z;\n+        dest.maxX = this.maxX + x;\n+        dest.maxY = this.maxY + y;\n+        dest.maxZ = this.maxZ + z;\n+        return dest;\n     }\n \n-    /**\n-     * Determine whether the given undirected line segment intersects this AABB, and return the values of the parameter\n-     * <i>t</i> in the ray equation\n-     * <i>p(t) = origin + p0 * (p1 - p0)</i> of the near and far point of intersection.\n-     * <p>\n-     * This method returns <code>true</code> for a line segment whose either end point lies inside this AABB.\n-     * <p>\n-     * Reference: <a href=\"https://dl.acm.org/citation.cfm?id=1198748\">An Efficient and Robust Ray\u2013Box Intersection</a>\n-     *\n-     * @param lineSegment the line segment\n-     * @param result a vector which will hold the resulting values of the parameter\n-     *         <i>t</i> in the ray equation <i>p(t) = p0 + t * (p1 - p0)</i> of the near and far point of intersection\n-     *         iff the line segment intersects this AABB\n-     * @return {@link Intersectionf#INSIDE} if the line segment lies completely inside of this AABB; or {@link\n-     *         Intersectionf#OUTSIDE} if the line segment lies completely outside of this AABB; or {@link\n-     *         Intersectionf#ONE_INTERSECTION} if one of the end points of the line segment lies inside of this AABB; or\n-     *         {@link Intersectionf#TWO_INTERSECTION} if the line segment intersects two sides of this AABB or lies on\n-     *         an edge or a side of this AABB\n-     */\n-    public int intersectLineSegment(LineSegmentf lineSegment, Vector2f result) {\n-        return Intersectionf.intersectLineSegmentAab(lineSegment, aabb, result);\n+    public BlockRegion translate(int x, int y, int z) {\n+        return this.translate(x, y, z, this);\n     }\n \n-    /**\n-     * Check whether <code>this</code> BlockRegion represents a valid BlockRegion.\n-     *\n-     * @return <code>true</code> iff this BlockRegion is valid; <code>false</code> otherwise\n-     */\n-    public boolean isValid() {\n-        return aabb.isValid();\n+    public BlockRegion translate(Vector3ic vec) {\n+        return translate(vec.x(), vec.y(), vec.z());\n     }\n \n-    /**\n-     * calculate the BlockRegion that is intersected between another region\n-     *\n-     * @param other the other BlockRegion\n-     * @param dest holds the result\n-     * @return dest\n-     */\n-    public BlockRegion intersection(BlockRegion other, BlockRegion dest) {\n-        this.aabb.intersection(other.aabb, dest.aabb);\n-        return dest;\n+    public BlockRegion setPosition(int x, int y, int z) {\n+        return this.setPosition(x, y, z, this);\n     }\n \n-    /**\n-     * Adds extend for each face of a BlockRegion.\n-     *\n-     * @param extent extents to grow each face\n-     * @param dest holds the result\n-     * @return dest\n-     */\n-    public BlockRegion addExtents(int extent, BlockRegion dest) {\n-        return addExtents(extent, extent, extent, dest);\n+    public BlockRegion setPosition(Vector3ic pos) {\n+        return this.setPosition(pos.x(), pos.y(), pos.z(), this);\n     }\n \n-    /**\n-     * Adds extend for each face of a BlockRegion.\n-     *\n-     * @param extentX the x coordinate to grow the extents\n-     * @param extentY the y coordinate to grow the extents\n-     * @param extentZ the z coordinate to grow the extents\n-     * @return this\n-     */\n-    public BlockRegion addExtents(int extentX, int extentY, int extentZ) {\n-        return addExtents(extentX, extentY, extentZ, this);\n+    @Override\n+    public BlockRegion expand(int dx, int dy, int dz, BlockRegion dest) {\n+        return dest.set(this.minX - dx, this.minY - dy, this.minZ - dz,\n+                this.maxX + dx, this.maxY + dy, this.maxZ + dz);\n     }\n \n-    /**\n-     * Adds extend for each face of a BlockRegion.\n-     *\n-     * @param extents extents to grow each face\n-     * @param dest holds the result\n-     * @return dest\n-     */\n-    public BlockRegion addExtents(Vector3ic extents, BlockRegion dest) {\n-        return addExtents(extents.x(), extents.y(), extents.z(), dest);\n+    public BlockRegion expand(int dx, int dy, int dz) {\n+        return this.expand(dx, dy, dz, this);\n     }\n \n-    /**\n-     * Adds extend for each face of a BlockRegion.\n-     *\n-     * @param extents the coordinates to grow the extents\n-     * @return this\n-     */\n-    public BlockRegion addExtents(Vector3ic extents) {\n-        return addExtents(extents.x(), extents.y(), extents.z(), this);\n+    public BlockRegion expand(Vector3ic extents) {\n+        return expand(extents.x(), extents.y(), extents.z());\n     }\n \n-    /**\n-     * Adds extend for each face of a BlockRegion\n-     *\n-     * @param extentX the x coordinate to grow the extents\n-     * @param extentY the y coordinate to grow the extents\n-     * @param extentZ the z coordinate to grow the extents\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockRegion addExtents(int extentX, int extentY, int extentZ, BlockRegion dest) {\n-        dest.aabb.minX = this.aabb.minX - extentX;\n-        dest.aabb.minY = this.aabb.minY - extentY;\n-        dest.aabb.minZ = this.aabb.minZ - extentZ;\n-\n-        dest.aabb.maxX = this.aabb.maxX + extentX;\n-        dest.aabb.maxY = this.aabb.maxY + extentY;\n-        dest.aabb.maxZ = this.aabb.maxZ + extentZ;\n+    // -- transform --------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockRegion transform(Matrix4fc m, BlockRegion dest) {\n+        Preconditions.checkArgument(m.isAffine());\n+        float dx = maxX - minX;\n+        float dy = maxY - minY;\n+        float dz = maxZ - minZ;\n+        float minx = Float.POSITIVE_INFINITY;\n+        float miny = Float.POSITIVE_INFINITY;\n+        float minz = Float.POSITIVE_INFINITY;\n+        float maxx = Float.NEGATIVE_INFINITY;\n+        float maxy = Float.NEGATIVE_INFINITY;\n+        float maxz = Float.NEGATIVE_INFINITY;\n+        for (int i = 0; i < 8; i++) {\n+            float x = minX + (i & 1) * dx;\n+            float y = minY + (i >> 1 & 1) * dy;\n+            float z = minZ + (i >> 2 & 1) * dz;\n+            float tx = m.m00() * x + m.m10() * y + m.m20() * z + m.m30();\n+            float ty = m.m01() * x + m.m11() * y + m.m21() * z + m.m31();\n+            float tz = m.m02() * x + m.m12() * y + m.m22() * z + m.m32();\n+            minx = Math.min(tx, minx);\n+            miny = Math.min(ty, miny);\n+            minz = Math.min(tz, minz);\n+            maxx = Math.max(tx, maxx);\n+            maxy = Math.max(ty, maxy);\n+            maxz = Math.max(tz, maxz);\n+        }\n+        dest.minX = Math.roundUsing(minx, RoundingMode.FLOOR);\n+        dest.minY = Math.roundUsing(miny, RoundingMode.FLOOR);\n+        dest.minZ = Math.roundUsing(minz, RoundingMode.FLOOR);\n+        dest.maxX = Math.roundUsing(maxx, RoundingMode.CEILING);\n+        dest.maxY = Math.roundUsing(maxy, RoundingMode.CEILING);\n+        dest.maxZ = Math.roundUsing(maxz, RoundingMode.CEILING);\n+\n         return dest;\n     }\n \n-    /**\n-     * Adds extend for each face of a BlockRegion.\n-     *\n-     * @param extentX the x coordinate to grow the extents\n-     * @param extentY the y coordinate to grow the extents\n-     * @param extentZ the z coordinate to grow the extents\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockRegion addExtents(float extentX, float extentY, float extentZ, BlockRegion dest) {\n-        dest.aabb.minX = Math.roundUsing(this.aabb.minX - extentX, RoundingMode.FLOOR);\n-        dest.aabb.minY = Math.roundUsing(this.aabb.minY - extentY, RoundingMode.FLOOR);\n-        dest.aabb.minZ = Math.roundUsing(this.aabb.minZ - extentZ, RoundingMode.FLOOR);\n-\n-        dest.aabb.maxX = Math.roundUsing(this.aabb.maxX + extentX, RoundingMode.CEILING);\n-        dest.aabb.maxY = Math.roundUsing(this.aabb.maxY + extentY, RoundingMode.CEILING);\n-        dest.aabb.maxZ = Math.roundUsing(this.aabb.maxZ + extentZ, RoundingMode.CEILING);\n-        return dest;\n+    public BlockRegion transform(Matrix4fc m) {\n+        return transform(m, this);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNzc2MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541917760", "bodyText": "The docstring needs to be adjusted to the different method semantics.", "author": "skaldarnar", "createdAt": "2020-12-13T12:41:39Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegions.java", "diffHunk": "@@ -16,6 +16,25 @@\n     private BlockRegions() {\n     }\n \n+    /**\n+     * Creates a new region spanning the smallest axis-aligned bounding box (AABB) containing both, min and max.\n+     * <p>\n+     * Note that each component of {@code min} should be smaller or equal to the respective component in {@code max}. If\n+     * a dimension of {@code min} is greater than the respective dimension of {@code max} the resulting block region\n+     * will have a size of 0 along that dimension.\n+     * <p>\n+     * Consider using {@link #encompassing(Vector3ic...)} as an alternative.\n+     *\n+     * @return new block region\n+     */", "originalCommit": "f18fe748926d91de85b40615ff2d573ca1a5d01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkyMzkwMQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541923901", "bodyText": "We already have that method added by another PR.\nSo let's drop this here and fix the docstring for the one that's already there below.", "author": "jdrueckert", "createdAt": "2020-12-13T13:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNzc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxOTAxNw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r546219017", "bodyText": "I removed the duplicate method, but the docstring of the existing one still needs adjusting.", "author": "jdrueckert", "createdAt": "2020-12-19T09:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNzc2MA=="}], "type": "inlineReview", "revised_code": {"commit": "cb8f168975fec55625b17257d173ce24d07d1137", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegions.java b/engine/src/main/java/org/terasology/world/block/BlockRegions.java\nindex 0145bd73f..85d6e0af2 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegions.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegions.java\n\n@@ -16,25 +16,6 @@\n     private BlockRegions() {\n     }\n \n-    /**\n-     * Creates a new region spanning the smallest axis-aligned bounding box (AABB) containing both, min and max.\n-     * <p>\n-     * Note that each component of {@code min} should be smaller or equal to the respective component in {@code max}. If\n-     * a dimension of {@code min} is greater than the respective dimension of {@code max} the resulting block region\n-     * will have a size of 0 along that dimension.\n-     * <p>\n-     * Consider using {@link #encompassing(Vector3ic...)} as an alternative.\n-     *\n-     * @return new block region\n-     */\n-    public static BlockRegion createFromMinAndSize(Vector3ic min, Vector3ic size) {\n-        return new BlockRegion().setMin(min).setMax(\n-            min.x() + size.x() - 1,\n-            min.y() + size.y() - 1,\n-            min.z() + size.z() - 1\n-        );\n-    }\n-\n     /**\n      * Creates a new region spanning the smallest axis-aligned bounding box (AABB) containing both, min and max.\n      * <p>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkyMjI4OQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541922289", "bodyText": "The chunk position is a single integer - what does this position mean?", "author": "skaldarnar", "createdAt": "2020-12-13T13:08:31Z", "path": "engine/src/main/java/org/terasology/world/chunks/Chunks.java", "diffHunk": "@@ -0,0 +1,306 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.chunks;\n+\n+import org.joml.Math;\n+import org.joml.RoundingMode;\n+import org.joml.Vector3fc;\n+import org.joml.Vector3i;\n+import org.joml.Vector3ic;\n+import org.terasology.module.sandbox.API;\n+import org.terasology.world.block.BlockRegion;\n+import org.terasology.world.block.BlockRegions;\n+\n+@API\n+public final class Chunks {\n+    public static final int SIZE_X = 32;\n+    public static final int SIZE_Y = 64;\n+    public static final int SIZE_Z = 32;\n+\n+    public static final int INNER_CHUNK_POS_FILTER_X = Integer.highestOneBit(SIZE_X) - 1;\n+    public static final int INNER_CHUNK_POS_FILTER_Y = Integer.highestOneBit(SIZE_Y) - 1;\n+    public static final int INNER_CHUNK_POS_FILTER_Z = Integer.highestOneBit(SIZE_Z) - 1;\n+\n+    public static final int POWER_X = Integer.numberOfTrailingZeros(SIZE_X);\n+    public static final int POWER_Y = Integer.numberOfTrailingZeros(SIZE_Y);\n+    public static final int POWER_Z = Integer.numberOfTrailingZeros(SIZE_Z);\n+\n+    public static final byte MAX_LIGHT = 0x0f; // max light for a light source 0-15\n+    public static final byte MAX_SUNLIGHT = 0x0f; // max sunlight for sunlight bounded 0-15\n+    public static final byte MAX_SUNLIGHT_REGEN = 63;\n+    public static final byte SUNLIGHT_REGEN_THRESHOLD = 48;\n+\n+    public static final Vector3ic CHUNK_POWER = new Vector3i(POWER_X, POWER_Y, POWER_Z);\n+    public static final Vector3ic CHUNK_SIZE = new Vector3i(SIZE_X, SIZE_Y, SIZE_Z);\n+    public static final Vector3ic INNER_CHUNK_POS_FILTER = new org.joml.Vector3i(INNER_CHUNK_POS_FILTER_X, INNER_CHUNK_POS_FILTER_Y, INNER_CHUNK_POS_FILTER_Z);\n+    public static final BlockRegion CHUNK_REGION = BlockRegions.createFromMinAndSize(new Vector3i(), CHUNK_SIZE);\n+\n+    public static final Vector3ic LOCAL_REGION_EXTENTS = new Vector3i(1, 1, 1);\n+\n+    private Chunks() {\n+    }\n+\n+    /**\n+     * Returns the chunk position of a given coordinate.", "originalCommit": "f18fe748926d91de85b40615ff2d573ca1a5d01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkyMjc4MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541922781", "bodyText": "And should this method ever be used directly (with a different chunkPower than the one from the constants)?", "author": "skaldarnar", "createdAt": "2020-12-13T13:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkyMjI4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "78df35848f7d3aec540172fa775cb0537b716e33", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/chunks/Chunks.java b/engine/src/main/java/org/terasology/world/chunks/Chunks.java\nindex 1cdac6986..3dcf5ccf1 100644\n--- a/engine/src/main/java/org/terasology/world/chunks/Chunks.java\n+++ b/engine/src/main/java/org/terasology/world/chunks/Chunks.java\n\n@@ -42,7 +42,7 @@ private Chunks() {\n     }\n \n     /**\n-     * Returns the chunk position of a given coordinate.\n+     * Returns the chunk coordinate given the position and the chunk power.\n      *\n      * @param val The coordinate of the block\n      * @param chunkPower the size of the chunk in powers of 2\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkyMzEyMg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r541923122", "bodyText": "This method does not take any arguments to set the size of a chunk... Does this method actually do the following:\n\nreturns the position of the chunk that encompasses the given world position", "author": "skaldarnar", "createdAt": "2020-12-13T13:13:05Z", "path": "engine/src/main/java/org/terasology/world/chunks/Chunks.java", "diffHunk": "@@ -0,0 +1,306 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.chunks;\n+\n+import org.joml.Math;\n+import org.joml.RoundingMode;\n+import org.joml.Vector3fc;\n+import org.joml.Vector3i;\n+import org.joml.Vector3ic;\n+import org.terasology.module.sandbox.API;\n+import org.terasology.world.block.BlockRegion;\n+import org.terasology.world.block.BlockRegions;\n+\n+@API\n+public final class Chunks {\n+    public static final int SIZE_X = 32;\n+    public static final int SIZE_Y = 64;\n+    public static final int SIZE_Z = 32;\n+\n+    public static final int INNER_CHUNK_POS_FILTER_X = Integer.highestOneBit(SIZE_X) - 1;\n+    public static final int INNER_CHUNK_POS_FILTER_Y = Integer.highestOneBit(SIZE_Y) - 1;\n+    public static final int INNER_CHUNK_POS_FILTER_Z = Integer.highestOneBit(SIZE_Z) - 1;\n+\n+    public static final int POWER_X = Integer.numberOfTrailingZeros(SIZE_X);\n+    public static final int POWER_Y = Integer.numberOfTrailingZeros(SIZE_Y);\n+    public static final int POWER_Z = Integer.numberOfTrailingZeros(SIZE_Z);\n+\n+    public static final byte MAX_LIGHT = 0x0f; // max light for a light source 0-15\n+    public static final byte MAX_SUNLIGHT = 0x0f; // max sunlight for sunlight bounded 0-15\n+    public static final byte MAX_SUNLIGHT_REGEN = 63;\n+    public static final byte SUNLIGHT_REGEN_THRESHOLD = 48;\n+\n+    public static final Vector3ic CHUNK_POWER = new Vector3i(POWER_X, POWER_Y, POWER_Z);\n+    public static final Vector3ic CHUNK_SIZE = new Vector3i(SIZE_X, SIZE_Y, SIZE_Z);\n+    public static final Vector3ic INNER_CHUNK_POS_FILTER = new org.joml.Vector3i(INNER_CHUNK_POS_FILTER_X, INNER_CHUNK_POS_FILTER_Y, INNER_CHUNK_POS_FILTER_Z);\n+    public static final BlockRegion CHUNK_REGION = BlockRegions.createFromMinAndSize(new Vector3i(), CHUNK_SIZE);\n+\n+    public static final Vector3ic LOCAL_REGION_EXTENTS = new Vector3i(1, 1, 1);\n+\n+    private Chunks() {\n+    }\n+\n+    /**\n+     * Returns the chunk position of a given coordinate.\n+     *\n+     * @param val The coordinate of the block\n+     * @param chunkPower the size of the chunk in powers of 2\n+     * @return The coordinate of the chunk\n+     */\n+    public static int toChunkPos(int val, int chunkPower) {\n+        return (val >> chunkPower);\n+    }\n+\n+    /**\n+     * The position of the chunk given the coordinate and size of chunk in powers of 2.\n+     * This uses the default power {@link #POWER_X}.\n+     *\n+     * @param x the x component\n+     * @return The coordinate of the chunk\n+     */\n+    public static int toChunkPosX(int x) {\n+        return toChunkPos(x, CHUNK_POWER.x());\n+    }\n+\n+    /**\n+     * The position of the chunk given the coordinate and size of chunk in powers of 2.\n+     * This uses the default power {@link #POWER_Y}\n+     *\n+     * @param y the y component\n+     * @return The coordinate of the chunk\n+     */\n+    public static int toChunkPosY(int y) {\n+        return toChunkPos(y, CHUNK_POWER.y());\n+    }\n+\n+    /**\n+     * The position of the chunk given the coordinate and size of chunk in powers of 2.\n+     * This uses the default power {@link #POWER_Z}\n+     *\n+     * @param z the z component\n+     * @return The coordinate of the chunk\n+     */\n+    public static int toChunkPosZ(int z) {\n+        return toChunkPos(z, CHUNK_POWER.z());\n+    }\n+\n+\n+    /**\n+     * The position of the chunk given the coordinate and size of chunk in powers of 2.", "originalCommit": "f18fe748926d91de85b40615ff2d573ca1a5d01e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "78df35848f7d3aec540172fa775cb0537b716e33", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/chunks/Chunks.java b/engine/src/main/java/org/terasology/world/chunks/Chunks.java\nindex 1cdac6986..3dcf5ccf1 100644\n--- a/engine/src/main/java/org/terasology/world/chunks/Chunks.java\n+++ b/engine/src/main/java/org/terasology/world/chunks/Chunks.java\n\n@@ -42,7 +42,7 @@ private Chunks() {\n     }\n \n     /**\n-     * Returns the chunk position of a given coordinate.\n+     * Returns the chunk coordinate given the position and the chunk power.\n      *\n      * @param val The coordinate of the block\n      * @param chunkPower the size of the chunk in powers of 2\n"}}, {"oid": "4151ca2558ae255ac8ffbdc83cedd8b321c63380", "url": "https://github.com/MovingBlocks/Terasology/commit/4151ca2558ae255ac8ffbdc83cedd8b321c63380", "message": "Merge branch 'develop' into feature/chunk-standardization", "committedDate": "2020-12-13T13:14:34Z", "type": "commit"}, {"oid": "1186eadd4ff7aa733d258eb5b7dad1c1f14b95ed", "url": "https://github.com/MovingBlocks/Terasology/commit/1186eadd4ff7aa733d258eb5b7dad1c1f14b95ed", "message": "correct test and fix formatting", "committedDate": "2020-12-14T03:17:15Z", "type": "commit"}, {"oid": "013d7b8e1f4225db39b9b51c9b2acce0f199400b", "url": "https://github.com/MovingBlocks/Terasology/commit/013d7b8e1f4225db39b9b51c9b2acce0f199400b", "message": "Merge branch 'feature/chunk-standardization' of github.com:pollend/Terasology into feature/chunk-standardization", "committedDate": "2020-12-14T03:17:48Z", "type": "commit"}, {"oid": "7576b3e602ac1abfc3bcbeb705e32c130529a042", "url": "https://github.com/MovingBlocks/Terasology/commit/7576b3e602ac1abfc3bcbeb705e32c130529a042", "message": "Merge branch 'develop' into feature/chunk-standardization", "committedDate": "2020-12-19T09:32:46Z", "type": "commit"}, {"oid": "cb8f168975fec55625b17257d173ce24d07d1137", "url": "https://github.com/MovingBlocks/Terasology/commit/cb8f168975fec55625b17257d173ce24d07d1137", "message": "chore: remove duplicate method", "committedDate": "2020-12-19T09:52:19Z", "type": "commit"}, {"oid": "0082e0d68163ec852624660434bc5dfa5d812f93", "url": "https://github.com/MovingBlocks/Terasology/commit/0082e0d68163ec852624660434bc5dfa5d812f93", "message": "correct assertions in BlockRegionTest for face", "committedDate": "2020-12-19T16:58:03Z", "type": "commit"}, {"oid": "bbc0efe90e02d01aa16324136dbbb7fa2dd35104", "url": "https://github.com/MovingBlocks/Terasology/commit/bbc0efe90e02d01aa16324136dbbb7fa2dd35104", "message": "Merge branch 'feature/chunk-standardization' of github.com:pollend/Terasology into feature/chunk-standardization", "committedDate": "2020-12-19T16:58:50Z", "type": "commit"}, {"oid": "78df35848f7d3aec540172fa775cb0537b716e33", "url": "https://github.com/MovingBlocks/Terasology/commit/78df35848f7d3aec540172fa775cb0537b716e33", "message": "update description for toChunkPos", "committedDate": "2020-12-19T17:32:46Z", "type": "commit"}, {"oid": "21317aa8e5c6c68724b62ddf9996a09a3d3a5b8c", "url": "https://github.com/MovingBlocks/Terasology/commit/21317aa8e5c6c68724b62ddf9996a09a3d3a5b8c", "message": "Merge remote-tracking branch 'upstream/develop' into feature/chunk-standardization", "committedDate": "2020-12-26T19:20:57Z", "type": "commit"}, {"oid": "fecd302cabf14edcacc726489c3de8b24e440e4c", "url": "https://github.com/MovingBlocks/Terasology/commit/fecd302cabf14edcacc726489c3de8b24e440e4c", "message": "add test and restore misc", "committedDate": "2020-12-26T19:35:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA0MzY2Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4306#discussion_r549043662", "bodyText": "This should expose the constant region:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final BlockRegion CHUNK_REGION = new BlockRegion(new Vector3i()).setSize(CHUNK_SIZE);\n          \n          \n            \n                public static final BlockRegionc CHUNK_REGION = new BlockRegion(0, 0, 0).setSize(CHUNK_SIZE);", "author": "skaldarnar", "createdAt": "2020-12-26T23:48:19Z", "path": "engine/src/main/java/org/terasology/world/chunks/Chunks.java", "diffHunk": "@@ -0,0 +1,305 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.chunks;\n+\n+import org.joml.Math;\n+import org.joml.RoundingMode;\n+import org.joml.Vector3fc;\n+import org.joml.Vector3i;\n+import org.joml.Vector3ic;\n+import org.terasology.module.sandbox.API;\n+import org.terasology.world.block.BlockRegion;\n+\n+@API\n+public final class Chunks {\n+    public static final int SIZE_X = 32;\n+    public static final int SIZE_Y = 64;\n+    public static final int SIZE_Z = 32;\n+\n+    public static final int INNER_CHUNK_POS_FILTER_X = Integer.highestOneBit(SIZE_X) - 1;\n+    public static final int INNER_CHUNK_POS_FILTER_Y = Integer.highestOneBit(SIZE_Y) - 1;\n+    public static final int INNER_CHUNK_POS_FILTER_Z = Integer.highestOneBit(SIZE_Z) - 1;\n+\n+    public static final int POWER_X = Integer.numberOfTrailingZeros(SIZE_X);\n+    public static final int POWER_Y = Integer.numberOfTrailingZeros(SIZE_Y);\n+    public static final int POWER_Z = Integer.numberOfTrailingZeros(SIZE_Z);\n+\n+    public static final byte MAX_LIGHT = 0x0f; // max light for a light source 0-15\n+    public static final byte MAX_SUNLIGHT = 0x0f; // max sunlight for sunlight bounded 0-15\n+    public static final byte MAX_SUNLIGHT_REGEN = 63;\n+    public static final byte SUNLIGHT_REGEN_THRESHOLD = 48;\n+\n+    public static final Vector3ic CHUNK_POWER = new Vector3i(POWER_X, POWER_Y, POWER_Z);\n+    public static final Vector3ic CHUNK_SIZE = new Vector3i(SIZE_X, SIZE_Y, SIZE_Z);\n+    public static final Vector3ic INNER_CHUNK_POS_FILTER = new org.joml.Vector3i(INNER_CHUNK_POS_FILTER_X, INNER_CHUNK_POS_FILTER_Y, INNER_CHUNK_POS_FILTER_Z);\n+    public static final BlockRegion CHUNK_REGION = new BlockRegion(new Vector3i()).setSize(CHUNK_SIZE);", "originalCommit": "fecd302cabf14edcacc726489c3de8b24e440e4c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9dbf88fab1ab6a04fb0e5f3040c0e6ed68746dc", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/chunks/Chunks.java b/engine/src/main/java/org/terasology/world/chunks/Chunks.java\nindex 150e7ab26..79e253564 100644\n--- a/engine/src/main/java/org/terasology/world/chunks/Chunks.java\n+++ b/engine/src/main/java/org/terasology/world/chunks/Chunks.java\n\n@@ -33,7 +33,7 @@\n     public static final Vector3ic CHUNK_POWER = new Vector3i(POWER_X, POWER_Y, POWER_Z);\n     public static final Vector3ic CHUNK_SIZE = new Vector3i(SIZE_X, SIZE_Y, SIZE_Z);\n     public static final Vector3ic INNER_CHUNK_POS_FILTER = new org.joml.Vector3i(INNER_CHUNK_POS_FILTER_X, INNER_CHUNK_POS_FILTER_Y, INNER_CHUNK_POS_FILTER_Z);\n-    public static final BlockRegion CHUNK_REGION = new BlockRegion(new Vector3i()).setSize(CHUNK_SIZE);\n+    public static final BlockRegionc CHUNK_REGION = new BlockRegion(0, 0, 0).setSize(CHUNK_SIZE);\n \n     public static final Vector3ic LOCAL_REGION_EXTENTS = new Vector3i(1, 1, 1);\n \n"}}, {"oid": "b9dbf88fab1ab6a04fb0e5f3040c0e6ed68746dc", "url": "https://github.com/MovingBlocks/Terasology/commit/b9dbf88fab1ab6a04fb0e5f3040c0e6ed68746dc", "message": "Update engine/src/main/java/org/terasology/world/chunks/Chunks.java\n\nCo-authored-by: Tobias Nett <skaldarnar@googlemail.com>", "committedDate": "2020-12-27T00:16:04Z", "type": "commit"}, {"oid": "e0d99e396711ac46db8b68b3108ecb9e5a9e41b5", "url": "https://github.com/MovingBlocks/Terasology/commit/e0d99e396711ac46db8b68b3108ecb9e5a9e41b5", "message": "migrate logic", "committedDate": "2020-12-27T00:23:57Z", "type": "commit"}, {"oid": "f0c68ae95f4e074c7e60d75116b489cb95aed3b2", "url": "https://github.com/MovingBlocks/Terasology/commit/f0c68ae95f4e074c7e60d75116b489cb95aed3b2", "message": "Merge branch 'feature/chunk-standardization' of github.com:pollend/Terasology into feature/chunk-standardization", "committedDate": "2020-12-27T00:24:46Z", "type": "commit"}, {"oid": "85c3f368c12b5e12548a87810fe2d5731d96d21b", "url": "https://github.com/MovingBlocks/Terasology/commit/85c3f368c12b5e12548a87810fe2d5731d96d21b", "message": "Merge branch 'develop' into feature/chunk-standardization", "committedDate": "2020-12-27T00:25:11Z", "type": "commit"}, {"oid": "9cb084b67f920e1c315855609020c13ee1e9fb23", "url": "https://github.com/MovingBlocks/Terasology/commit/9cb084b67f920e1c315855609020c13ee1e9fb23", "message": "add import", "committedDate": "2020-12-27T19:22:45Z", "type": "commit"}, {"oid": "60023d3dd57b6677c8c8150865901be150bd7536", "url": "https://github.com/MovingBlocks/Terasology/commit/60023d3dd57b6677c8c8150865901be150bd7536", "message": "Merge branch 'feature/chunk-standardization' of github.com:pollend/Terasology into feature/chunk-standardization", "committedDate": "2020-12-27T19:23:19Z", "type": "commit"}, {"oid": "43c6bf62424e8efe6e81c4a895f2556c69aad40f", "url": "https://github.com/MovingBlocks/Terasology/commit/43c6bf62424e8efe6e81c4a895f2556c69aad40f", "message": "Merge branch 'develop' into feature/chunk-standardization", "committedDate": "2020-12-30T17:48:20Z", "type": "commit"}, {"oid": "9d0c7d786221b353a1bede2fae60c61efd00377b", "url": "https://github.com/MovingBlocks/Terasology/commit/9d0c7d786221b353a1bede2fae60c61efd00377b", "message": "Merge branch 'develop' into feature/chunk-standardization", "committedDate": "2020-12-30T19:04:49Z", "type": "commit"}, {"oid": "7a6ab01c028923e42addce8b201890b31b9ed5e6", "url": "https://github.com/MovingBlocks/Terasology/commit/7a6ab01c028923e42addce8b201890b31b9ed5e6", "message": "refactor(BlockRegion): rename `blockFace` >>> `face`", "committedDate": "2020-12-30T19:20:10Z", "type": "commit"}]}