{"pr_number": 4326, "pr_title": "refactor!(BlockRegion): full API overhaul", "pr_createdAt": "2020-12-20T19:52:13Z", "pr_url": "https://github.com/MovingBlocks/Terasology/pull/4326", "timeline": [{"oid": "f4660f12ad3920788a4451910c8642cc2d04c06f", "url": "https://github.com/MovingBlocks/Terasology/commit/f4660f12ad3920788a4451910c8642cc2d04c06f", "message": "chore(BlockRegions): rename methods for creation; add JavaDoc", "committedDate": "2020-12-20T20:19:22Z", "type": "commit"}, {"oid": "a3008773516cfbbfc9ae2b0f9a63284a5ee5cbb0", "url": "https://github.com/MovingBlocks/Terasology/commit/a3008773516cfbbfc9ae2b0f9a63284a5ee5cbb0", "message": "doc(BlockRegion): docs for constructors", "committedDate": "2020-12-20T20:19:23Z", "type": "commit"}, {"oid": "1fb8b0d861b6b1afba587698fa28c5df9ad01ca3", "url": "https://github.com/MovingBlocks/Terasology/commit/1fb8b0d861b6b1afba587698fa28c5df9ad01ca3", "message": "doc(BlockRegion): docs for copy-setters and min", "committedDate": "2020-12-20T20:19:24Z", "type": "commit"}, {"oid": "8d4395c4c63b53e49b3eb87de212ee55b8682880", "url": "https://github.com/MovingBlocks/Terasology/commit/8d4395c4c63b53e49b3eb87de212ee55b8682880", "message": "doc(BlockRegion): docs for max", "committedDate": "2020-12-20T20:19:25Z", "type": "commit"}, {"oid": "2b1498fa6b6a17a1cb16ebc74e30410a4398518a", "url": "https://github.com/MovingBlocks/Terasology/commit/2b1498fa6b6a17a1cb16ebc74e30410a4398518a", "message": "test(BlockRegion): size", "committedDate": "2020-12-20T20:19:25Z", "type": "commit"}, {"oid": "cb4ff81103d4e378e11ce00b749ccf18d4860264", "url": "https://github.com/MovingBlocks/Terasology/commit/cb4ff81103d4e378e11ce00b749ccf18d4860264", "message": "doc(BlockRegion): docs for size", "committedDate": "2020-12-20T20:19:26Z", "type": "commit"}, {"oid": "50a6c997b83bbdcc7896579d970e0ccb1c074770", "url": "https://github.com/MovingBlocks/Terasology/commit/50a6c997b83bbdcc7896579d970e0ccb1c074770", "message": "doc(BlockRegion): docs for getBounds and center", "committedDate": "2020-12-20T20:19:27Z", "type": "commit"}, {"oid": "15b1f09bf2b9829571de34cff4a5d2fd58e19a9c", "url": "https://github.com/MovingBlocks/Terasology/commit/15b1f09bf2b9829571de34cff4a5d2fd58e19a9c", "message": "doc(BlockRegion): docs for union", "committedDate": "2020-12-20T20:19:28Z", "type": "commit"}, {"oid": "07a9ffc1a5d231840e0a07221084b6a7a0b8cefd", "url": "https://github.com/MovingBlocks/Terasology/commit/07a9ffc1a5d231840e0a07221084b6a7a0b8cefd", "message": "doc(BlockRegion): docs for intersect", "committedDate": "2020-12-20T20:19:29Z", "type": "commit"}, {"oid": "07a9ffc1a5d231840e0a07221084b6a7a0b8cefd", "url": "https://github.com/MovingBlocks/Terasology/commit/07a9ffc1a5d231840e0a07221084b6a7a0b8cefd", "message": "doc(BlockRegion): docs for intersect", "committedDate": "2020-12-20T20:19:29Z", "type": "forcePushed"}, {"oid": "23fc48b6c5cf2479ec042c74311e6b903d2fd790", "url": "https://github.com/MovingBlocks/Terasology/commit/23fc48b6c5cf2479ec042c74311e6b903d2fd790", "message": "doc(BlockRegion): general formatting changes", "committedDate": "2020-12-20T20:36:39Z", "type": "commit"}, {"oid": "1b0c672634e1732f31be51b94f1603e5e9799c2e", "url": "https://github.com/MovingBlocks/Terasology/commit/1b0c672634e1732f31be51b94f1603e5e9799c2e", "message": "doc(BlockRegion): docs for `translate`", "committedDate": "2020-12-20T20:41:40Z", "type": "commit"}, {"oid": "b092ae047e829c7e6a4651dc7f40df2ac6128e13", "url": "https://github.com/MovingBlocks/Terasology/commit/b092ae047e829c7e6a4651dc7f40df2ac6128e13", "message": "doc(BlockRegion): docs for `extend`", "committedDate": "2020-12-20T20:48:49Z", "type": "commit"}, {"oid": "e4eb7b525a4bf77e0e9c05f88034064e837d0453", "url": "https://github.com/MovingBlocks/Terasology/commit/e4eb7b525a4bf77e0e9c05f88034064e837d0453", "message": "doc(BlockRegion): docs for `transform`", "committedDate": "2020-12-20T20:53:13Z", "type": "commit"}, {"oid": "8dd65816f2a39b33106a33a793a20807a7505e3b", "url": "https://github.com/MovingBlocks/Terasology/commit/8dd65816f2a39b33106a33a793a20807a7505e3b", "message": "doc(BlockRegion): docs for `contains`", "committedDate": "2020-12-20T21:00:43Z", "type": "commit"}, {"oid": "a698a2a11b3289a5469f143b2477a519ff803c26", "url": "https://github.com/MovingBlocks/Terasology/commit/a698a2a11b3289a5469f143b2477a519ff803c26", "message": "refactor!(BlockRegion): name all `contains` check consistently\n\nBREAKING CHANGE: checks for blocks coordinates and world coordinates where previously separated by names as we assumed their semantics to be different.\n\nThis was changed, e.g., the check returns the same result when used with integer values.", "committedDate": "2020-12-20T21:04:59Z", "type": "commit"}, {"oid": "0841d8e2f39b90422e5cb7b6daf02eef05da93ba", "url": "https://github.com/MovingBlocks/Terasology/commit/0841d8e2f39b90422e5cb7b6daf02eef05da93ba", "message": "doc(BlockRegion): small adjustments for `intersects...` checks", "committedDate": "2020-12-20T21:26:38Z", "type": "commit"}, {"oid": "79925c6c0b386d0731a6f65b7183fe8d0b4267a7", "url": "https://github.com/MovingBlocks/Terasology/commit/79925c6c0b386d0731a6f65b7183fe8d0b4267a7", "message": "doc(BlockRegion): `equals` and small adjustment to string representation", "committedDate": "2020-12-20T21:28:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzOTA4Nw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r546439087", "bodyText": "This bit is a bit nasty, as this is currently the only way how to get an invalid region I think...", "author": "skaldarnar", "createdAt": "2020-12-20T21:32:11Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -528,9 +577,12 @@ public BlockRegion union(EntityRef blockRef) {\n     // ---------------------------------------------------------------------------------------------------------------//\n \n     /**\n-     * calculate the BlockRegion that is intersected between another region\n+     * Compute the intersection of this region with the {@code other} region.\n+     * <p>\n+     * NOTE: If the regions don't intersect this region will become invalid!", "originalCommit": "79925c6c0b386d0731a6f65b7183fe8d0b4267a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUwMzY4Nw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r546503687", "bodyText": "I don't think you can avoid everything.", "author": "pollend", "createdAt": "2020-12-21T04:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzOTA4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6799c3ad88cc478e6dfeac8279416677b54c833e", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 88543a429..6232b190b 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -119,597 +113,396 @@ public BlockRegion(Vector3ic block) {\n      * Create a new copy of the given block region {@code source}.\n      *\n      * @param source the block region to copy.\n-     * @see #copy()\n      */\n     public BlockRegion(BlockRegion source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n+     * Reset both the minimum and maximum corner of this region.\n      *\n      * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX);\n+        Preconditions.checkArgument(minY <= maxY);\n+        Preconditions.checkArgument(minZ <= maxZ);\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n         return this;\n     }\n \n     /**\n-     * Create a fresh copy of this block region.\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @see BlockRegion#BlockRegion(BlockRegion)\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * The x-coordinate of the minimum corner\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n+     *\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n+    public BlockRegion set(BlockRegion source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n+    }\n+\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n     public int minX() {\n         return this.minX;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block x\n-     *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n-     */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    @Override\n+    public int minY() {\n+        return this.minY;\n     }\n \n-    /**\n-     * Set the minimum x-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code x} is greater than the maximum x-coordinate\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n-    public int minY() {\n-        return this.minY;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n+        dest.minX = x;\n+        return dest;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    public BlockRegion minX(int x) {\n+        return this.minX(x, this);\n     }\n \n-    /**\n-     * Set the minimum y-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code y} is greater than the maximum y-coordinate\n-     */\n-    public BlockRegion minY(int y) {\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n         Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+        dest.minY = y;\n+        return dest;\n     }\n \n-    /**\n-     * The z-coordinate of the minimum corner\n-     */\n-    public int minZ() {\n-        return this.minZ;\n+    public BlockRegion minY(int y) {\n+        return this.minY(y, this);\n     }\n \n-    /**\n-     * the minimum coordinate of the first block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #minZ()}\n-     */\n-    @Deprecated\n-    public int getMinZ() {\n-        return this.minZ;\n+    @Override\n+    public BlockRegion minZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n+        dest.minZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Set the minimum z-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code z} is greater than the maximum z-coordinate\n-     */\n     public BlockRegion minZ(int z) {\n-        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n-        this.minZ = z;\n-        return this;\n+        return this.minZ(z, this);\n     }\n \n-    /**\n-     * Get the block coordinate of the minimum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest} after the result has been set\n-     */\n-    public Vector3i getMin(Vector3i dest) {\n-        return dest.set(minX, minY, minZ);\n+    @Override\n+    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n+        Preconditions.checkArgument(minX <= this.maxX || this.maxX == Integer.MIN_VALUE);\n+        Preconditions.checkArgument(minY <= this.maxY || this.maxX == Integer.MIN_VALUE);\n+        Preconditions.checkArgument(minZ <= this.maxZ || this.maxX == Integer.MIN_VALUE);\n+        dest.minX = minX;\n+        dest.minY = minY;\n+        dest.minZ = minZ;\n+        return dest;\n+    }\n+\n+    public BlockRegion setMin(int x, int y, int z) {\n+        return this.setMin(x, y, z, this);\n     }\n \n-    /**\n-     * Set the coordinates of the minimum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is greater than the respective component of the max\n-     *         corner\n-     */\n     public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min.x(), min.y(), min.z());\n+        return this.setMin(min, this);\n     }\n \n-    /**\n-     * Set the coordinates of the minimum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is greater than the respective component of the max\n-     *         corner\n-     */\n-    public BlockRegion setMin(int minX, int minY, int minZ) {\n-        Preconditions.checkArgument(minX <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minY <= this.maxY || this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minZ <= this.maxZ || this.maxX == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        this.minZ = minZ;\n-        return this;\n+    public BlockRegion addMin(int dx, int dy, int dz) {\n+        return this.addMin(dx, dy, dz, this);\n+    }\n+\n+    public BlockRegion addMin(Vector3ic dmin) {\n+        return this.addMin(dmin, this);\n     }\n \n+\n     // -- max --------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * The x-coordinate of the maximum corner\n-     */\n+    @Override\n     public int maxX() {\n         return this.maxX;\n     }\n \n-    /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #maxX()}\n-     */\n-    @Deprecated\n-    public int getMaxX() {\n-        return this.maxX;\n+    @Override\n+    public int maxY() {\n+        return this.maxY;\n     }\n \n-    /**\n-     * Set the maximum x-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code x} is smaller than the minimum x-coordinate\n-     */\n-    public BlockRegion maxX(int x) {\n-        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n-        this.maxX = x;\n-        return this;\n+    @Override\n+    public int maxZ() {\n+        return this.maxZ;\n     }\n \n-    /**\n-     * The y-coordinate of the maximum corner\n-     */\n-    public int maxY() {\n-        return this.maxY;\n+    @Override\n+    public BlockRegion maxX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n+        dest.maxX = x;\n+        return dest;\n     }\n \n-    /**\n-     * the maximum coordinate of the second block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #maxY()}\n-     */\n-    @Deprecated\n-    public int getMaxY() {\n-        return this.maxY;\n+    public BlockRegion maxX(int x) {\n+        return this.maxX(x, this);\n     }\n \n-    /**\n-     * Set the maximum y-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code y} is smaller than the minimum y-coordinate\n-     */\n-    public BlockRegion maxY(int y) {\n+    @Override\n+    public BlockRegion maxY(int y, BlockRegion dest) {\n         Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n-        this.maxY = y;\n-        return this;\n+        dest.maxY = y;\n+        return dest;\n     }\n \n-    /**\n-     * The z-coordinate of the maximum corner\n-     */\n-    public int maxZ() {\n-        return this.maxZ;\n+    public BlockRegion maxY(int y) {\n+        return this.maxY(y, this);\n     }\n \n-    /**\n-     * the maximum coordinate of the second block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #maxZ()}\n-     */\n-    @Deprecated\n-    public int getMaxZ() {\n-        return this.maxZ;\n+    @Override\n+    public BlockRegion maxZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n+        dest.maxZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Set the maximum z-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code z} is smaller than the minimum z-coordinate\n-     */\n     public BlockRegion maxZ(int z) {\n+        return this.maxZ(z, this);\n+    }\n+\n+    @Override\n+    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n+        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n         Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxZ = z;\n-        return this;\n+        dest.maxX = x;\n+        dest.maxY = y;\n+        dest.maxZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Get the block coordinate of the maximum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest} after the result has been set\n-     */\n-    public Vector3i getMax(Vector3i dest) {\n-        return dest.set(maxX, maxY, maxZ);\n+    public BlockRegion setMax(int x, int y, int z) {\n+        return this.setMax(x, y, z, this);\n     }\n \n-    /**\n-     * Set the coordinates of the maximum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is smaller than the respective component of the minimum\n-     *         corner\n-     */\n     public BlockRegion setMax(Vector3ic max) {\n-        return this.setMax(max.x(), max.y(), max.z());\n+        return this.setMax(max, this);\n     }\n \n-    /**\n-     * Set the coordinates of the maximum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is smaller than the respective component of the minimum\n-     *         corner\n-     */\n-    public BlockRegion setMax(int maxX, int maxY, int maxZ) {\n-        Preconditions.checkArgument(maxX >= this.minX || this.minX == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxY >= this.minY || this.minY == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxZ >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        this.maxZ = maxZ;\n-        return this;\n+    public BlockRegion addMax(int dx, int dy, int dz) {\n+        return this.addMax(dx, dy, dz, this);\n+    }\n+\n+    public BlockRegion addMax(Vector3ic dmax) {\n+        return this.addMax(dmax, this);\n     }\n \n     // -- size -------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Set the size of the block region from the minimum corner.\n-     *\n-     * @param x the x coordinate to set the size; must be > 0\n-     * @param y the y coordinate to set the size; must be > 0\n-     * @param z the z coordinate to set the size; must be > 0\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n-     */\n-    public BlockRegion setSize(int x, int y, int z) {\n+    @Override\n+    public BlockRegion setSize(int x, int y, int z, BlockRegion dest) {\n         Preconditions.checkArgument(x > 0);\n         Preconditions.checkArgument(y > 0);\n         Preconditions.checkArgument(z > 0);\n-        this.maxX = this.minX + x - 1;\n-        this.maxY = this.minY + y - 1;\n-        this.maxZ = this.minZ + z - 1;\n-        return this;\n-    }\n-\n-    /**\n-     * Set the size of the block region from the minimum corner.\n-     *\n-     * @param size the size to set; all dimensions must be > 0\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n-     */\n-    public BlockRegion setSize(Vector3ic size) {\n-        return setSize(size.x(), size.y(), size.z());\n-    }\n-\n-    /**\n-     * The number of blocks in this region along the +x, +y, +z  axis from the minimum to the maximum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector3i getSize(Vector3i dest) {\n-        return dest.set(sizeX(), sizeY(), sizeZ());\n-    }\n-\n-    /**\n-     * The number of blocks on the x axis.\n-     */\n-    public int sizeX() {\n-        return this.maxX - this.minX + 1;\n+        dest.maxX = this.minX + x - 1;\n+        dest.maxY = this.minY + y - 1;\n+        dest.maxZ = this.minZ + z - 1;\n+        return dest;\n     }\n \n-    /**\n-     * The number of blocks on the y axis.\n-     */\n-    public int sizeY() {\n-        return this.maxY - this.minY + 1;\n+    public BlockRegion setSize(int x, int y, int z) {\n+        return this.setSize(x, y, z, this);\n     }\n \n-    /**\n-     * The number of blocks on the z axis.\n-     */\n-    public int sizeZ() {\n-        return this.maxZ - this.minZ + 1;\n+    public BlockRegion setSize(Vector3ic size) {\n+        return setSize(size.x(), size.y(), size.z());\n     }\n \n-    // -- world ------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The bounding box in world coordinates.\n-     * <p>\n-     * The bounding box of a single block at {@code (x, y, z)} is centered at the integer coordinate {@code (x, y, z)}\n-     * and extents by {@code 0.5} in each dimension.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest}\n-     */\n-    //TODO: 1.9.26 has a constant interface for aabbf\n-    public AABBf getBounds(AABBf dest) {\n-        dest.minX = minX - .5f;\n-        dest.minY = minY - .5f;\n-        dest.minZ = minZ - .5f;\n-\n-        dest.maxX = maxX + .5f;\n-        dest.maxY = maxY + .5f;\n-        dest.maxZ = maxZ + .5f;\n-\n+    // -- IN-PLACE MUTATION ------------------------------------------------------------------------------------------//\n+    @Override\n+    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = Math.min(this.minX, x);\n+        dest.minY = Math.min(this.minY, y);\n+        dest.minZ = Math.min(this.minZ, z);\n+\n+        dest.maxX = Math.max(this.maxX, x);\n+        dest.maxY = Math.max(this.maxY, y);\n+        dest.maxZ = Math.max(this.maxZ, z);\n         return dest;\n     }\n \n-    /**\n-     * The center of the region in world coordinates if the region is valid; {@link Float#NaN} otherwise.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest}\n-     */\n-    public Vector3f center(Vector3f dest) {\n-        if (!this.isValid()) {\n-            return dest.set(Float.NaN);\n-        }\n-        return dest.set(\n-                (this.minX - .5f) + ((this.maxX - this.minX + 1.0f) / 2.0f),\n-                (this.minY - .5f) + ((this.maxY - this.minY + 1.0f) / 2.0f),\n-                (this.minZ - .5f) + ((this.maxZ - this.minZ + 1.0f) / 2.0f)\n-        );\n-    }\n-\n-    // -- IN-PLACE MUTATION ------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * Compute the union of this region and the given block coordinate.\n-     *\n-     * @param x the x coordinate of the block\n-     * @param y the y coordinate of the block\n-     * @param z the z coordinate of the block\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(int x, int y, int z) {\n-        this.minX = Math.min(this.minX, x);\n-        this.minY = Math.min(this.minY, y);\n-        this.minZ = Math.min(this.minZ, z);\n-\n-        this.maxX = Math.max(this.maxX, x);\n-        this.maxY = Math.max(this.maxY, y);\n-        this.maxZ = Math.max(this.maxZ, z);\n-        return this;\n+        return this.union(x, y, z, this);\n     }\n \n-    /**\n-     * Compute the union of this region and the given block coordinate.\n-     *\n-     * @param pos the position of the block\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(Vector3ic pos) {\n-        return union(pos.x(), pos.y(), pos.z());\n+        return union(pos.x(), pos.y(), pos.z(), this);\n     }\n \n-    /**\n-     * Compute the union of this region and the other region.\n-     *\n-     * @param other {@link BlockRegion}\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(BlockRegion other) {\n-        return this.union(other.minX, other.minY, other.minZ).union(other.maxX, other.maxY, other.maxZ);\n-    }\n-\n-    /**\n-     * Compute the union of this region and the given block entity.\n-     * <p>\n-     * An entity is a block entity if it has the {@link BlockComponent}. This region will not be modified if the given\n-     * entity does not have a {@link BlockComponent}.\n-     *\n-     * @param blockRef entityRef that describes a block\n-     * @return this region (after modification)\n-     */\n-    public BlockRegion union(EntityRef blockRef) {\n-        BlockComponent component = blockRef.getComponent(BlockComponent.class);\n-        if (component != null) {\n-            return this.union(component.position.x(), component.position.y(), component.position.z());\n-        }\n-        return this;\n+        return this.union(other, this);\n     }\n \n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Compute the intersection of this region with the {@code other} region.\n-     * <p>\n-     * NOTE: If the regions don't intersect this region will become invalid!\n-     *\n-     * @param other the other region\n-     * @return this region (after modification) or {@link Optional#empty()} if the regions don't intersect\n-     */\n-    public Optional<BlockRegion> intersect(BlockRegion other) {\n-        this.minX = Math.max(minX, other.minX);\n-        this.minY = Math.max(minY, other.minY);\n-        this.minZ = Math.max(minZ, other.minZ);\n+    @Override\n+    public Optional<BlockRegion> intersect(BlockRegion other, BlockRegion dest) {\n+        dest.minX = Math.max(minX, other.minX);\n+        dest.minY = Math.max(minY, other.minY);\n+        dest.minZ = Math.max(minZ, other.minZ);\n \n-        this.maxX = Math.min(maxX, other.maxX);\n-        this.maxY = Math.min(maxY, other.maxY);\n-        this.maxZ = Math.min(maxZ, other.maxZ);\n+        dest.maxX = Math.min(maxX, other.maxX);\n+        dest.maxY = Math.min(maxY, other.maxY);\n+        dest.maxZ = Math.min(maxZ, other.maxZ);\n \n-        if (this.isValid()) {\n-            return Optional.of(this);\n+        if (dest.isValid()) {\n+            return Optional.of(dest);\n         } else {\n             return Optional.empty();\n         }\n     }\n \n+    public Optional<BlockRegion> intersect(BlockRegion other) {\n+        return this.intersect(other, this);\n+    }\n+\n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Translate this region by the given vector {@code (x, y, z))}.\n-     *\n-     * @param x the x coordinate to translate by\n-     * @param y the y coordinate to translate by\n-     * @param z the z coordinate to translate by\n-     * @return this region (after modification)\n-     */\n+    @Override\n+    public BlockRegion translate(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = this.minX + x;\n+        dest.minY = this.minY + y;\n+        dest.minZ = this.minZ + z;\n+        dest.maxX = this.maxX + x;\n+        dest.maxY = this.maxY + y;\n+        dest.maxZ = this.maxZ + z;\n+        return dest;\n+    }\n+\n     public BlockRegion translate(int x, int y, int z) {\n-        this.minX = this.minX + x;\n-        this.minY = this.minY + y;\n-        this.minZ = this.minZ + z;\n-        this.maxX = this.maxX + x;\n-        this.maxY = this.maxY + y;\n-        this.maxZ = this.maxZ + z;\n-        return this;\n+        return this.translate(x, y, z, this);\n     }\n \n-    /**\n-     * Translate this region by the given vector {@code vec}.\n-     *\n-     * @param vec the vector to translate by\n-     * @return this region (after modification)\n-     */\n     public BlockRegion translate(Vector3ic vec) {\n         return translate(vec.x(), vec.y(), vec.z());\n     }\n \n     // -- extend -----------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     *\n-     * @param extentX the amount of blocks to extend this region by along the x axis in both directions\n-     * @param extentY the amount of blocks to extend this region by along the y axis in both directions\n-     * @param extentZ the amount of blocks to extend this region by along the z axis in both directions\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(int extentX, int extentY, int extentZ) {\n-        Preconditions.checkArgument(sizeX() + 2 * extentX > 0);\n-        Preconditions.checkArgument(sizeY() + 2 * extentY > 0);\n-        Preconditions.checkArgument(sizeZ() + 2 * extentZ > 0);\n-        this.minX = this.minX - extentX;\n-        this.minY = this.minY - extentY;\n-        this.minZ = this.minZ - extentZ;\n-\n-        this.maxX = this.maxX + extentX;\n-        this.maxY = this.maxY + extentY;\n-        this.maxZ = this.maxZ + extentZ;\n+    @Override\n+    public BlockRegion expand(int dx, int dy, int dz, BlockRegion dest) {\n+        Preconditions.checkArgument(getSizeX() + 2 * dx > 0);\n+        Preconditions.checkArgument(getSizeY() + 2 * dy > 0);\n+        Preconditions.checkArgument(getSizeZ() + 2 * dz > 0);\n+        dest.minX = this.minX - dx;\n+        dest.minY = this.minY - dy;\n+        dest.minZ = this.minZ - dz;\n+\n+        dest.maxX = this.maxX + dx;\n+        dest.maxY = this.maxY + dy;\n+        dest.maxZ = this.maxZ + dz;\n \n-        return this;\n+        return dest;\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     *\n-     * @param extents the amount of blocks to extend this region by\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(Vector3ic extents) {\n-        return extend(extents.x(), extents.y(), extents.z());\n+    public BlockRegion expand(int dx, int dy, int dz) {\n+        return this.expand(dx, dy, dz, this);\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     * <p>\n-     * The extents will be floored for each dimension.\n-     *\n-     * @param extentX the amount of blocks to extend this region by along the x axis in both directions\n-     * @param extentY the amount of blocks to extend this region by along the y axis in both directions\n-     * @param extentZ the amount of blocks to extend this region by along the z axis in both directions\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(float extentX, float extentY, float extentZ) {\n-        return extend(\n-                Math.roundUsing(extentX, RoundingMode.FLOOR),\n-                Math.roundUsing(extentY, RoundingMode.FLOOR),\n-                Math.roundUsing(extentZ, RoundingMode.FLOOR));\n+    public BlockRegion expand(Vector3ic extents) {\n+        return expand(extents.x(), extents.y(), extents.z());\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     * <p>\n-     * The extents will be floored for each dimension.\n-     *\n-     * @param extents the amount of blocks to extend this region by\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(Vector3f extents) {\n-        return extend(extents.x(), extents.y(), extents.z());\n+    public BlockRegion expand(float dx, float dy, float dz) {\n+        return this.expand(dx, dy, dz, this);\n+    }\n+\n+    public BlockRegion expand(Vector3f extents) {\n+        return expand(extents.x(), extents.y(), extents.z());\n     }\n \n     // -- transform --------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Apply the given {@link Matrix4fc#isAffine() affine} transformation to this {@link BlockRegion}.\n-     * <p>\n-     * The matrix in {@code m} <i>must</i> be {@link Matrix4fc#isAffine() affine}.\n-     *\n-     * @param m the affine transformation matrix\n-     * @param dest will hold the result\n-     * @return {@code dest} (after modification)\n-     * @throws IllegalArgumentException if the matrix {@code m} is not {@link Matrix4fc#isAffine() affine}\n-     */\n+    @Override\n     public BlockRegion transform(Matrix4fc m, BlockRegion dest) {\n         Preconditions.checkArgument(m.isAffine());\n         float dx = maxX - minX;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzODk3NQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r546438975", "bodyText": "this seems kind of redundant. do we need this?", "author": "pollend", "createdAt": "2020-12-20T21:31:10Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -116,6 +143,11 @@ public BlockRegion set(BlockRegion source) {\n         return this;\n     }\n \n+    /**\n+     * Create a fresh copy of this block region.\n+     *\n+     * @see BlockRegion#BlockRegion(BlockRegion)\n+     */\n     public BlockRegion copy() {\n         return new BlockRegion(this);\n     }", "originalCommit": "79925c6c0b386d0731a6f65b7183fe8d0b4267a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzNjUyMw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r546636523", "bodyText": "While writing tests I thought that I could read\nregion.copy().doThis().doThat()\nway better than\nnew BlockRegion(region).doThis().doThat()\nMight be just personal taste, but I thought this would not hurt...", "author": "skaldarnar", "createdAt": "2020-12-21T10:47:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzODk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1OTcyNw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r546659727", "bodyText": "I'm guessing @pollend meant the comment rather than the method itself.\nIn order to get this in so we can align the other joml PRs with it and make progress, I'll dismiss your review @pollend but please let's talk about this on Discord if you want and if applicable do a follow-up PR.", "author": "jdrueckert", "createdAt": "2020-12-21T11:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzODk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzNzE0Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r547037146", "bodyText": "It's not too bad, I think it should be fine as is then. Just don't want there to be too many variations. Some of the convenience ends up being more confusing. might not be recognizable that copy means producing a new duplicate of the original. I don't think new BlockRegion(a) is any more convenient then a.copy().\nBlockRegion b = new BlockRegion(0,0,0,0,0,0);\nBlockRegion temp =  b.copy();\n\nvs\n\nBlockRegion b = new BlockRegion(0,0,0,0,0,0);\nBlockRegion temp =  new BlockRegion(b); \n\nthe copy method hides the instantiation so its not apparent what is exactly happening at a glance. feels like something that is convenient at the cost of readability.\nI guess you've also hidden all the constructor methods so you basically need a copy method. The whole process of shifting everything to a utility class and hiding an instantiation in a method just seems strange to me. The whole things feels a bit like taking an additional detour.", "author": "pollend", "createdAt": "2020-12-22T02:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzODk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIyNDM5Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r547224392", "bodyText": "I actually did re-expose the constructors for min/max and single block position, as well as the copy-constructor taking another region. What's still left on the utility class are constructors for fromMinAndSize and fromCenterAndExtents.\nI can remove the copy method, but then I'd also go for removing the utility class, as\nfromMinAndSize(min, size) == new BlockRegion(min).setSize(size);\n\nfromCenterAndExtents(center, extents) == new BlockRegion(center).expand(extents);\nIt would be nice to make BlockRegion implements Iterable, but then we'd need to throw out on of the iterables, too (preferably keep in the in-place variant, as you can implement the other on caller side).", "author": "skaldarnar", "createdAt": "2020-12-22T11:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzODk3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6799c3ad88cc478e6dfeac8279416677b54c833e", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 88543a429..6232b190b 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -119,597 +113,396 @@ public BlockRegion(Vector3ic block) {\n      * Create a new copy of the given block region {@code source}.\n      *\n      * @param source the block region to copy.\n-     * @see #copy()\n      */\n     public BlockRegion(BlockRegion source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n+     * Reset both the minimum and maximum corner of this region.\n      *\n      * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX);\n+        Preconditions.checkArgument(minY <= maxY);\n+        Preconditions.checkArgument(minZ <= maxZ);\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n         return this;\n     }\n \n     /**\n-     * Create a fresh copy of this block region.\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @see BlockRegion#BlockRegion(BlockRegion)\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * The x-coordinate of the minimum corner\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n+     *\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n+    public BlockRegion set(BlockRegion source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n+    }\n+\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n     public int minX() {\n         return this.minX;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block x\n-     *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n-     */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    @Override\n+    public int minY() {\n+        return this.minY;\n     }\n \n-    /**\n-     * Set the minimum x-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code x} is greater than the maximum x-coordinate\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n-    public int minY() {\n-        return this.minY;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n+        dest.minX = x;\n+        return dest;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    public BlockRegion minX(int x) {\n+        return this.minX(x, this);\n     }\n \n-    /**\n-     * Set the minimum y-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code y} is greater than the maximum y-coordinate\n-     */\n-    public BlockRegion minY(int y) {\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n         Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+        dest.minY = y;\n+        return dest;\n     }\n \n-    /**\n-     * The z-coordinate of the minimum corner\n-     */\n-    public int minZ() {\n-        return this.minZ;\n+    public BlockRegion minY(int y) {\n+        return this.minY(y, this);\n     }\n \n-    /**\n-     * the minimum coordinate of the first block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #minZ()}\n-     */\n-    @Deprecated\n-    public int getMinZ() {\n-        return this.minZ;\n+    @Override\n+    public BlockRegion minZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n+        dest.minZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Set the minimum z-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code z} is greater than the maximum z-coordinate\n-     */\n     public BlockRegion minZ(int z) {\n-        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n-        this.minZ = z;\n-        return this;\n+        return this.minZ(z, this);\n     }\n \n-    /**\n-     * Get the block coordinate of the minimum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest} after the result has been set\n-     */\n-    public Vector3i getMin(Vector3i dest) {\n-        return dest.set(minX, minY, minZ);\n+    @Override\n+    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n+        Preconditions.checkArgument(minX <= this.maxX || this.maxX == Integer.MIN_VALUE);\n+        Preconditions.checkArgument(minY <= this.maxY || this.maxX == Integer.MIN_VALUE);\n+        Preconditions.checkArgument(minZ <= this.maxZ || this.maxX == Integer.MIN_VALUE);\n+        dest.minX = minX;\n+        dest.minY = minY;\n+        dest.minZ = minZ;\n+        return dest;\n+    }\n+\n+    public BlockRegion setMin(int x, int y, int z) {\n+        return this.setMin(x, y, z, this);\n     }\n \n-    /**\n-     * Set the coordinates of the minimum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is greater than the respective component of the max\n-     *         corner\n-     */\n     public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min.x(), min.y(), min.z());\n+        return this.setMin(min, this);\n     }\n \n-    /**\n-     * Set the coordinates of the minimum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is greater than the respective component of the max\n-     *         corner\n-     */\n-    public BlockRegion setMin(int minX, int minY, int minZ) {\n-        Preconditions.checkArgument(minX <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minY <= this.maxY || this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minZ <= this.maxZ || this.maxX == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        this.minZ = minZ;\n-        return this;\n+    public BlockRegion addMin(int dx, int dy, int dz) {\n+        return this.addMin(dx, dy, dz, this);\n+    }\n+\n+    public BlockRegion addMin(Vector3ic dmin) {\n+        return this.addMin(dmin, this);\n     }\n \n+\n     // -- max --------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * The x-coordinate of the maximum corner\n-     */\n+    @Override\n     public int maxX() {\n         return this.maxX;\n     }\n \n-    /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #maxX()}\n-     */\n-    @Deprecated\n-    public int getMaxX() {\n-        return this.maxX;\n+    @Override\n+    public int maxY() {\n+        return this.maxY;\n     }\n \n-    /**\n-     * Set the maximum x-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code x} is smaller than the minimum x-coordinate\n-     */\n-    public BlockRegion maxX(int x) {\n-        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n-        this.maxX = x;\n-        return this;\n+    @Override\n+    public int maxZ() {\n+        return this.maxZ;\n     }\n \n-    /**\n-     * The y-coordinate of the maximum corner\n-     */\n-    public int maxY() {\n-        return this.maxY;\n+    @Override\n+    public BlockRegion maxX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n+        dest.maxX = x;\n+        return dest;\n     }\n \n-    /**\n-     * the maximum coordinate of the second block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #maxY()}\n-     */\n-    @Deprecated\n-    public int getMaxY() {\n-        return this.maxY;\n+    public BlockRegion maxX(int x) {\n+        return this.maxX(x, this);\n     }\n \n-    /**\n-     * Set the maximum y-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code y} is smaller than the minimum y-coordinate\n-     */\n-    public BlockRegion maxY(int y) {\n+    @Override\n+    public BlockRegion maxY(int y, BlockRegion dest) {\n         Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n-        this.maxY = y;\n-        return this;\n+        dest.maxY = y;\n+        return dest;\n     }\n \n-    /**\n-     * The z-coordinate of the maximum corner\n-     */\n-    public int maxZ() {\n-        return this.maxZ;\n+    public BlockRegion maxY(int y) {\n+        return this.maxY(y, this);\n     }\n \n-    /**\n-     * the maximum coordinate of the second block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #maxZ()}\n-     */\n-    @Deprecated\n-    public int getMaxZ() {\n-        return this.maxZ;\n+    @Override\n+    public BlockRegion maxZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n+        dest.maxZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Set the maximum z-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code z} is smaller than the minimum z-coordinate\n-     */\n     public BlockRegion maxZ(int z) {\n+        return this.maxZ(z, this);\n+    }\n+\n+    @Override\n+    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n+        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n         Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxZ = z;\n-        return this;\n+        dest.maxX = x;\n+        dest.maxY = y;\n+        dest.maxZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Get the block coordinate of the maximum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest} after the result has been set\n-     */\n-    public Vector3i getMax(Vector3i dest) {\n-        return dest.set(maxX, maxY, maxZ);\n+    public BlockRegion setMax(int x, int y, int z) {\n+        return this.setMax(x, y, z, this);\n     }\n \n-    /**\n-     * Set the coordinates of the maximum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is smaller than the respective component of the minimum\n-     *         corner\n-     */\n     public BlockRegion setMax(Vector3ic max) {\n-        return this.setMax(max.x(), max.y(), max.z());\n+        return this.setMax(max, this);\n     }\n \n-    /**\n-     * Set the coordinates of the maximum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is smaller than the respective component of the minimum\n-     *         corner\n-     */\n-    public BlockRegion setMax(int maxX, int maxY, int maxZ) {\n-        Preconditions.checkArgument(maxX >= this.minX || this.minX == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxY >= this.minY || this.minY == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxZ >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        this.maxZ = maxZ;\n-        return this;\n+    public BlockRegion addMax(int dx, int dy, int dz) {\n+        return this.addMax(dx, dy, dz, this);\n+    }\n+\n+    public BlockRegion addMax(Vector3ic dmax) {\n+        return this.addMax(dmax, this);\n     }\n \n     // -- size -------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Set the size of the block region from the minimum corner.\n-     *\n-     * @param x the x coordinate to set the size; must be > 0\n-     * @param y the y coordinate to set the size; must be > 0\n-     * @param z the z coordinate to set the size; must be > 0\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n-     */\n-    public BlockRegion setSize(int x, int y, int z) {\n+    @Override\n+    public BlockRegion setSize(int x, int y, int z, BlockRegion dest) {\n         Preconditions.checkArgument(x > 0);\n         Preconditions.checkArgument(y > 0);\n         Preconditions.checkArgument(z > 0);\n-        this.maxX = this.minX + x - 1;\n-        this.maxY = this.minY + y - 1;\n-        this.maxZ = this.minZ + z - 1;\n-        return this;\n-    }\n-\n-    /**\n-     * Set the size of the block region from the minimum corner.\n-     *\n-     * @param size the size to set; all dimensions must be > 0\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n-     */\n-    public BlockRegion setSize(Vector3ic size) {\n-        return setSize(size.x(), size.y(), size.z());\n-    }\n-\n-    /**\n-     * The number of blocks in this region along the +x, +y, +z  axis from the minimum to the maximum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector3i getSize(Vector3i dest) {\n-        return dest.set(sizeX(), sizeY(), sizeZ());\n-    }\n-\n-    /**\n-     * The number of blocks on the x axis.\n-     */\n-    public int sizeX() {\n-        return this.maxX - this.minX + 1;\n+        dest.maxX = this.minX + x - 1;\n+        dest.maxY = this.minY + y - 1;\n+        dest.maxZ = this.minZ + z - 1;\n+        return dest;\n     }\n \n-    /**\n-     * The number of blocks on the y axis.\n-     */\n-    public int sizeY() {\n-        return this.maxY - this.minY + 1;\n+    public BlockRegion setSize(int x, int y, int z) {\n+        return this.setSize(x, y, z, this);\n     }\n \n-    /**\n-     * The number of blocks on the z axis.\n-     */\n-    public int sizeZ() {\n-        return this.maxZ - this.minZ + 1;\n+    public BlockRegion setSize(Vector3ic size) {\n+        return setSize(size.x(), size.y(), size.z());\n     }\n \n-    // -- world ------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The bounding box in world coordinates.\n-     * <p>\n-     * The bounding box of a single block at {@code (x, y, z)} is centered at the integer coordinate {@code (x, y, z)}\n-     * and extents by {@code 0.5} in each dimension.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest}\n-     */\n-    //TODO: 1.9.26 has a constant interface for aabbf\n-    public AABBf getBounds(AABBf dest) {\n-        dest.minX = minX - .5f;\n-        dest.minY = minY - .5f;\n-        dest.minZ = minZ - .5f;\n-\n-        dest.maxX = maxX + .5f;\n-        dest.maxY = maxY + .5f;\n-        dest.maxZ = maxZ + .5f;\n-\n+    // -- IN-PLACE MUTATION ------------------------------------------------------------------------------------------//\n+    @Override\n+    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = Math.min(this.minX, x);\n+        dest.minY = Math.min(this.minY, y);\n+        dest.minZ = Math.min(this.minZ, z);\n+\n+        dest.maxX = Math.max(this.maxX, x);\n+        dest.maxY = Math.max(this.maxY, y);\n+        dest.maxZ = Math.max(this.maxZ, z);\n         return dest;\n     }\n \n-    /**\n-     * The center of the region in world coordinates if the region is valid; {@link Float#NaN} otherwise.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest}\n-     */\n-    public Vector3f center(Vector3f dest) {\n-        if (!this.isValid()) {\n-            return dest.set(Float.NaN);\n-        }\n-        return dest.set(\n-                (this.minX - .5f) + ((this.maxX - this.minX + 1.0f) / 2.0f),\n-                (this.minY - .5f) + ((this.maxY - this.minY + 1.0f) / 2.0f),\n-                (this.minZ - .5f) + ((this.maxZ - this.minZ + 1.0f) / 2.0f)\n-        );\n-    }\n-\n-    // -- IN-PLACE MUTATION ------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * Compute the union of this region and the given block coordinate.\n-     *\n-     * @param x the x coordinate of the block\n-     * @param y the y coordinate of the block\n-     * @param z the z coordinate of the block\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(int x, int y, int z) {\n-        this.minX = Math.min(this.minX, x);\n-        this.minY = Math.min(this.minY, y);\n-        this.minZ = Math.min(this.minZ, z);\n-\n-        this.maxX = Math.max(this.maxX, x);\n-        this.maxY = Math.max(this.maxY, y);\n-        this.maxZ = Math.max(this.maxZ, z);\n-        return this;\n+        return this.union(x, y, z, this);\n     }\n \n-    /**\n-     * Compute the union of this region and the given block coordinate.\n-     *\n-     * @param pos the position of the block\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(Vector3ic pos) {\n-        return union(pos.x(), pos.y(), pos.z());\n+        return union(pos.x(), pos.y(), pos.z(), this);\n     }\n \n-    /**\n-     * Compute the union of this region and the other region.\n-     *\n-     * @param other {@link BlockRegion}\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(BlockRegion other) {\n-        return this.union(other.minX, other.minY, other.minZ).union(other.maxX, other.maxY, other.maxZ);\n-    }\n-\n-    /**\n-     * Compute the union of this region and the given block entity.\n-     * <p>\n-     * An entity is a block entity if it has the {@link BlockComponent}. This region will not be modified if the given\n-     * entity does not have a {@link BlockComponent}.\n-     *\n-     * @param blockRef entityRef that describes a block\n-     * @return this region (after modification)\n-     */\n-    public BlockRegion union(EntityRef blockRef) {\n-        BlockComponent component = blockRef.getComponent(BlockComponent.class);\n-        if (component != null) {\n-            return this.union(component.position.x(), component.position.y(), component.position.z());\n-        }\n-        return this;\n+        return this.union(other, this);\n     }\n \n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Compute the intersection of this region with the {@code other} region.\n-     * <p>\n-     * NOTE: If the regions don't intersect this region will become invalid!\n-     *\n-     * @param other the other region\n-     * @return this region (after modification) or {@link Optional#empty()} if the regions don't intersect\n-     */\n-    public Optional<BlockRegion> intersect(BlockRegion other) {\n-        this.minX = Math.max(minX, other.minX);\n-        this.minY = Math.max(minY, other.minY);\n-        this.minZ = Math.max(minZ, other.minZ);\n+    @Override\n+    public Optional<BlockRegion> intersect(BlockRegion other, BlockRegion dest) {\n+        dest.minX = Math.max(minX, other.minX);\n+        dest.minY = Math.max(minY, other.minY);\n+        dest.minZ = Math.max(minZ, other.minZ);\n \n-        this.maxX = Math.min(maxX, other.maxX);\n-        this.maxY = Math.min(maxY, other.maxY);\n-        this.maxZ = Math.min(maxZ, other.maxZ);\n+        dest.maxX = Math.min(maxX, other.maxX);\n+        dest.maxY = Math.min(maxY, other.maxY);\n+        dest.maxZ = Math.min(maxZ, other.maxZ);\n \n-        if (this.isValid()) {\n-            return Optional.of(this);\n+        if (dest.isValid()) {\n+            return Optional.of(dest);\n         } else {\n             return Optional.empty();\n         }\n     }\n \n+    public Optional<BlockRegion> intersect(BlockRegion other) {\n+        return this.intersect(other, this);\n+    }\n+\n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Translate this region by the given vector {@code (x, y, z))}.\n-     *\n-     * @param x the x coordinate to translate by\n-     * @param y the y coordinate to translate by\n-     * @param z the z coordinate to translate by\n-     * @return this region (after modification)\n-     */\n+    @Override\n+    public BlockRegion translate(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = this.minX + x;\n+        dest.minY = this.minY + y;\n+        dest.minZ = this.minZ + z;\n+        dest.maxX = this.maxX + x;\n+        dest.maxY = this.maxY + y;\n+        dest.maxZ = this.maxZ + z;\n+        return dest;\n+    }\n+\n     public BlockRegion translate(int x, int y, int z) {\n-        this.minX = this.minX + x;\n-        this.minY = this.minY + y;\n-        this.minZ = this.minZ + z;\n-        this.maxX = this.maxX + x;\n-        this.maxY = this.maxY + y;\n-        this.maxZ = this.maxZ + z;\n-        return this;\n+        return this.translate(x, y, z, this);\n     }\n \n-    /**\n-     * Translate this region by the given vector {@code vec}.\n-     *\n-     * @param vec the vector to translate by\n-     * @return this region (after modification)\n-     */\n     public BlockRegion translate(Vector3ic vec) {\n         return translate(vec.x(), vec.y(), vec.z());\n     }\n \n     // -- extend -----------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     *\n-     * @param extentX the amount of blocks to extend this region by along the x axis in both directions\n-     * @param extentY the amount of blocks to extend this region by along the y axis in both directions\n-     * @param extentZ the amount of blocks to extend this region by along the z axis in both directions\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(int extentX, int extentY, int extentZ) {\n-        Preconditions.checkArgument(sizeX() + 2 * extentX > 0);\n-        Preconditions.checkArgument(sizeY() + 2 * extentY > 0);\n-        Preconditions.checkArgument(sizeZ() + 2 * extentZ > 0);\n-        this.minX = this.minX - extentX;\n-        this.minY = this.minY - extentY;\n-        this.minZ = this.minZ - extentZ;\n-\n-        this.maxX = this.maxX + extentX;\n-        this.maxY = this.maxY + extentY;\n-        this.maxZ = this.maxZ + extentZ;\n+    @Override\n+    public BlockRegion expand(int dx, int dy, int dz, BlockRegion dest) {\n+        Preconditions.checkArgument(getSizeX() + 2 * dx > 0);\n+        Preconditions.checkArgument(getSizeY() + 2 * dy > 0);\n+        Preconditions.checkArgument(getSizeZ() + 2 * dz > 0);\n+        dest.minX = this.minX - dx;\n+        dest.minY = this.minY - dy;\n+        dest.minZ = this.minZ - dz;\n+\n+        dest.maxX = this.maxX + dx;\n+        dest.maxY = this.maxY + dy;\n+        dest.maxZ = this.maxZ + dz;\n \n-        return this;\n+        return dest;\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     *\n-     * @param extents the amount of blocks to extend this region by\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(Vector3ic extents) {\n-        return extend(extents.x(), extents.y(), extents.z());\n+    public BlockRegion expand(int dx, int dy, int dz) {\n+        return this.expand(dx, dy, dz, this);\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     * <p>\n-     * The extents will be floored for each dimension.\n-     *\n-     * @param extentX the amount of blocks to extend this region by along the x axis in both directions\n-     * @param extentY the amount of blocks to extend this region by along the y axis in both directions\n-     * @param extentZ the amount of blocks to extend this region by along the z axis in both directions\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(float extentX, float extentY, float extentZ) {\n-        return extend(\n-                Math.roundUsing(extentX, RoundingMode.FLOOR),\n-                Math.roundUsing(extentY, RoundingMode.FLOOR),\n-                Math.roundUsing(extentZ, RoundingMode.FLOOR));\n+    public BlockRegion expand(Vector3ic extents) {\n+        return expand(extents.x(), extents.y(), extents.z());\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     * <p>\n-     * The extents will be floored for each dimension.\n-     *\n-     * @param extents the amount of blocks to extend this region by\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(Vector3f extents) {\n-        return extend(extents.x(), extents.y(), extents.z());\n+    public BlockRegion expand(float dx, float dy, float dz) {\n+        return this.expand(dx, dy, dz, this);\n+    }\n+\n+    public BlockRegion expand(Vector3f extents) {\n+        return expand(extents.x(), extents.y(), extents.z());\n     }\n \n     // -- transform --------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Apply the given {@link Matrix4fc#isAffine() affine} transformation to this {@link BlockRegion}.\n-     * <p>\n-     * The matrix in {@code m} <i>must</i> be {@link Matrix4fc#isAffine() affine}.\n-     *\n-     * @param m the affine transformation matrix\n-     * @param dest will hold the result\n-     * @return {@code dest} (after modification)\n-     * @throws IllegalArgumentException if the matrix {@code m} is not {@link Matrix4fc#isAffine() affine}\n-     */\n+    @Override\n     public BlockRegion transform(Matrix4fc m, BlockRegion dest) {\n         Preconditions.checkArgument(m.isAffine());\n         float dx = maxX - minX;\n"}}, {"oid": "57bef6796e22331061c2d0ebcca51c48d946dd87", "url": "https://github.com/MovingBlocks/Terasology/commit/57bef6796e22331061c2d0ebcca51c48d946dd87", "message": "Merge branch 'develop' into docs/BlockRegion", "committedDate": "2020-12-21T11:40:48Z", "type": "commit"}, {"oid": "e0f0c7bbd1cc845e106627ad64b3e7a8c9065e4c", "url": "https://github.com/MovingBlocks/Terasology/commit/e0f0c7bbd1cc845e106627ad64b3e7a8c9065e4c", "message": "feat(BlockRegions): expose INVALID region to be used for reduction", "committedDate": "2020-12-21T12:21:39Z", "type": "commit"}, {"oid": "ed1c725d7493b3296dcdc2f8e39401b4fc1444ef", "url": "https://github.com/MovingBlocks/Terasology/commit/ed1c725d7493b3296dcdc2f8e39401b4fc1444ef", "message": "Merge remote-tracking branch 'origin/docs/BlockRegion' into docs/BlockRegion", "committedDate": "2020-12-21T12:29:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY4MDkyNw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r546680927", "bodyText": "I've asked about this on Discord: https://discord.com/channels/270264625419911192/701818347238588561/790546593911799808", "author": "skaldarnar", "createdAt": "2020-12-21T12:32:58Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegions.java", "diffHunk": "@@ -16,98 +17,134 @@\n import java.util.stream.StreamSupport;\n \n public final class BlockRegions {\n+    /**\n+     * An invalid block region.\n+     * <p>\n+     * CAUTION: Behavior for this region may be undeterministic for some operations. Avoid extensive use and encode an\n+     * <i>empty region</i> by other means, e.g., by using {@code null} or {@link java.util.Optional}.\n+     * <p>\n+     * This region may be used as initial value for reductions on block regions. For instance, to compute the union (the\n+     * region that encompasses all regions in some collection {@code regions}) the following Stream-API snippet can be\n+     * used:\n+     * <pre>\n+     *     BlockRegion union = regions.stream().reduce(BlockRegions.INVALID, BlockRegion::union, BlockRegion::union);\n+     * </pre>\n+     */\n+    public static final BlockRegion INVALID = new BlockRegion();", "originalCommit": "ed1c725d7493b3296dcdc2f8e39401b4fc1444ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcyNjM1MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r546726351", "bodyText": "Note: this either has to be a Supplier<BlockRegion> or should return a BlockRegionc so that it cannot be modified.", "author": "skaldarnar", "createdAt": "2020-12-21T14:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY4MDkyNw=="}], "type": "inlineReview", "revised_code": {"commit": "f7ac93f0698378f4ad0c7937fd21ca91efa32a49", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegions.java b/engine/src/main/java/org/terasology/world/block/BlockRegions.java\nindex c73de3015..13ae44c33 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegions.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegions.java\n\n@@ -63,6 +63,19 @@ public static BlockRegion fromMinAndMax(int minX, int minY, int minZ, int maxX,\n         return new BlockRegion(minX, minY, minZ, maxX, maxY, maxZ);\n     }\n \n+    /**\n+     * Creates a new region centered around {@code center} extending each side by {@code extents}.\n+     * <p>\n+     * The resulting axis-aligned bounding box (AABB) will have a size of {@code 2 * extents}\n+     * <p>\n+     * The {@code extents} MUST be non-negative in every dimension, otherwise an {@link IllegalArgumentException} will\n+     * be thrown.\n+     */\n+    public static BlockRegion fromCenterAndExtents(int centerX, int centerY, int centerZ,\n+                                                   int extentsX, int extentsY, int extentsZ) {\n+        return new BlockRegion(centerX, centerY, centerZ).extend(extentsX, extentsY, extentsZ);\n+    }\n+\n     /**\n      * Creates a new region centered around {@code center} extending each side by {@code extents}.\n      * <p>\n"}}, {"oid": "d9cc440128ca3e8b5e568a596614ddede22fdca2", "url": "https://github.com/MovingBlocks/Terasology/commit/d9cc440128ca3e8b5e568a596614ddede22fdca2", "message": "feat(BlockRegion): re-add `getSize...` getters (duplicates of `size...`)", "committedDate": "2020-12-21T12:47:10Z", "type": "commit"}, {"oid": "f7ac93f0698378f4ad0c7937fd21ca91efa32a49", "url": "https://github.com/MovingBlocks/Terasology/commit/f7ac93f0698378f4ad0c7937fd21ca91efa32a49", "message": "feat(BlockRegions): add variant with 6 int args for `fromCenterAndExtents`", "committedDate": "2020-12-21T13:44:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MTQ5Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r547051492", "bodyText": "I just realized this precondition might be a problem if you setMin above max and then aftewards you setmax. The final region is going to be valid but you're going to hit this exception. Its an extra burden to require the min and max to be set once or always assume that its going to be valid.\nBlockRegions.createFromMinAndMax(0,0,0,0,0,0).setMin(1,1,1).setMax(2,2,2);", "author": "pollend", "createdAt": "2020-12-22T03:47:58Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -210,31 +245,32 @@ public BlockRegion minZ(int z) {\n     }\n \n     /**\n-     * Get the block coordinate minimum corner.\n+     * Get the block coordinate of the minimum corner.\n      *\n      * @param dest will hold the result\n+     * @return {@code dest} after the result has been set\n      */\n     public Vector3i getMin(Vector3i dest) {\n         return dest.set(minX, minY, minZ);\n     }\n \n     /**\n-     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n+     * Set the coordinates of the minimum corner for this region.\n      *\n-     * @param min the first coordinate of the first block\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if any dimension is greater than the respective component of the max\n+     *         corner\n      */\n     public BlockRegion setMin(Vector3ic min) {\n         return this.setMin(min.x(), min.y(), min.z());\n     }\n \n     /**\n-     * sets the minimum block for this {@link BlockRegion}\n+     * Set the coordinates of the minimum corner for this region.\n      *\n-     * @param minX the x coordinate of the first block\n-     * @param minY the y coordinate of the first block\n-     * @param minZ the z coordinate of the first block\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if any dimension is greater than the respective component of the max\n+     *         corner\n      */\n     public BlockRegion setMin(int minX, int minY, int minZ) {", "originalCommit": "f7ac93f0698378f4ad0c7937fd21ca91efa32a49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIyNjI1OQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r547226259", "bodyText": "Well, I thought we agreed with @4Denthusiast that we are trying for a design where a BlockRegion is (almost always) valid - which means that you have to pay attention to details like this. In this case you know that min and max will work out in the end, but what happens if the calls are split over several methods or even different systems handling it?\nWe already have set(BlockRegion), maybe we also need set(minX, minY, minZ, maxX, maxY, maxZ) which would solve your problem, I guess?", "author": "skaldarnar", "createdAt": "2020-12-22T11:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MTQ5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6799c3ad88cc478e6dfeac8279416677b54c833e", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 35bc3dfea..6232b190b 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -119,618 +113,396 @@ public BlockRegion(Vector3ic block) {\n      * Create a new copy of the given block region {@code source}.\n      *\n      * @param source the block region to copy.\n-     * @see #copy()\n      */\n     public BlockRegion(BlockRegion source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n+     * Reset both the minimum and maximum corner of this region.\n      *\n      * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX);\n+        Preconditions.checkArgument(minY <= maxY);\n+        Preconditions.checkArgument(minZ <= maxZ);\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n         return this;\n     }\n \n     /**\n-     * Create a fresh copy of this block region.\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @see BlockRegion#BlockRegion(BlockRegion)\n-     */\n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n-    }\n-\n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The x-coordinate of the minimum corner\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public int minX() {\n-        return this.minX;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    public BlockRegion set(BlockRegion source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * Set the minimum x-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code x} is greater than the maximum x-coordinate\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n+    @Override\n     public int minY() {\n         return this.minY;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * Set the minimum y-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code y} is greater than the maximum y-coordinate\n-     */\n-    public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n+        dest.minX = x;\n+        return dest;\n     }\n \n-    /**\n-     * The z-coordinate of the minimum corner\n-     */\n-    public int minZ() {\n-        return this.minZ;\n+    public BlockRegion minX(int x) {\n+        return this.minX(x, this);\n     }\n \n-    /**\n-     * the minimum coordinate of the first block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #minZ()}\n-     */\n-    @Deprecated\n-    public int getMinZ() {\n-        return this.minZ;\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n+        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n+        dest.minY = y;\n+        return dest;\n     }\n \n-    /**\n-     * Set the minimum z-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code z} is greater than the maximum z-coordinate\n-     */\n-    public BlockRegion minZ(int z) {\n-        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n-        this.minZ = z;\n-        return this;\n+    public BlockRegion minY(int y) {\n+        return this.minY(y, this);\n     }\n \n-    /**\n-     * Get the block coordinate of the minimum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest} after the result has been set\n-     */\n-    public Vector3i getMin(Vector3i dest) {\n-        return dest.set(minX, minY, minZ);\n+    @Override\n+    public BlockRegion minZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n+        dest.minZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Set the coordinates of the minimum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is greater than the respective component of the max\n-     *         corner\n-     */\n-    public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min.x(), min.y(), min.z());\n+    public BlockRegion minZ(int z) {\n+        return this.minZ(z, this);\n     }\n \n-    /**\n-     * Set the coordinates of the minimum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is greater than the respective component of the max\n-     *         corner\n-     */\n-    public BlockRegion setMin(int minX, int minY, int minZ) {\n+    @Override\n+    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n         Preconditions.checkArgument(minX <= this.maxX || this.maxX == Integer.MIN_VALUE);\n         Preconditions.checkArgument(minY <= this.maxY || this.maxX == Integer.MIN_VALUE);\n         Preconditions.checkArgument(minZ <= this.maxZ || this.maxX == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        this.minZ = minZ;\n-        return this;\n+        dest.minX = minX;\n+        dest.minY = minY;\n+        dest.minZ = minZ;\n+        return dest;\n     }\n \n-    // -- max --------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The x-coordinate of the maximum corner\n-     */\n-    public int maxX() {\n-        return this.maxX;\n+    public BlockRegion setMin(int x, int y, int z) {\n+        return this.setMin(x, y, z, this);\n     }\n \n-    /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #maxX()}\n-     */\n-    @Deprecated\n-    public int getMaxX() {\n-        return this.maxX;\n+    public BlockRegion setMin(Vector3ic min) {\n+        return this.setMin(min, this);\n     }\n \n-    /**\n-     * Set the maximum x-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code x} is smaller than the minimum x-coordinate\n-     */\n-    public BlockRegion maxX(int x) {\n-        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n-        this.maxX = x;\n-        return this;\n+    public BlockRegion addMin(int dx, int dy, int dz) {\n+        return this.addMin(dx, dy, dz, this);\n     }\n \n-    /**\n-     * The y-coordinate of the maximum corner\n-     */\n-    public int maxY() {\n-        return this.maxY;\n+    public BlockRegion addMin(Vector3ic dmin) {\n+        return this.addMin(dmin, this);\n     }\n \n-    /**\n-     * the maximum coordinate of the second block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #maxY()}\n-     */\n-    @Deprecated\n-    public int getMaxY() {\n-        return this.maxY;\n-    }\n \n-    /**\n-     * Set the maximum y-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code y} is smaller than the minimum y-coordinate\n-     */\n-    public BlockRegion maxY(int y) {\n-        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n-        this.maxY = y;\n-        return this;\n+    // -- max --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int maxX() {\n+        return this.maxX;\n     }\n \n-    /**\n-     * The z-coordinate of the maximum corner\n-     */\n-    public int maxZ() {\n-        return this.maxZ;\n+    @Override\n+    public int maxY() {\n+        return this.maxY;\n     }\n \n-    /**\n-     * the maximum coordinate of the second block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #maxZ()}\n-     */\n-    @Deprecated\n-    public int getMaxZ() {\n+    @Override\n+    public int maxZ() {\n         return this.maxZ;\n     }\n \n-    /**\n-     * Set the maximum z-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code z} is smaller than the minimum z-coordinate\n-     */\n-    public BlockRegion maxZ(int z) {\n-        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxZ = z;\n-        return this;\n+    @Override\n+    public BlockRegion maxX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n+        dest.maxX = x;\n+        return dest;\n     }\n \n-    /**\n-     * Get the block coordinate of the maximum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest} after the result has been set\n-     */\n-    public Vector3i getMax(Vector3i dest) {\n-        return dest.set(maxX, maxY, maxZ);\n+    public BlockRegion maxX(int x) {\n+        return this.maxX(x, this);\n     }\n \n-    /**\n-     * Set the coordinates of the maximum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is smaller than the respective component of the minimum\n-     *         corner\n-     */\n-    public BlockRegion setMax(Vector3ic max) {\n-        return this.setMax(max.x(), max.y(), max.z());\n+    @Override\n+    public BlockRegion maxY(int y, BlockRegion dest) {\n+        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n+        dest.maxY = y;\n+        return dest;\n     }\n \n-    /**\n-     * Set the coordinates of the maximum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is smaller than the respective component of the minimum\n-     *         corner\n-     */\n-    public BlockRegion setMax(int maxX, int maxY, int maxZ) {\n-        Preconditions.checkArgument(maxX >= this.minX || this.minX == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxY >= this.minY || this.minY == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxZ >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        this.maxZ = maxZ;\n-        return this;\n+    public BlockRegion maxY(int y) {\n+        return this.maxY(y, this);\n     }\n \n-    // -- size -------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * Set the size of the block region from the minimum corner.\n-     *\n-     * @param x the x coordinate to set the size; must be > 0\n-     * @param y the y coordinate to set the size; must be > 0\n-     * @param z the z coordinate to set the size; must be > 0\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n-     */\n-    public BlockRegion setSize(int x, int y, int z) {\n-        Preconditions.checkArgument(x > 0);\n-        Preconditions.checkArgument(y > 0);\n-        Preconditions.checkArgument(z > 0);\n-        this.maxX = this.minX + x - 1;\n-        this.maxY = this.minY + y - 1;\n-        this.maxZ = this.minZ + z - 1;\n-        return this;\n+    @Override\n+    public BlockRegion maxZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n+        dest.maxZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Set the size of the block region from the minimum corner.\n-     *\n-     * @param size the size to set; all dimensions must be > 0\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n-     */\n-    public BlockRegion setSize(Vector3ic size) {\n-        return setSize(size.x(), size.y(), size.z());\n+    public BlockRegion maxZ(int z) {\n+        return this.maxZ(z, this);\n     }\n \n-    /**\n-     * The number of blocks in this region along the +x, +y, +z  axis from the minimum to the maximum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector3i getSize(Vector3i dest) {\n-        return dest.set(sizeX(), sizeY(), sizeZ());\n+    @Override\n+    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n+        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n+        dest.maxX = x;\n+        dest.maxY = y;\n+        dest.maxZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * The number of blocks on the x axis.\n-     */\n-    public int sizeX() {\n-        return this.maxX - this.minX + 1;\n+    public BlockRegion setMax(int x, int y, int z) {\n+        return this.setMax(x, y, z, this);\n     }\n \n-    /**\n-     * @see #sizeX()\n-     */\n-    public int getSizeX() {\n-        return sizeX();\n+    public BlockRegion setMax(Vector3ic max) {\n+        return this.setMax(max, this);\n     }\n \n-    /**\n-     * The number of blocks on the y axis.\n-     */\n-    public int sizeY() {\n-        return this.maxY - this.minY + 1;\n+    public BlockRegion addMax(int dx, int dy, int dz) {\n+        return this.addMax(dx, dy, dz, this);\n     }\n \n-    /**\n-     * @see #sizeY()\n-     */\n-    public int getSizeY() {\n-        return sizeY();\n+    public BlockRegion addMax(Vector3ic dmax) {\n+        return this.addMax(dmax, this);\n     }\n \n-    /**\n-     * The number of blocks on the z axis.\n-     */\n-    public int sizeZ() {\n-        return this.maxZ - this.minZ + 1;\n-    }\n+    // -- size -------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * @see #sizeZ()\n-     */\n-    public int getSizeZ() {\n-        return sizeZ();\n+    @Override\n+    public BlockRegion setSize(int x, int y, int z, BlockRegion dest) {\n+        Preconditions.checkArgument(x > 0);\n+        Preconditions.checkArgument(y > 0);\n+        Preconditions.checkArgument(z > 0);\n+        dest.maxX = this.minX + x - 1;\n+        dest.maxY = this.minY + y - 1;\n+        dest.maxZ = this.minZ + z - 1;\n+        return dest;\n     }\n \n-    // -- world ------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The bounding box in world coordinates.\n-     * <p>\n-     * The bounding box of a single block at {@code (x, y, z)} is centered at the integer coordinate {@code (x, y, z)}\n-     * and extents by {@code 0.5} in each dimension.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest}\n-     */\n-    //TODO: 1.9.26 has a constant interface for aabbf\n-    public AABBf getBounds(AABBf dest) {\n-        dest.minX = minX - .5f;\n-        dest.minY = minY - .5f;\n-        dest.minZ = minZ - .5f;\n-\n-        dest.maxX = maxX + .5f;\n-        dest.maxY = maxY + .5f;\n-        dest.maxZ = maxZ + .5f;\n-\n-        return dest;\n+    public BlockRegion setSize(int x, int y, int z) {\n+        return this.setSize(x, y, z, this);\n     }\n \n-    /**\n-     * The center of the region in world coordinates if the region is valid; {@link Float#NaN} otherwise.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest}\n-     */\n-    public Vector3f center(Vector3f dest) {\n-        if (!this.isValid()) {\n-            return dest.set(Float.NaN);\n-        }\n-        return dest.set(\n-                (this.minX - .5f) + ((this.maxX - this.minX + 1.0f) / 2.0f),\n-                (this.minY - .5f) + ((this.maxY - this.minY + 1.0f) / 2.0f),\n-                (this.minZ - .5f) + ((this.maxZ - this.minZ + 1.0f) / 2.0f)\n-        );\n+    public BlockRegion setSize(Vector3ic size) {\n+        return setSize(size.x(), size.y(), size.z());\n     }\n \n     // -- IN-PLACE MUTATION ------------------------------------------------------------------------------------------//\n+    @Override\n+    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = Math.min(this.minX, x);\n+        dest.minY = Math.min(this.minY, y);\n+        dest.minZ = Math.min(this.minZ, z);\n+\n+        dest.maxX = Math.max(this.maxX, x);\n+        dest.maxY = Math.max(this.maxY, y);\n+        dest.maxZ = Math.max(this.maxZ, z);\n+        return dest;\n+    }\n \n-    /**\n-     * Compute the union of this region and the given block coordinate.\n-     *\n-     * @param x the x coordinate of the block\n-     * @param y the y coordinate of the block\n-     * @param z the z coordinate of the block\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(int x, int y, int z) {\n-        this.minX = Math.min(this.minX, x);\n-        this.minY = Math.min(this.minY, y);\n-        this.minZ = Math.min(this.minZ, z);\n-\n-        this.maxX = Math.max(this.maxX, x);\n-        this.maxY = Math.max(this.maxY, y);\n-        this.maxZ = Math.max(this.maxZ, z);\n-        return this;\n+        return this.union(x, y, z, this);\n     }\n \n-    /**\n-     * Compute the union of this region and the given block coordinate.\n-     *\n-     * @param pos the position of the block\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(Vector3ic pos) {\n-        return union(pos.x(), pos.y(), pos.z());\n+        return union(pos.x(), pos.y(), pos.z(), this);\n     }\n \n-    /**\n-     * Compute the union of this region and the other region.\n-     *\n-     * @param other {@link BlockRegion}\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(BlockRegion other) {\n-        return this.union(other.minX, other.minY, other.minZ).union(other.maxX, other.maxY, other.maxZ);\n-    }\n-\n-    /**\n-     * Compute the union of this region and the given block entity.\n-     * <p>\n-     * An entity is a block entity if it has the {@link BlockComponent}. This region will not be modified if the given\n-     * entity does not have a {@link BlockComponent}.\n-     *\n-     * @param blockRef entityRef that describes a block\n-     * @return this region (after modification)\n-     */\n-    public BlockRegion union(EntityRef blockRef) {\n-        BlockComponent component = blockRef.getComponent(BlockComponent.class);\n-        if (component != null) {\n-            return this.union(component.position.x(), component.position.y(), component.position.z());\n-        }\n-        return this;\n+        return this.union(other, this);\n     }\n \n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Compute the intersection of this region with the {@code other} region.\n-     * <p>\n-     * NOTE: If the regions don't intersect this region will become invalid!\n-     *\n-     * @param other the other region\n-     * @return this region (after modification) or {@link Optional#empty()} if the regions don't intersect\n-     */\n-    public Optional<BlockRegion> intersect(BlockRegion other) {\n-        this.minX = Math.max(minX, other.minX);\n-        this.minY = Math.max(minY, other.minY);\n-        this.minZ = Math.max(minZ, other.minZ);\n+    @Override\n+    public Optional<BlockRegion> intersect(BlockRegion other, BlockRegion dest) {\n+        dest.minX = Math.max(minX, other.minX);\n+        dest.minY = Math.max(minY, other.minY);\n+        dest.minZ = Math.max(minZ, other.minZ);\n \n-        this.maxX = Math.min(maxX, other.maxX);\n-        this.maxY = Math.min(maxY, other.maxY);\n-        this.maxZ = Math.min(maxZ, other.maxZ);\n+        dest.maxX = Math.min(maxX, other.maxX);\n+        dest.maxY = Math.min(maxY, other.maxY);\n+        dest.maxZ = Math.min(maxZ, other.maxZ);\n \n-        if (this.isValid()) {\n-            return Optional.of(this);\n+        if (dest.isValid()) {\n+            return Optional.of(dest);\n         } else {\n             return Optional.empty();\n         }\n     }\n \n+    public Optional<BlockRegion> intersect(BlockRegion other) {\n+        return this.intersect(other, this);\n+    }\n+\n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Translate this region by the given vector {@code (x, y, z))}.\n-     *\n-     * @param x the x coordinate to translate by\n-     * @param y the y coordinate to translate by\n-     * @param z the z coordinate to translate by\n-     * @return this region (after modification)\n-     */\n+    @Override\n+    public BlockRegion translate(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = this.minX + x;\n+        dest.minY = this.minY + y;\n+        dest.minZ = this.minZ + z;\n+        dest.maxX = this.maxX + x;\n+        dest.maxY = this.maxY + y;\n+        dest.maxZ = this.maxZ + z;\n+        return dest;\n+    }\n+\n     public BlockRegion translate(int x, int y, int z) {\n-        this.minX = this.minX + x;\n-        this.minY = this.minY + y;\n-        this.minZ = this.minZ + z;\n-        this.maxX = this.maxX + x;\n-        this.maxY = this.maxY + y;\n-        this.maxZ = this.maxZ + z;\n-        return this;\n+        return this.translate(x, y, z, this);\n     }\n \n-    /**\n-     * Translate this region by the given vector {@code vec}.\n-     *\n-     * @param vec the vector to translate by\n-     * @return this region (after modification)\n-     */\n     public BlockRegion translate(Vector3ic vec) {\n         return translate(vec.x(), vec.y(), vec.z());\n     }\n \n     // -- extend -----------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     *\n-     * @param extentX the amount of blocks to extend this region by along the x axis in both directions\n-     * @param extentY the amount of blocks to extend this region by along the y axis in both directions\n-     * @param extentZ the amount of blocks to extend this region by along the z axis in both directions\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(int extentX, int extentY, int extentZ) {\n-        Preconditions.checkArgument(sizeX() + 2 * extentX > 0);\n-        Preconditions.checkArgument(sizeY() + 2 * extentY > 0);\n-        Preconditions.checkArgument(sizeZ() + 2 * extentZ > 0);\n-        this.minX = this.minX - extentX;\n-        this.minY = this.minY - extentY;\n-        this.minZ = this.minZ - extentZ;\n-\n-        this.maxX = this.maxX + extentX;\n-        this.maxY = this.maxY + extentY;\n-        this.maxZ = this.maxZ + extentZ;\n+    @Override\n+    public BlockRegion expand(int dx, int dy, int dz, BlockRegion dest) {\n+        Preconditions.checkArgument(getSizeX() + 2 * dx > 0);\n+        Preconditions.checkArgument(getSizeY() + 2 * dy > 0);\n+        Preconditions.checkArgument(getSizeZ() + 2 * dz > 0);\n+        dest.minX = this.minX - dx;\n+        dest.minY = this.minY - dy;\n+        dest.minZ = this.minZ - dz;\n+\n+        dest.maxX = this.maxX + dx;\n+        dest.maxY = this.maxY + dy;\n+        dest.maxZ = this.maxZ + dz;\n \n-        return this;\n+        return dest;\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     *\n-     * @param extents the amount of blocks to extend this region by\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(Vector3ic extents) {\n-        return extend(extents.x(), extents.y(), extents.z());\n+    public BlockRegion expand(int dx, int dy, int dz) {\n+        return this.expand(dx, dy, dz, this);\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     * <p>\n-     * The extents will be floored for each dimension.\n-     *\n-     * @param extentX the amount of blocks to extend this region by along the x axis in both directions\n-     * @param extentY the amount of blocks to extend this region by along the y axis in both directions\n-     * @param extentZ the amount of blocks to extend this region by along the z axis in both directions\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(float extentX, float extentY, float extentZ) {\n-        return extend(\n-                Math.roundUsing(extentX, RoundingMode.FLOOR),\n-                Math.roundUsing(extentY, RoundingMode.FLOOR),\n-                Math.roundUsing(extentZ, RoundingMode.FLOOR));\n+    public BlockRegion expand(Vector3ic extents) {\n+        return expand(extents.x(), extents.y(), extents.z());\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     * <p>\n-     * The extents will be floored for each dimension.\n-     *\n-     * @param extents the amount of blocks to extend this region by\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(Vector3f extents) {\n-        return extend(extents.x(), extents.y(), extents.z());\n+    public BlockRegion expand(float dx, float dy, float dz) {\n+        return this.expand(dx, dy, dz, this);\n+    }\n+\n+    public BlockRegion expand(Vector3f extents) {\n+        return expand(extents.x(), extents.y(), extents.z());\n     }\n \n     // -- transform --------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Apply the given {@link Matrix4fc#isAffine() affine} transformation to this {@link BlockRegion}.\n-     * <p>\n-     * The matrix in {@code m} <i>must</i> be {@link Matrix4fc#isAffine() affine}.\n-     *\n-     * @param m the affine transformation matrix\n-     * @param dest will hold the result\n-     * @return {@code dest} (after modification)\n-     * @throws IllegalArgumentException if the matrix {@code m} is not {@link Matrix4fc#isAffine() affine}\n-     */\n+    @Override\n     public BlockRegion transform(Matrix4fc m, BlockRegion dest) {\n         Preconditions.checkArgument(m.isAffine());\n         float dx = maxX - minX;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MTc1OQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r547051759", "bodyText": "similar problem here.", "author": "pollend", "createdAt": "2020-12-22T03:49:03Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -267,9 +303,10 @@ public int getMaxX() {\n     }\n \n     /**\n-     * set the maximum coordinate of the second block x\n+     * Set the maximum x-coordinate of this region.\n      *\n-     * @return the minX\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if {@code x} is smaller than the minimum x-coordinate\n      */\n     public BlockRegion maxX(int x) {\n         Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);", "originalCommit": "f7ac93f0698378f4ad0c7937fd21ca91efa32a49", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6799c3ad88cc478e6dfeac8279416677b54c833e", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 35bc3dfea..6232b190b 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -119,618 +113,396 @@ public BlockRegion(Vector3ic block) {\n      * Create a new copy of the given block region {@code source}.\n      *\n      * @param source the block region to copy.\n-     * @see #copy()\n      */\n     public BlockRegion(BlockRegion source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n+     * Reset both the minimum and maximum corner of this region.\n      *\n      * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX);\n+        Preconditions.checkArgument(minY <= maxY);\n+        Preconditions.checkArgument(minZ <= maxZ);\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n         return this;\n     }\n \n     /**\n-     * Create a fresh copy of this block region.\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @see BlockRegion#BlockRegion(BlockRegion)\n-     */\n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n-    }\n-\n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The x-coordinate of the minimum corner\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public int minX() {\n-        return this.minX;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    public BlockRegion set(BlockRegion source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * Set the minimum x-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code x} is greater than the maximum x-coordinate\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n+    @Override\n     public int minY() {\n         return this.minY;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * Set the minimum y-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code y} is greater than the maximum y-coordinate\n-     */\n-    public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n+        dest.minX = x;\n+        return dest;\n     }\n \n-    /**\n-     * The z-coordinate of the minimum corner\n-     */\n-    public int minZ() {\n-        return this.minZ;\n+    public BlockRegion minX(int x) {\n+        return this.minX(x, this);\n     }\n \n-    /**\n-     * the minimum coordinate of the first block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #minZ()}\n-     */\n-    @Deprecated\n-    public int getMinZ() {\n-        return this.minZ;\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n+        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n+        dest.minY = y;\n+        return dest;\n     }\n \n-    /**\n-     * Set the minimum z-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code z} is greater than the maximum z-coordinate\n-     */\n-    public BlockRegion minZ(int z) {\n-        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n-        this.minZ = z;\n-        return this;\n+    public BlockRegion minY(int y) {\n+        return this.minY(y, this);\n     }\n \n-    /**\n-     * Get the block coordinate of the minimum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest} after the result has been set\n-     */\n-    public Vector3i getMin(Vector3i dest) {\n-        return dest.set(minX, minY, minZ);\n+    @Override\n+    public BlockRegion minZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n+        dest.minZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Set the coordinates of the minimum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is greater than the respective component of the max\n-     *         corner\n-     */\n-    public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min.x(), min.y(), min.z());\n+    public BlockRegion minZ(int z) {\n+        return this.minZ(z, this);\n     }\n \n-    /**\n-     * Set the coordinates of the minimum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is greater than the respective component of the max\n-     *         corner\n-     */\n-    public BlockRegion setMin(int minX, int minY, int minZ) {\n+    @Override\n+    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n         Preconditions.checkArgument(minX <= this.maxX || this.maxX == Integer.MIN_VALUE);\n         Preconditions.checkArgument(minY <= this.maxY || this.maxX == Integer.MIN_VALUE);\n         Preconditions.checkArgument(minZ <= this.maxZ || this.maxX == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        this.minZ = minZ;\n-        return this;\n+        dest.minX = minX;\n+        dest.minY = minY;\n+        dest.minZ = minZ;\n+        return dest;\n     }\n \n-    // -- max --------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The x-coordinate of the maximum corner\n-     */\n-    public int maxX() {\n-        return this.maxX;\n+    public BlockRegion setMin(int x, int y, int z) {\n+        return this.setMin(x, y, z, this);\n     }\n \n-    /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #maxX()}\n-     */\n-    @Deprecated\n-    public int getMaxX() {\n-        return this.maxX;\n+    public BlockRegion setMin(Vector3ic min) {\n+        return this.setMin(min, this);\n     }\n \n-    /**\n-     * Set the maximum x-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code x} is smaller than the minimum x-coordinate\n-     */\n-    public BlockRegion maxX(int x) {\n-        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n-        this.maxX = x;\n-        return this;\n+    public BlockRegion addMin(int dx, int dy, int dz) {\n+        return this.addMin(dx, dy, dz, this);\n     }\n \n-    /**\n-     * The y-coordinate of the maximum corner\n-     */\n-    public int maxY() {\n-        return this.maxY;\n+    public BlockRegion addMin(Vector3ic dmin) {\n+        return this.addMin(dmin, this);\n     }\n \n-    /**\n-     * the maximum coordinate of the second block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #maxY()}\n-     */\n-    @Deprecated\n-    public int getMaxY() {\n-        return this.maxY;\n-    }\n \n-    /**\n-     * Set the maximum y-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code y} is smaller than the minimum y-coordinate\n-     */\n-    public BlockRegion maxY(int y) {\n-        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n-        this.maxY = y;\n-        return this;\n+    // -- max --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int maxX() {\n+        return this.maxX;\n     }\n \n-    /**\n-     * The z-coordinate of the maximum corner\n-     */\n-    public int maxZ() {\n-        return this.maxZ;\n+    @Override\n+    public int maxY() {\n+        return this.maxY;\n     }\n \n-    /**\n-     * the maximum coordinate of the second block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #maxZ()}\n-     */\n-    @Deprecated\n-    public int getMaxZ() {\n+    @Override\n+    public int maxZ() {\n         return this.maxZ;\n     }\n \n-    /**\n-     * Set the maximum z-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code z} is smaller than the minimum z-coordinate\n-     */\n-    public BlockRegion maxZ(int z) {\n-        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxZ = z;\n-        return this;\n+    @Override\n+    public BlockRegion maxX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n+        dest.maxX = x;\n+        return dest;\n     }\n \n-    /**\n-     * Get the block coordinate of the maximum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest} after the result has been set\n-     */\n-    public Vector3i getMax(Vector3i dest) {\n-        return dest.set(maxX, maxY, maxZ);\n+    public BlockRegion maxX(int x) {\n+        return this.maxX(x, this);\n     }\n \n-    /**\n-     * Set the coordinates of the maximum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is smaller than the respective component of the minimum\n-     *         corner\n-     */\n-    public BlockRegion setMax(Vector3ic max) {\n-        return this.setMax(max.x(), max.y(), max.z());\n+    @Override\n+    public BlockRegion maxY(int y, BlockRegion dest) {\n+        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n+        dest.maxY = y;\n+        return dest;\n     }\n \n-    /**\n-     * Set the coordinates of the maximum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is smaller than the respective component of the minimum\n-     *         corner\n-     */\n-    public BlockRegion setMax(int maxX, int maxY, int maxZ) {\n-        Preconditions.checkArgument(maxX >= this.minX || this.minX == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxY >= this.minY || this.minY == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxZ >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        this.maxZ = maxZ;\n-        return this;\n+    public BlockRegion maxY(int y) {\n+        return this.maxY(y, this);\n     }\n \n-    // -- size -------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * Set the size of the block region from the minimum corner.\n-     *\n-     * @param x the x coordinate to set the size; must be > 0\n-     * @param y the y coordinate to set the size; must be > 0\n-     * @param z the z coordinate to set the size; must be > 0\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n-     */\n-    public BlockRegion setSize(int x, int y, int z) {\n-        Preconditions.checkArgument(x > 0);\n-        Preconditions.checkArgument(y > 0);\n-        Preconditions.checkArgument(z > 0);\n-        this.maxX = this.minX + x - 1;\n-        this.maxY = this.minY + y - 1;\n-        this.maxZ = this.minZ + z - 1;\n-        return this;\n+    @Override\n+    public BlockRegion maxZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n+        dest.maxZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Set the size of the block region from the minimum corner.\n-     *\n-     * @param size the size to set; all dimensions must be > 0\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n-     */\n-    public BlockRegion setSize(Vector3ic size) {\n-        return setSize(size.x(), size.y(), size.z());\n+    public BlockRegion maxZ(int z) {\n+        return this.maxZ(z, this);\n     }\n \n-    /**\n-     * The number of blocks in this region along the +x, +y, +z  axis from the minimum to the maximum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector3i getSize(Vector3i dest) {\n-        return dest.set(sizeX(), sizeY(), sizeZ());\n+    @Override\n+    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n+        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n+        dest.maxX = x;\n+        dest.maxY = y;\n+        dest.maxZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * The number of blocks on the x axis.\n-     */\n-    public int sizeX() {\n-        return this.maxX - this.minX + 1;\n+    public BlockRegion setMax(int x, int y, int z) {\n+        return this.setMax(x, y, z, this);\n     }\n \n-    /**\n-     * @see #sizeX()\n-     */\n-    public int getSizeX() {\n-        return sizeX();\n+    public BlockRegion setMax(Vector3ic max) {\n+        return this.setMax(max, this);\n     }\n \n-    /**\n-     * The number of blocks on the y axis.\n-     */\n-    public int sizeY() {\n-        return this.maxY - this.minY + 1;\n+    public BlockRegion addMax(int dx, int dy, int dz) {\n+        return this.addMax(dx, dy, dz, this);\n     }\n \n-    /**\n-     * @see #sizeY()\n-     */\n-    public int getSizeY() {\n-        return sizeY();\n+    public BlockRegion addMax(Vector3ic dmax) {\n+        return this.addMax(dmax, this);\n     }\n \n-    /**\n-     * The number of blocks on the z axis.\n-     */\n-    public int sizeZ() {\n-        return this.maxZ - this.minZ + 1;\n-    }\n+    // -- size -------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * @see #sizeZ()\n-     */\n-    public int getSizeZ() {\n-        return sizeZ();\n+    @Override\n+    public BlockRegion setSize(int x, int y, int z, BlockRegion dest) {\n+        Preconditions.checkArgument(x > 0);\n+        Preconditions.checkArgument(y > 0);\n+        Preconditions.checkArgument(z > 0);\n+        dest.maxX = this.minX + x - 1;\n+        dest.maxY = this.minY + y - 1;\n+        dest.maxZ = this.minZ + z - 1;\n+        return dest;\n     }\n \n-    // -- world ------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The bounding box in world coordinates.\n-     * <p>\n-     * The bounding box of a single block at {@code (x, y, z)} is centered at the integer coordinate {@code (x, y, z)}\n-     * and extents by {@code 0.5} in each dimension.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest}\n-     */\n-    //TODO: 1.9.26 has a constant interface for aabbf\n-    public AABBf getBounds(AABBf dest) {\n-        dest.minX = minX - .5f;\n-        dest.minY = minY - .5f;\n-        dest.minZ = minZ - .5f;\n-\n-        dest.maxX = maxX + .5f;\n-        dest.maxY = maxY + .5f;\n-        dest.maxZ = maxZ + .5f;\n-\n-        return dest;\n+    public BlockRegion setSize(int x, int y, int z) {\n+        return this.setSize(x, y, z, this);\n     }\n \n-    /**\n-     * The center of the region in world coordinates if the region is valid; {@link Float#NaN} otherwise.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest}\n-     */\n-    public Vector3f center(Vector3f dest) {\n-        if (!this.isValid()) {\n-            return dest.set(Float.NaN);\n-        }\n-        return dest.set(\n-                (this.minX - .5f) + ((this.maxX - this.minX + 1.0f) / 2.0f),\n-                (this.minY - .5f) + ((this.maxY - this.minY + 1.0f) / 2.0f),\n-                (this.minZ - .5f) + ((this.maxZ - this.minZ + 1.0f) / 2.0f)\n-        );\n+    public BlockRegion setSize(Vector3ic size) {\n+        return setSize(size.x(), size.y(), size.z());\n     }\n \n     // -- IN-PLACE MUTATION ------------------------------------------------------------------------------------------//\n+    @Override\n+    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = Math.min(this.minX, x);\n+        dest.minY = Math.min(this.minY, y);\n+        dest.minZ = Math.min(this.minZ, z);\n+\n+        dest.maxX = Math.max(this.maxX, x);\n+        dest.maxY = Math.max(this.maxY, y);\n+        dest.maxZ = Math.max(this.maxZ, z);\n+        return dest;\n+    }\n \n-    /**\n-     * Compute the union of this region and the given block coordinate.\n-     *\n-     * @param x the x coordinate of the block\n-     * @param y the y coordinate of the block\n-     * @param z the z coordinate of the block\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(int x, int y, int z) {\n-        this.minX = Math.min(this.minX, x);\n-        this.minY = Math.min(this.minY, y);\n-        this.minZ = Math.min(this.minZ, z);\n-\n-        this.maxX = Math.max(this.maxX, x);\n-        this.maxY = Math.max(this.maxY, y);\n-        this.maxZ = Math.max(this.maxZ, z);\n-        return this;\n+        return this.union(x, y, z, this);\n     }\n \n-    /**\n-     * Compute the union of this region and the given block coordinate.\n-     *\n-     * @param pos the position of the block\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(Vector3ic pos) {\n-        return union(pos.x(), pos.y(), pos.z());\n+        return union(pos.x(), pos.y(), pos.z(), this);\n     }\n \n-    /**\n-     * Compute the union of this region and the other region.\n-     *\n-     * @param other {@link BlockRegion}\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(BlockRegion other) {\n-        return this.union(other.minX, other.minY, other.minZ).union(other.maxX, other.maxY, other.maxZ);\n-    }\n-\n-    /**\n-     * Compute the union of this region and the given block entity.\n-     * <p>\n-     * An entity is a block entity if it has the {@link BlockComponent}. This region will not be modified if the given\n-     * entity does not have a {@link BlockComponent}.\n-     *\n-     * @param blockRef entityRef that describes a block\n-     * @return this region (after modification)\n-     */\n-    public BlockRegion union(EntityRef blockRef) {\n-        BlockComponent component = blockRef.getComponent(BlockComponent.class);\n-        if (component != null) {\n-            return this.union(component.position.x(), component.position.y(), component.position.z());\n-        }\n-        return this;\n+        return this.union(other, this);\n     }\n \n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Compute the intersection of this region with the {@code other} region.\n-     * <p>\n-     * NOTE: If the regions don't intersect this region will become invalid!\n-     *\n-     * @param other the other region\n-     * @return this region (after modification) or {@link Optional#empty()} if the regions don't intersect\n-     */\n-    public Optional<BlockRegion> intersect(BlockRegion other) {\n-        this.minX = Math.max(minX, other.minX);\n-        this.minY = Math.max(minY, other.minY);\n-        this.minZ = Math.max(minZ, other.minZ);\n+    @Override\n+    public Optional<BlockRegion> intersect(BlockRegion other, BlockRegion dest) {\n+        dest.minX = Math.max(minX, other.minX);\n+        dest.minY = Math.max(minY, other.minY);\n+        dest.minZ = Math.max(minZ, other.minZ);\n \n-        this.maxX = Math.min(maxX, other.maxX);\n-        this.maxY = Math.min(maxY, other.maxY);\n-        this.maxZ = Math.min(maxZ, other.maxZ);\n+        dest.maxX = Math.min(maxX, other.maxX);\n+        dest.maxY = Math.min(maxY, other.maxY);\n+        dest.maxZ = Math.min(maxZ, other.maxZ);\n \n-        if (this.isValid()) {\n-            return Optional.of(this);\n+        if (dest.isValid()) {\n+            return Optional.of(dest);\n         } else {\n             return Optional.empty();\n         }\n     }\n \n+    public Optional<BlockRegion> intersect(BlockRegion other) {\n+        return this.intersect(other, this);\n+    }\n+\n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Translate this region by the given vector {@code (x, y, z))}.\n-     *\n-     * @param x the x coordinate to translate by\n-     * @param y the y coordinate to translate by\n-     * @param z the z coordinate to translate by\n-     * @return this region (after modification)\n-     */\n+    @Override\n+    public BlockRegion translate(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = this.minX + x;\n+        dest.minY = this.minY + y;\n+        dest.minZ = this.minZ + z;\n+        dest.maxX = this.maxX + x;\n+        dest.maxY = this.maxY + y;\n+        dest.maxZ = this.maxZ + z;\n+        return dest;\n+    }\n+\n     public BlockRegion translate(int x, int y, int z) {\n-        this.minX = this.minX + x;\n-        this.minY = this.minY + y;\n-        this.minZ = this.minZ + z;\n-        this.maxX = this.maxX + x;\n-        this.maxY = this.maxY + y;\n-        this.maxZ = this.maxZ + z;\n-        return this;\n+        return this.translate(x, y, z, this);\n     }\n \n-    /**\n-     * Translate this region by the given vector {@code vec}.\n-     *\n-     * @param vec the vector to translate by\n-     * @return this region (after modification)\n-     */\n     public BlockRegion translate(Vector3ic vec) {\n         return translate(vec.x(), vec.y(), vec.z());\n     }\n \n     // -- extend -----------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     *\n-     * @param extentX the amount of blocks to extend this region by along the x axis in both directions\n-     * @param extentY the amount of blocks to extend this region by along the y axis in both directions\n-     * @param extentZ the amount of blocks to extend this region by along the z axis in both directions\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(int extentX, int extentY, int extentZ) {\n-        Preconditions.checkArgument(sizeX() + 2 * extentX > 0);\n-        Preconditions.checkArgument(sizeY() + 2 * extentY > 0);\n-        Preconditions.checkArgument(sizeZ() + 2 * extentZ > 0);\n-        this.minX = this.minX - extentX;\n-        this.minY = this.minY - extentY;\n-        this.minZ = this.minZ - extentZ;\n-\n-        this.maxX = this.maxX + extentX;\n-        this.maxY = this.maxY + extentY;\n-        this.maxZ = this.maxZ + extentZ;\n+    @Override\n+    public BlockRegion expand(int dx, int dy, int dz, BlockRegion dest) {\n+        Preconditions.checkArgument(getSizeX() + 2 * dx > 0);\n+        Preconditions.checkArgument(getSizeY() + 2 * dy > 0);\n+        Preconditions.checkArgument(getSizeZ() + 2 * dz > 0);\n+        dest.minX = this.minX - dx;\n+        dest.minY = this.minY - dy;\n+        dest.minZ = this.minZ - dz;\n+\n+        dest.maxX = this.maxX + dx;\n+        dest.maxY = this.maxY + dy;\n+        dest.maxZ = this.maxZ + dz;\n \n-        return this;\n+        return dest;\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     *\n-     * @param extents the amount of blocks to extend this region by\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(Vector3ic extents) {\n-        return extend(extents.x(), extents.y(), extents.z());\n+    public BlockRegion expand(int dx, int dy, int dz) {\n+        return this.expand(dx, dy, dz, this);\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     * <p>\n-     * The extents will be floored for each dimension.\n-     *\n-     * @param extentX the amount of blocks to extend this region by along the x axis in both directions\n-     * @param extentY the amount of blocks to extend this region by along the y axis in both directions\n-     * @param extentZ the amount of blocks to extend this region by along the z axis in both directions\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(float extentX, float extentY, float extentZ) {\n-        return extend(\n-                Math.roundUsing(extentX, RoundingMode.FLOOR),\n-                Math.roundUsing(extentY, RoundingMode.FLOOR),\n-                Math.roundUsing(extentZ, RoundingMode.FLOOR));\n+    public BlockRegion expand(Vector3ic extents) {\n+        return expand(extents.x(), extents.y(), extents.z());\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     * <p>\n-     * The extents will be floored for each dimension.\n-     *\n-     * @param extents the amount of blocks to extend this region by\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(Vector3f extents) {\n-        return extend(extents.x(), extents.y(), extents.z());\n+    public BlockRegion expand(float dx, float dy, float dz) {\n+        return this.expand(dx, dy, dz, this);\n+    }\n+\n+    public BlockRegion expand(Vector3f extents) {\n+        return expand(extents.x(), extents.y(), extents.z());\n     }\n \n     // -- transform --------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Apply the given {@link Matrix4fc#isAffine() affine} transformation to this {@link BlockRegion}.\n-     * <p>\n-     * The matrix in {@code m} <i>must</i> be {@link Matrix4fc#isAffine() affine}.\n-     *\n-     * @param m the affine transformation matrix\n-     * @param dest will hold the result\n-     * @return {@code dest} (after modification)\n-     * @throws IllegalArgumentException if the matrix {@code m} is not {@link Matrix4fc#isAffine() affine}\n-     */\n+    @Override\n     public BlockRegion transform(Matrix4fc m, BlockRegion dest) {\n         Preconditions.checkArgument(m.isAffine());\n         float dx = maxX - minX;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MTk3Mw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r547051973", "bodyText": "There is really no need to offer both. it's either getSizeX or sizeX().", "author": "pollend", "createdAt": "2020-12-22T03:50:04Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -413,34 +455,58 @@ public Vector3i getSize(Vector3i dest) {\n     }\n \n     /**\n-     * The number of blocks on the X axis\n-     *\n-     * @return number of blocks in the X axis\n+     * The number of blocks on the x axis.\n      */\n     public int sizeX() {\n         return this.maxX - this.minX + 1;\n     }\n \n     /**\n-     * The number of blocks on the Y axis\n-     *\n-     * @return number of blocks in the Y axis\n+     * @see #sizeX()\n+     */\n+    public int getSizeX() {\n+        return sizeX();\n+    }\n+\n+    /**\n+     * The number of blocks on the y axis.", "originalCommit": "f7ac93f0698378f4ad0c7937fd21ca91efa32a49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIyNjcyNA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r547226724", "bodyText": "Yep, will remove sizeX() again as per comment on Discord: \"only use minX (without get for coordinates and/or main attributes?)\".", "author": "skaldarnar", "createdAt": "2020-12-22T11:33:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MTk3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6799c3ad88cc478e6dfeac8279416677b54c833e", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 35bc3dfea..6232b190b 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -119,618 +113,396 @@ public BlockRegion(Vector3ic block) {\n      * Create a new copy of the given block region {@code source}.\n      *\n      * @param source the block region to copy.\n-     * @see #copy()\n      */\n     public BlockRegion(BlockRegion source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n+     * Reset both the minimum and maximum corner of this region.\n      *\n      * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX);\n+        Preconditions.checkArgument(minY <= maxY);\n+        Preconditions.checkArgument(minZ <= maxZ);\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n         return this;\n     }\n \n     /**\n-     * Create a fresh copy of this block region.\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @see BlockRegion#BlockRegion(BlockRegion)\n-     */\n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n-    }\n-\n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The x-coordinate of the minimum corner\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public int minX() {\n-        return this.minX;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    public BlockRegion set(BlockRegion source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * Set the minimum x-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code x} is greater than the maximum x-coordinate\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n+    @Override\n     public int minY() {\n         return this.minY;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * Set the minimum y-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code y} is greater than the maximum y-coordinate\n-     */\n-    public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n+        dest.minX = x;\n+        return dest;\n     }\n \n-    /**\n-     * The z-coordinate of the minimum corner\n-     */\n-    public int minZ() {\n-        return this.minZ;\n+    public BlockRegion minX(int x) {\n+        return this.minX(x, this);\n     }\n \n-    /**\n-     * the minimum coordinate of the first block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #minZ()}\n-     */\n-    @Deprecated\n-    public int getMinZ() {\n-        return this.minZ;\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n+        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n+        dest.minY = y;\n+        return dest;\n     }\n \n-    /**\n-     * Set the minimum z-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code z} is greater than the maximum z-coordinate\n-     */\n-    public BlockRegion minZ(int z) {\n-        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n-        this.minZ = z;\n-        return this;\n+    public BlockRegion minY(int y) {\n+        return this.minY(y, this);\n     }\n \n-    /**\n-     * Get the block coordinate of the minimum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest} after the result has been set\n-     */\n-    public Vector3i getMin(Vector3i dest) {\n-        return dest.set(minX, minY, minZ);\n+    @Override\n+    public BlockRegion minZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n+        dest.minZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Set the coordinates of the minimum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is greater than the respective component of the max\n-     *         corner\n-     */\n-    public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min.x(), min.y(), min.z());\n+    public BlockRegion minZ(int z) {\n+        return this.minZ(z, this);\n     }\n \n-    /**\n-     * Set the coordinates of the minimum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is greater than the respective component of the max\n-     *         corner\n-     */\n-    public BlockRegion setMin(int minX, int minY, int minZ) {\n+    @Override\n+    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n         Preconditions.checkArgument(minX <= this.maxX || this.maxX == Integer.MIN_VALUE);\n         Preconditions.checkArgument(minY <= this.maxY || this.maxX == Integer.MIN_VALUE);\n         Preconditions.checkArgument(minZ <= this.maxZ || this.maxX == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        this.minZ = minZ;\n-        return this;\n+        dest.minX = minX;\n+        dest.minY = minY;\n+        dest.minZ = minZ;\n+        return dest;\n     }\n \n-    // -- max --------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The x-coordinate of the maximum corner\n-     */\n-    public int maxX() {\n-        return this.maxX;\n+    public BlockRegion setMin(int x, int y, int z) {\n+        return this.setMin(x, y, z, this);\n     }\n \n-    /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #maxX()}\n-     */\n-    @Deprecated\n-    public int getMaxX() {\n-        return this.maxX;\n+    public BlockRegion setMin(Vector3ic min) {\n+        return this.setMin(min, this);\n     }\n \n-    /**\n-     * Set the maximum x-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code x} is smaller than the minimum x-coordinate\n-     */\n-    public BlockRegion maxX(int x) {\n-        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n-        this.maxX = x;\n-        return this;\n+    public BlockRegion addMin(int dx, int dy, int dz) {\n+        return this.addMin(dx, dy, dz, this);\n     }\n \n-    /**\n-     * The y-coordinate of the maximum corner\n-     */\n-    public int maxY() {\n-        return this.maxY;\n+    public BlockRegion addMin(Vector3ic dmin) {\n+        return this.addMin(dmin, this);\n     }\n \n-    /**\n-     * the maximum coordinate of the second block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #maxY()}\n-     */\n-    @Deprecated\n-    public int getMaxY() {\n-        return this.maxY;\n-    }\n \n-    /**\n-     * Set the maximum y-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code y} is smaller than the minimum y-coordinate\n-     */\n-    public BlockRegion maxY(int y) {\n-        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n-        this.maxY = y;\n-        return this;\n+    // -- max --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int maxX() {\n+        return this.maxX;\n     }\n \n-    /**\n-     * The z-coordinate of the maximum corner\n-     */\n-    public int maxZ() {\n-        return this.maxZ;\n+    @Override\n+    public int maxY() {\n+        return this.maxY;\n     }\n \n-    /**\n-     * the maximum coordinate of the second block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #maxZ()}\n-     */\n-    @Deprecated\n-    public int getMaxZ() {\n+    @Override\n+    public int maxZ() {\n         return this.maxZ;\n     }\n \n-    /**\n-     * Set the maximum z-coordinate of this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if {@code z} is smaller than the minimum z-coordinate\n-     */\n-    public BlockRegion maxZ(int z) {\n-        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxZ = z;\n-        return this;\n+    @Override\n+    public BlockRegion maxX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n+        dest.maxX = x;\n+        return dest;\n     }\n \n-    /**\n-     * Get the block coordinate of the maximum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest} after the result has been set\n-     */\n-    public Vector3i getMax(Vector3i dest) {\n-        return dest.set(maxX, maxY, maxZ);\n+    public BlockRegion maxX(int x) {\n+        return this.maxX(x, this);\n     }\n \n-    /**\n-     * Set the coordinates of the maximum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is smaller than the respective component of the minimum\n-     *         corner\n-     */\n-    public BlockRegion setMax(Vector3ic max) {\n-        return this.setMax(max.x(), max.y(), max.z());\n+    @Override\n+    public BlockRegion maxY(int y, BlockRegion dest) {\n+        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n+        dest.maxY = y;\n+        return dest;\n     }\n \n-    /**\n-     * Set the coordinates of the maximum corner for this region.\n-     *\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if any dimension is smaller than the respective component of the minimum\n-     *         corner\n-     */\n-    public BlockRegion setMax(int maxX, int maxY, int maxZ) {\n-        Preconditions.checkArgument(maxX >= this.minX || this.minX == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxY >= this.minY || this.minY == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxZ >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        this.maxZ = maxZ;\n-        return this;\n+    public BlockRegion maxY(int y) {\n+        return this.maxY(y, this);\n     }\n \n-    // -- size -------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * Set the size of the block region from the minimum corner.\n-     *\n-     * @param x the x coordinate to set the size; must be > 0\n-     * @param y the y coordinate to set the size; must be > 0\n-     * @param z the z coordinate to set the size; must be > 0\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n-     */\n-    public BlockRegion setSize(int x, int y, int z) {\n-        Preconditions.checkArgument(x > 0);\n-        Preconditions.checkArgument(y > 0);\n-        Preconditions.checkArgument(z > 0);\n-        this.maxX = this.minX + x - 1;\n-        this.maxY = this.minY + y - 1;\n-        this.maxZ = this.minZ + z - 1;\n-        return this;\n+    @Override\n+    public BlockRegion maxZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n+        dest.maxZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Set the size of the block region from the minimum corner.\n-     *\n-     * @param size the size to set; all dimensions must be > 0\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n-     */\n-    public BlockRegion setSize(Vector3ic size) {\n-        return setSize(size.x(), size.y(), size.z());\n+    public BlockRegion maxZ(int z) {\n+        return this.maxZ(z, this);\n     }\n \n-    /**\n-     * The number of blocks in this region along the +x, +y, +z  axis from the minimum to the maximum corner.\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector3i getSize(Vector3i dest) {\n-        return dest.set(sizeX(), sizeY(), sizeZ());\n+    @Override\n+    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n+        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n+        dest.maxX = x;\n+        dest.maxY = y;\n+        dest.maxZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * The number of blocks on the x axis.\n-     */\n-    public int sizeX() {\n-        return this.maxX - this.minX + 1;\n+    public BlockRegion setMax(int x, int y, int z) {\n+        return this.setMax(x, y, z, this);\n     }\n \n-    /**\n-     * @see #sizeX()\n-     */\n-    public int getSizeX() {\n-        return sizeX();\n+    public BlockRegion setMax(Vector3ic max) {\n+        return this.setMax(max, this);\n     }\n \n-    /**\n-     * The number of blocks on the y axis.\n-     */\n-    public int sizeY() {\n-        return this.maxY - this.minY + 1;\n+    public BlockRegion addMax(int dx, int dy, int dz) {\n+        return this.addMax(dx, dy, dz, this);\n     }\n \n-    /**\n-     * @see #sizeY()\n-     */\n-    public int getSizeY() {\n-        return sizeY();\n+    public BlockRegion addMax(Vector3ic dmax) {\n+        return this.addMax(dmax, this);\n     }\n \n-    /**\n-     * The number of blocks on the z axis.\n-     */\n-    public int sizeZ() {\n-        return this.maxZ - this.minZ + 1;\n-    }\n+    // -- size -------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * @see #sizeZ()\n-     */\n-    public int getSizeZ() {\n-        return sizeZ();\n+    @Override\n+    public BlockRegion setSize(int x, int y, int z, BlockRegion dest) {\n+        Preconditions.checkArgument(x > 0);\n+        Preconditions.checkArgument(y > 0);\n+        Preconditions.checkArgument(z > 0);\n+        dest.maxX = this.minX + x - 1;\n+        dest.maxY = this.minY + y - 1;\n+        dest.maxZ = this.minZ + z - 1;\n+        return dest;\n     }\n \n-    // -- world ------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The bounding box in world coordinates.\n-     * <p>\n-     * The bounding box of a single block at {@code (x, y, z)} is centered at the integer coordinate {@code (x, y, z)}\n-     * and extents by {@code 0.5} in each dimension.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest}\n-     */\n-    //TODO: 1.9.26 has a constant interface for aabbf\n-    public AABBf getBounds(AABBf dest) {\n-        dest.minX = minX - .5f;\n-        dest.minY = minY - .5f;\n-        dest.minZ = minZ - .5f;\n-\n-        dest.maxX = maxX + .5f;\n-        dest.maxY = maxY + .5f;\n-        dest.maxZ = maxZ + .5f;\n-\n-        return dest;\n+    public BlockRegion setSize(int x, int y, int z) {\n+        return this.setSize(x, y, z, this);\n     }\n \n-    /**\n-     * The center of the region in world coordinates if the region is valid; {@link Float#NaN} otherwise.\n-     *\n-     * @param dest will hold the result\n-     * @return {@code dest}\n-     */\n-    public Vector3f center(Vector3f dest) {\n-        if (!this.isValid()) {\n-            return dest.set(Float.NaN);\n-        }\n-        return dest.set(\n-                (this.minX - .5f) + ((this.maxX - this.minX + 1.0f) / 2.0f),\n-                (this.minY - .5f) + ((this.maxY - this.minY + 1.0f) / 2.0f),\n-                (this.minZ - .5f) + ((this.maxZ - this.minZ + 1.0f) / 2.0f)\n-        );\n+    public BlockRegion setSize(Vector3ic size) {\n+        return setSize(size.x(), size.y(), size.z());\n     }\n \n     // -- IN-PLACE MUTATION ------------------------------------------------------------------------------------------//\n+    @Override\n+    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = Math.min(this.minX, x);\n+        dest.minY = Math.min(this.minY, y);\n+        dest.minZ = Math.min(this.minZ, z);\n+\n+        dest.maxX = Math.max(this.maxX, x);\n+        dest.maxY = Math.max(this.maxY, y);\n+        dest.maxZ = Math.max(this.maxZ, z);\n+        return dest;\n+    }\n \n-    /**\n-     * Compute the union of this region and the given block coordinate.\n-     *\n-     * @param x the x coordinate of the block\n-     * @param y the y coordinate of the block\n-     * @param z the z coordinate of the block\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(int x, int y, int z) {\n-        this.minX = Math.min(this.minX, x);\n-        this.minY = Math.min(this.minY, y);\n-        this.minZ = Math.min(this.minZ, z);\n-\n-        this.maxX = Math.max(this.maxX, x);\n-        this.maxY = Math.max(this.maxY, y);\n-        this.maxZ = Math.max(this.maxZ, z);\n-        return this;\n+        return this.union(x, y, z, this);\n     }\n \n-    /**\n-     * Compute the union of this region and the given block coordinate.\n-     *\n-     * @param pos the position of the block\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(Vector3ic pos) {\n-        return union(pos.x(), pos.y(), pos.z());\n+        return union(pos.x(), pos.y(), pos.z(), this);\n     }\n \n-    /**\n-     * Compute the union of this region and the other region.\n-     *\n-     * @param other {@link BlockRegion}\n-     * @return this region (after modification)\n-     */\n     public BlockRegion union(BlockRegion other) {\n-        return this.union(other.minX, other.minY, other.minZ).union(other.maxX, other.maxY, other.maxZ);\n-    }\n-\n-    /**\n-     * Compute the union of this region and the given block entity.\n-     * <p>\n-     * An entity is a block entity if it has the {@link BlockComponent}. This region will not be modified if the given\n-     * entity does not have a {@link BlockComponent}.\n-     *\n-     * @param blockRef entityRef that describes a block\n-     * @return this region (after modification)\n-     */\n-    public BlockRegion union(EntityRef blockRef) {\n-        BlockComponent component = blockRef.getComponent(BlockComponent.class);\n-        if (component != null) {\n-            return this.union(component.position.x(), component.position.y(), component.position.z());\n-        }\n-        return this;\n+        return this.union(other, this);\n     }\n \n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Compute the intersection of this region with the {@code other} region.\n-     * <p>\n-     * NOTE: If the regions don't intersect this region will become invalid!\n-     *\n-     * @param other the other region\n-     * @return this region (after modification) or {@link Optional#empty()} if the regions don't intersect\n-     */\n-    public Optional<BlockRegion> intersect(BlockRegion other) {\n-        this.minX = Math.max(minX, other.minX);\n-        this.minY = Math.max(minY, other.minY);\n-        this.minZ = Math.max(minZ, other.minZ);\n+    @Override\n+    public Optional<BlockRegion> intersect(BlockRegion other, BlockRegion dest) {\n+        dest.minX = Math.max(minX, other.minX);\n+        dest.minY = Math.max(minY, other.minY);\n+        dest.minZ = Math.max(minZ, other.minZ);\n \n-        this.maxX = Math.min(maxX, other.maxX);\n-        this.maxY = Math.min(maxY, other.maxY);\n-        this.maxZ = Math.min(maxZ, other.maxZ);\n+        dest.maxX = Math.min(maxX, other.maxX);\n+        dest.maxY = Math.min(maxY, other.maxY);\n+        dest.maxZ = Math.min(maxZ, other.maxZ);\n \n-        if (this.isValid()) {\n-            return Optional.of(this);\n+        if (dest.isValid()) {\n+            return Optional.of(dest);\n         } else {\n             return Optional.empty();\n         }\n     }\n \n+    public Optional<BlockRegion> intersect(BlockRegion other) {\n+        return this.intersect(other, this);\n+    }\n+\n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Translate this region by the given vector {@code (x, y, z))}.\n-     *\n-     * @param x the x coordinate to translate by\n-     * @param y the y coordinate to translate by\n-     * @param z the z coordinate to translate by\n-     * @return this region (after modification)\n-     */\n+    @Override\n+    public BlockRegion translate(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = this.minX + x;\n+        dest.minY = this.minY + y;\n+        dest.minZ = this.minZ + z;\n+        dest.maxX = this.maxX + x;\n+        dest.maxY = this.maxY + y;\n+        dest.maxZ = this.maxZ + z;\n+        return dest;\n+    }\n+\n     public BlockRegion translate(int x, int y, int z) {\n-        this.minX = this.minX + x;\n-        this.minY = this.minY + y;\n-        this.minZ = this.minZ + z;\n-        this.maxX = this.maxX + x;\n-        this.maxY = this.maxY + y;\n-        this.maxZ = this.maxZ + z;\n-        return this;\n+        return this.translate(x, y, z, this);\n     }\n \n-    /**\n-     * Translate this region by the given vector {@code vec}.\n-     *\n-     * @param vec the vector to translate by\n-     * @return this region (after modification)\n-     */\n     public BlockRegion translate(Vector3ic vec) {\n         return translate(vec.x(), vec.y(), vec.z());\n     }\n \n     // -- extend -----------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     *\n-     * @param extentX the amount of blocks to extend this region by along the x axis in both directions\n-     * @param extentY the amount of blocks to extend this region by along the y axis in both directions\n-     * @param extentZ the amount of blocks to extend this region by along the z axis in both directions\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(int extentX, int extentY, int extentZ) {\n-        Preconditions.checkArgument(sizeX() + 2 * extentX > 0);\n-        Preconditions.checkArgument(sizeY() + 2 * extentY > 0);\n-        Preconditions.checkArgument(sizeZ() + 2 * extentZ > 0);\n-        this.minX = this.minX - extentX;\n-        this.minY = this.minY - extentY;\n-        this.minZ = this.minZ - extentZ;\n-\n-        this.maxX = this.maxX + extentX;\n-        this.maxY = this.maxY + extentY;\n-        this.maxZ = this.maxZ + extentZ;\n+    @Override\n+    public BlockRegion expand(int dx, int dy, int dz, BlockRegion dest) {\n+        Preconditions.checkArgument(getSizeX() + 2 * dx > 0);\n+        Preconditions.checkArgument(getSizeY() + 2 * dy > 0);\n+        Preconditions.checkArgument(getSizeZ() + 2 * dz > 0);\n+        dest.minX = this.minX - dx;\n+        dest.minY = this.minY - dy;\n+        dest.minZ = this.minZ - dz;\n+\n+        dest.maxX = this.maxX + dx;\n+        dest.maxY = this.maxY + dy;\n+        dest.maxZ = this.maxZ + dz;\n \n-        return this;\n+        return dest;\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     *\n-     * @param extents the amount of blocks to extend this region by\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(Vector3ic extents) {\n-        return extend(extents.x(), extents.y(), extents.z());\n+    public BlockRegion expand(int dx, int dy, int dz) {\n+        return this.expand(dx, dy, dz, this);\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     * <p>\n-     * The extents will be floored for each dimension.\n-     *\n-     * @param extentX the amount of blocks to extend this region by along the x axis in both directions\n-     * @param extentY the amount of blocks to extend this region by along the y axis in both directions\n-     * @param extentZ the amount of blocks to extend this region by along the z axis in both directions\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(float extentX, float extentY, float extentZ) {\n-        return extend(\n-                Math.roundUsing(extentX, RoundingMode.FLOOR),\n-                Math.roundUsing(extentY, RoundingMode.FLOOR),\n-                Math.roundUsing(extentZ, RoundingMode.FLOOR));\n+    public BlockRegion expand(Vector3ic extents) {\n+        return expand(extents.x(), extents.y(), extents.z());\n     }\n \n-    /**\n-     * Extend this region by adding the given {@code extents} for each face of a region.\n-     * <p>\n-     * The extents will be floored for each dimension.\n-     *\n-     * @param extents the amount of blocks to extend this region by\n-     * @return this region (after modification)\n-     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n-     */\n-    public BlockRegion extend(Vector3f extents) {\n-        return extend(extents.x(), extents.y(), extents.z());\n+    public BlockRegion expand(float dx, float dy, float dz) {\n+        return this.expand(dx, dy, dz, this);\n+    }\n+\n+    public BlockRegion expand(Vector3f extents) {\n+        return expand(extents.x(), extents.y(), extents.z());\n     }\n \n     // -- transform --------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Apply the given {@link Matrix4fc#isAffine() affine} transformation to this {@link BlockRegion}.\n-     * <p>\n-     * The matrix in {@code m} <i>must</i> be {@link Matrix4fc#isAffine() affine}.\n-     *\n-     * @param m the affine transformation matrix\n-     * @param dest will hold the result\n-     * @return {@code dest} (after modification)\n-     * @throws IllegalArgumentException if the matrix {@code m} is not {@link Matrix4fc#isAffine() affine}\n-     */\n+    @Override\n     public BlockRegion transform(Matrix4fc m, BlockRegion dest) {\n         Preconditions.checkArgument(m.isAffine());\n         float dx = maxX - minX;\n"}}, {"oid": "a5ce0758fffb146e617c841aabc95ab16e8d56c0", "url": "https://github.com/MovingBlocks/Terasology/commit/a5ce0758fffb146e617c841aabc95ab16e8d56c0", "message": "Merge branch 'develop' into docs/BlockRegion", "committedDate": "2020-12-22T11:11:42Z", "type": "commit"}, {"oid": "967b037582324f6aff818f65b85e3b9ccd71f386", "url": "https://github.com/MovingBlocks/Terasology/commit/967b037582324f6aff818f65b85e3b9ccd71f386", "message": "feat(BlockRegion): add immutable interface `BlockRegionc`", "committedDate": "2020-12-23T14:00:10Z", "type": "commit"}, {"oid": "89c958e8bd8b32e51c9d6572ae9a878c0d8db2ff", "url": "https://github.com/MovingBlocks/Terasology/commit/89c958e8bd8b32e51c9d6572ae9a878c0d8db2ff", "message": "doc(BlockRegion): add JavaDoc for BlockRegionc", "committedDate": "2020-12-23T15:25:49Z", "type": "commit"}, {"oid": "6799c3ad88cc478e6dfeac8279416677b54c833e", "url": "https://github.com/MovingBlocks/Terasology/commit/6799c3ad88cc478e6dfeac8279416677b54c833e", "message": "refactor(BlockRegion): implement BlockRegion in terms of BlockRegionc", "committedDate": "2020-12-23T15:27:26Z", "type": "commit"}, {"oid": "8a66bfd95203c932c0f4c185819f381a9b00e896", "url": "https://github.com/MovingBlocks/Terasology/commit/8a66bfd95203c932c0f4c185819f381a9b00e896", "message": "doc(BlockRegion): add docs for BlockRegionc::iterator", "committedDate": "2020-12-23T15:45:00Z", "type": "commit"}, {"oid": "b8f32f559246faae7ed6c4931353edab7490a2a6", "url": "https://github.com/MovingBlocks/Terasology/commit/b8f32f559246faae7ed6c4931353edab7490a2a6", "message": "refactor!(BlockRegion): remove BlockRegions and BlockRegionIterable", "committedDate": "2020-12-23T16:17:46Z", "type": "commit"}, {"oid": "b9e4b9204f22b1a66258d1bc76f644ba3edecfdd", "url": "https://github.com/MovingBlocks/Terasology/commit/b9e4b9204f22b1a66258d1bc76f644ba3edecfdd", "message": "refactor!(BlockRegion): use BlockRegionc (super type) instead of specific subtype", "committedDate": "2020-12-23T16:58:16Z", "type": "commit"}, {"oid": "533fd585860012b1ee8b3d136c67e68d95909278", "url": "https://github.com/MovingBlocks/Terasology/commit/533fd585860012b1ee8b3d136c67e68d95909278", "message": "test(BlockRegion): update test cases; merge BlockRegionIterableTest into BlockRegionTest", "committedDate": "2020-12-23T16:58:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEzNTk2OQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548135969", "bodyText": "@pollend would you be okay with addToMin?", "author": "jdrueckert", "createdAt": "2020-12-23T18:50:52Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -93,550 +114,397 @@\n      *\n      * @param source the block region to copy.\n      */\n-    public BlockRegion(BlockRegion source) {\n+    public BlockRegion(BlockRegionc source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * set source to current region\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @param source the source region\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n-\n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n-        return this;\n-    }\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+        Preconditions.checkArgument(minZ <= maxZ || (minZ == INVALID.minZ() && maxZ == INVALID.maxZ()));\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n+        return this;\n     }\n \n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * The x-coordinate of the minimum corner\n+     * Reset both the minimum and maximum corner of this region.\n+     *\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public int minX() {\n-        return this.minX;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    public BlockRegion set(BlockRegionc source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block x\n-     *\n-     * @return the minX\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n+    @Override\n     public int minY() {\n         return this.minY;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block y\n-     *\n-     * @return the minY\n-     */\n-    public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n+        dest.minX = x;\n+        return dest;\n     }\n \n-    /**\n-     * The z-coordinate of the minimum corner\n-     */\n-    public int minZ() {\n-        return this.minZ;\n+    public BlockRegion minX(int x) {\n+        return this.minX(x, this);\n     }\n \n-    /**\n-     * the minimum coordinate of the first block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #minZ()}\n-     */\n-    @Deprecated\n-    public int getMinZ() {\n-        return this.minZ;\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n+        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n+        dest.minY = y;\n+        return dest;\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block z\n-     *\n-     * @return the minZ\n-     */\n-    public BlockRegion minZ(int z) {\n-        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n-        this.minZ = z;\n-        return this;\n+    public BlockRegion minY(int y) {\n+        return this.minY(y, this);\n     }\n \n-    /**\n-     * Get the block coordinate minimum corner.\n-     *\n-     * @param dest will hold the result\n-     */\n-    public Vector3i getMin(Vector3i dest) {\n-        return dest.set(minX, minY, minZ);\n+    @Override\n+    public BlockRegion minZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n+        dest.minZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param min the first coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min.x(), min.y(), min.z());\n+    public BlockRegion minZ(int z) {\n+        return this.minZ(z, this);\n     }\n \n-    /**\n-     * sets the minimum block for this {@link BlockRegion}\n-     *\n-     * @param minX the x coordinate of the first block\n-     * @param minY the y coordinate of the first block\n-     * @param minZ the z coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMin(int minX, int minY, int minZ) {\n+    @Override\n+    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n         Preconditions.checkArgument(minX <= this.maxX || this.maxX == Integer.MIN_VALUE);\n         Preconditions.checkArgument(minY <= this.maxY || this.maxX == Integer.MIN_VALUE);\n         Preconditions.checkArgument(minZ <= this.maxZ || this.maxX == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        this.minZ = minZ;\n-        return this;\n+        dest.minX = minX;\n+        dest.minY = minY;\n+        dest.minZ = minZ;\n+        return dest;\n     }\n \n-    // -- max --------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The x-coordinate of the maximum corner\n-     */\n-    public int maxX() {\n-        return this.maxX;\n+    public BlockRegion setMin(int x, int y, int z) {\n+        return this.setMin(x, y, z, this);\n     }\n \n-    /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #maxX()}\n-     */\n-    @Deprecated\n-    public int getMaxX() {\n-        return this.maxX;\n+    public BlockRegion setMin(Vector3ic min) {\n+        return this.setMin(min, this);\n     }\n \n-    /**\n-     * set the maximum coordinate of the second block x\n-     *\n-     * @return the minX\n-     */\n-    public BlockRegion maxX(int x) {\n-        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n-        this.maxX = x;\n-        return this;\n+    public BlockRegion addMin(int dx, int dy, int dz) {", "originalCommit": "533fd585860012b1ee8b3d136c67e68d95909278", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEzOTYwNQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548139605", "bodyText": "Or alternatively moveMin?", "author": "jdrueckert", "createdAt": "2020-12-23T18:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEzNTk2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "12ce7edb0167dd39a3eb7c9821cfe1c2acbb2e96", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 72183d7fc..1573fd3c3 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -290,12 +290,12 @@ public BlockRegion setMin(Vector3ic min) {\n         return this.setMin(min, this);\n     }\n \n-    public BlockRegion addMin(int dx, int dy, int dz) {\n-        return this.addMin(dx, dy, dz, this);\n+    public BlockRegion addToMin(int dx, int dy, int dz) {\n+        return this.addToMin(dx, dy, dz, this);\n     }\n \n-    public BlockRegion addMin(Vector3ic dmin) {\n-        return this.addMin(dmin, this);\n+    public BlockRegion addToMin(Vector3ic dmin) {\n+        return this.addToMin(dmin, this);\n     }\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEzNjMxNg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548136316", "bodyText": "@pollend would you be okay with addToMax?", "author": "jdrueckert", "createdAt": "2020-12-23T18:51:16Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -93,550 +114,397 @@\n      *\n      * @param source the block region to copy.\n      */\n-    public BlockRegion(BlockRegion source) {\n+    public BlockRegion(BlockRegionc source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * set source to current region\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @param source the source region\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n-\n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n-        return this;\n-    }\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+        Preconditions.checkArgument(minZ <= maxZ || (minZ == INVALID.minZ() && maxZ == INVALID.maxZ()));\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n+        return this;\n     }\n \n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * The x-coordinate of the minimum corner\n+     * Reset both the minimum and maximum corner of this region.\n+     *\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public int minX() {\n-        return this.minX;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    public BlockRegion set(BlockRegionc source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block x\n-     *\n-     * @return the minX\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n+    @Override\n     public int minY() {\n         return this.minY;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block y\n-     *\n-     * @return the minY\n-     */\n-    public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n+        dest.minX = x;\n+        return dest;\n     }\n \n-    /**\n-     * The z-coordinate of the minimum corner\n-     */\n-    public int minZ() {\n-        return this.minZ;\n+    public BlockRegion minX(int x) {\n+        return this.minX(x, this);\n     }\n \n-    /**\n-     * the minimum coordinate of the first block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #minZ()}\n-     */\n-    @Deprecated\n-    public int getMinZ() {\n-        return this.minZ;\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n+        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n+        dest.minY = y;\n+        return dest;\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block z\n-     *\n-     * @return the minZ\n-     */\n-    public BlockRegion minZ(int z) {\n-        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n-        this.minZ = z;\n-        return this;\n+    public BlockRegion minY(int y) {\n+        return this.minY(y, this);\n     }\n \n-    /**\n-     * Get the block coordinate minimum corner.\n-     *\n-     * @param dest will hold the result\n-     */\n-    public Vector3i getMin(Vector3i dest) {\n-        return dest.set(minX, minY, minZ);\n+    @Override\n+    public BlockRegion minZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n+        dest.minZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param min the first coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min.x(), min.y(), min.z());\n+    public BlockRegion minZ(int z) {\n+        return this.minZ(z, this);\n     }\n \n-    /**\n-     * sets the minimum block for this {@link BlockRegion}\n-     *\n-     * @param minX the x coordinate of the first block\n-     * @param minY the y coordinate of the first block\n-     * @param minZ the z coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMin(int minX, int minY, int minZ) {\n+    @Override\n+    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n         Preconditions.checkArgument(minX <= this.maxX || this.maxX == Integer.MIN_VALUE);\n         Preconditions.checkArgument(minY <= this.maxY || this.maxX == Integer.MIN_VALUE);\n         Preconditions.checkArgument(minZ <= this.maxZ || this.maxX == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        this.minZ = minZ;\n-        return this;\n+        dest.minX = minX;\n+        dest.minY = minY;\n+        dest.minZ = minZ;\n+        return dest;\n     }\n \n-    // -- max --------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The x-coordinate of the maximum corner\n-     */\n-    public int maxX() {\n-        return this.maxX;\n+    public BlockRegion setMin(int x, int y, int z) {\n+        return this.setMin(x, y, z, this);\n     }\n \n-    /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #maxX()}\n-     */\n-    @Deprecated\n-    public int getMaxX() {\n-        return this.maxX;\n+    public BlockRegion setMin(Vector3ic min) {\n+        return this.setMin(min, this);\n     }\n \n-    /**\n-     * set the maximum coordinate of the second block x\n-     *\n-     * @return the minX\n-     */\n-    public BlockRegion maxX(int x) {\n-        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n-        this.maxX = x;\n-        return this;\n+    public BlockRegion addMin(int dx, int dy, int dz) {\n+        return this.addMin(dx, dy, dz, this);\n     }\n \n-    /**\n-     * The y-coordinate of the maximum corner\n-     */\n-    public int maxY() {\n-        return this.maxY;\n+    public BlockRegion addMin(Vector3ic dmin) {\n+        return this.addMin(dmin, this);\n     }\n \n-    /**\n-     * the maximum coordinate of the second block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #maxY()}\n-     */\n-    @Deprecated\n-    public int getMaxY() {\n-        return this.maxY;\n+\n+    // -- max --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int maxX() {\n+        return this.maxX;\n     }\n \n-    /**\n-     * set the maximum coordinate of the second block y\n-     *\n-     * @return the minY\n-     */\n-    public BlockRegion maxY(int y) {\n-        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n-        this.maxY = y;\n-        return this;\n+    @Override\n+    public int maxY() {\n+        return this.maxY;\n     }\n \n-    /**\n-     * The z-coordinate of the maximum corner\n-     */\n+    @Override\n     public int maxZ() {\n         return this.maxZ;\n     }\n \n-    /**\n-     * the maximum coordinate of the second block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #maxZ()}\n-     */\n-    @Deprecated\n-    public int getMaxZ() {\n-        return this.maxZ;\n+    @Override\n+    public BlockRegion maxX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n+        dest.maxX = x;\n+        return dest;\n     }\n \n-    /**\n-     * set the maximum coordinate of the second block z\n-     *\n-     * @return the minZ\n-     */\n-    public BlockRegion maxZ(int z) {\n-        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxZ = z;\n-        return this;\n+    public BlockRegion maxX(int x) {\n+        return this.maxX(x, this);\n     }\n \n-    /**\n-     * Get the block coordinate of the maximum corner.\n-     *\n-     * @param dest will hold the result\n-     */\n-    public Vector3i getMax(Vector3i dest) {\n-        return dest.set(maxX, maxY, maxZ);\n+    @Override\n+    public BlockRegion maxY(int y, BlockRegion dest) {\n+        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n+        dest.maxY = y;\n+        return dest;\n     }\n \n-    /**\n-     * Sets the maximum coordinate of the second block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param max the second coordinate of the second block\n-     * @return this\n-     */\n-    public BlockRegion setMax(Vector3ic max) {\n-        return this.setMax(max.x(), max.y(), max.z());\n+    public BlockRegion maxY(int y) {\n+        return this.maxY(y, this);\n     }\n \n-    /**\n-     * sets the maximum block for this {@link BlockRegion}\n-     *\n-     * @param maxX the x coordinate of the first block\n-     * @param maxY the y coordinate of the first block\n-     * @param maxZ the z coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMax(int maxX, int maxY, int maxZ) {\n-        Preconditions.checkArgument(maxX >= this.minX || this.minX == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxY >= this.minY || this.minY == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxZ >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        this.maxZ = maxZ;\n-        return this;\n+    @Override\n+    public BlockRegion maxZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n+        dest.maxZ = z;\n+        return dest;\n     }\n \n-    // -- size -------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * Set the size of the block region from minimum the minimum corner.\n-     *\n-     * @param x the x coordinate to set the size; must be > 0\n-     * @param y the y coordinate to set the size; must be > 0\n-     * @param z the z coordinate to set the size; must be > 0\n-     * @return this after modification\n-     */\n-    public BlockRegion setSize(int x, int y, int z) {\n-        Preconditions.checkArgument(x > 0);\n-        Preconditions.checkArgument(y > 0);\n-        Preconditions.checkArgument(z > 0);\n-        this.maxX = this.minX + x - 1;\n-        this.maxY = this.minY + y - 1;\n-        this.maxZ = this.minZ + z - 1;\n-        return this;\n+    public BlockRegion maxZ(int z) {\n+        return this.maxZ(z, this);\n     }\n \n-    /**\n-     * Set the size of the block region from minimum the minimum corner.\n-     *\n-     * @param size the size to set; all dimensions must be > 0\n-     * @return this after modification\n-     */\n-    public BlockRegion setSize(Vector3ic size) {\n-        return setSize(size.x(), size.y(), size.z());\n+    @Override\n+    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n+        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n+        dest.maxX = x;\n+        dest.maxY = y;\n+        dest.maxZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * the number of blocks for the +x, +y, +z from the minimum to the maximum\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector3i getSize(Vector3i dest) {\n-        return dest.set(sizeX(), sizeY(), sizeZ());\n+    public BlockRegion setMax(int x, int y, int z) {\n+        return this.setMax(x, y, z, this);\n     }\n \n-    /**\n-     * The number of blocks on the X axis\n-     *\n-     * @return number of blocks in the X axis\n-     */\n-    public int sizeX() {\n-        return this.maxX - this.minX + 1;\n+    public BlockRegion setMax(Vector3ic max) {\n+        return this.setMax(max, this);\n     }\n \n-    /**\n-     * The number of blocks on the Y axis\n-     *\n-     * @return number of blocks in the Y axis\n-     */\n-    public int sizeY() {\n-        return this.maxY - this.minY + 1;\n+    public BlockRegion addMax(int dx, int dy, int dz) {", "originalCommit": "533fd585860012b1ee8b3d136c67e68d95909278", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEzOTgxNg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548139816", "bodyText": "Or alternatively moveMax?", "author": "jdrueckert", "createdAt": "2020-12-23T18:55:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEzNjMxNg=="}], "type": "inlineReview", "revised_code": {"commit": "12ce7edb0167dd39a3eb7c9821cfe1c2acbb2e96", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 72183d7fc..1573fd3c3 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -290,12 +290,12 @@ public BlockRegion setMin(Vector3ic min) {\n         return this.setMin(min, this);\n     }\n \n-    public BlockRegion addMin(int dx, int dy, int dz) {\n-        return this.addMin(dx, dy, dz, this);\n+    public BlockRegion addToMin(int dx, int dy, int dz) {\n+        return this.addToMin(dx, dy, dz, this);\n     }\n \n-    public BlockRegion addMin(Vector3ic dmin) {\n-        return this.addMin(dmin, this);\n+    public BlockRegion addToMin(Vector3ic dmin) {\n+        return this.addToMin(dmin, this);\n     }\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIyNjkyMQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548226921", "bodyText": "This check is out of sync with set(...). Can we just use 'set` in the constructor?\n    public BlockRegion(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n      this.set(minX, minY, minZ, maxX, maxY, maxZ);\n    }", "author": "skaldarnar", "createdAt": "2020-12-23T20:51:02Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -76,15 +80,32 @@\n         this.maxZ = maxZ;\n     }", "originalCommit": "533fd585860012b1ee8b3d136c67e68d95909278", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b359b2e64c078c8ddf0e72bce03b9fd4776a0584", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 72183d7fc..38d9f07ce 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -67,17 +67,7 @@\n      * @throws IllegalArgumentException if any min component is greater than the corresponding max component\n      */\n     public BlockRegion(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n-        Preconditions.checkArgument(minX <= maxX);\n-        Preconditions.checkArgument(minY <= maxY);\n-        Preconditions.checkArgument(minZ <= maxZ);\n-\n-        this.minX = minX;\n-        this.minY = minY;\n-        this.minZ = minZ;\n-\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        this.maxZ = maxZ;\n+        this.set(minX, minY, minZ, maxX, maxY, maxZ);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIzMzg2NA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548233864", "bodyText": "This implementation is wrong!\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public BlockRegion minX(int x, BlockRegion dest) {\n          \n          \n            \n                    Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n          \n          \n            \n                    dest.minX = x;\n          \n          \n            \n                    return dest;\n          \n          \n            \n                public BlockRegion minX(int x, BlockRegion dest) {\n          \n          \n            \n                    return dest.set(x, minY, minZ, maxX, maxY, maxZ);\n          \n      \n    \n    \n  \n\nSame for the other methods of the same pattern.", "author": "skaldarnar", "createdAt": "2020-12-23T21:00:54Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -93,550 +114,397 @@\n      *\n      * @param source the block region to copy.\n      */\n-    public BlockRegion(BlockRegion source) {\n+    public BlockRegion(BlockRegionc source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * set source to current region\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @param source the source region\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n-\n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n-        return this;\n-    }\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+        Preconditions.checkArgument(minZ <= maxZ || (minZ == INVALID.minZ() && maxZ == INVALID.maxZ()));\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n+        return this;\n     }\n \n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * The x-coordinate of the minimum corner\n+     * Reset both the minimum and maximum corner of this region.\n+     *\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public int minX() {\n-        return this.minX;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    public BlockRegion set(BlockRegionc source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block x\n-     *\n-     * @return the minX\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n+    @Override\n     public int minY() {\n         return this.minY;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block y\n-     *\n-     * @return the minY\n-     */\n-    public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n+        dest.minX = x;\n+        return dest;", "originalCommit": "533fd585860012b1ee8b3d136c67e68d95909278", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIzNjY2OA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548236668", "bodyText": "Alternatively, we could only offer these methods to modify individual components on the mutable class.", "author": "skaldarnar", "createdAt": "2020-12-23T21:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIzMzg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI0MTAxMA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548241010", "bodyText": "Guess that's a question for @pollend I'm okay with either option", "author": "jdrueckert", "createdAt": "2020-12-23T21:10:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIzMzg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI5OTI0Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548299242", "bodyText": "Why do you need to have a dest for a mutation like this. Just modify the direct object. Simpler to set it to another object and then set min and max.", "author": "pollend", "createdAt": "2020-12-23T22:33:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIzMzg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwNTgxOQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548305819", "bodyText": "Hm, can we clarify in which situations we want to have the variants with explicit destinations and in which we don't want/need them? I don't see a clear pattern here \ud83d\ude48", "author": "skaldarnar", "createdAt": "2020-12-23T22:45:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIzMzg2NA=="}], "type": "inlineReview", "revised_code": {"commit": "12ce7edb0167dd39a3eb7c9821cfe1c2acbb2e96", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 72183d7fc..1573fd3c3 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -290,12 +290,12 @@ public BlockRegion setMin(Vector3ic min) {\n         return this.setMin(min, this);\n     }\n \n-    public BlockRegion addMin(int dx, int dy, int dz) {\n-        return this.addMin(dx, dy, dz, this);\n+    public BlockRegion addToMin(int dx, int dy, int dz) {\n+        return this.addToMin(dx, dy, dz, this);\n     }\n \n-    public BlockRegion addMin(Vector3ic dmin) {\n-        return this.addMin(dmin, this);\n+    public BlockRegion addToMin(Vector3ic dmin) {\n+        return this.addToMin(dmin, this);\n     }\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI0NjgwMg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548246802", "bodyText": "Should this be called setMin or min, analogous to minX/minY?\nnevermind, this would get crazy with overloading things...", "author": "skaldarnar", "createdAt": "2020-12-23T21:18:28Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -93,550 +114,397 @@\n      *\n      * @param source the block region to copy.\n      */\n-    public BlockRegion(BlockRegion source) {\n+    public BlockRegion(BlockRegionc source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * set source to current region\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @param source the source region\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n-\n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n-        return this;\n-    }\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+        Preconditions.checkArgument(minZ <= maxZ || (minZ == INVALID.minZ() && maxZ == INVALID.maxZ()));\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n+        return this;\n     }\n \n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * The x-coordinate of the minimum corner\n+     * Reset both the minimum and maximum corner of this region.\n+     *\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public int minX() {\n-        return this.minX;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    public BlockRegion set(BlockRegionc source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block x\n-     *\n-     * @return the minX\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n+    @Override\n     public int minY() {\n         return this.minY;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block y\n-     *\n-     * @return the minY\n-     */\n-    public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n+        dest.minX = x;\n+        return dest;\n     }\n \n-    /**\n-     * The z-coordinate of the minimum corner\n-     */\n-    public int minZ() {\n-        return this.minZ;\n+    public BlockRegion minX(int x) {\n+        return this.minX(x, this);\n     }\n \n-    /**\n-     * the minimum coordinate of the first block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #minZ()}\n-     */\n-    @Deprecated\n-    public int getMinZ() {\n-        return this.minZ;\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n+        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n+        dest.minY = y;\n+        return dest;\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block z\n-     *\n-     * @return the minZ\n-     */\n-    public BlockRegion minZ(int z) {\n-        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n-        this.minZ = z;\n-        return this;\n+    public BlockRegion minY(int y) {\n+        return this.minY(y, this);\n     }\n \n-    /**\n-     * Get the block coordinate minimum corner.\n-     *\n-     * @param dest will hold the result\n-     */\n-    public Vector3i getMin(Vector3i dest) {\n-        return dest.set(minX, minY, minZ);\n+    @Override\n+    public BlockRegion minZ(int z, BlockRegion dest) {\n+        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n+        dest.minZ = z;\n+        return dest;\n     }\n \n-    /**\n-     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param min the first coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min.x(), min.y(), min.z());\n+    public BlockRegion minZ(int z) {\n+        return this.minZ(z, this);\n     }\n \n-    /**\n-     * sets the minimum block for this {@link BlockRegion}\n-     *\n-     * @param minX the x coordinate of the first block\n-     * @param minY the y coordinate of the first block\n-     * @param minZ the z coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMin(int minX, int minY, int minZ) {\n+    @Override\n+    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {", "originalCommit": "533fd585860012b1ee8b3d136c67e68d95909278", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12ce7edb0167dd39a3eb7c9821cfe1c2acbb2e96", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 72183d7fc..1573fd3c3 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -290,12 +290,12 @@ public BlockRegion setMin(Vector3ic min) {\n         return this.setMin(min, this);\n     }\n \n-    public BlockRegion addMin(int dx, int dy, int dz) {\n-        return this.addMin(dx, dy, dz, this);\n+    public BlockRegion addToMin(int dx, int dy, int dz) {\n+        return this.addToMin(dx, dy, dz, this);\n     }\n \n-    public BlockRegion addMin(Vector3ic dmin) {\n-        return this.addMin(dmin, this);\n+    public BlockRegion addToMin(Vector3ic dmin) {\n+        return this.addToMin(dmin, this);\n     }\n \n \n"}}, {"oid": "12ce7edb0167dd39a3eb7c9821cfe1c2acbb2e96", "url": "https://github.com/MovingBlocks/Terasology/commit/12ce7edb0167dd39a3eb7c9821cfe1c2acbb2e96", "message": "refactor: rename addM[in|ax] to addToM[in|ax]", "committedDate": "2020-12-23T21:38:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI2ODkzMQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548268931", "bodyText": "I'm not sure this is correct \ud83e\udd14 I think we are missing the 0.5f margin to each side, e.g.,\n// bounding box: (.5, .5, .5)..(1.5, 1.5, 1.5)\nnew BlockRegion(1,1,1).expand(0.5f, 0.5f, 0.5f) == new BlockRegion(0,0,0, 2,2,2)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return this.expand(\n          \n          \n            \n                            Math.roundUsing(dx, RoundingMode.FLOOR),\n          \n          \n            \n                            Math.roundUsing(dy, RoundingMode.FLOOR),\n          \n          \n            \n                            Math.roundUsing(dz, RoundingMode.FLOOR),\n          \n          \n            \n                            dest);\n          \n          \n            \n                }\n          \n          \n            \n                    return this.expand(\n          \n          \n            \n                            Math.roundUsing(dx + 0.5f, RoundingMode.FLOOR),\n          \n          \n            \n                            Math.roundUsing(dy + 0.5f, RoundingMode.FLOOR),\n          \n          \n            \n                            Math.roundUsing(dz + 0.5f, RoundingMode.FLOOR),\n          \n          \n            \n                            dest);\n          \n          \n            \n                }", "author": "skaldarnar", "createdAt": "2020-12-23T21:49:30Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegionc.java", "diffHunk": "@@ -0,0 +1,799 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+package org.terasology.world.block;\n+\n+import org.joml.AABBf;\n+import org.joml.Intersectionf;\n+import org.joml.LineSegmentf;\n+import org.joml.Math;\n+import org.joml.Matrix4fc;\n+import org.joml.Planef;\n+import org.joml.Rayf;\n+import org.joml.RoundingMode;\n+import org.joml.Spheref;\n+import org.joml.Vector2f;\n+import org.joml.Vector3f;\n+import org.joml.Vector3fc;\n+import org.joml.Vector3i;\n+import org.joml.Vector3ic;\n+\n+import java.util.Iterator;\n+import java.util.Optional;\n+\n+/**\n+ * An immutable, bounded, axis-aligned volume in space denoting a collection of blocks contained within.\n+ */\n+public interface BlockRegionc extends Iterable<Vector3ic> {\n+\n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    /**\n+     * Iterate over the blocks in the block region, where the same {@link Vector3ic} is reused for low memory\n+     * footprint.\n+     * <p>\n+     * Do not store the elements directly or use them outside the context of the iterator as they will change when the\n+     * iterator is advanced. You may create new vectors from the elements if necessary, e.g.:\n+     * <pre>\n+     *     for (Vector3ic p : region) {\n+     *         Vector3i pos = new Vector3i(p);\n+     *         // use 'pos' instead of 'p'\n+     *     }\n+     * </pre>\n+     */\n+    Iterator<Vector3ic> iterator();\n+\n+    // -- min -------------------------------------------------------------------------------------------------------//\n+\n+    /**\n+     * The x-coordinate of the minimum corner\n+     */\n+    int minX();\n+\n+    /**\n+     * The y-coordinate of the minimum corner\n+     */\n+    int minY();\n+\n+    /**\n+     * The z-coordinate of the minimum corner\n+     */\n+    int minZ();\n+\n+    /**\n+     * Get the block coordinate of the minimum corner.\n+     *\n+     * @param dest will hold the result\n+     * @return {@code dest}\n+     */\n+    default Vector3i getMin(Vector3i dest) {\n+        return dest.set(minX(), minY(), minZ());\n+    }\n+\n+    /**\n+     * Set the minimum x-coordinate of the region.\n+     *\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if {@code x} is greater than the maximum x coordinate\n+     */\n+    BlockRegion minX(int x, BlockRegion dest);\n+\n+    /**\n+     * Set the minimum y-coordinate of the region.\n+     *\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if {@code y} is greater than the maximum y coordinate\n+     */\n+    BlockRegion minY(int y, BlockRegion dest);\n+\n+    /**\n+     * Set the minimum z-coordinate of the region.\n+     *\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if {@code z} is greater than the maximum z coordinate\n+     */\n+    BlockRegion minZ(int z, BlockRegion dest);\n+\n+    /**\n+     * Set the coordinates of the minimum corner for this region.\n+     *\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if any dimension is greater than the respective component of the maximum\n+     *         corner\n+     */\n+    BlockRegion setMin(int x, int y, int z, BlockRegion dest);\n+\n+    /**\n+     * Set the coordinates of the minimum corner for this region.\n+     *\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if any dimension is greater than the respective component of the maximum\n+     *         corner\n+     */\n+    default BlockRegion setMin(Vector3ic min, BlockRegion dest) {\n+        return this.setMin(min.x(), min.y(), min.z(), dest);\n+    }\n+\n+    /**\n+     * Translate the minimum corner of the region by adding given {@code (dx, dy, dz)}.\n+     *\n+     * @param dx the number of blocks to add to the minimum corner on the x axis\n+     * @param dy the number of blocks to add to the minimum corner on the y axis\n+     * @param dz the number of blocks to add to the minimum corner on the z axis\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would be {@link #isValid() invalid}.\n+     */\n+    default BlockRegion addMin(int dx, int dy, int dz, BlockRegion dest) {\n+        return this.setMin(minX() + dx, minY() + dy, minZ() + dz, dest);\n+    }\n+\n+    /**\n+     * Translate the minimum corner of the region by adding given {@code (dx, dy, dz)}.\n+     *\n+     * @param dmin the translation vector for the minimum corner\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would be {@link #isValid() invalid}.\n+     */\n+    default BlockRegion addMin(Vector3ic dmin, BlockRegion dest) {\n+        return this.addMin(dmin.x(), dmin.y(), dmin.z(), dest);\n+    }\n+\n+    // -- max -------------------------------------------------------------------------------------------------------//\n+\n+    /**\n+     * The x-coordinate of the maximum corner\n+     */\n+    int maxX();\n+\n+    /**\n+     * The y-coordinate of the maximum corner\n+     */\n+    int maxY();\n+\n+    /**\n+     * The z-coordinate of the maximum corner\n+     */\n+    int maxZ();\n+\n+    /**\n+     * Get the block coordinate of the maximum corner.\n+     *\n+     * @param dest will hold the result\n+     * @return {@code dest}\n+     */\n+    default Vector3i getMax(Vector3i dest) {\n+        return dest.set(maxX(), maxY(), maxZ());\n+    }\n+\n+    /**\n+     * Set the maximum x-coordinate of the region.\n+     *\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if {@code x} is smaller than the minimum x-coordinate\n+     */\n+    BlockRegion maxX(int x, BlockRegion dest);\n+\n+    /**\n+     * Set the maximum y-coordinate of the region.\n+     *\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if {@code x} is smaller than the minimum x-coordinate\n+     */\n+    BlockRegion maxY(int y, BlockRegion dest);\n+\n+    /**\n+     * Set the maximum z-coordinate of the region.\n+     *\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if {@code x} is smaller than the minimum x-coordinate\n+     */\n+    BlockRegion maxZ(int z, BlockRegion dest);\n+\n+    /**\n+     * Set the coordinates of the maximum corner for this region.\n+     *\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if any dimension is smaller than the respective component of the minimum\n+     *         corner\n+     */\n+    BlockRegion setMax(int x, int y, int z, BlockRegion dest);\n+\n+    /**\n+     * Set the coordinates of the maximum corner for this region.\n+     *\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if any dimension is smaller than the respective component of the minimum\n+     *         corner\n+     */\n+    default BlockRegion setMax(Vector3ic max, BlockRegion dest) {\n+        return this.setMax(max.x(), max.y(), max.z(), dest);\n+    }\n+\n+    /**\n+     * Translate the maximum corner of the region by adding given {@code (dx, dy, dz)}.\n+     *\n+     * @param dx the number of blocks to add to the maximum corner on the x axis\n+     * @param dy the number of blocks to add to the maximum corner on the y axis\n+     * @param dz the number of blocks to add to the maximum corner on the z axis\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would be {@link #isValid() invalid}.\n+     */\n+    default BlockRegion addMax(int dx, int dy, int dz, BlockRegion dest) {\n+        return this.setMax(maxX() + dx, maxY() + dy, maxZ() + dz, dest);\n+    }\n+\n+    /**\n+     * Translate the maximum corner of the region by adding given {@code (dx, dy, dz)}.\n+     *\n+     * @param dmax the translation vector for the maximum corner\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would be {@link #isValid() invalid}.\n+     */\n+    default BlockRegion addMax(Vector3ic dmax, BlockRegion dest) {\n+        return this.addMax(dmax.x(), dmax.y(), dmax.z(), dest);\n+    }\n+\n+    // -- size ------------------------------------------------------------------------------------------------------//\n+\n+    /**\n+     * The number of blocks on the x axis.\n+     */\n+    default int getSizeX() {\n+        return maxX() - minX() + 1;\n+    }\n+\n+    /**\n+     * The number of blocks on the y axis.\n+     */\n+    default int getSizeY() {\n+        return maxY() - minY() + 1;\n+    }\n+\n+    /**\n+     * The number of blocks on the z axis.\n+     */\n+    default int getSizeZ() {\n+        return maxZ() - minZ() + 1;\n+    }\n+\n+    /**\n+     * The number of blocks in this region along the +x, +y, +z  axis from the minimum to the maximum corner.\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    default Vector3i getSize(Vector3i dest) {\n+        return dest.set(getSizeX(), getSizeY(), getSizeZ());\n+    }\n+\n+    /**\n+     * Set the size of the block region from the minimum corner.\n+     *\n+     * @param x the x coordinate to set the size; must be > 0\n+     * @param y the y coordinate to set the size; must be > 0\n+     * @param z the z coordinate to set the size; must be >\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n+     */\n+    BlockRegion setSize(int x, int y, int z, BlockRegion dest);\n+\n+    /**\n+     * Set the size of the block region from the minimum corner.\n+     *\n+     * @param size the size to set; all dimensions must be > 0\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n+     */\n+    default BlockRegion setSize(Vector3ic size, BlockRegion dest) {\n+        return this.setSize(size.x(), size.y(), size.z(), dest);\n+    }\n+\n+    /**\n+     * The volume of this region in blocks, i.e., the number of blocks contained in this region.\n+     * <p>\n+     * The volume is computed by\n+     * <pre>\n+     *     volume = sizeX * sizeY * sizeZ;\n+     * </pre>\n+     *\n+     * @return the volume in blocks\n+     */\n+    default int volume() {\n+        return getSizeX() * getSizeY() * getSizeZ();\n+    }\n+\n+    // -- world -----------------------------------------------------------------------------------------------------//\n+\n+    /**\n+     * The bounding box in world coordinates.\n+     * <p>\n+     * The bounding box of a single block at {@code (x, y, z)} is centered at the integer coordinate {@code (x, y, z)}\n+     * and extents by {@code 0.5} in each dimension.\n+     *\n+     * @param dest will hold the result\n+     * @return {@code dest}\n+     */\n+    //TODO: 1.9.26 has a constant interface for aabbf\n+    default AABBf getBounds(AABBf dest) {\n+        dest.minX = minX() - .5f;\n+        dest.minY = minY() - .5f;\n+        dest.minZ = minZ() - .5f;\n+\n+        dest.maxX = maxX() + .5f;\n+        dest.maxY = maxY() + .5f;\n+        dest.maxZ = maxZ() + .5f;\n+\n+        return dest;\n+    }\n+\n+    /**\n+     * The center of the region in world coordinates if the region is valid; {@link Float#NaN} otherwise.\n+     *\n+     * @param dest will hold the result\n+     * @return {@code dest}\n+     */\n+    default Vector3f center(Vector3f dest) {\n+        if (!this.isValid()) {\n+            return dest.set(Float.NaN);\n+        }\n+        return dest.set(\n+                (this.minX() - .5f) + ((this.maxX() - this.minX() + 1.0f) / 2.0f),\n+                (this.minY() - .5f) + ((this.maxY() - this.minY() + 1.0f) / 2.0f),\n+                (this.minZ() - .5f) + ((this.maxZ() - this.minZ() + 1.0f) / 2.0f)\n+        );\n+    }\n+\n+    // -- IN-PLACE MUTATION -----------------------------------------------------------------------------------------//\n+    // -- union -----------------------------------------------------------------------------------------------------//\n+\n+    /**\n+     * Compute the union of this region and the given block coordinate.\n+     *\n+     * @param x the x coordinate of the block\n+     * @param y the y coordinate of the block\n+     * @param z the z coordinate of the block\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     */\n+    BlockRegion union(int x, int y, int z, BlockRegion dest);\n+\n+    /**\n+     * Compute the union of this region and the given block coordinate.\n+     *\n+     * @param pos the position of the block\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     */\n+    default BlockRegion union(Vector3ic pos, BlockRegion dest) {\n+        return this.union(pos.x(), pos.y(), pos.z(), dest);\n+    }\n+\n+    /**\n+     * Compute the union of this region and the other region.\n+     *\n+     * @param other {@link BlockRegion}\n+     * @param dest destination; will hold the result\n+     * @return @code dest} (after modification)\n+     */\n+    default BlockRegion union(BlockRegionc other, BlockRegion dest) {\n+        return this.union(other.minX(), other.minY(), other.minZ(), dest)\n+                .union(other.maxX(), other.maxY(), other.maxZ(), dest);\n+    }\n+\n+    // -- intersect -------------------------------------------------------------------------------------------------//\n+\n+    /**\n+     * Compute the intersection of this region with the {@code other} region.\n+     * <p>\n+     * NOTE: If the regions don't intersect the destination region will become invalid!\n+     *\n+     * @param other the other region\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification) or {@link Optional#empty()} if the regions don't intersect\n+     */\n+    Optional<BlockRegion> intersect(BlockRegionc other, BlockRegion dest);\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    /**\n+     * Translate this region by the given vector {@code (x, y, z))}.\n+     *\n+     * @param dx the x coordinate to translate by\n+     * @param dy the y coordinate to translate by\n+     * @param dz the z coordinate to translate by\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     */\n+    BlockRegion translate(int dx, int dy, int dz, BlockRegion dest);\n+\n+    /**\n+     * Translate this region by the given vector {@code vec}.\n+     *\n+     * @param vec the vector to translate by\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     */\n+    default BlockRegion translate(Vector3ic vec, BlockRegion dest) {\n+        return this.translate(vec.x(), vec.y(), vec.z(), dest);\n+    }\n+\n+    // -- expand -----------------------------------------------------------------------------------------------------//\n+\n+    /**\n+     * Expand this region by adding the given {@code extents} for each face of the region.\n+     *\n+     * @param dx the amount of blocks to extend this region by along the x axis in both directions\n+     * @param dy the amount of blocks to extend this region by along the y axis in both directions\n+     * @param dz the amount of blocks to extend this region by along the z axis in both directions\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n+     */\n+    BlockRegion expand(int dx, int dy, int dz, BlockRegion dest);\n+\n+    /**\n+     * Expand this region by adding the given {@code extents} for each face of a region.\n+     *\n+     * @param vec the amount of blocks to expand this region by\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n+     */\n+    default BlockRegion expand(Vector3ic vec, BlockRegion dest) {\n+        return this.expand(vec.x(), vec.y(), vec.z(), dest);\n+    }\n+\n+    /**\n+     * Extend this region by adding the given {@code extents} for each face of a region.\n+     * <p>\n+     * The extents will be floored for each dimension.\n+     *\n+     * @param dx the amount of blocks to extend this region by along the x axis in both directions\n+     * @param dy the amount of blocks to extend this region by along the y axis in both directions\n+     * @param dz the amount of blocks to extend this region by along the z axis in both directions\n+     * @param dest destination; will hold the result\n+     * @return {@code dest} (after modification)\n+     * @throws IllegalArgumentException if extending this region would result in any non-positive dimension\n+     */\n+    //TODO: why do we offer float variants here?\n+    default BlockRegion expand(float dx, float dy, float dz, BlockRegion dest) {\n+        return this.expand(\n+                Math.roundUsing(dx, RoundingMode.FLOOR),\n+                Math.roundUsing(dy, RoundingMode.FLOOR),\n+                Math.roundUsing(dz, RoundingMode.FLOOR),\n+                dest);\n+    }", "originalCommit": "533fd585860012b1ee8b3d136c67e68d95909278", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI3Njc0MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548276741", "bodyText": "I don't understand why we need expand to accept float values in the first place.\nCan a BlockRegion contain only parts of blocks? If not I don't see a use case in which we would need to support float input.\n@pollend what do you think?", "author": "jdrueckert", "createdAt": "2020-12-23T22:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI2ODkzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "067a5dca8b24f8ceb55e6e899770e2966aad1c1a", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegionc.java b/engine/src/main/java/org/terasology/world/block/BlockRegionc.java\nindex ea69fb23f..1b0bc33f4 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegionc.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegionc.java\n\n@@ -128,7 +128,7 @@ default BlockRegion setMin(Vector3ic min, BlockRegion dest) {\n      * @return {@code dest} (after modification)\n      * @throws IllegalArgumentException if the resulting region would be {@link #isValid() invalid}.\n      */\n-    default BlockRegion addMin(int dx, int dy, int dz, BlockRegion dest) {\n+    default BlockRegion addToMin(int dx, int dy, int dz, BlockRegion dest) {\n         return this.setMin(minX() + dx, minY() + dy, minZ() + dz, dest);\n     }\n \n"}}, {"oid": "067a5dca8b24f8ceb55e6e899770e2966aad1c1a", "url": "https://github.com/MovingBlocks/Terasology/commit/067a5dca8b24f8ceb55e6e899770e2966aad1c1a", "message": "fix: rename rename addM[in|ax] to addToM[in|ax] in interface class", "committedDate": "2020-12-23T22:42:30Z", "type": "commit"}, {"oid": "fd8b77246293594425aa72ea03135dc2f9334370", "url": "https://github.com/MovingBlocks/Terasology/commit/fd8b77246293594425aa72ea03135dc2f9334370", "message": "remove expand with float arguments", "committedDate": "2020-12-23T22:43:55Z", "type": "commit"}, {"oid": "b359b2e64c078c8ddf0e72bce03b9fd4776a0584", "url": "https://github.com/MovingBlocks/Terasology/commit/b359b2e64c078c8ddf0e72bce03b9fd4776a0584", "message": "fix(BlockRegion): correct some implementation errors", "committedDate": "2020-12-23T22:47:07Z", "type": "commit"}, {"oid": "fe5423f19b2c1103a403ae96a65e6a7611f6c389", "url": "https://github.com/MovingBlocks/Terasology/commit/fe5423f19b2c1103a403ae96a65e6a7611f6c389", "message": "test(BlockRegion): fix broken test; remove expand(float) tests", "committedDate": "2020-12-23T22:59:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1NDg3NQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548354875", "bodyText": "A setter like this just looks kind of strange to me. all it does is write to the dest with a substitution of a single value.  I don't really seeing this adding much to the API.\nBlockRegion a = new BlockRegion(0,0,0);\n\nBlockRegion b = new BlockRegion(a).minY(-1);\nvs\nBlockRegion b = a.minY(-1, new BlockRegion(BlockRegion.INVALID));", "author": "pollend", "createdAt": "2020-12-24T02:32:32Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -93,550 +104,349 @@\n      *\n      * @param source the block region to copy.\n      */\n-    public BlockRegion(BlockRegion source) {\n+    public BlockRegion(BlockRegionc source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * set source to current region\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @param source the source region\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n-\n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n-        return this;\n-    }\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+        Preconditions.checkArgument(minZ <= maxZ || (minZ == INVALID.minZ() && maxZ == INVALID.maxZ()));\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n+        return this;\n     }\n \n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * The x-coordinate of the minimum corner\n+     * Reset both the minimum and maximum corner of this region.\n+     *\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public int minX() {\n-        return this.minX;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    public BlockRegion set(BlockRegionc source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block x\n-     *\n-     * @return the minX\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n+    @Override\n     public int minY() {\n         return this.minY;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block y\n-     *\n-     * @return the minY\n-     */\n-    public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        return dest.set(x, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);", "originalCommit": "fe5423f19b2c1103a403ae96a65e6a7611f6c389", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e0585c20f6bf6dc300e0caa1b82a0228af67ea7", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 38d9f07ce..ee57275a5 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -228,55 +227,73 @@ public int minZ() {\n         return this.minZ;\n     }\n \n-    @Override\n-    public BlockRegion minX(int x, BlockRegion dest) {\n-        return dest.set(x, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);\n-    }\n-\n+    /**\n+     * Set the minimum x-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minX(int x) {\n-        return this.minX(x, this);\n-    }\n-\n-    @Override\n-    public BlockRegion minY(int y, BlockRegion dest) {\n-        return dest.set(this.minX, y, this.minZ, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(x <= maxX);\n+        this.minX = x;\n+        return this;\n     }\n \n+    /**\n+     * Set the minimum y-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minY(int y) {\n-        return this.minY(y, this);\n-    }\n-\n-    @Override\n-    public BlockRegion minZ(int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, z, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(y <= maxY);\n+        this.minY = y;\n+        return this;\n     }\n \n+    /**\n+     * Set the minimum z-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minZ(int z) {\n-        return this.minZ(z, this);\n-    }\n-\n-    @Override\n-    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n-        return dest.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(z <= maxZ);\n+        this.minZ = z;\n+        return this;\n     }\n \n-    public BlockRegion setMin(int x, int y, int z) {\n-        return this.setMin(x, y, z, this);\n+    /**\n+     * Set the coordinates of the minimum corner for this region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n+    public BlockRegion setMin(int minX, int minY, int minZ) {\n+        return this.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n     public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min, this);\n+        return this.setMin(min.x(), min.y(), min.z());\n     }\n \n+    /**\n+     * Translate the minimum corner of the region by adding given {@code (dx, dy, dz)}.\n+     *\n+     * @param dx the number of blocks to add to the minimum corner on the x axis\n+     * @param dy the number of blocks to add to the minimum corner on the y axis\n+     * @param dz the number of blocks to add to the minimum corner on the z axis\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion addToMin(int dx, int dy, int dz) {\n-        return this.addToMin(dx, dy, dz, this);\n+        return this.setMin(minX() + dx, minY() + dy, minZ() + dz);\n     }\n \n     public BlockRegion addToMin(Vector3ic dmin) {\n-        return this.addToMin(dmin, this);\n+        return this.addToMin(dmin.x(), dmin.y(), dmin.z());\n     }\n \n-\n     // -- max --------------------------------------------------------------------------------------------------------//\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1NTkzNQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548355935", "bodyText": "I would drop this as well.", "author": "pollend", "createdAt": "2020-12-24T02:37:46Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -93,550 +104,349 @@\n      *\n      * @param source the block region to copy.\n      */\n-    public BlockRegion(BlockRegion source) {\n+    public BlockRegion(BlockRegionc source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * set source to current region\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @param source the source region\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n-\n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n-        return this;\n-    }\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+        Preconditions.checkArgument(minZ <= maxZ || (minZ == INVALID.minZ() && maxZ == INVALID.maxZ()));\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n+        return this;\n     }\n \n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * The x-coordinate of the minimum corner\n+     * Reset both the minimum and maximum corner of this region.\n+     *\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public int minX() {\n-        return this.minX;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    public BlockRegion set(BlockRegionc source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block x\n-     *\n-     * @return the minX\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n+    @Override\n     public int minY() {\n         return this.minY;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block y\n-     *\n-     * @return the minY\n-     */\n-    public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        return dest.set(x, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * The z-coordinate of the minimum corner\n-     */\n-    public int minZ() {\n-        return this.minZ;\n+    public BlockRegion minX(int x) {\n+        return this.minX(x, this);\n     }\n \n-    /**\n-     * the minimum coordinate of the first block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #minZ()}\n-     */\n-    @Deprecated\n-    public int getMinZ() {\n-        return this.minZ;\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n+        return dest.set(this.minX, y, this.minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block z\n-     *\n-     * @return the minZ\n-     */\n-    public BlockRegion minZ(int z) {\n-        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n-        this.minZ = z;\n-        return this;\n+    public BlockRegion minY(int y) {\n+        return this.minY(y, this);\n     }\n \n-    /**\n-     * Get the block coordinate minimum corner.\n-     *\n-     * @param dest will hold the result\n-     */\n-    public Vector3i getMin(Vector3i dest) {\n-        return dest.set(minX, minY, minZ);\n+    @Override\n+    public BlockRegion minZ(int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, z, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param min the first coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min.x(), min.y(), min.z());\n+    public BlockRegion minZ(int z) {\n+        return this.minZ(z, this);\n     }\n \n-    /**\n-     * sets the minimum block for this {@link BlockRegion}\n-     *\n-     * @param minX the x coordinate of the first block\n-     * @param minY the y coordinate of the first block\n-     * @param minZ the z coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMin(int minX, int minY, int minZ) {\n-        Preconditions.checkArgument(minX <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minY <= this.maxY || this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minZ <= this.maxZ || this.maxX == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        this.minZ = minZ;\n-        return this;\n+    @Override\n+    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n+        return dest.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);", "originalCommit": "fe5423f19b2c1103a403ae96a65e6a7611f6c389", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e0585c20f6bf6dc300e0caa1b82a0228af67ea7", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 38d9f07ce..ee57275a5 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -228,55 +227,73 @@ public int minZ() {\n         return this.minZ;\n     }\n \n-    @Override\n-    public BlockRegion minX(int x, BlockRegion dest) {\n-        return dest.set(x, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);\n-    }\n-\n+    /**\n+     * Set the minimum x-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minX(int x) {\n-        return this.minX(x, this);\n-    }\n-\n-    @Override\n-    public BlockRegion minY(int y, BlockRegion dest) {\n-        return dest.set(this.minX, y, this.minZ, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(x <= maxX);\n+        this.minX = x;\n+        return this;\n     }\n \n+    /**\n+     * Set the minimum y-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minY(int y) {\n-        return this.minY(y, this);\n-    }\n-\n-    @Override\n-    public BlockRegion minZ(int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, z, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(y <= maxY);\n+        this.minY = y;\n+        return this;\n     }\n \n+    /**\n+     * Set the minimum z-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minZ(int z) {\n-        return this.minZ(z, this);\n-    }\n-\n-    @Override\n-    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n-        return dest.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(z <= maxZ);\n+        this.minZ = z;\n+        return this;\n     }\n \n-    public BlockRegion setMin(int x, int y, int z) {\n-        return this.setMin(x, y, z, this);\n+    /**\n+     * Set the coordinates of the minimum corner for this region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n+    public BlockRegion setMin(int minX, int minY, int minZ) {\n+        return this.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n     public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min, this);\n+        return this.setMin(min.x(), min.y(), min.z());\n     }\n \n+    /**\n+     * Translate the minimum corner of the region by adding given {@code (dx, dy, dz)}.\n+     *\n+     * @param dx the number of blocks to add to the minimum corner on the x axis\n+     * @param dy the number of blocks to add to the minimum corner on the y axis\n+     * @param dz the number of blocks to add to the minimum corner on the z axis\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion addToMin(int dx, int dy, int dz) {\n-        return this.addToMin(dx, dy, dz, this);\n+        return this.setMin(minX() + dx, minY() + dy, minZ() + dz);\n     }\n \n     public BlockRegion addToMin(Vector3ic dmin) {\n-        return this.addToMin(dmin, this);\n+        return this.addToMin(dmin.x(), dmin.y(), dmin.z());\n     }\n \n-\n     // -- max --------------------------------------------------------------------------------------------------------//\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1NjY3Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548356676", "bodyText": "I would drop this as well. just as easy to just do new BlockRegion(a).setSize(3,3,3) or b.set(a).setSize(3,3,3) vs a.setSize(3,3,3, new BlockRegion(BlockRegion.INVALID));. A setter that sets the value of another object is kind of strange?", "author": "pollend", "createdAt": "2020-12-24T02:41:38Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -93,550 +104,349 @@\n      *\n      * @param source the block region to copy.\n      */\n-    public BlockRegion(BlockRegion source) {\n+    public BlockRegion(BlockRegionc source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * set source to current region\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @param source the source region\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n-\n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n-        return this;\n-    }\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+        Preconditions.checkArgument(minZ <= maxZ || (minZ == INVALID.minZ() && maxZ == INVALID.maxZ()));\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n+        return this;\n     }\n \n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * The x-coordinate of the minimum corner\n+     * Reset both the minimum and maximum corner of this region.\n+     *\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public int minX() {\n-        return this.minX;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    public BlockRegion set(BlockRegionc source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block x\n-     *\n-     * @return the minX\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n+    @Override\n     public int minY() {\n         return this.minY;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block y\n-     *\n-     * @return the minY\n-     */\n-    public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        return dest.set(x, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * The z-coordinate of the minimum corner\n-     */\n-    public int minZ() {\n-        return this.minZ;\n+    public BlockRegion minX(int x) {\n+        return this.minX(x, this);\n     }\n \n-    /**\n-     * the minimum coordinate of the first block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #minZ()}\n-     */\n-    @Deprecated\n-    public int getMinZ() {\n-        return this.minZ;\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n+        return dest.set(this.minX, y, this.minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block z\n-     *\n-     * @return the minZ\n-     */\n-    public BlockRegion minZ(int z) {\n-        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n-        this.minZ = z;\n-        return this;\n+    public BlockRegion minY(int y) {\n+        return this.minY(y, this);\n     }\n \n-    /**\n-     * Get the block coordinate minimum corner.\n-     *\n-     * @param dest will hold the result\n-     */\n-    public Vector3i getMin(Vector3i dest) {\n-        return dest.set(minX, minY, minZ);\n+    @Override\n+    public BlockRegion minZ(int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, z, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param min the first coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min.x(), min.y(), min.z());\n+    public BlockRegion minZ(int z) {\n+        return this.minZ(z, this);\n     }\n \n-    /**\n-     * sets the minimum block for this {@link BlockRegion}\n-     *\n-     * @param minX the x coordinate of the first block\n-     * @param minY the y coordinate of the first block\n-     * @param minZ the z coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMin(int minX, int minY, int minZ) {\n-        Preconditions.checkArgument(minX <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minY <= this.maxY || this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minZ <= this.maxZ || this.maxX == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        this.minZ = minZ;\n-        return this;\n+    @Override\n+    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n+        return dest.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    // -- max --------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * The x-coordinate of the maximum corner\n-     */\n-    public int maxX() {\n-        return this.maxX;\n+    public BlockRegion setMin(int x, int y, int z) {\n+        return this.setMin(x, y, z, this);\n     }\n \n-    /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #maxX()}\n-     */\n-    @Deprecated\n-    public int getMaxX() {\n-        return this.maxX;\n+    public BlockRegion setMin(Vector3ic min) {\n+        return this.setMin(min, this);\n     }\n \n-    /**\n-     * set the maximum coordinate of the second block x\n-     *\n-     * @return the minX\n-     */\n-    public BlockRegion maxX(int x) {\n-        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n-        this.maxX = x;\n-        return this;\n+    public BlockRegion addToMin(int dx, int dy, int dz) {\n+        return this.addToMin(dx, dy, dz, this);\n     }\n \n-    /**\n-     * The y-coordinate of the maximum corner\n-     */\n-    public int maxY() {\n-        return this.maxY;\n+    public BlockRegion addToMin(Vector3ic dmin) {\n+        return this.addToMin(dmin, this);\n     }\n \n-    /**\n-     * the maximum coordinate of the second block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #maxY()}\n-     */\n-    @Deprecated\n-    public int getMaxY() {\n-        return this.maxY;\n+\n+    // -- max --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int maxX() {\n+        return this.maxX;\n     }\n \n-    /**\n-     * set the maximum coordinate of the second block y\n-     *\n-     * @return the minY\n-     */\n-    public BlockRegion maxY(int y) {\n-        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n-        this.maxY = y;\n-        return this;\n+    @Override\n+    public int maxY() {\n+        return this.maxY;\n     }\n \n-    /**\n-     * The z-coordinate of the maximum corner\n-     */\n+    @Override\n     public int maxZ() {\n         return this.maxZ;\n     }\n \n-    /**\n-     * the maximum coordinate of the second block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #maxZ()}\n-     */\n-    @Deprecated\n-    public int getMaxZ() {\n-        return this.maxZ;\n+    @Override\n+    public BlockRegion maxX(int x, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, x, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * set the maximum coordinate of the second block z\n-     *\n-     * @return the minZ\n-     */\n-    public BlockRegion maxZ(int z) {\n-        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxZ = z;\n-        return this;\n+    public BlockRegion maxX(int x) {\n+        return this.maxX(x, this);\n     }\n \n-    /**\n-     * Get the block coordinate of the maximum corner.\n-     *\n-     * @param dest will hold the result\n-     */\n-    public Vector3i getMax(Vector3i dest) {\n-        return dest.set(maxX, maxY, maxZ);\n+    @Override\n+    public BlockRegion maxY(int y, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.maxX, y, this.maxZ);\n     }\n \n-    /**\n-     * Sets the maximum coordinate of the second block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param max the second coordinate of the second block\n-     * @return this\n-     */\n-    public BlockRegion setMax(Vector3ic max) {\n-        return this.setMax(max.x(), max.y(), max.z());\n+    public BlockRegion maxY(int y) {\n+        return this.maxY(y, this);\n     }\n \n-    /**\n-     * sets the maximum block for this {@link BlockRegion}\n-     *\n-     * @param maxX the x coordinate of the first block\n-     * @param maxY the y coordinate of the first block\n-     * @param maxZ the z coordinate of the first block\n-     * @return this\n-     */\n-    public BlockRegion setMax(int maxX, int maxY, int maxZ) {\n-        Preconditions.checkArgument(maxX >= this.minX || this.minX == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxY >= this.minY || this.minY == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxZ >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        this.maxZ = maxZ;\n-        return this;\n+    @Override\n+    public BlockRegion maxZ(int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.maxX, this.maxY, z);\n     }\n \n-    // -- size -------------------------------------------------------------------------------------------------------//\n-\n-    /**\n-     * Set the size of the block region from minimum the minimum corner.\n-     *\n-     * @param x the x coordinate to set the size; must be > 0\n-     * @param y the y coordinate to set the size; must be > 0\n-     * @param z the z coordinate to set the size; must be > 0\n-     * @return this after modification\n-     */\n-    public BlockRegion setSize(int x, int y, int z) {\n-        Preconditions.checkArgument(x > 0);\n-        Preconditions.checkArgument(y > 0);\n-        Preconditions.checkArgument(z > 0);\n-        this.maxX = this.minX + x - 1;\n-        this.maxY = this.minY + y - 1;\n-        this.maxZ = this.minZ + z - 1;\n-        return this;\n+    public BlockRegion maxZ(int z) {\n+        return this.maxZ(z, this);\n     }\n \n-    /**\n-     * Set the size of the block region from minimum the minimum corner.\n-     *\n-     * @param size the size to set; all dimensions must be > 0\n-     * @return this after modification\n-     */\n-    public BlockRegion setSize(Vector3ic size) {\n-        return setSize(size.x(), size.y(), size.z());\n+    @Override\n+    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, maxX, maxY, maxZ);\n     }\n \n-    /**\n-     * the number of blocks for the +x, +y, +z from the minimum to the maximum\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector3i getSize(Vector3i dest) {\n-        return dest.set(sizeX(), sizeY(), sizeZ());\n+    public BlockRegion setMax(int x, int y, int z) {\n+        return this.setMax(x, y, z, this);\n     }\n \n-    /**\n-     * The number of blocks on the X axis\n-     *\n-     * @return number of blocks in the X axis\n-     */\n-    public int sizeX() {\n-        return this.maxX - this.minX + 1;\n+    public BlockRegion setMax(Vector3ic max) {\n+        return this.setMax(max, this);\n     }\n \n-    /**\n-     * The number of blocks on the Y axis\n-     *\n-     * @return number of blocks in the Y axis\n-     */\n-    public int sizeY() {\n-        return this.maxY - this.minY + 1;\n+    public BlockRegion addToMax(int dx, int dy, int dz) {\n+        return this.addToMax(dx, dy, dz, this);\n     }\n \n-    /**\n-     * The number of blocks on the Z axis\n-     *\n-     * @return number of blocks in the Z axis\n-     */\n-    public int sizeZ() {\n-        return this.maxZ - this.minZ + 1;\n+    public BlockRegion addToMax(Vector3ic dmax) {\n+        return this.addToMax(dmax, this);\n     }\n \n-    // -- world ------------------------------------------------------------------------------------------------------//\n-\n-    //TODO: 1.9.26 has a constant interface for aabbf\n-    public AABBf getBounds(AABBf dest) {\n-        dest.minX = minX - .5f;\n-        dest.minY = minY - .5f;\n-        dest.minZ = minZ - .5f;\n+    // -- size -------------------------------------------------------------------------------------------------------//\n \n-        dest.maxX = maxX + .5f;\n-        dest.maxY = maxY + .5f;\n-        dest.maxZ = maxZ + .5f;\n+    @Override\n+    public BlockRegion setSize(int x, int y, int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.minX + x, this.minY + y, this.minZ + z);\n+    }", "originalCommit": "fe5423f19b2c1103a403ae96a65e6a7611f6c389", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ4MTEyMA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548481120", "bodyText": "A setter that sets the value of another object is kind of strange?\n\nI'm REALLY confused by now o.O At first I was confused by this pattern in JOML, than you and others explained to me why that's a good thing. Now, it seems the other way around, and we should probably not offer those dest variants at all...\nIn all cases, these two expressions are equivalent:\na.op(b, dest) == dest.set(a).op(b)", "author": "skaldarnar", "createdAt": "2020-12-24T10:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1NjY3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODU1OTMyNA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548559324", "bodyText": "Drop the dest variations for the setters. They're simple enough for the most part not to need it. I guess that can be debatable. Maybe size might be fine.", "author": "pollend", "createdAt": "2020-12-24T15:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1NjY3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6e0585c20f6bf6dc300e0caa1b82a0228af67ea7", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 38d9f07ce..ee57275a5 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -228,55 +227,73 @@ public int minZ() {\n         return this.minZ;\n     }\n \n-    @Override\n-    public BlockRegion minX(int x, BlockRegion dest) {\n-        return dest.set(x, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);\n-    }\n-\n+    /**\n+     * Set the minimum x-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minX(int x) {\n-        return this.minX(x, this);\n-    }\n-\n-    @Override\n-    public BlockRegion minY(int y, BlockRegion dest) {\n-        return dest.set(this.minX, y, this.minZ, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(x <= maxX);\n+        this.minX = x;\n+        return this;\n     }\n \n+    /**\n+     * Set the minimum y-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minY(int y) {\n-        return this.minY(y, this);\n-    }\n-\n-    @Override\n-    public BlockRegion minZ(int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, z, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(y <= maxY);\n+        this.minY = y;\n+        return this;\n     }\n \n+    /**\n+     * Set the minimum z-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minZ(int z) {\n-        return this.minZ(z, this);\n-    }\n-\n-    @Override\n-    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n-        return dest.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(z <= maxZ);\n+        this.minZ = z;\n+        return this;\n     }\n \n-    public BlockRegion setMin(int x, int y, int z) {\n-        return this.setMin(x, y, z, this);\n+    /**\n+     * Set the coordinates of the minimum corner for this region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n+    public BlockRegion setMin(int minX, int minY, int minZ) {\n+        return this.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n     public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min, this);\n+        return this.setMin(min.x(), min.y(), min.z());\n     }\n \n+    /**\n+     * Translate the minimum corner of the region by adding given {@code (dx, dy, dz)}.\n+     *\n+     * @param dx the number of blocks to add to the minimum corner on the x axis\n+     * @param dy the number of blocks to add to the minimum corner on the y axis\n+     * @param dz the number of blocks to add to the minimum corner on the z axis\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion addToMin(int dx, int dy, int dz) {\n-        return this.addToMin(dx, dy, dz, this);\n+        return this.setMin(minX() + dx, minY() + dy, minZ() + dz);\n     }\n \n     public BlockRegion addToMin(Vector3ic dmin) {\n-        return this.addToMin(dmin, this);\n+        return this.addToMin(dmin.x(), dmin.y(), dmin.z());\n     }\n \n-\n     // -- max --------------------------------------------------------------------------------------------------------//\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1OTAzMw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548359033", "bodyText": "I would drop this as well.", "author": "pollend", "createdAt": "2020-12-24T02:53:13Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -93,550 +104,349 @@\n      *\n      * @param source the block region to copy.\n      */\n-    public BlockRegion(BlockRegion source) {\n+    public BlockRegion(BlockRegionc source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * set source to current region\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @param source the source region\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n-\n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n-        return this;\n-    }\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+        Preconditions.checkArgument(minZ <= maxZ || (minZ == INVALID.minZ() && maxZ == INVALID.maxZ()));\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n+        return this;\n     }\n \n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * The x-coordinate of the minimum corner\n+     * Reset both the minimum and maximum corner of this region.\n+     *\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public int minX() {\n-        return this.minX;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    public BlockRegion set(BlockRegionc source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block x\n-     *\n-     * @return the minX\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n+    @Override\n     public int minY() {\n         return this.minY;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block y\n-     *\n-     * @return the minY\n-     */\n-    public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        return dest.set(x, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * The z-coordinate of the minimum corner\n-     */\n-    public int minZ() {\n-        return this.minZ;\n+    public BlockRegion minX(int x) {\n+        return this.minX(x, this);\n     }\n \n-    /**\n-     * the minimum coordinate of the first block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #minZ()}\n-     */\n-    @Deprecated\n-    public int getMinZ() {\n-        return this.minZ;\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n+        return dest.set(this.minX, y, this.minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block z\n-     *\n-     * @return the minZ\n-     */\n-    public BlockRegion minZ(int z) {\n-        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n-        this.minZ = z;\n-        return this;\n+    public BlockRegion minY(int y) {\n+        return this.minY(y, this);\n     }\n \n-    /**\n-     * Get the block coordinate minimum corner.\n-     *\n-     * @param dest will hold the result\n-     */\n-    public Vector3i getMin(Vector3i dest) {\n-        return dest.set(minX, minY, minZ);\n+    @Override\n+    public BlockRegion minZ(int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, z, this.maxX, this.maxY, this.maxZ);\n     }", "originalCommit": "fe5423f19b2c1103a403ae96a65e6a7611f6c389", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e0585c20f6bf6dc300e0caa1b82a0228af67ea7", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 38d9f07ce..ee57275a5 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -228,55 +227,73 @@ public int minZ() {\n         return this.minZ;\n     }\n \n-    @Override\n-    public BlockRegion minX(int x, BlockRegion dest) {\n-        return dest.set(x, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);\n-    }\n-\n+    /**\n+     * Set the minimum x-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minX(int x) {\n-        return this.minX(x, this);\n-    }\n-\n-    @Override\n-    public BlockRegion minY(int y, BlockRegion dest) {\n-        return dest.set(this.minX, y, this.minZ, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(x <= maxX);\n+        this.minX = x;\n+        return this;\n     }\n \n+    /**\n+     * Set the minimum y-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minY(int y) {\n-        return this.minY(y, this);\n-    }\n-\n-    @Override\n-    public BlockRegion minZ(int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, z, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(y <= maxY);\n+        this.minY = y;\n+        return this;\n     }\n \n+    /**\n+     * Set the minimum z-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minZ(int z) {\n-        return this.minZ(z, this);\n-    }\n-\n-    @Override\n-    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n-        return dest.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(z <= maxZ);\n+        this.minZ = z;\n+        return this;\n     }\n \n-    public BlockRegion setMin(int x, int y, int z) {\n-        return this.setMin(x, y, z, this);\n+    /**\n+     * Set the coordinates of the minimum corner for this region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n+    public BlockRegion setMin(int minX, int minY, int minZ) {\n+        return this.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n     public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min, this);\n+        return this.setMin(min.x(), min.y(), min.z());\n     }\n \n+    /**\n+     * Translate the minimum corner of the region by adding given {@code (dx, dy, dz)}.\n+     *\n+     * @param dx the number of blocks to add to the minimum corner on the x axis\n+     * @param dy the number of blocks to add to the minimum corner on the y axis\n+     * @param dz the number of blocks to add to the minimum corner on the z axis\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion addToMin(int dx, int dy, int dz) {\n-        return this.addToMin(dx, dy, dz, this);\n+        return this.setMin(minX() + dx, minY() + dy, minZ() + dz);\n     }\n \n     public BlockRegion addToMin(Vector3ic dmin) {\n-        return this.addToMin(dmin, this);\n+        return this.addToMin(dmin.x(), dmin.y(), dmin.z());\n     }\n \n-\n     // -- max --------------------------------------------------------------------------------------------------------//\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1OTA1MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548359050", "bodyText": "I would drop this as well.", "author": "pollend", "createdAt": "2020-12-24T02:53:20Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -93,550 +104,349 @@\n      *\n      * @param source the block region to copy.\n      */\n-    public BlockRegion(BlockRegion source) {\n+    public BlockRegion(BlockRegionc source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * set source to current region\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @param source the source region\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n-\n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n-        return this;\n-    }\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+        Preconditions.checkArgument(minZ <= maxZ || (minZ == INVALID.minZ() && maxZ == INVALID.maxZ()));\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n+        return this;\n     }\n \n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * The x-coordinate of the minimum corner\n+     * Reset both the minimum and maximum corner of this region.\n+     *\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public int minX() {\n-        return this.minX;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    public BlockRegion set(BlockRegionc source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block x\n-     *\n-     * @return the minX\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n+    @Override\n     public int minY() {\n         return this.minY;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block y\n-     *\n-     * @return the minY\n-     */\n-    public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n-        return this;\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        return dest.set(x, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * The z-coordinate of the minimum corner\n-     */\n-    public int minZ() {\n-        return this.minZ;\n+    public BlockRegion minX(int x) {\n+        return this.minX(x, this);\n     }\n \n-    /**\n-     * the minimum coordinate of the first block z\n-     *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #minZ()}\n-     */\n-    @Deprecated\n-    public int getMinZ() {\n-        return this.minZ;\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n+        return dest.set(this.minX, y, this.minZ, this.maxX, this.maxY, this.maxZ);\n     }", "originalCommit": "fe5423f19b2c1103a403ae96a65e6a7611f6c389", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e0585c20f6bf6dc300e0caa1b82a0228af67ea7", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 38d9f07ce..ee57275a5 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -228,55 +227,73 @@ public int minZ() {\n         return this.minZ;\n     }\n \n-    @Override\n-    public BlockRegion minX(int x, BlockRegion dest) {\n-        return dest.set(x, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);\n-    }\n-\n+    /**\n+     * Set the minimum x-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minX(int x) {\n-        return this.minX(x, this);\n-    }\n-\n-    @Override\n-    public BlockRegion minY(int y, BlockRegion dest) {\n-        return dest.set(this.minX, y, this.minZ, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(x <= maxX);\n+        this.minX = x;\n+        return this;\n     }\n \n+    /**\n+     * Set the minimum y-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minY(int y) {\n-        return this.minY(y, this);\n-    }\n-\n-    @Override\n-    public BlockRegion minZ(int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, z, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(y <= maxY);\n+        this.minY = y;\n+        return this;\n     }\n \n+    /**\n+     * Set the minimum z-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion minZ(int z) {\n-        return this.minZ(z, this);\n-    }\n-\n-    @Override\n-    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n-        return dest.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n+        Preconditions.checkArgument(z <= maxZ);\n+        this.minZ = z;\n+        return this;\n     }\n \n-    public BlockRegion setMin(int x, int y, int z) {\n-        return this.setMin(x, y, z, this);\n+    /**\n+     * Set the coordinates of the minimum corner for this region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n+    public BlockRegion setMin(int minX, int minY, int minZ) {\n+        return this.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n     public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min, this);\n+        return this.setMin(min.x(), min.y(), min.z());\n     }\n \n+    /**\n+     * Translate the minimum corner of the region by adding given {@code (dx, dy, dz)}.\n+     *\n+     * @param dx the number of blocks to add to the minimum corner on the x axis\n+     * @param dy the number of blocks to add to the minimum corner on the y axis\n+     * @param dz the number of blocks to add to the minimum corner on the z axis\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion addToMin(int dx, int dy, int dz) {\n-        return this.addToMin(dx, dy, dz, this);\n+        return this.setMin(minX() + dx, minY() + dy, minZ() + dz);\n     }\n \n     public BlockRegion addToMin(Vector3ic dmin) {\n-        return this.addToMin(dmin, this);\n+        return this.addToMin(dmin.x(), dmin.y(), dmin.z());\n     }\n \n-\n     // -- max --------------------------------------------------------------------------------------------------------//\n \n     @Override\n"}}, {"oid": "6e0585c20f6bf6dc300e0caa1b82a0228af67ea7", "url": "https://github.com/MovingBlocks/Terasology/commit/6e0585c20f6bf6dc300e0caa1b82a0228af67ea7", "message": "refactor!(BlockRegion): remove modifiers with explicit destination", "committedDate": "2020-12-24T11:49:01Z", "type": "commit"}, {"oid": "d05c5b3bbbdc7e6ee692eb2c1ae92e952a8c48b1", "url": "https://github.com/MovingBlocks/Terasology/commit/d05c5b3bbbdc7e6ee692eb2c1ae92e952a8c48b1", "message": "feat(BlockRegion): add `setPosition` modifier", "committedDate": "2020-12-24T11:49:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYxMTcxNQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548611715", "bodyText": "why did you drop this?", "author": "pollend", "createdAt": "2020-12-24T16:45:54Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -294,132 +311,171 @@ public int maxZ() {\n         return this.maxZ;\n     }\n \n-    @Override\n-    public BlockRegion maxX(int x, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, x, this.maxY, this.maxZ);\n-    }\n-\n+    /**\n+     * Set the maximum x-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion maxX(int x) {\n-        return this.maxX(x, this);\n-    }\n-\n-    @Override\n-    public BlockRegion maxY(int y, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, this.maxX, y, this.maxZ);\n+        Preconditions.checkArgument(x >= minX);\n+        this.maxX = x;\n+        return this;\n     }\n \n+    /**\n+     * Set the maximum y-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion maxY(int y) {\n-        return this.maxY(y, this);\n-    }\n-\n-    @Override\n-    public BlockRegion maxZ(int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, this.maxX, this.maxY, z);\n+        Preconditions.checkArgument(y >= minY);\n+        this.maxY = y;\n+        return this;\n     }\n \n+    /**\n+     * Set the maximum z-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion maxZ(int z) {\n-        return this.maxZ(z, this);\n-    }\n-\n-    @Override\n-    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, maxX, maxY, maxZ);\n+        Preconditions.checkArgument(z >= minZ);\n+        this.maxZ = z;\n+        return this;\n     }\n \n+    /**\n+     * Set the coordinates of the maximum corner for this region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion setMax(int x, int y, int z) {\n-        return this.setMax(x, y, z, this);\n+        return this.set(this.minX, this.minY, this.minZ, x, y, z);\n     }\n \n     public BlockRegion setMax(Vector3ic max) {\n-        return this.setMax(max, this);\n+        return this.setMax(max.x(), max.y(), max.z());\n     }\n \n+    /**\n+     * Translate the maximum corner of the region by adding given {@code (dx, dy, dz)}.\n+     *\n+     * @param dx the number of blocks to add to the maximum corner on the x axis\n+     * @param dy the number of blocks to add to the maximum corner on the y axis\n+     * @param dz the number of blocks to add to the maximum corner on the z axis\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion addToMax(int dx, int dy, int dz) {\n-        return this.addToMax(dx, dy, dz, this);\n+        return this.setMax(this.maxX + dx, this.maxY + dy, this.maxZ + dz);\n     }\n \n     public BlockRegion addToMax(Vector3ic dmax) {\n-        return this.addToMax(dmax, this);\n+        return this.addToMax(dmax.x(), dmax.y(), dmax.z());\n     }\n \n     // -- size -------------------------------------------------------------------------------------------------------//\n \n-    @Override\n-    public BlockRegion setSize(int x, int y, int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, this.minX + x, this.minY + y, this.minZ + z);\n-    }\n-\n+    /**\n+     * Set the size of the block region from the minimum corner.\n+     *\n+     * @param x the x coordinate to set the size; must be > 0\n+     * @param y the y coordinate to set the size; must be > 0\n+     * @param z the z coordinate to set the size; must be > 0\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n+     */\n     public BlockRegion setSize(int x, int y, int z) {\n-        return this.setSize(x, y, z, this);\n+        return this.setMax(this.minX + x, this.minY + y, this.minZ);\n     }\n \n     public BlockRegion setSize(Vector3ic size) {\n         return setSize(size.x(), size.y(), size.z());\n     }\n \n     // -- IN-PLACE MUTATION ------------------------------------------------------------------------------------------//\n-    @Override\n-    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n-        dest.minX = Math.min(this.minX, x);\n-        dest.minY = Math.min(this.minY, y);\n-        dest.minZ = Math.min(this.minZ, z);\n-\n-        dest.maxX = Math.max(this.maxX, x);\n-        dest.maxY = Math.max(this.maxY, y);\n-        dest.maxZ = Math.max(this.maxZ, z);\n-        return dest;\n-    }", "originalCommit": "6e0585c20f6bf6dc300e0caa1b82a0228af67ea7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7962383de4a81f2613fb579202c20392c411b526", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex ee57275a5..5bc0608a7 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -311,86 +294,63 @@ public int maxZ() {\n         return this.maxZ;\n     }\n \n-    /**\n-     * Set the maximum x-coordinate of the region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n+    @Override\n+    public BlockRegion maxX(int x, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, x, this.maxY, this.maxZ);\n+    }\n+\n     public BlockRegion maxX(int x) {\n-        Preconditions.checkArgument(x >= minX);\n-        this.maxX = x;\n-        return this;\n+        return this.maxX(x, this);\n+    }\n+\n+    @Override\n+    public BlockRegion maxY(int y, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.maxX, y, this.maxZ);\n     }\n \n-    /**\n-     * Set the maximum y-coordinate of the region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion maxY(int y) {\n-        Preconditions.checkArgument(y >= minY);\n-        this.maxY = y;\n-        return this;\n+        return this.maxY(y, this);\n+    }\n+\n+    @Override\n+    public BlockRegion maxZ(int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.maxX, this.maxY, z);\n     }\n \n-    /**\n-     * Set the maximum z-coordinate of the region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion maxZ(int z) {\n-        Preconditions.checkArgument(z >= minZ);\n-        this.maxZ = z;\n-        return this;\n+        return this.maxZ(z, this);\n+    }\n+\n+    @Override\n+    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, maxX, maxY, maxZ);\n     }\n \n-    /**\n-     * Set the coordinates of the maximum corner for this region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion setMax(int x, int y, int z) {\n-        return this.set(this.minX, this.minY, this.minZ, x, y, z);\n+        return this.setMax(x, y, z, this);\n     }\n \n     public BlockRegion setMax(Vector3ic max) {\n-        return this.setMax(max.x(), max.y(), max.z());\n+        return this.setMax(max, this);\n     }\n \n-    /**\n-     * Translate the maximum corner of the region by adding given {@code (dx, dy, dz)}.\n-     *\n-     * @param dx the number of blocks to add to the maximum corner on the x axis\n-     * @param dy the number of blocks to add to the maximum corner on the y axis\n-     * @param dz the number of blocks to add to the maximum corner on the z axis\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion addToMax(int dx, int dy, int dz) {\n-        return this.setMax(this.maxX + dx, this.maxY + dy, this.maxZ + dz);\n+        return this.addToMax(dx, dy, dz, this);\n     }\n \n     public BlockRegion addToMax(Vector3ic dmax) {\n-        return this.addToMax(dmax.x(), dmax.y(), dmax.z());\n+        return this.addToMax(dmax, this);\n     }\n \n     // -- size -------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Set the size of the block region from the minimum corner.\n-     *\n-     * @param x the x coordinate to set the size; must be > 0\n-     * @param y the y coordinate to set the size; must be > 0\n-     * @param z the z coordinate to set the size; must be > 0\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n-     */\n+    @Override\n+    public BlockRegion setSize(int x, int y, int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.minX + x, this.minY + y, this.minZ + z);\n+    }\n+\n     public BlockRegion setSize(int x, int y, int z) {\n-        return this.setMax(this.minX + x, this.minY + y, this.minZ);\n+        return this.setSize(x, y, z, this);\n     }\n \n     public BlockRegion setSize(Vector3ic size) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYxMTg4Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548611886", "bodyText": "this one is also fine.", "author": "pollend", "createdAt": "2020-12-24T16:46:10Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -294,132 +311,171 @@ public int maxZ() {\n         return this.maxZ;\n     }\n \n-    @Override\n-    public BlockRegion maxX(int x, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, x, this.maxY, this.maxZ);\n-    }\n-\n+    /**\n+     * Set the maximum x-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion maxX(int x) {\n-        return this.maxX(x, this);\n-    }\n-\n-    @Override\n-    public BlockRegion maxY(int y, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, this.maxX, y, this.maxZ);\n+        Preconditions.checkArgument(x >= minX);\n+        this.maxX = x;\n+        return this;\n     }\n \n+    /**\n+     * Set the maximum y-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion maxY(int y) {\n-        return this.maxY(y, this);\n-    }\n-\n-    @Override\n-    public BlockRegion maxZ(int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, this.maxX, this.maxY, z);\n+        Preconditions.checkArgument(y >= minY);\n+        this.maxY = y;\n+        return this;\n     }\n \n+    /**\n+     * Set the maximum z-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion maxZ(int z) {\n-        return this.maxZ(z, this);\n-    }\n-\n-    @Override\n-    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, maxX, maxY, maxZ);\n+        Preconditions.checkArgument(z >= minZ);\n+        this.maxZ = z;\n+        return this;\n     }\n \n+    /**\n+     * Set the coordinates of the maximum corner for this region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion setMax(int x, int y, int z) {\n-        return this.setMax(x, y, z, this);\n+        return this.set(this.minX, this.minY, this.minZ, x, y, z);\n     }\n \n     public BlockRegion setMax(Vector3ic max) {\n-        return this.setMax(max, this);\n+        return this.setMax(max.x(), max.y(), max.z());\n     }\n \n+    /**\n+     * Translate the maximum corner of the region by adding given {@code (dx, dy, dz)}.\n+     *\n+     * @param dx the number of blocks to add to the maximum corner on the x axis\n+     * @param dy the number of blocks to add to the maximum corner on the y axis\n+     * @param dz the number of blocks to add to the maximum corner on the z axis\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion addToMax(int dx, int dy, int dz) {\n-        return this.addToMax(dx, dy, dz, this);\n+        return this.setMax(this.maxX + dx, this.maxY + dy, this.maxZ + dz);\n     }\n \n     public BlockRegion addToMax(Vector3ic dmax) {\n-        return this.addToMax(dmax, this);\n+        return this.addToMax(dmax.x(), dmax.y(), dmax.z());\n     }\n \n     // -- size -------------------------------------------------------------------------------------------------------//\n \n-    @Override\n-    public BlockRegion setSize(int x, int y, int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, this.minX + x, this.minY + y, this.minZ + z);\n-    }\n-\n+    /**\n+     * Set the size of the block region from the minimum corner.\n+     *\n+     * @param x the x coordinate to set the size; must be > 0\n+     * @param y the y coordinate to set the size; must be > 0\n+     * @param z the z coordinate to set the size; must be > 0\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n+     */\n     public BlockRegion setSize(int x, int y, int z) {\n-        return this.setSize(x, y, z, this);\n+        return this.setMax(this.minX + x, this.minY + y, this.minZ);\n     }\n \n     public BlockRegion setSize(Vector3ic size) {\n         return setSize(size.x(), size.y(), size.z());\n     }\n \n     // -- IN-PLACE MUTATION ------------------------------------------------------------------------------------------//\n-    @Override\n-    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n-        dest.minX = Math.min(this.minX, x);\n-        dest.minY = Math.min(this.minY, y);\n-        dest.minZ = Math.min(this.minZ, z);\n-\n-        dest.maxX = Math.max(this.maxX, x);\n-        dest.maxY = Math.max(this.maxY, y);\n-        dest.maxZ = Math.max(this.maxZ, z);\n-        return dest;\n-    }\n \n+    /**\n+     * Compute the union of this region and the given block coordinate.\n+     *\n+     * @param x the x coordinate of the block\n+     * @param y the y coordinate of the block\n+     * @param z the z coordinate of the block\n+     * @return {@code this} (after modification)\n+     */\n     public BlockRegion union(int x, int y, int z) {\n-        return this.union(x, y, z, this);\n+        this.minX = Math.min(this.minX, x);\n+        this.minY = Math.min(this.minY, y);\n+        this.minZ = Math.min(this.minZ, z);\n+\n+        this.maxX = Math.max(this.maxX, x);\n+        this.maxY = Math.max(this.maxY, y);\n+        this.maxZ = Math.max(this.maxZ, z);\n+        return this;\n     }\n \n     public BlockRegion union(Vector3ic pos) {\n-        return union(pos.x(), pos.y(), pos.z(), this);\n+        return union(pos.x(), pos.y(), pos.z());\n     }\n \n+    /**\n+     * Compute the union of this region and the other region.\n+     *\n+     * @param other {@link BlockRegion}\n+     * @return @code this} (after modification)\n+     */\n     public BlockRegion union(BlockRegionc other) {\n-        return this.union(other, this);\n+        return this.union(other.minX(), other.minY(), other.minZ()).union(other.maxX(), other.maxY(), other.maxZ());\n     }\n \n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    @Override\n-    public Optional<BlockRegion> intersect(BlockRegionc other, BlockRegion dest) {\n-        dest.minX = Math.max(minX, other.minX());\n-        dest.minY = Math.max(minY, other.minY());\n-        dest.minZ = Math.max(minZ, other.minZ());", "originalCommit": "6e0585c20f6bf6dc300e0caa1b82a0228af67ea7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7962383de4a81f2613fb579202c20392c411b526", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex ee57275a5..5bc0608a7 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -311,86 +294,63 @@ public int maxZ() {\n         return this.maxZ;\n     }\n \n-    /**\n-     * Set the maximum x-coordinate of the region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n+    @Override\n+    public BlockRegion maxX(int x, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, x, this.maxY, this.maxZ);\n+    }\n+\n     public BlockRegion maxX(int x) {\n-        Preconditions.checkArgument(x >= minX);\n-        this.maxX = x;\n-        return this;\n+        return this.maxX(x, this);\n+    }\n+\n+    @Override\n+    public BlockRegion maxY(int y, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.maxX, y, this.maxZ);\n     }\n \n-    /**\n-     * Set the maximum y-coordinate of the region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion maxY(int y) {\n-        Preconditions.checkArgument(y >= minY);\n-        this.maxY = y;\n-        return this;\n+        return this.maxY(y, this);\n+    }\n+\n+    @Override\n+    public BlockRegion maxZ(int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.maxX, this.maxY, z);\n     }\n \n-    /**\n-     * Set the maximum z-coordinate of the region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion maxZ(int z) {\n-        Preconditions.checkArgument(z >= minZ);\n-        this.maxZ = z;\n-        return this;\n+        return this.maxZ(z, this);\n+    }\n+\n+    @Override\n+    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, maxX, maxY, maxZ);\n     }\n \n-    /**\n-     * Set the coordinates of the maximum corner for this region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion setMax(int x, int y, int z) {\n-        return this.set(this.minX, this.minY, this.minZ, x, y, z);\n+        return this.setMax(x, y, z, this);\n     }\n \n     public BlockRegion setMax(Vector3ic max) {\n-        return this.setMax(max.x(), max.y(), max.z());\n+        return this.setMax(max, this);\n     }\n \n-    /**\n-     * Translate the maximum corner of the region by adding given {@code (dx, dy, dz)}.\n-     *\n-     * @param dx the number of blocks to add to the maximum corner on the x axis\n-     * @param dy the number of blocks to add to the maximum corner on the y axis\n-     * @param dz the number of blocks to add to the maximum corner on the z axis\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion addToMax(int dx, int dy, int dz) {\n-        return this.setMax(this.maxX + dx, this.maxY + dy, this.maxZ + dz);\n+        return this.addToMax(dx, dy, dz, this);\n     }\n \n     public BlockRegion addToMax(Vector3ic dmax) {\n-        return this.addToMax(dmax.x(), dmax.y(), dmax.z());\n+        return this.addToMax(dmax, this);\n     }\n \n     // -- size -------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Set the size of the block region from the minimum corner.\n-     *\n-     * @param x the x coordinate to set the size; must be > 0\n-     * @param y the y coordinate to set the size; must be > 0\n-     * @param z the z coordinate to set the size; must be > 0\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n-     */\n+    @Override\n+    public BlockRegion setSize(int x, int y, int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.minX + x, this.minY + y, this.minZ + z);\n+    }\n+\n     public BlockRegion setSize(int x, int y, int z) {\n-        return this.setMax(this.minX + x, this.minY + y, this.minZ);\n+        return this.setSize(x, y, z, this);\n     }\n \n     public BlockRegion setSize(Vector3ic size) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYxMjE0OQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548612149", "bodyText": "you can keep this one to.", "author": "pollend", "createdAt": "2020-12-24T16:46:24Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -294,132 +311,171 @@ public int maxZ() {\n         return this.maxZ;\n     }\n \n-    @Override\n-    public BlockRegion maxX(int x, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, x, this.maxY, this.maxZ);\n-    }\n-\n+    /**\n+     * Set the maximum x-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion maxX(int x) {\n-        return this.maxX(x, this);\n-    }\n-\n-    @Override\n-    public BlockRegion maxY(int y, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, this.maxX, y, this.maxZ);\n+        Preconditions.checkArgument(x >= minX);\n+        this.maxX = x;\n+        return this;\n     }\n \n+    /**\n+     * Set the maximum y-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion maxY(int y) {\n-        return this.maxY(y, this);\n-    }\n-\n-    @Override\n-    public BlockRegion maxZ(int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, this.maxX, this.maxY, z);\n+        Preconditions.checkArgument(y >= minY);\n+        this.maxY = y;\n+        return this;\n     }\n \n+    /**\n+     * Set the maximum z-coordinate of the region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion maxZ(int z) {\n-        return this.maxZ(z, this);\n-    }\n-\n-    @Override\n-    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, maxX, maxY, maxZ);\n+        Preconditions.checkArgument(z >= minZ);\n+        this.maxZ = z;\n+        return this;\n     }\n \n+    /**\n+     * Set the coordinates of the maximum corner for this region.\n+     *\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion setMax(int x, int y, int z) {\n-        return this.setMax(x, y, z, this);\n+        return this.set(this.minX, this.minY, this.minZ, x, y, z);\n     }\n \n     public BlockRegion setMax(Vector3ic max) {\n-        return this.setMax(max, this);\n+        return this.setMax(max.x(), max.y(), max.z());\n     }\n \n+    /**\n+     * Translate the maximum corner of the region by adding given {@code (dx, dy, dz)}.\n+     *\n+     * @param dx the number of blocks to add to the maximum corner on the x axis\n+     * @param dy the number of blocks to add to the maximum corner on the y axis\n+     * @param dz the number of blocks to add to the maximum corner on the z axis\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n+     */\n     public BlockRegion addToMax(int dx, int dy, int dz) {\n-        return this.addToMax(dx, dy, dz, this);\n+        return this.setMax(this.maxX + dx, this.maxY + dy, this.maxZ + dz);\n     }\n \n     public BlockRegion addToMax(Vector3ic dmax) {\n-        return this.addToMax(dmax, this);\n+        return this.addToMax(dmax.x(), dmax.y(), dmax.z());\n     }\n \n     // -- size -------------------------------------------------------------------------------------------------------//\n \n-    @Override\n-    public BlockRegion setSize(int x, int y, int z, BlockRegion dest) {\n-        return dest.set(this.minX, this.minY, this.minZ, this.minX + x, this.minY + y, this.minZ + z);\n-    }\n-\n+    /**\n+     * Set the size of the block region from the minimum corner.\n+     *\n+     * @param x the x coordinate to set the size; must be > 0\n+     * @param y the y coordinate to set the size; must be > 0\n+     * @param z the z coordinate to set the size; must be > 0\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n+     */\n     public BlockRegion setSize(int x, int y, int z) {\n-        return this.setSize(x, y, z, this);\n+        return this.setMax(this.minX + x, this.minY + y, this.minZ);\n     }\n \n     public BlockRegion setSize(Vector3ic size) {\n         return setSize(size.x(), size.y(), size.z());\n     }\n \n     // -- IN-PLACE MUTATION ------------------------------------------------------------------------------------------//\n-    @Override\n-    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n-        dest.minX = Math.min(this.minX, x);\n-        dest.minY = Math.min(this.minY, y);\n-        dest.minZ = Math.min(this.minZ, z);\n-\n-        dest.maxX = Math.max(this.maxX, x);\n-        dest.maxY = Math.max(this.maxY, y);\n-        dest.maxZ = Math.max(this.maxZ, z);\n-        return dest;\n-    }\n \n+    /**\n+     * Compute the union of this region and the given block coordinate.\n+     *\n+     * @param x the x coordinate of the block\n+     * @param y the y coordinate of the block\n+     * @param z the z coordinate of the block\n+     * @return {@code this} (after modification)\n+     */\n     public BlockRegion union(int x, int y, int z) {\n-        return this.union(x, y, z, this);\n+        this.minX = Math.min(this.minX, x);\n+        this.minY = Math.min(this.minY, y);\n+        this.minZ = Math.min(this.minZ, z);\n+\n+        this.maxX = Math.max(this.maxX, x);\n+        this.maxY = Math.max(this.maxY, y);\n+        this.maxZ = Math.max(this.maxZ, z);\n+        return this;\n     }\n \n     public BlockRegion union(Vector3ic pos) {\n-        return union(pos.x(), pos.y(), pos.z(), this);\n+        return union(pos.x(), pos.y(), pos.z());\n     }\n \n+    /**\n+     * Compute the union of this region and the other region.\n+     *\n+     * @param other {@link BlockRegion}\n+     * @return @code this} (after modification)\n+     */\n     public BlockRegion union(BlockRegionc other) {\n-        return this.union(other, this);\n+        return this.union(other.minX(), other.minY(), other.minZ()).union(other.maxX(), other.maxY(), other.maxZ());\n     }\n \n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    @Override\n-    public Optional<BlockRegion> intersect(BlockRegionc other, BlockRegion dest) {\n-        dest.minX = Math.max(minX, other.minX());\n-        dest.minY = Math.max(minY, other.minY());\n-        dest.minZ = Math.max(minZ, other.minZ());\n+    /**\n+     * Compute the intersection of this region with the {@code other} region.\n+     * <p>\n+     * NOTE: If the regions don't intersect this region will become invalid!\n+     *\n+     * @param other the other region\n+     * @return {@code this} (after modification) or {@link Optional#empty()} if the regions don't intersect\n+     */\n+    public Optional<BlockRegion> intersect(BlockRegionc other) {\n+        this.minX = Math.max(minX, other.minX());\n+        this.minY = Math.max(minY, other.minY());\n+        this.minZ = Math.max(minZ, other.minZ());\n \n-        dest.maxX = Math.min(maxX, other.maxX());\n-        dest.maxY = Math.min(maxY, other.maxY());\n-        dest.maxZ = Math.min(maxZ, other.maxZ());\n+        this.maxX = Math.min(maxX, other.maxX());\n+        this.maxY = Math.min(maxY, other.maxY());\n+        this.maxZ = Math.min(maxZ, other.maxZ());\n \n-        if (dest.isValid()) {\n-            return Optional.of(dest);\n+        if (this.isValid()) {\n+            return Optional.of(this);\n         } else {\n             return Optional.empty();\n         }\n     }\n \n-    public Optional<BlockRegion> intersect(BlockRegionc other) {\n-        return this.intersect(other, this);\n-    }\n-\n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    @Override\n-    public BlockRegion translate(int x, int y, int z, BlockRegion dest) {\n-        dest.minX = this.minX + x;\n-        dest.minY = this.minY + y;\n-        dest.minZ = this.minZ + z;\n-        dest.maxX = this.maxX + x;\n-        dest.maxY = this.maxY + y;\n-        dest.maxZ = this.maxZ + z;\n-        return dest;\n-    }", "originalCommit": "6e0585c20f6bf6dc300e0caa1b82a0228af67ea7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7962383de4a81f2613fb579202c20392c411b526", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex ee57275a5..5bc0608a7 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -311,86 +294,63 @@ public int maxZ() {\n         return this.maxZ;\n     }\n \n-    /**\n-     * Set the maximum x-coordinate of the region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n+    @Override\n+    public BlockRegion maxX(int x, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, x, this.maxY, this.maxZ);\n+    }\n+\n     public BlockRegion maxX(int x) {\n-        Preconditions.checkArgument(x >= minX);\n-        this.maxX = x;\n-        return this;\n+        return this.maxX(x, this);\n+    }\n+\n+    @Override\n+    public BlockRegion maxY(int y, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.maxX, y, this.maxZ);\n     }\n \n-    /**\n-     * Set the maximum y-coordinate of the region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion maxY(int y) {\n-        Preconditions.checkArgument(y >= minY);\n-        this.maxY = y;\n-        return this;\n+        return this.maxY(y, this);\n+    }\n+\n+    @Override\n+    public BlockRegion maxZ(int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.maxX, this.maxY, z);\n     }\n \n-    /**\n-     * Set the maximum z-coordinate of the region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion maxZ(int z) {\n-        Preconditions.checkArgument(z >= minZ);\n-        this.maxZ = z;\n-        return this;\n+        return this.maxZ(z, this);\n+    }\n+\n+    @Override\n+    public BlockRegion setMax(int x, int y, int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, maxX, maxY, maxZ);\n     }\n \n-    /**\n-     * Set the coordinates of the maximum corner for this region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion setMax(int x, int y, int z) {\n-        return this.set(this.minX, this.minY, this.minZ, x, y, z);\n+        return this.setMax(x, y, z, this);\n     }\n \n     public BlockRegion setMax(Vector3ic max) {\n-        return this.setMax(max.x(), max.y(), max.z());\n+        return this.setMax(max, this);\n     }\n \n-    /**\n-     * Translate the maximum corner of the region by adding given {@code (dx, dy, dz)}.\n-     *\n-     * @param dx the number of blocks to add to the maximum corner on the x axis\n-     * @param dy the number of blocks to add to the maximum corner on the y axis\n-     * @param dz the number of blocks to add to the maximum corner on the z axis\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion addToMax(int dx, int dy, int dz) {\n-        return this.setMax(this.maxX + dx, this.maxY + dy, this.maxZ + dz);\n+        return this.addToMax(dx, dy, dz, this);\n     }\n \n     public BlockRegion addToMax(Vector3ic dmax) {\n-        return this.addToMax(dmax.x(), dmax.y(), dmax.z());\n+        return this.addToMax(dmax, this);\n     }\n \n     // -- size -------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Set the size of the block region from the minimum corner.\n-     *\n-     * @param x the x coordinate to set the size; must be > 0\n-     * @param y the y coordinate to set the size; must be > 0\n-     * @param z the z coordinate to set the size; must be > 0\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n-     */\n+    @Override\n+    public BlockRegion setSize(int x, int y, int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, this.minZ, this.minX + x, this.minY + y, this.minZ + z);\n+    }\n+\n     public BlockRegion setSize(int x, int y, int z) {\n-        return this.setMax(this.minX + x, this.minY + y, this.minZ);\n+        return this.setSize(x, y, z, this);\n     }\n \n     public BlockRegion setSize(Vector3ic size) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYxNjM1MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548616351", "bodyText": "this one is also fine.", "author": "pollend", "createdAt": "2020-12-24T16:52:04Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -428,14 +484,20 @@ public BlockRegion translate(Vector3ic vec) {\n \n     // -- extend -----------------------------------------------------------------------------------------------------//\n \n-    @Override\n-    public BlockRegion expand(int dx, int dy, int dz, BlockRegion dest) {\n-        return dest.set(this.minX - dx, this.minY - dy, this.minZ - dz,\n-                this.maxX + dx, this.maxY + dy, this.maxZ + dz);\n-    }", "originalCommit": "6e0585c20f6bf6dc300e0caa1b82a0228af67ea7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7962383de4a81f2613fb579202c20392c411b526", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex ee57275a5..5bc0608a7 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -398,124 +358,108 @@ public BlockRegion setSize(Vector3ic size) {\n     }\n \n     // -- IN-PLACE MUTATION ------------------------------------------------------------------------------------------//\n+    @Override\n+    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = Math.min(this.minX, x);\n+        dest.minY = Math.min(this.minY, y);\n+        dest.minZ = Math.min(this.minZ, z);\n \n-    /**\n-     * Compute the union of this region and the given block coordinate.\n-     *\n-     * @param x the x coordinate of the block\n-     * @param y the y coordinate of the block\n-     * @param z the z coordinate of the block\n-     * @return {@code this} (after modification)\n-     */\n-    public BlockRegion union(int x, int y, int z) {\n-        this.minX = Math.min(this.minX, x);\n-        this.minY = Math.min(this.minY, y);\n-        this.minZ = Math.min(this.minZ, z);\n+        dest.maxX = Math.max(this.maxX, x);\n+        dest.maxY = Math.max(this.maxY, y);\n+        dest.maxZ = Math.max(this.maxZ, z);\n+        return dest;\n+    }\n \n-        this.maxX = Math.max(this.maxX, x);\n-        this.maxY = Math.max(this.maxY, y);\n-        this.maxZ = Math.max(this.maxZ, z);\n-        return this;\n+    public BlockRegion union(int x, int y, int z) {\n+        return this.union(x, y, z, this);\n     }\n \n     public BlockRegion union(Vector3ic pos) {\n-        return union(pos.x(), pos.y(), pos.z());\n+        return union(pos.x(), pos.y(), pos.z(), this);\n     }\n \n-    /**\n-     * Compute the union of this region and the other region.\n-     *\n-     * @param other {@link BlockRegion}\n-     * @return @code this} (after modification)\n-     */\n     public BlockRegion union(BlockRegionc other) {\n-        return this.union(other.minX(), other.minY(), other.minZ()).union(other.maxX(), other.maxY(), other.maxZ());\n+        return this.union(other, this);\n     }\n \n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Compute the intersection of this region with the {@code other} region.\n-     * <p>\n-     * NOTE: If the regions don't intersect this region will become invalid!\n-     *\n-     * @param other the other region\n-     * @return {@code this} (after modification) or {@link Optional#empty()} if the regions don't intersect\n-     */\n-    public Optional<BlockRegion> intersect(BlockRegionc other) {\n-        this.minX = Math.max(minX, other.minX());\n-        this.minY = Math.max(minY, other.minY());\n-        this.minZ = Math.max(minZ, other.minZ());\n+    @Override\n+    public Optional<BlockRegion> intersect(BlockRegionc other, BlockRegion dest) {\n+        dest.minX = Math.max(minX, other.minX());\n+        dest.minY = Math.max(minY, other.minY());\n+        dest.minZ = Math.max(minZ, other.minZ());\n \n-        this.maxX = Math.min(maxX, other.maxX());\n-        this.maxY = Math.min(maxY, other.maxY());\n-        this.maxZ = Math.min(maxZ, other.maxZ());\n+        dest.maxX = Math.min(maxX, other.maxX());\n+        dest.maxY = Math.min(maxY, other.maxY());\n+        dest.maxZ = Math.min(maxZ, other.maxZ());\n \n-        if (this.isValid()) {\n-            return Optional.of(this);\n+        if (dest.isValid()) {\n+            return Optional.of(dest);\n         } else {\n             return Optional.empty();\n         }\n     }\n \n+    public Optional<BlockRegion> intersect(BlockRegionc other) {\n+        return this.intersect(other, this);\n+    }\n+\n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Translate this region by the given vector {@code (dx, dy, dz))}.\n-     *\n-     * @param dx the x coordinate to translate by\n-     * @param dy the y coordinate to translate by\n-     * @param dz the z coordinate to translate by\n-     * @return {@code this} (after modification)\n-     */\n-    public BlockRegion translate(int dx, int dy, int dz) {\n-        this.minX = this.minX + dx;\n-        this.minY = this.minY + dy;\n-        this.minZ = this.minZ + dz;\n-        this.maxX = this.maxX + dx;\n-        this.maxY = this.maxY + dy;\n-        this.maxZ = this.maxZ + dz;\n-        return this;\n+    @Override\n+    public BlockRegion translate(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = this.minX + x;\n+        dest.minY = this.minY + y;\n+        dest.minZ = this.minZ + z;\n+        dest.maxX = this.maxX + x;\n+        dest.maxY = this.maxY + y;\n+        dest.maxZ = this.maxZ + z;\n+        return dest;\n+    }\n+\n+    public BlockRegion translate(int x, int y, int z) {\n+        return this.translate(x, y, z, this);\n     }\n \n     public BlockRegion translate(Vector3ic vec) {\n         return translate(vec.x(), vec.y(), vec.z());\n     }\n \n-    // -- extend -----------------------------------------------------------------------------------------------------//\n-\n-    // -- expand -----------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * Expand this region by adding the given {@code extents} for each face of the region.\n+     * Move this region to the given position {@code (x, y, z)). The position is defined by the minimum corner.\n      *\n-     * @param dx the amount of blocks to extend this region by along the x axis in both directions\n-     * @param dy the amount of blocks to extend this region by along the y axis in both directions\n-     * @param dz the amount of blocks to extend this region by along the z axis in both directions\n+     * @param x the new x coordinate of the minimum corner\n+     * @param y the new y coordinate of the minimum corner\n+     * @param z the new z coordinate of the minimum corner\n      * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n      */\n-    public BlockRegion expand(int dx, int dy, int dz) {\n-        return this.set(this.minX - dx, this.minY - dy, this.minZ - dz,\n+    public BlockRegion setPosition(int x, int y, int z) {\n+        return this.translate(x - this.minX, y - this.minY, z - this.minZ);\n+    }\n+\n+    public BlockRegion setPosition(Vector3ic pos) {\n+        return this.setPosition(pos.x(), pos.y(), pos.z());\n+    }\n+\n+    @Override\n+    public BlockRegion expand(int dx, int dy, int dz, BlockRegion dest) {\n+        return dest.set(this.minX - dx, this.minY - dy, this.minZ - dz,\n                 this.maxX + dx, this.maxY + dy, this.maxZ + dz);\n     }\n \n+    public BlockRegion expand(int dx, int dy, int dz) {\n+        return this.expand(dx, dy, dz, this);\n+    }\n+\n     public BlockRegion expand(Vector3ic extents) {\n         return expand(extents.x(), extents.y(), extents.z());\n     }\n \n     // -- transform --------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Apply the given {@link Matrix4fc#isAffine() affine} transformation to this {@link BlockRegion}.\n-     * <p>\n-     * The matrix in {@code m} <i>must</i> be {@link Matrix4fc#isAffine() affine}.\n-     *\n-     * @param m the affine transformation matrix\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the matrix {@code m} is not {@link Matrix4fc#isAffine() affine}\n-     */\n-    public BlockRegion transform(Matrix4fc m) {\n+    @Override\n+    public BlockRegion transform(Matrix4fc m, BlockRegion dest) {\n         Preconditions.checkArgument(m.isAffine());\n         float dx = maxX - minX;\n         float dy = maxY - minY;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYxNjU3MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548616571", "bodyText": "you can keep this one to.", "author": "pollend", "createdAt": "2020-12-24T16:52:24Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -444,8 +506,16 @@ public BlockRegion expand(Vector3ic extents) {\n \n     // -- transform --------------------------------------------------------------------------------------------------//\n \n-    @Override\n-    public BlockRegion transform(Matrix4fc m, BlockRegion dest) {", "originalCommit": "6e0585c20f6bf6dc300e0caa1b82a0228af67ea7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7962383de4a81f2613fb579202c20392c411b526", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex ee57275a5..5bc0608a7 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -398,124 +358,108 @@ public BlockRegion setSize(Vector3ic size) {\n     }\n \n     // -- IN-PLACE MUTATION ------------------------------------------------------------------------------------------//\n+    @Override\n+    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = Math.min(this.minX, x);\n+        dest.minY = Math.min(this.minY, y);\n+        dest.minZ = Math.min(this.minZ, z);\n \n-    /**\n-     * Compute the union of this region and the given block coordinate.\n-     *\n-     * @param x the x coordinate of the block\n-     * @param y the y coordinate of the block\n-     * @param z the z coordinate of the block\n-     * @return {@code this} (after modification)\n-     */\n-    public BlockRegion union(int x, int y, int z) {\n-        this.minX = Math.min(this.minX, x);\n-        this.minY = Math.min(this.minY, y);\n-        this.minZ = Math.min(this.minZ, z);\n+        dest.maxX = Math.max(this.maxX, x);\n+        dest.maxY = Math.max(this.maxY, y);\n+        dest.maxZ = Math.max(this.maxZ, z);\n+        return dest;\n+    }\n \n-        this.maxX = Math.max(this.maxX, x);\n-        this.maxY = Math.max(this.maxY, y);\n-        this.maxZ = Math.max(this.maxZ, z);\n-        return this;\n+    public BlockRegion union(int x, int y, int z) {\n+        return this.union(x, y, z, this);\n     }\n \n     public BlockRegion union(Vector3ic pos) {\n-        return union(pos.x(), pos.y(), pos.z());\n+        return union(pos.x(), pos.y(), pos.z(), this);\n     }\n \n-    /**\n-     * Compute the union of this region and the other region.\n-     *\n-     * @param other {@link BlockRegion}\n-     * @return @code this} (after modification)\n-     */\n     public BlockRegion union(BlockRegionc other) {\n-        return this.union(other.minX(), other.minY(), other.minZ()).union(other.maxX(), other.maxY(), other.maxZ());\n+        return this.union(other, this);\n     }\n \n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Compute the intersection of this region with the {@code other} region.\n-     * <p>\n-     * NOTE: If the regions don't intersect this region will become invalid!\n-     *\n-     * @param other the other region\n-     * @return {@code this} (after modification) or {@link Optional#empty()} if the regions don't intersect\n-     */\n-    public Optional<BlockRegion> intersect(BlockRegionc other) {\n-        this.minX = Math.max(minX, other.minX());\n-        this.minY = Math.max(minY, other.minY());\n-        this.minZ = Math.max(minZ, other.minZ());\n+    @Override\n+    public Optional<BlockRegion> intersect(BlockRegionc other, BlockRegion dest) {\n+        dest.minX = Math.max(minX, other.minX());\n+        dest.minY = Math.max(minY, other.minY());\n+        dest.minZ = Math.max(minZ, other.minZ());\n \n-        this.maxX = Math.min(maxX, other.maxX());\n-        this.maxY = Math.min(maxY, other.maxY());\n-        this.maxZ = Math.min(maxZ, other.maxZ());\n+        dest.maxX = Math.min(maxX, other.maxX());\n+        dest.maxY = Math.min(maxY, other.maxY());\n+        dest.maxZ = Math.min(maxZ, other.maxZ());\n \n-        if (this.isValid()) {\n-            return Optional.of(this);\n+        if (dest.isValid()) {\n+            return Optional.of(dest);\n         } else {\n             return Optional.empty();\n         }\n     }\n \n+    public Optional<BlockRegion> intersect(BlockRegionc other) {\n+        return this.intersect(other, this);\n+    }\n+\n     // ---------------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Translate this region by the given vector {@code (dx, dy, dz))}.\n-     *\n-     * @param dx the x coordinate to translate by\n-     * @param dy the y coordinate to translate by\n-     * @param dz the z coordinate to translate by\n-     * @return {@code this} (after modification)\n-     */\n-    public BlockRegion translate(int dx, int dy, int dz) {\n-        this.minX = this.minX + dx;\n-        this.minY = this.minY + dy;\n-        this.minZ = this.minZ + dz;\n-        this.maxX = this.maxX + dx;\n-        this.maxY = this.maxY + dy;\n-        this.maxZ = this.maxZ + dz;\n-        return this;\n+    @Override\n+    public BlockRegion translate(int x, int y, int z, BlockRegion dest) {\n+        dest.minX = this.minX + x;\n+        dest.minY = this.minY + y;\n+        dest.minZ = this.minZ + z;\n+        dest.maxX = this.maxX + x;\n+        dest.maxY = this.maxY + y;\n+        dest.maxZ = this.maxZ + z;\n+        return dest;\n+    }\n+\n+    public BlockRegion translate(int x, int y, int z) {\n+        return this.translate(x, y, z, this);\n     }\n \n     public BlockRegion translate(Vector3ic vec) {\n         return translate(vec.x(), vec.y(), vec.z());\n     }\n \n-    // -- extend -----------------------------------------------------------------------------------------------------//\n-\n-    // -- expand -----------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * Expand this region by adding the given {@code extents} for each face of the region.\n+     * Move this region to the given position {@code (x, y, z)). The position is defined by the minimum corner.\n      *\n-     * @param dx the amount of blocks to extend this region by along the x axis in both directions\n-     * @param dy the amount of blocks to extend this region by along the y axis in both directions\n-     * @param dz the amount of blocks to extend this region by along the z axis in both directions\n+     * @param x the new x coordinate of the minimum corner\n+     * @param y the new y coordinate of the minimum corner\n+     * @param z the new z coordinate of the minimum corner\n      * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n      */\n-    public BlockRegion expand(int dx, int dy, int dz) {\n-        return this.set(this.minX - dx, this.minY - dy, this.minZ - dz,\n+    public BlockRegion setPosition(int x, int y, int z) {\n+        return this.translate(x - this.minX, y - this.minY, z - this.minZ);\n+    }\n+\n+    public BlockRegion setPosition(Vector3ic pos) {\n+        return this.setPosition(pos.x(), pos.y(), pos.z());\n+    }\n+\n+    @Override\n+    public BlockRegion expand(int dx, int dy, int dz, BlockRegion dest) {\n+        return dest.set(this.minX - dx, this.minY - dy, this.minZ - dz,\n                 this.maxX + dx, this.maxY + dy, this.maxZ + dz);\n     }\n \n+    public BlockRegion expand(int dx, int dy, int dz) {\n+        return this.expand(dx, dy, dz, this);\n+    }\n+\n     public BlockRegion expand(Vector3ic extents) {\n         return expand(extents.x(), extents.y(), extents.z());\n     }\n \n     // -- transform --------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * Apply the given {@link Matrix4fc#isAffine() affine} transformation to this {@link BlockRegion}.\n-     * <p>\n-     * The matrix in {@code m} <i>must</i> be {@link Matrix4fc#isAffine() affine}.\n-     *\n-     * @param m the affine transformation matrix\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the matrix {@code m} is not {@link Matrix4fc#isAffine() affine}\n-     */\n-    public BlockRegion transform(Matrix4fc m) {\n+    @Override\n+    public BlockRegion transform(Matrix4fc m, BlockRegion dest) {\n         Preconditions.checkArgument(m.isAffine());\n         float dx = maxX - minX;\n         float dy = maxY - minY;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODY1ODc3NQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548658775", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return this.setMax(this.minX + x, this.minY + y, this.minZ);\n          \n          \n            \n                    return this.setMax(this.minX + x - 1, this.minY + y - 1, this.minZ + z - 1);\n          \n      \n    \n    \n  \n\nA size of one is new BlockRegion(0,0,0,0,0,0) so you need to subtract one.", "author": "pollend", "createdAt": "2020-12-24T17:54:12Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -93,392 +103,309 @@\n      *\n      * @param source the block region to copy.\n      */\n-    public BlockRegion(BlockRegion source) {\n+    public BlockRegion(BlockRegionc source) {\n         this.set(source);\n     }\n \n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector3ic> iterator() {\n+        return new Iterator<Vector3ic>() {\n+            private Vector3i current = null;\n+            private final Vector3i next = getMin(new Vector3i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.z++;\n+                    if (next.z > maxZ) {\n+                        next.z = minZ;\n+                        next.y++;\n+                        if (next.y > maxY) {\n+                            next.y = minY;\n+                            next.x++;\n+                        }\n+                    }\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector3ic next() {\n+                if (current == null) {\n+                    current = new Vector3i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n     // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n \n     /**\n-     * set source to current region\n+     * Reset both the minimum and maximum corner of this region.\n      *\n-     * @param source the source region\n-     * @return this\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public BlockRegion set(BlockRegion source) {\n-        this.minX = source.minX;\n-        this.minY = source.minY;\n-        this.minZ = source.minZ;\n-\n-        this.maxX = source.maxX;\n-        this.maxY = source.maxY;\n-        this.maxZ = source.maxZ;\n-        return this;\n-    }\n+    public BlockRegion set(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+        Preconditions.checkArgument(minZ <= maxZ || (minZ == INVALID.minZ() && maxZ == INVALID.maxZ()));\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.minZ = minZ;\n \n-    public BlockRegion copy() {\n-        return new BlockRegion(this);\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        this.maxZ = maxZ;\n+        return this;\n     }\n \n-    // -- min --------------------------------------------------------------------------------------------------------//\n-\n     /**\n-     * The x-coordinate of the minimum corner\n+     * Reset both the minimum and maximum corner of this region.\n+     *\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    public int minX() {\n-        return this.minX;\n+    public BlockRegion set(Vector3ic min, Vector3ic max) {\n+        return this.set(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * the minimum coordinate of the first block x\n+     * Reset this region to have the same minimum and maximum corner as the {@code source} region.\n      *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #minX()}\n+     * @return this region (after modification)\n+     * @throws IllegalArgumentException if the given coordinates for min and max are {@link #isValid()\n+     *         invalid}.\n      */\n-    @Deprecated\n-    public int getMinX() {\n-        return this.minX;\n+    public BlockRegion set(BlockRegionc source) {\n+        return this.set(source.minX(), source.minY(), source.minZ(), source.maxX(), source.maxY(), source.maxZ());\n     }\n \n-    /**\n-     * set the minimum coordinate of the first block x\n-     *\n-     * @return the minX\n-     */\n-    public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        this.minX = x;\n-        return this;\n+    // -- min --------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n+        return this.minX;\n     }\n \n-    /**\n-     * The y-coordinate of the minimum corner\n-     */\n+    @Override\n     public int minY() {\n         return this.minY;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #minY()}\n-     */\n-    @Deprecated\n-    public int getMinY() {\n-        return this.minY;\n+    @Override\n+    public int minZ() {\n+        return this.minZ;\n     }\n \n     /**\n-     * set the minimum coordinate of the first block y\n+     * Set the minimum x-coordinate of the region.\n      *\n-     * @return the minY\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n      */\n-    public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= this.maxY || this.maxY == Integer.MIN_VALUE);\n-        this.minY = y;\n+    public BlockRegion minX(int x) {\n+        Preconditions.checkArgument(x <= maxX);\n+        this.minX = x;\n         return this;\n     }\n \n     /**\n-     * The z-coordinate of the minimum corner\n-     */\n-    public int minZ() {\n-        return this.minZ;\n-    }\n-\n-    /**\n-     * the minimum coordinate of the first block z\n+     * Set the minimum y-coordinate of the region.\n      *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #minZ()}\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n      */\n-    @Deprecated\n-    public int getMinZ() {\n-        return this.minZ;\n+    public BlockRegion minY(int y) {\n+        Preconditions.checkArgument(y <= maxY);\n+        this.minY = y;\n+        return this;\n     }\n \n     /**\n-     * set the minimum coordinate of the first block z\n+     * Set the minimum z-coordinate of the region.\n      *\n-     * @return the minZ\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n      */\n     public BlockRegion minZ(int z) {\n-        Preconditions.checkArgument(z <= this.maxZ || this.maxZ == Integer.MIN_VALUE);\n+        Preconditions.checkArgument(z <= maxZ);\n         this.minZ = z;\n         return this;\n     }\n \n     /**\n-     * Get the block coordinate minimum corner.\n+     * Set the coordinates of the minimum corner for this region.\n      *\n-     * @param dest will hold the result\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n      */\n-    public Vector3i getMin(Vector3i dest) {\n-        return dest.set(minX, minY, minZ);\n+    public BlockRegion setMin(int minX, int minY, int minZ) {\n+        return this.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param min the first coordinate of the first block\n-     * @return this\n-     */\n     public BlockRegion setMin(Vector3ic min) {\n         return this.setMin(min.x(), min.y(), min.z());\n     }\n \n     /**\n-     * sets the minimum block for this {@link BlockRegion}\n+     * Translate the minimum corner of the region by adding given {@code (dx, dy, dz)}.\n      *\n-     * @param minX the x coordinate of the first block\n-     * @param minY the y coordinate of the first block\n-     * @param minZ the z coordinate of the first block\n-     * @return this\n+     * @param dx the number of blocks to add to the minimum corner on the x axis\n+     * @param dy the number of blocks to add to the minimum corner on the y axis\n+     * @param dz the number of blocks to add to the minimum corner on the z axis\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n      */\n-    public BlockRegion setMin(int minX, int minY, int minZ) {\n-        Preconditions.checkArgument(minX <= this.maxX || this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minY <= this.maxY || this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minZ <= this.maxZ || this.maxX == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        this.minZ = minZ;\n-        return this;\n+    public BlockRegion addToMin(int dx, int dy, int dz) {\n+        return this.setMin(minX() + dx, minY() + dy, minZ() + dz);\n+    }\n+\n+    public BlockRegion addToMin(Vector3ic dmin) {\n+        return this.addToMin(dmin.x(), dmin.y(), dmin.z());\n     }\n \n     // -- max --------------------------------------------------------------------------------------------------------//\n \n-    /**\n-     * The x-coordinate of the maximum corner\n-     */\n+    @Override\n     public int maxX() {\n         return this.maxX;\n     }\n \n-    /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n-     * @deprecated use {@link #maxX()}\n-     */\n-    @Deprecated\n-    public int getMaxX() {\n-        return this.maxX;\n+    @Override\n+    public int maxY() {\n+        return this.maxY;\n+    }\n+\n+    @Override\n+    public int maxZ() {\n+        return this.maxZ;\n     }\n \n     /**\n-     * set the maximum coordinate of the second block x\n+     * Set the maximum x-coordinate of the region.\n      *\n-     * @return the minX\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n      */\n     public BlockRegion maxX(int x) {\n-        Preconditions.checkArgument(x >= this.minX || this.minX == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(x >= minX);\n         this.maxX = x;\n         return this;\n     }\n \n     /**\n-     * The y-coordinate of the maximum corner\n-     */\n-    public int maxY() {\n-        return this.maxY;\n-    }\n-\n-    /**\n-     * the maximum coordinate of the second block y\n+     * Set the maximum y-coordinate of the region.\n      *\n-     * @return the minimum coordinate y\n-     * @deprecated use {@link #maxY()}\n-     */\n-    @Deprecated\n-    public int getMaxY() {\n-        return this.maxY;\n-    }\n-\n-    /**\n-     * set the maximum coordinate of the second block y\n-     *\n-     * @return the minY\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n      */\n     public BlockRegion maxY(int y) {\n-        Preconditions.checkArgument(y >= this.minY || this.minY == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(y >= minY);\n         this.maxY = y;\n         return this;\n     }\n \n     /**\n-     * The z-coordinate of the maximum corner\n-     */\n-    public int maxZ() {\n-        return this.maxZ;\n-    }\n-\n-    /**\n-     * the maximum coordinate of the second block z\n+     * Set the maximum z-coordinate of the region.\n      *\n-     * @return the minimum coordinate z\n-     * @deprecated use {@link #maxZ()}\n-     */\n-    @Deprecated\n-    public int getMaxZ() {\n-        return this.maxZ;\n-    }\n-\n-    /**\n-     * set the maximum coordinate of the second block z\n-     *\n-     * @return the minZ\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n      */\n     public BlockRegion maxZ(int z) {\n-        Preconditions.checkArgument(z >= this.minZ || this.minZ == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(z >= minZ);\n         this.maxZ = z;\n         return this;\n     }\n \n     /**\n-     * Get the block coordinate of the maximum corner.\n+     * Set the coordinates of the maximum corner for this region.\n      *\n-     * @param dest will hold the result\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n      */\n-    public Vector3i getMax(Vector3i dest) {\n-        return dest.set(maxX, maxY, maxZ);\n+    public BlockRegion setMax(int x, int y, int z) {\n+        return this.set(this.minX, this.minY, this.minZ, x, y, z);\n     }\n \n-    /**\n-     * Sets the maximum coordinate of the second block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param max the second coordinate of the second block\n-     * @return this\n-     */\n     public BlockRegion setMax(Vector3ic max) {\n         return this.setMax(max.x(), max.y(), max.z());\n     }\n \n     /**\n-     * sets the maximum block for this {@link BlockRegion}\n+     * Translate the maximum corner of the region by adding given {@code (dx, dy, dz)}.\n      *\n-     * @param maxX the x coordinate of the first block\n-     * @param maxY the y coordinate of the first block\n-     * @param maxZ the z coordinate of the first block\n-     * @return this\n+     * @param dx the number of blocks to add to the maximum corner on the x axis\n+     * @param dy the number of blocks to add to the maximum corner on the y axis\n+     * @param dz the number of blocks to add to the maximum corner on the z axis\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n      */\n-    public BlockRegion setMax(int maxX, int maxY, int maxZ) {\n-        Preconditions.checkArgument(maxX >= this.minX || this.minX == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxY >= this.minY || this.minY == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxZ >= this.minZ || this.minZ == Integer.MAX_VALUE);\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        this.maxZ = maxZ;\n-        return this;\n+    public BlockRegion addToMax(int dx, int dy, int dz) {\n+        return this.setMax(this.maxX + dx, this.maxY + dy, this.maxZ + dz);\n+    }\n+\n+    public BlockRegion addToMax(Vector3ic dmax) {\n+        return this.addToMax(dmax.x(), dmax.y(), dmax.z());\n     }\n \n     // -- size -------------------------------------------------------------------------------------------------------//\n \n     /**\n-     * Set the size of the block region from minimum the minimum corner.\n+     * Set the size of the block region from the minimum corner.\n      *\n      * @param x the x coordinate to set the size; must be > 0\n      * @param y the y coordinate to set the size; must be > 0\n      * @param z the z coordinate to set the size; must be > 0\n-     * @return this after modification\n+     * @return {@code this} (after modification)\n+     * @throws IllegalArgumentException if the size is smaller than or equal to 0 in any dimension\n      */\n     public BlockRegion setSize(int x, int y, int z) {\n-        Preconditions.checkArgument(x > 0);\n-        Preconditions.checkArgument(y > 0);\n-        Preconditions.checkArgument(z > 0);\n-        this.maxX = this.minX + x - 1;\n-        this.maxY = this.minY + y - 1;\n-        this.maxZ = this.minZ + z - 1;\n-        return this;\n+        return this.setMax(this.minX + x, this.minY + y, this.minZ);", "originalCommit": "d05c5b3bbbdc7e6ee692eb2c1ae92e952a8c48b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODcwOTE2Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548709162", "bodyText": "That's right \ud83d\udc4d However, we don't need the preconditions here as we are calling setMax which will check conditions (so no need to duplicate the code).", "author": "skaldarnar", "createdAt": "2020-12-24T19:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODY1ODc3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "7962383de4a81f2613fb579202c20392c411b526", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex 9113301e2..5bc0608a7 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -227,73 +228,55 @@ public int minZ() {\n         return this.minZ;\n     }\n \n-    /**\n-     * Set the minimum x-coordinate of the region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n+    @Override\n+    public BlockRegion minX(int x, BlockRegion dest) {\n+        return dest.set(x, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);\n+    }\n+\n     public BlockRegion minX(int x) {\n-        Preconditions.checkArgument(x <= maxX);\n-        this.minX = x;\n-        return this;\n+        return this.minX(x, this);\n+    }\n+\n+    @Override\n+    public BlockRegion minY(int y, BlockRegion dest) {\n+        return dest.set(this.minX, y, this.minZ, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * Set the minimum y-coordinate of the region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion minY(int y) {\n-        Preconditions.checkArgument(y <= maxY);\n-        this.minY = y;\n-        return this;\n+        return this.minY(y, this);\n+    }\n+\n+    @Override\n+    public BlockRegion minZ(int z, BlockRegion dest) {\n+        return dest.set(this.minX, this.minY, z, this.maxX, this.maxY, this.maxZ);\n     }\n \n-    /**\n-     * Set the minimum z-coordinate of the region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion minZ(int z) {\n-        Preconditions.checkArgument(z <= maxZ);\n-        this.minZ = z;\n-        return this;\n+        return this.minZ(z, this);\n     }\n \n-    /**\n-     * Set the coordinates of the minimum corner for this region.\n-     *\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n-    public BlockRegion setMin(int minX, int minY, int minZ) {\n-        return this.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n+    @Override\n+    public BlockRegion setMin(int minX, int minY, int minZ, BlockRegion dest) {\n+        return dest.set(minX, minY, minZ, this.maxX, this.maxY, this.maxZ);\n+    }\n+\n+    public BlockRegion setMin(int x, int y, int z) {\n+        return this.setMin(x, y, z, this);\n     }\n \n     public BlockRegion setMin(Vector3ic min) {\n-        return this.setMin(min.x(), min.y(), min.z());\n+        return this.setMin(min, this);\n     }\n \n-    /**\n-     * Translate the minimum corner of the region by adding given {@code (dx, dy, dz)}.\n-     *\n-     * @param dx the number of blocks to add to the minimum corner on the x axis\n-     * @param dy the number of blocks to add to the minimum corner on the y axis\n-     * @param dz the number of blocks to add to the minimum corner on the z axis\n-     * @return {@code this} (after modification)\n-     * @throws IllegalArgumentException if the resulting region would become {@link #isValid() invalid}.\n-     */\n     public BlockRegion addToMin(int dx, int dy, int dz) {\n-        return this.setMin(minX() + dx, minY() + dy, minZ() + dz);\n+        return this.addToMin(dx, dy, dz, this);\n     }\n \n     public BlockRegion addToMin(Vector3ic dmin) {\n-        return this.addToMin(dmin.x(), dmin.y(), dmin.z());\n+        return this.addToMin(dmin, this);\n     }\n \n+\n     // -- max --------------------------------------------------------------------------------------------------------//\n \n     @Override\n"}}, {"oid": "7962383de4a81f2613fb579202c20392c411b526", "url": "https://github.com/MovingBlocks/Terasology/commit/7962383de4a81f2613fb579202c20392c411b526", "message": "Revert \"refactor!(BlockRegion): remove modifiers with explicit destination\"\n\nThis reverts commit 6e0585c20f6bf6dc300e0caa1b82a0228af67ea7.", "committedDate": "2020-12-24T21:03:47Z", "type": "commit"}, {"oid": "1e656d11ba4577449c8ebec7a1b3c935171dde75", "url": "https://github.com/MovingBlocks/Terasology/commit/1e656d11ba4577449c8ebec7a1b3c935171dde75", "message": "fix(BlockRegion): address review comments", "committedDate": "2020-12-24T21:09:46Z", "type": "commit"}, {"oid": "8c4a928d135e8be4bcfaf9935211c058c10eedad", "url": "https://github.com/MovingBlocks/Terasology/commit/8c4a928d135e8be4bcfaf9935211c058c10eedad", "message": "feat(BlockRegion): add `dest` variants for `setPosition`", "committedDate": "2020-12-24T21:10:08Z", "type": "commit"}, {"oid": "3088d19312dc39113e9a8e82a93e52ceeb41d1e7", "url": "https://github.com/MovingBlocks/Terasology/commit/3088d19312dc39113e9a8e82a93e52ceeb41d1e7", "message": "fix(BlockRegion): fix failing tests; fix bugs", "committedDate": "2020-12-24T21:38:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc1MjQxOQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548752419", "bodyText": "for these you need to use set the dest can become invalid between setMin and setMax", "author": "pollend", "createdAt": "2020-12-24T21:40:13Z", "path": "engine/src/main/java/org/terasology/math/ChunkMath.java", "diffHunk": "@@ -575,67 +574,67 @@ public static BlockRegion getEdgeRegion(BlockRegion region, Side side, BlockRegi\n         switch (side) {\n             case TOP:\n                 return dest.setMin(\n-                    region.getMinX(),\n-                    region.getMaxY(),\n-                    region.getMinZ()\n+                    region.minX(),\n+                    region.maxY(),\n+                    region.minZ()\n                 ).setMax(\n-                    region.getMaxX(),\n-                    region.getMaxY(),\n-                    region.getMaxZ());\n+                    region.maxX(),\n+                    region.maxY(),\n+                    region.maxZ());\n             case BOTTOM:\n                 return dest.setMin(\n-                    region.getMinX(),\n-                    region.getMinY(),\n-                    region.getMinZ()\n+                    region.minX(),\n+                    region.minY(),\n+                    region.minZ()\n                 ).setMax(\n-                    region.getMaxX(),\n-                    region.getMinY(),\n-                    region.getMaxZ());\n+                    region.maxX(),\n+                    region.minY(),\n+                    region.maxZ());\n             case LEFT:\n                 return dest.setMin(\n-                    region.getMinX(),\n-                    region.getMinY(),\n-                    region.getMinZ()\n+                    region.minX(),\n+                    region.minY(),\n+                    region.minZ()\n                 ).setMax(\n-                    region.getMinX(),\n-                    region.getMaxY(),\n-                    region.getMaxZ());\n+                    region.minX(),\n+                    region.maxY(),\n+                    region.maxZ());\n             case RIGHT:\n                 return dest.setMin(\n-                    region.getMaxX(),\n-                    region.getMinY(),\n-                    region.getMinZ()\n+                    region.maxX(),\n+                    region.minY(),\n+                    region.minZ()\n                 ).setMax(\n-                    region.getMaxX(),\n-                    region.getMaxY(),\n-                    region.getMaxZ());\n+                    region.maxX(),\n+                    region.maxY(),\n+                    region.maxZ());\n             case FRONT:\n                 return dest.setMin(\n-                    region.getMinX(),\n-                    region.getMinY(),\n-                    region.getMinZ()\n+                    region.minX(),\n+                    region.minY(),\n+                    region.minZ()\n                 ).setMax(\n-                    region.getMaxX(),\n-                    region.getMaxY(),\n-                    region.getMinZ());\n+                    region.maxX(),\n+                    region.maxY(),\n+                    region.minZ());\n             case BACK:\n                 return dest.setMin(\n-                    region.getMinX(),\n-                    region.getMinY(),\n-                    region.getMaxZ()\n+                    region.minX(),\n+                    region.minY(),\n+                    region.maxZ()\n                 ).setMax(\n-                    region.getMaxX(),\n-                    region.getMaxY(),\n-                    region.getMaxZ());\n+                    region.maxX(),\n+                    region.maxY(),\n+                    region.maxZ());\n             default:\n                 return dest.setMin(\n-                    region.getMinX(),\n-                    region.getMinY(),\n-                    region.getMinZ()\n+                    region.minX(),\n+                    region.minY(),\n+                    region.minZ()\n                 ).setMax(\n-                    region.getMaxX(),\n-                    region.getMaxY(),\n-                    region.getMaxZ()\n+                    region.maxX(),\n+                    region.maxY(),\n+                    region.maxZ()\n                 );", "originalCommit": "8c4a928d135e8be4bcfaf9935211c058c10eedad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc1Mjc4OQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4326#discussion_r548752789", "bodyText": "Done \ud83d\udc4d", "author": "skaldarnar", "createdAt": "2020-12-24T21:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc1MjQxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "4e71e0ca31aabf9a566d8011f833f500ede25425", "chunk": "diff --git a/engine/src/main/java/org/terasology/math/ChunkMath.java b/engine/src/main/java/org/terasology/math/ChunkMath.java\nindex 69408b6ba..8f8dc7851 100644\n--- a/engine/src/main/java/org/terasology/math/ChunkMath.java\n+++ b/engine/src/main/java/org/terasology/math/ChunkMath.java\n\n@@ -570,73 +571,65 @@ public static Region3i getEdgeRegion(Region3i region, Side side) {\n      * @param dest will hold the result\n      * @return dest\n      */\n-    public static BlockRegion getEdgeRegion(BlockRegion region, Side side, BlockRegion dest) {\n+    public static BlockRegion getEdgeRegion(BlockRegionc region, Side side, BlockRegion dest) {\n         switch (side) {\n             case TOP:\n-                return dest.setMin(\n+                return dest.set(\n                     region.minX(),\n                     region.maxY(),\n-                    region.minZ()\n-                ).setMax(\n+                    region.minZ(),\n                     region.maxX(),\n                     region.maxY(),\n                     region.maxZ());\n             case BOTTOM:\n-                return dest.setMin(\n+                return dest.set(\n                     region.minX(),\n                     region.minY(),\n-                    region.minZ()\n-                ).setMax(\n+                    region.minZ(),\n                     region.maxX(),\n                     region.minY(),\n                     region.maxZ());\n             case LEFT:\n-                return dest.setMin(\n+                return dest.set(\n                     region.minX(),\n                     region.minY(),\n-                    region.minZ()\n-                ).setMax(\n+                    region.minZ(),\n                     region.minX(),\n                     region.maxY(),\n                     region.maxZ());\n             case RIGHT:\n-                return dest.setMin(\n+                return dest.set(\n                     region.maxX(),\n                     region.minY(),\n-                    region.minZ()\n-                ).setMax(\n+                    region.minZ(),\n                     region.maxX(),\n                     region.maxY(),\n                     region.maxZ());\n             case FRONT:\n-                return dest.setMin(\n+                return dest.set(\n                     region.minX(),\n                     region.minY(),\n-                    region.minZ()\n-                ).setMax(\n+                    region.minZ(),\n                     region.maxX(),\n                     region.maxY(),\n                     region.minZ());\n             case BACK:\n-                return dest.setMin(\n+                return dest.set(\n                     region.minX(),\n                     region.minY(),\n-                    region.maxZ()\n-                ).setMax(\n+                    region.maxZ(),\n                     region.maxX(),\n                     region.maxY(),\n                     region.maxZ());\n             default:\n-                return dest.setMin(\n+                return dest.set(\n                     region.minX(),\n                     region.minY(),\n-                    region.minZ()\n-                ).setMax(\n+                    region.minZ(),\n                     region.maxX(),\n                     region.maxY(),\n                     region.maxZ()\n                 );\n-\n         }\n     }\n \n"}}, {"oid": "4e71e0ca31aabf9a566d8011f833f500ede25425", "url": "https://github.com/MovingBlocks/Terasology/commit/4e71e0ca31aabf9a566d8011f833f500ede25425", "message": "fix(ChunkMath): address review comments", "committedDate": "2020-12-24T21:44:13Z", "type": "commit"}]}