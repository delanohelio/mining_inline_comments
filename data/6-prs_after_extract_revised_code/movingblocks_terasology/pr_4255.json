{"pr_number": 4255, "pr_title": "feat(subsystems): extract TypeHandlerLibrary.", "pr_createdAt": "2020-11-18T14:25:31Z", "pr_url": "https://github.com/MovingBlocks/Terasology/pull/4255", "timeline": [{"oid": "3309071fa76cdcd3e7795cc3d3b073803136ca16", "url": "https://github.com/MovingBlocks/Terasology/commit/3309071fa76cdcd3e7795cc3d3b073803136ca16", "message": "feat(extract-TypeHandlerLibrary): extract TypeHandlerLibrary.", "committedDate": "2020-11-18T14:19:29Z", "type": "commit"}, {"oid": "da466bb2e2b3414c339d6ea379499ec42a1f96de", "url": "https://github.com/MovingBlocks/Terasology/commit/da466bb2e2b3414c339d6ea379499ec42a1f96de", "message": "Merge branch 'develop' into extract-TypeHanderLibrary", "committedDate": "2020-11-18T14:28:46Z", "type": "commit"}, {"oid": "c3778faf3d612d96d72d64ab3e30d8a42cd986b9", "url": "https://github.com/MovingBlocks/Terasology/commit/c3778faf3d612d96d72d64ab3e30d8a42cd986b9", "message": "fix(subsystem): fix manifest's classpath gatherning in buildscript time. (locked cache)", "committedDate": "2020-11-18T14:39:26Z", "type": "commit"}, {"oid": "186bd9e1190d48ea11ef3123eb15b055b45f6e6b", "url": "https://github.com/MovingBlocks/Terasology/commit/186bd9e1190d48ea11ef3123eb15b055b45f6e6b", "message": "chore(subsystem): replace copyrigh with 2 line copyright", "committedDate": "2020-11-19T06:29:37Z", "type": "commit"}, {"oid": "2afecd30a0094fe7d7763d729ad05f1aa5b58af7", "url": "https://github.com/MovingBlocks/Terasology/commit/2afecd30a0094fe7d7763d729ad05f1aa5b58af7", "message": "feat(TypeHandlerLibrary): add PersistentDataArray implementations of `in-memory`", "committedDate": "2020-11-19T09:43:04Z", "type": "commit"}, {"oid": "9ee1e9825d9e6f44b65ffe505e08c1c90698ac29", "url": "https://github.com/MovingBlocks/Terasology/commit/9ee1e9825d9e6f44b65ffe505e08c1c90698ac29", "message": "feat(TypeHandlerLibrary): add PersistentDataArray implementations of `in-memory`", "committedDate": "2020-11-19T11:29:12Z", "type": "commit"}, {"oid": "aa0c2122dbacd7d39049a1051d326fc0e6ce659d", "url": "https://github.com/MovingBlocks/Terasology/commit/aa0c2122dbacd7d39049a1051d326fc0e6ce659d", "message": "feat(TypeHandlerLibrary): move tests from engine to TypEHandlerLibrary subsystem", "committedDate": "2020-11-19T12:20:23Z", "type": "commit"}, {"oid": "2bfc4e783fe7161454308fc99bb3531c749f90a0", "url": "https://github.com/MovingBlocks/Terasology/commit/2bfc4e783fe7161454308fc99bb3531c749f90a0", "message": "feat(TypeHandlerLibrary): add tests for simple type handlers and byte/bytes type handlers", "committedDate": "2020-11-19T14:03:37Z", "type": "commit"}, {"oid": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f", "url": "https://github.com/MovingBlocks/Terasology/commit/5b8657b94b9e44aa8cfb87371a312415ecf0d92f", "message": "Merge branch 'develop' into extract-TypeHanderLibrary", "committedDate": "2020-11-19T14:03:45Z", "type": "commit"}, {"oid": "a0f743abf245f481ca84d51b3162130f07d95201", "url": "https://github.com/MovingBlocks/Terasology/commit/a0f743abf245f481ca84d51b3162130f07d95201", "message": "feat(TypeHandlerLibrary): move most part of code from TypeHandlerLibraryIml", "committedDate": "2020-11-19T14:48:24Z", "type": "commit"}, {"oid": "ba68cee64f82e1eb76153e29048438d36e42881b", "url": "https://github.com/MovingBlocks/Terasology/commit/ba68cee64f82e1eb76153e29048438d36e42881b", "message": "chore(TypeHandlerLibrary): remove public modifiers for tests (sonarlint - junit 5 issue)", "committedDate": "2020-11-20T07:52:32Z", "type": "commit"}, {"oid": "ead37d4cc2bd6ea338bec9fb20f7f4c48b5e8ba2", "url": "https://github.com/MovingBlocks/Terasology/commit/ead37d4cc2bd6ea338bec9fb20f7f4c48b5e8ba2", "message": "feat(TypeHandlerLibrary): split TypeHandlerLibraryTest and setup default handlers correctly", "committedDate": "2020-11-20T07:53:19Z", "type": "commit"}, {"oid": "23d4a4e187704a580fc244dfeaa85bfbd0261533", "url": "https://github.com/MovingBlocks/Terasology/commit/23d4a4e187704a580fc244dfeaa85bfbd0261533", "message": "chore(TypeHandlerLibrary): make fields private for TypeHandlerLibrary", "committedDate": "2020-11-20T08:23:35Z", "type": "commit"}, {"oid": "0a96103b02c5a53511d33615fb625914bba99fa6", "url": "https://github.com/MovingBlocks/Terasology/commit/0a96103b02c5a53511d33615fb625914bba99fa6", "message": "perf(TypeHandlerLibrary): replace mock with implementation in CharacterTypeHandlerTest", "committedDate": "2020-11-20T08:23:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYyOTg1OA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527629858", "bodyText": "\ud83d\udc4d \ud83e\udd17", "author": "skaldarnar", "createdAt": "2020-11-20T11:29:13Z", "path": "subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/package-info.java", "diffHunk": "@@ -0,0 +1,11 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+/**\n+ * This package contains the interfaces and abstract classes for use when defining type handlers.\n+ * Type handlers provide the algorithms for serializing and deserializing types - this uses an implementation agnostic set of interfaces\n+ * so TypeHandlers can be used for different serialization techniques (Json, Protobuf, etc).", "originalCommit": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYzNTQ2MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527635461", "bodyText": "I think it is \"built-in handlers\", thus suggestion to rename this slightly:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static void populateBuildinHandlers(TypeHandlerLibrary typeHandlerLibrary) {\n          \n          \n            \n                static void populateBuiltInHandlers(TypeHandlerLibrary typeHandlerLibrary) {", "author": "skaldarnar", "createdAt": "2020-11-20T11:40:36Z", "path": "subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.persistence.typeHandling;\n+\n+import org.terasology.persistence.typeHandling.coreTypes.BooleanTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.ByteArrayTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.ByteTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.CharacterTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.DoubleTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.FloatTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.IntTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.LongTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.NumberTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.StringTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.factories.ArrayTypeHandlerFactory;\n+import org.terasology.persistence.typeHandling.coreTypes.factories.EnumTypeHandlerFactory;\n+import org.terasology.persistence.typeHandling.coreTypes.factories.StringMapTypeHandlerFactory;\n+import org.terasology.reflection.TypeInfo;\n+import org.terasology.reflection.metadata.ClassMetadata;\n+\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+/**\n+ * A library of type handlers. This is used for the construction of class metadata.\n+ * This library should be initialised by adding a number of base type handlers, describing how to serialize each supported type.\n+ * It will then produce serializers for classes (through their ClassMetadata) on request.\n+ */\n+public interface TypeHandlerLibrary {\n+    static void populateBuildinHandlers(TypeHandlerLibrary typeHandlerLibrary) {", "originalCommit": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "08f2717dc4a9e2694803da59f4483838b8040c3f", "chunk": "diff --git a/subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java b/subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java\nindex 01158a4c6..627d24444 100644\n--- a/subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java\n+++ b/subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java\n\n@@ -3,6 +3,11 @@\n \n package org.terasology.persistence.typeHandling;\n \n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.reflections.Reflections;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.terasology.persistence.typeHandling.coreTypes.BooleanTypeHandler;\n import org.terasology.persistence.typeHandling.coreTypes.ByteArrayTypeHandler;\n import org.terasology.persistence.typeHandling.coreTypes.ByteTypeHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYzNzM0OQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527637349", "bodyText": "Maybe we can add some Javadoc here? I guess this returns the Serializer for the given type, or null if no serializer for that type was registered?", "author": "skaldarnar", "createdAt": "2020-11-20T11:44:26Z", "path": "subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.persistence.typeHandling;\n+\n+import org.terasology.persistence.typeHandling.coreTypes.BooleanTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.ByteArrayTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.ByteTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.CharacterTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.DoubleTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.FloatTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.IntTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.LongTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.NumberTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.StringTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.factories.ArrayTypeHandlerFactory;\n+import org.terasology.persistence.typeHandling.coreTypes.factories.EnumTypeHandlerFactory;\n+import org.terasology.persistence.typeHandling.coreTypes.factories.StringMapTypeHandlerFactory;\n+import org.terasology.reflection.TypeInfo;\n+import org.terasology.reflection.metadata.ClassMetadata;\n+\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+/**\n+ * A library of type handlers. This is used for the construction of class metadata.\n+ * This library should be initialised by adding a number of base type handlers, describing how to serialize each supported type.\n+ * It will then produce serializers for classes (through their ClassMetadata) on request.\n+ */\n+public interface TypeHandlerLibrary {\n+    static void populateBuildinHandlers(TypeHandlerLibrary typeHandlerLibrary) {\n+        typeHandlerLibrary.addTypeHandler(Boolean.class, new BooleanTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Boolean.TYPE, new BooleanTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Byte.class, new ByteTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Byte.TYPE, new ByteTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Character.class, new CharacterTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Character.TYPE, new CharacterTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Double.class, new DoubleTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Double.TYPE, new DoubleTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Float.class, new FloatTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Float.TYPE, new FloatTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Integer.class, new IntTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Integer.TYPE, new IntTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Long.class, new LongTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Long.TYPE, new LongTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(String.class, new StringTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Number.class, new NumberTypeHandler());\n+\n+        typeHandlerLibrary.addTypeHandlerFactory(new ArrayTypeHandlerFactory());\n+        typeHandlerLibrary.addTypeHandler(byte[].class, new ByteArrayTypeHandler());\n+\n+        typeHandlerLibrary.addTypeHandlerFactory(new EnumTypeHandlerFactory());\n+        typeHandlerLibrary.addTypeHandlerFactory(new StringMapTypeHandlerFactory());\n+    }\n+\n+    /**\n+     * Creates a copy of an this serialization library. This copy is initialised with all type handlers that were added to the original, but does not retain any\n+     * serializers or type handlers that were generated. This can be used to override specific types handlers from another type serializer.\n+     */\n+    TypeHandlerLibrary copy();\n+\n+    Serializer getSerializerFor(ClassMetadata<?, ?> type);", "originalCommit": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "08f2717dc4a9e2694803da59f4483838b8040c3f", "chunk": "diff --git a/subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java b/subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java\nindex 01158a4c6..627d24444 100644\n--- a/subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java\n+++ b/subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java\n\n@@ -3,6 +3,11 @@\n \n package org.terasology.persistence.typeHandling;\n \n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.reflections.Reflections;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.terasology.persistence.typeHandling.coreTypes.BooleanTypeHandler;\n import org.terasology.persistence.typeHandling.coreTypes.ByteArrayTypeHandler;\n import org.terasology.persistence.typeHandling.coreTypes.ByteTypeHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYzODYyMQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527638621", "bodyText": "Is this change intentional? Is it important that the factory is added to this implementation or would the interface be better in the docstring here?\nI'm actually not sure what the best practice here is ... \ud83e\udd14", "author": "skaldarnar", "createdAt": "2020-11-20T11:46:59Z", "path": "engine/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibraryImpl.java", "diffHunk": "@@ -283,15 +246,16 @@ public Serializer getSerializerFor(ClassMetadata<?, ?> type) {\n     }\n \n     /**\n-     * Adds a new {@link TypeHandlerFactory} to the {@link TypeHandlerLibrary}. Factories\n+     * Adds a new {@link TypeHandlerFactory} to the {@link TypeHandlerLibraryImpl}. Factories", "originalCommit": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "08f2717dc4a9e2694803da59f4483838b8040c3f", "chunk": "diff --git a/engine/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibraryImpl.java b/engine/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibraryImpl.java\nindex 507349cb2..46337f853 100644\n--- a/engine/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibraryImpl.java\n+++ b/engine/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibraryImpl.java\n\n@@ -228,230 +171,4 @@ private static void populateWithDefaultHandlers(TypeHandlerLibrary serialization\n         serializationLibrary.addTypeHandler(IntegerRange.class, new IntegerRangeHandler());\n     }\n \n-    /**\n-     * Obtains a serializer for the given type\n-     *\n-     * @param type The ClassMetadata for the type of interest\n-     * @return A serializer for serializing/deserializing the type\n-     */\n-    @Override\n-    public Serializer getSerializerFor(ClassMetadata<?, ?> type) {\n-        Serializer serializer = serializerMap.get(type);\n-        if (serializer == null) {\n-            Map<FieldMetadata<?, ?>, TypeHandler> fieldHandlerMap = getFieldHandlerMap(type);\n-            serializer = new Serializer(type, fieldHandlerMap);\n-            serializerMap.put(type, serializer);\n-        }\n-        return serializer;\n-    }\n-\n-    /**\n-     * Adds a new {@link TypeHandlerFactory} to the {@link TypeHandlerLibraryImpl}. Factories\n-     * added later are given a higher priority during {@link TypeHandler} generation.\n-     */\n-    @Override\n-    public void addTypeHandlerFactory(TypeHandlerFactory typeHandlerFactory) {\n-        typeHandlerFactories.add(typeHandlerFactory);\n-    }\n-\n-    /**\n-     * Adds a {@link TypeHandler} for the specified type to this {@link TypeHandlerLibraryImpl} by\n-     * adding to the library a new {@link TypeHandlerFactory} that returns the {@link TypeHandler}\n-     * whenever the {@link TypeHandler} for the specified type is requested.\n-     * <p>\n-     * If the specified {@link SerializationSandbox} does not allow the addition of the given\n-     * {@link TypeHandler} for the given type, the {@link TypeHandler} is not added to the\n-     * library and false is returned.\n-     *\n-     * @param typeClass   The {@link Class} of the type handled by the {@link TypeHandler}.\n-     * @param typeHandler The {@link TypeHandler} to add to the library.\n-     * @param <T>         The type handled by the {@link TypeHandler}.\n-     * @return True if the {@link TypeHandler} was successfully added, false otherwise.\n-     */\n-    @Override\n-    public <T> boolean addTypeHandler(Class<T> typeClass, TypeHandler<T> typeHandler) {\n-        return addTypeHandler(TypeInfo.of(typeClass), typeHandler);\n-    }\n-\n-    /**\n-     * Adds a {@link TypeHandler} for the specified type to this {@link TypeHandlerLibraryImpl} by\n-     * adding to the library a new {@link TypeHandlerFactory} that returns the {@link TypeHandler}\n-     * whenever the {@link TypeHandler} for the specified type is requested.\n-     * <p>\n-     * If the specified {@link SerializationSandbox} does not allow the addition of the given\n-     * {@link TypeHandler} for the given type, the {@link TypeHandler} is not added to the\n-     * library and false is returned.\n-     *\n-     * @param <T>         The type handled by the {@link TypeHandler}.\n-     * @param type        The {@link TypeInfo} of the type handled by the {@link TypeHandler}.\n-     * @param typeHandler The {@link TypeHandler} to add to the library.\n-     * @return True if the {@link TypeHandler} was successfully added, false otherwise.\n-     */\n-    @Override\n-    public <T> boolean addTypeHandler(TypeInfo<T> type, TypeHandler<T> typeHandler) {\n-        if (!sandbox.isValidTypeHandlerDeclaration(type, typeHandler)) {\n-            return false;\n-        }\n-\n-        addTypeHandlerFactory(new SpecificTypeHandlerFactory<T>(type) {\n-            @Override\n-            protected TypeHandler<T> createHandler(TypeHandlerContext context) {\n-                return typeHandler;\n-            }\n-        });\n-\n-        return true;\n-    }\n-\n-    /**\n-     * Adds an {@link InstanceCreator} to the {@link TypeHandlerLibraryImpl} for the specified type.\n-     */\n-    @Override\n-    public <T> void addInstanceCreator(Class<T> typeClass, InstanceCreator<T> instanceCreator) {\n-        addInstanceCreator(TypeInfo.of(typeClass), instanceCreator);\n-    }\n-\n-    /**\n-     * Adds an {@link InstanceCreator} to the {@link TypeHandlerLibraryImpl} for the specified type.\n-     */\n-    @Override\n-    public <T> void addInstanceCreator(TypeInfo<T> typeInfo, InstanceCreator<T> instanceCreator) {\n-        instanceCreators.put(typeInfo.getType(), instanceCreator);\n-    }\n-\n-    /**\n-     * Retrieves the {@link TypeHandler} for the specified type, if available.\n-     * <p>\n-     * Each {@link TypeHandlerFactory} added to this {@link TypeHandlerLibraryImpl} is requested\n-     * to generate a {@link TypeHandler} for the given type. Most recently added factories are\n-     * requested first, hence a {@link TypeHandlerFactory} can override one that was added\n-     * before it.\n-     *\n-     * @param type The {@link Type} describing the type for which to\n-     *             retrieve the {@link TypeHandler}.\n-     * @return The {@link TypeHandler} for the specified type, if available.\n-     */\n-    @Override\n-    @SuppressWarnings({\"unchecked\"})\n-    public Optional<TypeHandler<?>> getTypeHandler(Type type) {\n-        TypeInfo typeInfo = TypeInfo.of(type);\n-        return (Optional<TypeHandler<?>>) getTypeHandler(typeInfo);\n-    }\n-\n-    /**\n-     * Retrieves the {@link TypeHandler} for the specified type, if available.\n-     * <p>\n-     * Each {@link TypeHandlerFactory} added to this {@link TypeHandlerLibraryImpl} is requested\n-     * to generate a {@link TypeHandler} for the given type. Most recently added factories are\n-     * requested first, hence a {@link TypeHandlerFactory} can override one that was added\n-     * before it.\n-     *\n-     * @param typeClass The {@link Class} of the type for which to\n-     *                  retrieve the {@link TypeHandler}.\n-     * @param <T>       The type for which to retrieve the {@link TypeHandler}.\n-     * @return The {@link TypeHandler} for the specified type, if available.\n-     */\n-    @Override\n-    public <T> Optional<TypeHandler<T>> getTypeHandler(Class<T> typeClass) {\n-        return getTypeHandler(TypeInfo.of(typeClass));\n-    }\n-\n-    /**\n-     * Retrieves the {@link TypeHandler} for the specified type, if available.\n-     * <p>\n-     * Each {@link TypeHandlerFactory} added to this {@link TypeHandlerLibraryImpl} is requested\n-     * to generate a {@link TypeHandler} for the given type. Most recently added factories are\n-     * requested first, hence a {@link TypeHandlerFactory} can override one that was added\n-     * before it.\n-     *\n-     * @param type The {@link TypeInfo} describing the type for which to\n-     *             retrieve the {@link TypeHandler}.\n-     * @param <T>  The type for which to retrieve the {@link TypeHandler}.\n-     * @return The {@link TypeHandler} for the specified type, if available.\n-     */\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> Optional<TypeHandler<T>> getTypeHandler(TypeInfo<T> type) {\n-        TypeHandlerContext context = new TypeHandlerContext(this, sandbox);\n-\n-        if (typeHandlerCache.containsKey(type)) {\n-            return Optional.of((TypeHandler<T>) typeHandlerCache.get(type));\n-        }\n-\n-        Map<TypeInfo<?>, FutureTypeHandler<?>> futures = futureTypeHandlers.get();\n-        boolean cleanupFutureTypeHandlers = false;\n-\n-        if (futures == null) {\n-            cleanupFutureTypeHandlers = true;\n-            futures = new HashMap<>();\n-            futureTypeHandlers.set(futures);\n-        }\n-\n-        FutureTypeHandler<T> future = (FutureTypeHandler<T>) futures.get(type);\n-\n-        if (future != null) {\n-            return Optional.of(future);\n-        }\n-\n-        try {\n-            future = new FutureTypeHandler<>();\n-            futures.put(type, future);\n-\n-            // TODO: Explore reversing typeHandlerFactories itself before building object\n-            for (int i = typeHandlerFactories.size() - 1; i >= 0; i--) {\n-                TypeHandlerFactory typeHandlerFactory = typeHandlerFactories.get(i);\n-                Optional<TypeHandler<T>> typeHandler = typeHandlerFactory.create(type, context);\n-\n-                if (typeHandler.isPresent()) {\n-                    TypeHandler<T> handler = typeHandler.get();\n-\n-                    if (!sandbox.isValidTypeHandlerDeclaration(type, handler)) {\n-                        continue;\n-                    }\n-\n-                    typeHandlerCache.put(type, handler);\n-                    future.typeHandler = handler;\n-\n-                    return Optional.of(handler);\n-                }\n-            }\n-\n-            return Optional.empty();\n-        } finally {\n-            futures.remove(type);\n-\n-            if (cleanupFutureTypeHandlers) {\n-                futureTypeHandlers.remove();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Returns a {@link TypeHandler} that can handle all types deriving from {@link T}.\n-     *\n-     * @param typeInfo The {@link TypeInfo} describing the base type for which to return a\n-     *                 {@link TypeHandler}.\n-     * @param <T>      The base type for which to return a {@link TypeHandler}.\n-     */\n-    @Override\n-    public <T> TypeHandler<T> getBaseTypeHandler(TypeInfo<T> typeInfo) {\n-        TypeHandler<T> delegateHandler = getTypeHandler(typeInfo).orElse(null);\n-\n-        TypeHandlerContext context = new TypeHandlerContext(this, sandbox);\n-        return new RuntimeDelegatingTypeHandler<>(delegateHandler, typeInfo, context);\n-    }\n-\n-    private Map<FieldMetadata<?, ?>, TypeHandler> getFieldHandlerMap(ClassMetadata<?, ?> type) {\n-        Map<FieldMetadata<?, ?>, TypeHandler> handlerMap = Maps.newHashMap();\n-        for (FieldMetadata<?, ?> field : type.getFields()) {\n-            Optional<TypeHandler<?>> handler = getTypeHandler(field.getField().getGenericType());\n-\n-            if (handler.isPresent()) {\n-                handlerMap.put(field, handler.get());\n-            } else {\n-                logger.error(\"Unsupported field: '{}.{}'\", type.getUri(), field.getName());\n-            }\n-        }\n-        return handlerMap;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY0MzczNw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527643737", "bodyText": "Does it make sense to support this without a rounding mode? when would that be of use?", "author": "skaldarnar", "createdAt": "2020-11-20T11:57:23Z", "path": "subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/inMemory/arrays/PersistedDoubleArray.java", "diffHunk": "@@ -0,0 +1,63 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.persistence.typeHandling.inMemory.arrays;\n+\n+import gnu.trove.list.TDoubleList;\n+import gnu.trove.list.TFloatList;\n+import gnu.trove.list.TIntList;\n+import gnu.trove.list.TLongList;\n+import org.terasology.persistence.typeHandling.PersistedData;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedDouble;\n+\n+import java.util.Iterator;\n+\n+public class PersistedDoubleArray extends PersistedNumberArray {\n+\n+    private final TDoubleList data;\n+\n+    public PersistedDoubleArray(TDoubleList data) {\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return data.size();\n+    }\n+\n+    @Override\n+    public TDoubleList getAsDoubleArray() {\n+        return data;\n+    }\n+\n+    @Override\n+    public TFloatList getAsFloatArray() {\n+        return TroveUtils.doubleToFloat(data);\n+    }\n+\n+    @Override\n+    public TIntList getAsIntegerArray() {\n+        return TroveUtils.doubleToInt(data);", "originalCommit": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3ODAyMA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527678020", "bodyText": "just copied behavior from protobuf and/or gson PersistentData impls.\nReally idkm why?", "author": "DarkWeird", "createdAt": "2020-11-20T13:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY0MzczNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY0NzAwOA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527647008", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @DisplayName(\"Chech simple core types serialization\")\n          \n          \n            \n                @DisplayName(\"Check simple core types serialization\")", "author": "skaldarnar", "createdAt": "2020-11-20T12:03:08Z", "path": "subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.persistence.typeHandling.coreTypes;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.terasology.persistence.typeHandling.PersistedData;\n+import org.terasology.persistence.typeHandling.TypeHandler;\n+import org.terasology.persistence.typeHandling.inMemory.InMemoryPersistedDataSerializer;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedBoolean;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedDouble;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedFloat;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedInteger;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedLong;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedString;\n+\n+import java.lang.reflect.Field;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+class SimpleCoreHandlerTest {\n+\n+    private static Stream<Arguments> primitives() {\n+        return Stream.of(\n+                Arguments.of(true, new BooleanTypeHandler(), new PersistedBoolean(true)),\n+\n+                Arguments.of(1.0, new NumberTypeHandler(), new PersistedDouble(1)),\n+                Arguments.of(1, new IntTypeHandler(), new PersistedInteger(1)),\n+                Arguments.of(1L, new LongTypeHandler(), new PersistedLong(1)),\n+                Arguments.of(1.0F, new FloatTypeHandler(), new PersistedFloat(1)),\n+                Arguments.of(1.0, new DoubleTypeHandler(), new PersistedDouble(1)),\n+\n+                Arguments.of(\"foo\", new StringTypeHandler(), new PersistedString(\"foo\")),\n+                Arguments.of('f', new CharacterTypeHandler(), new PersistedString(\"f\")));\n+    }\n+\n+    @ParameterizedTest(name = \"{1}\")\n+    @DisplayName(\"Chech simple core types serialization\")", "originalCommit": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "479caaa4cd6aab514b52be0620454694b96c463a", "chunk": "diff --git a/subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java b/subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java\nindex 69f7309a1..02052c9e5 100644\n--- a/subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java\n+++ b/subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java\n\n@@ -39,7 +39,7 @@\n     }\n \n     @ParameterizedTest(name = \"{1}\")\n-    @DisplayName(\"Chech simple core types serialization\")\n+    @DisplayName(\"Check simple core types serialization\")\n     @MethodSource(\"primitives\")\n     <T> void serialization(T obj, TypeHandler<T> typeHandler, PersistedData expectedData) throws Exception {\n         PersistedData data = typeHandler.serialize(obj, new InMemoryPersistedDataSerializer());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY0NzQ1NA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527647454", "bodyText": "Testing some edge cases would be nice, but the setup is quite nice and we can easily add them later.", "author": "skaldarnar", "createdAt": "2020-11-20T12:04:09Z", "path": "subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.persistence.typeHandling.coreTypes;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.terasology.persistence.typeHandling.PersistedData;\n+import org.terasology.persistence.typeHandling.TypeHandler;\n+import org.terasology.persistence.typeHandling.inMemory.InMemoryPersistedDataSerializer;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedBoolean;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedDouble;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedFloat;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedInteger;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedLong;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedString;\n+\n+import java.lang.reflect.Field;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+class SimpleCoreHandlerTest {\n+\n+    private static Stream<Arguments> primitives() {\n+        return Stream.of(\n+                Arguments.of(true, new BooleanTypeHandler(), new PersistedBoolean(true)),\n+\n+                Arguments.of(1.0, new NumberTypeHandler(), new PersistedDouble(1)),\n+                Arguments.of(1, new IntTypeHandler(), new PersistedInteger(1)),\n+                Arguments.of(1L, new LongTypeHandler(), new PersistedLong(1)),\n+                Arguments.of(1.0F, new FloatTypeHandler(), new PersistedFloat(1)),\n+                Arguments.of(1.0, new DoubleTypeHandler(), new PersistedDouble(1)),\n+\n+                Arguments.of(\"foo\", new StringTypeHandler(), new PersistedString(\"foo\")),\n+                Arguments.of('f', new CharacterTypeHandler(), new PersistedString(\"f\")));", "originalCommit": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcxMTk0Nw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527711947", "bodyText": "this typehandlers almost haven't edge cases. (related to java's data types)\nyeah, I known one case :D sends emoji character to CharacterTypeHandler.. and deserialize it back.", "author": "DarkWeird", "createdAt": "2020-11-20T14:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY0NzQ1NA=="}], "type": "inlineReview", "revised_code": {"commit": "479caaa4cd6aab514b52be0620454694b96c463a", "chunk": "diff --git a/subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java b/subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java\nindex 69f7309a1..02052c9e5 100644\n--- a/subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java\n+++ b/subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java\n\n@@ -39,7 +39,7 @@\n     }\n \n     @ParameterizedTest(name = \"{1}\")\n-    @DisplayName(\"Chech simple core types serialization\")\n+    @DisplayName(\"Check simple core types serialization\")\n     @MethodSource(\"primitives\")\n     <T> void serialization(T obj, TypeHandler<T> typeHandler, PersistedData expectedData) throws Exception {\n         PersistedData data = typeHandler.serialize(obj, new InMemoryPersistedDataSerializer());\n"}}, {"oid": "08f2717dc4a9e2694803da59f4483838b8040c3f", "url": "https://github.com/MovingBlocks/Terasology/commit/08f2717dc4a9e2694803da59f4483838b8040c3f", "message": "feat(TypeHandlerLibrary): add Test for In-memory persistent", "committedDate": "2020-11-20T13:01:04Z", "type": "commit"}, {"oid": "a4690a01ce3c00c38e46dba24a88745ff73e13f2", "url": "https://github.com/MovingBlocks/Terasology/commit/a4690a01ce3c00c38e46dba24a88745ff73e13f2", "message": "Merge remote-tracking branch 'origin/extract-TypeHanderLibrary' into extract-subsystem", "committedDate": "2020-11-20T13:03:37Z", "type": "commit"}, {"oid": "af1a93aa5ee069d22076d94e5ba0267c9c68c232", "url": "https://github.com/MovingBlocks/Terasology/commit/af1a93aa5ee069d22076d94e5ba0267c9c68c232", "message": "Merge branch 'develop' into extract-TypeHanderLibrary", "committedDate": "2020-11-20T13:03:04Z", "type": "commit"}, {"oid": "e46bbb85e479ea73f55958bba343f3c4a04439c7", "url": "https://github.com/MovingBlocks/Terasology/commit/e46bbb85e479ea73f55958bba343f3c4a04439c7", "message": "Update subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java\n\nCo-authored-by: Tobias Nett <skaldarnar@googlemail.com>", "committedDate": "2020-11-20T13:14:18Z", "type": "commit"}, {"oid": "479caaa4cd6aab514b52be0620454694b96c463a", "url": "https://github.com/MovingBlocks/Terasology/commit/479caaa4cd6aab514b52be0620454694b96c463a", "message": "Update subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java\n\nCo-authored-by: Tobias Nett <skaldarnar@googlemail.com>", "committedDate": "2020-11-20T13:14:31Z", "type": "commit"}, {"oid": "da3033cd40d64069e1273fa8a55cea0b2f5b4691", "url": "https://github.com/MovingBlocks/Terasology/commit/da3033cd40d64069e1273fa8a55cea0b2f5b4691", "message": "fix(TypeHandlerLibrary): change method reference for typeHandlerLibrary.populateBuiltInHandlers", "committedDate": "2020-11-20T13:42:18Z", "type": "commit"}, {"oid": "708a4d11da82826f5d63c4bc71a0be33f6dd992e", "url": "https://github.com/MovingBlocks/Terasology/commit/708a4d11da82826f5d63c4bc71a0be33f6dd992e", "message": "feat(TypeHandlerLibrary): move `ConstructorLibrary`, `CollectionTypeHandlerFactory`, `OjbectFiledMapTypeHandlerFactory` and they tests  to `TypeHandlerWidget` subsystem.", "committedDate": "2020-11-20T13:54:37Z", "type": "commit"}, {"oid": "df2122a8ff97eea33e3e3e0bb95afc62866f178e", "url": "https://github.com/MovingBlocks/Terasology/commit/df2122a8ff97eea33e3e3e0bb95afc62866f178e", "message": "docs(TypeHandlerLibrary): some license headers and docs", "committedDate": "2020-11-20T14:11:05Z", "type": "commit"}, {"oid": "abbb5898de47b6bc0baec3be2add479cfe79ddca", "url": "https://github.com/MovingBlocks/Terasology/commit/abbb5898de47b6bc0baec3be2add479cfe79ddca", "message": "Merge branch 'develop' into extract-TypeHanderLibrary", "committedDate": "2020-11-21T12:52:52Z", "type": "commit"}, {"oid": "60b503a82bdce3a2bd0c2684c0a65f9a60532426", "url": "https://github.com/MovingBlocks/Terasology/commit/60b503a82bdce3a2bd0c2684c0a65f9a60532426", "message": "Merge branch 'develop' into extract-TypeHanderLibrary", "committedDate": "2020-11-24T07:00:32Z", "type": "commit"}, {"oid": "89bf385498d6716e9d25a9c7c9a060eaca627780", "url": "https://github.com/MovingBlocks/Terasology/commit/89bf385498d6716e9d25a9c7c9a060eaca627780", "message": "fix(TypeHandlerLibrary): move `AbstractSerializer` to TWL subsystem.", "committedDate": "2020-11-24T10:54:10Z", "type": "commit"}, {"oid": "fb36bc2a492d959b4859991e93b01aaaa13c7ef7", "url": "https://github.com/MovingBlocks/Terasology/commit/fb36bc2a492d959b4859991e93b01aaaa13c7ef7", "message": "Merge branch 'develop' into extract-TypeHanderLibrary", "committedDate": "2020-11-30T21:41:11Z", "type": "commit"}, {"oid": "cead38f378afca42148b3b1502f3e0d433df6035", "url": "https://github.com/MovingBlocks/Terasology/commit/cead38f378afca42148b3b1502f3e0d433df6035", "message": "Merge branch 'develop' into extract-TypeHanderLibrary", "committedDate": "2020-12-07T09:47:51Z", "type": "commit"}]}