{"pr_number": 4050, "pr_title": "feat: add BlockArea to replace Rect2i", "pr_createdAt": "2020-06-14T05:39:05Z", "pr_url": "https://github.com/MovingBlocks/Terasology/pull/4050", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MjMwOQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4050#discussion_r439842309", "bodyText": "\"Square\" in the sense of 90\u00b0 angles, or in the sense of a quadratic rectangle with all four sides of equal length?\nI'd vote to call this RectangularRegion for clearer naming and to avoid confusion.", "author": "skaldarnar", "createdAt": "2020-06-14T15:42:59Z", "path": "engine/src/main/java/org/terasology/world/block/SquareRegion.java", "diffHunk": "@@ -0,0 +1,671 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.block;\n+\n+import org.joml.AABBi;\n+import org.joml.Math;\n+import org.joml.Rectanglef;\n+import org.joml.Rectanglei;\n+import org.joml.RoundingMode;\n+import org.joml.Vector2fc;\n+import org.joml.Vector2i;\n+import org.joml.Vector2ic;\n+import org.joml.Vector3ic;\n+\n+/**\n+ * is a bounded rectangle describing squares contained within.\n+ * A {@link SquareRegion} is described and backed by an {@link org.joml.Rectanglei}\n+ */\n+public class SquareRegion {", "originalCommit": "59d99fdf796f1e8b150ea951628855952827d079", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "df2a8088a50cac644a497c5c6f2c190f238f24df", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/SquareRegion.java b/engine/src/main/java/org/terasology/world/block/RectangularRegion.java\nsimilarity index 91%\nrename from engine/src/main/java/org/terasology/world/block/SquareRegion.java\nrename to engine/src/main/java/org/terasology/world/block/RectangularRegion.java\nindex f5f0db750..d461326a6 100644\n--- a/engine/src/main/java/org/terasology/world/block/SquareRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/RectangularRegion.java\n\n@@ -15,30 +15,30 @@\n \n /**\n  * is a bounded rectangle describing squares contained within.\n- * A {@link SquareRegion} is described and backed by an {@link org.joml.Rectanglei}\n+ * A {@link RectangularRegion} is described and backed by an {@link org.joml.Rectanglei}\n  */\n-public class SquareRegion {\n+public class RectangularRegion {\n     /**\n      * rectangle region that backs a SquareRegion\n      */\n     public final Rectanglei rectangle = new Rectanglei();\n \n-    public SquareRegion() {\n+    public RectangularRegion() {\n     }\n \n-    public SquareRegion(SquareRegion source) {\n+    public RectangularRegion(RectangularRegion source) {\n         RectangleUtility.set(rectangle, source.rectangle);\n     }\n \n-    public SquareRegion(Rectanglei source) {\n+    public RectangularRegion(Rectanglei source) {\n         RectangleUtility.set(rectangle, source);\n     }\n \n-    public SquareRegion(Vector2ic min, Vector2ic max) {\n+    public RectangularRegion(Vector2ic min, Vector2ic max) {\n         this(min.x(), min.y(), max.x(), max.y());\n     }\n \n-    public SquareRegion(int minX, int minY, int maxX, int maxY) {\n+    public RectangularRegion(int minX, int minY, int maxX, int maxY) {\n         this.setMin(minX, minY).setMax(maxX, maxY);\n     }\n \n"}}, {"oid": "88b4ac0b894bff0019b585617d85530ea3261dda", "url": "https://github.com/MovingBlocks/Terasology/commit/88b4ac0b894bff0019b585617d85530ea3261dda", "message": "add SquareRegion to replace Rect2i", "committedDate": "2020-11-14T22:10:57Z", "type": "commit"}, {"oid": "df2a8088a50cac644a497c5c6f2c190f238f24df", "url": "https://github.com/MovingBlocks/Terasology/commit/df2a8088a50cac644a497c5c6f2c190f238f24df", "message": "rename to RectangularRegion", "committedDate": "2020-11-14T22:10:57Z", "type": "commit"}, {"oid": "72f541669e5795536f2f5ce9058309fc9df2354b", "url": "https://github.com/MovingBlocks/Terasology/commit/72f541669e5795536f2f5ce9058309fc9df2354b", "message": "add missing contains for both regions and added tests", "committedDate": "2020-11-14T22:10:57Z", "type": "commit"}, {"oid": "72f541669e5795536f2f5ce9058309fc9df2354b", "url": "https://github.com/MovingBlocks/Terasology/commit/72f541669e5795536f2f5ce9058309fc9df2354b", "message": "add missing contains for both regions and added tests", "committedDate": "2020-11-14T22:10:57Z", "type": "forcePushed"}, {"oid": "c33acf882700e0f7b48e49f7c61ea1e5c521f3a6", "url": "https://github.com/MovingBlocks/Terasology/commit/c33acf882700e0f7b48e49f7c61ea1e5c521f3a6", "message": "Merge branch 'develop' into feature/square_region", "committedDate": "2020-11-14T22:20:24Z", "type": "commit"}, {"oid": "a110566b11b0e1ee1e4273d35649acb46d94bc01", "url": "https://github.com/MovingBlocks/Terasology/commit/a110566b11b0e1ee1e4273d35649acb46d94bc01", "message": "Merge branch 'develop' into feature/square_region", "committedDate": "2020-11-25T18:21:03Z", "type": "commit"}, {"oid": "6671fb429769f92fd07dc262b1630a257055e9b9", "url": "https://github.com/MovingBlocks/Terasology/commit/6671fb429769f92fd07dc262b1630a257055e9b9", "message": "Merge remote-tracking branch 'upstream/develop' into feature/square_region", "committedDate": "2020-12-12T17:33:37Z", "type": "commit"}, {"oid": "986bb62c4701e7af9c790a122f9c31fe164caf06", "url": "https://github.com/MovingBlocks/Terasology/commit/986bb62c4701e7af9c790a122f9c31fe164caf06", "message": "Merge branch 'feature/square_region' of github.com:pollend/Terasology into feature/square_region", "committedDate": "2020-12-12T17:33:55Z", "type": "commit"}, {"oid": "53046d457fac3c6a2206f347883fe1981296552d", "url": "https://github.com/MovingBlocks/Terasology/commit/53046d457fac3c6a2206f347883fe1981296552d", "message": "Merge branch 'develop' into feature/square_region", "committedDate": "2020-12-13T14:46:02Z", "type": "commit"}, {"oid": "168dc5e164da0d608eb2708e8470cd2fd3107d03", "url": "https://github.com/MovingBlocks/Terasology/commit/168dc5e164da0d608eb2708e8470cd2fd3107d03", "message": "- rename RectangularRegion >>> BlockArea\n- add BlockAreas utility class\n- adjust tests", "committedDate": "2020-12-13T17:51:55Z", "type": "commit"}, {"oid": "89ff710cf0d0f5dac89041cb05b1b6369ce0da14", "url": "https://github.com/MovingBlocks/Terasology/commit/89ff710cf0d0f5dac89041cb05b1b6369ce0da14", "message": "... something something rewrite ...", "committedDate": "2020-12-13T19:47:49Z", "type": "commit"}, {"oid": "3f6308b3a4d32fedea58be6270d7120d6c9d9698", "url": "https://github.com/MovingBlocks/Terasology/commit/3f6308b3a4d32fedea58be6270d7120d6c9d9698", "message": "... moar WIP", "committedDate": "2020-12-13T20:06:44Z", "type": "commit"}, {"oid": "b3b127c662d1efd6e4df695b3cec4560bcc4d10d", "url": "https://github.com/MovingBlocks/Terasology/commit/b3b127c662d1efd6e4df695b3cec4560bcc4d10d", "message": "...", "committedDate": "2020-12-13T20:18:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk5Nzg1Nw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4050#discussion_r541997857", "bodyText": "@pollend Is this too much overhead keeping the vectors? Should I instead use just 4 plain integers?", "author": "skaldarnar", "createdAt": "2020-12-13T20:22:29Z", "path": "engine/src/main/java/org/terasology/world/block/BlockArea.java", "diffHunk": "@@ -0,0 +1,622 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.block;\n+\n+import com.google.common.base.Preconditions;\n+import org.joml.AABBf;\n+import org.joml.AABBi;\n+import org.joml.Math;\n+import org.joml.Rectangled;\n+import org.joml.Rectanglef;\n+import org.joml.Rectanglei;\n+import org.joml.RoundingMode;\n+import org.joml.Vector2fc;\n+import org.joml.Vector2i;\n+import org.joml.Vector2ic;\n+import org.joml.Vector3ic;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A bounded axis-aligned rectangle of blocks.\n+ * <p>\n+ * A block area is described and backed by an {@link org.joml.Rectanglei}\n+ *\n+ * @see BlockAreas\n+ */\n+public class BlockArea {\n+    private final Vector2i min = new Vector2i(Integer.MAX_VALUE);\n+    private final Vector2i max = new Vector2i(Integer.MIN_VALUE);", "originalCommit": "b3b127c662d1efd6e4df695b3cec4560bcc4d10d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk5ODA2Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4050#discussion_r541998062", "bodyText": "I would just use 4 integers.", "author": "pollend", "createdAt": "2020-12-13T20:24:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk5Nzg1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f43b7423b7793a8a0444acd59218157cc0d070b5", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockArea.java b/engine/src/main/java/org/terasology/world/block/BlockArea.java\nindex f5f02de2a..36bc2c5f9 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockArea.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockArea.java\n\n@@ -188,6 +188,19 @@ public BlockArea union(int x, int y, BlockArea dest) {\n         return dest;\n     }\n \n+    /**\n+     * calculate the BlockRegion that is intersected between another region\n+     *\n+     * @param other the other BlockRegion\n+     * @param dest holds the result\n+     * @return dest\n+     */\n+    public BlockArea intersection(BlockArea other, BlockArea dest) {\n+        dest.min.set(Math.max(this.min.x(), other.min.x()), Math.max(this.min.y(), other.min.y()));\n+        dest.max.set(Math.min(this.max.x(), other.max.x()), Math.min(this.max.y(), other.max.y()));\n+        return dest;\n+    }\n+\n     /**\n      * the number of blocks for the +x, +y, +z from the minimum to the maximum\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk5Nzk1OA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4050#discussion_r541997958", "bodyText": "@pollend Should we compute the bounding rectangle every time something changes, or just when it is requested (lazy)? I've prepared to do the latter, not fully implemented yet, though.", "author": "skaldarnar", "createdAt": "2020-12-13T20:23:23Z", "path": "engine/src/main/java/org/terasology/world/block/BlockArea.java", "diffHunk": "@@ -0,0 +1,622 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.block;\n+\n+import com.google.common.base.Preconditions;\n+import org.joml.AABBf;\n+import org.joml.AABBi;\n+import org.joml.Math;\n+import org.joml.Rectangled;\n+import org.joml.Rectanglef;\n+import org.joml.Rectanglei;\n+import org.joml.RoundingMode;\n+import org.joml.Vector2fc;\n+import org.joml.Vector2i;\n+import org.joml.Vector2ic;\n+import org.joml.Vector3ic;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A bounded axis-aligned rectangle of blocks.\n+ * <p>\n+ * A block area is described and backed by an {@link org.joml.Rectanglei}\n+ *\n+ * @see BlockAreas\n+ */\n+public class BlockArea {\n+    private final Vector2i min = new Vector2i(Integer.MAX_VALUE);\n+    private final Vector2i max = new Vector2i(Integer.MIN_VALUE);\n+\n+    private boolean dirty = true;\n+    private Rectanglef rectangle = new Rectanglef();", "originalCommit": "b3b127c662d1efd6e4df695b3cec4560bcc4d10d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk5ODI0Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4050#discussion_r541998242", "bodyText": "I would just update the bounds if it changes. you still end up needing to recalculate it for most cases.  when you update min you only need to update the minimum of the bounds and the same for max. its probably more expensive to check if its dirty and then try update both the bounds.", "author": "pollend", "createdAt": "2020-12-13T20:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk5Nzk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAwMDcwNQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4050#discussion_r542000705", "bodyText": "I would expect this to be used sufficiently rarely that just not cacheing at all would be best.", "author": "4Denthusiast", "createdAt": "2020-12-13T20:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk5Nzk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAwNzY1NQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4050#discussion_r542007655", "bodyText": "If we're going to re-compute it anyways, maybe make it more explicit? Then the caller can do whatever they want with it....\nRectanglef worldArea = BlockAreas.toWorldArea(area);", "author": "skaldarnar", "createdAt": "2020-12-13T21:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk5Nzk1OA=="}], "type": "inlineReview", "revised_code": {"commit": "f43b7423b7793a8a0444acd59218157cc0d070b5", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockArea.java b/engine/src/main/java/org/terasology/world/block/BlockArea.java\nindex f5f02de2a..36bc2c5f9 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockArea.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockArea.java\n\n@@ -188,6 +188,19 @@ public BlockArea union(int x, int y, BlockArea dest) {\n         return dest;\n     }\n \n+    /**\n+     * calculate the BlockRegion that is intersected between another region\n+     *\n+     * @param other the other BlockRegion\n+     * @param dest holds the result\n+     * @return dest\n+     */\n+    public BlockArea intersection(BlockArea other, BlockArea dest) {\n+        dest.min.set(Math.max(this.min.x(), other.min.x()), Math.max(this.min.y(), other.min.y()));\n+        dest.max.set(Math.min(this.max.x(), other.max.x()), Math.min(this.max.y(), other.max.y()));\n+        return dest;\n+    }\n+\n     /**\n      * the number of blocks for the +x, +y, +z from the minimum to the maximum\n      *\n"}}, {"oid": "f43b7423b7793a8a0444acd59218157cc0d070b5", "url": "https://github.com/MovingBlocks/Terasology/commit/f43b7423b7793a8a0444acd59218157cc0d070b5", "message": "chore: remove RectangleUtility", "committedDate": "2020-12-13T20:27:57Z", "type": "commit"}, {"oid": "dd7fd624f3bd49f4ac10de3d397d1347e4b18d9d", "url": "https://github.com/MovingBlocks/Terasology/commit/dd7fd624f3bd49f4ac10de3d397d1347e4b18d9d", "message": "test: make test arguments source explicit", "committedDate": "2020-12-13T21:05:02Z", "type": "commit"}, {"oid": "1f1cc80127fed9bc405001719b61d6e7afe5ddc1", "url": "https://github.com/MovingBlocks/Terasology/commit/1f1cc80127fed9bc405001719b61d6e7afe5ddc1", "message": "test: more tests for intersection", "committedDate": "2020-12-13T22:26:29Z", "type": "commit"}, {"oid": "ae58d1527d3b9be34de1fc947b5576b07b50cc54", "url": "https://github.com/MovingBlocks/Terasology/commit/ae58d1527d3b9be34de1fc947b5576b07b50cc54", "message": "perf: replace vectors for min and max by plain integers", "committedDate": "2020-12-13T23:09:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2MjA3MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4050#discussion_r542062070", "bodyText": "why do we need a copy method when can just use a constructor method.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /**\n          \n          \n            \n                 * @return a copy of this block area\n          \n          \n            \n                 */\n          \n          \n            \n                public BlockArea copy() {\n          \n          \n            \n                    return new BlockArea().set(this);\n          \n          \n            \n                }\n          \n          \n            \n                /**\n          \n          \n            \n                 */\n          \n          \n            \n                public BlockArea(BlockArea area) {\n          \n          \n            \n                     this.set(this);\n          \n          \n            \n                }", "author": "pollend", "createdAt": "2020-12-14T01:57:13Z", "path": "engine/src/main/java/org/terasology/world/block/BlockArea.java", "diffHunk": "@@ -0,0 +1,508 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.block;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import org.joml.Math;\n+import org.joml.Rectangled;\n+import org.joml.Rectanglef;\n+import org.joml.Vector2fc;\n+import org.joml.Vector2i;\n+import org.joml.Vector2ic;\n+\n+/**\n+ * A bounded axis-aligned rectangle of blocks.\n+ * <p>\n+ * A block area is described and backed by an {@link org.joml.Rectanglei}\n+ *\n+ * @see BlockAreas\n+ */\n+public class BlockArea {\n+    private int minX = Integer.MAX_VALUE;\n+    private int minY = Integer.MAX_VALUE;\n+    private int maxX = Integer.MIN_VALUE;\n+    private int maxY = Integer.MIN_VALUE;\n+\n+    private Rectanglef bounds = new Rectanglef();\n+\n+    public BlockArea() {\n+    }\n+\n+    /**\n+     * @return a copy of this block area\n+     */\n+    public BlockArea copy() {\n+        return new BlockArea().set(this);\n+    }", "originalCommit": "ae58d1527d3b9be34de1fc947b5576b07b50cc54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "430c9caa56062556ea548afe315d65a183661f8e", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockArea.java b/engine/src/main/java/org/terasology/world/block/BlockArea.java\nindex f5ee7971d..02ab966c4 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockArea.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockArea.java\n\n@@ -6,436 +6,322 @@\n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import org.joml.Math;\n-import org.joml.Rectangled;\n-import org.joml.Rectanglef;\n-import org.joml.Vector2fc;\n import org.joml.Vector2i;\n import org.joml.Vector2ic;\n \n+import java.util.Iterator;\n+import java.util.Optional;\n+\n /**\n- * A bounded axis-aligned rectangle of blocks.\n- * <p>\n- * A block area is described and backed by an {@link org.joml.Rectanglei}\n- *\n- * @see BlockAreas\n+ * A mutable, bounded, axis-aligned are denoting a collection of blocks contained within.\n  */\n-public class BlockArea {\n+public class BlockArea implements BlockAreac {\n+\n+    public static final BlockAreac INVALID = new BlockArea();\n+\n     private int minX = Integer.MAX_VALUE;\n     private int minY = Integer.MAX_VALUE;\n     private int maxX = Integer.MIN_VALUE;\n     private int maxY = Integer.MIN_VALUE;\n \n-    private Rectanglef bounds = new Rectanglef();\n+    // -- CONSTRUCTORS -----------------------------------------------------------------------------------------------//\n+\n+    BlockArea() {\n+    }\n+\n+    public BlockArea(int minX, int minY, int maxX, int maxY) {\n+        this.set(minX, minY, maxX, maxY);\n+    }\n \n-    public BlockArea() {\n+    public BlockArea(Vector2ic min, Vector2ic max) {\n+        this.set(min.x(), min.y(), max.x(), max.y());\n     }\n \n-    /**\n-     * @return a copy of this block area\n-     */\n-    public BlockArea copy() {\n-        return new BlockArea().set(this);\n+    public BlockArea(int x, int y) {\n+        this.set(x, y, x, y);\n     }\n \n-    public boolean isValid() {\n-        return minX <= maxX && minY <= maxY;\n+    public BlockArea(Vector2ic pos) {\n+        this.set(pos, pos);\n     }\n \n-    public boolean isEmpty() {\n-        return !isValid();\n+    public BlockArea(BlockAreac other) {\n+        this.set(other.minX(), other.minY(), other.maxX(), other.maxY());\n     }\n \n-    public BlockArea set(BlockArea other) {\n-        this.minX = other.minX;\n-        this.minY = other.minY;\n-        this.maxX = other.maxX;\n-        this.maxY = other.maxY;\n+    // -- reset ------------------------------------------------------------------------------------------------------//\n+\n+    public BlockArea set(int minX, int minY, int maxX, int maxY) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n \n-        Rectangles.set(this.bounds, other.bounds);\n         return this;\n     }\n \n-    /**\n-     * get the minimum block coordinate\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector2i getMin(Vector2i dest) {\n-        return dest.set(minX, minY);\n-    }\n-\n-    /**\n-     * get the maximum block coordinate\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector2i getMax(Vector2i dest) {\n-        return dest.set(maxX, maxY);\n-    }\n-\n-    /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n-     */\n-    public int getMaxX() {\n-        return maxX;\n+    public BlockArea set(Vector2ic min, Vector2ic max) {\n+        return this.set(min.x(), min.y(), max.x(), max.y());\n     }\n \n-    /**\n-     * the maximum coordinate of the second block y\n-     *\n-     * @return the minimum coordinate y\n-     */\n-    public int getMaxY() {\n-        return maxY;\n+    public BlockArea set(BlockAreac other) {\n+        return this.set(other.minX(), other.minY(), other.maxX(), other.maxY());\n     }\n \n-    /**\n-     * the minimum coordinate of the first block x\n-     *\n-     * @return the minimum coordinate x\n-     */\n-    public int getMinX() {\n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector2ic> iterator() {\n+        return new Iterator<Vector2ic>() {\n+            private Vector2i current = null;\n+            private final Vector2i next = getMin(new Vector2i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.y++;\n+                    if (next.y > maxY) {\n+                        next.y = minY;\n+                        next.x++;\n+                    }\n+\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector2ic next() {\n+                if (current == null) {\n+                    current = new Vector2i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n+    // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n         return minX;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     */\n-    public int getMinY() {\n+    @Override\n+    public int minY() {\n         return minY;\n     }\n \n-    /**\n-     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param min the first coordinate of the first block\n-     * @return this\n-     */\n-    @SuppressWarnings(\"checkstyle:HiddenField\")\n+    @Override\n+    public BlockArea minX(int x, BlockArea dest) {\n+        return dest.set(x, minY, maxX, maxY);\n+    }\n+\n+    public BlockArea minX(int x) {\n+        return minX(x, this);\n+    }\n+\n+    @Override\n+    public BlockArea minY(int y, BlockArea dest) {\n+        return dest.set(minX, y, maxX, maxY);\n+    }\n+\n+    public BlockArea minY(int y) {\n+        return minY(y, this);\n+    }\n+\n+    @Override\n+    public BlockArea setMin(int x, int y, BlockArea dest) {\n+        return dest.set(x, y, maxX, maxY);\n+    }\n+\n+    public BlockArea setMin(int x, int y) {\n+        return this.setMin(x, y, this);\n+    }\n+\n     public BlockArea setMin(Vector2ic min) {\n-        return setMin(min.x(), min.y());\n-    }\n-\n-    /**\n-     * sets the minimum block for this {@link BlockRegion}\n-     *\n-     * @param minX the x coordinate of the first block\n-     * @param minY the y coordinate of the first block\n-     * @return this\n-     */\n-    public BlockArea setMin(int minX, int minY) {\n-        Preconditions.checkArgument(minX <= this.maxX ^ this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minY <= this.maxY ^ this.maxY == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        Rectangles.setMin(this.bounds, minX - 0.5f, minY - 0.5f);\n-        return this;\n+        return this.setMin(min.x(), min.y(), this);\n+    }\n+\n+    public BlockArea addToMin(int x, int y) {\n+        return this.addToMin(x, y, this);\n+    }\n+\n+    public BlockArea addToMin(Vector2ic min) {\n+        return this.addToMin(min.x(), min.y(), this);\n+    }\n+\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int maxX() {\n+        return maxX;\n+    }\n+\n+    @Override\n+    public int maxY() {\n+        return maxY;\n+    }\n+\n+    @Override\n+    public BlockArea maxX(int x, BlockArea dest) {\n+        return dest.set(minX, minY, x, maxY);\n+    }\n+\n+    public BlockArea maxX(int x) {\n+        return maxX(x, this);\n+    }\n+\n+    @Override\n+    public BlockArea maxY(int y, BlockArea dest) {\n+        return dest.set(minX, minY, maxX, y);\n+    }\n+\n+    public BlockArea maxY(int y) {\n+        return maxY(y, this);\n+    }\n+\n+    @Override\n+    public BlockArea setMax(int x, int y, BlockArea dest) {\n+        return dest.set(minX, minY, x, y);\n+    }\n+\n+    public BlockArea setMax(int x, int y) {\n+        return this.setMax(x, y, this);\n     }\n \n-    /**\n-     * Sets the maximum coordinate of the second block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param max the second coordinate of the second block\n-     * @return this\n-     */\n     public BlockArea setMax(Vector2ic max) {\n-        return setMax(max.x(), max.y());\n-    }\n-\n-    /**\n-     * sets the maximum block for this {@link BlockRegion}\n-     *\n-     * @param maxX the x coordinate of the first block\n-     * @param maxY the y coordinate of the first block\n-     * @return this\n-     */\n-    @SuppressWarnings(\"checkstyle:HiddenField\")\n-    public BlockArea setMax(int maxX, int maxY) {\n-        Preconditions.checkArgument(maxX >= this.minX ^ this.minX == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxY >= this.minY ^ this.minY == Integer.MAX_VALUE);\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        Rectangles.setMax(this.bounds, maxX + 0.5f, maxY + 0.5f);\n-        return this;\n+        return this.setMax(max.x(), max.y(), this);\n     }\n \n-    /**\n-     * Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n-     *\n-     * @param other {@link BlockRegion}\n-     * @return this\n-     */\n-    public BlockArea union(BlockArea other) {\n-        return union(other.minX, other.minY).union(other.minX, other.maxY);\n+    public BlockArea addToMax(int x, int y) {\n+        return this.addToMax(x, y, this);\n     }\n \n-    /**\n-     * Set <code>this</code> to the union of <code>this</code> and the given block <code>p</code>.\n-     *\n-     * @param p the position of the block\n-     * @return this\n-     */\n-    public BlockArea union(Vector2ic p) {\n-        return union(p.x(), p.y());\n+    public BlockArea addToMax(Vector2ic max) {\n+        return this.addToMax(max.x(), max.y(), this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea setSize(int sizeX, int sizeY, BlockArea dest) {\n+        return dest.set(minX, minY, minX + sizeX, minY + sizeY);\n+    }\n+\n+    public BlockArea setSize(int sizeX, int sizeY) {\n+        return this.setSize(sizeX, sizeY, this);\n+    }\n+\n+    public BlockArea setSize(Vector2ic size) {\n+        return this.setSize(size.x(), size.y(), this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea union(int x, int y, BlockArea dest) {\n+        return dest.set(\n+                Math.min(this.minX, x), Math.min(this.minY, y),\n+                Math.max(this.maxX, x), Math.max(this.maxY, y));\n     }\n \n     public BlockArea union(int x, int y) {\n         return union(x, y, this);\n     }\n \n-    /**\n-     * Compute the union of <code>this</code> and the given block <code>(x, y, z)</code> and stores the result in\n-     * <code>dest</code>\n-     *\n-     * @param x the x coordinate of the block\n-     * @param y the y coordinate of the block\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea union(int x, int y, BlockArea dest) {\n-        return dest\n-                .setMin(Math.min(dest.minX, x), Math.min(dest.minY, y))\n-                .setMax(Math.max(dest.maxX, x), Math.max(dest.maxY, y));\n-    }\n-\n-    /**\n-     * calculate the BlockRegion that is intersected between another region\n-     *\n-     * @param other the other BlockRegion\n-     * @param dest holds the result\n-     * @return dest\n-     */\n-    public BlockArea intersection(BlockArea other, BlockArea dest) {\n-        return dest\n-                .setMin(Math.max(this.minX, other.minX), Math.max(this.minY, other.minY))\n-                .setMax(Math.min(this.maxX, other.maxX), Math.min(this.maxY, other.maxY));\n-    }\n-\n-    /**\n-     * the number of blocks for the +x, +y, +z from the minimum to the maximum\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector2i getSize(Vector2i dest) {\n-        return dest.set(getSizeX(), getSizeY());\n-    }\n-\n-    /**\n-     * The number of blocks on the X axis\n-     *\n-     * @return number of blocks in the X axis\n-     */\n-    public int getSizeX() {\n-        return this.maxX - this.minX;\n-    }\n-\n-    /**\n-     * The number of blocks on the Y axis\n-     *\n-     * @return number of blocks in the Y axis\n-     */\n-    public int getSizeY() {\n-        return this.maxY - this.minY;\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param x the x coordinate to translate by\n-     * @param y the y coordinate to translate by\n-     * @return this\n-     */\n-    public BlockArea translate(int x, int y) {\n-        return translate(x, y, this);\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param xy the vector to translate by\n-     * @return this\n-     */\n-    public BlockArea translate(Vector2ic xy) {\n-        return translate(xy, this);\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param xy the vector to translate by\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea translate(Vector2ic xy, BlockArea dest) {\n-        return translate(xy.x(), xy.y(), dest);\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xy</code>.\n-     *\n-     * @param x the length to translate by along x direction\n-     * @param y the length to translate by along y direction\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea translate(int x, int y, BlockArea dest) {\n-        dest.minX += x;\n-        dest.minY += y;\n-        dest.maxX += x;\n-        dest.maxY += y;\n-        dest.bounds.translate(x, y);\n-        return dest;\n+    public BlockArea union(Vector2ic p) {\n+        return union(p.x(), p.y(), this);\n+    }\n+\n+    public BlockArea union(BlockArea other) {\n+        return union(other, this);\n     }\n \n-    /**\n-     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param pos the coordinates of the block\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsBlock(Vector2ic pos) {\n-        return containsBlock(pos.x(), pos.y());\n-    }\n-\n-    /**\n-     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsBlock(int x, int y) {\n-        return x >= minX && y >= minY && x <= maxX && y <= maxY;\n-    }\n-\n-    /**\n-     * WORLD-COORDINATES\n-     * Test whether the point <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this BlockRegion; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(float x, float y) {\n-        return getWorldArea().containsPoint(x, y);\n-    }\n-\n-    /**\n-     * @see #containsPoint(float, float)\n-     */\n-    public boolean containsPoint(Vector2fc point) {\n-        return this.containsPoint(point.x(), point.y());\n-    }\n-\n-    /**\n-     * Test whether the point <code>(x, y, z)</code> lies inside this AABB.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(int x, int y) {\n-        return containsBlock(x, y);\n-    }\n-\n-    /**\n-     * Test whether the given point lies inside this AABB.\n-     *\n-     * @param point the coordinates of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(Vector2ic point) {\n-        return containsPoint(point.x(), point.y());\n-    }\n-\n-    /**\n-     * Test whether the given {@link BlockArea}  lies inside the {@link BlockArea}\n-     *\n-     * @param area the area to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockArea}; <code>false</code> otherwise\n-     */\n-    public boolean containsArea(BlockArea area) {\n-        return this.containsBlock(area.minX, area.minY) && this.containsBlock(area.maxX, area.maxY);\n-    }\n-\n-    /**\n-     * Test whether <code>this</code> and <code>other</code> intersect.\n-     *\n-     * @param other the other BlockRegion\n-     * @return <code>true</code> iff both AABBs intersect; <code>false</code> otherwise\n-     */\n-    public boolean intersectsArea(BlockArea other) {\n-        return this.minX <= other.maxX && this.maxX >= other.minX && this.maxY >= other.minY && this.minY <= other.maxY;\n-    }\n-\n-    /**\n-     * Adds extend for each face of a BlockRegion.\n-     *\n-     * @param extent extents to grow each face\n-     * @param dest holds the result\n-     * @return dest\n-     */\n-    public BlockArea addExtents(int extent, BlockArea dest) {\n-        return addExtents(extent, extent, dest);\n-    }\n-\n-    /**\n-     * Adds extend for each face of a BlockRegion.\n-     *\n-     * @param extentX the x coordinate to grow the extents\n-     * @param extentY the y coordinate to grow the extents\n-     * @return this\n-     */\n-    public BlockArea addExtents(int extentX, int extentY) {\n-        return addExtents(extentX, extentY, this);\n-    }\n-\n-    /**\n-     * Adds extend for each face of a BlockRegion\n-     *\n-     * @param extentX the x coordinate to grow the extents\n-     * @param extentY the y coordinate to grow the extents\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea addExtents(int extentX, int extentY, BlockArea dest) {\n-        Preconditions.checkArgument(dest.getSizeX() + 2 * extentX >= 0 && dest.getSizeY() + 2 * extentY >= 0);\n-        dest.minX -= extentX;\n-        dest.minY -= extentY;\n-        dest.maxX += extentX;\n-        dest.maxY += extentY;\n-        Rectangles.expand(this.bounds, extentX, extentY);\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Optional<BlockArea> intersect(BlockAreac other, BlockArea dest) {\n+        dest.minX = Math.max(minX, other.minX());\n+        dest.minY = Math.max(minY, other.minY());\n+\n+        dest.maxX = Math.min(maxX, other.maxX());\n+        dest.maxY = Math.min(maxY, other.maxY());\n+\n+        if (dest.isValid()) {\n+            return Optional.of(dest);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public Optional<BlockArea> intersect(BlockAreac other) {\n+        return this.intersect(other, this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea translate(int dx, int dy, BlockArea dest) {\n+        dest.minX = minX + dx;\n+        dest.minY = minY + dy;\n+        dest.maxX = maxX + dx;\n+        dest.maxY = maxY + dy;\n         return dest;\n     }\n \n+    public BlockArea translate(int dx, int dy) {\n+        return translate(dx, dy, this);\n+    }\n+\n+    public BlockArea translate(Vector2ic dv) {\n+        return translate(dv.x(), dv.y(), this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea expand(int dx, int dy, BlockArea dest) {\n+        return dest.set(minX - dx, minY - dy, maxX + dx, maxY + dy);\n+    }\n \n-    /**\n-     * Test whether the given {@link Rectanglef}  lies inside the {@link BlockArea}\n-     *\n-     * @param rect the rectangle to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockArea}; <code>false</code> otherwise\n-     */\n-    public boolean containsRectangle(Rectanglef rect) {\n-        return getWorldArea().containsRectangle(rect);\n+    public BlockArea expand(int dx, int dy) {\n+        return expand(dx, dy, this);\n     }\n \n-    /**\n-     * Test whether the given {@link Rectangled}  lies inside the {@link BlockArea}\n-     *\n-     * @param rect the rectangle to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockArea}; <code>false</code> otherwise\n-     */\n-    public boolean containsRectangle(Rectangled rect) {\n-        return getWorldArea().containsRectangle(rect);\n+    public BlockArea expand(Vector2ic dv) {\n+        return expand(dv.x(), dv.y(), this);\n     }\n \n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2Mjc1MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4050#discussion_r542062751", "bodyText": "I think we should lean more on using assertions.\nhttps://www.geeksforgeeks.org/assertions-in-java/", "author": "pollend", "createdAt": "2020-12-14T01:59:50Z", "path": "engine/src/main/java/org/terasology/world/block/BlockArea.java", "diffHunk": "@@ -0,0 +1,508 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.block;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import org.joml.Math;\n+import org.joml.Rectangled;\n+import org.joml.Rectanglef;\n+import org.joml.Vector2fc;\n+import org.joml.Vector2i;\n+import org.joml.Vector2ic;\n+\n+/**\n+ * A bounded axis-aligned rectangle of blocks.\n+ * <p>\n+ * A block area is described and backed by an {@link org.joml.Rectanglei}\n+ *\n+ * @see BlockAreas\n+ */\n+public class BlockArea {\n+    private int minX = Integer.MAX_VALUE;\n+    private int minY = Integer.MAX_VALUE;\n+    private int maxX = Integer.MIN_VALUE;\n+    private int maxY = Integer.MIN_VALUE;\n+\n+    private Rectanglef bounds = new Rectanglef();\n+\n+    public BlockArea() {\n+    }\n+\n+    /**\n+     * @return a copy of this block area\n+     */\n+    public BlockArea copy() {\n+        return new BlockArea().set(this);\n+    }\n+\n+    public boolean isValid() {\n+        return minX <= maxX && minY <= maxY;\n+    }\n+\n+    public boolean isEmpty() {\n+        return !isValid();\n+    }\n+\n+    public BlockArea set(BlockArea other) {\n+        this.minX = other.minX;\n+        this.minY = other.minY;\n+        this.maxX = other.maxX;\n+        this.maxY = other.maxY;\n+\n+        Rectangles.set(this.bounds, other.bounds);\n+        return this;\n+    }\n+\n+    /**\n+     * get the minimum block coordinate\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector2i getMin(Vector2i dest) {\n+        return dest.set(minX, minY);\n+    }\n+\n+    /**\n+     * get the maximum block coordinate\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector2i getMax(Vector2i dest) {\n+        return dest.set(maxX, maxY);\n+    }\n+\n+    /**\n+     * the maximum coordinate of the second block x\n+     *\n+     * @return the minimum coordinate x\n+     */\n+    public int getMaxX() {\n+        return maxX;\n+    }\n+\n+    /**\n+     * the maximum coordinate of the second block y\n+     *\n+     * @return the minimum coordinate y\n+     */\n+    public int getMaxY() {\n+        return maxY;\n+    }\n+\n+    /**\n+     * the minimum coordinate of the first block x\n+     *\n+     * @return the minimum coordinate x\n+     */\n+    public int getMinX() {\n+        return minX;\n+    }\n+\n+    /**\n+     * the minimum coordinate of the first block y\n+     *\n+     * @return the minimum coordinate y\n+     */\n+    public int getMinY() {\n+        return minY;\n+    }\n+\n+    /**\n+     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n+     *\n+     * @param min the first coordinate of the first block\n+     * @return this\n+     */\n+    @SuppressWarnings(\"checkstyle:HiddenField\")\n+    public BlockArea setMin(Vector2ic min) {\n+        return setMin(min.x(), min.y());\n+    }\n+\n+    /**\n+     * sets the minimum block for this {@link BlockRegion}\n+     *\n+     * @param minX the x coordinate of the first block\n+     * @param minY the y coordinate of the first block\n+     * @return this\n+     */\n+    public BlockArea setMin(int minX, int minY) {\n+        Preconditions.checkArgument(minX <= this.maxX ^ this.maxX == Integer.MIN_VALUE);\n+        Preconditions.checkArgument(minY <= this.maxY ^ this.maxY == Integer.MIN_VALUE);", "originalCommit": "ae58d1527d3b9be34de1fc947b5576b07b50cc54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "430c9caa56062556ea548afe315d65a183661f8e", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockArea.java b/engine/src/main/java/org/terasology/world/block/BlockArea.java\nindex f5ee7971d..02ab966c4 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockArea.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockArea.java\n\n@@ -6,436 +6,322 @@\n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import org.joml.Math;\n-import org.joml.Rectangled;\n-import org.joml.Rectanglef;\n-import org.joml.Vector2fc;\n import org.joml.Vector2i;\n import org.joml.Vector2ic;\n \n+import java.util.Iterator;\n+import java.util.Optional;\n+\n /**\n- * A bounded axis-aligned rectangle of blocks.\n- * <p>\n- * A block area is described and backed by an {@link org.joml.Rectanglei}\n- *\n- * @see BlockAreas\n+ * A mutable, bounded, axis-aligned are denoting a collection of blocks contained within.\n  */\n-public class BlockArea {\n+public class BlockArea implements BlockAreac {\n+\n+    public static final BlockAreac INVALID = new BlockArea();\n+\n     private int minX = Integer.MAX_VALUE;\n     private int minY = Integer.MAX_VALUE;\n     private int maxX = Integer.MIN_VALUE;\n     private int maxY = Integer.MIN_VALUE;\n \n-    private Rectanglef bounds = new Rectanglef();\n+    // -- CONSTRUCTORS -----------------------------------------------------------------------------------------------//\n+\n+    BlockArea() {\n+    }\n+\n+    public BlockArea(int minX, int minY, int maxX, int maxY) {\n+        this.set(minX, minY, maxX, maxY);\n+    }\n \n-    public BlockArea() {\n+    public BlockArea(Vector2ic min, Vector2ic max) {\n+        this.set(min.x(), min.y(), max.x(), max.y());\n     }\n \n-    /**\n-     * @return a copy of this block area\n-     */\n-    public BlockArea copy() {\n-        return new BlockArea().set(this);\n+    public BlockArea(int x, int y) {\n+        this.set(x, y, x, y);\n     }\n \n-    public boolean isValid() {\n-        return minX <= maxX && minY <= maxY;\n+    public BlockArea(Vector2ic pos) {\n+        this.set(pos, pos);\n     }\n \n-    public boolean isEmpty() {\n-        return !isValid();\n+    public BlockArea(BlockAreac other) {\n+        this.set(other.minX(), other.minY(), other.maxX(), other.maxY());\n     }\n \n-    public BlockArea set(BlockArea other) {\n-        this.minX = other.minX;\n-        this.minY = other.minY;\n-        this.maxX = other.maxX;\n-        this.maxY = other.maxY;\n+    // -- reset ------------------------------------------------------------------------------------------------------//\n+\n+    public BlockArea set(int minX, int minY, int maxX, int maxY) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n \n-        Rectangles.set(this.bounds, other.bounds);\n         return this;\n     }\n \n-    /**\n-     * get the minimum block coordinate\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector2i getMin(Vector2i dest) {\n-        return dest.set(minX, minY);\n-    }\n-\n-    /**\n-     * get the maximum block coordinate\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector2i getMax(Vector2i dest) {\n-        return dest.set(maxX, maxY);\n-    }\n-\n-    /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n-     */\n-    public int getMaxX() {\n-        return maxX;\n+    public BlockArea set(Vector2ic min, Vector2ic max) {\n+        return this.set(min.x(), min.y(), max.x(), max.y());\n     }\n \n-    /**\n-     * the maximum coordinate of the second block y\n-     *\n-     * @return the minimum coordinate y\n-     */\n-    public int getMaxY() {\n-        return maxY;\n+    public BlockArea set(BlockAreac other) {\n+        return this.set(other.minX(), other.minY(), other.maxX(), other.maxY());\n     }\n \n-    /**\n-     * the minimum coordinate of the first block x\n-     *\n-     * @return the minimum coordinate x\n-     */\n-    public int getMinX() {\n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector2ic> iterator() {\n+        return new Iterator<Vector2ic>() {\n+            private Vector2i current = null;\n+            private final Vector2i next = getMin(new Vector2i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.y++;\n+                    if (next.y > maxY) {\n+                        next.y = minY;\n+                        next.x++;\n+                    }\n+\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector2ic next() {\n+                if (current == null) {\n+                    current = new Vector2i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n+    // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n         return minX;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     */\n-    public int getMinY() {\n+    @Override\n+    public int minY() {\n         return minY;\n     }\n \n-    /**\n-     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param min the first coordinate of the first block\n-     * @return this\n-     */\n-    @SuppressWarnings(\"checkstyle:HiddenField\")\n+    @Override\n+    public BlockArea minX(int x, BlockArea dest) {\n+        return dest.set(x, minY, maxX, maxY);\n+    }\n+\n+    public BlockArea minX(int x) {\n+        return minX(x, this);\n+    }\n+\n+    @Override\n+    public BlockArea minY(int y, BlockArea dest) {\n+        return dest.set(minX, y, maxX, maxY);\n+    }\n+\n+    public BlockArea minY(int y) {\n+        return minY(y, this);\n+    }\n+\n+    @Override\n+    public BlockArea setMin(int x, int y, BlockArea dest) {\n+        return dest.set(x, y, maxX, maxY);\n+    }\n+\n+    public BlockArea setMin(int x, int y) {\n+        return this.setMin(x, y, this);\n+    }\n+\n     public BlockArea setMin(Vector2ic min) {\n-        return setMin(min.x(), min.y());\n-    }\n-\n-    /**\n-     * sets the minimum block for this {@link BlockRegion}\n-     *\n-     * @param minX the x coordinate of the first block\n-     * @param minY the y coordinate of the first block\n-     * @return this\n-     */\n-    public BlockArea setMin(int minX, int minY) {\n-        Preconditions.checkArgument(minX <= this.maxX ^ this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minY <= this.maxY ^ this.maxY == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        Rectangles.setMin(this.bounds, minX - 0.5f, minY - 0.5f);\n-        return this;\n+        return this.setMin(min.x(), min.y(), this);\n+    }\n+\n+    public BlockArea addToMin(int x, int y) {\n+        return this.addToMin(x, y, this);\n+    }\n+\n+    public BlockArea addToMin(Vector2ic min) {\n+        return this.addToMin(min.x(), min.y(), this);\n+    }\n+\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int maxX() {\n+        return maxX;\n+    }\n+\n+    @Override\n+    public int maxY() {\n+        return maxY;\n+    }\n+\n+    @Override\n+    public BlockArea maxX(int x, BlockArea dest) {\n+        return dest.set(minX, minY, x, maxY);\n+    }\n+\n+    public BlockArea maxX(int x) {\n+        return maxX(x, this);\n+    }\n+\n+    @Override\n+    public BlockArea maxY(int y, BlockArea dest) {\n+        return dest.set(minX, minY, maxX, y);\n+    }\n+\n+    public BlockArea maxY(int y) {\n+        return maxY(y, this);\n+    }\n+\n+    @Override\n+    public BlockArea setMax(int x, int y, BlockArea dest) {\n+        return dest.set(minX, minY, x, y);\n+    }\n+\n+    public BlockArea setMax(int x, int y) {\n+        return this.setMax(x, y, this);\n     }\n \n-    /**\n-     * Sets the maximum coordinate of the second block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param max the second coordinate of the second block\n-     * @return this\n-     */\n     public BlockArea setMax(Vector2ic max) {\n-        return setMax(max.x(), max.y());\n-    }\n-\n-    /**\n-     * sets the maximum block for this {@link BlockRegion}\n-     *\n-     * @param maxX the x coordinate of the first block\n-     * @param maxY the y coordinate of the first block\n-     * @return this\n-     */\n-    @SuppressWarnings(\"checkstyle:HiddenField\")\n-    public BlockArea setMax(int maxX, int maxY) {\n-        Preconditions.checkArgument(maxX >= this.minX ^ this.minX == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxY >= this.minY ^ this.minY == Integer.MAX_VALUE);\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        Rectangles.setMax(this.bounds, maxX + 0.5f, maxY + 0.5f);\n-        return this;\n+        return this.setMax(max.x(), max.y(), this);\n     }\n \n-    /**\n-     * Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n-     *\n-     * @param other {@link BlockRegion}\n-     * @return this\n-     */\n-    public BlockArea union(BlockArea other) {\n-        return union(other.minX, other.minY).union(other.minX, other.maxY);\n+    public BlockArea addToMax(int x, int y) {\n+        return this.addToMax(x, y, this);\n     }\n \n-    /**\n-     * Set <code>this</code> to the union of <code>this</code> and the given block <code>p</code>.\n-     *\n-     * @param p the position of the block\n-     * @return this\n-     */\n-    public BlockArea union(Vector2ic p) {\n-        return union(p.x(), p.y());\n+    public BlockArea addToMax(Vector2ic max) {\n+        return this.addToMax(max.x(), max.y(), this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea setSize(int sizeX, int sizeY, BlockArea dest) {\n+        return dest.set(minX, minY, minX + sizeX, minY + sizeY);\n+    }\n+\n+    public BlockArea setSize(int sizeX, int sizeY) {\n+        return this.setSize(sizeX, sizeY, this);\n+    }\n+\n+    public BlockArea setSize(Vector2ic size) {\n+        return this.setSize(size.x(), size.y(), this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea union(int x, int y, BlockArea dest) {\n+        return dest.set(\n+                Math.min(this.minX, x), Math.min(this.minY, y),\n+                Math.max(this.maxX, x), Math.max(this.maxY, y));\n     }\n \n     public BlockArea union(int x, int y) {\n         return union(x, y, this);\n     }\n \n-    /**\n-     * Compute the union of <code>this</code> and the given block <code>(x, y, z)</code> and stores the result in\n-     * <code>dest</code>\n-     *\n-     * @param x the x coordinate of the block\n-     * @param y the y coordinate of the block\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea union(int x, int y, BlockArea dest) {\n-        return dest\n-                .setMin(Math.min(dest.minX, x), Math.min(dest.minY, y))\n-                .setMax(Math.max(dest.maxX, x), Math.max(dest.maxY, y));\n-    }\n-\n-    /**\n-     * calculate the BlockRegion that is intersected between another region\n-     *\n-     * @param other the other BlockRegion\n-     * @param dest holds the result\n-     * @return dest\n-     */\n-    public BlockArea intersection(BlockArea other, BlockArea dest) {\n-        return dest\n-                .setMin(Math.max(this.minX, other.minX), Math.max(this.minY, other.minY))\n-                .setMax(Math.min(this.maxX, other.maxX), Math.min(this.maxY, other.maxY));\n-    }\n-\n-    /**\n-     * the number of blocks for the +x, +y, +z from the minimum to the maximum\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector2i getSize(Vector2i dest) {\n-        return dest.set(getSizeX(), getSizeY());\n-    }\n-\n-    /**\n-     * The number of blocks on the X axis\n-     *\n-     * @return number of blocks in the X axis\n-     */\n-    public int getSizeX() {\n-        return this.maxX - this.minX;\n-    }\n-\n-    /**\n-     * The number of blocks on the Y axis\n-     *\n-     * @return number of blocks in the Y axis\n-     */\n-    public int getSizeY() {\n-        return this.maxY - this.minY;\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param x the x coordinate to translate by\n-     * @param y the y coordinate to translate by\n-     * @return this\n-     */\n-    public BlockArea translate(int x, int y) {\n-        return translate(x, y, this);\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param xy the vector to translate by\n-     * @return this\n-     */\n-    public BlockArea translate(Vector2ic xy) {\n-        return translate(xy, this);\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param xy the vector to translate by\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea translate(Vector2ic xy, BlockArea dest) {\n-        return translate(xy.x(), xy.y(), dest);\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xy</code>.\n-     *\n-     * @param x the length to translate by along x direction\n-     * @param y the length to translate by along y direction\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea translate(int x, int y, BlockArea dest) {\n-        dest.minX += x;\n-        dest.minY += y;\n-        dest.maxX += x;\n-        dest.maxY += y;\n-        dest.bounds.translate(x, y);\n-        return dest;\n+    public BlockArea union(Vector2ic p) {\n+        return union(p.x(), p.y(), this);\n+    }\n+\n+    public BlockArea union(BlockArea other) {\n+        return union(other, this);\n     }\n \n-    /**\n-     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param pos the coordinates of the block\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsBlock(Vector2ic pos) {\n-        return containsBlock(pos.x(), pos.y());\n-    }\n-\n-    /**\n-     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsBlock(int x, int y) {\n-        return x >= minX && y >= minY && x <= maxX && y <= maxY;\n-    }\n-\n-    /**\n-     * WORLD-COORDINATES\n-     * Test whether the point <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this BlockRegion; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(float x, float y) {\n-        return getWorldArea().containsPoint(x, y);\n-    }\n-\n-    /**\n-     * @see #containsPoint(float, float)\n-     */\n-    public boolean containsPoint(Vector2fc point) {\n-        return this.containsPoint(point.x(), point.y());\n-    }\n-\n-    /**\n-     * Test whether the point <code>(x, y, z)</code> lies inside this AABB.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(int x, int y) {\n-        return containsBlock(x, y);\n-    }\n-\n-    /**\n-     * Test whether the given point lies inside this AABB.\n-     *\n-     * @param point the coordinates of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(Vector2ic point) {\n-        return containsPoint(point.x(), point.y());\n-    }\n-\n-    /**\n-     * Test whether the given {@link BlockArea}  lies inside the {@link BlockArea}\n-     *\n-     * @param area the area to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockArea}; <code>false</code> otherwise\n-     */\n-    public boolean containsArea(BlockArea area) {\n-        return this.containsBlock(area.minX, area.minY) && this.containsBlock(area.maxX, area.maxY);\n-    }\n-\n-    /**\n-     * Test whether <code>this</code> and <code>other</code> intersect.\n-     *\n-     * @param other the other BlockRegion\n-     * @return <code>true</code> iff both AABBs intersect; <code>false</code> otherwise\n-     */\n-    public boolean intersectsArea(BlockArea other) {\n-        return this.minX <= other.maxX && this.maxX >= other.minX && this.maxY >= other.minY && this.minY <= other.maxY;\n-    }\n-\n-    /**\n-     * Adds extend for each face of a BlockRegion.\n-     *\n-     * @param extent extents to grow each face\n-     * @param dest holds the result\n-     * @return dest\n-     */\n-    public BlockArea addExtents(int extent, BlockArea dest) {\n-        return addExtents(extent, extent, dest);\n-    }\n-\n-    /**\n-     * Adds extend for each face of a BlockRegion.\n-     *\n-     * @param extentX the x coordinate to grow the extents\n-     * @param extentY the y coordinate to grow the extents\n-     * @return this\n-     */\n-    public BlockArea addExtents(int extentX, int extentY) {\n-        return addExtents(extentX, extentY, this);\n-    }\n-\n-    /**\n-     * Adds extend for each face of a BlockRegion\n-     *\n-     * @param extentX the x coordinate to grow the extents\n-     * @param extentY the y coordinate to grow the extents\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea addExtents(int extentX, int extentY, BlockArea dest) {\n-        Preconditions.checkArgument(dest.getSizeX() + 2 * extentX >= 0 && dest.getSizeY() + 2 * extentY >= 0);\n-        dest.minX -= extentX;\n-        dest.minY -= extentY;\n-        dest.maxX += extentX;\n-        dest.maxY += extentY;\n-        Rectangles.expand(this.bounds, extentX, extentY);\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Optional<BlockArea> intersect(BlockAreac other, BlockArea dest) {\n+        dest.minX = Math.max(minX, other.minX());\n+        dest.minY = Math.max(minY, other.minY());\n+\n+        dest.maxX = Math.min(maxX, other.maxX());\n+        dest.maxY = Math.min(maxY, other.maxY());\n+\n+        if (dest.isValid()) {\n+            return Optional.of(dest);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public Optional<BlockArea> intersect(BlockAreac other) {\n+        return this.intersect(other, this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea translate(int dx, int dy, BlockArea dest) {\n+        dest.minX = minX + dx;\n+        dest.minY = minY + dy;\n+        dest.maxX = maxX + dx;\n+        dest.maxY = maxY + dy;\n         return dest;\n     }\n \n+    public BlockArea translate(int dx, int dy) {\n+        return translate(dx, dy, this);\n+    }\n+\n+    public BlockArea translate(Vector2ic dv) {\n+        return translate(dv.x(), dv.y(), this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea expand(int dx, int dy, BlockArea dest) {\n+        return dest.set(minX - dx, minY - dy, maxX + dx, maxY + dy);\n+    }\n \n-    /**\n-     * Test whether the given {@link Rectanglef}  lies inside the {@link BlockArea}\n-     *\n-     * @param rect the rectangle to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockArea}; <code>false</code> otherwise\n-     */\n-    public boolean containsRectangle(Rectanglef rect) {\n-        return getWorldArea().containsRectangle(rect);\n+    public BlockArea expand(int dx, int dy) {\n+        return expand(dx, dy, this);\n     }\n \n-    /**\n-     * Test whether the given {@link Rectangled}  lies inside the {@link BlockArea}\n-     *\n-     * @param rect the rectangle to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockArea}; <code>false</code> otherwise\n-     */\n-    public boolean containsRectangle(Rectangled rect) {\n-        return getWorldArea().containsRectangle(rect);\n+    public BlockArea expand(Vector2ic dv) {\n+        return expand(dv.x(), dv.y(), this);\n     }\n \n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2MzI2Mw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4050#discussion_r542063263", "bodyText": "for the size you need to add 1.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return this.maxX - this.minX;\n          \n          \n            \n                    return this.maxX - this.minX + 1;", "author": "pollend", "createdAt": "2020-12-14T02:01:56Z", "path": "engine/src/main/java/org/terasology/world/block/BlockArea.java", "diffHunk": "@@ -0,0 +1,508 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.block;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import org.joml.Math;\n+import org.joml.Rectangled;\n+import org.joml.Rectanglef;\n+import org.joml.Vector2fc;\n+import org.joml.Vector2i;\n+import org.joml.Vector2ic;\n+\n+/**\n+ * A bounded axis-aligned rectangle of blocks.\n+ * <p>\n+ * A block area is described and backed by an {@link org.joml.Rectanglei}\n+ *\n+ * @see BlockAreas\n+ */\n+public class BlockArea {\n+    private int minX = Integer.MAX_VALUE;\n+    private int minY = Integer.MAX_VALUE;\n+    private int maxX = Integer.MIN_VALUE;\n+    private int maxY = Integer.MIN_VALUE;\n+\n+    private Rectanglef bounds = new Rectanglef();\n+\n+    public BlockArea() {\n+    }\n+\n+    /**\n+     * @return a copy of this block area\n+     */\n+    public BlockArea copy() {\n+        return new BlockArea().set(this);\n+    }\n+\n+    public boolean isValid() {\n+        return minX <= maxX && minY <= maxY;\n+    }\n+\n+    public boolean isEmpty() {\n+        return !isValid();\n+    }\n+\n+    public BlockArea set(BlockArea other) {\n+        this.minX = other.minX;\n+        this.minY = other.minY;\n+        this.maxX = other.maxX;\n+        this.maxY = other.maxY;\n+\n+        Rectangles.set(this.bounds, other.bounds);\n+        return this;\n+    }\n+\n+    /**\n+     * get the minimum block coordinate\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector2i getMin(Vector2i dest) {\n+        return dest.set(minX, minY);\n+    }\n+\n+    /**\n+     * get the maximum block coordinate\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector2i getMax(Vector2i dest) {\n+        return dest.set(maxX, maxY);\n+    }\n+\n+    /**\n+     * the maximum coordinate of the second block x\n+     *\n+     * @return the minimum coordinate x\n+     */\n+    public int getMaxX() {\n+        return maxX;\n+    }\n+\n+    /**\n+     * the maximum coordinate of the second block y\n+     *\n+     * @return the minimum coordinate y\n+     */\n+    public int getMaxY() {\n+        return maxY;\n+    }\n+\n+    /**\n+     * the minimum coordinate of the first block x\n+     *\n+     * @return the minimum coordinate x\n+     */\n+    public int getMinX() {\n+        return minX;\n+    }\n+\n+    /**\n+     * the minimum coordinate of the first block y\n+     *\n+     * @return the minimum coordinate y\n+     */\n+    public int getMinY() {\n+        return minY;\n+    }\n+\n+    /**\n+     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n+     *\n+     * @param min the first coordinate of the first block\n+     * @return this\n+     */\n+    @SuppressWarnings(\"checkstyle:HiddenField\")\n+    public BlockArea setMin(Vector2ic min) {\n+        return setMin(min.x(), min.y());\n+    }\n+\n+    /**\n+     * sets the minimum block for this {@link BlockRegion}\n+     *\n+     * @param minX the x coordinate of the first block\n+     * @param minY the y coordinate of the first block\n+     * @return this\n+     */\n+    public BlockArea setMin(int minX, int minY) {\n+        Preconditions.checkArgument(minX <= this.maxX ^ this.maxX == Integer.MIN_VALUE);\n+        Preconditions.checkArgument(minY <= this.maxY ^ this.maxY == Integer.MIN_VALUE);\n+        this.minX = minX;\n+        this.minY = minY;\n+        Rectangles.setMin(this.bounds, minX - 0.5f, minY - 0.5f);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the maximum coordinate of the second block for <code>this</code> {@link BlockRegion}\n+     *\n+     * @param max the second coordinate of the second block\n+     * @return this\n+     */\n+    public BlockArea setMax(Vector2ic max) {\n+        return setMax(max.x(), max.y());\n+    }\n+\n+    /**\n+     * sets the maximum block for this {@link BlockRegion}\n+     *\n+     * @param maxX the x coordinate of the first block\n+     * @param maxY the y coordinate of the first block\n+     * @return this\n+     */\n+    @SuppressWarnings(\"checkstyle:HiddenField\")\n+    public BlockArea setMax(int maxX, int maxY) {\n+        Preconditions.checkArgument(maxX >= this.minX ^ this.minX == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(maxY >= this.minY ^ this.minY == Integer.MAX_VALUE);\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        Rectangles.setMax(this.bounds, maxX + 0.5f, maxY + 0.5f);\n+        return this;\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n+     *\n+     * @param other {@link BlockRegion}\n+     * @return this\n+     */\n+    public BlockArea union(BlockArea other) {\n+        return union(other.minX, other.minY).union(other.minX, other.maxY);\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and the given block <code>p</code>.\n+     *\n+     * @param p the position of the block\n+     * @return this\n+     */\n+    public BlockArea union(Vector2ic p) {\n+        return union(p.x(), p.y());\n+    }\n+\n+    public BlockArea union(int x, int y) {\n+        return union(x, y, this);\n+    }\n+\n+    /**\n+     * Compute the union of <code>this</code> and the given block <code>(x, y, z)</code> and stores the result in\n+     * <code>dest</code>\n+     *\n+     * @param x the x coordinate of the block\n+     * @param y the y coordinate of the block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockArea union(int x, int y, BlockArea dest) {\n+        return dest\n+                .setMin(Math.min(dest.minX, x), Math.min(dest.minY, y))\n+                .setMax(Math.max(dest.maxX, x), Math.max(dest.maxY, y));\n+    }\n+\n+    /**\n+     * calculate the BlockRegion that is intersected between another region\n+     *\n+     * @param other the other BlockRegion\n+     * @param dest holds the result\n+     * @return dest\n+     */\n+    public BlockArea intersection(BlockArea other, BlockArea dest) {\n+        return dest\n+                .setMin(Math.max(this.minX, other.minX), Math.max(this.minY, other.minY))\n+                .setMax(Math.min(this.maxX, other.maxX), Math.min(this.maxY, other.maxY));\n+    }\n+\n+    /**\n+     * the number of blocks for the +x, +y, +z from the minimum to the maximum\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector2i getSize(Vector2i dest) {\n+        return dest.set(getSizeX(), getSizeY());\n+    }\n+\n+    /**\n+     * The number of blocks on the X axis\n+     *\n+     * @return number of blocks in the X axis\n+     */\n+    public int getSizeX() {\n+        return this.maxX - this.minX;", "originalCommit": "ae58d1527d3b9be34de1fc947b5576b07b50cc54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "430c9caa56062556ea548afe315d65a183661f8e", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockArea.java b/engine/src/main/java/org/terasology/world/block/BlockArea.java\nindex f5ee7971d..02ab966c4 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockArea.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockArea.java\n\n@@ -6,436 +6,322 @@\n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import org.joml.Math;\n-import org.joml.Rectangled;\n-import org.joml.Rectanglef;\n-import org.joml.Vector2fc;\n import org.joml.Vector2i;\n import org.joml.Vector2ic;\n \n+import java.util.Iterator;\n+import java.util.Optional;\n+\n /**\n- * A bounded axis-aligned rectangle of blocks.\n- * <p>\n- * A block area is described and backed by an {@link org.joml.Rectanglei}\n- *\n- * @see BlockAreas\n+ * A mutable, bounded, axis-aligned are denoting a collection of blocks contained within.\n  */\n-public class BlockArea {\n+public class BlockArea implements BlockAreac {\n+\n+    public static final BlockAreac INVALID = new BlockArea();\n+\n     private int minX = Integer.MAX_VALUE;\n     private int minY = Integer.MAX_VALUE;\n     private int maxX = Integer.MIN_VALUE;\n     private int maxY = Integer.MIN_VALUE;\n \n-    private Rectanglef bounds = new Rectanglef();\n+    // -- CONSTRUCTORS -----------------------------------------------------------------------------------------------//\n+\n+    BlockArea() {\n+    }\n+\n+    public BlockArea(int minX, int minY, int maxX, int maxY) {\n+        this.set(minX, minY, maxX, maxY);\n+    }\n \n-    public BlockArea() {\n+    public BlockArea(Vector2ic min, Vector2ic max) {\n+        this.set(min.x(), min.y(), max.x(), max.y());\n     }\n \n-    /**\n-     * @return a copy of this block area\n-     */\n-    public BlockArea copy() {\n-        return new BlockArea().set(this);\n+    public BlockArea(int x, int y) {\n+        this.set(x, y, x, y);\n     }\n \n-    public boolean isValid() {\n-        return minX <= maxX && minY <= maxY;\n+    public BlockArea(Vector2ic pos) {\n+        this.set(pos, pos);\n     }\n \n-    public boolean isEmpty() {\n-        return !isValid();\n+    public BlockArea(BlockAreac other) {\n+        this.set(other.minX(), other.minY(), other.maxX(), other.maxY());\n     }\n \n-    public BlockArea set(BlockArea other) {\n-        this.minX = other.minX;\n-        this.minY = other.minY;\n-        this.maxX = other.maxX;\n-        this.maxY = other.maxY;\n+    // -- reset ------------------------------------------------------------------------------------------------------//\n+\n+    public BlockArea set(int minX, int minY, int maxX, int maxY) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n \n-        Rectangles.set(this.bounds, other.bounds);\n         return this;\n     }\n \n-    /**\n-     * get the minimum block coordinate\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector2i getMin(Vector2i dest) {\n-        return dest.set(minX, minY);\n-    }\n-\n-    /**\n-     * get the maximum block coordinate\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector2i getMax(Vector2i dest) {\n-        return dest.set(maxX, maxY);\n-    }\n-\n-    /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n-     */\n-    public int getMaxX() {\n-        return maxX;\n+    public BlockArea set(Vector2ic min, Vector2ic max) {\n+        return this.set(min.x(), min.y(), max.x(), max.y());\n     }\n \n-    /**\n-     * the maximum coordinate of the second block y\n-     *\n-     * @return the minimum coordinate y\n-     */\n-    public int getMaxY() {\n-        return maxY;\n+    public BlockArea set(BlockAreac other) {\n+        return this.set(other.minX(), other.minY(), other.maxX(), other.maxY());\n     }\n \n-    /**\n-     * the minimum coordinate of the first block x\n-     *\n-     * @return the minimum coordinate x\n-     */\n-    public int getMinX() {\n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector2ic> iterator() {\n+        return new Iterator<Vector2ic>() {\n+            private Vector2i current = null;\n+            private final Vector2i next = getMin(new Vector2i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.y++;\n+                    if (next.y > maxY) {\n+                        next.y = minY;\n+                        next.x++;\n+                    }\n+\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector2ic next() {\n+                if (current == null) {\n+                    current = new Vector2i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n+    // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n         return minX;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     */\n-    public int getMinY() {\n+    @Override\n+    public int minY() {\n         return minY;\n     }\n \n-    /**\n-     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param min the first coordinate of the first block\n-     * @return this\n-     */\n-    @SuppressWarnings(\"checkstyle:HiddenField\")\n+    @Override\n+    public BlockArea minX(int x, BlockArea dest) {\n+        return dest.set(x, minY, maxX, maxY);\n+    }\n+\n+    public BlockArea minX(int x) {\n+        return minX(x, this);\n+    }\n+\n+    @Override\n+    public BlockArea minY(int y, BlockArea dest) {\n+        return dest.set(minX, y, maxX, maxY);\n+    }\n+\n+    public BlockArea minY(int y) {\n+        return minY(y, this);\n+    }\n+\n+    @Override\n+    public BlockArea setMin(int x, int y, BlockArea dest) {\n+        return dest.set(x, y, maxX, maxY);\n+    }\n+\n+    public BlockArea setMin(int x, int y) {\n+        return this.setMin(x, y, this);\n+    }\n+\n     public BlockArea setMin(Vector2ic min) {\n-        return setMin(min.x(), min.y());\n-    }\n-\n-    /**\n-     * sets the minimum block for this {@link BlockRegion}\n-     *\n-     * @param minX the x coordinate of the first block\n-     * @param minY the y coordinate of the first block\n-     * @return this\n-     */\n-    public BlockArea setMin(int minX, int minY) {\n-        Preconditions.checkArgument(minX <= this.maxX ^ this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minY <= this.maxY ^ this.maxY == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        Rectangles.setMin(this.bounds, minX - 0.5f, minY - 0.5f);\n-        return this;\n+        return this.setMin(min.x(), min.y(), this);\n+    }\n+\n+    public BlockArea addToMin(int x, int y) {\n+        return this.addToMin(x, y, this);\n+    }\n+\n+    public BlockArea addToMin(Vector2ic min) {\n+        return this.addToMin(min.x(), min.y(), this);\n+    }\n+\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int maxX() {\n+        return maxX;\n+    }\n+\n+    @Override\n+    public int maxY() {\n+        return maxY;\n+    }\n+\n+    @Override\n+    public BlockArea maxX(int x, BlockArea dest) {\n+        return dest.set(minX, minY, x, maxY);\n+    }\n+\n+    public BlockArea maxX(int x) {\n+        return maxX(x, this);\n+    }\n+\n+    @Override\n+    public BlockArea maxY(int y, BlockArea dest) {\n+        return dest.set(minX, minY, maxX, y);\n+    }\n+\n+    public BlockArea maxY(int y) {\n+        return maxY(y, this);\n+    }\n+\n+    @Override\n+    public BlockArea setMax(int x, int y, BlockArea dest) {\n+        return dest.set(minX, minY, x, y);\n+    }\n+\n+    public BlockArea setMax(int x, int y) {\n+        return this.setMax(x, y, this);\n     }\n \n-    /**\n-     * Sets the maximum coordinate of the second block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param max the second coordinate of the second block\n-     * @return this\n-     */\n     public BlockArea setMax(Vector2ic max) {\n-        return setMax(max.x(), max.y());\n-    }\n-\n-    /**\n-     * sets the maximum block for this {@link BlockRegion}\n-     *\n-     * @param maxX the x coordinate of the first block\n-     * @param maxY the y coordinate of the first block\n-     * @return this\n-     */\n-    @SuppressWarnings(\"checkstyle:HiddenField\")\n-    public BlockArea setMax(int maxX, int maxY) {\n-        Preconditions.checkArgument(maxX >= this.minX ^ this.minX == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxY >= this.minY ^ this.minY == Integer.MAX_VALUE);\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        Rectangles.setMax(this.bounds, maxX + 0.5f, maxY + 0.5f);\n-        return this;\n+        return this.setMax(max.x(), max.y(), this);\n     }\n \n-    /**\n-     * Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n-     *\n-     * @param other {@link BlockRegion}\n-     * @return this\n-     */\n-    public BlockArea union(BlockArea other) {\n-        return union(other.minX, other.minY).union(other.minX, other.maxY);\n+    public BlockArea addToMax(int x, int y) {\n+        return this.addToMax(x, y, this);\n     }\n \n-    /**\n-     * Set <code>this</code> to the union of <code>this</code> and the given block <code>p</code>.\n-     *\n-     * @param p the position of the block\n-     * @return this\n-     */\n-    public BlockArea union(Vector2ic p) {\n-        return union(p.x(), p.y());\n+    public BlockArea addToMax(Vector2ic max) {\n+        return this.addToMax(max.x(), max.y(), this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea setSize(int sizeX, int sizeY, BlockArea dest) {\n+        return dest.set(minX, minY, minX + sizeX, minY + sizeY);\n+    }\n+\n+    public BlockArea setSize(int sizeX, int sizeY) {\n+        return this.setSize(sizeX, sizeY, this);\n+    }\n+\n+    public BlockArea setSize(Vector2ic size) {\n+        return this.setSize(size.x(), size.y(), this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea union(int x, int y, BlockArea dest) {\n+        return dest.set(\n+                Math.min(this.minX, x), Math.min(this.minY, y),\n+                Math.max(this.maxX, x), Math.max(this.maxY, y));\n     }\n \n     public BlockArea union(int x, int y) {\n         return union(x, y, this);\n     }\n \n-    /**\n-     * Compute the union of <code>this</code> and the given block <code>(x, y, z)</code> and stores the result in\n-     * <code>dest</code>\n-     *\n-     * @param x the x coordinate of the block\n-     * @param y the y coordinate of the block\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea union(int x, int y, BlockArea dest) {\n-        return dest\n-                .setMin(Math.min(dest.minX, x), Math.min(dest.minY, y))\n-                .setMax(Math.max(dest.maxX, x), Math.max(dest.maxY, y));\n-    }\n-\n-    /**\n-     * calculate the BlockRegion that is intersected between another region\n-     *\n-     * @param other the other BlockRegion\n-     * @param dest holds the result\n-     * @return dest\n-     */\n-    public BlockArea intersection(BlockArea other, BlockArea dest) {\n-        return dest\n-                .setMin(Math.max(this.minX, other.minX), Math.max(this.minY, other.minY))\n-                .setMax(Math.min(this.maxX, other.maxX), Math.min(this.maxY, other.maxY));\n-    }\n-\n-    /**\n-     * the number of blocks for the +x, +y, +z from the minimum to the maximum\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector2i getSize(Vector2i dest) {\n-        return dest.set(getSizeX(), getSizeY());\n-    }\n-\n-    /**\n-     * The number of blocks on the X axis\n-     *\n-     * @return number of blocks in the X axis\n-     */\n-    public int getSizeX() {\n-        return this.maxX - this.minX;\n-    }\n-\n-    /**\n-     * The number of blocks on the Y axis\n-     *\n-     * @return number of blocks in the Y axis\n-     */\n-    public int getSizeY() {\n-        return this.maxY - this.minY;\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param x the x coordinate to translate by\n-     * @param y the y coordinate to translate by\n-     * @return this\n-     */\n-    public BlockArea translate(int x, int y) {\n-        return translate(x, y, this);\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param xy the vector to translate by\n-     * @return this\n-     */\n-    public BlockArea translate(Vector2ic xy) {\n-        return translate(xy, this);\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param xy the vector to translate by\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea translate(Vector2ic xy, BlockArea dest) {\n-        return translate(xy.x(), xy.y(), dest);\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xy</code>.\n-     *\n-     * @param x the length to translate by along x direction\n-     * @param y the length to translate by along y direction\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea translate(int x, int y, BlockArea dest) {\n-        dest.minX += x;\n-        dest.minY += y;\n-        dest.maxX += x;\n-        dest.maxY += y;\n-        dest.bounds.translate(x, y);\n-        return dest;\n+    public BlockArea union(Vector2ic p) {\n+        return union(p.x(), p.y(), this);\n+    }\n+\n+    public BlockArea union(BlockArea other) {\n+        return union(other, this);\n     }\n \n-    /**\n-     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param pos the coordinates of the block\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsBlock(Vector2ic pos) {\n-        return containsBlock(pos.x(), pos.y());\n-    }\n-\n-    /**\n-     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsBlock(int x, int y) {\n-        return x >= minX && y >= minY && x <= maxX && y <= maxY;\n-    }\n-\n-    /**\n-     * WORLD-COORDINATES\n-     * Test whether the point <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this BlockRegion; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(float x, float y) {\n-        return getWorldArea().containsPoint(x, y);\n-    }\n-\n-    /**\n-     * @see #containsPoint(float, float)\n-     */\n-    public boolean containsPoint(Vector2fc point) {\n-        return this.containsPoint(point.x(), point.y());\n-    }\n-\n-    /**\n-     * Test whether the point <code>(x, y, z)</code> lies inside this AABB.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(int x, int y) {\n-        return containsBlock(x, y);\n-    }\n-\n-    /**\n-     * Test whether the given point lies inside this AABB.\n-     *\n-     * @param point the coordinates of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(Vector2ic point) {\n-        return containsPoint(point.x(), point.y());\n-    }\n-\n-    /**\n-     * Test whether the given {@link BlockArea}  lies inside the {@link BlockArea}\n-     *\n-     * @param area the area to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockArea}; <code>false</code> otherwise\n-     */\n-    public boolean containsArea(BlockArea area) {\n-        return this.containsBlock(area.minX, area.minY) && this.containsBlock(area.maxX, area.maxY);\n-    }\n-\n-    /**\n-     * Test whether <code>this</code> and <code>other</code> intersect.\n-     *\n-     * @param other the other BlockRegion\n-     * @return <code>true</code> iff both AABBs intersect; <code>false</code> otherwise\n-     */\n-    public boolean intersectsArea(BlockArea other) {\n-        return this.minX <= other.maxX && this.maxX >= other.minX && this.maxY >= other.minY && this.minY <= other.maxY;\n-    }\n-\n-    /**\n-     * Adds extend for each face of a BlockRegion.\n-     *\n-     * @param extent extents to grow each face\n-     * @param dest holds the result\n-     * @return dest\n-     */\n-    public BlockArea addExtents(int extent, BlockArea dest) {\n-        return addExtents(extent, extent, dest);\n-    }\n-\n-    /**\n-     * Adds extend for each face of a BlockRegion.\n-     *\n-     * @param extentX the x coordinate to grow the extents\n-     * @param extentY the y coordinate to grow the extents\n-     * @return this\n-     */\n-    public BlockArea addExtents(int extentX, int extentY) {\n-        return addExtents(extentX, extentY, this);\n-    }\n-\n-    /**\n-     * Adds extend for each face of a BlockRegion\n-     *\n-     * @param extentX the x coordinate to grow the extents\n-     * @param extentY the y coordinate to grow the extents\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea addExtents(int extentX, int extentY, BlockArea dest) {\n-        Preconditions.checkArgument(dest.getSizeX() + 2 * extentX >= 0 && dest.getSizeY() + 2 * extentY >= 0);\n-        dest.minX -= extentX;\n-        dest.minY -= extentY;\n-        dest.maxX += extentX;\n-        dest.maxY += extentY;\n-        Rectangles.expand(this.bounds, extentX, extentY);\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Optional<BlockArea> intersect(BlockAreac other, BlockArea dest) {\n+        dest.minX = Math.max(minX, other.minX());\n+        dest.minY = Math.max(minY, other.minY());\n+\n+        dest.maxX = Math.min(maxX, other.maxX());\n+        dest.maxY = Math.min(maxY, other.maxY());\n+\n+        if (dest.isValid()) {\n+            return Optional.of(dest);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public Optional<BlockArea> intersect(BlockAreac other) {\n+        return this.intersect(other, this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea translate(int dx, int dy, BlockArea dest) {\n+        dest.minX = minX + dx;\n+        dest.minY = minY + dy;\n+        dest.maxX = maxX + dx;\n+        dest.maxY = maxY + dy;\n         return dest;\n     }\n \n+    public BlockArea translate(int dx, int dy) {\n+        return translate(dx, dy, this);\n+    }\n+\n+    public BlockArea translate(Vector2ic dv) {\n+        return translate(dv.x(), dv.y(), this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea expand(int dx, int dy, BlockArea dest) {\n+        return dest.set(minX - dx, minY - dy, maxX + dx, maxY + dy);\n+    }\n \n-    /**\n-     * Test whether the given {@link Rectanglef}  lies inside the {@link BlockArea}\n-     *\n-     * @param rect the rectangle to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockArea}; <code>false</code> otherwise\n-     */\n-    public boolean containsRectangle(Rectanglef rect) {\n-        return getWorldArea().containsRectangle(rect);\n+    public BlockArea expand(int dx, int dy) {\n+        return expand(dx, dy, this);\n     }\n \n-    /**\n-     * Test whether the given {@link Rectangled}  lies inside the {@link BlockArea}\n-     *\n-     * @param rect the rectangle to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockArea}; <code>false</code> otherwise\n-     */\n-    public boolean containsRectangle(Rectangled rect) {\n-        return getWorldArea().containsRectangle(rect);\n+    public BlockArea expand(Vector2ic dv) {\n+        return expand(dv.x(), dv.y(), this);\n     }\n \n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2MzQzMw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4050#discussion_r542063433", "bodyText": "you need to add 1 for the size so its consistent with BlockRegion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return this.maxY - this.minY;\n          \n          \n            \n                    return this.maxY - this.minY + 1;", "author": "pollend", "createdAt": "2020-12-14T02:02:28Z", "path": "engine/src/main/java/org/terasology/world/block/BlockArea.java", "diffHunk": "@@ -0,0 +1,508 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.block;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import org.joml.Math;\n+import org.joml.Rectangled;\n+import org.joml.Rectanglef;\n+import org.joml.Vector2fc;\n+import org.joml.Vector2i;\n+import org.joml.Vector2ic;\n+\n+/**\n+ * A bounded axis-aligned rectangle of blocks.\n+ * <p>\n+ * A block area is described and backed by an {@link org.joml.Rectanglei}\n+ *\n+ * @see BlockAreas\n+ */\n+public class BlockArea {\n+    private int minX = Integer.MAX_VALUE;\n+    private int minY = Integer.MAX_VALUE;\n+    private int maxX = Integer.MIN_VALUE;\n+    private int maxY = Integer.MIN_VALUE;\n+\n+    private Rectanglef bounds = new Rectanglef();\n+\n+    public BlockArea() {\n+    }\n+\n+    /**\n+     * @return a copy of this block area\n+     */\n+    public BlockArea copy() {\n+        return new BlockArea().set(this);\n+    }\n+\n+    public boolean isValid() {\n+        return minX <= maxX && minY <= maxY;\n+    }\n+\n+    public boolean isEmpty() {\n+        return !isValid();\n+    }\n+\n+    public BlockArea set(BlockArea other) {\n+        this.minX = other.minX;\n+        this.minY = other.minY;\n+        this.maxX = other.maxX;\n+        this.maxY = other.maxY;\n+\n+        Rectangles.set(this.bounds, other.bounds);\n+        return this;\n+    }\n+\n+    /**\n+     * get the minimum block coordinate\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector2i getMin(Vector2i dest) {\n+        return dest.set(minX, minY);\n+    }\n+\n+    /**\n+     * get the maximum block coordinate\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector2i getMax(Vector2i dest) {\n+        return dest.set(maxX, maxY);\n+    }\n+\n+    /**\n+     * the maximum coordinate of the second block x\n+     *\n+     * @return the minimum coordinate x\n+     */\n+    public int getMaxX() {\n+        return maxX;\n+    }\n+\n+    /**\n+     * the maximum coordinate of the second block y\n+     *\n+     * @return the minimum coordinate y\n+     */\n+    public int getMaxY() {\n+        return maxY;\n+    }\n+\n+    /**\n+     * the minimum coordinate of the first block x\n+     *\n+     * @return the minimum coordinate x\n+     */\n+    public int getMinX() {\n+        return minX;\n+    }\n+\n+    /**\n+     * the minimum coordinate of the first block y\n+     *\n+     * @return the minimum coordinate y\n+     */\n+    public int getMinY() {\n+        return minY;\n+    }\n+\n+    /**\n+     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n+     *\n+     * @param min the first coordinate of the first block\n+     * @return this\n+     */\n+    @SuppressWarnings(\"checkstyle:HiddenField\")\n+    public BlockArea setMin(Vector2ic min) {\n+        return setMin(min.x(), min.y());\n+    }\n+\n+    /**\n+     * sets the minimum block for this {@link BlockRegion}\n+     *\n+     * @param minX the x coordinate of the first block\n+     * @param minY the y coordinate of the first block\n+     * @return this\n+     */\n+    public BlockArea setMin(int minX, int minY) {\n+        Preconditions.checkArgument(minX <= this.maxX ^ this.maxX == Integer.MIN_VALUE);\n+        Preconditions.checkArgument(minY <= this.maxY ^ this.maxY == Integer.MIN_VALUE);\n+        this.minX = minX;\n+        this.minY = minY;\n+        Rectangles.setMin(this.bounds, minX - 0.5f, minY - 0.5f);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the maximum coordinate of the second block for <code>this</code> {@link BlockRegion}\n+     *\n+     * @param max the second coordinate of the second block\n+     * @return this\n+     */\n+    public BlockArea setMax(Vector2ic max) {\n+        return setMax(max.x(), max.y());\n+    }\n+\n+    /**\n+     * sets the maximum block for this {@link BlockRegion}\n+     *\n+     * @param maxX the x coordinate of the first block\n+     * @param maxY the y coordinate of the first block\n+     * @return this\n+     */\n+    @SuppressWarnings(\"checkstyle:HiddenField\")\n+    public BlockArea setMax(int maxX, int maxY) {\n+        Preconditions.checkArgument(maxX >= this.minX ^ this.minX == Integer.MAX_VALUE);\n+        Preconditions.checkArgument(maxY >= this.minY ^ this.minY == Integer.MAX_VALUE);\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n+        Rectangles.setMax(this.bounds, maxX + 0.5f, maxY + 0.5f);\n+        return this;\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n+     *\n+     * @param other {@link BlockRegion}\n+     * @return this\n+     */\n+    public BlockArea union(BlockArea other) {\n+        return union(other.minX, other.minY).union(other.minX, other.maxY);\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and the given block <code>p</code>.\n+     *\n+     * @param p the position of the block\n+     * @return this\n+     */\n+    public BlockArea union(Vector2ic p) {\n+        return union(p.x(), p.y());\n+    }\n+\n+    public BlockArea union(int x, int y) {\n+        return union(x, y, this);\n+    }\n+\n+    /**\n+     * Compute the union of <code>this</code> and the given block <code>(x, y, z)</code> and stores the result in\n+     * <code>dest</code>\n+     *\n+     * @param x the x coordinate of the block\n+     * @param y the y coordinate of the block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockArea union(int x, int y, BlockArea dest) {\n+        return dest\n+                .setMin(Math.min(dest.minX, x), Math.min(dest.minY, y))\n+                .setMax(Math.max(dest.maxX, x), Math.max(dest.maxY, y));\n+    }\n+\n+    /**\n+     * calculate the BlockRegion that is intersected between another region\n+     *\n+     * @param other the other BlockRegion\n+     * @param dest holds the result\n+     * @return dest\n+     */\n+    public BlockArea intersection(BlockArea other, BlockArea dest) {\n+        return dest\n+                .setMin(Math.max(this.minX, other.minX), Math.max(this.minY, other.minY))\n+                .setMax(Math.min(this.maxX, other.maxX), Math.min(this.maxY, other.maxY));\n+    }\n+\n+    /**\n+     * the number of blocks for the +x, +y, +z from the minimum to the maximum\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector2i getSize(Vector2i dest) {\n+        return dest.set(getSizeX(), getSizeY());\n+    }\n+\n+    /**\n+     * The number of blocks on the X axis\n+     *\n+     * @return number of blocks in the X axis\n+     */\n+    public int getSizeX() {\n+        return this.maxX - this.minX;\n+    }\n+\n+    /**\n+     * The number of blocks on the Y axis\n+     *\n+     * @return number of blocks in the Y axis\n+     */\n+    public int getSizeY() {\n+        return this.maxY - this.minY;", "originalCommit": "ae58d1527d3b9be34de1fc947b5576b07b50cc54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "430c9caa56062556ea548afe315d65a183661f8e", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockArea.java b/engine/src/main/java/org/terasology/world/block/BlockArea.java\nindex f5ee7971d..02ab966c4 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockArea.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockArea.java\n\n@@ -6,436 +6,322 @@\n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import org.joml.Math;\n-import org.joml.Rectangled;\n-import org.joml.Rectanglef;\n-import org.joml.Vector2fc;\n import org.joml.Vector2i;\n import org.joml.Vector2ic;\n \n+import java.util.Iterator;\n+import java.util.Optional;\n+\n /**\n- * A bounded axis-aligned rectangle of blocks.\n- * <p>\n- * A block area is described and backed by an {@link org.joml.Rectanglei}\n- *\n- * @see BlockAreas\n+ * A mutable, bounded, axis-aligned are denoting a collection of blocks contained within.\n  */\n-public class BlockArea {\n+public class BlockArea implements BlockAreac {\n+\n+    public static final BlockAreac INVALID = new BlockArea();\n+\n     private int minX = Integer.MAX_VALUE;\n     private int minY = Integer.MAX_VALUE;\n     private int maxX = Integer.MIN_VALUE;\n     private int maxY = Integer.MIN_VALUE;\n \n-    private Rectanglef bounds = new Rectanglef();\n+    // -- CONSTRUCTORS -----------------------------------------------------------------------------------------------//\n+\n+    BlockArea() {\n+    }\n+\n+    public BlockArea(int minX, int minY, int maxX, int maxY) {\n+        this.set(minX, minY, maxX, maxY);\n+    }\n \n-    public BlockArea() {\n+    public BlockArea(Vector2ic min, Vector2ic max) {\n+        this.set(min.x(), min.y(), max.x(), max.y());\n     }\n \n-    /**\n-     * @return a copy of this block area\n-     */\n-    public BlockArea copy() {\n-        return new BlockArea().set(this);\n+    public BlockArea(int x, int y) {\n+        this.set(x, y, x, y);\n     }\n \n-    public boolean isValid() {\n-        return minX <= maxX && minY <= maxY;\n+    public BlockArea(Vector2ic pos) {\n+        this.set(pos, pos);\n     }\n \n-    public boolean isEmpty() {\n-        return !isValid();\n+    public BlockArea(BlockAreac other) {\n+        this.set(other.minX(), other.minY(), other.maxX(), other.maxY());\n     }\n \n-    public BlockArea set(BlockArea other) {\n-        this.minX = other.minX;\n-        this.minY = other.minY;\n-        this.maxX = other.maxX;\n-        this.maxY = other.maxY;\n+    // -- reset ------------------------------------------------------------------------------------------------------//\n+\n+    public BlockArea set(int minX, int minY, int maxX, int maxY) {\n+        Preconditions.checkArgument(minX <= maxX || (minX == INVALID.minX() && maxX == INVALID.maxX()));\n+        Preconditions.checkArgument(minY <= maxY || (minY == INVALID.minY() && maxY == INVALID.maxY()));\n+\n+        this.minX = minX;\n+        this.minY = minY;\n+        this.maxX = maxX;\n+        this.maxY = maxY;\n \n-        Rectangles.set(this.bounds, other.bounds);\n         return this;\n     }\n \n-    /**\n-     * get the minimum block coordinate\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector2i getMin(Vector2i dest) {\n-        return dest.set(minX, minY);\n-    }\n-\n-    /**\n-     * get the maximum block coordinate\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector2i getMax(Vector2i dest) {\n-        return dest.set(maxX, maxY);\n-    }\n-\n-    /**\n-     * the maximum coordinate of the second block x\n-     *\n-     * @return the minimum coordinate x\n-     */\n-    public int getMaxX() {\n-        return maxX;\n+    public BlockArea set(Vector2ic min, Vector2ic max) {\n+        return this.set(min.x(), min.y(), max.x(), max.y());\n     }\n \n-    /**\n-     * the maximum coordinate of the second block y\n-     *\n-     * @return the minimum coordinate y\n-     */\n-    public int getMaxY() {\n-        return maxY;\n+    public BlockArea set(BlockAreac other) {\n+        return this.set(other.minX(), other.minY(), other.maxX(), other.maxY());\n     }\n \n-    /**\n-     * the minimum coordinate of the first block x\n-     *\n-     * @return the minimum coordinate x\n-     */\n-    public int getMinX() {\n+    // -- ITERABLE ---------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Iterator<Vector2ic> iterator() {\n+        return new Iterator<Vector2ic>() {\n+            private Vector2i current = null;\n+            private final Vector2i next = getMin(new Vector2i());\n+\n+            public boolean findNext() {\n+                if (current.equals(next)) {\n+                    next.y++;\n+                    if (next.y > maxY) {\n+                        next.y = minY;\n+                        next.x++;\n+                    }\n+\n+                    return contains(next);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (!isValid()) {\n+                    return false;\n+                }\n+                if (current == null) {\n+                    return true;\n+                }\n+\n+                if (current.equals(next)) {\n+                    return findNext();\n+                }\n+                return contains(next);\n+            }\n+\n+            @Override\n+            public Vector2ic next() {\n+                if (current == null) {\n+                    current = new Vector2i(next);\n+                    return next;\n+                }\n+\n+                if (current.equals(next)) {\n+                    if (findNext()) {\n+                        return next;\n+                    }\n+                    return null;\n+                }\n+                current.set(next);\n+                return next;\n+            }\n+        };\n+    }\n+\n+    // -- GETTERS & SETTERS ------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int minX() {\n         return minX;\n     }\n \n-    /**\n-     * the minimum coordinate of the first block y\n-     *\n-     * @return the minimum coordinate y\n-     */\n-    public int getMinY() {\n+    @Override\n+    public int minY() {\n         return minY;\n     }\n \n-    /**\n-     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param min the first coordinate of the first block\n-     * @return this\n-     */\n-    @SuppressWarnings(\"checkstyle:HiddenField\")\n+    @Override\n+    public BlockArea minX(int x, BlockArea dest) {\n+        return dest.set(x, minY, maxX, maxY);\n+    }\n+\n+    public BlockArea minX(int x) {\n+        return minX(x, this);\n+    }\n+\n+    @Override\n+    public BlockArea minY(int y, BlockArea dest) {\n+        return dest.set(minX, y, maxX, maxY);\n+    }\n+\n+    public BlockArea minY(int y) {\n+        return minY(y, this);\n+    }\n+\n+    @Override\n+    public BlockArea setMin(int x, int y, BlockArea dest) {\n+        return dest.set(x, y, maxX, maxY);\n+    }\n+\n+    public BlockArea setMin(int x, int y) {\n+        return this.setMin(x, y, this);\n+    }\n+\n     public BlockArea setMin(Vector2ic min) {\n-        return setMin(min.x(), min.y());\n-    }\n-\n-    /**\n-     * sets the minimum block for this {@link BlockRegion}\n-     *\n-     * @param minX the x coordinate of the first block\n-     * @param minY the y coordinate of the first block\n-     * @return this\n-     */\n-    public BlockArea setMin(int minX, int minY) {\n-        Preconditions.checkArgument(minX <= this.maxX ^ this.maxX == Integer.MIN_VALUE);\n-        Preconditions.checkArgument(minY <= this.maxY ^ this.maxY == Integer.MIN_VALUE);\n-        this.minX = minX;\n-        this.minY = minY;\n-        Rectangles.setMin(this.bounds, minX - 0.5f, minY - 0.5f);\n-        return this;\n+        return this.setMin(min.x(), min.y(), this);\n+    }\n+\n+    public BlockArea addToMin(int x, int y) {\n+        return this.addToMin(x, y, this);\n+    }\n+\n+    public BlockArea addToMin(Vector2ic min) {\n+        return this.addToMin(min.x(), min.y(), this);\n+    }\n+\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public int maxX() {\n+        return maxX;\n+    }\n+\n+    @Override\n+    public int maxY() {\n+        return maxY;\n+    }\n+\n+    @Override\n+    public BlockArea maxX(int x, BlockArea dest) {\n+        return dest.set(minX, minY, x, maxY);\n+    }\n+\n+    public BlockArea maxX(int x) {\n+        return maxX(x, this);\n+    }\n+\n+    @Override\n+    public BlockArea maxY(int y, BlockArea dest) {\n+        return dest.set(minX, minY, maxX, y);\n+    }\n+\n+    public BlockArea maxY(int y) {\n+        return maxY(y, this);\n+    }\n+\n+    @Override\n+    public BlockArea setMax(int x, int y, BlockArea dest) {\n+        return dest.set(minX, minY, x, y);\n+    }\n+\n+    public BlockArea setMax(int x, int y) {\n+        return this.setMax(x, y, this);\n     }\n \n-    /**\n-     * Sets the maximum coordinate of the second block for <code>this</code> {@link BlockRegion}\n-     *\n-     * @param max the second coordinate of the second block\n-     * @return this\n-     */\n     public BlockArea setMax(Vector2ic max) {\n-        return setMax(max.x(), max.y());\n-    }\n-\n-    /**\n-     * sets the maximum block for this {@link BlockRegion}\n-     *\n-     * @param maxX the x coordinate of the first block\n-     * @param maxY the y coordinate of the first block\n-     * @return this\n-     */\n-    @SuppressWarnings(\"checkstyle:HiddenField\")\n-    public BlockArea setMax(int maxX, int maxY) {\n-        Preconditions.checkArgument(maxX >= this.minX ^ this.minX == Integer.MAX_VALUE);\n-        Preconditions.checkArgument(maxY >= this.minY ^ this.minY == Integer.MAX_VALUE);\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        Rectangles.setMax(this.bounds, maxX + 0.5f, maxY + 0.5f);\n-        return this;\n+        return this.setMax(max.x(), max.y(), this);\n     }\n \n-    /**\n-     * Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n-     *\n-     * @param other {@link BlockRegion}\n-     * @return this\n-     */\n-    public BlockArea union(BlockArea other) {\n-        return union(other.minX, other.minY).union(other.minX, other.maxY);\n+    public BlockArea addToMax(int x, int y) {\n+        return this.addToMax(x, y, this);\n     }\n \n-    /**\n-     * Set <code>this</code> to the union of <code>this</code> and the given block <code>p</code>.\n-     *\n-     * @param p the position of the block\n-     * @return this\n-     */\n-    public BlockArea union(Vector2ic p) {\n-        return union(p.x(), p.y());\n+    public BlockArea addToMax(Vector2ic max) {\n+        return this.addToMax(max.x(), max.y(), this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea setSize(int sizeX, int sizeY, BlockArea dest) {\n+        return dest.set(minX, minY, minX + sizeX, minY + sizeY);\n+    }\n+\n+    public BlockArea setSize(int sizeX, int sizeY) {\n+        return this.setSize(sizeX, sizeY, this);\n+    }\n+\n+    public BlockArea setSize(Vector2ic size) {\n+        return this.setSize(size.x(), size.y(), this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea union(int x, int y, BlockArea dest) {\n+        return dest.set(\n+                Math.min(this.minX, x), Math.min(this.minY, y),\n+                Math.max(this.maxX, x), Math.max(this.maxY, y));\n     }\n \n     public BlockArea union(int x, int y) {\n         return union(x, y, this);\n     }\n \n-    /**\n-     * Compute the union of <code>this</code> and the given block <code>(x, y, z)</code> and stores the result in\n-     * <code>dest</code>\n-     *\n-     * @param x the x coordinate of the block\n-     * @param y the y coordinate of the block\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea union(int x, int y, BlockArea dest) {\n-        return dest\n-                .setMin(Math.min(dest.minX, x), Math.min(dest.minY, y))\n-                .setMax(Math.max(dest.maxX, x), Math.max(dest.maxY, y));\n-    }\n-\n-    /**\n-     * calculate the BlockRegion that is intersected between another region\n-     *\n-     * @param other the other BlockRegion\n-     * @param dest holds the result\n-     * @return dest\n-     */\n-    public BlockArea intersection(BlockArea other, BlockArea dest) {\n-        return dest\n-                .setMin(Math.max(this.minX, other.minX), Math.max(this.minY, other.minY))\n-                .setMax(Math.min(this.maxX, other.maxX), Math.min(this.maxY, other.maxY));\n-    }\n-\n-    /**\n-     * the number of blocks for the +x, +y, +z from the minimum to the maximum\n-     *\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public Vector2i getSize(Vector2i dest) {\n-        return dest.set(getSizeX(), getSizeY());\n-    }\n-\n-    /**\n-     * The number of blocks on the X axis\n-     *\n-     * @return number of blocks in the X axis\n-     */\n-    public int getSizeX() {\n-        return this.maxX - this.minX;\n-    }\n-\n-    /**\n-     * The number of blocks on the Y axis\n-     *\n-     * @return number of blocks in the Y axis\n-     */\n-    public int getSizeY() {\n-        return this.maxY - this.minY;\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param x the x coordinate to translate by\n-     * @param y the y coordinate to translate by\n-     * @return this\n-     */\n-    public BlockArea translate(int x, int y) {\n-        return translate(x, y, this);\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param xy the vector to translate by\n-     * @return this\n-     */\n-    public BlockArea translate(Vector2ic xy) {\n-        return translate(xy, this);\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xyz</code>.\n-     *\n-     * @param xy the vector to translate by\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea translate(Vector2ic xy, BlockArea dest) {\n-        return translate(xy.x(), xy.y(), dest);\n-    }\n-\n-    /**\n-     * Translate <code>this</code> by the given vector <code>xy</code>.\n-     *\n-     * @param x the length to translate by along x direction\n-     * @param y the length to translate by along y direction\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea translate(int x, int y, BlockArea dest) {\n-        dest.minX += x;\n-        dest.minY += y;\n-        dest.maxX += x;\n-        dest.maxY += y;\n-        dest.bounds.translate(x, y);\n-        return dest;\n+    public BlockArea union(Vector2ic p) {\n+        return union(p.x(), p.y(), this);\n+    }\n+\n+    public BlockArea union(BlockArea other) {\n+        return union(other, this);\n     }\n \n-    /**\n-     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param pos the coordinates of the block\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsBlock(Vector2ic pos) {\n-        return containsBlock(pos.x(), pos.y());\n-    }\n-\n-    /**\n-     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsBlock(int x, int y) {\n-        return x >= minX && y >= minY && x <= maxX && y <= maxY;\n-    }\n-\n-    /**\n-     * WORLD-COORDINATES\n-     * Test whether the point <code>(x, y, z)</code> lies inside this BlockRegion.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this BlockRegion; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(float x, float y) {\n-        return getWorldArea().containsPoint(x, y);\n-    }\n-\n-    /**\n-     * @see #containsPoint(float, float)\n-     */\n-    public boolean containsPoint(Vector2fc point) {\n-        return this.containsPoint(point.x(), point.y());\n-    }\n-\n-    /**\n-     * Test whether the point <code>(x, y, z)</code> lies inside this AABB.\n-     *\n-     * @param x the x coordinate of the point\n-     * @param y the y coordinate of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(int x, int y) {\n-        return containsBlock(x, y);\n-    }\n-\n-    /**\n-     * Test whether the given point lies inside this AABB.\n-     *\n-     * @param point the coordinates of the point\n-     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n-     */\n-    public boolean containsPoint(Vector2ic point) {\n-        return containsPoint(point.x(), point.y());\n-    }\n-\n-    /**\n-     * Test whether the given {@link BlockArea}  lies inside the {@link BlockArea}\n-     *\n-     * @param area the area to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockArea}; <code>false</code> otherwise\n-     */\n-    public boolean containsArea(BlockArea area) {\n-        return this.containsBlock(area.minX, area.minY) && this.containsBlock(area.maxX, area.maxY);\n-    }\n-\n-    /**\n-     * Test whether <code>this</code> and <code>other</code> intersect.\n-     *\n-     * @param other the other BlockRegion\n-     * @return <code>true</code> iff both AABBs intersect; <code>false</code> otherwise\n-     */\n-    public boolean intersectsArea(BlockArea other) {\n-        return this.minX <= other.maxX && this.maxX >= other.minX && this.maxY >= other.minY && this.minY <= other.maxY;\n-    }\n-\n-    /**\n-     * Adds extend for each face of a BlockRegion.\n-     *\n-     * @param extent extents to grow each face\n-     * @param dest holds the result\n-     * @return dest\n-     */\n-    public BlockArea addExtents(int extent, BlockArea dest) {\n-        return addExtents(extent, extent, dest);\n-    }\n-\n-    /**\n-     * Adds extend for each face of a BlockRegion.\n-     *\n-     * @param extentX the x coordinate to grow the extents\n-     * @param extentY the y coordinate to grow the extents\n-     * @return this\n-     */\n-    public BlockArea addExtents(int extentX, int extentY) {\n-        return addExtents(extentX, extentY, this);\n-    }\n-\n-    /**\n-     * Adds extend for each face of a BlockRegion\n-     *\n-     * @param extentX the x coordinate to grow the extents\n-     * @param extentY the y coordinate to grow the extents\n-     * @param dest will hold the result\n-     * @return dest\n-     */\n-    public BlockArea addExtents(int extentX, int extentY, BlockArea dest) {\n-        Preconditions.checkArgument(dest.getSizeX() + 2 * extentX >= 0 && dest.getSizeY() + 2 * extentY >= 0);\n-        dest.minX -= extentX;\n-        dest.minY -= extentY;\n-        dest.maxX += extentX;\n-        dest.maxY += extentY;\n-        Rectangles.expand(this.bounds, extentX, extentY);\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public Optional<BlockArea> intersect(BlockAreac other, BlockArea dest) {\n+        dest.minX = Math.max(minX, other.minX());\n+        dest.minY = Math.max(minY, other.minY());\n+\n+        dest.maxX = Math.min(maxX, other.maxX());\n+        dest.maxY = Math.min(maxY, other.maxY());\n+\n+        if (dest.isValid()) {\n+            return Optional.of(dest);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public Optional<BlockArea> intersect(BlockAreac other) {\n+        return this.intersect(other, this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea translate(int dx, int dy, BlockArea dest) {\n+        dest.minX = minX + dx;\n+        dest.minY = minY + dy;\n+        dest.maxX = maxX + dx;\n+        dest.maxY = maxY + dy;\n         return dest;\n     }\n \n+    public BlockArea translate(int dx, int dy) {\n+        return translate(dx, dy, this);\n+    }\n+\n+    public BlockArea translate(Vector2ic dv) {\n+        return translate(dv.x(), dv.y(), this);\n+    }\n+\n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n+    @Override\n+    public BlockArea expand(int dx, int dy, BlockArea dest) {\n+        return dest.set(minX - dx, minY - dy, maxX + dx, maxY + dy);\n+    }\n \n-    /**\n-     * Test whether the given {@link Rectanglef}  lies inside the {@link BlockArea}\n-     *\n-     * @param rect the rectangle to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockArea}; <code>false</code> otherwise\n-     */\n-    public boolean containsRectangle(Rectanglef rect) {\n-        return getWorldArea().containsRectangle(rect);\n+    public BlockArea expand(int dx, int dy) {\n+        return expand(dx, dy, this);\n     }\n \n-    /**\n-     * Test whether the given {@link Rectangled}  lies inside the {@link BlockArea}\n-     *\n-     * @param rect the rectangle to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockArea}; <code>false</code> otherwise\n-     */\n-    public boolean containsRectangle(Rectangled rect) {\n-        return getWorldArea().containsRectangle(rect);\n+    public BlockArea expand(Vector2ic dv) {\n+        return expand(dv.x(), dv.y(), this);\n     }\n \n+    // ---------------------------------------------------------------------------------------------------------------//\n+\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2MzU5Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4050#discussion_r542063596", "bodyText": "lets wait on this changes after this #4321", "author": "pollend", "createdAt": "2020-12-14T02:03:05Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -518,6 +519,43 @@ public boolean containsPoint(Vector3fc point) {\n         return this.aabb.containsPoint(point);\n     }\n \n+\n+    /**\n+     * Test whether the given aabb lies inside the {@link BlockRegion}\n+     * @param region the region to test\n+     * @return <code>true</code> iff the given value lies inside this {@link BlockRegion}; <code>false</code> otherwise\n+     */\n+    public boolean containsBlockRegion(BlockRegion region) {\n+        return this.containsAABB(region.aabb);\n+    }\n+\n+    /**\n+     * Test whether the given {@link AABBi} lies inside the {@link BlockRegion}\n+     * @param value the aabb to test\n+     * @return <code>true</code> iff the given value lies inside this {@link BlockRegion}; <code>false</code> otherwise\n+     */\n+    public boolean containsAABB(AABBi value) {\n+        return this.aabb.containsAABB(value);\n+    }\n+\n+    /**\n+     * Test whether the given {@link AABBf} lies inside the {@link BlockRegion}\n+     * @param value the aabb to test\n+     * @return <code>true</code> iff the given value lies inside this {@link BlockRegion}; <code>false</code> otherwise\n+     */\n+    public boolean containsAABB(AABBf value) {\n+        return this.aabb.containsAABB(aabb);\n+    }\n+\n+    /**\n+     * Test whether the given {@link AABBd} lies inside the {@link BlockRegion}\n+     * @param value the aabb to test\n+     * @return <code>true</code> iff the given value lies inside this {@link BlockRegion}; <code>false</code> otherwise\n+     */\n+    public boolean containsAABB(AABBd value) {\n+        return this.aabb.containsAABB(value);\n+    }\n+", "originalCommit": "ae58d1527d3b9be34de1fc947b5576b07b50cc54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI5NTA3MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4050#discussion_r548295070", "bodyText": "I'll remove these changes from this PR as they are not related to BlockArea.", "author": "skaldarnar", "createdAt": "2020-12-23T22:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2MzU5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "8d306d7f7b4c62942ddab3c8f0fbc2ed5240d7d3", "chunk": "diff --git a/engine/src/main/java/org/terasology/world/block/BlockRegion.java b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\nindex c7a0aca38..e3c243d45 100644\n--- a/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n+++ b/engine/src/main/java/org/terasology/world/block/BlockRegion.java\n\n@@ -516,45 +742,10 @@ public boolean containsPoint(Vector3ic point) {\n      * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n      */\n     public boolean containsPoint(Vector3fc point) {\n-        return this.aabb.containsPoint(point);\n-    }\n-\n-\n-    /**\n-     * Test whether the given aabb lies inside the {@link BlockRegion}\n-     * @param region the region to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockRegion}; <code>false</code> otherwise\n-     */\n-    public boolean containsBlockRegion(BlockRegion region) {\n-        return this.containsAABB(region.aabb);\n-    }\n-\n-    /**\n-     * Test whether the given {@link AABBi} lies inside the {@link BlockRegion}\n-     * @param value the aabb to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockRegion}; <code>false</code> otherwise\n-     */\n-    public boolean containsAABB(AABBi value) {\n-        return this.aabb.containsAABB(value);\n-    }\n-\n-    /**\n-     * Test whether the given {@link AABBf} lies inside the {@link BlockRegion}\n-     * @param value the aabb to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockRegion}; <code>false</code> otherwise\n-     */\n-    public boolean containsAABB(AABBf value) {\n-        return this.aabb.containsAABB(aabb);\n+        return this.containsPoint(point.x(), point.y(), point.z());\n     }\n \n-    /**\n-     * Test whether the given {@link AABBd} lies inside the {@link BlockRegion}\n-     * @param value the aabb to test\n-     * @return <code>true</code> iff the given value lies inside this {@link BlockRegion}; <code>false</code> otherwise\n-     */\n-    public boolean containsAABB(AABBd value) {\n-        return this.aabb.containsAABB(value);\n-    }\n+    // -- intersects -------------------------------------------------------------------------------------------------//\n \n     /**\n      * Test whether the plane given via its plane equation <code>a*x + b*y + c*z + d = 0</code> intersects this AABB.\n"}}, {"oid": "fc050189a2822b1383c5f6e36ecfc9a55b162de5", "url": "https://github.com/MovingBlocks/Terasology/commit/fc050189a2822b1383c5f6e36ecfc9a55b162de5", "message": "feat(BlockArea): add immutable interface for BlockArea", "committedDate": "2020-12-23T22:28:22Z", "type": "commit"}, {"oid": "430c9caa56062556ea548afe315d65a183661f8e", "url": "https://github.com/MovingBlocks/Terasology/commit/430c9caa56062556ea548afe315d65a183661f8e", "message": "feat(BlockArea): implement BlockArea in terms of BlockAreac", "committedDate": "2020-12-23T22:29:23Z", "type": "commit"}, {"oid": "e9902589da032986e887723eb8b8cda093f6aafe", "url": "https://github.com/MovingBlocks/Terasology/commit/e9902589da032986e887723eb8b8cda093f6aafe", "message": "feat(BlockArea): remove BlockAreas utility class", "committedDate": "2020-12-23T22:29:36Z", "type": "commit"}, {"oid": "fce71e1813fd148021c11d0080a4379b15177f22", "url": "https://github.com/MovingBlocks/Terasology/commit/fce71e1813fd148021c11d0080a4379b15177f22", "message": "test(BlockArea): adjust tests", "committedDate": "2020-12-23T22:29:46Z", "type": "commit"}, {"oid": "8d306d7f7b4c62942ddab3c8f0fbc2ed5240d7d3", "url": "https://github.com/MovingBlocks/Terasology/commit/8d306d7f7b4c62942ddab3c8f0fbc2ed5240d7d3", "message": "revert changes to BlockRegion", "committedDate": "2020-12-23T22:30:19Z", "type": "commit"}, {"oid": "38acfea00bf59e4c7a619705cf78fa24b06fb13c", "url": "https://github.com/MovingBlocks/Terasology/commit/38acfea00bf59e4c7a619705cf78fa24b06fb13c", "message": "Merge branch 'develop' into feature/square_region", "committedDate": "2020-12-23T22:49:59Z", "type": "commit"}, {"oid": "5f7b97d4dac62e83a5efc92fb13eb4f4bd4ba232", "url": "https://github.com/MovingBlocks/Terasology/commit/5f7b97d4dac62e83a5efc92fb13eb4f4bd4ba232", "message": "refactor: remove dest variants for modifying methods", "committedDate": "2020-12-24T11:32:30Z", "type": "commit"}, {"oid": "c34f1092fc549baf690d91f89471b7e0baac6959", "url": "https://github.com/MovingBlocks/Terasology/commit/c34f1092fc549baf690d91f89471b7e0baac6959", "message": "Revert \"refactor: remove dest variants for modifying methods\"\n\nThis reverts commit 5f7b97d4dac62e83a5efc92fb13eb4f4bd4ba232.", "committedDate": "2020-12-24T21:13:22Z", "type": "commit"}, {"oid": "6b49bd6c895f0ae7ee37d71ad7bf309360a23a31", "url": "https://github.com/MovingBlocks/Terasology/commit/6b49bd6c895f0ae7ee37d71ad7bf309360a23a31", "message": "feat(BlockArea): add `dest` variants for `setPosition`", "committedDate": "2020-12-24T21:17:25Z", "type": "commit"}, {"oid": "a0a6a69239cd4bfb18b1f1f5435e3c82c7ac5711", "url": "https://github.com/MovingBlocks/Terasology/commit/a0a6a69239cd4bfb18b1f1f5435e3c82c7ac5711", "message": "fix(BlockArea): set correct max corner in `setSize`", "committedDate": "2020-12-24T21:19:21Z", "type": "commit"}, {"oid": "ec6c6da491a51fc39a36f88d60e155ea69f27b0e", "url": "https://github.com/MovingBlocks/Terasology/commit/ec6c6da491a51fc39a36f88d60e155ea69f27b0e", "message": "Merge branch 'develop' into feature/square_region", "committedDate": "2020-12-26T19:42:04Z", "type": "commit"}, {"oid": "167f39f5cf2db4a38127ed6a80bc538715462d0e", "url": "https://github.com/MovingBlocks/Terasology/commit/167f39f5cf2db4a38127ed6a80bc538715462d0e", "message": "Merge branch 'develop' into feature/square_region", "committedDate": "2020-12-27T16:57:16Z", "type": "commit"}]}