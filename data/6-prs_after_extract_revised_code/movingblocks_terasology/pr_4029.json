{"pr_number": 4029, "pr_title": "feat(JOML): Migrate ChunkMath", "pr_createdAt": "2020-06-04T02:11:05Z", "pr_url": "https://github.com/MovingBlocks/Terasology/pull/4029", "timeline": [{"oid": "0ffe4b72ac5526e4cc9367262f86dd640ed7b024", "url": "https://github.com/MovingBlocks/Terasology/commit/0ffe4b72ac5526e4cc9367262f86dd640ed7b024", "message": "feat(JOML): Migrate ChunkMath", "committedDate": "2020-06-04T02:10:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MDYxNw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r434960617", "bodyText": "Bonus for dropping in even a brief line at the start of the javadoc just to cover the method overall \ud83d\udc4d", "author": "Cervator", "createdAt": "2020-06-04T02:42:44Z", "path": "engine/src/main/java/org/terasology/math/ChunkMath.java", "diffHunk": "@@ -64,35 +67,188 @@ public static int calcChunkPosZ(int z, int chunkPowerZ) {\n     public static int calcChunkPosX(int x) {\n         return calcChunkPosX(x, ChunkConstants.CHUNK_POWER.x);\n     }\n+\n     public static int calcChunkPosY(int y) {\n         return calcChunkPosY(y, ChunkConstants.CHUNK_POWER.y);\n     }\n+\n     public static int calcChunkPosZ(int z) {\n         return calcChunkPosZ(z, ChunkConstants.CHUNK_POWER.z);\n     }\n \n+    /**\n+     *", "originalCommit": "0ffe4b72ac5526e4cc9367262f86dd640ed7b024", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5196f3efaf5183a6af3a9d4f52cf43067c11739f", "chunk": "diff --git a/engine/src/main/java/org/terasology/math/ChunkMath.java b/engine/src/main/java/org/terasology/math/ChunkMath.java\nindex f051b2f41..59b169d4c 100644\n--- a/engine/src/main/java/org/terasology/math/ChunkMath.java\n+++ b/engine/src/main/java/org/terasology/math/ChunkMath.java\n\n@@ -148,9 +148,9 @@ public static Vector3i calcChunkPos(int x, int y, int z, Vector3i chunkPower) {\n     }\n \n     /**\n-     * The position relative of the chunk with the given power ({@link ChunkConstants#POWER_X}, {@link ChunkConstants#POWER_Y}, {@link ChunkConstants#POWER_Z})\n+     * The position of the chunk given the coordinate and size of chunk in powers of 2.\n      *\n-     * <p>Chunk size is in powers of 2 (2, 4, 8, 16, ...)</p>\n+     * <p>default chunk size ({@link ChunkConstants#SIZE_X}, {@link ChunkConstants#SIZE_Y}, {@link ChunkConstants#SIZE_Z}) </p>\n      *\n      * @param pos absolute position of the block\n      * @param dest will hold the result\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MDgzMQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r434960831", "bodyText": "Should this be deprecated then, or briefly Javadoc'ed?", "author": "Cervator", "createdAt": "2020-06-04T02:43:31Z", "path": "engine/src/main/java/org/terasology/math/ChunkMath.java", "diffHunk": "@@ -64,35 +67,188 @@ public static int calcChunkPosZ(int z, int chunkPowerZ) {\n     public static int calcChunkPosX(int x) {\n         return calcChunkPosX(x, ChunkConstants.CHUNK_POWER.x);\n     }\n+\n     public static int calcChunkPosY(int y) {\n         return calcChunkPosY(y, ChunkConstants.CHUNK_POWER.y);\n     }\n+\n     public static int calcChunkPosZ(int z) {\n         return calcChunkPosZ(z, ChunkConstants.CHUNK_POWER.z);\n     }\n \n+    /**\n+     *\n+     * @param pos the absolute world position\n+     * @param chunkPower the location of the chunk\n+     * @return the relative block in the chunk\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(Vector3ic, Vector3ic, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(Vector3i pos, Vector3i chunkPower) {\n         return calcChunkPos(pos.x, pos.y, pos.z, chunkPower);\n     }\n \n+    /**\n+     *\n+     * @param pos\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(Vector3fc, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(Vector3f pos) {\n         return calcChunkPos(new Vector3i(pos, RoundingMode.HALF_UP));\n     }\n \n+    /**\n+     *\n+     * @param pos\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(Vector3ic, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(Vector3i pos) {\n         return calcChunkPos(pos.x, pos.y, pos.z);\n     }\n \n+    /**\n+     *\n+     * @param x\n+     * @param y\n+     * @param z\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(int, int, int, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(int x, int y, int z) {\n         return calcChunkPos(x, y, z, ChunkConstants.CHUNK_POWER);\n     }\n \n+    /**\n+     *\n+     * @param x\n+     * @param y\n+     * @param z\n+     * @param chunkPower\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(int, int, int, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n+    public static Vector3i calcChunkPos(int x, int y, int z, Vector3i chunkPower) {\n+        return new Vector3i(calcChunkPosX(x, chunkPower.x), calcChunkPosY(y, chunkPower.y), calcChunkPosZ(z, chunkPower.z));\n+    }\n+\n+    //TODO: can be replaced by region3i iterator", "originalCommit": "0ffe4b72ac5526e4cc9367262f86dd640ed7b024", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5196f3efaf5183a6af3a9d4f52cf43067c11739f", "chunk": "diff --git a/engine/src/main/java/org/terasology/math/ChunkMath.java b/engine/src/main/java/org/terasology/math/ChunkMath.java\nindex f051b2f41..59b169d4c 100644\n--- a/engine/src/main/java/org/terasology/math/ChunkMath.java\n+++ b/engine/src/main/java/org/terasology/math/ChunkMath.java\n\n@@ -148,9 +148,9 @@ public static Vector3i calcChunkPos(int x, int y, int z, Vector3i chunkPower) {\n     }\n \n     /**\n-     * The position relative of the chunk with the given power ({@link ChunkConstants#POWER_X}, {@link ChunkConstants#POWER_Y}, {@link ChunkConstants#POWER_Z})\n+     * The position of the chunk given the coordinate and size of chunk in powers of 2.\n      *\n-     * <p>Chunk size is in powers of 2 (2, 4, 8, 16, ...)</p>\n+     * <p>default chunk size ({@link ChunkConstants#SIZE_X}, {@link ChunkConstants#SIZE_Y}, {@link ChunkConstants#SIZE_Z}) </p>\n      *\n      * @param pos absolute position of the block\n      * @param dest will hold the result\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MTY1Mw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r434961653", "bodyText": "Clarify? If dest is a param, and it gets used in a calculation, the result of which is returned while also matching dest ... why was the calculation needed? \ud83e\udd14 Methinks that probably isn't accurate then?", "author": "Cervator", "createdAt": "2020-06-04T02:46:49Z", "path": "engine/src/main/java/org/terasology/math/ChunkMath.java", "diffHunk": "@@ -64,35 +67,188 @@ public static int calcChunkPosZ(int z, int chunkPowerZ) {\n     public static int calcChunkPosX(int x) {\n         return calcChunkPosX(x, ChunkConstants.CHUNK_POWER.x);\n     }\n+\n     public static int calcChunkPosY(int y) {\n         return calcChunkPosY(y, ChunkConstants.CHUNK_POWER.y);\n     }\n+\n     public static int calcChunkPosZ(int z) {\n         return calcChunkPosZ(z, ChunkConstants.CHUNK_POWER.z);\n     }\n \n+    /**\n+     *\n+     * @param pos the absolute world position\n+     * @param chunkPower the location of the chunk\n+     * @return the relative block in the chunk\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(Vector3ic, Vector3ic, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(Vector3i pos, Vector3i chunkPower) {\n         return calcChunkPos(pos.x, pos.y, pos.z, chunkPower);\n     }\n \n+    /**\n+     *\n+     * @param pos\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(Vector3fc, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(Vector3f pos) {\n         return calcChunkPos(new Vector3i(pos, RoundingMode.HALF_UP));\n     }\n \n+    /**\n+     *\n+     * @param pos\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(Vector3ic, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(Vector3i pos) {\n         return calcChunkPos(pos.x, pos.y, pos.z);\n     }\n \n+    /**\n+     *\n+     * @param x\n+     * @param y\n+     * @param z\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(int, int, int, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(int x, int y, int z) {\n         return calcChunkPos(x, y, z, ChunkConstants.CHUNK_POWER);\n     }\n \n+    /**\n+     *\n+     * @param x\n+     * @param y\n+     * @param z\n+     * @param chunkPower\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(int, int, int, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n+    public static Vector3i calcChunkPos(int x, int y, int z, Vector3i chunkPower) {\n+        return new Vector3i(calcChunkPosX(x, chunkPower.x), calcChunkPosY(y, chunkPower.y), calcChunkPosZ(z, chunkPower.z));\n+    }\n+\n+    //TODO: can be replaced by region3i iterator\n     public static Vector3i[] calcChunkPos(Region3i region) {\n         return calcChunkPos(region, ChunkConstants.CHUNK_POWER);\n     }\n \n-    public static Vector3i calcChunkPos(int x, int y, int z, Vector3i chunkPower) {\n-        return new Vector3i(calcChunkPosX(x, chunkPower.x), calcChunkPosY(y, chunkPower.y), calcChunkPosZ(z, chunkPower.z));\n+    /**\n+     * The position relative of the chunk with the given power ({@link ChunkConstants#POWER_X}, {@link ChunkConstants#POWER_Y}, {@link ChunkConstants#POWER_Z})\n+     *\n+     * <p>Chunk size is in powers of 2 (2, 4, 8, 16, ...)</p>\n+     *\n+     * @param pos absolute position of the block\n+     * @param dest will hold the result", "originalCommit": "0ffe4b72ac5526e4cc9367262f86dd640ed7b024", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MzQ1Mw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r434963453", "bodyText": "I write it to a destination variable so we can avoid an extra allocation. we use these functions in quite a few loops so reducing the hit to cache seems worth it. the result is just the value written to that destination vector.", "author": "pollend", "createdAt": "2020-06-04T02:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MTY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3NjYyMg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r434976622", "bodyText": "So if that happens in a different method, I still think the documentation here is confusing. Because the logic clearly returns the result of a method call to which dest is passed - in the end it may well end up the same thing, but you aren't literally returning dest you're returning a calculation based on dest ?\nIf the goal is to avoid an extra allocation then you're achieving that in the other method. It doesn't really seem meaningful to tell the user about that here? Shouldn't you doc instead what dest starts as, since that's what it is doing as a param?", "author": "Cervator", "createdAt": "2020-06-04T03:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MTY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1NTA5MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r436155090", "bodyText": "From what I've seen of joml so far, this seems to be the common idiom. The current value of dest is irrelevant, it's just a mutable container for stuffing results in to.\nI don't love it, because it feels like one of the bad parts of programming in C, but if the joml devs think it helps I find that all-too-believable.\n(...if only Java could stack-allocate vectors. then we could just call functions, return results. wouldn't that be nice.)", "author": "keturn", "createdAt": "2020-06-05T20:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MTY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2NjQ1Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r436166456", "bodyText": "I might be dense, but then I still don't get it. Why have dest at all to begin with, if its value is irrelevant? Doesn't the user ultimately end up using the return value, even if that becomes the same value as dest in the end? Or is the user meant to subsequently use the variable they passed in as dest as it has changed-via-reference?\nIn either case the docs fail to enlighten this dummy here what's going on :-)", "author": "Cervator", "createdAt": "2020-06-05T21:12:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MTY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NDEwOA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r436174108", "bodyText": "a method that takes dest and has a return value does have some redundancy in its signature.\nreturning void would be unambiguous. I expect the return value is provided for convenience so you can write things like calculateChunkPos(pos, dest).mul(5) instead of calculateChunkPos(pos, dest);    dest.mul(5)\nthis is a pattern that's going to show up all over the joml-using matrix and vector code, so I think documentation about the pattern would go in the wiki or the package-level docs of terasology.math, probably with references to things like\n\nhttps://github.com/JOML-CI/JOML/wiki/Design\nhttps://github.com/JOML-CI/JOML/wiki/Anti-Patterns-and-Best-Practices#favor-destination-arguments-over-allocating-new-objects", "author": "keturn", "createdAt": "2020-06-05T21:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MTY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3ODk1MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r436178951", "bodyText": "So really the only reason to taking dest as a param is just to avoid allocating something new?\n* @param dest value ignored, but set to the same as the return value to avoid an allocation\n?\n(Edit: probably something better than that, but in the general direction of that)", "author": "Cervator", "createdAt": "2020-06-05T21:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MTY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4MzM4NA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r436183384", "bodyText": "hmm, \"set to the same as\" makes it sound like dest and the return value are separate-but-equal things. But it's the same object.\nmmm. I think I need another lunch before I try to think more about technical writing.", "author": "keturn", "createdAt": "2020-06-05T22:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MTY1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "5196f3efaf5183a6af3a9d4f52cf43067c11739f", "chunk": "diff --git a/engine/src/main/java/org/terasology/math/ChunkMath.java b/engine/src/main/java/org/terasology/math/ChunkMath.java\nindex f051b2f41..59b169d4c 100644\n--- a/engine/src/main/java/org/terasology/math/ChunkMath.java\n+++ b/engine/src/main/java/org/terasology/math/ChunkMath.java\n\n@@ -148,9 +148,9 @@ public static Vector3i calcChunkPos(int x, int y, int z, Vector3i chunkPower) {\n     }\n \n     /**\n-     * The position relative of the chunk with the given power ({@link ChunkConstants#POWER_X}, {@link ChunkConstants#POWER_Y}, {@link ChunkConstants#POWER_Z})\n+     * The position of the chunk given the coordinate and size of chunk in powers of 2.\n      *\n-     * <p>Chunk size is in powers of 2 (2, 4, 8, 16, ...)</p>\n+     * <p>default chunk size ({@link ChunkConstants#SIZE_X}, {@link ChunkConstants#SIZE_Y}, {@link ChunkConstants#SIZE_Z}) </p>\n      *\n      * @param pos absolute position of the block\n      * @param dest will hold the result\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MjAyNQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r434962025", "bodyText": "Is \"component\" a math term here? To me as a mundane developer it makes me think about our ES Components. If not a needed math term could it be named differently?", "author": "Cervator", "createdAt": "2020-06-04T02:48:18Z", "path": "engine/src/main/java/org/terasology/math/ChunkMath.java", "diffHunk": "@@ -64,35 +67,188 @@ public static int calcChunkPosZ(int z, int chunkPowerZ) {\n     public static int calcChunkPosX(int x) {\n         return calcChunkPosX(x, ChunkConstants.CHUNK_POWER.x);\n     }\n+\n     public static int calcChunkPosY(int y) {\n         return calcChunkPosY(y, ChunkConstants.CHUNK_POWER.y);\n     }\n+\n     public static int calcChunkPosZ(int z) {\n         return calcChunkPosZ(z, ChunkConstants.CHUNK_POWER.z);\n     }\n \n+    /**\n+     *\n+     * @param pos the absolute world position\n+     * @param chunkPower the location of the chunk\n+     * @return the relative block in the chunk\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(Vector3ic, Vector3ic, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(Vector3i pos, Vector3i chunkPower) {\n         return calcChunkPos(pos.x, pos.y, pos.z, chunkPower);\n     }\n \n+    /**\n+     *\n+     * @param pos\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(Vector3fc, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(Vector3f pos) {\n         return calcChunkPos(new Vector3i(pos, RoundingMode.HALF_UP));\n     }\n \n+    /**\n+     *\n+     * @param pos\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(Vector3ic, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(Vector3i pos) {\n         return calcChunkPos(pos.x, pos.y, pos.z);\n     }\n \n+    /**\n+     *\n+     * @param x\n+     * @param y\n+     * @param z\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(int, int, int, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(int x, int y, int z) {\n         return calcChunkPos(x, y, z, ChunkConstants.CHUNK_POWER);\n     }\n \n+    /**\n+     *\n+     * @param x\n+     * @param y\n+     * @param z\n+     * @param chunkPower\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(int, int, int, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n+    public static Vector3i calcChunkPos(int x, int y, int z, Vector3i chunkPower) {\n+        return new Vector3i(calcChunkPosX(x, chunkPower.x), calcChunkPosY(y, chunkPower.y), calcChunkPosZ(z, chunkPower.z));\n+    }\n+\n+    //TODO: can be replaced by region3i iterator\n     public static Vector3i[] calcChunkPos(Region3i region) {\n         return calcChunkPos(region, ChunkConstants.CHUNK_POWER);\n     }\n \n-    public static Vector3i calcChunkPos(int x, int y, int z, Vector3i chunkPower) {\n-        return new Vector3i(calcChunkPosX(x, chunkPower.x), calcChunkPosY(y, chunkPower.y), calcChunkPosZ(z, chunkPower.z));\n+    /**\n+     * The position relative of the chunk with the given power ({@link ChunkConstants#POWER_X}, {@link ChunkConstants#POWER_Y}, {@link ChunkConstants#POWER_Z})\n+     *\n+     * <p>Chunk size is in powers of 2 (2, 4, 8, 16, ...)</p>\n+     *\n+     * @param pos absolute position of the block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public static org.joml.Vector3i calcChunkPos(Vector3fc pos, org.joml.Vector3i dest) {\n+        return calcChunkPos(Math.roundHalfUp(pos.x()), Math.roundHalfUp(pos.y()), Math.roundHalfUp(pos.z()), ChunkConstants.POWER_X, ChunkConstants.POWER_Y, ChunkConstants.POWER_Z, dest);\n+    }\n+\n+    /**\n+     * The position relative to the size of chunk with the given chunk power\n+     *\n+     * <p>Chunk size is in powers of 2 (2, 4, 8, 16, ...)</p>\n+     *\n+     * @param pos absolute position of the block\n+     * @param chunkPower the size of the chunk in powers 2\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public static org.joml.Vector3i calcChunkPos(Vector3fc pos, Vector3ic chunkPower, org.joml.Vector3i dest) {\n+        return calcChunkPos(Math.roundHalfUp(pos.x()), Math.roundHalfUp(pos.y()), Math.roundHalfUp(pos.z()),\n+            chunkPower, dest);\n+    }\n+\n+    /**\n+     * The position relative to the size of chunk with the given power ({@link ChunkConstants#POWER_X}, {@link ChunkConstants#POWER_Y}, {@link ChunkConstants#POWER_Z})\n+     *\n+     * <p>Chunk size is in powers of 2 (2, 4, 8, 16, ...)</p>\n+     *\n+     * @param pos absolute position of the block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public static org.joml.Vector3i calcChunkPos(Vector3ic pos, org.joml.Vector3i dest) {\n+        return calcChunkPos(pos.x(), pos.y(), pos.z(), ChunkConstants.POWER_X, ChunkConstants.POWER_Y, ChunkConstants.POWER_Z, dest);\n+    }\n+\n+    /**\n+     * The position relative to the size of chunk with the given power ({@link ChunkConstants#POWER_X}, {@link ChunkConstants#POWER_Y}, {@link ChunkConstants#POWER_Z})\n+     *\n+     * <p>Chunk size is in powers of 2 (2, 4, 8, 16, ...)</p>\n+     *\n+     * @param x absolute x component of the block\n+     * @param y absolute y component of the block\n+     * @param z absolute z component of the block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public static org.joml.Vector3i calcChunkPos(int x, int y, int z, org.joml.Vector3i dest) {\n+        return calcChunkPos(x, y, z, ChunkConstants.POWER_X, ChunkConstants.POWER_Y, ChunkConstants.POWER_Z, dest);\n+    }\n+\n+    /**\n+     * The position relative to the size of chunk with the given chunk power\n+     *\n+     * <p>Chunk size is in powers of 2 (2, 4, 8, 16, ...)</p>\n+     *\n+     * @param pos the absolute position of the block\n+     * @param chunkPower the size of the chunk in powers of 2\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public static org.joml.Vector3i calcChunkPos(Vector3ic pos, Vector3ic chunkPower, org.joml.Vector3i dest) {\n+        return calcChunkPos(pos.x(), pos.y(), pos.z(), chunkPower.x(), chunkPower.y(), chunkPower.z(), dest);\n+    }\n+\n+    /**\n+     * The position relative to the size of chunk with the given chunk power\n+     *\n+     * <p>Chunk size is in powers of 2 (2, 4, 8, 16, ...)</p>\n+     *\n+     * @param x absolute x component of the block", "originalCommit": "0ffe4b72ac5526e4cc9367262f86dd640ed7b024", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2NDEwNw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r434964107", "bodyText": "I just follow what JOML is doing with referring to vector components. do you have a better name we can use?", "author": "pollend", "createdAt": "2020-06-04T02:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MjAyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3Njc2NA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r434976764", "bodyText": "x y and z coordinates ?", "author": "Cervator", "createdAt": "2020-06-04T03:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MjAyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5MDYyNw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r435090627", "bodyText": "Mathemtically, it's more common to talk about \"the components of a vector\" when interpreting that vector as merely an n-tuple of numbers. It seems that when the components are interpreted as a position in some kind of coordinate system (like cartesian) then it's more common to talk about \"coordinates\".", "author": "httpdigest", "createdAt": "2020-06-04T08:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MjAyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2NjU1MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r436166550", "bodyText": "yeah, component was the standard term for this in my math/physics education. unfortunate terminology collision in an environment that works with entity-component-system so much.", "author": "keturn", "createdAt": "2020-06-05T21:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MjAyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5196f3efaf5183a6af3a9d4f52cf43067c11739f", "chunk": "diff --git a/engine/src/main/java/org/terasology/math/ChunkMath.java b/engine/src/main/java/org/terasology/math/ChunkMath.java\nindex f051b2f41..59b169d4c 100644\n--- a/engine/src/main/java/org/terasology/math/ChunkMath.java\n+++ b/engine/src/main/java/org/terasology/math/ChunkMath.java\n\n@@ -148,9 +148,9 @@ public static Vector3i calcChunkPos(int x, int y, int z, Vector3i chunkPower) {\n     }\n \n     /**\n-     * The position relative of the chunk with the given power ({@link ChunkConstants#POWER_X}, {@link ChunkConstants#POWER_Y}, {@link ChunkConstants#POWER_Z})\n+     * The position of the chunk given the coordinate and size of chunk in powers of 2.\n      *\n-     * <p>Chunk size is in powers of 2 (2, 4, 8, 16, ...)</p>\n+     * <p>default chunk size ({@link ChunkConstants#SIZE_X}, {@link ChunkConstants#SIZE_Y}, {@link ChunkConstants#SIZE_Z}) </p>\n      *\n      * @param pos absolute position of the block\n      * @param dest will hold the result\n"}}, {"oid": "5196f3efaf5183a6af3a9d4f52cf43067c11739f", "url": "https://github.com/MovingBlocks/Terasology/commit/5196f3efaf5183a6af3a9d4f52cf43067c11739f", "message": "correct description for chunkmath", "committedDate": "2020-06-04T04:19:12Z", "type": "commit"}, {"oid": "20ffdd65f192b8d1bd1adbf763eda1d57c264848", "url": "https://github.com/MovingBlocks/Terasology/commit/20ffdd65f192b8d1bd1adbf763eda1d57c264848", "message": "add test cases to chunk", "committedDate": "2020-06-04T04:41:48Z", "type": "commit"}, {"oid": "d2c68e02e8ce11a326be230f6cdd89033c2dc509", "url": "https://github.com/MovingBlocks/Terasology/commit/d2c68e02e8ce11a326be230f6cdd89033c2dc509", "message": "update chunk math", "committedDate": "2020-06-04T04:45:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2NDMyNw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r436164327", "bodyText": "Are things picky about how these values are rounded?\nI suggest making a test for it. As much for documentation as anything else, and it'll explicitly point out if this ever changes. It's one of those almost-too-simple-to-test things otherwise.\nvalues like -1000f, -499.9f, -500.1f, -500.5f, -0f, 0f, 500.5f, 500.1f, -499.9f, 1000f\nor somesuch for mix of positive, negative, above-half and below-half.\nIf they're not picky about how they're rounded, x.intValue() might be ever-so-slightly cheaper. except that'll be always-towards-zero, which is probably worse for us than always-more-positive or always-more-negative, so, in conclusion, I'm over-thinking things again", "author": "keturn", "createdAt": "2020-06-05T21:06:12Z", "path": "engine/src/main/java/org/terasology/math/ChunkMath.java", "diffHunk": "@@ -30,79 +33,208 @@\n \n     private ChunkMath() {\n     }\n-\n-    /**\n-     * Returns the chunk position of a given coordinate.\n-     *\n-     * @param x The X-coordinate of the block\n-     * @return The X-coordinate of the chunk\n-     */\n-    public static int calcChunkPosX(int x, int chunkPowerX) {\n-        return (x >> chunkPowerX);\n-    }\n-\n-    /**\n-     * Returns the chunk position of a given coordinate.\n-     *\n-     * @param y The Y-coordinate of the block\n-     * @return The Y-coordinate of the chunk\n-     */\n-    public static int calcChunkPosY(int y, int chunkPowerY) {\n-        return (y >> chunkPowerY);\n-    }\n-\n+    \n     /**\n      * Returns the chunk position of a given coordinate.\n-     *\n-     * @param z The Z-coordinate of the block\n-     * @return The Z-coordinate of the chunk\n+     * @param x The coordinate of the block\n+     * @param chunkPower the size of the chunk in powers of 2\n+     * @return The coordinate of the chunk\n      */\n-    public static int calcChunkPosZ(int z, int chunkPowerZ) {\n-        return (z >> chunkPowerZ);\n+    public static int calcChunkPos(int x, int chunkPower) {\n+        return (x >> chunkPower);\n     }\n \n     public static int calcChunkPosX(int x) {\n-        return calcChunkPosX(x, ChunkConstants.CHUNK_POWER.x);\n+        return calcChunkPos(x, ChunkConstants.CHUNK_POWER.x);\n     }\n+\n     public static int calcChunkPosY(int y) {\n-        return calcChunkPosY(y, ChunkConstants.CHUNK_POWER.y);\n+        return calcChunkPos(y, ChunkConstants.CHUNK_POWER.y);\n     }\n+\n     public static int calcChunkPosZ(int z) {\n-        return calcChunkPosZ(z, ChunkConstants.CHUNK_POWER.z);\n+        return calcChunkPos(z, ChunkConstants.CHUNK_POWER.z);\n     }\n \n+    /**\n+     *\n+     * @param pos the absolute world position\n+     * @param chunkPower the location of the chunk\n+     * @return the relative block in the chunk\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(Vector3ic, Vector3ic, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(Vector3i pos, Vector3i chunkPower) {\n         return calcChunkPos(pos.x, pos.y, pos.z, chunkPower);\n     }\n \n+    /**\n+     *\n+     * @param pos\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(Vector3fc, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(Vector3f pos) {\n         return calcChunkPos(new Vector3i(pos, RoundingMode.HALF_UP));\n     }\n \n+    /**\n+     *\n+     * @param pos\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(Vector3ic, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(Vector3i pos) {\n         return calcChunkPos(pos.x, pos.y, pos.z);\n     }\n \n+    /**\n+     *\n+     * @param x\n+     * @param y\n+     * @param z\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(int, int, int, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n     public static Vector3i calcChunkPos(int x, int y, int z) {\n         return calcChunkPos(x, y, z, ChunkConstants.CHUNK_POWER);\n     }\n \n+    /**\n+     *\n+     * @param x\n+     * @param y\n+     * @param z\n+     * @param chunkPower\n+     * @return\n+     * @deprecated This is scheduled for removal in an upcoming version\n+     *             method will be replaced with JOML implementation {@link #calcChunkPos(int, int, int, org.joml.Vector3i)}.\n+     */\n+    @Deprecated\n+    public static Vector3i calcChunkPos(int x, int y, int z, Vector3i chunkPower) {\n+        return new Vector3i(calcChunkPos(x, chunkPower.x), calcChunkPos(y, chunkPower.y), calcChunkPos(z, chunkPower.z));\n+    }\n+\n+    //TODO: can be replaced by region3i iterator\n     public static Vector3i[] calcChunkPos(Region3i region) {\n         return calcChunkPos(region, ChunkConstants.CHUNK_POWER);\n     }\n \n-    public static Vector3i calcChunkPos(int x, int y, int z, Vector3i chunkPower) {\n-        return new Vector3i(calcChunkPosX(x, chunkPower.x), calcChunkPosY(y, chunkPower.y), calcChunkPosZ(z, chunkPower.z));\n+    /**\n+     * The position of the chunk given the coordinate and size of chunk in powers of 2.\n+     *\n+     * <p>default chunk size ({@link ChunkConstants#SIZE_X}, {@link ChunkConstants#SIZE_Y}, {@link ChunkConstants#SIZE_Z}) </p>\n+     *\n+     * @param pos absolute position of the block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public static org.joml.Vector3i calcChunkPos(Vector3fc pos, org.joml.Vector3i dest) {\n+        return calcChunkPos(Math.roundHalfUp(pos.x()), Math.roundHalfUp(pos.y()), Math.roundHalfUp(pos.z()), ChunkConstants.POWER_X, ChunkConstants.POWER_Y, ChunkConstants.POWER_Z, dest);\n+    }\n+\n+    /**\n+     * The position of the chunk given the coordinate and size of chunk in powers of 2.\n+     *\n+     * @param pos absolute position of the block\n+     * @param chunkPower the size of the chunk in powers 2\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public static org.joml.Vector3i calcChunkPos(Vector3fc pos, Vector3ic chunkPower, org.joml.Vector3i dest) {\n+        return calcChunkPos(Math.roundHalfUp(pos.x()), Math.roundHalfUp(pos.y()), Math.roundHalfUp(pos.z()),", "originalCommit": "d2c68e02e8ce11a326be230f6cdd89033c2dc509", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "789abfdf0e445f7a306e45b680a38c52addc1d4b", "chunk": "diff --git a/engine/src/main/java/org/terasology/math/ChunkMath.java b/engine/src/main/java/org/terasology/math/ChunkMath.java\nindex ba24f39b3..8ce93f195 100644\n--- a/engine/src/main/java/org/terasology/math/ChunkMath.java\n+++ b/engine/src/main/java/org/terasology/math/ChunkMath.java\n\n@@ -33,7 +33,7 @@\n \n     private ChunkMath() {\n     }\n-    \n+\n     /**\n      * Returns the chunk position of a given coordinate.\n      * @param x The coordinate of the block\n"}}, {"oid": "789abfdf0e445f7a306e45b680a38c52addc1d4b", "url": "https://github.com/MovingBlocks/Terasology/commit/789abfdf0e445f7a306e45b680a38c52addc1d4b", "message": "add chunk test", "committedDate": "2020-06-08T22:33:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA5NTc5NA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r437095794", "bodyText": "That's some exactly-half, over-half, under-half, that's good.\nThrow in at least one test with some negative coordinates, so we can tell if it's doing round-towards-zero or round-towards -infinity. What should that be... I guess x -0.1 is in chunk -1, along with x -63.9\nx: -64 and -64.1 are chunk -2? bah, the fencepost errors are messing with me. I keep confusing myself, I should draw more diagrams.", "author": "keturn", "createdAt": "2020-06-09T02:02:33Z", "path": "engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java", "diffHunk": "@@ -93,4 +93,14 @@ public void testCalcChunkPos() {\n         assertTrue(ChunkMath.calcChunkPos(10, 10, 10, temp).equals(0, 0, 0));\n     }\n \n+\n+    @Test\n+    public void testFloatingPointCalcChunkPos() {", "originalCommit": "789abfdf0e445f7a306e45b680a38c52addc1d4b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "257a7006cce54fa79f2fc6edeaa7b38830ae1ae4", "chunk": "diff --git a/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java b/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java\nindex 66486c6c6..6c0b722d8 100644\n--- a/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java\n+++ b/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java\n\n@@ -101,6 +101,8 @@ public void testFloatingPointCalcChunkPos() {\n         assertTrue(ChunkMath.calcChunkPos(32.9f, 63.9f, 32.9f, temp).equals(1, 0, 1), temp.toString());\n         assertTrue(ChunkMath.calcChunkPos(31.3f, 63.9f, 31.9f, temp).equals(0, 0, 0), temp.toString());\n         assertTrue(ChunkMath.calcChunkPos(31.6f, 64.5f, 32.1f, temp).equals(0, 1, 1), temp.toString());\n+        assertTrue(ChunkMath.calcChunkPos(.1f, -.2f, -.8f, temp).equals(0, -1, -1), temp.toString());\n+        assertTrue(ChunkMath.calcChunkPos(-.1f, -.99f, 2f, temp).equals(-1, -1, 0), temp.toString());\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA5NjQzNA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4029#discussion_r437096434", "bodyText": "wait what ... ohhh, chunks aren't cubical, they're taller than they are wide? okay. then my previous comment about where the x-boundary for chunk -1 is was wrong.", "author": "keturn", "createdAt": "2020-06-09T02:04:39Z", "path": "engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java", "diffHunk": "@@ -93,4 +93,14 @@ public void testCalcChunkPos() {\n         assertTrue(ChunkMath.calcChunkPos(10, 10, 10, temp).equals(0, 0, 0));\n     }\n \n+\n+    @Test\n+    public void testFloatingPointCalcChunkPos() {\n+        org.joml.Vector3i temp = new org.joml.Vector3i();\n+        assertTrue(ChunkMath.calcChunkPos(31.9f, 64.1f, 32.5f, temp).equals(0, 1, 1), temp.toString());\n+        assertTrue(ChunkMath.calcChunkPos(32.9f, 63.9f, 32.9f, temp).equals(1, 0, 1), temp.toString());", "originalCommit": "789abfdf0e445f7a306e45b680a38c52addc1d4b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "257a7006cce54fa79f2fc6edeaa7b38830ae1ae4", "chunk": "diff --git a/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java b/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java\nindex 66486c6c6..6c0b722d8 100644\n--- a/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java\n+++ b/engine-tests/src/test/java/org/terasology/math/ChunkMathTest.java\n\n@@ -101,6 +101,8 @@ public void testFloatingPointCalcChunkPos() {\n         assertTrue(ChunkMath.calcChunkPos(32.9f, 63.9f, 32.9f, temp).equals(1, 0, 1), temp.toString());\n         assertTrue(ChunkMath.calcChunkPos(31.3f, 63.9f, 31.9f, temp).equals(0, 0, 0), temp.toString());\n         assertTrue(ChunkMath.calcChunkPos(31.6f, 64.5f, 32.1f, temp).equals(0, 1, 1), temp.toString());\n+        assertTrue(ChunkMath.calcChunkPos(.1f, -.2f, -.8f, temp).equals(0, -1, -1), temp.toString());\n+        assertTrue(ChunkMath.calcChunkPos(-.1f, -.99f, 2f, temp).equals(-1, -1, 0), temp.toString());\n     }\n \n }\n"}}, {"oid": "257a7006cce54fa79f2fc6edeaa7b38830ae1ae4", "url": "https://github.com/MovingBlocks/Terasology/commit/257a7006cce54fa79f2fc6edeaa7b38830ae1ae4", "message": "add negative test cases", "committedDate": "2020-06-09T02:11:25Z", "type": "commit"}, {"oid": "b2b574fbccf04d844ff7f98475d8dca15f895cc3", "url": "https://github.com/MovingBlocks/Terasology/commit/b2b574fbccf04d844ff7f98475d8dca15f895cc3", "message": "Merge remote-tracking branch 'upstream/develop' into feature/joml_chunkmath", "committedDate": "2020-06-15T17:29:39Z", "type": "commit"}, {"oid": "4676c081cf00dff2f21006e88ba7c2c136789cc1", "url": "https://github.com/MovingBlocks/Terasology/commit/4676c081cf00dff2f21006e88ba7c2c136789cc1", "message": "update name convention for relativeBlock and introduced calcChunkRegion", "committedDate": "2020-06-15T18:59:52Z", "type": "commit"}, {"oid": "ba541feedf97b2afeb0185e78c0e145c4f05b44f", "url": "https://github.com/MovingBlocks/Terasology/commit/ba541feedf97b2afeb0185e78c0e145c4f05b44f", "message": "Merge remote-tracking branch 'upstream/develop' into feature/joml_chunkmath", "committedDate": "2020-07-05T22:32:47Z", "type": "commit"}]}