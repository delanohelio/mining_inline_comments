{"pr_number": 8758, "pr_title": "BAEL-3855", "pr_createdAt": "2020-02-19T22:29:54Z", "pr_url": "https://github.com/eugenp/tutorials/pull/8758", "timeline": [{"oid": "9c4f89d4142044ea62b9c7de98a4da6f6f6513fe", "url": "https://github.com/eugenp/tutorials/commit/9c4f89d4142044ea62b9c7de98a4da6f6f6513fe", "message": "Hexagonal architecture: a quick and practical example", "committedDate": "2019-12-05T10:32:58Z", "type": "commit"}, {"oid": "e2fd861f60bccf189f1aca68877e2ccb1edd6b27", "url": "https://github.com/eugenp/tutorials/commit/e2fd861f60bccf189f1aca68877e2ccb1edd6b27", "message": "Merge pull request #1 from eugenp/master\n\nSend PR", "committedDate": "2019-12-20T14:09:08Z", "type": "commit"}, {"oid": "a000150c46682fc16dd6ebb136d941f04459ccb9", "url": "https://github.com/eugenp/tutorials/commit/a000150c46682fc16dd6ebb136d941f04459ccb9", "message": "BAEL 3486", "committedDate": "2019-12-23T08:28:02Z", "type": "commit"}, {"oid": "4cf4a15ac8ce47f2fae2a1f18132ad97ce2c6991", "url": "https://github.com/eugenp/tutorials/commit/4cf4a15ac8ce47f2fae2a1f18132ad97ce2c6991", "message": "BAEL-3855\n\nLock Striping", "committedDate": "2020-02-19T22:14:25Z", "type": "commit"}, {"oid": "2227006e076e168ba8c8bf63de6733b79d77553b", "url": "https://github.com/eugenp/tutorials/commit/2227006e076e168ba8c8bf63de6733b79d77553b", "message": "BAEL-3855", "committedDate": "2020-02-19T22:26:24Z", "type": "commit"}, {"oid": "7094a3b15bc8c69b6773807f100071b0b7fed029", "url": "https://github.com/eugenp/tutorials/commit/7094a3b15bc8c69b6773807f100071b0b7fed029", "message": "BAEL-3855", "committedDate": "2020-02-19T22:27:45Z", "type": "commit"}, {"oid": "6388b70f30386a8af7b0bdcea03332b91a268fda", "url": "https://github.com/eugenp/tutorials/commit/6388b70f30386a8af7b0bdcea03332b91a268fda", "message": "BAEL-3855", "committedDate": "2020-02-19T22:28:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwODMxOQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r382108319", "bodyText": "fix indentation throughout the class", "author": "rpvilao", "createdAt": "2020-02-20T16:21:55Z", "path": "lock-striping/src/com/baeldung/concurrent/lock/BenchMark.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package com.baeldung.concurrent.lock;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.MILLISECONDS)\n+public class BenchMark {\n+    ConcurrentAccessMap accessMyMap;", "originalCommit": "6388b70f30386a8af7b0bdcea03332b91a268fda", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "63b4db7f7a4253e486d4b13fffadd4f26f89c8f6", "chunk": "diff --git a/lock-striping/src/com/baeldung/concurrent/lock/BenchMark.java b/lock-striping/src/com/baeldung/concurrent/lock/BenchMark.java\nindex 5aae5145d2..438bcb2f4b 100644\n--- a/lock-striping/src/com/baeldung/concurrent/lock/BenchMark.java\n+++ b/lock-striping/src/com/baeldung/concurrent/lock/BenchMark.java\n\n@@ -6,6 +6,7 @@ import java.util.concurrent.TimeUnit;\n \n import org.openjdk.jmh.annotations.Benchmark;\n import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n import org.openjdk.jmh.annotations.Measurement;\n import org.openjdk.jmh.annotations.Mode;\n import org.openjdk.jmh.annotations.OutputTimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjExMDM5Nw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r382110397", "bodyText": "indentation", "author": "rpvilao", "createdAt": "2020-02-20T16:25:13Z", "path": "lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.common.base.Supplier;\n+\n+public abstract class ConcurrentAccessMap {", "originalCommit": "6388b70f30386a8af7b0bdcea03332b91a268fda", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "63b4db7f7a4253e486d4b13fffadd4f26f89c8f6", "chunk": "diff --git a/lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java b/lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java\nindex 87c305b8aa..00b61cdc09 100644\n--- a/lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java\n+++ b/lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java\n\n@@ -6,28 +6,28 @@ import java.util.concurrent.CompletableFuture;\n import com.google.common.base.Supplier;\n \n public abstract class ConcurrentAccessMap {\n-\tstatic final int SLOTS = 4;\n-\tstatic final int THREADS = 10000;\n-\tstatic final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n-\tprivate CompletableFuture<?>[] requests;\n-\tMap<String, String> map;\n-\t\t\n-\tpublic ConcurrentAccessMap(Map<String, String> map) {\n-\t\tthis.map = map;\n-\t}\n-\t\n-\tpublic final void doWork(String type) {\n-\t\trequests = new CompletableFuture<?>[THREADS * SLOTS];\n+    static final int SLOTS = 4;\n+    static final int THREADS = 10000;\n+    static final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+    private CompletableFuture<?>[] requests;\n+    protected Map<String, String> map;\n+    \n+    public ConcurrentAccessMap(Map<String, String> map) {\n+        this.map = map;\n+    }\n \n-\t\tfor (int i = 0; i < THREADS; i++) {\n-        \trequests[SLOTS * i + 0] = CompletableFuture.supplyAsync(putSupplier(i));\n-    \t\trequests[SLOTS * i + 1] = CompletableFuture.supplyAsync(getSupplier(i));\n-    \t\trequests[SLOTS * i + 2] = CompletableFuture.supplyAsync(getSupplier(i));\n-    \t\trequests[SLOTS * i + 3] = CompletableFuture.supplyAsync(getSupplier(i)); \t\n+    public final void doWork(String type) {\n+        requests = new CompletableFuture<?>[THREADS * SLOTS];\n+\n+        for (int i = 0; i < THREADS; i++) {\n+            requests[SLOTS * i + 0] = CompletableFuture.supplyAsync(putSupplier(i));\n+            requests[SLOTS * i + 1] = CompletableFuture.supplyAsync(getSupplier(i));\n+            requests[SLOTS * i + 2] = CompletableFuture.supplyAsync(getSupplier(i));\n+            requests[SLOTS * i + 3] = CompletableFuture.supplyAsync(getSupplier(i)); \t\n \t\t}\n-\t\tCompletableFuture.allOf(requests).join();\n-\t}\n-\t\t\n-\tprotected abstract Supplier<?> putSupplier(int x);\n-\tprotected abstract Supplier<?> getSupplier(int x);\n-}\n+        CompletableFuture.allOf(requests).join();\n+    }\n+\n+    protected abstract Supplier<?> putSupplier(int x);\n+    protected abstract Supplier<?> getSupplier(int x);\n+}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjExMDQ5NA==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r382110494", "bodyText": "indentation", "author": "rpvilao", "createdAt": "2020-02-20T16:25:22Z", "path": "lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.common.base.Supplier;\n+\n+public abstract class ConcurrentAccessMap {\n+\tstatic final int SLOTS = 4;\n+\tstatic final int THREADS = 10000;\n+\tstatic final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+\tprivate CompletableFuture<?>[] requests;\n+\tMap<String, String> map;\n+\t\t\n+\tpublic ConcurrentAccessMap(Map<String, String> map) {\n+\t\tthis.map = map;\n+\t}\n+\t\n+\tpublic final void doWork(String type) {\n+\t\trequests = new CompletableFuture<?>[THREADS * SLOTS];\n+\n+\t\tfor (int i = 0; i < THREADS; i++) {\n+        \trequests[SLOTS * i + 0] = CompletableFuture.supplyAsync(putSupplier(i));", "originalCommit": "6388b70f30386a8af7b0bdcea03332b91a268fda", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "63b4db7f7a4253e486d4b13fffadd4f26f89c8f6", "chunk": "diff --git a/lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java b/lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java\nindex 87c305b8aa..00b61cdc09 100644\n--- a/lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java\n+++ b/lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java\n\n@@ -6,28 +6,28 @@ import java.util.concurrent.CompletableFuture;\n import com.google.common.base.Supplier;\n \n public abstract class ConcurrentAccessMap {\n-\tstatic final int SLOTS = 4;\n-\tstatic final int THREADS = 10000;\n-\tstatic final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n-\tprivate CompletableFuture<?>[] requests;\n-\tMap<String, String> map;\n-\t\t\n-\tpublic ConcurrentAccessMap(Map<String, String> map) {\n-\t\tthis.map = map;\n-\t}\n-\t\n-\tpublic final void doWork(String type) {\n-\t\trequests = new CompletableFuture<?>[THREADS * SLOTS];\n+    static final int SLOTS = 4;\n+    static final int THREADS = 10000;\n+    static final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+    private CompletableFuture<?>[] requests;\n+    protected Map<String, String> map;\n+    \n+    public ConcurrentAccessMap(Map<String, String> map) {\n+        this.map = map;\n+    }\n \n-\t\tfor (int i = 0; i < THREADS; i++) {\n-        \trequests[SLOTS * i + 0] = CompletableFuture.supplyAsync(putSupplier(i));\n-    \t\trequests[SLOTS * i + 1] = CompletableFuture.supplyAsync(getSupplier(i));\n-    \t\trequests[SLOTS * i + 2] = CompletableFuture.supplyAsync(getSupplier(i));\n-    \t\trequests[SLOTS * i + 3] = CompletableFuture.supplyAsync(getSupplier(i)); \t\n+    public final void doWork(String type) {\n+        requests = new CompletableFuture<?>[THREADS * SLOTS];\n+\n+        for (int i = 0; i < THREADS; i++) {\n+            requests[SLOTS * i + 0] = CompletableFuture.supplyAsync(putSupplier(i));\n+            requests[SLOTS * i + 1] = CompletableFuture.supplyAsync(getSupplier(i));\n+            requests[SLOTS * i + 2] = CompletableFuture.supplyAsync(getSupplier(i));\n+            requests[SLOTS * i + 3] = CompletableFuture.supplyAsync(getSupplier(i)); \t\n \t\t}\n-\t\tCompletableFuture.allOf(requests).join();\n-\t}\n-\t\t\n-\tprotected abstract Supplier<?> putSupplier(int x);\n-\tprotected abstract Supplier<?> getSupplier(int x);\n-}\n+        CompletableFuture.allOf(requests).join();\n+    }\n+\n+    protected abstract Supplier<?> putSupplier(int x);\n+    protected abstract Supplier<?> getSupplier(int x);\n+}\n\\ No newline at end of file\n"}}, {"oid": "63b4db7f7a4253e486d4b13fffadd4f26f89c8f6", "url": "https://github.com/eugenp/tutorials/commit/63b4db7f7a4253e486d4b13fffadd4f26f89c8f6", "message": "BAEL-3855\n\nidentation, moved to new module, removed needless classes, better benchmark", "committedDate": "2020-02-21T13:17:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwMDc2Nw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r382900767", "bodyText": "fix indentation", "author": "rpvilao", "createdAt": "2020-02-22T09:47:33Z", "path": "lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.common.base.Supplier;\n+\n+public abstract class ConcurrentAccessMap {\n+    static final int SLOTS = 4;\n+    static final int THREADS = 10000;\n+    static final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+    private CompletableFuture<?>[] requests;\n+    protected Map<String, String> map;\n+    \n+    public ConcurrentAccessMap(Map<String, String> map) {\n+        this.map = map;\n+    }\n+\n+    public final void doWork(String type) {\n+        requests = new CompletableFuture<?>[THREADS * SLOTS];\n+\n+        for (int i = 0; i < THREADS; i++) {\n+            requests[SLOTS * i + 0] = CompletableFuture.supplyAsync(putSupplier(i));\n+            requests[SLOTS * i + 1] = CompletableFuture.supplyAsync(getSupplier(i));\n+            requests[SLOTS * i + 2] = CompletableFuture.supplyAsync(getSupplier(i));\n+            requests[SLOTS * i + 3] = CompletableFuture.supplyAsync(getSupplier(i)); \t\n+\t\t}", "originalCommit": "63b4db7f7a4253e486d4b13fffadd4f26f89c8f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwNjYyNQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r382906625", "bodyText": "Updated now", "author": "mguarnaccia", "createdAt": "2020-02-22T11:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwMDc2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "38d9ed40ca3b8abea4c365646572e4a7026fa633", "chunk": "diff --git a/lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java b/lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java\ndeleted file mode 100644\nindex 00b61cdc09..0000000000\n--- a/lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java\n+++ /dev/null\n\n@@ -1,33 +0,0 @@\n-package com.baeldung.concurrent.lock;\n-\n-import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-\n-import com.google.common.base.Supplier;\n-\n-public abstract class ConcurrentAccessMap {\n-    static final int SLOTS = 4;\n-    static final int THREADS = 10000;\n-    static final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n-    private CompletableFuture<?>[] requests;\n-    protected Map<String, String> map;\n-    \n-    public ConcurrentAccessMap(Map<String, String> map) {\n-        this.map = map;\n-    }\n-\n-    public final void doWork(String type) {\n-        requests = new CompletableFuture<?>[THREADS * SLOTS];\n-\n-        for (int i = 0; i < THREADS; i++) {\n-            requests[SLOTS * i + 0] = CompletableFuture.supplyAsync(putSupplier(i));\n-            requests[SLOTS * i + 1] = CompletableFuture.supplyAsync(getSupplier(i));\n-            requests[SLOTS * i + 2] = CompletableFuture.supplyAsync(getSupplier(i));\n-            requests[SLOTS * i + 3] = CompletableFuture.supplyAsync(getSupplier(i)); \t\n-\t\t}\n-        CompletableFuture.allOf(requests).join();\n-    }\n-\n-    protected abstract Supplier<?> putSupplier(int x);\n-    protected abstract Supplier<?> getSupplier(int x);\n-}\n\\ No newline at end of file\n"}}, {"oid": "d1e309cecf6093746fcf32c84119fc730f0b03ce", "url": "https://github.com/eugenp/tutorials/commit/d1e309cecf6093746fcf32c84119fc730f0b03ce", "message": "BAEL-3855\n\nTree update", "committedDate": "2020-02-22T11:34:10Z", "type": "commit"}, {"oid": "8a0d5d85363680bcda2a75f3d71f642225ccca78", "url": "https://github.com/eugenp/tutorials/commit/8a0d5d85363680bcda2a75f3d71f642225ccca78", "message": "BAEL-3855\n\ntree fix", "committedDate": "2020-02-24T09:10:02Z", "type": "commit"}, {"oid": "f1d6b292bd2d785b95fe2cd86b77ee77dacfa00c", "url": "https://github.com/eugenp/tutorials/commit/f1d6b292bd2d785b95fe2cd86b77ee77dacfa00c", "message": "BAEL-3855\n\nMoved to java-core-modules folder", "committedDate": "2020-02-25T09:31:59Z", "type": "commit"}, {"oid": "38d9ed40ca3b8abea4c365646572e4a7026fa633", "url": "https://github.com/eugenp/tutorials/commit/38d9ed40ca3b8abea4c365646572e4a7026fa633", "message": "BAEL-3855\n\nUpdated", "committedDate": "2020-03-09T15:43:35Z", "type": "commit"}, {"oid": "388ba64d3dc8a6e7a4fa11465a382ccf40658b05", "url": "https://github.com/eugenp/tutorials/commit/388ba64d3dc8a6e7a4fa11465a382ccf40658b05", "message": "Delete CoarseGrained.java", "committedDate": "2020-03-11T10:20:37Z", "type": "commit"}, {"oid": "ade062068900b5994bd09665a5aa766db8b6638e", "url": "https://github.com/eugenp/tutorials/commit/ade062068900b5994bd09665a5aa766db8b6638e", "message": "Delete LockStriped.java", "committedDate": "2020-03-11T10:21:01Z", "type": "commit"}, {"oid": "e2c4ff751b26bed7e293cae523c948ce1c81ec7d", "url": "https://github.com/eugenp/tutorials/commit/e2c4ff751b26bed7e293cae523c948ce1c81ec7d", "message": "BAEL-3855", "committedDate": "2020-03-11T12:19:25Z", "type": "commit"}, {"oid": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "url": "https://github.com/eugenp/tutorials/commit/0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "message": "BAEL-3855", "committedDate": "2020-03-11T13:31:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5NjUxMg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r390996512", "bodyText": "I think this would be simplified by having both instances of your test instantiated from the beginning:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ConcurrentAccessExperiment accessMyMap;\n          \n          \n            \n                SingleLock single = new SingleLock();\n          \n          \n            \n                StripedLock striped = new StripedLock(BUCKETS);", "author": "jzheaux", "createdAt": "2020-03-11T14:09:26Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+@Fork(value = 1)\n+@Warmup(iterations = 0)\n+public class ConcurrentAccessBenchmark {\n+    ConcurrentAccessExperiment accessMyMap;", "originalCommit": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyOTUzNg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391129536", "bodyText": "Now both are inited on test call", "author": "mguarnaccia", "createdAt": "2020-03-11T17:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5NjUxMg=="}], "type": "inlineReview", "revised_code": {"commit": "1faabdd643e3dcfc32f4ecec2000614a158a8e36", "chunk": "diff --git a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\nindex 7c84c39804..4dfbd8ea18 100644\n--- a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\n+++ b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\n\n@@ -1,5 +1,7 @@\n package com.baeldung.concurrent.lock;\n \n+import java.util.HashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n import org.openjdk.jmh.annotations.Benchmark;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5NzM3Nw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r390997377", "bodyText": "The JMH documentation states that benchmark methods should return a value in order to protect against dead code elimination. Maybe doWork could return the resulting Map.", "author": "jzheaux", "createdAt": "2020-03-11T14:10:40Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+@Fork(value = 1)\n+@Warmup(iterations = 0)\n+public class ConcurrentAccessBenchmark {\n+    ConcurrentAccessExperiment accessMyMap;\n+    static final int SLOTS = 4;\n+    static final int THREADS = 10000;\n+    static final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+\n+    @Param({\"Single Lock\", \"Striped Lock\"})\n+    private String lockType;\n+\n+    @Param({\"HashMap\", \"ConcurrentHashMap\"})\n+    private String mapType;\n+\n+    @Setup\n+    public void setup() {\n+        switch (lockType) {\n+            case \"Single Lock\":\n+                accessMyMap = new SingleLock();\n+                break;\n+            case \"Striped Lock\":\n+                accessMyMap = new StripedLock(BUCKETS);\n+                break;\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public void test() throws InterruptedException {", "originalCommit": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEzMjk4Mw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391132983", "bodyText": "Done!", "author": "mguarnaccia", "createdAt": "2020-03-11T17:17:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5NzM3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "1faabdd643e3dcfc32f4ecec2000614a158a8e36", "chunk": "diff --git a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\nindex 7c84c39804..4dfbd8ea18 100644\n--- a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\n+++ b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\n\n@@ -1,5 +1,7 @@\n package com.baeldung.concurrent.lock;\n \n+import java.util.HashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n import org.openjdk.jmh.annotations.Benchmark;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwMDQ5Ng==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391000496", "bodyText": "I believe that having more than one benchmark method would simplify both ConcurrentAccessBenchmark and ConcurrentAccessExperiment. For example:\n@Benchmark\npublic Map<String, String> singleLockHashMap() {\n    return this.single.doWork(new HashMap<>(), THREADS, SLOTS);\n}\n\n@Benchmark\npublic Map<String, String> stripedLockHashMap() {\n    return this.striped.doWork(new HashMap<>(), THREADS, SLOTS);\n}\n\n@Benchmark\npublic Map<String, String> singleLockConcurrentHashMap() {\n    return this.single.doWork(new ConcurrentHashMap<>(), THREADS, SLOTS);\n}\n\n@Benchmark\npublic Map<String, String> stripedLockConcurrentHashMap() {\n    return this.striped.doWork(new ConcurrentHashMap<>(), THREADS, SLOTS);\n}\nThen, you wouldn't need the setup method in this class nor in the experiment class. You could also then remove the lockType parameter and wouldn't need a direct reference to ConcurrentAccessExperiment.", "author": "jzheaux", "createdAt": "2020-03-11T14:14:49Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+@Fork(value = 1)\n+@Warmup(iterations = 0)\n+public class ConcurrentAccessBenchmark {\n+    ConcurrentAccessExperiment accessMyMap;\n+    static final int SLOTS = 4;\n+    static final int THREADS = 10000;\n+    static final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+\n+    @Param({\"Single Lock\", \"Striped Lock\"})\n+    private String lockType;\n+\n+    @Param({\"HashMap\", \"ConcurrentHashMap\"})\n+    private String mapType;\n+\n+    @Setup\n+    public void setup() {\n+        switch (lockType) {\n+            case \"Single Lock\":\n+                accessMyMap = new SingleLock();\n+                break;\n+            case \"Striped Lock\":\n+                accessMyMap = new StripedLock(BUCKETS);\n+                break;\n+        }\n+    }\n+\n+    @Benchmark", "originalCommit": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEzMTAwNQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391131005", "bodyText": "Done!", "author": "mguarnaccia", "createdAt": "2020-03-11T17:13:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwMDQ5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "1faabdd643e3dcfc32f4ecec2000614a158a8e36", "chunk": "diff --git a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\nindex 7c84c39804..4dfbd8ea18 100644\n--- a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\n+++ b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\n\n@@ -1,5 +1,7 @@\n package com.baeldung.concurrent.lock;\n \n+import java.util.HashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n import org.openjdk.jmh.annotations.Benchmark;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwMDcxMg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391000712", "bodyText": "Let's remove this since it's redundant", "author": "jzheaux", "createdAt": "2020-03-11T14:15:07Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessExperiment.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import com.google.common.base.Supplier;\n+\n+public abstract class ConcurrentAccessExperiment {\n+\n+    public ConcurrentAccessExperiment() {", "originalCommit": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEzMTEwMw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391131103", "bodyText": "Done", "author": "mguarnaccia", "createdAt": "2020-03-11T17:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwMDcxMg=="}], "type": "inlineReview", "revised_code": {"commit": "1faabdd643e3dcfc32f4ecec2000614a158a8e36", "chunk": "diff --git a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessExperiment.java b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessExperiment.java\nindex b1276410ce..ec6d3895da 100644\n--- a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessExperiment.java\n+++ b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessExperiment.java\n\n@@ -1,30 +1,14 @@\n package com.baeldung.concurrent.lock;\n \n-import java.util.HashMap;\n import java.util.Map;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n \n import com.google.common.base.Supplier;\n \n public abstract class ConcurrentAccessExperiment {\n \n-    public ConcurrentAccessExperiment() {\n-    }\n-\n-    private Map<String,String> doMapSetup(String typeOfMap) {\n-        switch (typeOfMap) {\n-            case \"HashMap\":\n-                return new HashMap<String,String>();\n-            case \"ConcurrentHashMap\":\n-                return new ConcurrentHashMap<String,String>();\n-        }\n-        return null;\n-    }\n-\n-    public final void doWork(String typeOfMap, int threads, int slots) {\n+    public final Map<String,String> doWork(Map<String,String> map, int threads, int slots) {\n         CompletableFuture<?>[] requests = new CompletableFuture<?>[threads * slots];\n-        Map<String,String> map = doMapSetup(typeOfMap);\n \n         for (int i = 0; i < threads; i++) {\n             requests[slots * i + 0] = CompletableFuture.supplyAsync(putSupplier(map, i));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwMTU0MQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391001541", "bodyText": "Why not simply use lock.lock()? That seems to be the default suggestion from the JavaDoc.", "author": "jzheaux", "createdAt": "2020-03-11T14:16:12Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import com.google.common.base.Supplier;\n+\n+public class SingleLock extends ConcurrentAccessExperiment {\n+    ReentrantLock lock;\n+\n+    public SingleLock() {\n+        lock = new ReentrantLock();\n+    }\n+\n+    protected synchronized Supplier<?> putSupplier(Map<String,String> map, int key) {\n+        return (()-> {\n+            boolean done = false;\n+            try {\n+                while(!done) {", "originalCommit": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMzM4NQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391203385", "bodyText": "done, but I had to replicate the behavior in both *Lock classes", "author": "mguarnaccia", "createdAt": "2020-03-11T19:14:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwMTU0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e0058789fbdaf60da758b1b49ea45067bfa78746", "chunk": "diff --git a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java\nindex 8a3106f650..84a82baff2 100644\n--- a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java\n+++ b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java\n\n@@ -14,30 +14,30 @@ public class SingleLock extends ConcurrentAccessExperiment {\n \n     protected synchronized Supplier<?> putSupplier(Map<String,String> map, int key) {\n         return (()-> {\n-            boolean done = false;\n             try {\n-                while(!done) {\n-                    done = lock.tryLock();\n-                }\n+                lock.lock();\n                 map.put(\"key\" + key, \"value\" + key);\n+            } catch (Exception e) {\n+                this.putSupplier(map, key);\n             } finally {\n-                lock.unlock();\n-            }\n+                try {\n+                    lock.unlock();\n+                } catch (Exception e) {}            }\n             return null;\n         });\n     }\n \n     protected synchronized Supplier<?> getSupplier(Map<String,String> map, int key) {\n         return (()-> {\n-            boolean done = false;\n             try {\n-                while(!done) {\n-                \tdone = lock.tryLock();\n-                }\n+                lock.lock();\n                 map.get(\"key\" + key);\n+            } catch (Exception e) {\n+                this.getSupplier(map, key);\n             } finally {\n-                lock.unlock();\n-            }\n+                try {\n+                    lock.unlock();\n+                } catch (Exception e) {}            }\n             return null;\n         });\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwNDk5OQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391004999", "bodyText": "I'm not sure I understand the point of these methods being synchronized if they are using programmatic locks. I've always understood that these are alternatives - you can use locks instead of synchronized as an optimization.", "author": "jzheaux", "createdAt": "2020-03-11T14:20:46Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import com.google.common.base.Supplier;\n+\n+public class SingleLock extends ConcurrentAccessExperiment {\n+    ReentrantLock lock;\n+\n+    public SingleLock() {\n+        lock = new ReentrantLock();\n+    }\n+\n+    protected synchronized Supplier<?> putSupplier(Map<String,String> map, int key) {", "originalCommit": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMzAzNw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391203037", "bodyText": "ok, it was added from a previous thread we had. removed now.", "author": "mguarnaccia", "createdAt": "2020-03-11T19:13:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwNDk5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e0058789fbdaf60da758b1b49ea45067bfa78746", "chunk": "diff --git a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java\nindex 8a3106f650..84a82baff2 100644\n--- a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java\n+++ b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java\n\n@@ -14,30 +14,30 @@ public class SingleLock extends ConcurrentAccessExperiment {\n \n     protected synchronized Supplier<?> putSupplier(Map<String,String> map, int key) {\n         return (()-> {\n-            boolean done = false;\n             try {\n-                while(!done) {\n-                    done = lock.tryLock();\n-                }\n+                lock.lock();\n                 map.put(\"key\" + key, \"value\" + key);\n+            } catch (Exception e) {\n+                this.putSupplier(map, key);\n             } finally {\n-                lock.unlock();\n-            }\n+                try {\n+                    lock.unlock();\n+                } catch (Exception e) {}            }\n             return null;\n         });\n     }\n \n     protected synchronized Supplier<?> getSupplier(Map<String,String> map, int key) {\n         return (()-> {\n-            boolean done = false;\n             try {\n-                while(!done) {\n-                \tdone = lock.tryLock();\n-                }\n+                lock.lock();\n                 map.get(\"key\" + key);\n+            } catch (Exception e) {\n+                this.getSupplier(map, key);\n             } finally {\n-                lock.unlock();\n-            }\n+                try {\n+                    lock.unlock();\n+                } catch (Exception e) {}            }\n             return null;\n         });\n     }\n"}}, {"oid": "1faabdd643e3dcfc32f4ecec2000614a158a8e36", "url": "https://github.com/eugenp/tutorials/commit/1faabdd643e3dcfc32f4ecec2000614a158a8e36", "message": "BAEL-3855", "committedDate": "2020-03-11T17:18:05Z", "type": "commit"}, {"oid": "e0058789fbdaf60da758b1b49ea45067bfa78746", "url": "https://github.com/eugenp/tutorials/commit/e0058789fbdaf60da758b1b49ea45067bfa78746", "message": "BAEL-3855", "committedDate": "2020-03-11T18:56:30Z", "type": "commit"}, {"oid": "7b403992993f8d27532141c372a0e0811d1875ac", "url": "https://github.com/eugenp/tutorials/commit/7b403992993f8d27532141c372a0e0811d1875ac", "message": "BAEL-3855", "committedDate": "2020-03-11T19:09:14Z", "type": "commit"}, {"oid": "2892b138ee99616983a67d7fbb2ec4c3c0358ef6", "url": "https://github.com/eugenp/tutorials/commit/2892b138ee99616983a67d7fbb2ec4c3c0358ef6", "message": "BAEL-3855\n\nidentation", "committedDate": "2020-03-11T19:13:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3Mzk4Mw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392273983", "bodyText": "Wouldn't this be an infinite loop? Seems risky to just infinitely try again. I'd recommend doing:\nlock.lock();\ntry {\n    return map.put(\"key\" + key, \"value\" + key);\n} finally {\n    lock.unlock();\n}\nThis is what the JavaDoc recommends.\nAlso, if you return the result of map.put, then you don't need the extra return null; at the bottom.", "author": "jzheaux", "createdAt": "2020-03-13T14:48:07Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import com.google.common.base.Supplier;\n+\n+public class SingleLock extends ConcurrentAccessExperiment {\n+    ReentrantLock lock;\n+\n+    public SingleLock() {\n+        lock = new ReentrantLock();\n+    }\n+\n+    protected Supplier<?> putSupplier(Map<String,String> map, int key) {\n+        return (()-> {\n+            try {\n+                lock.lock();\n+                map.put(\"key\" + key, \"value\" + key);\n+            } catch (Exception e) {\n+                this.putSupplier(map, key);", "originalCommit": "2892b138ee99616983a67d7fbb2ec4c3c0358ef6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4Mjc2Mg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392282762", "bodyText": "Well, what if the lock is not acquired? the thread won't execute and we lose a put/get", "author": "mguarnaccia", "createdAt": "2020-03-13T15:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3Mzk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU5NzMwMg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392597302", "bodyText": "lock will block until the lock is acquired. From the JavaDoc:\n\nIf the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one.", "author": "jzheaux", "createdAt": "2020-03-14T15:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3Mzk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU5NzU1NA==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392597554", "bodyText": "The thread will block until the lock is acquired. From the JavaDoc:\n\nIf the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one.\n\nI guess the question I have is, what is so different about this use case that we'd deviate from the JavaDoc?", "author": "jzheaux", "createdAt": "2020-03-14T15:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3Mzk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY2NTM5Nw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392665397", "bodyText": "Ok", "author": "mguarnaccia", "createdAt": "2020-03-15T11:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3Mzk4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "34bfe41cd9eeae716b258d14d9c0236b15878dec", "chunk": "diff --git a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java\nindex 9bbac82c6d..762053c4c9 100644\n--- a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java\n+++ b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java\n\n@@ -17,12 +17,8 @@ public class SingleLock extends ConcurrentAccessExperiment {\n             try {\n                 lock.lock();\n                 map.put(\"key\" + key, \"value\" + key);\n-            } catch (Exception e) {\n-                this.putSupplier(map, key);\n             } finally {\n-                try {\n-                    lock.unlock();\n-                } catch (Exception e) {}\n+                lock.unlock();\n             }\n             return null;\n         });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NTEzMA==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392275130", "bodyText": "Please check the indentation here.", "author": "jzheaux", "createdAt": "2020-03-13T14:49:55Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/StripedLock.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.locks.Lock;\n+\n+import com.google.common.base.Supplier;\n+import com.google.common.util.concurrent.Striped;\n+\n+public class StripedLock extends ConcurrentAccessExperiment {\n+    Striped<Lock> stripedLock;\n+\n+    public StripedLock(int buckets) {\n+        stripedLock = Striped.lock(buckets);\n+    }\n+\n+    protected Supplier<?> putSupplier(Map<String,String> map, int key) {\n+        return (()-> {\n+        \tint bucket = key % stripedLock.size();", "originalCommit": "2892b138ee99616983a67d7fbb2ec4c3c0358ef6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI5OTAxMA==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392299010", "bodyText": "Done", "author": "mguarnaccia", "createdAt": "2020-03-13T15:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NTEzMA=="}], "type": "inlineReview", "revised_code": {"commit": "d04b0f30b6094ad647200e4ca32f8294400bd1ea", "chunk": "diff --git a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/StripedLock.java b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/StripedLock.java\nindex 8b661ecedc..46610c3b78 100644\n--- a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/StripedLock.java\n+++ b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/StripedLock.java\n\n@@ -15,7 +15,7 @@ public class StripedLock extends ConcurrentAccessExperiment {\n \n     protected Supplier<?> putSupplier(Map<String,String> map, int key) {\n         return (()-> {\n-        \tint bucket = key % stripedLock.size();\n+            int bucket = key % stripedLock.size();\n             Lock lock = stripedLock.get(bucket);\n             try {\n                 lock.tryLock();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NjM2NQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392276365", "bodyText": "I don't understand why you are re-instantiated the object each time. Won't that play into your results?\nIt seems like what you want to do is just reuse one already instantiated at the field level. That way, your benchmark is only about the work being done on the map and not about that plus the cost of instantiating the worker object.", "author": "jzheaux", "createdAt": "2020-03-13T14:51:49Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+@Fork(value = 2)\n+@Warmup(iterations = 0)\n+public class ConcurrentAccessBenchmark {\n+    ConcurrentAccessExperiment accessMyMap;\n+    static final int SLOTS = 4;\n+    static final int THREADS = 10000;\n+    static final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public void singleLockHashMap() throws InterruptedException {\n+        (new SingleLock()).doWork(new HashMap<String,String>(), THREADS, SLOTS);", "originalCommit": "2892b138ee99616983a67d7fbb2ec4c3c0358ef6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI5NTY3Mg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392295672", "bodyText": "I'm sorry but I don't get the point. Instantiating the object is not such a big cost, also it appears in every test. If we want to instantiate the maps before, we should also remove the \"put\" phase inside the test.", "author": "mguarnaccia", "createdAt": "2020-03-13T15:22:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NjM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU5NzQ0Mg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392597442", "bodyText": "To be clear, I'm only referring to new SingleLock() and by association new StripedLock().\nThe reason we should remove the instantiation is that it is unnecessary. What are you gaining from instantiating it here? AFAICT, each test doesn't need its own instance in order to give correct results.", "author": "jzheaux", "createdAt": "2020-03-14T15:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NjM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY2NDUwNw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392664507", "bodyText": "Ok", "author": "mguarnaccia", "createdAt": "2020-03-15T11:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NjM2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d04b0f30b6094ad647200e4ca32f8294400bd1ea", "chunk": "diff --git a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\nindex 4dfbd8ea18..2dcaa5cb53 100644\n--- a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\n+++ b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\n\n@@ -3,6 +3,7 @@ package com.baeldung.concurrent.lock;\n import java.util.HashMap;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n+import java.util.Map;\n \n import org.openjdk.jmh.annotations.Benchmark;\n import org.openjdk.jmh.annotations.BenchmarkMode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NjUzNQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392276535", "bodyText": "These need to return values, in accordance with JMH's guidelines.", "author": "jzheaux", "createdAt": "2020-03-13T14:52:06Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+@Fork(value = 2)\n+@Warmup(iterations = 0)\n+public class ConcurrentAccessBenchmark {\n+    ConcurrentAccessExperiment accessMyMap;\n+    static final int SLOTS = 4;\n+    static final int THREADS = 10000;\n+    static final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public void singleLockHashMap() throws InterruptedException {", "originalCommit": "2892b138ee99616983a67d7fbb2ec4c3c0358ef6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI5NzgxOA==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392297818", "bodyText": "Sorry, I only changed the doWork method. I'll fix it.", "author": "mguarnaccia", "createdAt": "2020-03-13T15:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NjUzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "d04b0f30b6094ad647200e4ca32f8294400bd1ea", "chunk": "diff --git a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\nindex 4dfbd8ea18..2dcaa5cb53 100644\n--- a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\n+++ b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java\n\n@@ -3,6 +3,7 @@ package com.baeldung.concurrent.lock;\n import java.util.HashMap;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n+import java.util.Map;\n \n import org.openjdk.jmh.annotations.Benchmark;\n import org.openjdk.jmh.annotations.BenchmarkMode;\n"}}, {"oid": "d04b0f30b6094ad647200e4ca32f8294400bd1ea", "url": "https://github.com/eugenp/tutorials/commit/d04b0f30b6094ad647200e4ca32f8294400bd1ea", "message": "BAEL-3855", "committedDate": "2020-03-13T15:33:34Z", "type": "commit"}, {"oid": "34bfe41cd9eeae716b258d14d9c0236b15878dec", "url": "https://github.com/eugenp/tutorials/commit/34bfe41cd9eeae716b258d14d9c0236b15878dec", "message": "BAEL-3855", "committedDate": "2020-03-15T11:50:43Z", "type": "commit"}, {"oid": "22b51db880fdd7ca547f566ace3ddd927f2adeaf", "url": "https://github.com/eugenp/tutorials/commit/22b51db880fdd7ca547f566ace3ddd927f2adeaf", "message": "BAEL-3855", "committedDate": "2020-03-15T12:04:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc4MTQ0Nw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r393781447", "bodyText": "We don't want to lock inside the try (see the JavaDoc). The reason is that if lock.lock() did in fact throw a RuntimeException, then the unlock could cause some unexpected results (since it's re-entrant, it could unlock one more level than intended, for example).", "author": "jzheaux", "createdAt": "2020-03-17T15:50:38Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import com.google.common.base.Supplier;\n+\n+public class SingleLock extends ConcurrentAccessExperiment {\n+    ReentrantLock lock;\n+\n+    public SingleLock() {\n+        lock = new ReentrantLock();\n+    }\n+\n+    protected Supplier<?> putSupplier(Map<String,String> map, int key) {\n+        return (()-> {\n+            try {\n+                lock.lock();", "originalCommit": "22b51db880fdd7ca547f566ace3ddd927f2adeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIwMzMzMg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r394203332", "bodyText": "Ok!", "author": "mguarnaccia", "createdAt": "2020-03-18T09:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc4MTQ0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "9140283ca2f8c9d8d2e191825dadce46bb8f0089", "chunk": "diff --git a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java\nindex 19b3ba4510..4dff459df6 100644\n--- a/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java\n+++ b/core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java\n\n@@ -14,8 +14,8 @@ public class SingleLock extends ConcurrentAccessExperiment {\n \n     protected Supplier<?> putSupplier(Map<String,String> map, int key) {\n         return (()-> {\n+            lock.lock();\n             try {\n-                lock.lock();\n                 return map.put(\"key\" + key, \"value\" + key);\n             } finally {\n                 lock.unlock();\n"}}, {"oid": "9140283ca2f8c9d8d2e191825dadce46bb8f0089", "url": "https://github.com/eugenp/tutorials/commit/9140283ca2f8c9d8d2e191825dadce46bb8f0089", "message": "BAEL-3855", "committedDate": "2020-03-18T09:18:58Z", "type": "commit"}]}