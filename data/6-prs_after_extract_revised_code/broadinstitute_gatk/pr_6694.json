{"pr_number": 6694, "pr_title": "add microbial mode", "pr_createdAt": "2020-07-02T20:07:45Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6694", "timeline": [{"oid": "7dc51cd8d9360cb2b10ccca5ee033bf29dbfeea6", "url": "https://github.com/broadinstitute/gatk/commit/7dc51cd8d9360cb2b10ccca5ee033bf29dbfeea6", "message": "add microbial mode", "committedDate": "2020-10-01T14:18:08Z", "type": "forcePushed"}, {"oid": "4c6f006fbdbf18b69c3c46b5cc4037488fd21c4b", "url": "https://github.com/broadinstitute/gatk/commit/4c6f006fbdbf18b69c3c46b5cc4037488fd21c4b", "message": "add microbial mode", "committedDate": "2020-11-17T14:52:45Z", "type": "forcePushed"}, {"oid": "ff60e320f857fb45ad04eda380dbb9f072568f86", "url": "https://github.com/broadinstitute/gatk/commit/ff60e320f857fb45ad04eda380dbb9f072568f86", "message": "manual rebase", "committedDate": "2020-11-17T15:35:49Z", "type": "forcePushed"}, {"oid": "9690dac82192ab6e8199330adddb813e7064fd30", "url": "https://github.com/broadinstitute/gatk/commit/9690dac82192ab6e8199330adddb813e7064fd30", "message": "manual rebase", "committedDate": "2021-01-26T16:31:39Z", "type": "forcePushed"}, {"oid": "4acfd7a593e7b6d305f663bd3cdf085bdfcd3d19", "url": "https://github.com/broadinstitute/gatk/commit/4acfd7a593e7b6d305f663bd3cdf085bdfcd3d19", "message": "manual rebase", "committedDate": "2021-01-26T19:16:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc3NzI5OA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r564777298", "bodyText": "I would recommend removing the changes to this class since they are holdovers from before the rebase of the dangling head branch.", "author": "jamesemery", "createdAt": "2021-01-26T19:32:00Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/AbstractReadThreadingGraph.java", "diffHunk": "@@ -594,25 +594,25 @@ int mergeDanglingHeadLegacy(final DanglingChainMergeHelper danglingHeadMergeResu\n \n         final List<CigarElement> elements = danglingHeadMergeResult.cigar.getCigarElements();\n         final CigarElement firstElement = elements.get(0);\n-        Utils.validateArg(firstElement.getOperator() == CigarOperator.M, \"The first Cigar element must be an M\");", "originalCommit": "4acfd7a593e7b6d305f663bd3cdf085bdfcd3d19", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f39bee1600efd798400dfedcb3aeb107eaa577b", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/AbstractReadThreadingGraph.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/AbstractReadThreadingGraph.java\nindex ff8f3b300..f440285d9 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/AbstractReadThreadingGraph.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/AbstractReadThreadingGraph.java\n\n@@ -594,7 +594,6 @@ public abstract class AbstractReadThreadingGraph extends BaseGraph<MultiDeBruijn\n \n         final List<CigarElement> elements = danglingHeadMergeResult.cigar.getCigarElements();\n         final CigarElement firstElement = elements.get(0);\n-        Utils.validateArg( firstElement.getOperator() == CigarOperator.M, \"The first Cigar element must be an M\");\n \n         final int indexesToMerge = bestPrefixMatchLegacy(danglingHeadMergeResult.referencePathString, danglingHeadMergeResult.danglingPathString, firstElement.getLength());\n         if (indexesToMerge <= 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyMjgzMA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570422830", "bodyText": "Thank you for correcting this spelling error... i have no idea how that could have happened in the first place...", "author": "jamesemery", "createdAt": "2021-02-04T17:47:28Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/ReadThreadingGraphUnitTest.java", "diffHunk": "@@ -293,7 +293,7 @@ public void testDanglingTails(final String refEnd,\n         final GATKRead read = ArtificialReadUtils.createArtificialRead(alt.getBytes(), Utils.dupBytes((byte) 30, alt.length()), alt.length() + \"M\");\n         final SAMFileHeader header = ArtificialReadUtils.createArtificialSamHeader();\n         rtgraph.addRead(read, header);\n-        rtgraph.setMinMatchingBasesToDangingEndRecovery(numLeadingMatchesAllowed);", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/ReadThreadingGraphUnitTest.java b/src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/ReadThreadingGraphUnitTest.java\nindex db8126453..61d09dca9 100644\n--- a/src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/ReadThreadingGraphUnitTest.java\n+++ b/src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/ReadThreadingGraphUnitTest.java\n\n@@ -293,7 +293,7 @@ public final class ReadThreadingGraphUnitTest extends GATKBaseTest {\n         final GATKRead read = ArtificialReadUtils.createArtificialRead(alt.getBytes(), Utils.dupBytes((byte) 30, alt.length()), alt.length() + \"M\");\n         final SAMFileHeader header = ArtificialReadUtils.createArtificialSamHeader();\n         rtgraph.addRead(read, header);\n-        rtgraph.setMinMatchingBasesToDanglingEndRecovery(numLeadingMatchesAllowed);\n+        rtgraph.setMinMatchingBasesToDangingEndRecovery(numLeadingMatchesAllowed);\n         rtgraph.buildGraphIfNecessary();\n \n         // confirm that we have just a single dangling tail\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNTI0Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570425247", "bodyText": "it looks like there might still be some code leftover in this class as a result of the rebase... Can you try resetting this class and make sure the only change is the misspelled argument that you fixed?", "author": "jamesemery", "createdAt": "2021-02-04T17:50:39Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/AbstractReadThreadingGraph.java", "diffHunk": "@@ -594,25 +594,24 @@ int mergeDanglingHeadLegacy(final DanglingChainMergeHelper danglingHeadMergeResu\n \n         final List<CigarElement> elements = danglingHeadMergeResult.cigar.getCigarElements();\n         final CigarElement firstElement = elements.get(0);\n-        Utils.validateArg(firstElement.getOperator() == CigarOperator.M, \"The first Cigar element must be an M\");\n \n         final int indexesToMerge = bestPrefixMatchLegacy(danglingHeadMergeResult.referencePathString, danglingHeadMergeResult.danglingPathString, firstElement.getLength());\n         if (indexesToMerge <= 0) {\n             return 0;\n         }\n \n         // we can't push back the reference path\n-        if (indexesToMerge >= danglingHeadMergeResult.referencePath.size() - 1) {\n+        if ( indexesToMerge >= danglingHeadMergeResult.referencePath.size() - 1 ) {\n             return 0;\n         }\n \n         // but we can manipulate the dangling path if we need to\n-        if (indexesToMerge >= danglingHeadMergeResult.danglingPath.size() &&\n-                !extendDanglingPathAgainstReference(danglingHeadMergeResult, indexesToMerge - danglingHeadMergeResult.danglingPath.size() + 2)) {\n+        if ( indexesToMerge >= danglingHeadMergeResult.danglingPath.size() &&\n+                ! extendDanglingPathAgainstReference(danglingHeadMergeResult, indexesToMerge - danglingHeadMergeResult.danglingPath.size() + 2) ) {\n             return 0;\n         }\n \n-        addEdge(danglingHeadMergeResult.referencePath.get(indexesToMerge + 1), danglingHeadMergeResult.danglingPath.get(indexesToMerge), ((MyEdgeFactory) getEdgeFactory()).createEdge(false, 1));\n+        addEdge(danglingHeadMergeResult.referencePath.get(indexesToMerge), danglingHeadMergeResult.danglingPath.get(indexesToMerge), ((MyEdgeFactory)getEdgeFactory()).createEdge(false, 1));", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f39bee1600efd798400dfedcb3aeb107eaa577b", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/AbstractReadThreadingGraph.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/AbstractReadThreadingGraph.java\nindex 17eb384d1..f440285d9 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/AbstractReadThreadingGraph.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/AbstractReadThreadingGraph.java\n\n@@ -606,8 +606,8 @@ public abstract class AbstractReadThreadingGraph extends BaseGraph<MultiDeBruijn\n         }\n \n         // but we can manipulate the dangling path if we need to\n-        if ( indexesToMerge >= danglingHeadMergeResult.danglingPath.size() &&\n-                ! extendDanglingPathAgainstReference(danglingHeadMergeResult, indexesToMerge - danglingHeadMergeResult.danglingPath.size() + 2) ) {\n+        if (indexesToMerge >= danglingHeadMergeResult.danglingPath.size() &&\n+                !extendDanglingPathAgainstReference(danglingHeadMergeResult, indexesToMerge - danglingHeadMergeResult.danglingPath.size() + 2, elements)) {\n             return 0;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNjI2Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570426263", "bodyText": "Can you update this list to be comprehensive to all the changes?\nAlso were you not going to make this argument affect the graph code at all? I thought bacterial mode would want to use the new dangling end pruning code and that doesn't seem to be linked to microbial mode at all.", "author": "jamesemery", "createdAt": "2021-02-04T17:52:11Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java", "diffHunk": "@@ -43,6 +43,13 @@\n     @Argument(fullName = M2ArgumentCollection.MITOCHONDRIA_MODE_LONG_NAME, optional = true, doc = \"Set filters to mitochondrial defaults\")\n     public boolean mitochondria = false;\n \n+    /**\n+     * Mitochondria mode excludes the filters {@link ClusteredEventsFilter}, {@link MultiallelicFilter},", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNjU4NA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570426584", "bodyText": "This also doesn't refrence the median mapping wquality change.", "author": "jamesemery", "createdAt": "2021-02-04T17:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNjI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NDMwODg2Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r674308862", "bodyText": "right now that flag is specified in the wdl for microbial mutect. We may decide to add it to the code when using this mode in a later PR", "author": "ahaessly", "createdAt": "2021-07-21T20:18:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNjI2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java\nindex 91dc166ce..991693e67 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java\n\n@@ -43,13 +43,6 @@ public class M2FiltersArgumentCollection {\n     @Argument(fullName = M2ArgumentCollection.MITOCHONDRIA_MODE_LONG_NAME, optional = true, doc = \"Set filters to mitochondrial defaults\")\n     public boolean mitochondria = false;\n \n-    /**\n-     * Mitochondria mode excludes the filters {@link ClusteredEventsFilter}, {@link MultiallelicFilter},\n-     * {@link FilteredHaplotypeFilter}, {@link FragmentLengthFilter}, and {@link GermlineFilter}\n-     */\n-    @Argument(fullName = M2ArgumentCollection.MICROBIAL_MODE_LONG_NAME, optional = true, doc = \"Set filters to microbial defaults\")\n-    public boolean microbial = false;\n-\n \n     /**\n      * Hard filter thresholds\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNjcyNg==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570426726", "bodyText": "Why was this commented out?", "author": "jamesemery", "createdAt": "2021-02-04T17:52:55Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java", "diffHunk": "@@ -62,12 +69,13 @@\n     private static final int DEFAULT_MAX_ALT_ALLELES = 1;\n     private static final int DEFAULT_MIN_UNIQUE_ALT_READS = 0;\n     private static final int DEFAULT_MIN_MEDIAN_MAPPING_QUALITY = 30;\n+    private static final int DEFAULT_MIN_MEDIAN_MAPPING_QUALITY_FOR_MICROBIAL = 20;\n     private static final int DEFAULT_MIN_MEDIAN_BASE_QUALITY = 20;\n     private static final int DEFAULT_MAX_MEDIAN_FRAGMENT_LENGTH_DIFFERENCE = 10000;\n     private static final int DEFAULT_MIN_MEDIAN_READ_POSITION = 1;\n     private static final double DEFAULT_MAX_N_RATIO = Double.POSITIVE_INFINITY;\n     private static final int DEFAULT_MIN_READS_ON_EACH_STRAND = 0;\n-    private static final double DEFAULT_MAX_NUMT_FRACTION = 0.85;\n+//    private static final double DEFAULT_MAX_NUMT_FRACTION = 0.85;", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NDMwOTc4NA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r674309784", "bodyText": "This filter is no longer used. Clean up from microbial PR", "author": "ahaessly", "createdAt": "2021-07-21T20:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNjcyNg=="}], "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java\nindex 91dc166ce..991693e67 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java\n\n@@ -69,13 +62,12 @@ public class M2FiltersArgumentCollection {\n     private static final int DEFAULT_MAX_ALT_ALLELES = 1;\n     private static final int DEFAULT_MIN_UNIQUE_ALT_READS = 0;\n     private static final int DEFAULT_MIN_MEDIAN_MAPPING_QUALITY = 30;\n-    private static final int DEFAULT_MIN_MEDIAN_MAPPING_QUALITY_FOR_MICROBIAL = 20;\n     private static final int DEFAULT_MIN_MEDIAN_BASE_QUALITY = 20;\n     private static final int DEFAULT_MAX_MEDIAN_FRAGMENT_LENGTH_DIFFERENCE = 10000;\n     private static final int DEFAULT_MIN_MEDIAN_READ_POSITION = 1;\n     private static final double DEFAULT_MAX_N_RATIO = Double.POSITIVE_INFINITY;\n     private static final int DEFAULT_MIN_READS_ON_EACH_STRAND = 0;\n-//    private static final double DEFAULT_MAX_NUMT_FRACTION = 0.85;\n+    private static final double DEFAULT_MAX_NUMT_FRACTION = 0.85;\n     private static final double DEFAULT_MIN_AF = 0;\n \n     @Argument(fullName = MAX_EVENTS_IN_REGION_LONG_NAME, optional = true, doc = \"Maximum events in a single assembly region.  Filter all variants if exceeded.\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzMDA1Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570430056", "bodyText": "A few questions about this tool? Does it do this operation on all contigs in the fasta? The documentation doesn't seem to specify that? Perhaps there should be a mechanism to update that.", "author": "jamesemery", "createdAt": "2021-02-04T17:57:21Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\ndeleted file mode 100644\nindex 6a6986c69..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.fasta;\n-\n-import htsjdk.samtools.SAMSequenceDictionary;\n-import htsjdk.samtools.SAMSequenceRecord;\n-import htsjdk.samtools.reference.FastaReferenceWriter;\n-import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n-import org.broadinstitute.barclay.help.DocumentedFeature;\n-import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n-import org.broadinstitute.hellbender.engine.GATKTool;\n-import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n-import picard.cmdline.programgroups.ReferenceProgramGroup;\n-\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.ListIterator;\n-\n-/**\n- * Create a fasta with the bases shifted by offset\n- *\n- * delta1 = offset - 1\n- * delta2 = total - delta1\n- *\n- * To shift forward:\n- * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n- * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n- *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n- *\n- * To shift back:\n- * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n- * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n- *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n- *\n- */\n-@DocumentedFeature\n-@CommandLineProgramProperties(\n-        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n-        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n-        programGroup = ReferenceProgramGroup.class\n-)\n-public class ShiftFasta extends GATKTool {\n-\n-    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n-            doc = \"Path to write the output fasta to\")\n-    protected String output;\n-\n-    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n-    @Argument(fullName = SHIFT_BACK_OUTPUT,\n-            doc = \"Path to write the shift_back file to\")\n-    protected String shiftBackOutput;\n-\n-    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n-    @Argument(fullName = SHIFT_OFFSET_LIST,\n-            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n-    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n-    private List<Integer> shiftOffsets = null;\n-\n-    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n-    @Argument(fullName = INTERAL_FILE_NAME,\n-            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n-    private String intervalFilename;\n-\n-    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n-    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n-    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n-\n-    ReferenceDataSource refSource;\n-    FastaReferenceWriter refWriter;\n-    FileWriter chainFileWriter;\n-    FileWriter intervalRegularWriter;\n-    FileWriter intervalShiftedWriter;\n-\n-    int chainId = 0;\n-\n-    @Override\n-    public boolean requiresReference() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void onTraversalStart() {\n-        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n-        final Path path = IOUtils.getPath(output);\n-        chainId = 1;\n-        try {\n-            refWriter = new FastaReferenceWriterBuilder()\n-                    .setFastaFile(path)\n-                    .setBasesPerLine(basesPerLine)\n-                    .build();\n-            chainFileWriter = new FileWriter(shiftBackOutput);\n-            if (intervalFilename != null) {\n-                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n-                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n-            }\n-        } catch (IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    public void traverse() {\n-        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n-        long refLengthLong = refDict.getReferenceLength();\n-        if (refLengthLong > Integer.MAX_VALUE) {\n-            // TODO fix this??\n-            throw new UserException.BadInput(\"Reference length is too long\");\n-        }\n-        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n-        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n-                shiftOffsets.listIterator() : null;\n-        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n-    }\n-\n-    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n-        int contigLength = seq.getSequenceLength();\n-        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n-        if (shiftOffset != 0) {\n-            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n-            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n-            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n-            int shiftBackOffset = bases.length - shiftOffset;\n-\n-            try {\n-                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n-                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n-                if (intervalFilename != null && shiftOffsetsIt == null) {\n-                    int intervalStart = shiftOffset/2;\n-                    int intervalEnd = intervalStart + contigLength/2 - 1;\n-                    int shiftedIntervalStart = intervalStart;\n-                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n-                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n-                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n-                }\n-            } catch (IOException e) {\n-                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-            }\n-        }\n-    }\n-\n-    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n-        String[] items = new String[] { \"chain\",\n-                Integer.toString(score),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(shiftBackStart),\n-                Integer.toString(shiftBackEnd),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(start),\n-                Integer.toString(end),\n-                Integer.toString(id)\n-        };\n-        return String.join(\"\\t\", items);\n-    }\n-\n-    @Override\n-    public Object onTraversalSuccess(){\n-        // TODO is this right?\n-        return null;\n-    }\n-\n-    @Override\n-    public void closeTool() {\n-        super.closeTool();\n-        try{\n-            if( refWriter != null ) {\n-                refWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (chainFileWriter != null) {\n-                chainFileWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write chain file due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (intervalRegularWriter != null) {\n-                intervalRegularWriter.close();\n-            }\n-            if (intervalShiftedWriter != null) {\n-                intervalShiftedWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write intervals due to \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzMzAxNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570433015", "bodyText": "Why are you catching the se IllegalStateExceptions?", "author": "jamesemery", "createdAt": "2021-02-04T18:01:18Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n+        int contigLength = seq.getSequenceLength();\n+        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n+        if (shiftOffset != 0) {\n+            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n+            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n+            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n+            int shiftBackOffset = bases.length - shiftOffset;\n+\n+            try {\n+                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n+                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n+                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n+                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n+                if (intervalFilename != null && shiftOffsetsIt == null) {\n+                    int intervalStart = shiftOffset/2;\n+                    int intervalEnd = intervalStart + contigLength/2 - 1;\n+                    int shiftedIntervalStart = intervalStart;\n+                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n+                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n+                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n+                }\n+            } catch (IOException e) {\n+                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n+        String[] items = new String[] { \"chain\",\n+                Integer.toString(score),\n+                name,\n+                Integer.toString(length),\n+                \"+\",\n+                Integer.toString(shiftBackStart),\n+                Integer.toString(shiftBackEnd),\n+                name,\n+                Integer.toString(length),\n+                \"+\",\n+                Integer.toString(start),\n+                Integer.toString(end),\n+                Integer.toString(id)\n+        };\n+        return String.join(\"\\t\", items);\n+    }\n+\n+    @Override\n+    public Object onTraversalSuccess(){\n+        // TODO is this right?\n+        return null;\n+    }\n+\n+    @Override\n+    public void closeTool() {\n+        super.closeTool();\n+        try{\n+            if( refWriter != null ) {\n+                refWriter.close();\n+            }\n+        } catch (IllegalStateException e){\n+            //sink this\n+        } catch (IOException e) {\n+            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n+        }\n+        try{\n+            if (chainFileWriter != null) {\n+                chainFileWriter.close();\n+            }\n+        } catch (IllegalStateException e){", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\ndeleted file mode 100644\nindex 6a6986c69..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.fasta;\n-\n-import htsjdk.samtools.SAMSequenceDictionary;\n-import htsjdk.samtools.SAMSequenceRecord;\n-import htsjdk.samtools.reference.FastaReferenceWriter;\n-import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n-import org.broadinstitute.barclay.help.DocumentedFeature;\n-import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n-import org.broadinstitute.hellbender.engine.GATKTool;\n-import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n-import picard.cmdline.programgroups.ReferenceProgramGroup;\n-\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.ListIterator;\n-\n-/**\n- * Create a fasta with the bases shifted by offset\n- *\n- * delta1 = offset - 1\n- * delta2 = total - delta1\n- *\n- * To shift forward:\n- * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n- * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n- *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n- *\n- * To shift back:\n- * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n- * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n- *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n- *\n- */\n-@DocumentedFeature\n-@CommandLineProgramProperties(\n-        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n-        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n-        programGroup = ReferenceProgramGroup.class\n-)\n-public class ShiftFasta extends GATKTool {\n-\n-    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n-            doc = \"Path to write the output fasta to\")\n-    protected String output;\n-\n-    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n-    @Argument(fullName = SHIFT_BACK_OUTPUT,\n-            doc = \"Path to write the shift_back file to\")\n-    protected String shiftBackOutput;\n-\n-    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n-    @Argument(fullName = SHIFT_OFFSET_LIST,\n-            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n-    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n-    private List<Integer> shiftOffsets = null;\n-\n-    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n-    @Argument(fullName = INTERAL_FILE_NAME,\n-            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n-    private String intervalFilename;\n-\n-    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n-    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n-    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n-\n-    ReferenceDataSource refSource;\n-    FastaReferenceWriter refWriter;\n-    FileWriter chainFileWriter;\n-    FileWriter intervalRegularWriter;\n-    FileWriter intervalShiftedWriter;\n-\n-    int chainId = 0;\n-\n-    @Override\n-    public boolean requiresReference() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void onTraversalStart() {\n-        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n-        final Path path = IOUtils.getPath(output);\n-        chainId = 1;\n-        try {\n-            refWriter = new FastaReferenceWriterBuilder()\n-                    .setFastaFile(path)\n-                    .setBasesPerLine(basesPerLine)\n-                    .build();\n-            chainFileWriter = new FileWriter(shiftBackOutput);\n-            if (intervalFilename != null) {\n-                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n-                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n-            }\n-        } catch (IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    public void traverse() {\n-        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n-        long refLengthLong = refDict.getReferenceLength();\n-        if (refLengthLong > Integer.MAX_VALUE) {\n-            // TODO fix this??\n-            throw new UserException.BadInput(\"Reference length is too long\");\n-        }\n-        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n-        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n-                shiftOffsets.listIterator() : null;\n-        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n-    }\n-\n-    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n-        int contigLength = seq.getSequenceLength();\n-        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n-        if (shiftOffset != 0) {\n-            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n-            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n-            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n-            int shiftBackOffset = bases.length - shiftOffset;\n-\n-            try {\n-                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n-                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n-                if (intervalFilename != null && shiftOffsetsIt == null) {\n-                    int intervalStart = shiftOffset/2;\n-                    int intervalEnd = intervalStart + contigLength/2 - 1;\n-                    int shiftedIntervalStart = intervalStart;\n-                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n-                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n-                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n-                }\n-            } catch (IOException e) {\n-                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-            }\n-        }\n-    }\n-\n-    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n-        String[] items = new String[] { \"chain\",\n-                Integer.toString(score),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(shiftBackStart),\n-                Integer.toString(shiftBackEnd),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(start),\n-                Integer.toString(end),\n-                Integer.toString(id)\n-        };\n-        return String.join(\"\\t\", items);\n-    }\n-\n-    @Override\n-    public Object onTraversalSuccess(){\n-        // TODO is this right?\n-        return null;\n-    }\n-\n-    @Override\n-    public void closeTool() {\n-        super.closeTool();\n-        try{\n-            if( refWriter != null ) {\n-                refWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (chainFileWriter != null) {\n-                chainFileWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write chain file due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (intervalRegularWriter != null) {\n-                intervalRegularWriter.close();\n-            }\n-            if (intervalShiftedWriter != null) {\n-                intervalShiftedWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write intervals due to \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzNDQ5OA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570434498", "bodyText": "I would get rid of most of these try-catch blocks.", "author": "jamesemery", "createdAt": "2021-02-04T18:03:36Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n+        int contigLength = seq.getSequenceLength();\n+        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n+        if (shiftOffset != 0) {\n+            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n+            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n+            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n+            int shiftBackOffset = bases.length - shiftOffset;\n+\n+            try {\n+                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n+                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n+                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n+                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n+                if (intervalFilename != null && shiftOffsetsIt == null) {\n+                    int intervalStart = shiftOffset/2;\n+                    int intervalEnd = intervalStart + contigLength/2 - 1;\n+                    int shiftedIntervalStart = intervalStart;\n+                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n+                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n+                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n+                }\n+            } catch (IOException e) {\n+                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n+        String[] items = new String[] { \"chain\",\n+                Integer.toString(score),\n+                name,\n+                Integer.toString(length),\n+                \"+\",\n+                Integer.toString(shiftBackStart),\n+                Integer.toString(shiftBackEnd),\n+                name,\n+                Integer.toString(length),\n+                \"+\",\n+                Integer.toString(start),\n+                Integer.toString(end),\n+                Integer.toString(id)\n+        };\n+        return String.join(\"\\t\", items);\n+    }\n+\n+    @Override\n+    public Object onTraversalSuccess(){\n+        // TODO is this right?\n+        return null;\n+    }\n+\n+    @Override\n+    public void closeTool() {\n+        super.closeTool();\n+        try{\n+            if( refWriter != null ) {\n+                refWriter.close();\n+            }\n+        } catch (IllegalStateException e){\n+            //sink this", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\ndeleted file mode 100644\nindex 6a6986c69..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.fasta;\n-\n-import htsjdk.samtools.SAMSequenceDictionary;\n-import htsjdk.samtools.SAMSequenceRecord;\n-import htsjdk.samtools.reference.FastaReferenceWriter;\n-import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n-import org.broadinstitute.barclay.help.DocumentedFeature;\n-import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n-import org.broadinstitute.hellbender.engine.GATKTool;\n-import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n-import picard.cmdline.programgroups.ReferenceProgramGroup;\n-\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.ListIterator;\n-\n-/**\n- * Create a fasta with the bases shifted by offset\n- *\n- * delta1 = offset - 1\n- * delta2 = total - delta1\n- *\n- * To shift forward:\n- * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n- * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n- *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n- *\n- * To shift back:\n- * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n- * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n- *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n- *\n- */\n-@DocumentedFeature\n-@CommandLineProgramProperties(\n-        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n-        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n-        programGroup = ReferenceProgramGroup.class\n-)\n-public class ShiftFasta extends GATKTool {\n-\n-    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n-            doc = \"Path to write the output fasta to\")\n-    protected String output;\n-\n-    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n-    @Argument(fullName = SHIFT_BACK_OUTPUT,\n-            doc = \"Path to write the shift_back file to\")\n-    protected String shiftBackOutput;\n-\n-    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n-    @Argument(fullName = SHIFT_OFFSET_LIST,\n-            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n-    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n-    private List<Integer> shiftOffsets = null;\n-\n-    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n-    @Argument(fullName = INTERAL_FILE_NAME,\n-            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n-    private String intervalFilename;\n-\n-    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n-    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n-    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n-\n-    ReferenceDataSource refSource;\n-    FastaReferenceWriter refWriter;\n-    FileWriter chainFileWriter;\n-    FileWriter intervalRegularWriter;\n-    FileWriter intervalShiftedWriter;\n-\n-    int chainId = 0;\n-\n-    @Override\n-    public boolean requiresReference() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void onTraversalStart() {\n-        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n-        final Path path = IOUtils.getPath(output);\n-        chainId = 1;\n-        try {\n-            refWriter = new FastaReferenceWriterBuilder()\n-                    .setFastaFile(path)\n-                    .setBasesPerLine(basesPerLine)\n-                    .build();\n-            chainFileWriter = new FileWriter(shiftBackOutput);\n-            if (intervalFilename != null) {\n-                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n-                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n-            }\n-        } catch (IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    public void traverse() {\n-        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n-        long refLengthLong = refDict.getReferenceLength();\n-        if (refLengthLong > Integer.MAX_VALUE) {\n-            // TODO fix this??\n-            throw new UserException.BadInput(\"Reference length is too long\");\n-        }\n-        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n-        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n-                shiftOffsets.listIterator() : null;\n-        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n-    }\n-\n-    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n-        int contigLength = seq.getSequenceLength();\n-        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n-        if (shiftOffset != 0) {\n-            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n-            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n-            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n-            int shiftBackOffset = bases.length - shiftOffset;\n-\n-            try {\n-                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n-                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n-                if (intervalFilename != null && shiftOffsetsIt == null) {\n-                    int intervalStart = shiftOffset/2;\n-                    int intervalEnd = intervalStart + contigLength/2 - 1;\n-                    int shiftedIntervalStart = intervalStart;\n-                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n-                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n-                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n-                }\n-            } catch (IOException e) {\n-                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-            }\n-        }\n-    }\n-\n-    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n-        String[] items = new String[] { \"chain\",\n-                Integer.toString(score),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(shiftBackStart),\n-                Integer.toString(shiftBackEnd),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(start),\n-                Integer.toString(end),\n-                Integer.toString(id)\n-        };\n-        return String.join(\"\\t\", items);\n-    }\n-\n-    @Override\n-    public Object onTraversalSuccess(){\n-        // TODO is this right?\n-        return null;\n-    }\n-\n-    @Override\n-    public void closeTool() {\n-        super.closeTool();\n-        try{\n-            if( refWriter != null ) {\n-                refWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (chainFileWriter != null) {\n-                chainFileWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write chain file due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (intervalRegularWriter != null) {\n-                intervalRegularWriter.close();\n-            }\n-            if (intervalShiftedWriter != null) {\n-                intervalShiftedWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write intervals due to \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzNzE3Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570437176", "bodyText": "This method needs some comments.", "author": "jamesemery", "createdAt": "2021-02-04T18:07:35Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\ndeleted file mode 100644\nindex 6a6986c69..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.fasta;\n-\n-import htsjdk.samtools.SAMSequenceDictionary;\n-import htsjdk.samtools.SAMSequenceRecord;\n-import htsjdk.samtools.reference.FastaReferenceWriter;\n-import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n-import org.broadinstitute.barclay.help.DocumentedFeature;\n-import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n-import org.broadinstitute.hellbender.engine.GATKTool;\n-import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n-import picard.cmdline.programgroups.ReferenceProgramGroup;\n-\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.ListIterator;\n-\n-/**\n- * Create a fasta with the bases shifted by offset\n- *\n- * delta1 = offset - 1\n- * delta2 = total - delta1\n- *\n- * To shift forward:\n- * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n- * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n- *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n- *\n- * To shift back:\n- * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n- * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n- *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n- *\n- */\n-@DocumentedFeature\n-@CommandLineProgramProperties(\n-        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n-        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n-        programGroup = ReferenceProgramGroup.class\n-)\n-public class ShiftFasta extends GATKTool {\n-\n-    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n-            doc = \"Path to write the output fasta to\")\n-    protected String output;\n-\n-    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n-    @Argument(fullName = SHIFT_BACK_OUTPUT,\n-            doc = \"Path to write the shift_back file to\")\n-    protected String shiftBackOutput;\n-\n-    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n-    @Argument(fullName = SHIFT_OFFSET_LIST,\n-            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n-    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n-    private List<Integer> shiftOffsets = null;\n-\n-    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n-    @Argument(fullName = INTERAL_FILE_NAME,\n-            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n-    private String intervalFilename;\n-\n-    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n-    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n-    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n-\n-    ReferenceDataSource refSource;\n-    FastaReferenceWriter refWriter;\n-    FileWriter chainFileWriter;\n-    FileWriter intervalRegularWriter;\n-    FileWriter intervalShiftedWriter;\n-\n-    int chainId = 0;\n-\n-    @Override\n-    public boolean requiresReference() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void onTraversalStart() {\n-        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n-        final Path path = IOUtils.getPath(output);\n-        chainId = 1;\n-        try {\n-            refWriter = new FastaReferenceWriterBuilder()\n-                    .setFastaFile(path)\n-                    .setBasesPerLine(basesPerLine)\n-                    .build();\n-            chainFileWriter = new FileWriter(shiftBackOutput);\n-            if (intervalFilename != null) {\n-                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n-                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n-            }\n-        } catch (IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    public void traverse() {\n-        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n-        long refLengthLong = refDict.getReferenceLength();\n-        if (refLengthLong > Integer.MAX_VALUE) {\n-            // TODO fix this??\n-            throw new UserException.BadInput(\"Reference length is too long\");\n-        }\n-        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n-        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n-                shiftOffsets.listIterator() : null;\n-        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n-    }\n-\n-    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n-        int contigLength = seq.getSequenceLength();\n-        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n-        if (shiftOffset != 0) {\n-            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n-            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n-            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n-            int shiftBackOffset = bases.length - shiftOffset;\n-\n-            try {\n-                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n-                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n-                if (intervalFilename != null && shiftOffsetsIt == null) {\n-                    int intervalStart = shiftOffset/2;\n-                    int intervalEnd = intervalStart + contigLength/2 - 1;\n-                    int shiftedIntervalStart = intervalStart;\n-                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n-                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n-                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n-                }\n-            } catch (IOException e) {\n-                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-            }\n-        }\n-    }\n-\n-    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n-        String[] items = new String[] { \"chain\",\n-                Integer.toString(score),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(shiftBackStart),\n-                Integer.toString(shiftBackEnd),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(start),\n-                Integer.toString(end),\n-                Integer.toString(id)\n-        };\n-        return String.join(\"\\t\", items);\n-    }\n-\n-    @Override\n-    public Object onTraversalSuccess(){\n-        // TODO is this right?\n-        return null;\n-    }\n-\n-    @Override\n-    public void closeTool() {\n-        super.closeTool();\n-        try{\n-            if( refWriter != null ) {\n-                refWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (chainFileWriter != null) {\n-                chainFileWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write chain file due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (intervalRegularWriter != null) {\n-                intervalRegularWriter.close();\n-            }\n-            if (intervalShiftedWriter != null) {\n-                intervalShiftedWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write intervals due to \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzNzI4OA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570437288", "bodyText": "final", "author": "jamesemery", "createdAt": "2021-02-04T18:07:45Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n+        int contigLength = seq.getSequenceLength();", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\ndeleted file mode 100644\nindex 6a6986c69..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.fasta;\n-\n-import htsjdk.samtools.SAMSequenceDictionary;\n-import htsjdk.samtools.SAMSequenceRecord;\n-import htsjdk.samtools.reference.FastaReferenceWriter;\n-import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n-import org.broadinstitute.barclay.help.DocumentedFeature;\n-import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n-import org.broadinstitute.hellbender.engine.GATKTool;\n-import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n-import picard.cmdline.programgroups.ReferenceProgramGroup;\n-\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.ListIterator;\n-\n-/**\n- * Create a fasta with the bases shifted by offset\n- *\n- * delta1 = offset - 1\n- * delta2 = total - delta1\n- *\n- * To shift forward:\n- * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n- * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n- *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n- *\n- * To shift back:\n- * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n- * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n- *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n- *\n- */\n-@DocumentedFeature\n-@CommandLineProgramProperties(\n-        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n-        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n-        programGroup = ReferenceProgramGroup.class\n-)\n-public class ShiftFasta extends GATKTool {\n-\n-    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n-            doc = \"Path to write the output fasta to\")\n-    protected String output;\n-\n-    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n-    @Argument(fullName = SHIFT_BACK_OUTPUT,\n-            doc = \"Path to write the shift_back file to\")\n-    protected String shiftBackOutput;\n-\n-    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n-    @Argument(fullName = SHIFT_OFFSET_LIST,\n-            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n-    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n-    private List<Integer> shiftOffsets = null;\n-\n-    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n-    @Argument(fullName = INTERAL_FILE_NAME,\n-            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n-    private String intervalFilename;\n-\n-    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n-    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n-    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n-\n-    ReferenceDataSource refSource;\n-    FastaReferenceWriter refWriter;\n-    FileWriter chainFileWriter;\n-    FileWriter intervalRegularWriter;\n-    FileWriter intervalShiftedWriter;\n-\n-    int chainId = 0;\n-\n-    @Override\n-    public boolean requiresReference() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void onTraversalStart() {\n-        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n-        final Path path = IOUtils.getPath(output);\n-        chainId = 1;\n-        try {\n-            refWriter = new FastaReferenceWriterBuilder()\n-                    .setFastaFile(path)\n-                    .setBasesPerLine(basesPerLine)\n-                    .build();\n-            chainFileWriter = new FileWriter(shiftBackOutput);\n-            if (intervalFilename != null) {\n-                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n-                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n-            }\n-        } catch (IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    public void traverse() {\n-        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n-        long refLengthLong = refDict.getReferenceLength();\n-        if (refLengthLong > Integer.MAX_VALUE) {\n-            // TODO fix this??\n-            throw new UserException.BadInput(\"Reference length is too long\");\n-        }\n-        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n-        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n-                shiftOffsets.listIterator() : null;\n-        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n-    }\n-\n-    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n-        int contigLength = seq.getSequenceLength();\n-        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n-        if (shiftOffset != 0) {\n-            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n-            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n-            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n-            int shiftBackOffset = bases.length - shiftOffset;\n-\n-            try {\n-                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n-                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n-                if (intervalFilename != null && shiftOffsetsIt == null) {\n-                    int intervalStart = shiftOffset/2;\n-                    int intervalEnd = intervalStart + contigLength/2 - 1;\n-                    int shiftedIntervalStart = intervalStart;\n-                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n-                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n-                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n-                }\n-            } catch (IOException e) {\n-                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-            }\n-        }\n-    }\n-\n-    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n-        String[] items = new String[] { \"chain\",\n-                Integer.toString(score),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(shiftBackStart),\n-                Integer.toString(shiftBackEnd),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(start),\n-                Integer.toString(end),\n-                Integer.toString(id)\n-        };\n-        return String.join(\"\\t\", items);\n-    }\n-\n-    @Override\n-    public Object onTraversalSuccess(){\n-        // TODO is this right?\n-        return null;\n-    }\n-\n-    @Override\n-    public void closeTool() {\n-        super.closeTool();\n-        try{\n-            if( refWriter != null ) {\n-                refWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (chainFileWriter != null) {\n-                chainFileWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write chain file due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (intervalRegularWriter != null) {\n-                intervalRegularWriter.close();\n-            }\n-            if (intervalShiftedWriter != null) {\n-                intervalShiftedWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write intervals due to \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzODMyMw==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570438323", "bodyText": "I would pull this int a method \"writechainfileline(etc..)\"", "author": "jamesemery", "createdAt": "2021-02-04T18:09:13Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n+        int contigLength = seq.getSequenceLength();\n+        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n+        if (shiftOffset != 0) {\n+            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n+            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n+            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n+            int shiftBackOffset = bases.length - shiftOffset;\n+\n+            try {\n+                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n+                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\ndeleted file mode 100644\nindex 6a6986c69..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.fasta;\n-\n-import htsjdk.samtools.SAMSequenceDictionary;\n-import htsjdk.samtools.SAMSequenceRecord;\n-import htsjdk.samtools.reference.FastaReferenceWriter;\n-import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n-import org.broadinstitute.barclay.help.DocumentedFeature;\n-import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n-import org.broadinstitute.hellbender.engine.GATKTool;\n-import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n-import picard.cmdline.programgroups.ReferenceProgramGroup;\n-\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.ListIterator;\n-\n-/**\n- * Create a fasta with the bases shifted by offset\n- *\n- * delta1 = offset - 1\n- * delta2 = total - delta1\n- *\n- * To shift forward:\n- * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n- * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n- *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n- *\n- * To shift back:\n- * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n- * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n- *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n- *\n- */\n-@DocumentedFeature\n-@CommandLineProgramProperties(\n-        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n-        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n-        programGroup = ReferenceProgramGroup.class\n-)\n-public class ShiftFasta extends GATKTool {\n-\n-    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n-            doc = \"Path to write the output fasta to\")\n-    protected String output;\n-\n-    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n-    @Argument(fullName = SHIFT_BACK_OUTPUT,\n-            doc = \"Path to write the shift_back file to\")\n-    protected String shiftBackOutput;\n-\n-    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n-    @Argument(fullName = SHIFT_OFFSET_LIST,\n-            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n-    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n-    private List<Integer> shiftOffsets = null;\n-\n-    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n-    @Argument(fullName = INTERAL_FILE_NAME,\n-            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n-    private String intervalFilename;\n-\n-    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n-    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n-    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n-\n-    ReferenceDataSource refSource;\n-    FastaReferenceWriter refWriter;\n-    FileWriter chainFileWriter;\n-    FileWriter intervalRegularWriter;\n-    FileWriter intervalShiftedWriter;\n-\n-    int chainId = 0;\n-\n-    @Override\n-    public boolean requiresReference() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void onTraversalStart() {\n-        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n-        final Path path = IOUtils.getPath(output);\n-        chainId = 1;\n-        try {\n-            refWriter = new FastaReferenceWriterBuilder()\n-                    .setFastaFile(path)\n-                    .setBasesPerLine(basesPerLine)\n-                    .build();\n-            chainFileWriter = new FileWriter(shiftBackOutput);\n-            if (intervalFilename != null) {\n-                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n-                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n-            }\n-        } catch (IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    public void traverse() {\n-        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n-        long refLengthLong = refDict.getReferenceLength();\n-        if (refLengthLong > Integer.MAX_VALUE) {\n-            // TODO fix this??\n-            throw new UserException.BadInput(\"Reference length is too long\");\n-        }\n-        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n-        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n-                shiftOffsets.listIterator() : null;\n-        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n-    }\n-\n-    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n-        int contigLength = seq.getSequenceLength();\n-        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n-        if (shiftOffset != 0) {\n-            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n-            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n-            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n-            int shiftBackOffset = bases.length - shiftOffset;\n-\n-            try {\n-                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n-                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n-                if (intervalFilename != null && shiftOffsetsIt == null) {\n-                    int intervalStart = shiftOffset/2;\n-                    int intervalEnd = intervalStart + contigLength/2 - 1;\n-                    int shiftedIntervalStart = intervalStart;\n-                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n-                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n-                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n-                }\n-            } catch (IOException e) {\n-                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-            }\n-        }\n-    }\n-\n-    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n-        String[] items = new String[] { \"chain\",\n-                Integer.toString(score),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(shiftBackStart),\n-                Integer.toString(shiftBackEnd),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(start),\n-                Integer.toString(end),\n-                Integer.toString(id)\n-        };\n-        return String.join(\"\\t\", items);\n-    }\n-\n-    @Override\n-    public Object onTraversalSuccess(){\n-        // TODO is this right?\n-        return null;\n-    }\n-\n-    @Override\n-    public void closeTool() {\n-        super.closeTool();\n-        try{\n-            if( refWriter != null ) {\n-                refWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (chainFileWriter != null) {\n-                chainFileWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write chain file due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (intervalRegularWriter != null) {\n-                intervalRegularWriter.close();\n-            }\n-            if (intervalShiftedWriter != null) {\n-                intervalShiftedWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write intervals due to \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzOTc1MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570439751", "bodyText": "I would compartmentalize these writers into their own methods to make it a bit clearer and safer.", "author": "jamesemery", "createdAt": "2021-02-04T18:11:26Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n+        int contigLength = seq.getSequenceLength();\n+        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n+        if (shiftOffset != 0) {\n+            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n+            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n+            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n+            int shiftBackOffset = bases.length - shiftOffset;\n+\n+            try {\n+                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n+                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n+                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n+                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n+                if (intervalFilename != null && shiftOffsetsIt == null) {\n+                    int intervalStart = shiftOffset/2;", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\ndeleted file mode 100644\nindex 6a6986c69..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.fasta;\n-\n-import htsjdk.samtools.SAMSequenceDictionary;\n-import htsjdk.samtools.SAMSequenceRecord;\n-import htsjdk.samtools.reference.FastaReferenceWriter;\n-import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n-import org.broadinstitute.barclay.help.DocumentedFeature;\n-import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n-import org.broadinstitute.hellbender.engine.GATKTool;\n-import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n-import picard.cmdline.programgroups.ReferenceProgramGroup;\n-\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.ListIterator;\n-\n-/**\n- * Create a fasta with the bases shifted by offset\n- *\n- * delta1 = offset - 1\n- * delta2 = total - delta1\n- *\n- * To shift forward:\n- * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n- * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n- *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n- *\n- * To shift back:\n- * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n- * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n- *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n- *\n- */\n-@DocumentedFeature\n-@CommandLineProgramProperties(\n-        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n-        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n-        programGroup = ReferenceProgramGroup.class\n-)\n-public class ShiftFasta extends GATKTool {\n-\n-    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n-            doc = \"Path to write the output fasta to\")\n-    protected String output;\n-\n-    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n-    @Argument(fullName = SHIFT_BACK_OUTPUT,\n-            doc = \"Path to write the shift_back file to\")\n-    protected String shiftBackOutput;\n-\n-    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n-    @Argument(fullName = SHIFT_OFFSET_LIST,\n-            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n-    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n-    private List<Integer> shiftOffsets = null;\n-\n-    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n-    @Argument(fullName = INTERAL_FILE_NAME,\n-            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n-    private String intervalFilename;\n-\n-    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n-    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n-    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n-\n-    ReferenceDataSource refSource;\n-    FastaReferenceWriter refWriter;\n-    FileWriter chainFileWriter;\n-    FileWriter intervalRegularWriter;\n-    FileWriter intervalShiftedWriter;\n-\n-    int chainId = 0;\n-\n-    @Override\n-    public boolean requiresReference() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void onTraversalStart() {\n-        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n-        final Path path = IOUtils.getPath(output);\n-        chainId = 1;\n-        try {\n-            refWriter = new FastaReferenceWriterBuilder()\n-                    .setFastaFile(path)\n-                    .setBasesPerLine(basesPerLine)\n-                    .build();\n-            chainFileWriter = new FileWriter(shiftBackOutput);\n-            if (intervalFilename != null) {\n-                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n-                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n-            }\n-        } catch (IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    public void traverse() {\n-        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n-        long refLengthLong = refDict.getReferenceLength();\n-        if (refLengthLong > Integer.MAX_VALUE) {\n-            // TODO fix this??\n-            throw new UserException.BadInput(\"Reference length is too long\");\n-        }\n-        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n-        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n-                shiftOffsets.listIterator() : null;\n-        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n-    }\n-\n-    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n-        int contigLength = seq.getSequenceLength();\n-        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n-        if (shiftOffset != 0) {\n-            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n-            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n-            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n-            int shiftBackOffset = bases.length - shiftOffset;\n-\n-            try {\n-                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n-                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n-                if (intervalFilename != null && shiftOffsetsIt == null) {\n-                    int intervalStart = shiftOffset/2;\n-                    int intervalEnd = intervalStart + contigLength/2 - 1;\n-                    int shiftedIntervalStart = intervalStart;\n-                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n-                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n-                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n-                }\n-            } catch (IOException e) {\n-                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-            }\n-        }\n-    }\n-\n-    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n-        String[] items = new String[] { \"chain\",\n-                Integer.toString(score),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(shiftBackStart),\n-                Integer.toString(shiftBackEnd),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(start),\n-                Integer.toString(end),\n-                Integer.toString(id)\n-        };\n-        return String.join(\"\\t\", items);\n-    }\n-\n-    @Override\n-    public Object onTraversalSuccess(){\n-        // TODO is this right?\n-        return null;\n-    }\n-\n-    @Override\n-    public void closeTool() {\n-        super.closeTool();\n-        try{\n-            if( refWriter != null ) {\n-                refWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (chainFileWriter != null) {\n-                chainFileWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write chain file due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (intervalRegularWriter != null) {\n-                intervalRegularWriter.close();\n-            }\n-            if (intervalShiftedWriter != null) {\n-                intervalShiftedWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write intervals due to \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0MDI5Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570440292", "bodyText": "all these can be private", "author": "jamesemery", "createdAt": "2021-02-04T18:12:14Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\ndeleted file mode 100644\nindex 6a6986c69..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.fasta;\n-\n-import htsjdk.samtools.SAMSequenceDictionary;\n-import htsjdk.samtools.SAMSequenceRecord;\n-import htsjdk.samtools.reference.FastaReferenceWriter;\n-import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n-import org.broadinstitute.barclay.help.DocumentedFeature;\n-import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n-import org.broadinstitute.hellbender.engine.GATKTool;\n-import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n-import picard.cmdline.programgroups.ReferenceProgramGroup;\n-\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.ListIterator;\n-\n-/**\n- * Create a fasta with the bases shifted by offset\n- *\n- * delta1 = offset - 1\n- * delta2 = total - delta1\n- *\n- * To shift forward:\n- * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n- * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n- *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n- *\n- * To shift back:\n- * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n- * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n- *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n- *\n- */\n-@DocumentedFeature\n-@CommandLineProgramProperties(\n-        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n-        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n-        programGroup = ReferenceProgramGroup.class\n-)\n-public class ShiftFasta extends GATKTool {\n-\n-    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n-            doc = \"Path to write the output fasta to\")\n-    protected String output;\n-\n-    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n-    @Argument(fullName = SHIFT_BACK_OUTPUT,\n-            doc = \"Path to write the shift_back file to\")\n-    protected String shiftBackOutput;\n-\n-    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n-    @Argument(fullName = SHIFT_OFFSET_LIST,\n-            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n-    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n-    private List<Integer> shiftOffsets = null;\n-\n-    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n-    @Argument(fullName = INTERAL_FILE_NAME,\n-            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n-    private String intervalFilename;\n-\n-    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n-    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n-    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n-\n-    ReferenceDataSource refSource;\n-    FastaReferenceWriter refWriter;\n-    FileWriter chainFileWriter;\n-    FileWriter intervalRegularWriter;\n-    FileWriter intervalShiftedWriter;\n-\n-    int chainId = 0;\n-\n-    @Override\n-    public boolean requiresReference() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void onTraversalStart() {\n-        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n-        final Path path = IOUtils.getPath(output);\n-        chainId = 1;\n-        try {\n-            refWriter = new FastaReferenceWriterBuilder()\n-                    .setFastaFile(path)\n-                    .setBasesPerLine(basesPerLine)\n-                    .build();\n-            chainFileWriter = new FileWriter(shiftBackOutput);\n-            if (intervalFilename != null) {\n-                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n-                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n-            }\n-        } catch (IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    public void traverse() {\n-        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n-        long refLengthLong = refDict.getReferenceLength();\n-        if (refLengthLong > Integer.MAX_VALUE) {\n-            // TODO fix this??\n-            throw new UserException.BadInput(\"Reference length is too long\");\n-        }\n-        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n-        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n-                shiftOffsets.listIterator() : null;\n-        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n-    }\n-\n-    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n-        int contigLength = seq.getSequenceLength();\n-        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n-        if (shiftOffset != 0) {\n-            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n-            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n-            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n-            int shiftBackOffset = bases.length - shiftOffset;\n-\n-            try {\n-                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n-                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n-                if (intervalFilename != null && shiftOffsetsIt == null) {\n-                    int intervalStart = shiftOffset/2;\n-                    int intervalEnd = intervalStart + contigLength/2 - 1;\n-                    int shiftedIntervalStart = intervalStart;\n-                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n-                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n-                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n-                }\n-            } catch (IOException e) {\n-                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-            }\n-        }\n-    }\n-\n-    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n-        String[] items = new String[] { \"chain\",\n-                Integer.toString(score),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(shiftBackStart),\n-                Integer.toString(shiftBackEnd),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(start),\n-                Integer.toString(end),\n-                Integer.toString(id)\n-        };\n-        return String.join(\"\\t\", items);\n-    }\n-\n-    @Override\n-    public Object onTraversalSuccess(){\n-        // TODO is this right?\n-        return null;\n-    }\n-\n-    @Override\n-    public void closeTool() {\n-        super.closeTool();\n-        try{\n-            if( refWriter != null ) {\n-                refWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (chainFileWriter != null) {\n-                chainFileWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write chain file due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (intervalRegularWriter != null) {\n-                intervalRegularWriter.close();\n-            }\n-            if (intervalShiftedWriter != null) {\n-                intervalShiftedWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write intervals due to \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0MDU1Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570440557", "bodyText": "Can you add a CLI example here? That would make it a little easier for users to tell how this tool works.", "author": "jamesemery", "createdAt": "2021-02-04T18:12:43Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\ndeleted file mode 100644\nindex 6a6986c69..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.fasta;\n-\n-import htsjdk.samtools.SAMSequenceDictionary;\n-import htsjdk.samtools.SAMSequenceRecord;\n-import htsjdk.samtools.reference.FastaReferenceWriter;\n-import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n-import org.broadinstitute.barclay.help.DocumentedFeature;\n-import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n-import org.broadinstitute.hellbender.engine.GATKTool;\n-import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n-import picard.cmdline.programgroups.ReferenceProgramGroup;\n-\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.ListIterator;\n-\n-/**\n- * Create a fasta with the bases shifted by offset\n- *\n- * delta1 = offset - 1\n- * delta2 = total - delta1\n- *\n- * To shift forward:\n- * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n- * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n- *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n- *\n- * To shift back:\n- * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n- * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n- *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n- *\n- */\n-@DocumentedFeature\n-@CommandLineProgramProperties(\n-        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n-        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n-        programGroup = ReferenceProgramGroup.class\n-)\n-public class ShiftFasta extends GATKTool {\n-\n-    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n-            doc = \"Path to write the output fasta to\")\n-    protected String output;\n-\n-    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n-    @Argument(fullName = SHIFT_BACK_OUTPUT,\n-            doc = \"Path to write the shift_back file to\")\n-    protected String shiftBackOutput;\n-\n-    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n-    @Argument(fullName = SHIFT_OFFSET_LIST,\n-            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n-    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n-    private List<Integer> shiftOffsets = null;\n-\n-    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n-    @Argument(fullName = INTERAL_FILE_NAME,\n-            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n-    private String intervalFilename;\n-\n-    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n-    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n-    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n-\n-    ReferenceDataSource refSource;\n-    FastaReferenceWriter refWriter;\n-    FileWriter chainFileWriter;\n-    FileWriter intervalRegularWriter;\n-    FileWriter intervalShiftedWriter;\n-\n-    int chainId = 0;\n-\n-    @Override\n-    public boolean requiresReference() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void onTraversalStart() {\n-        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n-        final Path path = IOUtils.getPath(output);\n-        chainId = 1;\n-        try {\n-            refWriter = new FastaReferenceWriterBuilder()\n-                    .setFastaFile(path)\n-                    .setBasesPerLine(basesPerLine)\n-                    .build();\n-            chainFileWriter = new FileWriter(shiftBackOutput);\n-            if (intervalFilename != null) {\n-                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n-                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n-            }\n-        } catch (IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    public void traverse() {\n-        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n-        long refLengthLong = refDict.getReferenceLength();\n-        if (refLengthLong > Integer.MAX_VALUE) {\n-            // TODO fix this??\n-            throw new UserException.BadInput(\"Reference length is too long\");\n-        }\n-        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n-        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n-                shiftOffsets.listIterator() : null;\n-        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n-    }\n-\n-    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n-        int contigLength = seq.getSequenceLength();\n-        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n-        if (shiftOffset != 0) {\n-            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n-            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n-            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n-            int shiftBackOffset = bases.length - shiftOffset;\n-\n-            try {\n-                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n-                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n-                if (intervalFilename != null && shiftOffsetsIt == null) {\n-                    int intervalStart = shiftOffset/2;\n-                    int intervalEnd = intervalStart + contigLength/2 - 1;\n-                    int shiftedIntervalStart = intervalStart;\n-                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n-                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n-                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n-                }\n-            } catch (IOException e) {\n-                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-            }\n-        }\n-    }\n-\n-    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n-        String[] items = new String[] { \"chain\",\n-                Integer.toString(score),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(shiftBackStart),\n-                Integer.toString(shiftBackEnd),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(start),\n-                Integer.toString(end),\n-                Integer.toString(id)\n-        };\n-        return String.join(\"\\t\", items);\n-    }\n-\n-    @Override\n-    public Object onTraversalSuccess(){\n-        // TODO is this right?\n-        return null;\n-    }\n-\n-    @Override\n-    public void closeTool() {\n-        super.closeTool();\n-        try{\n-            if( refWriter != null ) {\n-                refWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (chainFileWriter != null) {\n-                chainFileWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write chain file due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (intervalRegularWriter != null) {\n-                intervalRegularWriter.close();\n-            }\n-            if (intervalShiftedWriter != null) {\n-                intervalShiftedWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write intervals due to \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0MTYyNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570441625", "bodyText": "Can you add a integration test for this tool? It seems pretty straightforward but as of right now it seems to pretty simply shift whatever contigs are in the fasta that is provided. It would be nice to have a test on one of the existing small fasta files in the test suite to check that the tool is doing something correctly. At worst you could simply make the liftover files etc for the mitochondria which would be nice to have checked in anyway.", "author": "jamesemery", "createdAt": "2021-02-04T18:14:22Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\ndeleted file mode 100644\nindex 6a6986c69..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.fasta;\n-\n-import htsjdk.samtools.SAMSequenceDictionary;\n-import htsjdk.samtools.SAMSequenceRecord;\n-import htsjdk.samtools.reference.FastaReferenceWriter;\n-import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n-import org.broadinstitute.barclay.help.DocumentedFeature;\n-import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n-import org.broadinstitute.hellbender.engine.GATKTool;\n-import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n-import picard.cmdline.programgroups.ReferenceProgramGroup;\n-\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.ListIterator;\n-\n-/**\n- * Create a fasta with the bases shifted by offset\n- *\n- * delta1 = offset - 1\n- * delta2 = total - delta1\n- *\n- * To shift forward:\n- * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n- * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n- *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n- *\n- * To shift back:\n- * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n- * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n- *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n- *\n- */\n-@DocumentedFeature\n-@CommandLineProgramProperties(\n-        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n-        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n-        programGroup = ReferenceProgramGroup.class\n-)\n-public class ShiftFasta extends GATKTool {\n-\n-    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n-            doc = \"Path to write the output fasta to\")\n-    protected String output;\n-\n-    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n-    @Argument(fullName = SHIFT_BACK_OUTPUT,\n-            doc = \"Path to write the shift_back file to\")\n-    protected String shiftBackOutput;\n-\n-    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n-    @Argument(fullName = SHIFT_OFFSET_LIST,\n-            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n-    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n-    private List<Integer> shiftOffsets = null;\n-\n-    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n-    @Argument(fullName = INTERAL_FILE_NAME,\n-            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n-    private String intervalFilename;\n-\n-    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n-    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n-    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n-\n-    ReferenceDataSource refSource;\n-    FastaReferenceWriter refWriter;\n-    FileWriter chainFileWriter;\n-    FileWriter intervalRegularWriter;\n-    FileWriter intervalShiftedWriter;\n-\n-    int chainId = 0;\n-\n-    @Override\n-    public boolean requiresReference() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void onTraversalStart() {\n-        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n-        final Path path = IOUtils.getPath(output);\n-        chainId = 1;\n-        try {\n-            refWriter = new FastaReferenceWriterBuilder()\n-                    .setFastaFile(path)\n-                    .setBasesPerLine(basesPerLine)\n-                    .build();\n-            chainFileWriter = new FileWriter(shiftBackOutput);\n-            if (intervalFilename != null) {\n-                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n-                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n-            }\n-        } catch (IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    public void traverse() {\n-        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n-        long refLengthLong = refDict.getReferenceLength();\n-        if (refLengthLong > Integer.MAX_VALUE) {\n-            // TODO fix this??\n-            throw new UserException.BadInput(\"Reference length is too long\");\n-        }\n-        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n-        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n-                shiftOffsets.listIterator() : null;\n-        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n-    }\n-\n-    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n-        int contigLength = seq.getSequenceLength();\n-        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n-        if (shiftOffset != 0) {\n-            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n-            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n-            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n-            int shiftBackOffset = bases.length - shiftOffset;\n-\n-            try {\n-                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n-                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n-                if (intervalFilename != null && shiftOffsetsIt == null) {\n-                    int intervalStart = shiftOffset/2;\n-                    int intervalEnd = intervalStart + contigLength/2 - 1;\n-                    int shiftedIntervalStart = intervalStart;\n-                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n-                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n-                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n-                }\n-            } catch (IOException e) {\n-                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-            }\n-        }\n-    }\n-\n-    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n-        String[] items = new String[] { \"chain\",\n-                Integer.toString(score),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(shiftBackStart),\n-                Integer.toString(shiftBackEnd),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(start),\n-                Integer.toString(end),\n-                Integer.toString(id)\n-        };\n-        return String.join(\"\\t\", items);\n-    }\n-\n-    @Override\n-    public Object onTraversalSuccess(){\n-        // TODO is this right?\n-        return null;\n-    }\n-\n-    @Override\n-    public void closeTool() {\n-        super.closeTool();\n-        try{\n-            if( refWriter != null ) {\n-                refWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (chainFileWriter != null) {\n-                chainFileWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write chain file due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (intervalRegularWriter != null) {\n-                intervalRegularWriter.close();\n-            }\n-            if (intervalShiftedWriter != null) {\n-                intervalShiftedWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write intervals due to \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0MjkwOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570442909", "bodyText": "Can you put a check here that makes sure the list is the same size as the length of the fasta file?", "author": "jamesemery", "createdAt": "2021-02-04T18:16:20Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjk5Njg0MA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r572996840", "bodyText": "isn't that what this check is doing? making sure that we have a shift offset for each contig:\nshiftOffsets.size() == contigs.size()", "author": "ahaessly", "createdAt": "2021-02-09T15:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0MjkwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzAxMTIwMA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r573011200", "bodyText": "You are right. However I still think we should be very careful about the shift offsets input. I think we should put a check here that asserts it is either empty OR it is exactly the lenght of the contigs in the file, otherwise if it is the wrong size we should throw a user exception since clearly there was a mistake.", "author": "jamesemery", "createdAt": "2021-02-09T15:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0MjkwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\ndeleted file mode 100644\nindex 6a6986c69..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.fasta;\n-\n-import htsjdk.samtools.SAMSequenceDictionary;\n-import htsjdk.samtools.SAMSequenceRecord;\n-import htsjdk.samtools.reference.FastaReferenceWriter;\n-import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n-import org.broadinstitute.barclay.help.DocumentedFeature;\n-import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n-import org.broadinstitute.hellbender.engine.GATKTool;\n-import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n-import picard.cmdline.programgroups.ReferenceProgramGroup;\n-\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.ListIterator;\n-\n-/**\n- * Create a fasta with the bases shifted by offset\n- *\n- * delta1 = offset - 1\n- * delta2 = total - delta1\n- *\n- * To shift forward:\n- * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n- * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n- *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n- *\n- * To shift back:\n- * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n- * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n- *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n- *\n- */\n-@DocumentedFeature\n-@CommandLineProgramProperties(\n-        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n-        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n-        programGroup = ReferenceProgramGroup.class\n-)\n-public class ShiftFasta extends GATKTool {\n-\n-    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n-            doc = \"Path to write the output fasta to\")\n-    protected String output;\n-\n-    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n-    @Argument(fullName = SHIFT_BACK_OUTPUT,\n-            doc = \"Path to write the shift_back file to\")\n-    protected String shiftBackOutput;\n-\n-    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n-    @Argument(fullName = SHIFT_OFFSET_LIST,\n-            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n-    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n-    private List<Integer> shiftOffsets = null;\n-\n-    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n-    @Argument(fullName = INTERAL_FILE_NAME,\n-            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n-    private String intervalFilename;\n-\n-    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n-    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n-    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n-\n-    ReferenceDataSource refSource;\n-    FastaReferenceWriter refWriter;\n-    FileWriter chainFileWriter;\n-    FileWriter intervalRegularWriter;\n-    FileWriter intervalShiftedWriter;\n-\n-    int chainId = 0;\n-\n-    @Override\n-    public boolean requiresReference() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void onTraversalStart() {\n-        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n-        final Path path = IOUtils.getPath(output);\n-        chainId = 1;\n-        try {\n-            refWriter = new FastaReferenceWriterBuilder()\n-                    .setFastaFile(path)\n-                    .setBasesPerLine(basesPerLine)\n-                    .build();\n-            chainFileWriter = new FileWriter(shiftBackOutput);\n-            if (intervalFilename != null) {\n-                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n-                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n-            }\n-        } catch (IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    public void traverse() {\n-        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n-        long refLengthLong = refDict.getReferenceLength();\n-        if (refLengthLong > Integer.MAX_VALUE) {\n-            // TODO fix this??\n-            throw new UserException.BadInput(\"Reference length is too long\");\n-        }\n-        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n-        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n-                shiftOffsets.listIterator() : null;\n-        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n-    }\n-\n-    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n-        int contigLength = seq.getSequenceLength();\n-        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n-        if (shiftOffset != 0) {\n-            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n-            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n-            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n-            int shiftBackOffset = bases.length - shiftOffset;\n-\n-            try {\n-                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n-                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n-                if (intervalFilename != null && shiftOffsetsIt == null) {\n-                    int intervalStart = shiftOffset/2;\n-                    int intervalEnd = intervalStart + contigLength/2 - 1;\n-                    int shiftedIntervalStart = intervalStart;\n-                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n-                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n-                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n-                }\n-            } catch (IOException e) {\n-                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-            }\n-        }\n-    }\n-\n-    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n-        String[] items = new String[] { \"chain\",\n-                Integer.toString(score),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(shiftBackStart),\n-                Integer.toString(shiftBackEnd),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(start),\n-                Integer.toString(end),\n-                Integer.toString(id)\n-        };\n-        return String.join(\"\\t\", items);\n-    }\n-\n-    @Override\n-    public Object onTraversalSuccess(){\n-        // TODO is this right?\n-        return null;\n-    }\n-\n-    @Override\n-    public void closeTool() {\n-        super.closeTool();\n-        try{\n-            if( refWriter != null ) {\n-                refWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (chainFileWriter != null) {\n-                chainFileWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write chain file due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (intervalRegularWriter != null) {\n-                intervalRegularWriter.close();\n-            }\n-            if (intervalShiftedWriter != null) {\n-                intervalShiftedWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write intervals due to \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0NDM4Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570444382", "bodyText": "How difficult would it be to add an integration test to M2 that asserts this argument is doing something reasonable?", "author": "jamesemery", "createdAt": "2021-02-04T18:18:32Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java", "diffHunk": "@@ -43,6 +43,13 @@\n     @Argument(fullName = M2ArgumentCollection.MITOCHONDRIA_MODE_LONG_NAME, optional = true, doc = \"Set filters to mitochondrial defaults\")\n     public boolean mitochondria = false;\n \n+    /**\n+     * Mitochondria mode excludes the filters {@link ClusteredEventsFilter}, {@link MultiallelicFilter},\n+     * {@link FilteredHaplotypeFilter}, {@link FragmentLengthFilter}, and {@link GermlineFilter}\n+     */\n+    @Argument(fullName = M2ArgumentCollection.MICROBIAL_MODE_LONG_NAME, optional = true, doc = \"Set filters to microbial defaults\")", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java\nindex 91dc166ce..991693e67 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java\n\n@@ -43,13 +43,6 @@ public class M2FiltersArgumentCollection {\n     @Argument(fullName = M2ArgumentCollection.MITOCHONDRIA_MODE_LONG_NAME, optional = true, doc = \"Set filters to mitochondrial defaults\")\n     public boolean mitochondria = false;\n \n-    /**\n-     * Mitochondria mode excludes the filters {@link ClusteredEventsFilter}, {@link MultiallelicFilter},\n-     * {@link FilteredHaplotypeFilter}, {@link FragmentLengthFilter}, and {@link GermlineFilter}\n-     */\n-    @Argument(fullName = M2ArgumentCollection.MICROBIAL_MODE_LONG_NAME, optional = true, doc = \"Set filters to microbial defaults\")\n-    public boolean microbial = false;\n-\n \n     /**\n      * Hard filter thresholds\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0NTYwNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570445605", "bodyText": "Here you need to add some tests that assert the offset is within the range of the actual file? There seems to be no check that the user cant specify a bogus value in the list input.", "author": "jamesemery", "createdAt": "2021-02-04T18:20:28Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n+        int contigLength = seq.getSequenceLength();\n+        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n+        if (shiftOffset != 0) {\n+            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n+            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n+            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n+            int shiftBackOffset = bases.length - shiftOffset;", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\ndeleted file mode 100644\nindex 6a6986c69..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.fasta;\n-\n-import htsjdk.samtools.SAMSequenceDictionary;\n-import htsjdk.samtools.SAMSequenceRecord;\n-import htsjdk.samtools.reference.FastaReferenceWriter;\n-import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n-import org.broadinstitute.barclay.help.DocumentedFeature;\n-import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n-import org.broadinstitute.hellbender.engine.GATKTool;\n-import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n-import picard.cmdline.programgroups.ReferenceProgramGroup;\n-\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.ListIterator;\n-\n-/**\n- * Create a fasta with the bases shifted by offset\n- *\n- * delta1 = offset - 1\n- * delta2 = total - delta1\n- *\n- * To shift forward:\n- * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n- * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n- *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n- *\n- * To shift back:\n- * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n- * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n- *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n- *\n- */\n-@DocumentedFeature\n-@CommandLineProgramProperties(\n-        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n-        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n-        programGroup = ReferenceProgramGroup.class\n-)\n-public class ShiftFasta extends GATKTool {\n-\n-    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n-            doc = \"Path to write the output fasta to\")\n-    protected String output;\n-\n-    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n-    @Argument(fullName = SHIFT_BACK_OUTPUT,\n-            doc = \"Path to write the shift_back file to\")\n-    protected String shiftBackOutput;\n-\n-    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n-    @Argument(fullName = SHIFT_OFFSET_LIST,\n-            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n-    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n-    private List<Integer> shiftOffsets = null;\n-\n-    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n-    @Argument(fullName = INTERAL_FILE_NAME,\n-            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n-    private String intervalFilename;\n-\n-    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n-    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n-    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n-\n-    ReferenceDataSource refSource;\n-    FastaReferenceWriter refWriter;\n-    FileWriter chainFileWriter;\n-    FileWriter intervalRegularWriter;\n-    FileWriter intervalShiftedWriter;\n-\n-    int chainId = 0;\n-\n-    @Override\n-    public boolean requiresReference() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void onTraversalStart() {\n-        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n-        final Path path = IOUtils.getPath(output);\n-        chainId = 1;\n-        try {\n-            refWriter = new FastaReferenceWriterBuilder()\n-                    .setFastaFile(path)\n-                    .setBasesPerLine(basesPerLine)\n-                    .build();\n-            chainFileWriter = new FileWriter(shiftBackOutput);\n-            if (intervalFilename != null) {\n-                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n-                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n-            }\n-        } catch (IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    public void traverse() {\n-        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n-        long refLengthLong = refDict.getReferenceLength();\n-        if (refLengthLong > Integer.MAX_VALUE) {\n-            // TODO fix this??\n-            throw new UserException.BadInput(\"Reference length is too long\");\n-        }\n-        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n-        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n-                shiftOffsets.listIterator() : null;\n-        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n-    }\n-\n-    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n-        int contigLength = seq.getSequenceLength();\n-        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n-        if (shiftOffset != 0) {\n-            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n-            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n-            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n-            int shiftBackOffset = bases.length - shiftOffset;\n-\n-            try {\n-                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n-                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n-                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n-                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n-                if (intervalFilename != null && shiftOffsetsIt == null) {\n-                    int intervalStart = shiftOffset/2;\n-                    int intervalEnd = intervalStart + contigLength/2 - 1;\n-                    int shiftedIntervalStart = intervalStart;\n-                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n-                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n-                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n-                }\n-            } catch (IOException e) {\n-                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-            }\n-        }\n-    }\n-\n-    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n-        String[] items = new String[] { \"chain\",\n-                Integer.toString(score),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(shiftBackStart),\n-                Integer.toString(shiftBackEnd),\n-                name,\n-                Integer.toString(length),\n-                \"+\",\n-                Integer.toString(start),\n-                Integer.toString(end),\n-                Integer.toString(id)\n-        };\n-        return String.join(\"\\t\", items);\n-    }\n-\n-    @Override\n-    public Object onTraversalSuccess(){\n-        // TODO is this right?\n-        return null;\n-    }\n-\n-    @Override\n-    public void closeTool() {\n-        super.closeTool();\n-        try{\n-            if( refWriter != null ) {\n-                refWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (chainFileWriter != null) {\n-                chainFileWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write chain file due to \" + e.getMessage(), e);\n-        }\n-        try{\n-            if (intervalRegularWriter != null) {\n-                intervalRegularWriter.close();\n-            }\n-            if (intervalShiftedWriter != null) {\n-                intervalShiftedWriter.close();\n-            }\n-        } catch (IllegalStateException e){\n-            //sink this\n-        } catch (IOException e) {\n-            throw new UserException(\"Failed to write intervals due to \" + e.getMessage(), e);\n-        }\n-    }\n-\n-    }\n"}}, {"oid": "3f39bee1600efd798400dfedcb3aeb107eaa577b", "url": "https://github.com/broadinstitute/gatk/commit/3f39bee1600efd798400dfedcb3aeb107eaa577b", "message": "parent 6d4310368601f28c9557746307fe1ac089156fe4\nauthor Andrea Haessly <ahaessly@broadinstitute.org> 1582141271 -0500\ncommitter Andrea Haessly <ahaessly@broadinstitute.org> 1611852899 -0500\n\nparent 6d4310368601f28c9557746307fe1ac089156fe4\nauthor Andrea Haessly <ahaessly@broadinstitute.org> 1582141271 -0500\ncommitter Andrea Haessly <ahaessly@broadinstitute.org> 1611852778 -0500\n\ninitial impl\ntested shift and chain\nmake offset optional\nfix format of chain file\nmake offset optional\nfix format of chain file\nadd interval output", "committedDate": "2021-03-15T19:55:28Z", "type": "forcePushed"}, {"oid": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "url": "https://github.com/broadinstitute/gatk/commit/0558f716d17af39e183a7b0580c8b787ec7abe1f", "message": "rebased version of this code", "committedDate": "2021-03-19T17:53:17Z", "type": "commit"}, {"oid": "c7d014fa4f482a57d11c5f8deda44e245f3b98b4", "url": "https://github.com/broadinstitute/gatk/commit/c7d014fa4f482a57d11c5f8deda44e245f3b98b4", "message": "fixed an issue where the logic for suffix ends was incorrect for dangling tails", "committedDate": "2021-03-19T17:53:22Z", "type": "commit"}, {"oid": "dd6907dbfc0196f7e6b9a4dc6119fd324a1c6e36", "url": "https://github.com/broadinstitute/gatk/commit/dd6907dbfc0196f7e6b9a4dc6119fd324a1c6e36", "message": "responding to review comments", "committedDate": "2021-03-19T17:53:26Z", "type": "commit"}, {"oid": "e94783ae99012ec1341c2b23100daf21f40b37ec", "url": "https://github.com/broadinstitute/gatk/commit/e94783ae99012ec1341c2b23100daf21f40b37ec", "message": "manual rebase", "committedDate": "2021-03-19T17:53:32Z", "type": "commit"}, {"oid": "e3865a05e986f8d7b7c64fdf232adb188abe7cf3", "url": "https://github.com/broadinstitute/gatk/commit/e3865a05e986f8d7b7c64fdf232adb188abe7cf3", "message": "change misspellings of dangling to the correct spelling", "committedDate": "2021-03-19T17:53:36Z", "type": "commit"}, {"oid": "14f82aeda2087989b2812a3519fd9ea12e9c52ea", "url": "https://github.com/broadinstitute/gatk/commit/14f82aeda2087989b2812a3519fd9ea12e9c52ea", "message": "remove change from bad merge", "committedDate": "2021-03-19T17:53:41Z", "type": "commit"}, {"oid": "e389981dfa26d5346daf3cc498eb32dcef145f7c", "url": "https://github.com/broadinstitute/gatk/commit/e389981dfa26d5346daf3cc498eb32dcef145f7c", "message": "parent 6d4310368601f28c9557746307fe1ac089156fe4\nauthor Andrea Haessly <ahaessly@broadinstitute.org> 1582141271 -0500\ncommitter Andrea Haessly <ahaessly@broadinstitute.org> 1611852899 -0500\n\nparent 6d4310368601f28c9557746307fe1ac089156fe4\nauthor Andrea Haessly <ahaessly@broadinstitute.org> 1582141271 -0500\ncommitter Andrea Haessly <ahaessly@broadinstitute.org> 1611852778 -0500\n\ninitial impl\ntested shift and chain\nmake offset optional\nfix format of chain file\nmake offset optional\nfix format of chain file\nadd interval output", "committedDate": "2021-03-19T17:53:46Z", "type": "commit"}, {"oid": "a4f8290f1c2760eb028efd7c960e214f4e2a0586", "url": "https://github.com/broadinstitute/gatk/commit/a4f8290f1c2760eb028efd7c960e214f4e2a0586", "message": "check for is empty", "committedDate": "2021-03-19T17:53:51Z", "type": "commit"}, {"oid": "a4f8290f1c2760eb028efd7c960e214f4e2a0586", "url": "https://github.com/broadinstitute/gatk/commit/a4f8290f1c2760eb028efd7c960e214f4e2a0586", "message": "check for is empty", "committedDate": "2021-03-19T17:53:51Z", "type": "forcePushed"}, {"oid": "ea496546f3ad8b66a9b710019a0bea0b6863f315", "url": "https://github.com/broadinstitute/gatk/commit/ea496546f3ad8b66a9b710019a0bea0b6863f315", "message": "add test, update from PR", "committedDate": "2021-03-19T18:09:25Z", "type": "commit"}, {"oid": "c9947f5a2596f71796877fd36757a590af50cf69", "url": "https://github.com/broadinstitute/gatk/commit/c9947f5a2596f71796877fd36757a590af50cf69", "message": "update from PR", "committedDate": "2021-03-22T15:08:25Z", "type": "commit"}, {"oid": "e77cda46991075b3625604a59343c2a784268e1e", "url": "https://github.com/broadinstitute/gatk/commit/e77cda46991075b3625604a59343c2a784268e1e", "message": "update from PR", "committedDate": "2021-04-01T17:52:38Z", "type": "commit"}, {"oid": "0f5d2180644190730cf9461ff35a5244518b1f72", "url": "https://github.com/broadinstitute/gatk/commit/0f5d2180644190730cf9461ff35a5244518b1f72", "message": "update documentation", "committedDate": "2021-07-21T20:27:32Z", "type": "commit"}, {"oid": "3652446773f28f6a79c12fef515364f0b3aca5f3", "url": "https://github.com/broadinstitute/gatk/commit/3652446773f28f6a79c12fef515364f0b3aca5f3", "message": "add pruner fix", "committedDate": "2021-07-21T20:29:18Z", "type": "commit"}, {"oid": "a1261ae54b4e6c7e3b71394c19336c73e73cd469", "url": "https://github.com/broadinstitute/gatk/commit/a1261ae54b4e6c7e3b71394c19336c73e73cd469", "message": "remove unfinished code", "committedDate": "2021-07-21T20:34:12Z", "type": "commit"}, {"oid": "bd288381be7b071754fd8ca9552af24500044e63", "url": "https://github.com/broadinstitute/gatk/commit/bd288381be7b071754fd8ca9552af24500044e63", "message": "test microbial mode", "committedDate": "2021-07-21T21:43:15Z", "type": "commit"}, {"oid": "af9f90aad04a9366a867dc67fb941e641b648813", "url": "https://github.com/broadinstitute/gatk/commit/af9f90aad04a9366a867dc67fb941e641b648813", "message": "fix bug", "committedDate": "2021-07-21T22:32:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NTcyNzA2NA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r675727064", "bodyText": "I would scrub out the folder references here and replace them with something like (<CIRCULAR.FASTA> etc...). Its generally confusing to see references like these in the docs especially when the data aren't checked into our repo.", "author": "jamesemery", "createdAt": "2021-07-23T17:34:00Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,245 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ * Example command line:\n+ * ShiftFasta\n+ * -R \"testfiles/shift/ecoli/Escherichia_coli_2017C-4173W12.fa\"   // the reference to shift\n+ * -O \"testfiles/shift/ecoli/shifted.fa\"                          // the shifted fasta\n+ * --shift-back-output \"testfiles/shift/ecoli/shiftback.chain\"    // the shiftback chain file to use when lifting over", "originalCommit": "af9f90aad04a9366a867dc67fb941e641b648813", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c0c54745029ffb2c63492ee85e563710a12c1d22", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\nindex 5d753f90a..3e2c4ba7c 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n\n@@ -40,10 +40,11 @@ import java.util.ListIterator;\n  *\n  * Example command line:\n  * ShiftFasta\n- * -R \"testfiles/shift/ecoli/Escherichia_coli_2017C-4173W12.fa\"   // the reference to shift\n- * -O \"testfiles/shift/ecoli/shifted.fa\"                          // the shifted fasta\n- * --shift-back-output \"testfiles/shift/ecoli/shiftback.chain\"    // the shiftback chain file to use when lifting over\n- * --interval-file-name \"testfiles/shift/ecoli/ecoli\"             // base name for output interval files (one for regular and one for shifted)\n+ * -R \"<CIRCURLAR_REFERENCE.fasta>\"         // the reference to shift\n+ * -O \"<SHIFTED_REFERENCE.fasta>\"           // output; the shifted fasta\n+ * --shift-back-output \"<SHIFT_BACK.chain>\" // output; the shiftback chain file to use when lifting over\n+ * --shift-offset-list \"<SHIFT_OFFSETS>\"    // optional; Specifies the offset to shift for each contig in the reference. If not specified, the offset will be half the length of the contig.\n+ * --interval-file-name \"<SHIFT_INTERVALS>\" // output; base name for output interval files (.intervals and .shifted.intervals) that should be used when calling variants against the unshifted and shifted reference.\n  * --line-width 100\n  */\n @DocumentedFeature\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NTczMTg1Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r675731856", "bodyText": "Rename to \"ShiftFastaIntegrationTest\" the test suite uses reflection to decide where to run tests so naming them correctly is important.", "author": "jamesemery", "createdAt": "2021-07-23T17:42:35Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaTest.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.GATKBaseTest;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.BaseTest;\n+import org.broadinstitute.hellbender.testutils.FastaTestUtils;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+\n+public class ShiftFastaTest extends CommandLineProgramTest {", "originalCommit": "af9f90aad04a9366a867dc67fb941e641b648813", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c0c54745029ffb2c63492ee85e563710a12c1d22", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaTest.java b/src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaIntegrationTest.java\nsimilarity index 96%\nrename from src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaTest.java\nrename to src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaIntegrationTest.java\nindex 0e6e81c84..606aac8de 100644\n--- a/src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaTest.java\n+++ b/src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaIntegrationTest.java\n\n@@ -9,7 +9,7 @@ import org.testng.annotations.Test;\n \n import java.io.File;\n \n-public class ShiftFastaTest extends CommandLineProgramTest {\n+public class ShiftFastaIntegrationTest extends CommandLineProgramTest {\n \n     private static final File MITO_REF = new File(toolsTestDir, \"mutect/mito/Homo_sapiens_assembly38.mt_only.fasta\");\n     private static final File SHIFTED_MITO_REF = new File(largeFileTestDir + \"mitochondria_references/Homo_sapiens_assembly38.chrM.shifted_by_8000_bases.fasta\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NTczMzc0MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r675733741", "bodyText": "Can you make sure this is properly checked in? It may be an issue with github display but I don't see those files being checked in for this PR so you may have forgotten to add them properly through lfs.", "author": "jamesemery", "createdAt": "2021-07-23T17:46:09Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaTest.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.GATKBaseTest;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.BaseTest;\n+import org.broadinstitute.hellbender.testutils.FastaTestUtils;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+\n+public class ShiftFastaTest extends CommandLineProgramTest {\n+\n+    private static final File MITO_REF = new File(toolsTestDir, \"mutect/mito/Homo_sapiens_assembly38.mt_only.fasta\");\n+    private static final File SHIFTED_MITO_REF = new File(largeFileTestDir + \"mitochondria_references/Homo_sapiens_assembly38.chrM.shifted_by_8000_bases.fasta\");", "originalCommit": "af9f90aad04a9366a867dc67fb941e641b648813", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c0c54745029ffb2c63492ee85e563710a12c1d22", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaTest.java b/src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaIntegrationTest.java\nsimilarity index 96%\nrename from src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaTest.java\nrename to src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaIntegrationTest.java\nindex 0e6e81c84..606aac8de 100644\n--- a/src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaTest.java\n+++ b/src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaIntegrationTest.java\n\n@@ -9,7 +9,7 @@ import org.testng.annotations.Test;\n \n import java.io.File;\n \n-public class ShiftFastaTest extends CommandLineProgramTest {\n+public class ShiftFastaIntegrationTest extends CommandLineProgramTest {\n \n     private static final File MITO_REF = new File(toolsTestDir, \"mutect/mito/Homo_sapiens_assembly38.mt_only.fasta\");\n     private static final File SHIFTED_MITO_REF = new File(largeFileTestDir + \"mitochondria_references/Homo_sapiens_assembly38.chrM.shifted_by_8000_bases.fasta\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NTczODE4OA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r675738188", "bodyText": "This is up to you but you may consider adding the @BetaFeature tag to this tool since its a new tool part of an in-development pipeline.", "author": "jamesemery", "createdAt": "2021-07-23T17:54:11Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,245 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ * Example command line:\n+ * ShiftFasta\n+ * -R \"testfiles/shift/ecoli/Escherichia_coli_2017C-4173W12.fa\"   // the reference to shift\n+ * -O \"testfiles/shift/ecoli/shifted.fa\"                          // the shifted fasta\n+ * --shift-back-output \"testfiles/shift/ecoli/shiftback.chain\"    // the shiftback chain file to use when lifting over\n+ * --interval-file-name \"testfiles/shift/ecoli/ecoli\"             // base name for output interval files (one for regular and one for shifted)\n+ * --line-width 100\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(", "originalCommit": "af9f90aad04a9366a867dc67fb941e641b648813", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c0c54745029ffb2c63492ee85e563710a12c1d22", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\nindex 5d753f90a..3e2c4ba7c 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java\n\n@@ -40,10 +40,11 @@ import java.util.ListIterator;\n  *\n  * Example command line:\n  * ShiftFasta\n- * -R \"testfiles/shift/ecoli/Escherichia_coli_2017C-4173W12.fa\"   // the reference to shift\n- * -O \"testfiles/shift/ecoli/shifted.fa\"                          // the shifted fasta\n- * --shift-back-output \"testfiles/shift/ecoli/shiftback.chain\"    // the shiftback chain file to use when lifting over\n- * --interval-file-name \"testfiles/shift/ecoli/ecoli\"             // base name for output interval files (one for regular and one for shifted)\n+ * -R \"<CIRCURLAR_REFERENCE.fasta>\"         // the reference to shift\n+ * -O \"<SHIFTED_REFERENCE.fasta>\"           // output; the shifted fasta\n+ * --shift-back-output \"<SHIFT_BACK.chain>\" // output; the shiftback chain file to use when lifting over\n+ * --shift-offset-list \"<SHIFT_OFFSETS>\"    // optional; Specifies the offset to shift for each contig in the reference. If not specified, the offset will be half the length of the contig.\n+ * --interval-file-name \"<SHIFT_INTERVALS>\" // output; base name for output interval files (.intervals and .shifted.intervals) that should be used when calling variants against the unshifted and shifted reference.\n  * --line-width 100\n  */\n @DocumentedFeature\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NTc0MDYzMA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r675740630", "bodyText": "Right I remember this change. When you do the squash + merge of this branch can you make sure its clearly stated in the commit description that this changes the behavior of the adaptive pruner at low/patchy reference coverage sites? This somewhat of a substantial fix to that method and it will be buried by this commit if we aren't careful.", "author": "jamesemery", "createdAt": "2021-07-23T17:56:38Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/graphs/AdaptiveChainPruner.java", "diffHunk": "@@ -56,11 +56,11 @@ public AdaptiveChainPruner(final double initialErrorProbability, final double lo\n         final Multimap<V, Path<V,E>> vertexToGoodOutgoingChains = ArrayListMultimap.create();\n \n         for (final Path<V,E> chain : chains) {\n-            if (chainLogOdds.get(chain).getRight() >= logOddsThreshold) {", "originalCommit": "af9f90aad04a9366a867dc67fb941e641b648813", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "c0c54745029ffb2c63492ee85e563710a12c1d22", "url": "https://github.com/broadinstitute/gatk/commit/c0c54745029ffb2c63492ee85e563710a12c1d22", "message": "this changes the behavior of the adaptive pruner at low/patchy reference coverage sites\\nAdd large files to resources", "committedDate": "2021-07-27T17:52:16Z", "type": "commit"}, {"oid": "b08dc270ab2b1495047ff97e3dc04d7d29ab1421", "url": "https://github.com/broadinstitute/gatk/commit/b08dc270ab2b1495047ff97e3dc04d7d29ab1421", "message": "doc as beta feature", "committedDate": "2021-07-29T15:16:14Z", "type": "commit"}]}