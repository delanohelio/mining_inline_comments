{"pr_number": 6561, "pr_title": "Migrate read arguments and downstream code to GATKPathSpecifier", "pr_createdAt": "2020-04-21T21:32:26Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6561", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzI1MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421033251", "bodyText": "This mention of Paths being the preferred form is no longer true with this PR.", "author": "lbergelson", "createdAt": "2020-05-06T19:19:08Z", "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java", "diffHunk": "@@ -30,18 +31,27 @@\n     protected ValidationStringency readValidationStringency = ReadConstants.DEFAULT_READ_VALIDATION_STRINGENCY;\n \n     @Argument(fullName = StandardArgumentDefinitions.READ_INDEX_LONG_NAME, shortName = StandardArgumentDefinitions.READ_INDEX_SHORT_NAME,\n-              doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n+            doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n                     \"and in the same order as the read inputs. If this argument is not specified, the path to the index \" +\n                     \"for each input will be inferred automatically.\",\n-              common = true,\n-              optional = true)\n-    protected List<String> readIndices;\n+            common = true,\n+            optional = true)\n+    protected List<GATKPathSpecifier> readIndices;\n \n     /**\n      * Get the list of BAM/SAM/CRAM files specified at the command line.\n      * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n      */\n-    public abstract List<Path> getReadPaths();\n+    public abstract List<GATKPathSpecifier> getReadPathSpecifiers();\n+\n+    /**\n+     * Get the list of BAM/SAM/CRAM files specified at the command line.\n+     * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3MjYyOA==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426872628", "bodyText": "Fixed.", "author": "cmnbroad", "createdAt": "2020-05-18T20:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzI1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c066a803e9e185ab25c87d97a1a0c89432f958cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java b/src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java\nindex 7fec55ba9..9d1ae4308 100644\n--- a/src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java\n+++ b/src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java\n\n@@ -39,14 +39,14 @@ public abstract class ReadInputArgumentCollection implements Serializable {\n     protected List<GATKPathSpecifier> readIndices;\n \n     /**\n-     * Get the list of BAM/SAM/CRAM files specified at the command line.\n-     * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n+     * Get the list of BAM/SAM/CRAM inputs specified at the command line.\n+     * GATKPathSpecifier is the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n      */\n     public abstract List<GATKPathSpecifier> getReadPathSpecifiers();\n \n     /**\n-     * Get the list of BAM/SAM/CRAM files specified at the command line.\n-     * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n+     * Get the list of BAM/SAM/CRAM inputs specified at the command line.\n+     * GATKPathSpecifier is the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n      */\n \n     public List<Path> getReadPaths() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzQ1Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421033457", "bodyText": "The comment about Paths isn't accurate anymore.", "author": "lbergelson", "createdAt": "2020-05-06T19:19:32Z", "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java", "diffHunk": "@@ -30,18 +31,27 @@\n     protected ValidationStringency readValidationStringency = ReadConstants.DEFAULT_READ_VALIDATION_STRINGENCY;\n \n     @Argument(fullName = StandardArgumentDefinitions.READ_INDEX_LONG_NAME, shortName = StandardArgumentDefinitions.READ_INDEX_SHORT_NAME,\n-              doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n+            doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n                     \"and in the same order as the read inputs. If this argument is not specified, the path to the index \" +\n                     \"for each input will be inferred automatically.\",\n-              common = true,\n-              optional = true)\n-    protected List<String> readIndices;\n+            common = true,\n+            optional = true)\n+    protected List<GATKPathSpecifier> readIndices;\n \n     /**\n      * Get the list of BAM/SAM/CRAM files specified at the command line.\n      * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3MjY5Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426872696", "bodyText": "Fixed.", "author": "cmnbroad", "createdAt": "2020-05-18T20:22:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzQ1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c066a803e9e185ab25c87d97a1a0c89432f958cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java b/src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java\nindex 7fec55ba9..9d1ae4308 100644\n--- a/src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java\n+++ b/src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java\n\n@@ -39,14 +39,14 @@ public abstract class ReadInputArgumentCollection implements Serializable {\n     protected List<GATKPathSpecifier> readIndices;\n \n     /**\n-     * Get the list of BAM/SAM/CRAM files specified at the command line.\n-     * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n+     * Get the list of BAM/SAM/CRAM inputs specified at the command line.\n+     * GATKPathSpecifier is the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n      */\n     public abstract List<GATKPathSpecifier> getReadPathSpecifiers();\n \n     /**\n-     * Get the list of BAM/SAM/CRAM files specified at the command line.\n-     * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n+     * Get the list of BAM/SAM/CRAM inputs specified at the command line.\n+     * GATKPathSpecifier is the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n      */\n \n     public List<Path> getReadPaths() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzc2MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421033761", "bodyText": "comment is out of date", "author": "lbergelson", "createdAt": "2020-05-06T19:20:03Z", "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/RequiredReadInputArgumentCollection.java", "diffHunk": "@@ -16,28 +17,11 @@\n public final class RequiredReadInputArgumentCollection extends ReadInputArgumentCollection {\n     private static final long serialVersionUID = 1L;\n     @Argument(fullName = StandardArgumentDefinitions.INPUT_LONG_NAME, shortName = StandardArgumentDefinitions.INPUT_SHORT_NAME, doc = \"BAM/SAM/CRAM file containing reads\", optional = false, common = true)\n-    public List<String> readFilesNames;\n+    public List<GATKPathSpecifier> readFilesNames;\n \n-    @Override\n-    public List<File> getReadFiles() {\n-        ArrayList<File> ret = new ArrayList<>();\n-        for (String fn : readFilesNames) {\n-            ret.add(new File(fn));\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    public List<Path> getReadPaths() {\n-        ArrayList<Path> ret = new ArrayList<>();\n-        for (String fn : readFilesNames) {\n-            ret.add(IOUtils.getPath(fn));\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    public List<String> getReadFilesNames() {\n-        return new ArrayList<>(readFilesNames);\n-    }\n+    /**\n+     * Get the list of BAM/SAM/CRAM files specified at the command line.\n+     * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3MjczMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426872731", "bodyText": "Fixed.", "author": "cmnbroad", "createdAt": "2020-05-18T20:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzc2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c066a803e9e185ab25c87d97a1a0c89432f958cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/RequiredReadInputArgumentCollection.java b/src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/RequiredReadInputArgumentCollection.java\nindex 2309b9d6a..a5af95ee7 100644\n--- a/src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/RequiredReadInputArgumentCollection.java\n+++ b/src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/RequiredReadInputArgumentCollection.java\n\n@@ -20,8 +20,8 @@ public final class RequiredReadInputArgumentCollection extends ReadInputArgument\n     public List<GATKPathSpecifier> readFilesNames;\n \n     /**\n-     * Get the list of BAM/SAM/CRAM files specified at the command line.\n-     * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n+     * Get the list of BAM/SAM/CRAM inputs specified at the command line.\n+     * GATKPathSpecifier is the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n      */\n     public List<GATKPathSpecifier> getReadPathSpecifiers() { return Collections.unmodifiableList(readFilesNames);}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNDEzMw==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421034133", "bodyText": "Ah, thanks for updating this.", "author": "lbergelson", "createdAt": "2020-05-06T19:20:43Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/GATKTool.java", "diffHunk": "@@ -277,7 +281,7 @@ public CountingReadFilter makeReadFilter(){\n \n     /**\n      * Must be overridden in order to add annotation arguments to the engine. If this is set to true the engine will\n-     * dynamically discover all {@link Annotation}s in the package defined by {@link org.broadinstitute.hellbender.cmdline.GATKPlugin.GATKAnnotationPluginDescriptor#pluginPackageName} and automatically\n+     * dynamically discover all {@link Annotation}s in the packages defined by {@link GATKAnnotationPluginDescriptor#getPackageNames()} and automatically", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a074242e86d54362cba10d84b38e233ca13ef934", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/GATKTool.java b/src/main/java/org/broadinstitute/hellbender/engine/GATKTool.java\nindex 1edaf6568..d57c8b40b 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/GATKTool.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/GATKTool.java\n\n@@ -281,7 +277,7 @@ public abstract class GATKTool extends CommandLineProgram {\n \n     /**\n      * Must be overridden in order to add annotation arguments to the engine. If this is set to true the engine will\n-     * dynamically discover all {@link Annotation}s in the packages defined by {@link GATKAnnotationPluginDescriptor#getPackageNames()} and automatically\n+     * dynamically discover all {@link Annotation}s in the package defined by {@link org.broadinstitute.hellbender.cmdline.GATKPlugin.GATKAnnotationPluginDescriptor#pluginPackageName} and automatically\n      * generate and add command line arguments allowing the user to specify which annotations or groups of annotations to use.\n      *\n      * To specify default annotations for a tool simply specify them using {@link #getDefaultVariantAnnotationGroups()} or {@link #getDefaultVariantAnnotations()}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNjE1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421036152", "bodyText": "This doesn't deal correctly with http path ending weirdness.  I think we should add a \"getExtension\" or 'getFilename\" method to avoid making this mistake.", "author": "lbergelson", "createdAt": "2020-05-06T19:24:05Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -323,31 +323,31 @@ public SAMFileHeader getHeaderForReads() {\n \n         JavaRDD<GATKRead> output = null;\n         ReadsSparkSource source = readsSource;\n-        for (String input : readInputs.keySet()) {\n+        for (final GATKPathSpecifier inputPathSpecifier : readInputs.keySet()) {\n             if (output == null) {\n-                output = getGatkReadJavaRDD(traversalParameters, source, input);\n+                output = getGatkReadJavaRDD(traversalParameters, source, inputPathSpecifier);\n             } else {\n-                output = output.union(getGatkReadJavaRDD(traversalParameters, source, input));\n+                output = output.union(getGatkReadJavaRDD(traversalParameters, source, inputPathSpecifier));\n             }\n         }\n         return output;\n     }\n \n-    protected JavaRDD<GATKRead> getGatkReadJavaRDD(TraversalParameters traversalParameters, ReadsSparkSource source, String input) {\n+    protected JavaRDD<GATKRead> getGatkReadJavaRDD(TraversalParameters traversalParameters, ReadsSparkSource source, GATKPathSpecifier inputSpecifier) {\n         JavaRDD<GATKRead> output;\n         // TODO: This if statement is a temporary hack until #959 gets resolve\n-        if (input.endsWith(\".adam\")) {\n+        if (inputSpecifier.getURIString().endsWith(\".adam\")) {", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3Mjc5NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426872795", "bodyText": "Fixed.", "author": "cmnbroad", "createdAt": "2020-05-18T20:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNjE1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c066a803e9e185ab25c87d97a1a0c89432f958cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java b/src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java\nindex 369e19d9b..450851334 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java\n\n@@ -336,7 +336,7 @@ public abstract class GATKSparkTool extends SparkCommandLineProgram {\n     protected JavaRDD<GATKRead> getGatkReadJavaRDD(TraversalParameters traversalParameters, ReadsSparkSource source, GATKPathSpecifier inputSpecifier) {\n         JavaRDD<GATKRead> output;\n         // TODO: This if statement is a temporary hack until #959 gets resolve\n-        if (inputSpecifier.getURIString().endsWith(\".adam\")) {\n+        if (inputSpecifier.hasExtension(\".adam\")) {\n             try {\n                 output = source.getADAMReads(inputSpecifier, traversalParameters, getHeaderForReads());\n             } catch (IOException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNzkwNg==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421037906", "bodyText": "A good improvement would be to add spark ReadInputArgument collections which only takes a single bam. Maybe we can do that in a separate pr.", "author": "lbergelson", "createdAt": "2020-05-06T19:27:15Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -504,20 +504,25 @@ public boolean useVariantAnnotations() {\n     }\n \n     /**\n-     * Returns the name of the source of reads data. It can be a file name or URL.\n+     * Returns the name of the source of reads data. It can be a file name or URL. Throws if the tool has more", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3MzEwNA==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426873104", "bodyText": "Yes, but lets do that in a separate PR.", "author": "cmnbroad", "createdAt": "2020-05-18T20:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNzkwNg=="}], "type": "inlineReview", "revised_code": {"commit": "c066a803e9e185ab25c87d97a1a0c89432f958cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java b/src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java\nindex 369e19d9b..450851334 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java\n\n@@ -517,7 +517,7 @@ public abstract class GATKSparkTool extends SparkCommandLineProgram {\n     /**\n      * Returns the header for a given input.\n      */\n-    protected SAMFileHeader getHeaderForInputPath(final GATKPathSpecifier inputPathSpecifier){\n+    protected SAMFileHeader getHeaderForReadsInput(final GATKPathSpecifier inputPathSpecifier){\n         final SAMFileHeader header = readInputs.get(inputPathSpecifier);\n         if (header == null) {\n             throw new GATKException(String.format(\"Input %s not present in tool inputs\", inputPathSpecifier.getRawInputString()));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzODI4NA==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421038284", "bodyText": "maybe getHeaderForReadsInput would be better.", "author": "lbergelson", "createdAt": "2020-05-06T19:27:59Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -504,20 +504,25 @@ public boolean useVariantAnnotations() {\n     }\n \n     /**\n-     * Returns the name of the source of reads data. It can be a file name or URL.\n+     * Returns the name of the source of reads data. It can be a file name or URL. Throws if the tool has more\n+     * than one source.\n      */\n-    protected List<String> getReadSourceName(){\n+    protected String getReadSourceName(){\n         if (readInputs.size() > 1) {\n-            throw new GATKException(\"Multiple ReadsDataSources specificed but a single source requested by the tool\");\n+            throw new GATKException(\"Multiple ReadsDataSources specified but a single source requested by the tool\");\n         }\n-        return new ArrayList<>(readInputs.keySet());\n+        return readInputs.keySet().stream().findFirst().get().toString();\n     }\n \n     /**\n-     * Returns a map of read input to header.\n+     * Returns the header for a given input.\n      */\n-    protected LinkedHashMap<String, SAMFileHeader> getReadSourceHeaderMap(){\n-        return readInputs;\n+    protected SAMFileHeader getHeaderForInputPath(final GATKPathSpecifier inputPathSpecifier){", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzOTI3NA==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421039274", "bodyText": "If we're changing other stuff to single read inputs maybe we should just change the underlying map into a single field.  I think that plan had been to support multiple inputs later but we never got to it.", "author": "lbergelson", "createdAt": "2020-05-06T19:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzODI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3NDM2Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426874363", "bodyText": "All I did here was to change the signature of the method so that we don't have to hand out the map. Instead the caller just queries it. So I think this change is orthogonal to the number of inputs.", "author": "cmnbroad", "createdAt": "2020-05-18T20:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzODI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM2MzEzNg==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r431363136", "bodyText": "Changed the name to getHeaderForReadsInput.", "author": "cmnbroad", "createdAt": "2020-05-27T18:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzODI4NA=="}], "type": "inlineReview", "revised_code": {"commit": "c066a803e9e185ab25c87d97a1a0c89432f958cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java b/src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java\nindex 369e19d9b..450851334 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java\n\n@@ -517,7 +517,7 @@ public abstract class GATKSparkTool extends SparkCommandLineProgram {\n     /**\n      * Returns the header for a given input.\n      */\n-    protected SAMFileHeader getHeaderForInputPath(final GATKPathSpecifier inputPathSpecifier){\n+    protected SAMFileHeader getHeaderForReadsInput(final GATKPathSpecifier inputPathSpecifier){\n         final SAMFileHeader header = readInputs.get(inputPathSpecifier);\n         if (header == null) {\n             throw new GATKException(String.format(\"Input %s not present in tool inputs\", inputPathSpecifier.getRawInputString()));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MjU1NA==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421042554", "bodyText": "As mentioned above, lets add methods for these to GATKPathSpecifier", "author": "lbergelson", "createdAt": "2020-05-06T19:35:31Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "diffHunk": "@@ -156,9 +157,9 @@ private SAMFileGATKReadWriter prepareSAMFileWriter(\n             SAMFileWriterFactory samFileWriterFactory,\n             SAMFileHeader samFileHeaderIn,\n             final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadFiles().get(0).getName());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadFiles().get(0).getName());\n-        final File outFile = new File(OUTPUT_DIRECTORY, base + keyName + extension);\n+        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3NDQxMA==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426874410", "bodyText": "Done.", "author": "cmnbroad", "createdAt": "2020-05-18T20:25:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MjU1NA=="}], "type": "inlineReview", "revised_code": {"commit": "c066a803e9e185ab25c87d97a1a0c89432f958cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java b/src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java\nindex e97fe249c..6dce90750 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java\n\n@@ -146,20 +143,15 @@ public final class SplitReads extends ReadWalker {\n             // attribute for which a given read/group has no value; anything else indicates a coding error\n             throw new GATKException.ShouldNeverReachHereException(\"Unrecognized attribute value found: \" + attributeValue);\n         }\n-        final SAMFileWriterFactory samFileWriterFactory = new SAMFileWriterFactory();\n-        final SAMFileHeader samFileHeaderIn = getHeaderForReads();\n-\n-        return prepareSAMFileWriter(samFileWriterFactory, samFileHeaderIn, attributeValue);\n+        return prepareSAMFileWriter(attributeValue);\n     }\n \n     //  Create a new output file and prepare and return the corresponding SAMFileGATKReadWriter.\n-    private SAMFileGATKReadWriter prepareSAMFileWriter(\n-            SAMFileWriterFactory samFileWriterFactory,\n-            SAMFileHeader samFileHeaderIn,\n-            final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n-        final GATKPathSpecifier outFile = new GATKPathSpecifier(new File(OUTPUT_DIRECTORY, base + keyName + extension).getAbsolutePath());\n+    private SAMFileGATKReadWriter prepareSAMFileWriter(final String keyName) {\n+        final GATKPathSpecifier pathSpec = readArguments.getReadPathSpecifiers().get(0);\n+        final GATKPathSpecifier outFile = new GATKPathSpecifier(\n+                OUTPUT_DIRECTORY.toPath().resolve(pathSpec.getBaseName() + keyName + pathSpec.getExtension()).toString()\n+        );\n         return createSAMWriter(outFile, true);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjQ5NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421086495", "bodyText": "While we're here can we make OUTPUT_DIRECTORY a GATKPathSpecifier too and avoid going through File here.", "author": "lbergelson", "createdAt": "2020-05-06T20:56:03Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "diffHunk": "@@ -156,9 +157,9 @@ private SAMFileGATKReadWriter prepareSAMFileWriter(\n             SAMFileWriterFactory samFileWriterFactory,\n             SAMFileHeader samFileHeaderIn,\n             final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadFiles().get(0).getName());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadFiles().get(0).getName());\n-        final File outFile = new File(OUTPUT_DIRECTORY, base + keyName + extension);\n+        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n+        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n+        final GATKPathSpecifier outFile = new GATKPathSpecifier(new File(OUTPUT_DIRECTORY, base + keyName + extension).getAbsolutePath());", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMxNDMwNw==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r427314307", "bodyText": "Done.", "author": "cmnbroad", "createdAt": "2020-05-19T13:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjQ5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c066a803e9e185ab25c87d97a1a0c89432f958cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java b/src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java\nindex e97fe249c..6dce90750 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java\n\n@@ -146,20 +143,15 @@ public final class SplitReads extends ReadWalker {\n             // attribute for which a given read/group has no value; anything else indicates a coding error\n             throw new GATKException.ShouldNeverReachHereException(\"Unrecognized attribute value found: \" + attributeValue);\n         }\n-        final SAMFileWriterFactory samFileWriterFactory = new SAMFileWriterFactory();\n-        final SAMFileHeader samFileHeaderIn = getHeaderForReads();\n-\n-        return prepareSAMFileWriter(samFileWriterFactory, samFileHeaderIn, attributeValue);\n+        return prepareSAMFileWriter(attributeValue);\n     }\n \n     //  Create a new output file and prepare and return the corresponding SAMFileGATKReadWriter.\n-    private SAMFileGATKReadWriter prepareSAMFileWriter(\n-            SAMFileWriterFactory samFileWriterFactory,\n-            SAMFileHeader samFileHeaderIn,\n-            final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n-        final GATKPathSpecifier outFile = new GATKPathSpecifier(new File(OUTPUT_DIRECTORY, base + keyName + extension).getAbsolutePath());\n+    private SAMFileGATKReadWriter prepareSAMFileWriter(final String keyName) {\n+        final GATKPathSpecifier pathSpec = readArguments.getReadPathSpecifiers().get(0);\n+        final GATKPathSpecifier outFile = new GATKPathSpecifier(\n+                OUTPUT_DIRECTORY.toPath().resolve(pathSpec.getBaseName() + keyName + pathSpec.getExtension()).toString()\n+        );\n         return createSAMWriter(outFile, true);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODExOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421088119", "bodyText": "might have weirdness with http paths with cruft after them", "author": "lbergelson", "createdAt": "2020-05-06T20:59:02Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/RevertSamSpark.java", "diffHunk": "@@ -269,7 +269,7 @@ protected void runTool(JavaSparkContext ctx) {\n         ////////////////////////////////////////////////////////////////////////////\n         Map<String, Path> writerMap = getOutputMap(outputMap,\n                                                   output,\n-                                                  getDefaultExtension(readArguments.getReadFiles().get(0).toString(), outputByReadgroupFileFormat),\n+                                                  getDefaultExtension(readArguments.getReadPathSpecifiers().get(0).getRawInputString(), outputByReadgroupFileFormat),", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMxNDQ3Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r427314472", "bodyText": "Done.", "author": "cmnbroad", "createdAt": "2020-05-19T13:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODExOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c066a803e9e185ab25c87d97a1a0c89432f958cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/spark/RevertSamSpark.java b/src/main/java/org/broadinstitute/hellbender/tools/spark/RevertSamSpark.java\nindex 9108a0556..289076c95 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/spark/RevertSamSpark.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/spark/RevertSamSpark.java\n\n@@ -269,7 +270,7 @@ public class RevertSamSpark extends GATKSparkTool {\n         ////////////////////////////////////////////////////////////////////////////\n         Map<String, Path> writerMap = getOutputMap(outputMap,\n                                                   output,\n-                                                  getDefaultExtension(readArguments.getReadPathSpecifiers().get(0).getRawInputString(), outputByReadgroupFileFormat),\n+                                                  getDefaultExtension(readArguments.getReadPathSpecifiers().get(0), outputByReadgroupFileFormat),\n                                                   localHeader.getReadGroups(),\n                                                   outputByReadGroup);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODcyNA==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421088724", "bodyText": "Can we lift the GATKPathSpecifier higher here and get rid of the string or is that difficult?", "author": "lbergelson", "createdAt": "2020-05-06T20:59:59Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PSUtils.java", "diffHunk": "@@ -57,12 +58,13 @@ public static void logItemizedWarning(final Logger logger, final Collection<?> i\n     /**\n      * Same as GATKSparkTool's getRecommendedNumReducers(), but can specify input BAM path (for when --input is not used)\n      */\n+    //TODO: fix this", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2NjY3NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r427466675", "bodyText": "It starts a cascade so it will be in a different pr.", "author": "cmnbroad", "createdAt": "2020-05-19T17:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODcyNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4OTI1NA==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421089254", "bodyText": "Can these paths be input as Path specifiers instead of strings here?", "author": "lbergelson", "createdAt": "2020-05-06T21:00:54Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java", "diffHunk": "@@ -152,12 +153,12 @@\n                                                              final ReadsSparkSource readsSource) {\n         if (path == null) return null;", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM4MDYzNg==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r427380636", "bodyText": "Yes, but it pulls on a longer thread. The pathseq package needs its own PR.", "author": "cmnbroad", "createdAt": "2020-05-19T15:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4OTI1NA=="}], "type": "inlineReview", "revised_code": {"commit": "7aef0fd68077685860512a6d8e530673ec900b21", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java b/src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java\nindex 2d812e189..fcf15fd34 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java\n\n@@ -157,8 +150,8 @@ public final class PathSeqBwaSpark extends GATKSparkTool {\n             if (header.getSequenceDictionary() != null && !header.getSequenceDictionary().isEmpty()) {\n                 throw new UserException.BadInput(\"Input BAM should be unaligned, but found one or more sequences in the header.\");\n             }\n-            PSBwaUtils.addReferenceSequencesToHeader(header, bwaArgs.referencePath, getReferenceWindowFunction());\n-            final JavaRDD<GATKRead> reads = readsSource.getParallelReads(new GATKPathSpecifier(path), null, null, bamPartitionSplitSize, useNio);\n+            PSBwaUtils.addReferenceSequencesToHeader(header, bwaArgs.microbeDictionary);\n+            final JavaRDD<GATKRead> reads = readsSource.getParallelReads(new GATKPathSpecifier(path), null, null, bamPartitionSplitSize);\n             return new Tuple2<>(header, reads);\n         }\n         logger.warn(\"Could not find file \" + path + \". Skipping...\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4OTU4NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421089585", "bodyText": "looks like the same thread as above, I assume the todos mean we should hit them later instead of in this PR?  Should we open an issue?", "author": "lbergelson", "createdAt": "2020-05-06T21:01:33Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqScoreSpark.java", "diffHunk": "@@ -136,13 +137,15 @@\n \n     private int recommendedNumReducers = 0;\n \n+    //TODO: fix this", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM5MjYzNg==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r427392636", "bodyText": "Replaced these with #6610 to track remaining todos.", "author": "cmnbroad", "createdAt": "2020-05-19T15:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4OTU4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c066a803e9e185ab25c87d97a1a0c89432f958cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqScoreSpark.java b/src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqScoreSpark.java\nindex 1783a9b3e..97d069f12 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqScoreSpark.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqScoreSpark.java\n\n@@ -137,12 +137,10 @@ public class PathSeqScoreSpark extends GATKSparkTool {\n \n     private int recommendedNumReducers = 0;\n \n-    //TODO: fix this\n     private Tuple2<JavaRDD<GATKRead>, SAMFileHeader> readInputWithHeader(final String path,\n                                                                          final ReadsSparkSource readsSource) {\n         if (path != null) {\n             if (BucketUtils.fileExists(path)) {\n-                //TODO: fix this\n                 recommendedNumReducers += PSUtils.pathseqGetRecommendedNumReducers(path, numReducers, getTargetPartitionSize());\n                 final SAMFileHeader header = readsSource.getHeader(new GATKPathSpecifier(path), null);\n                 JavaRDD<GATKRead> reads = readsSource.getParallelReads(new GATKPathSpecifier(path), null, null, bamPartitionSplitSize, useNio);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTU2NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421091565", "bodyText": "Let's burn this whole class with fire.", "author": "lbergelson", "createdAt": "2020-05-06T21:04:58Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/gcs/BucketUtils.java", "diffHunk": "@@ -122,6 +132,7 @@ public static boolean isRemoteStorageUrl(String path) {\n      * @param path the path\n      * @return an absolute file path if the original path was a relative file path, otherwise the original path\n      */\n+    //TODO: get rid of this..", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2Njk1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r427466952", "bodyText": "Yes, but still more work to do to get there.", "author": "cmnbroad", "createdAt": "2020-05-19T17:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTU2NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTg2Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421091866", "bodyText": "this needs a convenience method", "author": "lbergelson", "createdAt": "2020-05-06T21:05:33Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/io/IOUtils.java", "diffHunk": "@@ -57,10 +57,10 @@\n     private static final Pattern GENOMICSDB_URI_PATTERN = Pattern.compile(\"^\" + GENOMIC_DB_URI_SCHEME + \"(\\\\.?)(.*)(://)(.*)\");\n \n     /**\n-     * Returns true if the file's extension is CRAM.\n+     * Returns true if the GATKPathSpecifier's extension is CRAM.\n      */\n-    public static boolean isCramFile(final File inputFile) {\n-        return isCramFileName(inputFile.getName());\n+    public static boolean isCramFile(final GATKPathSpecifier pathSpec) {\n+        return pathSpec != null && FileExtensions.CRAM.equalsIgnoreCase(\".\" + FilenameUtils.getExtension(pathSpec.getURI().getPath()));", "originalCommit": "921e051ca633b9282340864620806d950532c8c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3NDU3OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426874579", "bodyText": "Done.", "author": "cmnbroad", "createdAt": "2020-05-18T20:26:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTg2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c066a803e9e185ab25c87d97a1a0c89432f958cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/utils/io/IOUtils.java b/src/main/java/org/broadinstitute/hellbender/utils/io/IOUtils.java\nindex 4d806f8f6..53ec5a305 100644\n--- a/src/main/java/org/broadinstitute/hellbender/utils/io/IOUtils.java\n+++ b/src/main/java/org/broadinstitute/hellbender/utils/io/IOUtils.java\n\n@@ -56,34 +56,6 @@ public final class IOUtils {\n      */\n     private static final Pattern GENOMICSDB_URI_PATTERN = Pattern.compile(\"^\" + GENOMIC_DB_URI_SCHEME + \"(\\\\.?)(.*)(://)(.*)\");\n \n-    /**\n-     * Returns true if the GATKPathSpecifier's extension is CRAM.\n-     */\n-    public static boolean isCramFile(final GATKPathSpecifier pathSpec) {\n-        return pathSpec != null && FileExtensions.CRAM.equalsIgnoreCase(\".\" + FilenameUtils.getExtension(pathSpec.getURI().getPath()));\n-    }\n-\n-    /**\n-     * Returns true if the file's extension is CRAM.\n-     */\n-    public static boolean isCramFile(final Path path) {\n-        return isCramFileName(path.getFileName().toString());\n-    }\n-\n-    /**\n-     * Returns true if the file's extension is CRAM.\n-     */\n-    public static boolean isCramFileName(final String inputFileName) {\n-        return isCramFile(new GATKPathSpecifier(inputFileName));\n-    }\n-\n-    /**\n-     * Returns true if the file's extension is BAM.\n-     */\n-    public static boolean isBamFileName(final String inputFileName) {\n-        return FileExtensions.BAM.equalsIgnoreCase(\".\" + FilenameUtils.getExtension(inputFileName));\n-    }\n-\n     /**\n      * Given a Path, determine if it is an HDF5 file without requiring that we're on a platform that supports\n      * HDF5 (let the caller decide if a return value of false is fatal).\n"}}, {"oid": "c066a803e9e185ab25c87d97a1a0c89432f958cf", "url": "https://github.com/broadinstitute/gatk/commit/c066a803e9e185ab25c87d97a1a0c89432f958cf", "message": "Rebase and fix code to enable the merge build to compile on travis.", "committedDate": "2020-05-19T14:45:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NTMzMA==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428295330", "bodyText": "There needs to be a comment about the different behavior on both methods javadoc. Otherwise people will accidentally interchange file.getExtension().equals(\".fasta.gz\") and file.hasExtension(\".fasta.gz\")", "author": "lbergelson", "createdAt": "2020-05-20T20:42:14Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot < lastComponent.length() - 1) {\n+                    // return a string that includes the leading \".\" to enable easy comparison with the many\n+                    // internal file extension constants we have that include the leading \".\" (i.e., in htsjdk),\n+                    // and also for API consistency (since hasExtension() requires the candidate extension to\n+                    // include a leading \".\", this allows hasExtension(getExtension()) to always work whenever\n+                    // getExtension() succeeds\n+                    return lastComponent.substring(indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));\n+    }\n+\n+    /**\n+     * Return true if the path component (the hierarchical part of the scheme specific part of the underlying URI)\n+     * ends with the provided {@code extension} string.\n+     *\n+     * @param extension the target extension to test, INCLUDING the leading \".\". May not be null.\n+     * @return true if the path component of this specifier ends with the extension, otherwise false\n+     */\n+    default boolean hasExtension(final String extension) {\n+        Utils.nonNull(extension, \"Target extension must not be null\");\n+        Utils.validateArg(extension.length() > 1, \"Target extension must be length > 1\");\n+        Utils.validateArg(extension.charAt(0) == '.', \"Target extension must include the leading '.'\");\n+\n+        // We don't want to use {@code #getExtension} here, since it won't work correctly if we're comparing an\n+        // extension that uses multiple . chars, such as .fasta.gz., and {@code #getExtension} will throw if there", "originalCommit": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNjI4Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r430716282", "bodyText": "Done.", "author": "cmnbroad", "createdAt": "2020-05-26T21:24:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NTMzMA=="}], "type": "inlineReview", "revised_code": {"commit": "a7015d2c7fda3220bafa07ee70411e3d95c40fcd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java b/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\nindex 63b3e2e7f..40a432cc8 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\n\n@@ -79,9 +79,11 @@ public interface PathURI {\n     /**\n      * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n      * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n-     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\" (the {@link #hasExtension(String)} method\n+     * can be used to test for the presence of multi-part extensions such as this). If the hierarchical name ends\n+     * with a last component that does not contain a \".\", returns an empty String.\n      * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n-     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     * (i.e. \"/\").\n      */\n     default String getExtension() {\n         final String hierarchicalPath = getURI().getPath();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NTc5Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428295792", "bodyText": "In order to use this safely there probably needs to be a matching hasExtension().  Otherwise people are forced to catch the exception in order to call this safely.", "author": "lbergelson", "createdAt": "2020-05-20T20:43:11Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {", "originalCommit": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTk0OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r430715949", "bodyText": "I modified both getExtension and getBaseName to return \"\" if there is no extension or basename.", "author": "cmnbroad", "createdAt": "2020-05-26T21:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NTc5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a7015d2c7fda3220bafa07ee70411e3d95c40fcd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java b/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\nindex 63b3e2e7f..40a432cc8 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\n\n@@ -79,9 +79,11 @@ public interface PathURI {\n     /**\n      * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n      * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n-     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\" (the {@link #hasExtension(String)} method\n+     * can be used to test for the presence of multi-part extensions such as this). If the hierarchical name ends\n+     * with a last component that does not contain a \".\", returns an empty String.\n      * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n-     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     * (i.e. \"/\").\n      */\n     default String getExtension() {\n         final String hierarchicalPath = getURI().getPath();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5Njc0Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428296743", "bodyText": "This seems like the wrong error message.", "author": "lbergelson", "createdAt": "2020-05-20T20:45:04Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot < lastComponent.length() - 1) {\n+                    // return a string that includes the leading \".\" to enable easy comparison with the many\n+                    // internal file extension constants we have that include the leading \".\" (i.e., in htsjdk),\n+                    // and also for API consistency (since hasExtension() requires the candidate extension to\n+                    // include a leading \".\", this allows hasExtension(getExtension()) to always work whenever\n+                    // getExtension() succeeds\n+                    return lastComponent.substring(indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));\n+    }\n+\n+    /**\n+     * Return true if the path component (the hierarchical part of the scheme specific part of the underlying URI)\n+     * ends with the provided {@code extension} string.\n+     *\n+     * @param extension the target extension to test, INCLUDING the leading \".\". May not be null.\n+     * @return true if the path component of this specifier ends with the extension, otherwise false\n+     */\n+    default boolean hasExtension(final String extension) {\n+        Utils.nonNull(extension, \"Target extension must not be null\");\n+        Utils.validateArg(extension.length() > 1, \"Target extension must be length > 1\");\n+        Utils.validateArg(extension.charAt(0) == '.', \"Target extension must include the leading '.'\");\n+\n+        // We don't want to use {@code #getExtension} here, since it won't work correctly if we're comparing an\n+        // extension that uses multiple . chars, such as .fasta.gz., and {@code #getExtension} will throw if there\n+        // is no extension.\n+        return getURI().getPath().toLowerCase().endsWith(extension.toLowerCase());\n+    }\n+\n+    /**\n+     * @return the base name (the last component of the hierarchical part of the scheme-specific part of the URI,\n+     * after the last \"/\"), up to but not including the extension (the last \".\").\n+     * @throws IllegalArgumentException if the last component is empty (ie, the component ends in \"/\"), or the last\n+     * component exists but starts with \".\"\n+     */\n+    default String getBaseName() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot > 1) {\n+                    return lastComponent.substring(0, indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));", "originalCommit": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNzkwNA==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r430717904", "bodyText": "Removed the throw and now returns \"\".", "author": "cmnbroad", "createdAt": "2020-05-26T21:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5Njc0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a7015d2c7fda3220bafa07ee70411e3d95c40fcd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java b/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\nindex 63b3e2e7f..40a432cc8 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\n\n@@ -79,9 +79,11 @@ public interface PathURI {\n     /**\n      * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n      * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n-     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\" (the {@link #hasExtension(String)} method\n+     * can be used to test for the presence of multi-part extensions such as this). If the hierarchical name ends\n+     * with a last component that does not contain a \".\", returns an empty String.\n      * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n-     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     * (i.e. \"/\").\n      */\n     default String getExtension() {\n         final String hierarchicalPath = getURI().getPath();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5OTM0Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428299347", "bodyText": "I think it might be better to be greedy about the extension and include everything after the first . as the extension? fasta.gz and bam.bai seem more common than \"my.filename.has.random.dots.fasta\".  Maybe I'm wrong about that though.\nTypically when people call baseName it's because they want to create a similarly name file with a different extension, so stripping all the extensions makes sense.\nI think the comment about the componentExisting but starting with \".\" doesn't match the tests where you have \".fasta.gz\".baseName() == \".fasta\".", "author": "lbergelson", "createdAt": "2020-05-20T20:50:17Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot < lastComponent.length() - 1) {\n+                    // return a string that includes the leading \".\" to enable easy comparison with the many\n+                    // internal file extension constants we have that include the leading \".\" (i.e., in htsjdk),\n+                    // and also for API consistency (since hasExtension() requires the candidate extension to\n+                    // include a leading \".\", this allows hasExtension(getExtension()) to always work whenever\n+                    // getExtension() succeeds\n+                    return lastComponent.substring(indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));\n+    }\n+\n+    /**\n+     * Return true if the path component (the hierarchical part of the scheme specific part of the underlying URI)\n+     * ends with the provided {@code extension} string.\n+     *\n+     * @param extension the target extension to test, INCLUDING the leading \".\". May not be null.\n+     * @return true if the path component of this specifier ends with the extension, otherwise false\n+     */\n+    default boolean hasExtension(final String extension) {\n+        Utils.nonNull(extension, \"Target extension must not be null\");\n+        Utils.validateArg(extension.length() > 1, \"Target extension must be length > 1\");\n+        Utils.validateArg(extension.charAt(0) == '.', \"Target extension must include the leading '.'\");\n+\n+        // We don't want to use {@code #getExtension} here, since it won't work correctly if we're comparing an\n+        // extension that uses multiple . chars, such as .fasta.gz., and {@code #getExtension} will throw if there\n+        // is no extension.\n+        return getURI().getPath().toLowerCase().endsWith(extension.toLowerCase());\n+    }\n+\n+    /**\n+     * @return the base name (the last component of the hierarchical part of the scheme-specific part of the URI,\n+     * after the last \"/\"), up to but not including the extension (the last \".\").\n+     * @throws IllegalArgumentException if the last component is empty (ie, the component ends in \"/\"), or the last\n+     * component exists but starts with \".\"\n+     */\n+    default String getBaseName() {", "originalCommit": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjY4NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428306685", "bodyText": "We might want to prefer returning empty string when the base name/ extension are empty.   (not when they're missing because the file ends in \"/\" though...).", "author": "lbergelson", "createdAt": "2020-05-20T21:04:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5OTM0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "a7015d2c7fda3220bafa07ee70411e3d95c40fcd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java b/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\nindex 63b3e2e7f..40a432cc8 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\n\n@@ -79,9 +79,11 @@ public interface PathURI {\n     /**\n      * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n      * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n-     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\" (the {@link #hasExtension(String)} method\n+     * can be used to test for the presence of multi-part extensions such as this). If the hierarchical name ends\n+     * with a last component that does not contain a \".\", returns an empty String.\n      * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n-     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     * (i.e. \"/\").\n      */\n     default String getExtension() {\n         final String hierarchicalPath = getURI().getPath();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMDAyNw==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428300027", "bodyText": "Is this problematic with files that are at the root of the directory structure or with relative paths that don't include any path above the filename?", "author": "lbergelson", "createdAt": "2020-05-20T20:51:37Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {", "originalCommit": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4NDE1Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r431384156", "bodyText": "I don't think it is. The underlying URI always has a scheme with an (possibly empty) auth, and if the scheme is file, the path component is always an absolute path from the root, even if the input string was a relative path. There are tests for such cases, i.e., localFile.bam and /localFile.bam, so I think its ok.", "author": "cmnbroad", "createdAt": "2020-05-27T19:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMDAyNw=="}], "type": "inlineReview", "revised_code": {"commit": "a7015d2c7fda3220bafa07ee70411e3d95c40fcd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java b/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\nindex 63b3e2e7f..40a432cc8 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/PathURI.java\n\n@@ -79,9 +79,11 @@ public interface PathURI {\n     /**\n      * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n      * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n-     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\" (the {@link #hasExtension(String)} method\n+     * can be used to test for the presence of multi-part extensions such as this). If the hierarchical name ends\n+     * with a last component that does not contain a \".\", returns an empty String.\n      * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n-     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     * (i.e. \"/\").\n      */\n     default String getExtension() {\n         final String hierarchicalPath = getURI().getPath();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMTA2OA==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428301068", "bodyText": "Should we mark this as a todo when we get resolve methods on GATKPathSpecifier directly?", "author": "lbergelson", "createdAt": "2020-05-20T20:53:37Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "diffHunk": "@@ -146,20 +143,15 @@ private SAMFileGATKReadWriter createUnknownOutOnDemand(String attributeValue) {\n             // attribute for which a given read/group has no value; anything else indicates a coding error\n             throw new GATKException.ShouldNeverReachHereException(\"Unrecognized attribute value found: \" + attributeValue);\n         }\n-        final SAMFileWriterFactory samFileWriterFactory = new SAMFileWriterFactory();\n-        final SAMFileHeader samFileHeaderIn = getHeaderForReads();\n-\n-        return prepareSAMFileWriter(samFileWriterFactory, samFileHeaderIn, attributeValue);\n+        return prepareSAMFileWriter(attributeValue);\n     }\n \n     //  Create a new output file and prepare and return the corresponding SAMFileGATKReadWriter.\n-    private SAMFileGATKReadWriter prepareSAMFileWriter(\n-            SAMFileWriterFactory samFileWriterFactory,\n-            SAMFileHeader samFileHeaderIn,\n-            final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n-        final GATKPathSpecifier outFile = new GATKPathSpecifier(new File(OUTPUT_DIRECTORY, base + keyName + extension).getAbsolutePath());\n+    private SAMFileGATKReadWriter prepareSAMFileWriter(final String keyName) {\n+        final GATKPathSpecifier pathSpec = readArguments.getReadPathSpecifiers().get(0);\n+        final GATKPathSpecifier outFile = new GATKPathSpecifier(", "originalCommit": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4NzQ1MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r431387451", "bodyText": "Added to #6610.", "author": "cmnbroad", "createdAt": "2020-05-27T19:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMTA2OA=="}], "type": "inlineReview", "revised_code": {"commit": "a074242e86d54362cba10d84b38e233ca13ef934", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java b/src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java\nindex 6dce90750..024127b7e 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java\n\n@@ -143,15 +145,20 @@ public final class SplitReads extends ReadWalker {\n             // attribute for which a given read/group has no value; anything else indicates a coding error\n             throw new GATKException.ShouldNeverReachHereException(\"Unrecognized attribute value found: \" + attributeValue);\n         }\n-        return prepareSAMFileWriter(attributeValue);\n+        final SAMFileWriterFactory samFileWriterFactory = new SAMFileWriterFactory();\n+        final SAMFileHeader samFileHeaderIn = getHeaderForReads();\n+\n+        return prepareSAMFileWriter(samFileWriterFactory, samFileHeaderIn, attributeValue);\n     }\n \n     //  Create a new output file and prepare and return the corresponding SAMFileGATKReadWriter.\n-    private SAMFileGATKReadWriter prepareSAMFileWriter(final String keyName) {\n-        final GATKPathSpecifier pathSpec = readArguments.getReadPathSpecifiers().get(0);\n-        final GATKPathSpecifier outFile = new GATKPathSpecifier(\n-                OUTPUT_DIRECTORY.toPath().resolve(pathSpec.getBaseName() + keyName + pathSpec.getExtension()).toString()\n-        );\n+    private SAMFileGATKReadWriter prepareSAMFileWriter(\n+            SAMFileWriterFactory samFileWriterFactory,\n+            SAMFileHeader samFileHeaderIn,\n+            final String keyName) {\n+        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n+        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n+        final File outFile = new File(OUTPUT_DIRECTORY, base + keyName + extension);\n         return createSAMWriter(outFile, true);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzYwNA==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428303604", "bodyText": "Maybe this is inconsistent, but we should allow a basename to not have an extension.  localFile's base name is just \"localFile\" I think.", "author": "lbergelson", "createdAt": "2020-05-20T20:58:30Z", "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "diffHunk": "@@ -286,6 +287,173 @@ public void testStdOut() throws IOException {\n         }\n     }\n \n+    @DataProvider(name = \"getExtensionTestCases\")\n+    public Object[][] getExtensionTestCases() {\n+        return new Object[][] {\n+                // input, extension\n+                {\"localFile.bam\", \".bam\"},\n+                {\"localFile.BAM\", \".BAM\"},\n+                {\"/localFile.bam\", \".bam\"},\n+                {\"gs://bucket/aFile.bam\", \".bam\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\"},\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\"},\n+\n+                // getExtension() returns \".gz\", but this case also satisfies hasExtension(\".fasta.gz\")\n+                {\"aFile.fasta.gz\", \".gz\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getExtensionTestCases\")\n+    public void testGetExtension(final String spec, final String expectedExtension) {\n+        final GATKPathSpecifier pathSpec = new GATKPathSpecifier(spec);\n+        final String actualExtension = pathSpec.getExtension();\n+\n+        Assert.assertEquals(actualExtension, expectedExtension);\n+        // verify that hasExtension(getExtension()) is always true\n+        Assert.assertTrue(pathSpec.hasExtension(actualExtension));\n+    }\n+\n+    @DataProvider(name=\"negativeGetExtensionTestCases\")\n+    public Object[][] negativeGetExtensionTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"\"},\n+                {\"/\"},\n+                {\".\"},\n+                {\"localFile\"},\n+                {\"localFile.\"},\n+                {\"/localFile.\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetExtensionTestCases\", expectedExceptions={IllegalArgumentException.class})\n+    public void testNegativeGetExtension(final String spec) {\n+        new GATKPathSpecifier(spec).getExtension();\n+    }\n+\n+    @DataProvider(name = \"hasExtensionTestCases\")\n+    public Object[][] hasExtensionTestCases() {\n+        return new Object[][]{\n+                // input, extension satisfies \"hasExtension\"\n+                {\"localFile.bam\", \".bam\", true },\n+                {\"localFile.BAM\", \".BAM\", true },\n+                {\"localFile.BAM\", \".bam\", true },\n+                {\"localFile.bam\", \".BAM\", true },\n+                {\"/localFile.bam\", \".bam\", true },\n+                {\"gs://bucket/aFile.bam\", \".bam\", true },\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\", true },\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\", true },\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\", true },\n+\n+                {\"aFile.fasta.gz\", \".gz\", true },\n+                {\"aFile.fasta.gz\", \".fasta.gz\", true },\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\", true },\n+                {\".fasta.gz\", \".fasta.gz\", true },\n+\n+                // no extensions\n+                {\"/\", \".ext\", false },\n+                {\".\", \".ext\", false },\n+                {\"localFile\", \".a\", false }, // extension must have length > 1\n+                {\"localFile.\", \".a\", false },\n+                {\"gs://hellbender/test/resources\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources?query=param\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/?query=param\", \".fasta\", false },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"hasExtensionTestCases\")\n+    public void testHasExtension(final String spec, final String extension, final boolean expectedResult) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).hasExtension(extension), expectedResult);\n+    }\n+\n+    @DataProvider(name = \"getBaseNameTestCases\")\n+    public Object[][] getBaseNameTestCases() {\n+        return new Object[][] {\n+                // input, baseName\n+                {\"localFile.bam\", \"localFile\"},\n+                {\"localFile.BAM\", \"localFile\"},\n+                {\"/localFile.bam\", \"localFile\"},\n+                {\"gs://bucket/aFile.bam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \"aFile\"},\n+                {\"http://bucket/aFile.bam?query=param\", \"aFile\"},\n+\n+                // This case satisfies hasExtension(\".fasta.gz\"), but getExtension() returns \".gz\".\n+                {\"aFile.fasta.gz\", \"aFile.fasta\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".fasta\",},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getBaseNameTestCases\")\n+    public void testGetBaseName(final String spec, final String baseName) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).getBaseName(), baseName);\n+    }\n+\n+    @DataProvider(name=\"negativeGetBaseNameTestCases\")\n+    public Object[][] negativeGetBaseNameTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"/\"},\n+                {\".\"},\n+                {\"/.\"},\n+                {\"/name/.fasta\"},\n+                {\"localFile\"},\n+                {\"gs://hellbender/test/resources\"},", "originalCommit": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcyNjI0MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r430726241", "bodyText": "Makes sense. Done.", "author": "cmnbroad", "createdAt": "2020-05-26T21:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzYwNA=="}], "type": "inlineReview", "revised_code": {"commit": "a7015d2c7fda3220bafa07ee70411e3d95c40fcd", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java b/src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java\nindex c46fca4cf..a6b815730 100644\n--- a/src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java\n+++ b/src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java\n\n@@ -303,6 +303,13 @@ public class GATKPathSpecifierUnitTest extends GATKBaseTest {\n                 {\"aFile.fasta.gz\", \".gz\"},\n                 // basename is \".fasta\"!\n                 {\".fasta.gz\", \".gz\"},\n+\n+                // no extensions\n+                {\"localFile\", \"\"},\n+                {\"localFile.\", \"\"},\n+                {\"/localFile.\", \"\"},\n+                {\"gs://hellbender/test/resources\", \"\"},\n+                {\"gs://hellbender/test/resources?query=param\", \"\"},\n         };\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjczNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428306735", "bodyText": "Could you add a test for the case \".\".hasExtension(\".\") ?", "author": "lbergelson", "createdAt": "2020-05-20T21:04:58Z", "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "diffHunk": "@@ -286,6 +287,173 @@ public void testStdOut() throws IOException {\n         }\n     }\n \n+    @DataProvider(name = \"getExtensionTestCases\")\n+    public Object[][] getExtensionTestCases() {\n+        return new Object[][] {\n+                // input, extension\n+                {\"localFile.bam\", \".bam\"},\n+                {\"localFile.BAM\", \".BAM\"},\n+                {\"/localFile.bam\", \".bam\"},\n+                {\"gs://bucket/aFile.bam\", \".bam\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\"},\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\"},\n+\n+                // getExtension() returns \".gz\", but this case also satisfies hasExtension(\".fasta.gz\")\n+                {\"aFile.fasta.gz\", \".gz\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getExtensionTestCases\")\n+    public void testGetExtension(final String spec, final String expectedExtension) {\n+        final GATKPathSpecifier pathSpec = new GATKPathSpecifier(spec);\n+        final String actualExtension = pathSpec.getExtension();\n+\n+        Assert.assertEquals(actualExtension, expectedExtension);\n+        // verify that hasExtension(getExtension()) is always true\n+        Assert.assertTrue(pathSpec.hasExtension(actualExtension));\n+    }\n+\n+    @DataProvider(name=\"negativeGetExtensionTestCases\")\n+    public Object[][] negativeGetExtensionTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"\"},\n+                {\"/\"},\n+                {\".\"},\n+                {\"localFile\"},\n+                {\"localFile.\"},\n+                {\"/localFile.\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetExtensionTestCases\", expectedExceptions={IllegalArgumentException.class})\n+    public void testNegativeGetExtension(final String spec) {\n+        new GATKPathSpecifier(spec).getExtension();\n+    }\n+\n+    @DataProvider(name = \"hasExtensionTestCases\")\n+    public Object[][] hasExtensionTestCases() {\n+        return new Object[][]{\n+                // input, extension satisfies \"hasExtension\"\n+                {\"localFile.bam\", \".bam\", true },\n+                {\"localFile.BAM\", \".BAM\", true },\n+                {\"localFile.BAM\", \".bam\", true },\n+                {\"localFile.bam\", \".BAM\", true },\n+                {\"/localFile.bam\", \".bam\", true },\n+                {\"gs://bucket/aFile.bam\", \".bam\", true },\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\", true },\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\", true },\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\", true },\n+\n+                {\"aFile.fasta.gz\", \".gz\", true },\n+                {\"aFile.fasta.gz\", \".fasta.gz\", true },\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\", true },\n+                {\".fasta.gz\", \".fasta.gz\", true },\n+\n+                // no extensions\n+                {\"/\", \".ext\", false },\n+                {\".\", \".ext\", false },", "originalCommit": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcyMTI3MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r430721271", "bodyText": "Hm, it doesn't. \".\" gets turned into a URI with an absolute path that ends in \"/./\".", "author": "cmnbroad", "createdAt": "2020-05-26T21:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjczNQ=="}], "type": "inlineReview", "revised_code": {"commit": "a7015d2c7fda3220bafa07ee70411e3d95c40fcd", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java b/src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java\nindex c46fca4cf..a6b815730 100644\n--- a/src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java\n+++ b/src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java\n\n@@ -303,6 +303,13 @@ public class GATKPathSpecifierUnitTest extends GATKBaseTest {\n                 {\"aFile.fasta.gz\", \".gz\"},\n                 // basename is \".fasta\"!\n                 {\".fasta.gz\", \".gz\"},\n+\n+                // no extensions\n+                {\"localFile\", \"\"},\n+                {\"localFile.\", \"\"},\n+                {\"/localFile.\", \"\"},\n+                {\"gs://hellbender/test/resources\", \"\"},\n+                {\"gs://hellbender/test/resources?query=param\", \"\"},\n         };\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjkzNw==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428306937", "bodyText": "Should we simple tests for isSam, isBam, is Cram ?", "author": "lbergelson", "createdAt": "2020-05-20T21:05:24Z", "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "diffHunk": "@@ -286,6 +287,173 @@ public void testStdOut() throws IOException {\n         }\n     }\n \n+    @DataProvider(name = \"getExtensionTestCases\")\n+    public Object[][] getExtensionTestCases() {\n+        return new Object[][] {\n+                // input, extension\n+                {\"localFile.bam\", \".bam\"},\n+                {\"localFile.BAM\", \".BAM\"},\n+                {\"/localFile.bam\", \".bam\"},\n+                {\"gs://bucket/aFile.bam\", \".bam\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\"},\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\"},\n+\n+                // getExtension() returns \".gz\", but this case also satisfies hasExtension(\".fasta.gz\")\n+                {\"aFile.fasta.gz\", \".gz\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getExtensionTestCases\")\n+    public void testGetExtension(final String spec, final String expectedExtension) {\n+        final GATKPathSpecifier pathSpec = new GATKPathSpecifier(spec);\n+        final String actualExtension = pathSpec.getExtension();\n+\n+        Assert.assertEquals(actualExtension, expectedExtension);\n+        // verify that hasExtension(getExtension()) is always true\n+        Assert.assertTrue(pathSpec.hasExtension(actualExtension));\n+    }\n+\n+    @DataProvider(name=\"negativeGetExtensionTestCases\")\n+    public Object[][] negativeGetExtensionTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"\"},\n+                {\"/\"},\n+                {\".\"},\n+                {\"localFile\"},\n+                {\"localFile.\"},\n+                {\"/localFile.\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetExtensionTestCases\", expectedExceptions={IllegalArgumentException.class})\n+    public void testNegativeGetExtension(final String spec) {\n+        new GATKPathSpecifier(spec).getExtension();\n+    }\n+\n+    @DataProvider(name = \"hasExtensionTestCases\")\n+    public Object[][] hasExtensionTestCases() {\n+        return new Object[][]{\n+                // input, extension satisfies \"hasExtension\"\n+                {\"localFile.bam\", \".bam\", true },\n+                {\"localFile.BAM\", \".BAM\", true },\n+                {\"localFile.BAM\", \".bam\", true },\n+                {\"localFile.bam\", \".BAM\", true },\n+                {\"/localFile.bam\", \".bam\", true },\n+                {\"gs://bucket/aFile.bam\", \".bam\", true },\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\", true },\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\", true },\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\", true },\n+\n+                {\"aFile.fasta.gz\", \".gz\", true },\n+                {\"aFile.fasta.gz\", \".fasta.gz\", true },\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\", true },\n+                {\".fasta.gz\", \".fasta.gz\", true },\n+\n+                // no extensions\n+                {\"/\", \".ext\", false },\n+                {\".\", \".ext\", false },\n+                {\"localFile\", \".a\", false }, // extension must have length > 1\n+                {\"localFile.\", \".a\", false },\n+                {\"gs://hellbender/test/resources\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources?query=param\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/?query=param\", \".fasta\", false },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"hasExtensionTestCases\")\n+    public void testHasExtension(final String spec, final String extension, final boolean expectedResult) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).hasExtension(extension), expectedResult);\n+    }\n+\n+    @DataProvider(name = \"getBaseNameTestCases\")\n+    public Object[][] getBaseNameTestCases() {\n+        return new Object[][] {\n+                // input, baseName\n+                {\"localFile.bam\", \"localFile\"},\n+                {\"localFile.BAM\", \"localFile\"},\n+                {\"/localFile.bam\", \"localFile\"},\n+                {\"gs://bucket/aFile.bam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \"aFile\"},\n+                {\"http://bucket/aFile.bam?query=param\", \"aFile\"},\n+\n+                // This case satisfies hasExtension(\".fasta.gz\"), but getExtension() returns \".gz\".\n+                {\"aFile.fasta.gz\", \"aFile.fasta\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".fasta\",},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getBaseNameTestCases\")\n+    public void testGetBaseName(final String spec, final String baseName) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).getBaseName(), baseName);\n+    }\n+\n+    @DataProvider(name=\"negativeGetBaseNameTestCases\")\n+    public Object[][] negativeGetBaseNameTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"/\"},\n+                {\".\"},\n+                {\"/.\"},\n+                {\"/name/.fasta\"},\n+                {\"localFile\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetBaseNameTestCases\", expectedExceptions = {IllegalArgumentException.class})\n+    public void testNegativeGetBaseName(final String spec) {\n+        new GATKPathSpecifier(spec).getBaseName();\n+    }\n+\n+    @DataProvider(name=\"isFastaTestCases\")\n+    public Object[][] isFastaTestCases() {\n+        final String twoBitRefURL = publicTestDir + \"large/human_g1k_v37.20.21.2bit\";\n+        return new Object[][] {\n+                { twoBitRefURL, false },\n+                { \"file://\" + twoBitRefURL, false },\n+                { hg38Reference, true }, // gzipped\n+                { \"file://\" + hg38Reference, true }, // gzipped\n+                { GCS_b37_CHR20_21_REFERENCE_2BIT, false },\n+                { GCS_b37_CHR20_21_REFERENCE, true },\n+                // dummy query params at the end to make sure URI.getPath does the right thing\n+                { GCS_b37_CHR20_21_REFERENCE + \"?query=param\", true}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"isFastaTestCases\")\n+    public void testIsFasta(final String referenceSpec, final boolean expectedIsFasta) {\n+        Assert.assertEquals(new GATKPathSpecifier(referenceSpec).isFasta(), expectedIsFasta);\n+    }\n+\n+    @DataProvider(name=\"isHadoopURLTestCases\")\n+    public Object[][] isHadoopURLTestCases() {\n+        return new Object[][] {\n+                { GATKPathSpecifier.HDFS_SCHEME + \"://someFile\", true },\n+                { \"file://someFile.bam\", false },\n+                { \"someFile.bam\", false },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"isHadoopURLTestCases\")\n+    public void testIsHadoopURL(final String referenceSpec, final boolean expectedIsHadoop) {\n+        Assert.assertEquals(new GATKPathSpecifier(referenceSpec).isHadoopURL(), expectedIsHadoop);\n+    }\n+", "originalCommit": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcyODc5Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r430728792", "bodyText": "We've come this far so, yes.", "author": "cmnbroad", "createdAt": "2020-05-26T21:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjkzNw=="}], "type": "inlineReview", "revised_code": {"commit": "a7015d2c7fda3220bafa07ee70411e3d95c40fcd", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java b/src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java\nindex c46fca4cf..a6b815730 100644\n--- a/src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java\n+++ b/src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java\n\n@@ -303,6 +303,13 @@ public class GATKPathSpecifierUnitTest extends GATKBaseTest {\n                 {\"aFile.fasta.gz\", \".gz\"},\n                 // basename is \".fasta\"!\n                 {\".fasta.gz\", \".gz\"},\n+\n+                // no extensions\n+                {\"localFile\", \"\"},\n+                {\"localFile.\", \"\"},\n+                {\"/localFile.\", \"\"},\n+                {\"gs://hellbender/test/resources\", \"\"},\n+                {\"gs://hellbender/test/resources?query=param\", \"\"},\n         };\n     }\n \n"}}, {"oid": "a7015d2c7fda3220bafa07ee70411e3d95c40fcd", "url": "https://github.com/broadinstitute/gatk/commit/a7015d2c7fda3220bafa07ee70411e3d95c40fcd", "message": "More code review comments.", "committedDate": "2020-05-27T20:08:21Z", "type": "forcePushed"}, {"oid": "7aef0fd68077685860512a6d8e530673ec900b21", "url": "https://github.com/broadinstitute/gatk/commit/7aef0fd68077685860512a6d8e530673ec900b21", "message": "On second though, use Optional for extension/basename methods. Additional test cases.", "committedDate": "2020-06-02T15:42:35Z", "type": "forcePushed"}, {"oid": "a074242e86d54362cba10d84b38e233ca13ef934", "url": "https://github.com/broadinstitute/gatk/commit/a074242e86d54362cba10d84b38e233ca13ef934", "message": "Migrate reads command line arguments, and downstream code, to use GATKPathSpecifier - Phase 1.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "9256a13c9e38e99890359e62667501565d4858bc", "url": "https://github.com/broadinstitute/gatk/commit/9256a13c9e38e99890359e62667501565d4858bc", "message": "Remove confusing getReadSourceName List interconversions.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "0eaf1eda8fd2f7f4caeb0bd72b11e99171d411a9", "url": "https://github.com/broadinstitute/gatk/commit/0eaf1eda8fd2f7f4caeb0bd72b11e99171d411a9", "message": "Migrate read outputs and writers to GATKPathSpecifier.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "3b32850fe374435eba770f0fea866f999bb57752", "url": "https://github.com/broadinstitute/gatk/commit/3b32850fe374435eba770f0fea866f999bb57752", "message": "Move read index inputs to GATKPathSpecifier.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "a8a3c2a7f6a96e449c45bad98f71460cbd4f7329", "url": "https://github.com/broadinstitute/gatk/commit/a8a3c2a7f6a96e449c45bad98f71460cbd4f7329", "message": "Migrate UserExceptions with File type, and some tool output to GATKPathSpecifier.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "31d9ca6ac394451cbd4527383c4d88fdd27ecf96", "url": "https://github.com/broadinstitute/gatk/commit/31d9ca6ac394451cbd4527383c4d88fdd27ecf96", "message": "Lift getReadPaths up to ReadArgumetnCollection, fix deprecation warning in GATKTool.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "126d045d9caa232862355b2b780a5eb13cf87d26", "url": "https://github.com/broadinstitute/gatk/commit/126d045d9caa232862355b2b780a5eb13cf87d26", "message": "Code review comments.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "ca858641f903060918931f982542435da43b4c37", "url": "https://github.com/broadinstitute/gatk/commit/ca858641f903060918931f982542435da43b4c37", "message": "SplitReads and RevertSamSpark.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "89720305dc94d09bdb521e63e6a029c89af97f88", "url": "https://github.com/broadinstitute/gatk/commit/89720305dc94d09bdb521e63e6a029c89af97f88", "message": "Remove TODOs in favor of an issue ticket.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "20361b7a7ce86c089e8cf4aa4e9a555f40fde1a0", "url": "https://github.com/broadinstitute/gatk/commit/20361b7a7ce86c089e8cf4aa4e9a555f40fde1a0", "message": "Rebase and fix code to enable the merge build to compile on travis.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "2af5162331dfb45f1d6548d7fabf49edc0c0bb1b", "url": "https://github.com/broadinstitute/gatk/commit/2af5162331dfb45f1d6548d7fabf49edc0c0bb1b", "message": "Fix isHadoopURL.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "fa07c551c5164e0438c234fb6633b01191605ffe", "url": "https://github.com/broadinstitute/gatk/commit/fa07c551c5164e0438c234fb6633b01191605ffe", "message": "More code review comments.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "919336aaeb3ec623956d290127f72dc0e508dc7b", "url": "https://github.com/broadinstitute/gatk/commit/919336aaeb3ec623956d290127f72dc0e508dc7b", "message": "Fix incorrectly resolved merge conflict.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "7aef0fd68077685860512a6d8e530673ec900b21", "url": "https://github.com/broadinstitute/gatk/commit/7aef0fd68077685860512a6d8e530673ec900b21", "message": "On second though, use Optional for extension/basename methods. Additional test cases.", "committedDate": "2020-06-02T15:42:35Z", "type": "commit"}, {"oid": "7b561cb3095793b5edc4dfe26150c1f7fc2d81aa", "url": "https://github.com/broadinstitute/gatk/commit/7b561cb3095793b5edc4dfe26150c1f7fc2d81aa", "message": "Update changes in PathSeqBwaSpark from master.", "committedDate": "2020-06-02T16:12:48Z", "type": "commit"}, {"oid": "997fa63493e72a2523102f114843fe11e86598f5", "url": "https://github.com/broadinstitute/gatk/commit/997fa63493e72a2523102f114843fe11e86598f5", "message": "Fix SplitReads to handle Optional returned from getBaseName and getExtension.", "committedDate": "2020-06-02T17:27:39Z", "type": "commit"}]}