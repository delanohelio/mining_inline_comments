{"pr_number": 6512, "pr_title": "Downsample a bam by duplicate sets instead of reads", "pr_createdAt": "2020-03-19T21:14:15Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6512", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1ODcyNg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407558726", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public File outputBam;\n          \n          \n            \n                public GATKPathSpecifier outputBam;", "author": "cmnbroad", "createdAt": "2020-04-13T16:05:49Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1OTcyOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407559729", "bodyText": "We're trying to eliminate the use of File wherever possible,  since its limiting, and rely the more general GATKPathSpecifier.", "author": "cmnbroad", "createdAt": "2020-04-13T16:07:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1ODcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg3MDA3Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408870073", "bodyText": "Done", "author": "takutosato", "createdAt": "2020-04-15T14:07:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1ODcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDc3Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r410460773", "bodyText": "@cmnbroad should I avoid createTempFile() in test classes as well? It creates a File object.", "author": "takutosato", "createdAt": "2020-04-17T20:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1ODcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxNTY4OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r410715689", "bodyText": "@takutosato No - using createTempFile  and File in tests is fine for now. Thanks.", "author": "cmnbroad", "createdAt": "2020-04-18T15:58:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1ODcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0NjQxNA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r412546414", "bodyText": "Awesome, thanks!", "author": "takutosato", "createdAt": "2020-04-21T22:54:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1ODcyNg=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\nindex 1be866536..ccb5d70ed 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n\n@@ -1,34 +1,33 @@\n package org.broadinstitute.hellbender.tools.walkers.consensus;\n \n-import org.apache.commons.math3.random.RandomGenerator;\n-import org.apache.commons.math3.random.RandomGeneratorFactory;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.engine.ReferenceContext;\n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import org.glassfish.jersey.Beta;\n import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n \n-import java.io.File;\n-import java.util.List;\n import java.util.Random;\n \n @CommandLineProgramProperties(\n-        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         programGroup = ReadDataManipulationProgramGroup.class\n )\n /**\n- * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n- * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n  *\n- * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n  *\n- * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n  * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n  * in addition to ones common to the entire cell population.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NTM3OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407565379", "bodyText": "If you use my GATKPathSpecifier suggestion above, you can just call .toPath() on the GATKPathSpecifier instance here.", "author": "cmnbroad", "createdAt": "2020-04-13T16:18:16Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));\n+        outputWriter = createSAMWriter(IOUtils.getPath(outputBam.getAbsolutePath()), false);", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMjMyMA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408402320", "bodyText": "Pre-sorted = false means this will resort the output I believe.  Is that what you want?", "author": "lbergelson", "createdAt": "2020-04-14T20:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg3MzUxOA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408873518", "bodyText": ".toPath -> done.\nHmmm. That's not what I want. But I don't think it sorts the output. Will investigate.", "author": "takutosato", "createdAt": "2020-04-15T14:12:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA3NjMxNA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409076314", "bodyText": "It probably doesn't sort it if the sort order is listed as \"unsorted\"", "author": "lbergelson", "createdAt": "2020-04-15T19:17:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NTM3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\nindex 1be866536..ccb5d70ed 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n\n@@ -1,34 +1,33 @@\n package org.broadinstitute.hellbender.tools.walkers.consensus;\n \n-import org.apache.commons.math3.random.RandomGenerator;\n-import org.apache.commons.math3.random.RandomGeneratorFactory;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.engine.ReferenceContext;\n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import org.glassfish.jersey.Beta;\n import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n \n-import java.io.File;\n-import java.util.List;\n import java.util.Random;\n \n @CommandLineProgramProperties(\n-        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         programGroup = ReadDataManipulationProgramGroup.class\n )\n /**\n- * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n- * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n  *\n- * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n  *\n- * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n  * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n  * in addition to ones common to the entire cell population.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDk2Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r406970962", "bodyText": "I wouldn't.  I don't think the performance gain is worth the potential confusion if someone does something like try to accumulate duplicate sets during the traversal.", "author": "lbergelson", "createdAt": "2020-04-10T22:38:00Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxMDQxMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407710411", "bodyText": "This should be private, protected, or marked visiblefortesting.", "author": "lbergelson", "createdAt": "2020-04-13T20:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDk2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NTM0OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408375348", "bodyText": "Sounds good. Done", "author": "takutosato", "createdAt": "2020-04-14T19:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDk2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex 02d318209..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -1,33 +1,49 @@\n package org.broadinstitute.hellbender.engine;\n \n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.Utils;\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n /**\n- * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n- * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n  * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n  */\n public abstract class DuplicateSetWalker extends ReadWalker {\n-    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n-    public static int INITIAL_MOLECULAR_ID = -1;\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to only keep read sets containing both strands (i.d. duplex evidence) by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n \n     @Override\n-    public final void onStartup(){\n-        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n-        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n-        super.onStartup();\n-        currentDuplicateSet = new DuplicateSet();\n-        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    public final void traverse(){\n+        super.traverse();\n+        processLastReadSet();\n     }\n \n     /***\n-     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n      * read1: ... MI:Z:0/A ...\n      * read2: ... MI:Z:0/A ...\n      * read3: ... MI:Z:0/B ...\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTExMg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r406971112", "bodyText": "I'm not super happy about that, it makes it less clear if downstream tools are meant to override it.", "author": "lbergelson", "createdAt": "2020-04-10T22:38:36Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex 02d318209..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -1,33 +1,49 @@\n package org.broadinstitute.hellbender.engine;\n \n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.Utils;\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n /**\n- * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n- * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n  * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n  */\n public abstract class DuplicateSetWalker extends ReadWalker {\n-    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n-    public static int INITIAL_MOLECULAR_ID = -1;\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to only keep read sets containing both strands (i.d. duplex evidence) by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n \n     @Override\n-    public final void onStartup(){\n-        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n-        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n-        super.onStartup();\n-        currentDuplicateSet = new DuplicateSet();\n-        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    public final void traverse(){\n+        super.traverse();\n+        processLastReadSet();\n     }\n \n     /***\n-     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n      * read1: ... MI:Z:0/A ...\n      * read2: ... MI:Z:0/A ...\n      * read3: ... MI:Z:0/B ...\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTUwNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r406971507", "bodyText": "Maybe I'm being dense, but couldn't you initialize this in place when you define the variable and not need to do it here?  That would avoid the need for overriding onStartup.  If you can't instantiate a DuplicateSet and set the ID at the same time, I would just change duplicate set.  It would probably be better though if instead of exposing a magic number, DuplicateSet had a function like isEmpty() that would answer the question of if a read has been added to it yet.", "author": "lbergelson", "createdAt": "2020-04-10T22:40:11Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM4MzM1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408383352", "bodyText": "Good points. Done.", "author": "takutosato", "createdAt": "2020-04-14T19:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTUwNw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex 02d318209..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -1,33 +1,49 @@\n package org.broadinstitute.hellbender.engine;\n \n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.Utils;\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n /**\n- * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n- * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n  * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n  */\n public abstract class DuplicateSetWalker extends ReadWalker {\n-    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n-    public static int INITIAL_MOLECULAR_ID = -1;\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to only keep read sets containing both strands (i.d. duplex evidence) by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n \n     @Override\n-    public final void onStartup(){\n-        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n-        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n-        super.onStartup();\n-        currentDuplicateSet = new DuplicateSet();\n-        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    public final void traverse(){\n+        super.traverse();\n+        processLastReadSet();\n     }\n \n     /***\n-     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n      * read1: ... MI:Z:0/A ...\n      * read2: ... MI:Z:0/A ...\n      * read3: ... MI:Z:0/B ...\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTY4OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r406971688", "bodyText": "Is there any way to tell if the file is sorted in the correct way or not?  It would be good to check that it is somehow.", "author": "lbergelson", "createdAt": "2020-04-10T22:40:57Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTg3Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r406971876", "bodyText": "You could do something silly like using a bloom filter to track already seen molecules ID's and warn if you see a surplus of collisions.", "author": "lbergelson", "createdAt": "2020-04-10T22:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNTcyOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407705729", "bodyText": "I would check if the bam have any sorting subkeys specified, it's a thing Nil's and Tim wanted to add to the spec so they might be outputting the.  I don't think htsjdk knows about them yet but if it exists in the bams it would be a good reason to make htsjdk aware of it.", "author": "lbergelson", "createdAt": "2020-04-13T20:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwODg3MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408408871", "bodyText": "Bam header has SO:unsorted.", "author": "takutosato", "createdAt": "2020-04-14T20:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxODA0OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408418048", "bodyText": "Added a check to ensure that the molecular ID is monotonically increasing and that the tag exists. They should catch it if the input bam is not sorted as required\u2014is that good enough?", "author": "takutosato", "createdAt": "2020-04-14T20:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzNDE3NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408434175", "bodyText": "Yeah, that sounds great.", "author": "lbergelson", "createdAt": "2020-04-14T21:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTY4OA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex 02d318209..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -1,33 +1,49 @@\n package org.broadinstitute.hellbender.engine;\n \n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.Utils;\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n /**\n- * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n- * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n  * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n  */\n public abstract class DuplicateSetWalker extends ReadWalker {\n-    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n-    public static int INITIAL_MOLECULAR_ID = -1;\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to only keep read sets containing both strands (i.d. duplex evidence) by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n \n     @Override\n-    public final void onStartup(){\n-        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n-        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n-        super.onStartup();\n-        currentDuplicateSet = new DuplicateSet();\n-        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    public final void traverse(){\n+        super.traverse();\n+        processLastReadSet();\n     }\n \n     /***\n-     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n      * read1: ... MI:Z:0/A ...\n      * read2: ... MI:Z:0/A ...\n      * read3: ... MI:Z:0/B ...\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MzA1Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r406973056", "bodyText": "final", "author": "lbergelson", "createdAt": "2020-04-10T22:47:03Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NTQyOA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408375428", "bodyText": "Done", "author": "takutosato", "createdAt": "2020-04-14T19:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MzA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxODEzOA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408418138", "bodyText": "removed variable", "author": "takutosato", "createdAt": "2020-04-14T20:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MzA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex 02d318209..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -1,33 +1,49 @@\n package org.broadinstitute.hellbender.engine;\n \n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.Utils;\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n /**\n- * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n- * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n  * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n  */\n public abstract class DuplicateSetWalker extends ReadWalker {\n-    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n-    public static int INITIAL_MOLECULAR_ID = -1;\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to only keep read sets containing both strands (i.d. duplex evidence) by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n \n     @Override\n-    public final void onStartup(){\n-        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n-        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n-        super.onStartup();\n-        currentDuplicateSet = new DuplicateSet();\n-        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    public final void traverse(){\n+        super.traverse();\n+        processLastReadSet();\n     }\n \n     /***\n-     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n      * read1: ... MI:Z:0/A ...\n      * read2: ... MI:Z:0/A ...\n      * read3: ... MI:Z:0/B ...\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNjU2Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407706567", "bodyText": "Make this final so downstream tools don't accidentally think they have to override it.  Modify the javadoc to explain that this shouldn't be called by the user and is only public because of prior constraints and point to the new apply they have to implement.", "author": "lbergelson", "createdAt": "2020-04-13T20:38:29Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzYxNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408423617", "bodyText": "done*3", "author": "takutosato", "createdAt": "2020-04-14T20:44:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNjU2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex 02d318209..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -1,33 +1,49 @@\n package org.broadinstitute.hellbender.engine;\n \n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.Utils;\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n /**\n- * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n- * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n  * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n  */\n public abstract class DuplicateSetWalker extends ReadWalker {\n-    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n-    public static int INITIAL_MOLECULAR_ID = -1;\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to only keep read sets containing both strands (i.d. duplex evidence) by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n \n     @Override\n-    public final void onStartup(){\n-        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n-        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n-        super.onStartup();\n-        currentDuplicateSet = new DuplicateSet();\n-        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    public final void traverse(){\n+        super.traverse();\n+        processLastReadSet();\n     }\n \n     /***\n-     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n      * read1: ... MI:Z:0/A ...\n      * read2: ... MI:Z:0/A ...\n      * read3: ... MI:Z:0/B ...\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNjk4NA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407706984", "bodyText": "This needs javadoc", "author": "lbergelson", "createdAt": "2020-04-13T20:39:18Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentDuplicateSet.getMoleculeId() != DuplicateSet.getMoleculeID(read)) {\n+            if (rejectDuplicateSet(currentDuplicateSet)){\n+                currentDuplicateSet = new DuplicateSet(read);\n+                return;\n+            }\n+\n+            apply(currentDuplicateSet,\n+                    new ReferenceContext(reference, currentDuplicateSet.getDuplicateSetInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentDuplicateSet.getDuplicateSetInterval()));\n+            currentDuplicateSet = new DuplicateSet(read);\n+        } else {\n+            Utils.validate(currentDuplicateSet.addRead(read), \"Adding a read that doesn't have a matching molecular ID tag\");\n+        }\n+    }\n+\n+    public abstract void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext );", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzY5Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408423692", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-14T20:44:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNjk4NA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex 02d318209..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -1,33 +1,49 @@\n package org.broadinstitute.hellbender.engine;\n \n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.Utils;\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n /**\n- * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n- * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n  * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n  */\n public abstract class DuplicateSetWalker extends ReadWalker {\n-    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n-    public static int INITIAL_MOLECULAR_ID = -1;\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to only keep read sets containing both strands (i.d. duplex evidence) by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n \n     @Override\n-    public final void onStartup(){\n-        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n-        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n-        super.onStartup();\n-        currentDuplicateSet = new DuplicateSet();\n-        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    public final void traverse(){\n+        super.traverse();\n+        processLastReadSet();\n     }\n \n     /***\n-     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n      * read1: ... MI:Z:0/A ...\n      * read2: ... MI:Z:0/A ...\n      * read3: ... MI:Z:0/B ...\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNzMyNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407707327", "bodyText": "This also needs javadoc explaining what it does and if you need to override it.", "author": "lbergelson", "createdAt": "2020-04-13T20:39:55Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentDuplicateSet.getMoleculeId() != DuplicateSet.getMoleculeID(read)) {\n+            if (rejectDuplicateSet(currentDuplicateSet)){\n+                currentDuplicateSet = new DuplicateSet(read);\n+                return;\n+            }\n+\n+            apply(currentDuplicateSet,\n+                    new ReferenceContext(reference, currentDuplicateSet.getDuplicateSetInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentDuplicateSet.getDuplicateSetInterval()));\n+            currentDuplicateSet = new DuplicateSet(read);\n+        } else {\n+            Utils.validate(currentDuplicateSet.addRead(read), \"Adding a read that doesn't have a matching molecular ID tag\");\n+        }\n+    }\n+\n+    public abstract void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext );\n+\n+    protected boolean rejectDuplicateSet(final DuplicateSet duplicateSet){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxMTc1OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407711758", "bodyText": "The naming is ok, but it might be better as something like duplicateSetHasValidInterval to make it clear what it's checking.", "author": "lbergelson", "createdAt": "2020-04-13T20:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNzMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMDY2OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408430668", "bodyText": "done*2. The idea is that the subclass can override it this to specify its own criteria for filtering a duplicate set, and I think \"reject\" is a clearer verb than \"filter\"", "author": "takutosato", "createdAt": "2020-04-14T20:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNzMyNw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex 02d318209..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -1,33 +1,49 @@\n package org.broadinstitute.hellbender.engine;\n \n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.Utils;\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n /**\n- * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n- * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n  * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n  */\n public abstract class DuplicateSetWalker extends ReadWalker {\n-    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n-    public static int INITIAL_MOLECULAR_ID = -1;\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to only keep read sets containing both strands (i.d. duplex evidence) by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n \n     @Override\n-    public final void onStartup(){\n-        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n-        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n-        super.onStartup();\n-        currentDuplicateSet = new DuplicateSet();\n-        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    public final void traverse(){\n+        super.traverse();\n+        processLastReadSet();\n     }\n \n     /***\n-     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n      * read1: ... MI:Z:0/A ...\n      * read2: ... MI:Z:0/A ...\n      * read3: ... MI:Z:0/B ...\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNzQ3Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407707473", "bodyText": "Is this a normal thing that happens or an error condition?", "author": "lbergelson", "createdAt": "2020-04-13T20:40:12Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentDuplicateSet.getMoleculeId() != DuplicateSet.getMoleculeID(read)) {\n+            if (rejectDuplicateSet(currentDuplicateSet)){\n+                currentDuplicateSet = new DuplicateSet(read);\n+                return;\n+            }\n+\n+            apply(currentDuplicateSet,\n+                    new ReferenceContext(reference, currentDuplicateSet.getDuplicateSetInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentDuplicateSet.getDuplicateSetInterval()));\n+            currentDuplicateSet = new DuplicateSet(read);\n+        } else {\n+            Utils.validate(currentDuplicateSet.addRead(read), \"Adding a read that doesn't have a matching molecular ID tag\");\n+        }\n+    }\n+\n+    public abstract void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext );\n+\n+    protected boolean rejectDuplicateSet(final DuplicateSet duplicateSet){\n+        if (!duplicateSet.hasValidInterval()) {\n+            logger.info(\"Duplicate Set with Invalid Intervals\");", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMTM2MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408431361", "bodyText": "This was a vestige of an earlier bug but I think I can safely remove the logging", "author": "takutosato", "createdAt": "2020-04-14T20:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNzQ3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex 02d318209..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -1,33 +1,49 @@\n package org.broadinstitute.hellbender.engine;\n \n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.Utils;\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n /**\n- * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n- * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n  * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n  */\n public abstract class DuplicateSetWalker extends ReadWalker {\n-    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n-    public static int INITIAL_MOLECULAR_ID = -1;\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to only keep read sets containing both strands (i.d. duplex evidence) by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n \n     @Override\n-    public final void onStartup(){\n-        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n-        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n-        super.onStartup();\n-        currentDuplicateSet = new DuplicateSet();\n-        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    public final void traverse(){\n+        super.traverse();\n+        processLastReadSet();\n     }\n \n     /***\n-     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n      * read1: ... MI:Z:0/A ...\n      * read2: ... MI:Z:0/A ...\n      * read3: ... MI:Z:0/B ...\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwODExNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407708117", "bodyText": "Lets extract this boolean as variable the first time we compute it.  That way if someone edits the code we can't get a mismatching case between the warning and the return value.", "author": "lbergelson", "createdAt": "2020-04-13T20:41:25Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentDuplicateSet.getMoleculeId() != DuplicateSet.getMoleculeID(read)) {\n+            if (rejectDuplicateSet(currentDuplicateSet)){\n+                currentDuplicateSet = new DuplicateSet(read);\n+                return;\n+            }\n+\n+            apply(currentDuplicateSet,\n+                    new ReferenceContext(reference, currentDuplicateSet.getDuplicateSetInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentDuplicateSet.getDuplicateSetInterval()));\n+            currentDuplicateSet = new DuplicateSet(read);\n+        } else {\n+            Utils.validate(currentDuplicateSet.addRead(read), \"Adding a read that doesn't have a matching molecular ID tag\");\n+        }\n+    }\n+\n+    public abstract void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext );\n+\n+    protected boolean rejectDuplicateSet(final DuplicateSet duplicateSet){\n+        if (!duplicateSet.hasValidInterval()) {\n+            logger.info(\"Duplicate Set with Invalid Intervals\");\n+            logger.info(\"Number of reads:\" + currentDuplicateSet.getReads().size());\n+            if (currentDuplicateSet.getReads().size() > 0) {\n+                logger.info(\"First read: \" + currentDuplicateSet.getReads().get(0));\n+            }\n+        }\n+\n+        return !duplicateSet.hasValidInterval();", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMTQ1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408431452", "bodyText": "rewritten", "author": "takutosato", "createdAt": "2020-04-14T20:59:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwODExNw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex 02d318209..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -1,33 +1,49 @@\n package org.broadinstitute.hellbender.engine;\n \n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.Utils;\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n /**\n- * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n- * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n  * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n  */\n public abstract class DuplicateSetWalker extends ReadWalker {\n-    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n-    public static int INITIAL_MOLECULAR_ID = -1;\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to only keep read sets containing both strands (i.d. duplex evidence) by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n \n     @Override\n-    public final void onStartup(){\n-        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n-        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n-        super.onStartup();\n-        currentDuplicateSet = new DuplicateSet();\n-        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    public final void traverse(){\n+        super.traverse();\n+        processLastReadSet();\n     }\n \n     /***\n-     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n      * read1: ... MI:Z:0/A ...\n      * read2: ... MI:Z:0/A ...\n      * read3: ... MI:Z:0/B ...\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwOTExMg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407709112", "bodyText": "lets see if we can avoid this.  I think we can.", "author": "lbergelson", "createdAt": "2020-04-13T20:43:18Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -46,7 +46,7 @@ public boolean requiresReads() {\n      * Marked final so that tool authors don't override it. Tool authors should override onTraversalStart() instead.\n      */\n     @Override\n-    protected final void onStartup() {\n+    protected void onStartup() {", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3OTc3NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408379775", "bodyText": "Yes I'm going to try. Uno momento.", "author": "takutosato", "createdAt": "2020-04-14T19:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwOTExMg=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\nindex 9e55e4b32..e3d6c52fd 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\n\n@@ -46,7 +46,7 @@ public abstract class ReadWalker extends WalkerBase {\n      * Marked final so that tool authors don't override it. Tool authors should override onTraversalStart() instead.\n      */\n     @Override\n-    protected void onStartup() {\n+    protected final void onStartup() {\n         super.onStartup();\n \n         setReadTraversalBounds();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwOTUxNg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407709516", "bodyText": "Hmn, I think returning null is ok because some tools might want to be able to process empty files without exploding.  Just document clearly that it can return null.", "author": "lbergelson", "createdAt": "2020-04-13T20:44:01Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -167,4 +167,16 @@ protected final void onShutdown() {\n         // Overridden only to make final so that concrete tool implementations don't override\n         super.onShutdown();\n     }\n+\n+    public void postProcess(){\n+        return;\n+    }\n+\n+    public GATKRead peekFirstRead(){\n+        if (reads.iterator().hasNext()){\n+            return reads.iterator().next();\n+        }\n+        // Maybe the correct thing to do is for this to return an error when the user input is empty\n+        return null;", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMzA1NA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408433054", "bodyText": "method removed", "author": "takutosato", "createdAt": "2020-04-14T21:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwOTUxNg=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\nindex 9e55e4b32..e3d6c52fd 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\n\n@@ -167,16 +167,4 @@ public abstract class ReadWalker extends WalkerBase {\n         // Overridden only to make final so that concrete tool implementations don't override\n         super.onShutdown();\n     }\n-\n-    public void postProcess(){\n-        return;\n-    }\n-\n-    public GATKRead peekFirstRead(){\n-        if (reads.iterator().hasNext()){\n-            return reads.iterator().next();\n-        }\n-        // Maybe the correct thing to do is for this to return an error when the user input is empty\n-        return null;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxMTE3MA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407711170", "bodyText": "extract this to a variable instead of calling it twice", "author": "lbergelson", "createdAt": "2020-04-13T20:47:12Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentDuplicateSet.getMoleculeId() != DuplicateSet.getMoleculeID(read)) {\n+            if (rejectDuplicateSet(currentDuplicateSet)){\n+                currentDuplicateSet = new DuplicateSet(read);\n+                return;\n+            }\n+\n+            apply(currentDuplicateSet,\n+                    new ReferenceContext(reference, currentDuplicateSet.getDuplicateSetInterval()), // Will create an empty ReferenceContext if reference or readInterval == null", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMzk0Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408433946", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-14T21:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxMTE3MA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex 02d318209..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -1,33 +1,49 @@\n package org.broadinstitute.hellbender.engine;\n \n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.Utils;\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n /**\n- * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n- * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n  * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n  */\n public abstract class DuplicateSetWalker extends ReadWalker {\n-    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n-    public static int INITIAL_MOLECULAR_ID = -1;\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to only keep read sets containing both strands (i.d. duplex evidence) by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n \n     @Override\n-    public final void onStartup(){\n-        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n-        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n-        super.onStartup();\n-        currentDuplicateSet = new DuplicateSet();\n-        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    public final void traverse(){\n+        super.traverse();\n+        processLastReadSet();\n     }\n \n     /***\n-     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n      * read1: ... MI:Z:0/A ...\n      * read2: ... MI:Z:0/A ...\n      * read3: ... MI:Z:0/B ...\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxMjY2NA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407712664", "bodyText": "You could change this expression to be something like currentDuplicateSet.moleculeIdsMatch(read) which might read better.", "author": "lbergelson", "createdAt": "2020-04-13T20:49:52Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentDuplicateSet.getMoleculeId() != DuplicateSet.getMoleculeID(read)) {", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex 02d318209..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -1,33 +1,49 @@\n package org.broadinstitute.hellbender.engine;\n \n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.Utils;\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n /**\n- * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n- * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n  * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n  */\n public abstract class DuplicateSetWalker extends ReadWalker {\n-    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n-    public static int INITIAL_MOLECULAR_ID = -1;\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to only keep read sets containing both strands (i.d. duplex evidence) by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true, minValue = 0)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n \n     @Override\n-    public final void onStartup(){\n-        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n-        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n-        super.onStartup();\n-        currentDuplicateSet = new DuplicateSet();\n-        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    public final void traverse(){\n+        super.traverse();\n+        processLastReadSet();\n     }\n \n     /***\n-     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n      * read1: ... MI:Z:0/A ...\n      * read2: ... MI:Z:0/A ...\n      * read3: ... MI:Z:0/B ...\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzE4MA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407717180", "bodyText": "This seems like a reasonable thing to add to the engine, but it needs documentation and possibly a rename.  Maybe finalizeTraversal would make sense?  Make it clear that it's different from onTraversalSuccess because it's meant to be implemented by framework classes, not actual tools.", "author": "lbergelson", "createdAt": "2020-04-13T20:58:30Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -99,7 +99,7 @@ public void traverse() {\n \n                     progressMeter.update(readInterval);\n                 });\n-\n+        postProcess();", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzUwMw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407717503", "bodyText": "@droazen Any thoughts on this?  The other option would be to override traverse in the subclass which is always awkward if unnecessary.", "author": "lbergelson", "createdAt": "2020-04-13T20:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyMDM0Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r412520342", "bodyText": "renamed to finalizeTraversal and made it final in DuplicateSetWalker.", "author": "takutosato", "createdAt": "2020-04-21T21:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzE4MA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\nindex 9e55e4b32..e3d6c52fd 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\n\n@@ -99,7 +99,7 @@ public abstract class ReadWalker extends WalkerBase {\n \n                     progressMeter.update(readInterval);\n                 });\n-        postProcess();\n+\n         logger.info(countedFilter.getSummaryLine());\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzg2OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407717868", "bodyText": "I said above, but this needs documentation", "author": "lbergelson", "createdAt": "2020-04-13T20:59:42Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -167,4 +167,16 @@ protected final void onShutdown() {\n         // Overridden only to make final so that concrete tool implementations don't override\n         super.onShutdown();\n     }\n+\n+    public void postProcess(){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyMDgzMw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r412520833", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-21T21:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzg2OA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\nindex 9e55e4b32..e3d6c52fd 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\n\n@@ -167,16 +167,4 @@ public abstract class ReadWalker extends WalkerBase {\n         // Overridden only to make final so that concrete tool implementations don't override\n         super.onShutdown();\n     }\n-\n-    public void postProcess(){\n-        return;\n-    }\n-\n-    public GATKRead peekFirstRead(){\n-        if (reads.iterator().hasNext()){\n-            return reads.iterator().next();\n-        }\n-        // Maybe the correct thing to do is for this to return an error when the user input is empty\n-        return null;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMTQzMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407721431", "bodyText": "Reference SAMTag.RX.name() here instead of totally redefining it from scratch.  It's ok to still assign it to a named constant since RX.name() isn't super helpful..", "author": "lbergelson", "createdAt": "2020-04-13T21:06:37Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;\n+    public static final String UMI_TAG = \"RX\";", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java b/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java\ndeleted file mode 100644\nindex 919fd9751..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java\n+++ /dev/null\n\n@@ -1,42 +0,0 @@\n-package org.broadinstitute.hellbender.engine.filters;\n-\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.util.List;\n-\n-public class UMIReadFilter extends ReadFilter {\n-    static final long serialVersionUID = 1L;\n-    public static final String UMI_TAG = \"RX\";\n-\n-    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n-    public String umi;\n-\n-    public UMIReadFilter() {};\n-\n-    @Override\n-    public boolean test(GATKRead read) {\n-        final String readUMI = read.getAttributeAsString(UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n-\n-//        final File umiFile = new File(umi);\n-//        if (umiFile.exists()){\n-//            try {\n-//                final List<String> umis = Files.readAllLines(umiFile.toPath());\n-//                return false; // ts: need an umi class, but hold that for now.\n-//            } catch (IOException e) {\n-//                throw new UserException(\"shutup\", e);\n-//            }\n-//        } else {\n-//            return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n-//        }\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMTYxNA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407721614", "bodyText": "private is the standard for this for some reason.", "author": "lbergelson", "createdAt": "2020-04-13T21:06:58Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java b/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java\ndeleted file mode 100644\nindex 919fd9751..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java\n+++ /dev/null\n\n@@ -1,42 +0,0 @@\n-package org.broadinstitute.hellbender.engine.filters;\n-\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.util.List;\n-\n-public class UMIReadFilter extends ReadFilter {\n-    static final long serialVersionUID = 1L;\n-    public static final String UMI_TAG = \"RX\";\n-\n-    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n-    public String umi;\n-\n-    public UMIReadFilter() {};\n-\n-    @Override\n-    public boolean test(GATKRead read) {\n-        final String readUMI = read.getAttributeAsString(UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n-\n-//        final File umiFile = new File(umi);\n-//        if (umiFile.exists()){\n-//            try {\n-//                final List<String> umis = Files.readAllLines(umiFile.toPath());\n-//                return false; // ts: need an umi class, but hold that for now.\n-//            } catch (IOException e) {\n-//                throw new UserException(\"shutup\", e);\n-//            }\n-//        } else {\n-//            return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n-//        }\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzA5OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407723098", "bodyText": "Split once and save the array into a variable.\nUtils.split(String, char) is substantially faster for non-regex splitting like this.", "author": "lbergelson", "createdAt": "2020-04-13T21:09:55Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;\n+    public static final String UMI_TAG = \"RX\";\n+\n+    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n+    public String umi;\n+\n+    public UMIReadFilter() {};\n+\n+    @Override\n+    public boolean test(GATKRead read) {\n+        final String readUMI = read.getAttributeAsString(UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzg3OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407723878", "bodyText": "Could you fix UMI.getUMI() while you're at it?  It does the same wasteful thing.    You might consider using that method as well to avoid reimplementing this.", "author": "lbergelson", "createdAt": "2020-04-13T21:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjE4Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407726187", "bodyText": "In fact, why not give UMI a string constructor, then make the argument a UMI, and just use UMI.equalsModuloOrder(). It would save reimplementing a bunch of stuff.", "author": "lbergelson", "createdAt": "2020-04-13T21:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzA5OA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java b/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java\ndeleted file mode 100644\nindex 919fd9751..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java\n+++ /dev/null\n\n@@ -1,42 +0,0 @@\n-package org.broadinstitute.hellbender.engine.filters;\n-\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.util.List;\n-\n-public class UMIReadFilter extends ReadFilter {\n-    static final long serialVersionUID = 1L;\n-    public static final String UMI_TAG = \"RX\";\n-\n-    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n-    public String umi;\n-\n-    public UMIReadFilter() {};\n-\n-    @Override\n-    public boolean test(GATKRead read) {\n-        final String readUMI = read.getAttributeAsString(UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n-\n-//        final File umiFile = new File(umi);\n-//        if (umiFile.exists()){\n-//            try {\n-//                final List<String> umis = Files.readAllLines(umiFile.toPath());\n-//                return false; // ts: need an umi class, but hold that for now.\n-//            } catch (IOException e) {\n-//                throw new UserException(\"shutup\", e);\n-//            }\n-//        } else {\n-//            return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n-//        }\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNDUyNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407724527", "bodyText": "Should we validate that constraint somewhere?  @cmnbroad is there a way to do validation of the arguments in a readfilter?", "author": "lbergelson", "createdAt": "2020-04-13T21:12:54Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;\n+    public static final String UMI_TAG = \"RX\";\n+\n+    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n+    public String umi;", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNDY1Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408424653", "bodyText": "Nothing built it. Maybe UMI should have a String constructor that does the splitting/parsing and then this arg can be typed as a UMI.", "author": "cmnbroad", "createdAt": "2020-04-14T20:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNDUyNw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java b/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java\ndeleted file mode 100644\nindex 919fd9751..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java\n+++ /dev/null\n\n@@ -1,42 +0,0 @@\n-package org.broadinstitute.hellbender.engine.filters;\n-\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.util.List;\n-\n-public class UMIReadFilter extends ReadFilter {\n-    static final long serialVersionUID = 1L;\n-    public static final String UMI_TAG = \"RX\";\n-\n-    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n-    public String umi;\n-\n-    public UMIReadFilter() {};\n-\n-    @Override\n-    public boolean test(GATKRead read) {\n-        final String readUMI = read.getAttributeAsString(UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n-\n-//        final File umiFile = new File(umi);\n-//        if (umiFile.exists()){\n-//            try {\n-//                final List<String> umis = Files.readAllLines(umiFile.toPath());\n-//                return false; // ts: need an umi class, but hold that for now.\n-//            } catch (IOException e) {\n-//                throw new UserException(\"shutup\", e);\n-//            }\n-//        } else {\n-//            return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n-//        }\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjIxOA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407726218", "bodyText": "This would be faster if you reworked it to check umi.equals(readUmi) first before deconstructing the string.  In any case, there's no need to rebuild readUMI, only the reversed order one.", "author": "lbergelson", "createdAt": "2020-04-13T21:16:10Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;\n+    public static final String UMI_TAG = \"RX\";\n+\n+    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n+    public String umi;\n+\n+    public UMIReadFilter() {};\n+\n+    @Override\n+    public boolean test(GATKRead read) {\n+        final String readUMI = read.getAttributeAsString(UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java b/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java\ndeleted file mode 100644\nindex 919fd9751..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java\n+++ /dev/null\n\n@@ -1,42 +0,0 @@\n-package org.broadinstitute.hellbender.engine.filters;\n-\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.util.List;\n-\n-public class UMIReadFilter extends ReadFilter {\n-    static final long serialVersionUID = 1L;\n-    public static final String UMI_TAG = \"RX\";\n-\n-    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n-    public String umi;\n-\n-    public UMIReadFilter() {};\n-\n-    @Override\n-    public boolean test(GATKRead read) {\n-        final String readUMI = read.getAttributeAsString(UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n-\n-//        final File umiFile = new File(umi);\n-//        if (umiFile.exists()){\n-//            try {\n-//                final List<String> umis = Files.readAllLines(umiFile.toPath());\n-//                return false; // ts: need an umi class, but hold that for now.\n-//            } catch (IOException e) {\n-//                throw new UserException(\"shutup\", e);\n-//            }\n-//        } else {\n-//            return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n-//        }\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjI4Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407726287", "bodyText": "dead code.  Do you want to allow many UMIs?", "author": "lbergelson", "createdAt": "2020-04-13T21:16:20Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;\n+    public static final String UMI_TAG = \"RX\";\n+\n+    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n+    public String umi;\n+\n+    public UMIReadFilter() {};\n+\n+    @Override\n+    public boolean test(GATKRead read) {\n+        final String readUMI = read.getAttributeAsString(UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n+\n+//        final File umiFile = new File(umi);\n+//        if (umiFile.exists()){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java b/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java\ndeleted file mode 100644\nindex 919fd9751..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java\n+++ /dev/null\n\n@@ -1,42 +0,0 @@\n-package org.broadinstitute.hellbender.engine.filters;\n-\n-import org.broadinstitute.barclay.argparser.Argument;\n-import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n-import org.broadinstitute.hellbender.exceptions.UserException;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.util.List;\n-\n-public class UMIReadFilter extends ReadFilter {\n-    static final long serialVersionUID = 1L;\n-    public static final String UMI_TAG = \"RX\";\n-\n-    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n-    public String umi;\n-\n-    public UMIReadFilter() {};\n-\n-    @Override\n-    public boolean test(GATKRead read) {\n-        final String readUMI = read.getAttributeAsString(UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n-\n-//        final File umiFile = new File(umi);\n-//        if (umiFile.exists()){\n-//            try {\n-//                final List<String> umis = Files.readAllLines(umiFile.toPath());\n-//                return false; // ts: need an umi class, but hold that for now.\n-//            } catch (IOException e) {\n-//                throw new UserException(\"shutup\", e);\n-//            }\n-//        } else {\n-//            return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n-//        }\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzIyOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407727229", "bodyText": "Needs class javadoc.", "author": "lbergelson", "createdAt": "2020-04-13T21:18:11Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\ndeleted file mode 100644\nindex 24ada0623..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\n+++ /dev/null\n\n@@ -1,66 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect;\n-\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-public class UMI {\n-    // The umis are stored here in the order they are stored in the read.\n-    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n-    public final String umi1;\n-    public final String umi2;\n-\n-    // Lexicographical ordering of the two (duplex) UMIs;\n-    public String umiSmall;\n-    public String umiLarge;\n-\n-    public UMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        this.umi1 = readUMI.split(\"-\", 2)[0];\n-        this.umi2 = readUMI.split(\"-\", 2)[1];\n-        if (this.umi1.compareTo(this.umi2) > 0) {\n-            umiLarge = this.umi1;\n-            umiSmall = this.umi2;\n-        } else {\n-            umiLarge = this.umi2;\n-            umiSmall = this.umi1;\n-        }\n-\n-    }\n-\n-    public static Pair<String, String> getUMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return new ImmutablePair<>(umi1, umi2);\n-    }\n-\n-    public boolean equalsReadUMI(final GATKRead read){\n-        return false;\n-    }\n-\n-    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n-    public boolean equalsExactly(final UMI that) {\n-        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n-    }\n-\n-    // Check for whether the two umis came from the same molecule\n-    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n-    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n-    public boolean equalsModuloOrder(final UMI that) {\n-        // Sort the respective UMIs in lexicographical order and compare\n-        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n-    }\n-\n-    public String getStandardizedUMI(){\n-        if (umi1.compareTo(umi2) > 0){\n-            // umi1 is lexicographically greater e.g. umi1 = TAT, umi2 = AAC\n-            return umi2 + \"-\" + umi1;\n-        } else {\n-            return umi1 + \"-\" + umi2;\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzMxNg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407727316", "bodyText": "final final", "author": "lbergelson", "createdAt": "2020-04-13T21:18:21Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\ndeleted file mode 100644\nindex 24ada0623..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\n+++ /dev/null\n\n@@ -1,66 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect;\n-\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-public class UMI {\n-    // The umis are stored here in the order they are stored in the read.\n-    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n-    public final String umi1;\n-    public final String umi2;\n-\n-    // Lexicographical ordering of the two (duplex) UMIs;\n-    public String umiSmall;\n-    public String umiLarge;\n-\n-    public UMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        this.umi1 = readUMI.split(\"-\", 2)[0];\n-        this.umi2 = readUMI.split(\"-\", 2)[1];\n-        if (this.umi1.compareTo(this.umi2) > 0) {\n-            umiLarge = this.umi1;\n-            umiSmall = this.umi2;\n-        } else {\n-            umiLarge = this.umi2;\n-            umiSmall = this.umi1;\n-        }\n-\n-    }\n-\n-    public static Pair<String, String> getUMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return new ImmutablePair<>(umi1, umi2);\n-    }\n-\n-    public boolean equalsReadUMI(final GATKRead read){\n-        return false;\n-    }\n-\n-    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n-    public boolean equalsExactly(final UMI that) {\n-        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n-    }\n-\n-    // Check for whether the two umis came from the same molecule\n-    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n-    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n-    public boolean equalsModuloOrder(final UMI that) {\n-        // Sort the respective UMIs in lexicographical order and compare\n-        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n-    }\n-\n-    public String getStandardizedUMI(){\n-        if (umi1.compareTo(umi2) > 0){\n-            // umi1 is lexicographically greater e.g. umi1 = TAT, umi2 = AAC\n-            return umi2 + \"-\" + umi1;\n-        } else {\n-            return umi1 + \"-\" + umi2;\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzQ3Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407727477", "bodyText": "save the array instead of splitting twice, mentioned above", "author": "lbergelson", "createdAt": "2020-04-13T21:18:38Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\ndeleted file mode 100644\nindex 24ada0623..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\n+++ /dev/null\n\n@@ -1,66 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect;\n-\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-public class UMI {\n-    // The umis are stored here in the order they are stored in the read.\n-    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n-    public final String umi1;\n-    public final String umi2;\n-\n-    // Lexicographical ordering of the two (duplex) UMIs;\n-    public String umiSmall;\n-    public String umiLarge;\n-\n-    public UMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        this.umi1 = readUMI.split(\"-\", 2)[0];\n-        this.umi2 = readUMI.split(\"-\", 2)[1];\n-        if (this.umi1.compareTo(this.umi2) > 0) {\n-            umiLarge = this.umi1;\n-            umiSmall = this.umi2;\n-        } else {\n-            umiLarge = this.umi2;\n-            umiSmall = this.umi1;\n-        }\n-\n-    }\n-\n-    public static Pair<String, String> getUMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return new ImmutablePair<>(umi1, umi2);\n-    }\n-\n-    public boolean equalsReadUMI(final GATKRead read){\n-        return false;\n-    }\n-\n-    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n-    public boolean equalsExactly(final UMI that) {\n-        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n-    }\n-\n-    // Check for whether the two umis came from the same molecule\n-    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n-    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n-    public boolean equalsModuloOrder(final UMI that) {\n-        // Sort the respective UMIs in lexicographical order and compare\n-        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n-    }\n-\n-    public String getStandardizedUMI(){\n-        if (umi1.compareTo(umi2) > 0){\n-            // umi1 is lexicographically greater e.g. umi1 = TAT, umi2 = AAC\n-            return umi2 + \"-\" + umi1;\n-        } else {\n-            return umi1 + \"-\" + umi2;\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODEzMg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407728132", "bodyText": "Should these things have getters?", "author": "lbergelson", "createdAt": "2020-04-13T21:19:56Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\ndeleted file mode 100644\nindex 24ada0623..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\n+++ /dev/null\n\n@@ -1,66 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect;\n-\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-public class UMI {\n-    // The umis are stored here in the order they are stored in the read.\n-    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n-    public final String umi1;\n-    public final String umi2;\n-\n-    // Lexicographical ordering of the two (duplex) UMIs;\n-    public String umiSmall;\n-    public String umiLarge;\n-\n-    public UMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        this.umi1 = readUMI.split(\"-\", 2)[0];\n-        this.umi2 = readUMI.split(\"-\", 2)[1];\n-        if (this.umi1.compareTo(this.umi2) > 0) {\n-            umiLarge = this.umi1;\n-            umiSmall = this.umi2;\n-        } else {\n-            umiLarge = this.umi2;\n-            umiSmall = this.umi1;\n-        }\n-\n-    }\n-\n-    public static Pair<String, String> getUMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return new ImmutablePair<>(umi1, umi2);\n-    }\n-\n-    public boolean equalsReadUMI(final GATKRead read){\n-        return false;\n-    }\n-\n-    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n-    public boolean equalsExactly(final UMI that) {\n-        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n-    }\n-\n-    // Check for whether the two umis came from the same molecule\n-    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n-    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n-    public boolean equalsModuloOrder(final UMI that) {\n-        // Sort the respective UMIs in lexicographical order and compare\n-        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n-    }\n-\n-    public String getStandardizedUMI(){\n-        if (umi1.compareTo(umi2) > 0){\n-            // umi1 is lexicographically greater e.g. umi1 = TAT, umi2 = AAC\n-            return umi2 + \"-\" + umi1;\n-        } else {\n-            return umi1 + \"-\" + umi2;\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODIyOA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407728228", "bodyText": "this seems broken", "author": "lbergelson", "createdAt": "2020-04-13T21:20:11Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return new ImmutablePair<>(umi1, umi2);\n+    }\n+\n+    public boolean equalsReadUMI(final GATKRead read){\n+        return false;", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\ndeleted file mode 100644\nindex 24ada0623..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\n+++ /dev/null\n\n@@ -1,66 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect;\n-\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-public class UMI {\n-    // The umis are stored here in the order they are stored in the read.\n-    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n-    public final String umi1;\n-    public final String umi2;\n-\n-    // Lexicographical ordering of the two (duplex) UMIs;\n-    public String umiSmall;\n-    public String umiLarge;\n-\n-    public UMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        this.umi1 = readUMI.split(\"-\", 2)[0];\n-        this.umi2 = readUMI.split(\"-\", 2)[1];\n-        if (this.umi1.compareTo(this.umi2) > 0) {\n-            umiLarge = this.umi1;\n-            umiSmall = this.umi2;\n-        } else {\n-            umiLarge = this.umi2;\n-            umiSmall = this.umi1;\n-        }\n-\n-    }\n-\n-    public static Pair<String, String> getUMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return new ImmutablePair<>(umi1, umi2);\n-    }\n-\n-    public boolean equalsReadUMI(final GATKRead read){\n-        return false;\n-    }\n-\n-    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n-    public boolean equalsExactly(final UMI that) {\n-        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n-    }\n-\n-    // Check for whether the two umis came from the same molecule\n-    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n-    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n-    public boolean equalsModuloOrder(final UMI that) {\n-        // Sort the respective UMIs in lexicographical order and compare\n-        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n-    }\n-\n-    public String getStandardizedUMI(){\n-        if (umi1.compareTo(umi2) > 0){\n-            // umi1 is lexicographically greater e.g. umi1 = TAT, umi2 = AAC\n-            return umi2 + \"-\" + umi1;\n-        } else {\n-            return umi1 + \"-\" + umi2;\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODUzOA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407728538", "bodyText": "Why have this and the constructor?", "author": "lbergelson", "createdAt": "2020-04-13T21:20:51Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODYwOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407728609", "bodyText": "This is unused.", "author": "lbergelson", "createdAt": "2020-04-13T21:20:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODUzOA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\ndeleted file mode 100644\nindex 24ada0623..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\n+++ /dev/null\n\n@@ -1,66 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect;\n-\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-public class UMI {\n-    // The umis are stored here in the order they are stored in the read.\n-    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n-    public final String umi1;\n-    public final String umi2;\n-\n-    // Lexicographical ordering of the two (duplex) UMIs;\n-    public String umiSmall;\n-    public String umiLarge;\n-\n-    public UMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        this.umi1 = readUMI.split(\"-\", 2)[0];\n-        this.umi2 = readUMI.split(\"-\", 2)[1];\n-        if (this.umi1.compareTo(this.umi2) > 0) {\n-            umiLarge = this.umi1;\n-            umiSmall = this.umi2;\n-        } else {\n-            umiLarge = this.umi2;\n-            umiSmall = this.umi1;\n-        }\n-\n-    }\n-\n-    public static Pair<String, String> getUMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return new ImmutablePair<>(umi1, umi2);\n-    }\n-\n-    public boolean equalsReadUMI(final GATKRead read){\n-        return false;\n-    }\n-\n-    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n-    public boolean equalsExactly(final UMI that) {\n-        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n-    }\n-\n-    // Check for whether the two umis came from the same molecule\n-    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n-    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n-    public boolean equalsModuloOrder(final UMI that) {\n-        // Sort the respective UMIs in lexicographical order and compare\n-        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n-    }\n-\n-    public String getStandardizedUMI(){\n-        if (umi1.compareTo(umi2) > 0){\n-            // umi1 is lexicographically greater e.g. umi1 = TAT, umi2 = AAC\n-            return umi2 + \"-\" + umi1;\n-        } else {\n-            return umi1 + \"-\" + umi2;\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODg0OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407728849", "bodyText": "This should be javadoc.", "author": "lbergelson", "createdAt": "2020-04-13T21:21:29Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return new ImmutablePair<>(umi1, umi2);\n+    }\n+\n+    public boolean equalsReadUMI(final GATKRead read){\n+        return false;\n+    }\n+\n+    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n+    public boolean equalsExactly(final UMI that) {", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\ndeleted file mode 100644\nindex 24ada0623..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\n+++ /dev/null\n\n@@ -1,66 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect;\n-\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-public class UMI {\n-    // The umis are stored here in the order they are stored in the read.\n-    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n-    public final String umi1;\n-    public final String umi2;\n-\n-    // Lexicographical ordering of the two (duplex) UMIs;\n-    public String umiSmall;\n-    public String umiLarge;\n-\n-    public UMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        this.umi1 = readUMI.split(\"-\", 2)[0];\n-        this.umi2 = readUMI.split(\"-\", 2)[1];\n-        if (this.umi1.compareTo(this.umi2) > 0) {\n-            umiLarge = this.umi1;\n-            umiSmall = this.umi2;\n-        } else {\n-            umiLarge = this.umi2;\n-            umiSmall = this.umi1;\n-        }\n-\n-    }\n-\n-    public static Pair<String, String> getUMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return new ImmutablePair<>(umi1, umi2);\n-    }\n-\n-    public boolean equalsReadUMI(final GATKRead read){\n-        return false;\n-    }\n-\n-    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n-    public boolean equalsExactly(final UMI that) {\n-        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n-    }\n-\n-    // Check for whether the two umis came from the same molecule\n-    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n-    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n-    public boolean equalsModuloOrder(final UMI that) {\n-        // Sort the respective UMIs in lexicographical order and compare\n-        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n-    }\n-\n-    public String getStandardizedUMI(){\n-        if (umi1.compareTo(umi2) > 0){\n-            // umi1 is lexicographically greater e.g. umi1 = TAT, umi2 = AAC\n-            return umi2 + \"-\" + umi1;\n-        } else {\n-            return umi1 + \"-\" + umi2;\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODk1MA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407728950", "bodyText": "This should also be javadoc", "author": "lbergelson", "createdAt": "2020-04-13T21:21:41Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return new ImmutablePair<>(umi1, umi2);\n+    }\n+\n+    public boolean equalsReadUMI(final GATKRead read){\n+        return false;\n+    }\n+\n+    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n+    public boolean equalsExactly(final UMI that) {\n+        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n+    }\n+\n+    // Check for whether the two umis came from the same molecule\n+    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n+    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n+    public boolean equalsModuloOrder(final UMI that) {", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyOTEwMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407729101", "bodyText": "Is this post error correction?", "author": "lbergelson", "createdAt": "2020-04-13T21:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODk1MA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\ndeleted file mode 100644\nindex 24ada0623..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\n+++ /dev/null\n\n@@ -1,66 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect;\n-\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-public class UMI {\n-    // The umis are stored here in the order they are stored in the read.\n-    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n-    public final String umi1;\n-    public final String umi2;\n-\n-    // Lexicographical ordering of the two (duplex) UMIs;\n-    public String umiSmall;\n-    public String umiLarge;\n-\n-    public UMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        this.umi1 = readUMI.split(\"-\", 2)[0];\n-        this.umi2 = readUMI.split(\"-\", 2)[1];\n-        if (this.umi1.compareTo(this.umi2) > 0) {\n-            umiLarge = this.umi1;\n-            umiSmall = this.umi2;\n-        } else {\n-            umiLarge = this.umi2;\n-            umiSmall = this.umi1;\n-        }\n-\n-    }\n-\n-    public static Pair<String, String> getUMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return new ImmutablePair<>(umi1, umi2);\n-    }\n-\n-    public boolean equalsReadUMI(final GATKRead read){\n-        return false;\n-    }\n-\n-    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n-    public boolean equalsExactly(final UMI that) {\n-        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n-    }\n-\n-    // Check for whether the two umis came from the same molecule\n-    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n-    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n-    public boolean equalsModuloOrder(final UMI that) {\n-        // Sort the respective UMIs in lexicographical order and compare\n-        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n-    }\n-\n-    public String getStandardizedUMI(){\n-        if (umi1.compareTo(umi2) > 0){\n-            // umi1 is lexicographically greater e.g. umi1 = TAT, umi2 = AAC\n-            return umi2 + \"-\" + umi1;\n-        } else {\n-            return umi1 + \"-\" + umi2;\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyOTE2NA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407729164", "bodyText": "Javadoc", "author": "lbergelson", "createdAt": "2020-04-13T21:22:10Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return new ImmutablePair<>(umi1, umi2);\n+    }\n+\n+    public boolean equalsReadUMI(final GATKRead read){\n+        return false;\n+    }\n+\n+    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n+    public boolean equalsExactly(final UMI that) {\n+        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n+    }\n+\n+    // Check for whether the two umis came from the same molecule\n+    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n+    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n+    public boolean equalsModuloOrder(final UMI that) {\n+        // Sort the respective UMIs in lexicographical order and compare\n+        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n+    }\n+\n+    public String getStandardizedUMI(){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\ndeleted file mode 100644\nindex 24ada0623..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\n+++ /dev/null\n\n@@ -1,66 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect;\n-\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-public class UMI {\n-    // The umis are stored here in the order they are stored in the read.\n-    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n-    public final String umi1;\n-    public final String umi2;\n-\n-    // Lexicographical ordering of the two (duplex) UMIs;\n-    public String umiSmall;\n-    public String umiLarge;\n-\n-    public UMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        this.umi1 = readUMI.split(\"-\", 2)[0];\n-        this.umi2 = readUMI.split(\"-\", 2)[1];\n-        if (this.umi1.compareTo(this.umi2) > 0) {\n-            umiLarge = this.umi1;\n-            umiSmall = this.umi2;\n-        } else {\n-            umiLarge = this.umi2;\n-            umiSmall = this.umi1;\n-        }\n-\n-    }\n-\n-    public static Pair<String, String> getUMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return new ImmutablePair<>(umi1, umi2);\n-    }\n-\n-    public boolean equalsReadUMI(final GATKRead read){\n-        return false;\n-    }\n-\n-    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n-    public boolean equalsExactly(final UMI that) {\n-        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n-    }\n-\n-    // Check for whether the two umis came from the same molecule\n-    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n-    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n-    public boolean equalsModuloOrder(final UMI that) {\n-        // Sort the respective UMIs in lexicographical order and compare\n-        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n-    }\n-\n-    public String getStandardizedUMI(){\n-        if (umi1.compareTo(umi2) > 0){\n-            // umi1 is lexicographically greater e.g. umi1 = TAT, umi2 = AAC\n-            return umi2 + \"-\" + umi1;\n-        } else {\n-            return umi1 + \"-\" + umi2;\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyOTI2Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407729266", "bodyText": "This is redundant since you sorted them already, just return umiSmall + umiLong, or better yet just save the combination.", "author": "lbergelson", "createdAt": "2020-04-13T21:22:22Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return new ImmutablePair<>(umi1, umi2);\n+    }\n+\n+    public boolean equalsReadUMI(final GATKRead read){\n+        return false;\n+    }\n+\n+    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n+    public boolean equalsExactly(final UMI that) {\n+        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n+    }\n+\n+    // Check for whether the two umis came from the same molecule\n+    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n+    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n+    public boolean equalsModuloOrder(final UMI that) {\n+        // Sort the respective UMIs in lexicographical order and compare\n+        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n+    }\n+\n+    public String getStandardizedUMI(){\n+        if (umi1.compareTo(umi2) > 0){\n+            // umi1 is lexicographically greater e.g. umi1 = TAT, umi2 = AAC", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\ndeleted file mode 100644\nindex 24ada0623..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\n+++ /dev/null\n\n@@ -1,66 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect;\n-\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-public class UMI {\n-    // The umis are stored here in the order they are stored in the read.\n-    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n-    public final String umi1;\n-    public final String umi2;\n-\n-    // Lexicographical ordering of the two (duplex) UMIs;\n-    public String umiSmall;\n-    public String umiLarge;\n-\n-    public UMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        this.umi1 = readUMI.split(\"-\", 2)[0];\n-        this.umi2 = readUMI.split(\"-\", 2)[1];\n-        if (this.umi1.compareTo(this.umi2) > 0) {\n-            umiLarge = this.umi1;\n-            umiSmall = this.umi2;\n-        } else {\n-            umiLarge = this.umi2;\n-            umiSmall = this.umi1;\n-        }\n-\n-    }\n-\n-    public static Pair<String, String> getUMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return new ImmutablePair<>(umi1, umi2);\n-    }\n-\n-    public boolean equalsReadUMI(final GATKRead read){\n-        return false;\n-    }\n-\n-    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n-    public boolean equalsExactly(final UMI that) {\n-        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n-    }\n-\n-    // Check for whether the two umis came from the same molecule\n-    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n-    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n-    public boolean equalsModuloOrder(final UMI that) {\n-        // Sort the respective UMIs in lexicographical order and compare\n-        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n-    }\n-\n-    public String getStandardizedUMI(){\n-        if (umi1.compareTo(umi2) > 0){\n-            // umi1 is lexicographically greater e.g. umi1 = TAT, umi2 = AAC\n-            return umi2 + \"-\" + umi1;\n-        } else {\n-            return umi1 + \"-\" + umi2;\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyOTYwMg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407729602", "bodyText": "This class has lots of unused/untested stuff that probably should be used / tested.  The umi logic should be implemented here and called from the filter.", "author": "lbergelson", "createdAt": "2020-04-13T21:23:03Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\ndeleted file mode 100644\nindex 24ada0623..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java\n+++ /dev/null\n\n@@ -1,66 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect;\n-\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-public class UMI {\n-    // The umis are stored here in the order they are stored in the read.\n-    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n-    public final String umi1;\n-    public final String umi2;\n-\n-    // Lexicographical ordering of the two (duplex) UMIs;\n-    public String umiSmall;\n-    public String umiLarge;\n-\n-    public UMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        this.umi1 = readUMI.split(\"-\", 2)[0];\n-        this.umi2 = readUMI.split(\"-\", 2)[1];\n-        if (this.umi1.compareTo(this.umi2) > 0) {\n-            umiLarge = this.umi1;\n-            umiSmall = this.umi2;\n-        } else {\n-            umiLarge = this.umi2;\n-            umiSmall = this.umi1;\n-        }\n-\n-    }\n-\n-    public static Pair<String, String> getUMI(final GATKRead read){\n-        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n-        final String umi1 = readUMI.split(\"-\", 2)[0];\n-        final String umi2 = readUMI.split(\"-\", 2)[1];\n-\n-        return new ImmutablePair<>(umi1, umi2);\n-    }\n-\n-    public boolean equalsReadUMI(final GATKRead read){\n-        return false;\n-    }\n-\n-    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n-    public boolean equalsExactly(final UMI that) {\n-        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n-    }\n-\n-    // Check for whether the two umis came from the same molecule\n-    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n-    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n-    public boolean equalsModuloOrder(final UMI that) {\n-        // Sort the respective UMIs in lexicographical order and compare\n-        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n-    }\n-\n-    public String getStandardizedUMI(){\n-        if (umi1.compareTo(umi2) > 0){\n-            // umi1 is lexicographically greater e.g. umi1 = TAT, umi2 = AAC\n-            return umi2 + \"-\" + umi1;\n-        } else {\n-            return umi1 + \"-\" + umi2;\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMDEwNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408400107", "bodyText": "typo?  tumor subclones", "author": "lbergelson", "createdAt": "2020-04-14T20:01:35Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4NDgzOA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408884838", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-15T14:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMDEwNw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\nindex 1be866536..ccb5d70ed 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n\n@@ -1,34 +1,33 @@\n package org.broadinstitute.hellbender.tools.walkers.consensus;\n \n-import org.apache.commons.math3.random.RandomGenerator;\n-import org.apache.commons.math3.random.RandomGeneratorFactory;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.engine.ReferenceContext;\n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import org.glassfish.jersey.Beta;\n import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n \n-import java.io.File;\n-import java.util.List;\n import java.util.Random;\n \n @CommandLineProgramProperties(\n-        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         programGroup = ReadDataManipulationProgramGroup.class\n )\n /**\n- * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n- * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n  *\n- * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n  *\n- * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n  * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n  * in addition to ones common to the entire cell population.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMTA0Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408401043", "bodyText": "I would probably give this a more descriptive name.  Maybe \"fraction-to-keep\"?", "author": "lbergelson", "createdAt": "2020-04-14T20:03:20Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyODM3MA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408428370", "bodyText": "You should add bounds to this, i.e. minValue = 0.0 maxValue = 1.0", "author": "lbergelson", "createdAt": "2020-04-14T20:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMTA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4NTY4MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408885681", "bodyText": "done*2", "author": "takutosato", "createdAt": "2020-04-15T14:28:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMTA0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\nindex 1be866536..ccb5d70ed 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n\n@@ -1,34 +1,33 @@\n package org.broadinstitute.hellbender.tools.walkers.consensus;\n \n-import org.apache.commons.math3.random.RandomGenerator;\n-import org.apache.commons.math3.random.RandomGeneratorFactory;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.engine.ReferenceContext;\n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import org.glassfish.jersey.Beta;\n import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n \n-import java.io.File;\n-import java.util.List;\n import java.util.Random;\n \n @CommandLineProgramProperties(\n-        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         programGroup = ReadDataManipulationProgramGroup.class\n )\n /**\n- * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n- * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n  *\n- * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n  *\n- * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n  * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n  * in addition to ones common to the entire cell population.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMTk1OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408401959", "bodyText": "I don't think these fields should be static.", "author": "lbergelson", "createdAt": "2020-04-14T20:04:54Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4Njc5OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408886798", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-15T14:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMTk1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\nindex 1be866536..ccb5d70ed 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n\n@@ -1,34 +1,33 @@\n package org.broadinstitute.hellbender.tools.walkers.consensus;\n \n-import org.apache.commons.math3.random.RandomGenerator;\n-import org.apache.commons.math3.random.RandomGeneratorFactory;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.engine.ReferenceContext;\n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import org.glassfish.jersey.Beta;\n import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n \n-import java.io.File;\n-import java.util.List;\n import java.util.Random;\n \n @CommandLineProgramProperties(\n-        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         programGroup = ReadDataManipulationProgramGroup.class\n )\n /**\n- * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n- * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n  *\n- * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n  *\n- * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n  * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n  * in addition to ones common to the entire cell population.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMjgwMw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408402803", "bodyText": "This is unnecessary because the walker bases are obligated to NOT implement this.  It's fine to do it anyway though.", "author": "lbergelson", "createdAt": "2020-04-14T20:06:33Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4NzM3OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408887378", "bodyText": "removed", "author": "takutosato", "createdAt": "2020-04-15T14:30:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMjgwMw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\nindex 1be866536..ccb5d70ed 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n\n@@ -1,34 +1,33 @@\n package org.broadinstitute.hellbender.tools.walkers.consensus;\n \n-import org.apache.commons.math3.random.RandomGenerator;\n-import org.apache.commons.math3.random.RandomGeneratorFactory;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.engine.ReferenceContext;\n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import org.glassfish.jersey.Beta;\n import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n \n-import java.io.File;\n-import java.util.List;\n import java.util.Random;\n \n @CommandLineProgramProperties(\n-        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         programGroup = ReadDataManipulationProgramGroup.class\n )\n /**\n- * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n- * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n  *\n- * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n  *\n- * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n  * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n  * in addition to ones common to the entire cell population.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwNDI1MA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408404250", "bodyText": "Why use the apache3 RandomNumberGenerator and not the built in Random?  If there's no good reason I would just use the java builtin.  I might add a comment if there is a reason to use the apache one.", "author": "lbergelson", "createdAt": "2020-04-14T20:09:05Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NDQxNA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408894414", "bodyText": "No reason, just copied and pasted from another tool. Happy to use Random instead.", "author": "takutosato", "createdAt": "2020-04-15T14:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwNDI1MA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\nindex 1be866536..ccb5d70ed 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n\n@@ -1,34 +1,33 @@\n package org.broadinstitute.hellbender.tools.walkers.consensus;\n \n-import org.apache.commons.math3.random.RandomGenerator;\n-import org.apache.commons.math3.random.RandomGeneratorFactory;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.engine.ReferenceContext;\n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import org.glassfish.jersey.Beta;\n import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n \n-import java.io.File;\n-import java.util.List;\n import java.util.Random;\n \n @CommandLineProgramProperties(\n-        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         programGroup = ReadDataManipulationProgramGroup.class\n )\n /**\n- * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n- * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n  *\n- * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n  *\n- * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n  * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n  * in addition to ones common to the entire cell population.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwNTkxNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408405917", "bodyText": "This should also be closed in closeTool() and you should check for null before doing so there.", "author": "lbergelson", "createdAt": "2020-04-14T20:12:10Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));\n+        outputWriter = createSAMWriter(IOUtils.getPath(outputBam.getAbsolutePath()), false);\n+    }\n+\n+    @Override\n+    public void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (filterDuplicateSet(duplicateSet)){\n+            return;\n+        }\n+        if (rng.nextDouble() < downsamplingRate){\n+            duplicateSet.getReads().forEach(r -> outputWriter.addRead(r));\n+            numReads += duplicateSet.getReads().size();\n+            numFragments += 1;\n+        }\n+    }\n+\n+    @Override\n+    public Object onTraversalSuccess(){\n+        outputWriter.close();", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NzYzNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408897637", "bodyText": "Done", "author": "takutosato", "createdAt": "2020-04-15T14:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwNTkxNw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\nindex 1be866536..ccb5d70ed 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n\n@@ -1,34 +1,33 @@\n package org.broadinstitute.hellbender.tools.walkers.consensus;\n \n-import org.apache.commons.math3.random.RandomGenerator;\n-import org.apache.commons.math3.random.RandomGeneratorFactory;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.engine.ReferenceContext;\n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import org.glassfish.jersey.Beta;\n import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n \n-import java.io.File;\n-import java.util.List;\n import java.util.Random;\n \n @CommandLineProgramProperties(\n-        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         programGroup = ReadDataManipulationProgramGroup.class\n )\n /**\n- * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n- * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n  *\n- * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n  *\n- * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n  * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n  * in addition to ones common to the entire cell population.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwNzkxNA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408407914", "bodyText": "If this is experimental I would make the argument that enables it @Advanced", "author": "lbergelson", "createdAt": "2020-04-14T20:15:53Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));\n+        outputWriter = createSAMWriter(IOUtils.getPath(outputBam.getAbsolutePath()), false);\n+    }\n+\n+    @Override\n+    public void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (filterDuplicateSet(duplicateSet)){\n+            return;\n+        }\n+        if (rng.nextDouble() < downsamplingRate){\n+            duplicateSet.getReads().forEach(r -> outputWriter.addRead(r));\n+            numReads += duplicateSet.getReads().size();\n+            numFragments += 1;\n+        }\n+    }\n+\n+    @Override\n+    public Object onTraversalSuccess(){\n+        outputWriter.close();\n+        logger.info(String.format(\"Wrote %d reads\", numReads));\n+        logger.info(String.format(\"Wrote %d fragments\", numFragments));\n+        return \"SUCCESS\";\n+    }\n+\n+    private boolean filterDuplicateSet(final DuplicateSet duplicateSet){\n+        if (duplicateSet.getReads().size() % 2 == 1){\n+            // We only keep reads with mates by default, as that's what fgbio GroupByUMI requires.\n+            logger.info(\"Duplicate set that contains an unpaired read discarded: \" + duplicateSet.getReads().get(0));\n+            return true;\n+        }\n+\n+        // Experiment: only keep duplex\n+        if (duplexOnly){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\nindex 1be866536..ccb5d70ed 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n\n@@ -1,34 +1,33 @@\n package org.broadinstitute.hellbender.tools.walkers.consensus;\n \n-import org.apache.commons.math3.random.RandomGenerator;\n-import org.apache.commons.math3.random.RandomGeneratorFactory;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.engine.ReferenceContext;\n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import org.glassfish.jersey.Beta;\n import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n \n-import java.io.File;\n-import java.util.List;\n import java.util.Random;\n \n @CommandLineProgramProperties(\n-        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         programGroup = ReadDataManipulationProgramGroup.class\n )\n /**\n- * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n- * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n  *\n- * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n  *\n- * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n  * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n  * in addition to ones common to the entire cell population.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwOTIxMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408409211", "bodyText": "I'm confused about this.  I thought  reads were only added if they had the same molecularID?", "author": "lbergelson", "createdAt": "2020-04-14T20:18:13Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));\n+        outputWriter = createSAMWriter(IOUtils.getPath(outputBam.getAbsolutePath()), false);\n+    }\n+\n+    @Override\n+    public void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (filterDuplicateSet(duplicateSet)){\n+            return;\n+        }\n+        if (rng.nextDouble() < downsamplingRate){\n+            duplicateSet.getReads().forEach(r -> outputWriter.addRead(r));\n+            numReads += duplicateSet.getReads().size();\n+            numFragments += 1;\n+        }\n+    }\n+\n+    @Override\n+    public Object onTraversalSuccess(){\n+        outputWriter.close();\n+        logger.info(String.format(\"Wrote %d reads\", numReads));\n+        logger.info(String.format(\"Wrote %d fragments\", numFragments));\n+        return \"SUCCESS\";\n+    }\n+\n+    private boolean filterDuplicateSet(final DuplicateSet duplicateSet){\n+        if (duplicateSet.getReads().size() % 2 == 1){\n+            // We only keep reads with mates by default, as that's what fgbio GroupByUMI requires.\n+            logger.info(\"Duplicate set that contains an unpaired read discarded: \" + duplicateSet.getReads().get(0));\n+            return true;\n+        }\n+\n+        // Experiment: only keep duplex\n+        if (duplexOnly){\n+            final List<String> molecularIDs = DuplicateSet.getMolecularIDs(duplicateSet.getReads());", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMTQ0Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408431443", "bodyText": "Ooh, there is a difference between the String molecular id's and the int molecular ids.  I would rename stuff because it's confusing as hell.  Maybe something like \"getMolecularIdNumber\" vs \"getCompleteMolecularIds\"?", "author": "lbergelson", "createdAt": "2020-04-14T20:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwOTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5OTc4NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408899785", "bodyText": "Exactly. Two reads can have the same molecular number, which means they come from the same molecule, but they can come from the different strands.\nI'm going to extract a class for ID, with members ID number (e.g. 1,2,...) and strand (A/B) etc to make this clear", "author": "takutosato", "createdAt": "2020-04-15T14:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwOTIxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\nindex 1be866536..ccb5d70ed 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n\n@@ -1,34 +1,33 @@\n package org.broadinstitute.hellbender.tools.walkers.consensus;\n \n-import org.apache.commons.math3.random.RandomGenerator;\n-import org.apache.commons.math3.random.RandomGeneratorFactory;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.engine.ReferenceContext;\n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import org.glassfish.jersey.Beta;\n import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n \n-import java.io.File;\n-import java.util.List;\n import java.util.Random;\n \n @CommandLineProgramProperties(\n-        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         programGroup = ReadDataManipulationProgramGroup.class\n )\n /**\n- * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n- * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n  *\n- * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n  *\n- * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n  * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n  * in addition to ones common to the entire cell population.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMDA0MA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408410040", "bodyText": "Do you have to take things like secondary/supplementary alignments into account here?", "author": "lbergelson", "createdAt": "2020-04-14T20:19:39Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));\n+        outputWriter = createSAMWriter(IOUtils.getPath(outputBam.getAbsolutePath()), false);\n+    }\n+\n+    @Override\n+    public void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (filterDuplicateSet(duplicateSet)){\n+            return;\n+        }\n+        if (rng.nextDouble() < downsamplingRate){\n+            duplicateSet.getReads().forEach(r -> outputWriter.addRead(r));\n+            numReads += duplicateSet.getReads().size();\n+            numFragments += 1;\n+        }\n+    }\n+\n+    @Override\n+    public Object onTraversalSuccess(){\n+        outputWriter.close();\n+        logger.info(String.format(\"Wrote %d reads\", numReads));\n+        logger.info(String.format(\"Wrote %d fragments\", numFragments));\n+        return \"SUCCESS\";\n+    }\n+\n+    private boolean filterDuplicateSet(final DuplicateSet duplicateSet){\n+        if (duplicateSet.getReads().size() % 2 == 1){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMDA3Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408900073", "bodyText": "I believe those are filtered by the upstream fgbio tool", "author": "takutosato", "createdAt": "2020-04-15T14:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMDA0MA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\nindex 1be866536..ccb5d70ed 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n\n@@ -1,34 +1,33 @@\n package org.broadinstitute.hellbender.tools.walkers.consensus;\n \n-import org.apache.commons.math3.random.RandomGenerator;\n-import org.apache.commons.math3.random.RandomGeneratorFactory;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.engine.ReferenceContext;\n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import org.glassfish.jersey.Beta;\n import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n \n-import java.io.File;\n-import java.util.List;\n import java.util.Random;\n \n @CommandLineProgramProperties(\n-        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         programGroup = ReadDataManipulationProgramGroup.class\n )\n /**\n- * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n- * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n  *\n- * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n  *\n- * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n  * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n  * in addition to ones common to the entire cell population.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMDUxOA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408410518", "bodyText": "Needs javadoc.  This might cause confusion with the existing DuplicateSet from htsjdk.  I don't know if there's a slightly more descriptive name that could be used?  If you think DuplicateSet is the right name then some confusion is ok though.", "author": "lbergelson", "createdAt": "2020-04-14T20:20:28Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkxMTAyNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408911027", "bodyText": "Renamed to ReadSetWithSharedUMI tentatively. Javadoc written.", "author": "takutosato", "createdAt": "2020-04-15T14:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMDUxOA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMTI3MA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408411270", "bodyText": "I think this is standard in the sam spec now.  ReferenceSamTags.MI.name()", "author": "lbergelson", "createdAt": "2020-04-14T20:21:53Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1MjkyMA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409052920", "bodyText": "Super", "author": "takutosato", "createdAt": "2020-04-15T18:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMTI3MA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMTY0NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408411645", "bodyText": "I'm confused about this, you expose -1 as a constant elsewhere, can all of that be handled internally instead?", "author": "lbergelson", "createdAt": "2020-04-14T20:22:34Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMTY5OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408411698", "bodyText": "This is never actually used.", "author": "lbergelson", "createdAt": "2020-04-14T20:22:40Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1NDMyOA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409054328", "bodyText": "Removed", "author": "takutosato", "createdAt": "2020-04-15T18:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMTY5OA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMjAwMA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408412000", "bodyText": "This should implement Locatable.", "author": "lbergelson", "createdAt": "2020-04-14T20:23:11Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1MTc4Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409051783", "bodyText": "Done", "author": "takutosato", "createdAt": "2020-04-15T18:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMjAwMA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMzM5MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408413391", "bodyText": "this can be final and initialized here.", "author": "lbergelson", "createdAt": "2020-04-14T20:25:43Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMzUwOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408413509", "bodyText": "You could keep an internal simple interval  / locatable if you didn't want 3 fields.  It's fine to have 3 though if you think that's easier.", "author": "lbergelson", "createdAt": "2020-04-14T20:25:58Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNDQ1MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408414451", "bodyText": "This is never set or used", "author": "lbergelson", "createdAt": "2020-04-14T20:27:47Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNDYxOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408414619", "bodyText": "This isn't used either and it's only kind of set.", "author": "lbergelson", "createdAt": "2020-04-14T20:28:05Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNDc0MA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408414740", "bodyText": "This comment needs addressing.", "author": "lbergelson", "createdAt": "2020-04-14T20:28:20Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNTEwMA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408415100", "bodyText": "javadoc", "author": "lbergelson", "createdAt": "2020-04-14T20:28:54Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNTU4Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408415582", "bodyText": "If your second constructor starts with the same code as the first constructor it's better to just do this();", "author": "lbergelson", "createdAt": "2020-04-14T20:29:48Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1NDkxNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409054915", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-15T18:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNTU4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNTgyOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408415829", "bodyText": "This seems like it should be private.", "author": "lbergelson", "createdAt": "2020-04-14T20:30:16Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1NTIwMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409055201", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-15T18:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNTgyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNjA1OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408416059", "bodyText": "typo in Inconsisntent.", "author": "lbergelson", "createdAt": "2020-04-14T20:30:41Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1NTQ0NA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409055444", "bodyText": "ooops", "author": "takutosato", "createdAt": "2020-04-15T18:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNjA1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNjE4Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408416187", "bodyText": "split these onto 2 lines.", "author": "lbergelson", "createdAt": "2020-04-14T20:30:54Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNjQ4OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408416489", "bodyText": "You probably want to wrap this in an UnmodifiableList to prevent someone from doing something wacky with the output that breaks assumptions about the duplicate set.", "author": "lbergelson", "createdAt": "2020-04-14T20:31:26Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1NjQ5MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409056491", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-15T18:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNjQ4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNzE3MA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408417170", "bodyText": "javadoc", "author": "lbergelson", "createdAt": "2020-04-14T20:32:37Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNzM0MA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408417340", "bodyText": "typo moledule", "author": "lbergelson", "createdAt": "2020-04-14T20:32:58Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxODE0NA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408418144", "bodyText": "I think this method should probably be removed.  Is there a use case for changing the molecule ID after it's already set?  Seems dangerous.", "author": "lbergelson", "createdAt": "2020-04-14T20:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNzM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA2MTQ2Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409061467", "bodyText": "That's true, removed", "author": "takutosato", "createdAt": "2020-04-15T18:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNzM0MA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNzM5Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408417393", "bodyText": "typo moledule", "author": "lbergelson", "createdAt": "2020-04-14T20:33:06Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxODI0Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408418247", "bodyText": "Similarly, this should probably be removed.", "author": "lbergelson", "createdAt": "2020-04-14T20:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNzM5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA2NDU5MA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409064590", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-15T18:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNzM5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxOTAyOA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408419028", "bodyText": "Is there ever a reason for allowing improper reads in the set?  It seems like this would better if it threw when an incorrect read was added.  That way you never have to check that the set is valid, it just is...", "author": "lbergelson", "createdAt": "2020-04-14T20:35:59Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1Mjg3NA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r410452874", "bodyText": "True, done", "author": "takutosato", "createdAt": "2020-04-17T20:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxOTAyOA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMDEyMg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408420122", "bodyText": "I'm again confused about the use of invalid duplicate sets with different molecules.  Seems like bad news.", "author": "lbergelson", "createdAt": "2020-04-14T20:38:07Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA2ODc2OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409068768", "bodyText": "Yes, the way the code is written, when this method returns false it the tool exists with error. I'm going to move that check to the beginning of this method to make that clear.", "author": "takutosato", "createdAt": "2020-04-15T19:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMDEyMg=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMTc3NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408421775", "bodyText": "If you are keeping an internal simple interval instead of separate values you could use interval.spanWith(read) instead of this logic.", "author": "lbergelson", "createdAt": "2020-04-14T20:41:02Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjA5Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408422093", "bodyText": "It seems like there will be problems if you have reads from different contigs.  I assume that's possible since they are aligned separately?", "author": "lbergelson", "createdAt": "2020-04-14T20:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMTc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc4NTc3Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409785773", "bodyText": "Much cleaner with spanWith. Now checks that the incoming read has the same contig.", "author": "takutosato", "createdAt": "2020-04-16T19:07:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMTc3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjM5Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408422396", "bodyText": "javadoc", "author": "lbergelson", "createdAt": "2020-04-14T20:42:12Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){\n+                fragmentStart = read.getStart();\n+            }\n+            if (read.getEnd() > fragmentEnd){\n+                fragmentEnd = read.getEnd();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getFragmentStart(){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjQ1MA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408422450", "bodyText": "doc", "author": "lbergelson", "createdAt": "2020-04-14T20:42:16Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){\n+                fragmentStart = read.getStart();\n+            }\n+            if (read.getEnd() > fragmentEnd){\n+                fragmentEnd = read.getEnd();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getFragmentStart(){\n+        return fragmentStart;\n+    }\n+\n+    public int getFragmentEnd(){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjQ4MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408422481", "bodyText": "doc", "author": "lbergelson", "createdAt": "2020-04-14T20:42:20Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){\n+                fragmentStart = read.getStart();\n+            }\n+            if (read.getEnd() > fragmentEnd){\n+                fragmentEnd = read.getEnd();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getFragmentStart(){\n+        return fragmentStart;\n+    }\n+\n+    public int getFragmentEnd(){\n+        return fragmentEnd;\n+    }\n+\n+    public int getMoleculeId() { return moleculeId; }", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjg5Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408422897", "bodyText": "unnecessary if this is locatable.", "author": "lbergelson", "createdAt": "2020-04-14T20:43:05Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){\n+                fragmentStart = read.getStart();\n+            }\n+            if (read.getEnd() > fragmentEnd){\n+                fragmentEnd = read.getEnd();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getFragmentStart(){\n+        return fragmentStart;\n+    }\n+\n+    public int getFragmentEnd(){\n+        return fragmentEnd;\n+    }\n+\n+    public int getMoleculeId() { return moleculeId; }\n+\n+    public SimpleInterval getDuplicateSetInterval(){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzg2NA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408423864", "bodyText": "This seems strange.  If you're computing intervals correctly you should never get an invalid one UNLESS you're mixing different contigs, in which case you probably want to test that more aggressively so that you don't sometimes get them by accident.", "author": "lbergelson", "createdAt": "2020-04-14T20:44:51Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){\n+                fragmentStart = read.getStart();\n+            }\n+            if (read.getEnd() > fragmentEnd){\n+                fragmentEnd = read.getEnd();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getFragmentStart(){\n+        return fragmentStart;\n+    }\n+\n+    public int getFragmentEnd(){\n+        return fragmentEnd;\n+    }\n+\n+    public int getMoleculeId() { return moleculeId; }\n+\n+    public SimpleInterval getDuplicateSetInterval(){\n+        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n+    }\n+\n+    public boolean hasValidInterval(){\n+        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc4MzU2Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409783563", "bodyText": "True. Removed.", "author": "takutosato", "createdAt": "2020-04-16T19:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzg2NA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNDIyMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408424221", "bodyText": "javadoc, confusing why we want this", "author": "lbergelson", "createdAt": "2020-04-14T20:45:32Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){\n+                fragmentStart = read.getStart();\n+            }\n+            if (read.getEnd() > fragmentEnd){\n+                fragmentEnd = read.getEnd();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getFragmentStart(){\n+        return fragmentStart;\n+    }\n+\n+    public int getFragmentEnd(){\n+        return fragmentEnd;\n+    }\n+\n+    public int getMoleculeId() { return moleculeId; }\n+\n+    public SimpleInterval getDuplicateSetInterval(){\n+        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n+    }\n+\n+    public boolean hasValidInterval(){\n+        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n+    }\n+\n+    public static List<String> getMolecularIDs(final List<GATKRead> reads) {", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMjMwNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408432305", "bodyText": "Ok, I understand this now... you need clear javadoc and probably to rename this method since it's very strange that getMolecularID on 2 reads can produce the same result but getMolecularIDs then has 2 values.", "author": "lbergelson", "createdAt": "2020-04-14T21:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNDIyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\ndeleted file mode 100644\nindex 7675d6572..000000000\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java\n+++ /dev/null\n\n@@ -1,122 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n-\n-import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n-import org.broadinstitute.hellbender.utils.SimpleInterval;\n-import org.broadinstitute.hellbender.utils.Utils;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class DuplicateSet {\n-    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n-    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n-    private int moleculeId = -1; // TODO: extract an ID class.\n-    private UMI umi;\n-    private String contig;\n-    private int fragmentStart = -1;\n-    private int fragmentEnd = -1;\n-    private List<GATKRead> reads;\n-    boolean smallInsert; // if true, the reads read into adaptors\n-    private boolean paired;  // TODO: is this useful/how can I detect this?\n-    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n-    public DuplicateSet(){\n-        reads = new ArrayList<>();\n-    }\n-\n-    public DuplicateSet(final GATKRead read){\n-        reads = new ArrayList<>();\n-        init(read);\n-        reads.add(read);\n-    }\n-\n-    public void init(GATKRead read){\n-        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n-                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n-        setMoleduleId(read);umi = new UMI(read);\n-        contig = read.getContig();\n-        fragmentStart = read.getStart();\n-        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n-        paired = false;\n-    }\n-\n-    public List<GATKRead> getReads(){\n-        return reads;\n-    }\n-\n-    public boolean sameMolecule(final GATKRead read){\n-        return getMoleculeID(read) == moleculeId;\n-    }\n-\n-    public void setMoleduleId(GATKRead read){\n-        moleculeId = getMoleculeID(read);\n-    }\n-\n-    public void setMoleduleId(int id){\n-        moleculeId = id;\n-    }\n-\n-    /**\n-     * Some examples of molecule IDs (MI tag):\n-     *\n-     * \"0/A\" (The first molecule in the bam, top (A) strand)\n-     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n-     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n-     *\n-     * Top strand is synonymous to \"F1R2\"\n-     * Bottom strand is synonymous to \"F2R1\"\n-     *\n-     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n-     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n-     */\n-    public static int getMoleculeID(final GATKRead read) {\n-        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n-        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n-    }\n-\n-    /** Returns true if the read was properly added to the duplicate set **/\n-    public boolean addRead(final GATKRead read){\n-        if (reads.isEmpty()){\n-            init(read);\n-            reads.add(read);\n-            return true;\n-        }\n-\n-        if (sameMolecule(read)){\n-            reads.add(read);\n-            if (read.getStart() < fragmentStart){\n-                fragmentStart = read.getStart();\n-            }\n-            if (read.getEnd() > fragmentEnd){\n-                fragmentEnd = read.getEnd();\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public int getFragmentStart(){\n-        return fragmentStart;\n-    }\n-\n-    public int getFragmentEnd(){\n-        return fragmentEnd;\n-    }\n-\n-    public int getMoleculeId() { return moleculeId; }\n-\n-    public SimpleInterval getDuplicateSetInterval(){\n-        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public boolean hasValidInterval(){\n-        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n-    }\n-\n-    public static List<String> getMolecularIDs(final List<GATKRead> reads) {\n-        return reads.stream().map(r -> r.getAttributeAsString(DuplicateSet.FGBIO_MOLECULAR_IDENTIFIER_TAG))\n-                .distinct().collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNDU4OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408424589", "bodyText": "Lets copy this to our bucket so we have our own copy and it can't be deleted out from under us", "author": "lbergelson", "createdAt": "2020-04-14T20:46:15Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java b/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\ndeleted file mode 100644\nindex 23892eab6..000000000\n--- a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\n+++ /dev/null\n\n@@ -1,129 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.consensus;\n-\n-import org.apache.commons.lang3.mutable.MutableInt;\n-import org.broadinstitute.hellbender.CommandLineProgramTest;\n-import org.broadinstitute.hellbender.engine.ReadsDataSource;\n-import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.io.File;\n-import java.nio.file.Paths;\n-import java.util.*;\n-\n-public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n-    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n-\n-    @Test\n-    public void test(){\n-        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n-        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", cloud)\n-                .add(\"O\", out)\n-                .add(\"DS\", \"1.0\")\n-                .add(\"keep-duplex-only\", \"true\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-    }\n-\n-    @Test\n-    public void testMatesAreTogether(){\n-        final File out = createTempFile(\"downsampled\", \"bam\");\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"O\", out.getAbsolutePath())\n-                .add(\"DS\", \"1.0\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            // Make sure that the read and its mate are next to each other in the file\n-            final GATKRead read1 = iterator.next();\n-            final GATKRead read2 = iterator.next();\n-            Assert.assertEquals(read1.getName(), read2.getName());\n-        }\n-    }\n-\n-    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n-    @Test\n-    public void testNoDownsampling(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        final double downsampleRate = 1.0;\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"DS\", Double.toString(downsampleRate))\n-                .add(\"O\", out.getAbsolutePath());\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-        final Map<String, MutableInt> originalMoleculeCounts = molecularIDsAndCounts(originalBam);\n-\n-        final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Map<String, MutableInt> downsampledMoleculeCounts = molecularIDsAndCounts(downsampledBam);\n-\n-        for (Map.Entry<String, MutableInt> originalIDAndCount : originalMoleculeCounts.entrySet()){\n-            final String originalID = originalIDAndCount.getKey();\n-            final int originalCount = originalIDAndCount.getValue().intValue();\n-            Assert.assertTrue(originalCount == downsampledMoleculeCounts.get(originalID).intValue());\n-        }\n-    }\n-\n-    /**\n-     * Test that the downsampling rate corresponds to the reduction in the number of duplicates in the output\n-     * file up to sampling noise.\n-     */\n-    @Test\n-    public void testDownsampleFraction(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        for (double downsampleRate : Arrays.asList(0.1, 0.3, 0.5)){\n-            final ArgumentsBuilder args = new ArgumentsBuilder()\n-                    .add(\"I\", NA12878_GROUPED)\n-                    .add(\"DS\", Double.toString(downsampleRate))\n-                    .add(\"O\", out.getAbsolutePath());\n-            runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-            final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-            final int originalMoleculeCount = countDuplicateSets(originalBam);\n-\n-            final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-            final int downsampledMoleculeCount = countDuplicateSets(downsampledBam);\n-\n-            final double noise = 2.0;\n-            final double deviationFromExpected = Math.abs(downsampleRate * originalMoleculeCount - downsampledMoleculeCount);\n-            Assert.assertTrue(deviationFromExpected < noise);\n-        }\n-    }\n-\n-    private int countDuplicateSets(final ReadsDataSource readsDataSource){\n-        int count = 0;\n-        String currentMolecularId = \"\"; // Note we are duplex aware: 12/A different from 12/B\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\");\n-            if (!molecularID.equals(currentMolecularId)){\n-                count++;\n-                currentMolecularId = molecularID;\n-            }\n-        }\n-\n-        return count;\n-    }\n-\n-    private Map<String, MutableInt> molecularIDsAndCounts(final ReadsDataSource readsDataSource){\n-        final Map<String, MutableInt> map = new TreeMap<>();\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\"); // Note we are duplex aware: 12/A different from 12/B\n-            if (map.containsKey(molecularID)){\n-                map.get(molecularID).increment();\n-            } else {\n-                map.put(molecularID, new MutableInt(0));\n-            }\n-        }\n-        return map;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNDgxNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408424817", "bodyText": "needs to be marked with groups=\"cloud\"", "author": "lbergelson", "createdAt": "2020-04-14T20:46:40Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java b/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\ndeleted file mode 100644\nindex 23892eab6..000000000\n--- a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\n+++ /dev/null\n\n@@ -1,129 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.consensus;\n-\n-import org.apache.commons.lang3.mutable.MutableInt;\n-import org.broadinstitute.hellbender.CommandLineProgramTest;\n-import org.broadinstitute.hellbender.engine.ReadsDataSource;\n-import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.io.File;\n-import java.nio.file.Paths;\n-import java.util.*;\n-\n-public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n-    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n-\n-    @Test\n-    public void test(){\n-        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n-        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", cloud)\n-                .add(\"O\", out)\n-                .add(\"DS\", \"1.0\")\n-                .add(\"keep-duplex-only\", \"true\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-    }\n-\n-    @Test\n-    public void testMatesAreTogether(){\n-        final File out = createTempFile(\"downsampled\", \"bam\");\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"O\", out.getAbsolutePath())\n-                .add(\"DS\", \"1.0\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            // Make sure that the read and its mate are next to each other in the file\n-            final GATKRead read1 = iterator.next();\n-            final GATKRead read2 = iterator.next();\n-            Assert.assertEquals(read1.getName(), read2.getName());\n-        }\n-    }\n-\n-    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n-    @Test\n-    public void testNoDownsampling(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        final double downsampleRate = 1.0;\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"DS\", Double.toString(downsampleRate))\n-                .add(\"O\", out.getAbsolutePath());\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-        final Map<String, MutableInt> originalMoleculeCounts = molecularIDsAndCounts(originalBam);\n-\n-        final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Map<String, MutableInt> downsampledMoleculeCounts = molecularIDsAndCounts(downsampledBam);\n-\n-        for (Map.Entry<String, MutableInt> originalIDAndCount : originalMoleculeCounts.entrySet()){\n-            final String originalID = originalIDAndCount.getKey();\n-            final int originalCount = originalIDAndCount.getValue().intValue();\n-            Assert.assertTrue(originalCount == downsampledMoleculeCounts.get(originalID).intValue());\n-        }\n-    }\n-\n-    /**\n-     * Test that the downsampling rate corresponds to the reduction in the number of duplicates in the output\n-     * file up to sampling noise.\n-     */\n-    @Test\n-    public void testDownsampleFraction(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        for (double downsampleRate : Arrays.asList(0.1, 0.3, 0.5)){\n-            final ArgumentsBuilder args = new ArgumentsBuilder()\n-                    .add(\"I\", NA12878_GROUPED)\n-                    .add(\"DS\", Double.toString(downsampleRate))\n-                    .add(\"O\", out.getAbsolutePath());\n-            runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-            final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-            final int originalMoleculeCount = countDuplicateSets(originalBam);\n-\n-            final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-            final int downsampledMoleculeCount = countDuplicateSets(downsampledBam);\n-\n-            final double noise = 2.0;\n-            final double deviationFromExpected = Math.abs(downsampleRate * originalMoleculeCount - downsampledMoleculeCount);\n-            Assert.assertTrue(deviationFromExpected < noise);\n-        }\n-    }\n-\n-    private int countDuplicateSets(final ReadsDataSource readsDataSource){\n-        int count = 0;\n-        String currentMolecularId = \"\"; // Note we are duplex aware: 12/A different from 12/B\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\");\n-            if (!molecularID.equals(currentMolecularId)){\n-                count++;\n-                currentMolecularId = molecularID;\n-            }\n-        }\n-\n-        return count;\n-    }\n-\n-    private Map<String, MutableInt> molecularIDsAndCounts(final ReadsDataSource readsDataSource){\n-        final Map<String, MutableInt> map = new TreeMap<>();\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\"); // Note we are duplex aware: 12/A different from 12/B\n-            if (map.containsKey(molecularID)){\n-                map.get(molecularID).increment();\n-            } else {\n-                map.put(molecularID, new MutableInt(0));\n-            }\n-        }\n-        return map;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNTE2MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408425161", "bodyText": "Specifying the program name should be unnecessary, it should automatic that.", "author": "lbergelson", "createdAt": "2020-04-14T20:47:18Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", cloud)\n+                .add(\"O\", out)\n+                .add(\"DS\", \"1.0\")\n+                .add(\"keep-duplex-only\", \"true\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNTQzOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408425439", "bodyText": "Should this test test something?", "author": "lbergelson", "createdAt": "2020-04-14T20:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNTE2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java b/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\ndeleted file mode 100644\nindex 23892eab6..000000000\n--- a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\n+++ /dev/null\n\n@@ -1,129 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.consensus;\n-\n-import org.apache.commons.lang3.mutable.MutableInt;\n-import org.broadinstitute.hellbender.CommandLineProgramTest;\n-import org.broadinstitute.hellbender.engine.ReadsDataSource;\n-import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.io.File;\n-import java.nio.file.Paths;\n-import java.util.*;\n-\n-public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n-    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n-\n-    @Test\n-    public void test(){\n-        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n-        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", cloud)\n-                .add(\"O\", out)\n-                .add(\"DS\", \"1.0\")\n-                .add(\"keep-duplex-only\", \"true\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-    }\n-\n-    @Test\n-    public void testMatesAreTogether(){\n-        final File out = createTempFile(\"downsampled\", \"bam\");\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"O\", out.getAbsolutePath())\n-                .add(\"DS\", \"1.0\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            // Make sure that the read and its mate are next to each other in the file\n-            final GATKRead read1 = iterator.next();\n-            final GATKRead read2 = iterator.next();\n-            Assert.assertEquals(read1.getName(), read2.getName());\n-        }\n-    }\n-\n-    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n-    @Test\n-    public void testNoDownsampling(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        final double downsampleRate = 1.0;\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"DS\", Double.toString(downsampleRate))\n-                .add(\"O\", out.getAbsolutePath());\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-        final Map<String, MutableInt> originalMoleculeCounts = molecularIDsAndCounts(originalBam);\n-\n-        final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Map<String, MutableInt> downsampledMoleculeCounts = molecularIDsAndCounts(downsampledBam);\n-\n-        for (Map.Entry<String, MutableInt> originalIDAndCount : originalMoleculeCounts.entrySet()){\n-            final String originalID = originalIDAndCount.getKey();\n-            final int originalCount = originalIDAndCount.getValue().intValue();\n-            Assert.assertTrue(originalCount == downsampledMoleculeCounts.get(originalID).intValue());\n-        }\n-    }\n-\n-    /**\n-     * Test that the downsampling rate corresponds to the reduction in the number of duplicates in the output\n-     * file up to sampling noise.\n-     */\n-    @Test\n-    public void testDownsampleFraction(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        for (double downsampleRate : Arrays.asList(0.1, 0.3, 0.5)){\n-            final ArgumentsBuilder args = new ArgumentsBuilder()\n-                    .add(\"I\", NA12878_GROUPED)\n-                    .add(\"DS\", Double.toString(downsampleRate))\n-                    .add(\"O\", out.getAbsolutePath());\n-            runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-            final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-            final int originalMoleculeCount = countDuplicateSets(originalBam);\n-\n-            final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-            final int downsampledMoleculeCount = countDuplicateSets(downsampledBam);\n-\n-            final double noise = 2.0;\n-            final double deviationFromExpected = Math.abs(downsampleRate * originalMoleculeCount - downsampledMoleculeCount);\n-            Assert.assertTrue(deviationFromExpected < noise);\n-        }\n-    }\n-\n-    private int countDuplicateSets(final ReadsDataSource readsDataSource){\n-        int count = 0;\n-        String currentMolecularId = \"\"; // Note we are duplex aware: 12/A different from 12/B\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\");\n-            if (!molecularID.equals(currentMolecularId)){\n-                count++;\n-                currentMolecularId = molecularID;\n-            }\n-        }\n-\n-        return count;\n-    }\n-\n-    private Map<String, MutableInt> molecularIDsAndCounts(final ReadsDataSource readsDataSource){\n-        final Map<String, MutableInt> map = new TreeMap<>();\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\"); // Note we are duplex aware: 12/A different from 12/B\n-            if (map.containsKey(molecularID)){\n-                map.get(molecularID).increment();\n-            } else {\n-                map.put(molecularID, new MutableInt(0));\n-            }\n-        }\n-        return map;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNTI1Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408425257", "bodyText": "this needs to be a temp file", "author": "lbergelson", "createdAt": "2020-04-14T20:47:31Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java b/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\ndeleted file mode 100644\nindex 23892eab6..000000000\n--- a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\n+++ /dev/null\n\n@@ -1,129 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.consensus;\n-\n-import org.apache.commons.lang3.mutable.MutableInt;\n-import org.broadinstitute.hellbender.CommandLineProgramTest;\n-import org.broadinstitute.hellbender.engine.ReadsDataSource;\n-import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.io.File;\n-import java.nio.file.Paths;\n-import java.util.*;\n-\n-public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n-    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n-\n-    @Test\n-    public void test(){\n-        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n-        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", cloud)\n-                .add(\"O\", out)\n-                .add(\"DS\", \"1.0\")\n-                .add(\"keep-duplex-only\", \"true\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-    }\n-\n-    @Test\n-    public void testMatesAreTogether(){\n-        final File out = createTempFile(\"downsampled\", \"bam\");\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"O\", out.getAbsolutePath())\n-                .add(\"DS\", \"1.0\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            // Make sure that the read and its mate are next to each other in the file\n-            final GATKRead read1 = iterator.next();\n-            final GATKRead read2 = iterator.next();\n-            Assert.assertEquals(read1.getName(), read2.getName());\n-        }\n-    }\n-\n-    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n-    @Test\n-    public void testNoDownsampling(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        final double downsampleRate = 1.0;\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"DS\", Double.toString(downsampleRate))\n-                .add(\"O\", out.getAbsolutePath());\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-        final Map<String, MutableInt> originalMoleculeCounts = molecularIDsAndCounts(originalBam);\n-\n-        final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Map<String, MutableInt> downsampledMoleculeCounts = molecularIDsAndCounts(downsampledBam);\n-\n-        for (Map.Entry<String, MutableInt> originalIDAndCount : originalMoleculeCounts.entrySet()){\n-            final String originalID = originalIDAndCount.getKey();\n-            final int originalCount = originalIDAndCount.getValue().intValue();\n-            Assert.assertTrue(originalCount == downsampledMoleculeCounts.get(originalID).intValue());\n-        }\n-    }\n-\n-    /**\n-     * Test that the downsampling rate corresponds to the reduction in the number of duplicates in the output\n-     * file up to sampling noise.\n-     */\n-    @Test\n-    public void testDownsampleFraction(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        for (double downsampleRate : Arrays.asList(0.1, 0.3, 0.5)){\n-            final ArgumentsBuilder args = new ArgumentsBuilder()\n-                    .add(\"I\", NA12878_GROUPED)\n-                    .add(\"DS\", Double.toString(downsampleRate))\n-                    .add(\"O\", out.getAbsolutePath());\n-            runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-            final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-            final int originalMoleculeCount = countDuplicateSets(originalBam);\n-\n-            final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-            final int downsampledMoleculeCount = countDuplicateSets(downsampledBam);\n-\n-            final double noise = 2.0;\n-            final double deviationFromExpected = Math.abs(downsampleRate * originalMoleculeCount - downsampledMoleculeCount);\n-            Assert.assertTrue(deviationFromExpected < noise);\n-        }\n-    }\n-\n-    private int countDuplicateSets(final ReadsDataSource readsDataSource){\n-        int count = 0;\n-        String currentMolecularId = \"\"; // Note we are duplex aware: 12/A different from 12/B\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\");\n-            if (!molecularID.equals(currentMolecularId)){\n-                count++;\n-                currentMolecularId = molecularID;\n-            }\n-        }\n-\n-        return count;\n-    }\n-\n-    private Map<String, MutableInt> molecularIDsAndCounts(final ReadsDataSource readsDataSource){\n-        final Map<String, MutableInt> map = new TreeMap<>();\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\"); // Note we are duplex aware: 12/A different from 12/B\n-            if (map.containsKey(molecularID)){\n-                map.get(molecularID).increment();\n-            } else {\n-                map.put(molecularID, new MutableInt(0));\n-            }\n-        }\n-        return map;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNjAzMw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408426033", "bodyText": "This is unused and adds complication, lets remove it.", "author": "lbergelson", "createdAt": "2020-04-14T20:48:53Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -167,4 +167,16 @@ protected final void onShutdown() {\n         // Overridden only to make final so that concrete tool implementations don't override\n         super.onShutdown();\n     }\n+\n+    public void postProcess(){\n+        return;\n+    }\n+\n+    public GATKRead peekFirstRead(){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1OTY5OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409059698", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-15T18:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNjAzMw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\nindex 9e55e4b32..e3d6c52fd 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\n\n@@ -167,16 +167,4 @@ public abstract class ReadWalker extends WalkerBase {\n         // Overridden only to make final so that concrete tool implementations don't override\n         super.onShutdown();\n     }\n-\n-    public void postProcess(){\n-        return;\n-    }\n-\n-    public GATKRead peekFirstRead(){\n-        if (reads.iterator().hasNext()){\n-            return reads.iterator().next();\n-        }\n-        // Maybe the correct thing to do is for this to return an error when the user input is empty\n-        return null;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNjU0OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408426549", "bodyText": "declare this in a try-with-resources block", "author": "lbergelson", "createdAt": "2020-04-14T20:49:47Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", cloud)\n+                .add(\"O\", out)\n+                .add(\"DS\", \"1.0\")\n+                .add(\"keep-duplex-only\", \"true\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+    }\n+\n+    @Test\n+    public void testMatesAreTogether(){\n+        final File out = createTempFile(\"downsampled\", \"bam\");\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"O\", out.getAbsolutePath())\n+                .add(\"DS\", \"1.0\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MzMyMw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r410463323", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-17T20:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNjU0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java b/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\ndeleted file mode 100644\nindex 23892eab6..000000000\n--- a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\n+++ /dev/null\n\n@@ -1,129 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.consensus;\n-\n-import org.apache.commons.lang3.mutable.MutableInt;\n-import org.broadinstitute.hellbender.CommandLineProgramTest;\n-import org.broadinstitute.hellbender.engine.ReadsDataSource;\n-import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.io.File;\n-import java.nio.file.Paths;\n-import java.util.*;\n-\n-public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n-    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n-\n-    @Test\n-    public void test(){\n-        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n-        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", cloud)\n-                .add(\"O\", out)\n-                .add(\"DS\", \"1.0\")\n-                .add(\"keep-duplex-only\", \"true\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-    }\n-\n-    @Test\n-    public void testMatesAreTogether(){\n-        final File out = createTempFile(\"downsampled\", \"bam\");\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"O\", out.getAbsolutePath())\n-                .add(\"DS\", \"1.0\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            // Make sure that the read and its mate are next to each other in the file\n-            final GATKRead read1 = iterator.next();\n-            final GATKRead read2 = iterator.next();\n-            Assert.assertEquals(read1.getName(), read2.getName());\n-        }\n-    }\n-\n-    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n-    @Test\n-    public void testNoDownsampling(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        final double downsampleRate = 1.0;\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"DS\", Double.toString(downsampleRate))\n-                .add(\"O\", out.getAbsolutePath());\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-        final Map<String, MutableInt> originalMoleculeCounts = molecularIDsAndCounts(originalBam);\n-\n-        final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Map<String, MutableInt> downsampledMoleculeCounts = molecularIDsAndCounts(downsampledBam);\n-\n-        for (Map.Entry<String, MutableInt> originalIDAndCount : originalMoleculeCounts.entrySet()){\n-            final String originalID = originalIDAndCount.getKey();\n-            final int originalCount = originalIDAndCount.getValue().intValue();\n-            Assert.assertTrue(originalCount == downsampledMoleculeCounts.get(originalID).intValue());\n-        }\n-    }\n-\n-    /**\n-     * Test that the downsampling rate corresponds to the reduction in the number of duplicates in the output\n-     * file up to sampling noise.\n-     */\n-    @Test\n-    public void testDownsampleFraction(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        for (double downsampleRate : Arrays.asList(0.1, 0.3, 0.5)){\n-            final ArgumentsBuilder args = new ArgumentsBuilder()\n-                    .add(\"I\", NA12878_GROUPED)\n-                    .add(\"DS\", Double.toString(downsampleRate))\n-                    .add(\"O\", out.getAbsolutePath());\n-            runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-            final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-            final int originalMoleculeCount = countDuplicateSets(originalBam);\n-\n-            final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-            final int downsampledMoleculeCount = countDuplicateSets(downsampledBam);\n-\n-            final double noise = 2.0;\n-            final double deviationFromExpected = Math.abs(downsampleRate * originalMoleculeCount - downsampledMoleculeCount);\n-            Assert.assertTrue(deviationFromExpected < noise);\n-        }\n-    }\n-\n-    private int countDuplicateSets(final ReadsDataSource readsDataSource){\n-        int count = 0;\n-        String currentMolecularId = \"\"; // Note we are duplex aware: 12/A different from 12/B\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\");\n-            if (!molecularID.equals(currentMolecularId)){\n-                count++;\n-                currentMolecularId = molecularID;\n-            }\n-        }\n-\n-        return count;\n-    }\n-\n-    private Map<String, MutableInt> molecularIDsAndCounts(final ReadsDataSource readsDataSource){\n-        final Map<String, MutableInt> map = new TreeMap<>();\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\"); // Note we are duplex aware: 12/A different from 12/B\n-            if (map.containsKey(molecularID)){\n-                map.get(molecularID).increment();\n-            } else {\n-                map.put(molecularID, new MutableInt(0));\n-            }\n-        }\n-        return map;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNjc0OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408426749", "bodyText": "declare datasources in a try-with-resources", "author": "lbergelson", "createdAt": "2020-04-14T20:50:10Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", cloud)\n+                .add(\"O\", out)\n+                .add(\"DS\", \"1.0\")\n+                .add(\"keep-duplex-only\", \"true\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+    }\n+\n+    @Test\n+    public void testMatesAreTogether(){\n+        final File out = createTempFile(\"downsampled\", \"bam\");\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"O\", out.getAbsolutePath())\n+                .add(\"DS\", \"1.0\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n+        while (iterator.hasNext()){\n+            // Make sure that the read and its mate are next to each other in the file\n+            final GATKRead read1 = iterator.next();\n+            final GATKRead read2 = iterator.next();\n+            Assert.assertEquals(read1.getName(), read2.getName());\n+        }\n+    }\n+\n+    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n+    @Test\n+    public void testNoDownsampling(){\n+        final File out = createTempFile(\"downasampled\", \"bam\");\n+        final double downsampleRate = 1.0;\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"DS\", Double.toString(downsampleRate))\n+                .add(\"O\", out.getAbsolutePath());\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java b/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\ndeleted file mode 100644\nindex 23892eab6..000000000\n--- a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\n+++ /dev/null\n\n@@ -1,129 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.consensus;\n-\n-import org.apache.commons.lang3.mutable.MutableInt;\n-import org.broadinstitute.hellbender.CommandLineProgramTest;\n-import org.broadinstitute.hellbender.engine.ReadsDataSource;\n-import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.io.File;\n-import java.nio.file.Paths;\n-import java.util.*;\n-\n-public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n-    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n-\n-    @Test\n-    public void test(){\n-        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n-        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", cloud)\n-                .add(\"O\", out)\n-                .add(\"DS\", \"1.0\")\n-                .add(\"keep-duplex-only\", \"true\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-    }\n-\n-    @Test\n-    public void testMatesAreTogether(){\n-        final File out = createTempFile(\"downsampled\", \"bam\");\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"O\", out.getAbsolutePath())\n-                .add(\"DS\", \"1.0\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            // Make sure that the read and its mate are next to each other in the file\n-            final GATKRead read1 = iterator.next();\n-            final GATKRead read2 = iterator.next();\n-            Assert.assertEquals(read1.getName(), read2.getName());\n-        }\n-    }\n-\n-    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n-    @Test\n-    public void testNoDownsampling(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        final double downsampleRate = 1.0;\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"DS\", Double.toString(downsampleRate))\n-                .add(\"O\", out.getAbsolutePath());\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-        final Map<String, MutableInt> originalMoleculeCounts = molecularIDsAndCounts(originalBam);\n-\n-        final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Map<String, MutableInt> downsampledMoleculeCounts = molecularIDsAndCounts(downsampledBam);\n-\n-        for (Map.Entry<String, MutableInt> originalIDAndCount : originalMoleculeCounts.entrySet()){\n-            final String originalID = originalIDAndCount.getKey();\n-            final int originalCount = originalIDAndCount.getValue().intValue();\n-            Assert.assertTrue(originalCount == downsampledMoleculeCounts.get(originalID).intValue());\n-        }\n-    }\n-\n-    /**\n-     * Test that the downsampling rate corresponds to the reduction in the number of duplicates in the output\n-     * file up to sampling noise.\n-     */\n-    @Test\n-    public void testDownsampleFraction(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        for (double downsampleRate : Arrays.asList(0.1, 0.3, 0.5)){\n-            final ArgumentsBuilder args = new ArgumentsBuilder()\n-                    .add(\"I\", NA12878_GROUPED)\n-                    .add(\"DS\", Double.toString(downsampleRate))\n-                    .add(\"O\", out.getAbsolutePath());\n-            runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-            final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-            final int originalMoleculeCount = countDuplicateSets(originalBam);\n-\n-            final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-            final int downsampledMoleculeCount = countDuplicateSets(downsampledBam);\n-\n-            final double noise = 2.0;\n-            final double deviationFromExpected = Math.abs(downsampleRate * originalMoleculeCount - downsampledMoleculeCount);\n-            Assert.assertTrue(deviationFromExpected < noise);\n-        }\n-    }\n-\n-    private int countDuplicateSets(final ReadsDataSource readsDataSource){\n-        int count = 0;\n-        String currentMolecularId = \"\"; // Note we are duplex aware: 12/A different from 12/B\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\");\n-            if (!molecularID.equals(currentMolecularId)){\n-                count++;\n-                currentMolecularId = molecularID;\n-            }\n-        }\n-\n-        return count;\n-    }\n-\n-    private Map<String, MutableInt> molecularIDsAndCounts(final ReadsDataSource readsDataSource){\n-        final Map<String, MutableInt> map = new TreeMap<>();\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\"); // Note we are duplex aware: 12/A different from 12/B\n-            if (map.containsKey(molecularID)){\n-                map.get(molecularID).increment();\n-            } else {\n-                map.put(molecularID, new MutableInt(0));\n-            }\n-        }\n-        return map;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNzU4NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408427585", "bodyText": "use the constant you defined", "author": "lbergelson", "createdAt": "2020-04-14T20:51:47Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", cloud)\n+                .add(\"O\", out)\n+                .add(\"DS\", \"1.0\")\n+                .add(\"keep-duplex-only\", \"true\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+    }\n+\n+    @Test\n+    public void testMatesAreTogether(){\n+        final File out = createTempFile(\"downsampled\", \"bam\");\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"O\", out.getAbsolutePath())\n+                .add(\"DS\", \"1.0\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n+        while (iterator.hasNext()){\n+            // Make sure that the read and its mate are next to each other in the file\n+            final GATKRead read1 = iterator.next();\n+            final GATKRead read2 = iterator.next();\n+            Assert.assertEquals(read1.getName(), read2.getName());\n+        }\n+    }\n+\n+    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n+    @Test\n+    public void testNoDownsampling(){\n+        final File out = createTempFile(\"downasampled\", \"bam\");\n+        final double downsampleRate = 1.0;\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"DS\", Double.toString(downsampleRate))\n+                .add(\"O\", out.getAbsolutePath());\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n+        final Map<String, MutableInt> originalMoleculeCounts = molecularIDsAndCounts(originalBam);\n+\n+        final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+        final Map<String, MutableInt> downsampledMoleculeCounts = molecularIDsAndCounts(downsampledBam);\n+\n+        for (Map.Entry<String, MutableInt> originalIDAndCount : originalMoleculeCounts.entrySet()){\n+            final String originalID = originalIDAndCount.getKey();\n+            final int originalCount = originalIDAndCount.getValue().intValue();\n+            Assert.assertTrue(originalCount == downsampledMoleculeCounts.get(originalID).intValue());\n+        }\n+    }\n+\n+    /**\n+     * Test that the downsampling rate corresponds to the reduction in the number of duplicates in the output\n+     * file up to sampling noise.\n+     */\n+    @Test\n+    public void testDownsampleFraction(){\n+        final File out = createTempFile(\"downasampled\", \"bam\");\n+        for (double downsampleRate : Arrays.asList(0.1, 0.3, 0.5)){\n+            final ArgumentsBuilder args = new ArgumentsBuilder()\n+                    .add(\"I\", NA12878_GROUPED)\n+                    .add(\"DS\", Double.toString(downsampleRate))\n+                    .add(\"O\", out.getAbsolutePath());\n+            runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+            final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n+            final int originalMoleculeCount = countDuplicateSets(originalBam);\n+\n+            final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+            final int downsampledMoleculeCount = countDuplicateSets(downsampledBam);\n+\n+            final double noise = 2.0;\n+            final double deviationFromExpected = Math.abs(downsampleRate * originalMoleculeCount - downsampledMoleculeCount);\n+            Assert.assertTrue(deviationFromExpected < noise);\n+        }\n+    }\n+\n+    private int countDuplicateSets(final ReadsDataSource readsDataSource){\n+        int count = 0;\n+        String currentMolecularId = \"\"; // Note we are duplex aware: 12/A different from 12/B\n+        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n+        while (iterator.hasNext()){\n+            final GATKRead read = iterator.next();\n+            final String molecularID = read.getAttributeAsString(\"MI\");", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NDE3Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r410464172", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-17T20:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNzU4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java b/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\ndeleted file mode 100644\nindex 23892eab6..000000000\n--- a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\n+++ /dev/null\n\n@@ -1,129 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.consensus;\n-\n-import org.apache.commons.lang3.mutable.MutableInt;\n-import org.broadinstitute.hellbender.CommandLineProgramTest;\n-import org.broadinstitute.hellbender.engine.ReadsDataSource;\n-import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.io.File;\n-import java.nio.file.Paths;\n-import java.util.*;\n-\n-public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n-    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n-\n-    @Test\n-    public void test(){\n-        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n-        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", cloud)\n-                .add(\"O\", out)\n-                .add(\"DS\", \"1.0\")\n-                .add(\"keep-duplex-only\", \"true\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-    }\n-\n-    @Test\n-    public void testMatesAreTogether(){\n-        final File out = createTempFile(\"downsampled\", \"bam\");\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"O\", out.getAbsolutePath())\n-                .add(\"DS\", \"1.0\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            // Make sure that the read and its mate are next to each other in the file\n-            final GATKRead read1 = iterator.next();\n-            final GATKRead read2 = iterator.next();\n-            Assert.assertEquals(read1.getName(), read2.getName());\n-        }\n-    }\n-\n-    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n-    @Test\n-    public void testNoDownsampling(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        final double downsampleRate = 1.0;\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"DS\", Double.toString(downsampleRate))\n-                .add(\"O\", out.getAbsolutePath());\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-        final Map<String, MutableInt> originalMoleculeCounts = molecularIDsAndCounts(originalBam);\n-\n-        final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Map<String, MutableInt> downsampledMoleculeCounts = molecularIDsAndCounts(downsampledBam);\n-\n-        for (Map.Entry<String, MutableInt> originalIDAndCount : originalMoleculeCounts.entrySet()){\n-            final String originalID = originalIDAndCount.getKey();\n-            final int originalCount = originalIDAndCount.getValue().intValue();\n-            Assert.assertTrue(originalCount == downsampledMoleculeCounts.get(originalID).intValue());\n-        }\n-    }\n-\n-    /**\n-     * Test that the downsampling rate corresponds to the reduction in the number of duplicates in the output\n-     * file up to sampling noise.\n-     */\n-    @Test\n-    public void testDownsampleFraction(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        for (double downsampleRate : Arrays.asList(0.1, 0.3, 0.5)){\n-            final ArgumentsBuilder args = new ArgumentsBuilder()\n-                    .add(\"I\", NA12878_GROUPED)\n-                    .add(\"DS\", Double.toString(downsampleRate))\n-                    .add(\"O\", out.getAbsolutePath());\n-            runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-            final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-            final int originalMoleculeCount = countDuplicateSets(originalBam);\n-\n-            final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-            final int downsampledMoleculeCount = countDuplicateSets(downsampledBam);\n-\n-            final double noise = 2.0;\n-            final double deviationFromExpected = Math.abs(downsampleRate * originalMoleculeCount - downsampledMoleculeCount);\n-            Assert.assertTrue(deviationFromExpected < noise);\n-        }\n-    }\n-\n-    private int countDuplicateSets(final ReadsDataSource readsDataSource){\n-        int count = 0;\n-        String currentMolecularId = \"\"; // Note we are duplex aware: 12/A different from 12/B\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\");\n-            if (!molecularID.equals(currentMolecularId)){\n-                count++;\n-                currentMolecularId = molecularID;\n-            }\n-        }\n-\n-        return count;\n-    }\n-\n-    private Map<String, MutableInt> molecularIDsAndCounts(final ReadsDataSource readsDataSource){\n-        final Map<String, MutableInt> map = new TreeMap<>();\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\"); // Note we are duplex aware: 12/A different from 12/B\n-            if (map.containsKey(molecularID)){\n-                map.get(molecularID).increment();\n-            } else {\n-                map.put(molecularID, new MutableInt(0));\n-            }\n-        }\n-        return map;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyODQ5Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408428496", "bodyText": "Can you add a test that shows that DS = 0.0 produces an empty file?", "author": "lbergelson", "createdAt": "2020-04-14T20:53:28Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", cloud)\n+                .add(\"O\", out)\n+                .add(\"DS\", \"1.0\")\n+                .add(\"keep-duplex-only\", \"true\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+    }\n+\n+    @Test\n+    public void testMatesAreTogether(){\n+        final File out = createTempFile(\"downsampled\", \"bam\");\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"O\", out.getAbsolutePath())\n+                .add(\"DS\", \"1.0\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n+        while (iterator.hasNext()){\n+            // Make sure that the read and its mate are next to each other in the file\n+            final GATKRead read1 = iterator.next();\n+            final GATKRead read2 = iterator.next();\n+            Assert.assertEquals(read1.getName(), read2.getName());\n+        }\n+    }\n+\n+    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n+    @Test\n+    public void testNoDownsampling(){", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java b/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\ndeleted file mode 100644\nindex 23892eab6..000000000\n--- a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\n+++ /dev/null\n\n@@ -1,129 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.consensus;\n-\n-import org.apache.commons.lang3.mutable.MutableInt;\n-import org.broadinstitute.hellbender.CommandLineProgramTest;\n-import org.broadinstitute.hellbender.engine.ReadsDataSource;\n-import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.io.File;\n-import java.nio.file.Paths;\n-import java.util.*;\n-\n-public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n-    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n-\n-    @Test\n-    public void test(){\n-        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n-        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", cloud)\n-                .add(\"O\", out)\n-                .add(\"DS\", \"1.0\")\n-                .add(\"keep-duplex-only\", \"true\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-    }\n-\n-    @Test\n-    public void testMatesAreTogether(){\n-        final File out = createTempFile(\"downsampled\", \"bam\");\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"O\", out.getAbsolutePath())\n-                .add(\"DS\", \"1.0\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            // Make sure that the read and its mate are next to each other in the file\n-            final GATKRead read1 = iterator.next();\n-            final GATKRead read2 = iterator.next();\n-            Assert.assertEquals(read1.getName(), read2.getName());\n-        }\n-    }\n-\n-    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n-    @Test\n-    public void testNoDownsampling(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        final double downsampleRate = 1.0;\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"DS\", Double.toString(downsampleRate))\n-                .add(\"O\", out.getAbsolutePath());\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-        final Map<String, MutableInt> originalMoleculeCounts = molecularIDsAndCounts(originalBam);\n-\n-        final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Map<String, MutableInt> downsampledMoleculeCounts = molecularIDsAndCounts(downsampledBam);\n-\n-        for (Map.Entry<String, MutableInt> originalIDAndCount : originalMoleculeCounts.entrySet()){\n-            final String originalID = originalIDAndCount.getKey();\n-            final int originalCount = originalIDAndCount.getValue().intValue();\n-            Assert.assertTrue(originalCount == downsampledMoleculeCounts.get(originalID).intValue());\n-        }\n-    }\n-\n-    /**\n-     * Test that the downsampling rate corresponds to the reduction in the number of duplicates in the output\n-     * file up to sampling noise.\n-     */\n-    @Test\n-    public void testDownsampleFraction(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        for (double downsampleRate : Arrays.asList(0.1, 0.3, 0.5)){\n-            final ArgumentsBuilder args = new ArgumentsBuilder()\n-                    .add(\"I\", NA12878_GROUPED)\n-                    .add(\"DS\", Double.toString(downsampleRate))\n-                    .add(\"O\", out.getAbsolutePath());\n-            runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-            final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-            final int originalMoleculeCount = countDuplicateSets(originalBam);\n-\n-            final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-            final int downsampledMoleculeCount = countDuplicateSets(downsampledBam);\n-\n-            final double noise = 2.0;\n-            final double deviationFromExpected = Math.abs(downsampleRate * originalMoleculeCount - downsampledMoleculeCount);\n-            Assert.assertTrue(deviationFromExpected < noise);\n-        }\n-    }\n-\n-    private int countDuplicateSets(final ReadsDataSource readsDataSource){\n-        int count = 0;\n-        String currentMolecularId = \"\"; // Note we are duplex aware: 12/A different from 12/B\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\");\n-            if (!molecularID.equals(currentMolecularId)){\n-                count++;\n-                currentMolecularId = molecularID;\n-            }\n-        }\n-\n-        return count;\n-    }\n-\n-    private Map<String, MutableInt> molecularIDsAndCounts(final ReadsDataSource readsDataSource){\n-        final Map<String, MutableInt> map = new TreeMap<>();\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\"); // Note we are duplex aware: 12/A different from 12/B\n-            if (map.containsKey(molecularID)){\n-                map.get(molecularID).increment();\n-            } else {\n-                map.put(molecularID, new MutableInt(0));\n-            }\n-        }\n-        return map;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMDQwNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408430405", "bodyText": "Should the doc include an example usage?", "author": "lbergelson", "createdAt": "2020-04-14T20:57:07Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc5MjcwNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r409792705", "bodyText": "Example usage added.", "author": "takutosato", "createdAt": "2020-04-16T19:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMDQwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\nindex 1be866536..ccb5d70ed 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n\n@@ -1,34 +1,33 @@\n package org.broadinstitute.hellbender.tools.walkers.consensus;\n \n-import org.apache.commons.math3.random.RandomGenerator;\n-import org.apache.commons.math3.random.RandomGeneratorFactory;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.engine.ReferenceContext;\n-import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n-import org.broadinstitute.hellbender.utils.io.IOUtils;\n import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import org.glassfish.jersey.Beta;\n import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n \n-import java.io.File;\n-import java.util.List;\n import java.util.Random;\n \n @CommandLineProgramProperties(\n-        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n         programGroup = ReadDataManipulationProgramGroup.class\n )\n /**\n- * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n- * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n  *\n- * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n  *\n- * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n  * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n  * in addition to ones common to the entire cell population.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMDUyNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408430525", "bodyText": "try-with-resources", "author": "lbergelson", "createdAt": "2020-04-14T20:57:22Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", cloud)\n+                .add(\"O\", out)\n+                .add(\"DS\", \"1.0\")\n+                .add(\"keep-duplex-only\", \"true\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+    }\n+\n+    @Test\n+    public void testMatesAreTogether(){\n+        final File out = createTempFile(\"downsampled\", \"bam\");\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"O\", out.getAbsolutePath())\n+                .add(\"DS\", \"1.0\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n+        while (iterator.hasNext()){\n+            // Make sure that the read and its mate are next to each other in the file\n+            final GATKRead read1 = iterator.next();\n+            final GATKRead read2 = iterator.next();\n+            Assert.assertEquals(read1.getName(), read2.getName());\n+        }\n+    }\n+\n+    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n+    @Test\n+    public void testNoDownsampling(){\n+        final File out = createTempFile(\"downasampled\", \"bam\");\n+        final double downsampleRate = 1.0;\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"DS\", Double.toString(downsampleRate))\n+                .add(\"O\", out.getAbsolutePath());\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n+        final Map<String, MutableInt> originalMoleculeCounts = molecularIDsAndCounts(originalBam);\n+\n+        final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+        final Map<String, MutableInt> downsampledMoleculeCounts = molecularIDsAndCounts(downsampledBam);\n+\n+        for (Map.Entry<String, MutableInt> originalIDAndCount : originalMoleculeCounts.entrySet()){\n+            final String originalID = originalIDAndCount.getKey();\n+            final int originalCount = originalIDAndCount.getValue().intValue();\n+            Assert.assertTrue(originalCount == downsampledMoleculeCounts.get(originalID).intValue());\n+        }\n+    }\n+\n+    /**\n+     * Test that the downsampling rate corresponds to the reduction in the number of duplicates in the output\n+     * file up to sampling noise.\n+     */\n+    @Test\n+    public void testDownsampleFraction(){\n+        final File out = createTempFile(\"downasampled\", \"bam\");\n+        for (double downsampleRate : Arrays.asList(0.1, 0.3, 0.5)){\n+            final ArgumentsBuilder args = new ArgumentsBuilder()\n+                    .add(\"I\", NA12878_GROUPED)\n+                    .add(\"DS\", Double.toString(downsampleRate))\n+                    .add(\"O\", out.getAbsolutePath());\n+            runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+            final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));", "originalCommit": "c14aa1527401cb1b4eaa1d545d1f966754403e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java b/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\ndeleted file mode 100644\nindex 23892eab6..000000000\n--- a/src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java\n+++ /dev/null\n\n@@ -1,129 +0,0 @@\n-package org.broadinstitute.hellbender.tools.walkers.consensus;\n-\n-import org.apache.commons.lang3.mutable.MutableInt;\n-import org.broadinstitute.hellbender.CommandLineProgramTest;\n-import org.broadinstitute.hellbender.engine.ReadsDataSource;\n-import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n-import org.broadinstitute.hellbender.utils.read.GATKRead;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.io.File;\n-import java.nio.file.Paths;\n-import java.util.*;\n-\n-public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n-    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n-\n-    @Test\n-    public void test(){\n-        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n-        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", cloud)\n-                .add(\"O\", out)\n-                .add(\"DS\", \"1.0\")\n-                .add(\"keep-duplex-only\", \"true\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-    }\n-\n-    @Test\n-    public void testMatesAreTogether(){\n-        final File out = createTempFile(\"downsampled\", \"bam\");\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"O\", out.getAbsolutePath())\n-                .add(\"DS\", \"1.0\");\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            // Make sure that the read and its mate are next to each other in the file\n-            final GATKRead read1 = iterator.next();\n-            final GATKRead read2 = iterator.next();\n-            Assert.assertEquals(read1.getName(), read2.getName());\n-        }\n-    }\n-\n-    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n-    @Test\n-    public void testNoDownsampling(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        final double downsampleRate = 1.0;\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"I\", NA12878_GROUPED)\n-                .add(\"DS\", Double.toString(downsampleRate))\n-                .add(\"O\", out.getAbsolutePath());\n-        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-        final Map<String, MutableInt> originalMoleculeCounts = molecularIDsAndCounts(originalBam);\n-\n-        final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-        final Map<String, MutableInt> downsampledMoleculeCounts = molecularIDsAndCounts(downsampledBam);\n-\n-        for (Map.Entry<String, MutableInt> originalIDAndCount : originalMoleculeCounts.entrySet()){\n-            final String originalID = originalIDAndCount.getKey();\n-            final int originalCount = originalIDAndCount.getValue().intValue();\n-            Assert.assertTrue(originalCount == downsampledMoleculeCounts.get(originalID).intValue());\n-        }\n-    }\n-\n-    /**\n-     * Test that the downsampling rate corresponds to the reduction in the number of duplicates in the output\n-     * file up to sampling noise.\n-     */\n-    @Test\n-    public void testDownsampleFraction(){\n-        final File out = createTempFile(\"downasampled\", \"bam\");\n-        for (double downsampleRate : Arrays.asList(0.1, 0.3, 0.5)){\n-            final ArgumentsBuilder args = new ArgumentsBuilder()\n-                    .add(\"I\", NA12878_GROUPED)\n-                    .add(\"DS\", Double.toString(downsampleRate))\n-                    .add(\"O\", out.getAbsolutePath());\n-            runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n-\n-            final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n-            final int originalMoleculeCount = countDuplicateSets(originalBam);\n-\n-            final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n-            final int downsampledMoleculeCount = countDuplicateSets(downsampledBam);\n-\n-            final double noise = 2.0;\n-            final double deviationFromExpected = Math.abs(downsampleRate * originalMoleculeCount - downsampledMoleculeCount);\n-            Assert.assertTrue(deviationFromExpected < noise);\n-        }\n-    }\n-\n-    private int countDuplicateSets(final ReadsDataSource readsDataSource){\n-        int count = 0;\n-        String currentMolecularId = \"\"; // Note we are duplex aware: 12/A different from 12/B\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\");\n-            if (!molecularID.equals(currentMolecularId)){\n-                count++;\n-                currentMolecularId = molecularID;\n-            }\n-        }\n-\n-        return count;\n-    }\n-\n-    private Map<String, MutableInt> molecularIDsAndCounts(final ReadsDataSource readsDataSource){\n-        final Map<String, MutableInt> map = new TreeMap<>();\n-        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n-        while (iterator.hasNext()){\n-            final GATKRead read = iterator.next();\n-            final String molecularID = read.getAttributeAsString(\"MI\"); // Note we are duplex aware: 12/A different from 12/B\n-            if (map.containsKey(molecularID)){\n-                map.get(molecularID).increment();\n-            } else {\n-                map.put(molecularID, new MutableInt(0));\n-            }\n-        }\n-        return map;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MjMyMw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413952323", "bodyText": "Wording.  This would be clearer as \"The user may choose to only keep read sets containing both strands by setting this argument to a positive number.\"\nI misread this at first as the \"read sets containing both strands will be kept ONLY if this is set to a positive number\"", "author": "lbergelson", "createdAt": "2020-04-23T16:39:22Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to keep read sets containing both strands (i.d. duplex evidence) only by setting this argument to a positive number", "originalCommit": "231aa413502db013f8d3473355e37e2a2d784c1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA2NzcyNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r414067727", "bodyText": "Ah I went back and forth about this and I clearly chose wrong. done.", "author": "takutosato", "createdAt": "2020-04-23T19:32:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MjMyMw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex fcd28d633..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -3,11 +3,17 @@ package org.broadinstitute.hellbender.engine;\n import htsjdk.samtools.SAMTag;\n import org.apache.commons.lang3.tuple.Pair;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n import org.broadinstitute.hellbender.exceptions.UserException;\n import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n /**\n  * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MjcxOA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413952718", "bodyText": "You can add a minValue = 0 here to keep it positive.", "author": "lbergelson", "createdAt": "2020-04-23T16:40:00Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to keep read sets containing both strands (i.d. duplex evidence) only by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true)", "originalCommit": "231aa413502db013f8d3473355e37e2a2d784c1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA2ODE1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r414068152", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-23T19:33:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MjcxOA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex fcd28d633..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -3,11 +3,17 @@ package org.broadinstitute.hellbender.engine;\n import htsjdk.samtools.SAMTag;\n import org.apache.commons.lang3.tuple.Pair;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n import org.broadinstitute.hellbender.exceptions.UserException;\n import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n /**\n  * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MzA4Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413953082", "bodyText": "I would add a minValue to the argument to make sure it's positive.", "author": "lbergelson", "createdAt": "2020-04-23T16:40:28Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;", "originalCommit": "231aa413502db013f8d3473355e37e2a2d784c1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA2ODE5NA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r414068194", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-23T19:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MzA4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex fcd28d633..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -3,11 +3,17 @@ package org.broadinstitute.hellbender.engine;\n import htsjdk.samtools.SAMTag;\n import org.apache.commons.lang3.tuple.Pair;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n import org.broadinstitute.hellbender.exceptions.UserException;\n import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n /**\n  * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NDQxNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413954417", "bodyText": "this comment should go on the line below, it's not about the rejection stuff", "author": "lbergelson", "createdAt": "2020-04-23T16:42:17Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to keep read sets containing both strands (i.d. duplex evidence) only by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecule ID, at which point we pass the list to the {@code apply} method,\n+     * process the set based on the child class's implementation of the method, and clear the {@code currentDuplicateSet} variable and start collecting reads again.\n+     *\n+     * Notice there are two apply() methods in this class:\n+     * This apply() inherited from ReadWalker is marked final to discourage subclassing.\n+     * A subclass must override the other apply() method that takes in the DuplicateSet.\n+     */\n+    @Override\n+    public final void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentReadsWithSameUMI == null){ // evaluates to true for the very first read\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        final int readMoleculeNumber = MoleculeID.getMoleculeNumberOfRead(read);\n+        final int duplicateSetMoleculeNumber = currentReadsWithSameUMI.getMoleculeNumber();\n+\n+        // If the incoming read has the molecule id less than that of the currentDuplicateSet,\n+        // the input bam is not sorted properly by the MI tag\n+        if (duplicateSetMoleculeNumber > readMoleculeNumber){\n+            throw new UserException(String.format(\"The input bam must be sorted by the molecule ID (%s) tag.\", SAMTag.MI.name()));\n+        }\n+\n+        if (duplicateSetMoleculeNumber < readMoleculeNumber) {\n+            // The incoming read's molecule ID does not match that of the current duplicate, meaning we've reached the end of the current set.\n+            // Call the apply() method to process the current set and start a new set.", "originalCommit": "231aa413502db013f8d3473355e37e2a2d784c1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3MDAxOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r414070019", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-23T19:36:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NDQxNw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex fcd28d633..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -3,11 +3,17 @@ package org.broadinstitute.hellbender.engine;\n import htsjdk.samtools.SAMTag;\n import org.apache.commons.lang3.tuple.Pair;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n import org.broadinstitute.hellbender.exceptions.UserException;\n import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n /**\n  * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NTI1OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413955258", "bodyText": "I like to put the exclusive conditions in an else block to make it clear that none of the options above fall down into this, but that's a style point that some people disagree with.", "author": "lbergelson", "createdAt": "2020-04-23T16:43:31Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to keep read sets containing both strands (i.d. duplex evidence) only by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecule ID, at which point we pass the list to the {@code apply} method,\n+     * process the set based on the child class's implementation of the method, and clear the {@code currentDuplicateSet} variable and start collecting reads again.\n+     *\n+     * Notice there are two apply() methods in this class:\n+     * This apply() inherited from ReadWalker is marked final to discourage subclassing.\n+     * A subclass must override the other apply() method that takes in the DuplicateSet.\n+     */\n+    @Override\n+    public final void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentReadsWithSameUMI == null){ // evaluates to true for the very first read\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        final int readMoleculeNumber = MoleculeID.getMoleculeNumberOfRead(read);\n+        final int duplicateSetMoleculeNumber = currentReadsWithSameUMI.getMoleculeNumber();\n+\n+        // If the incoming read has the molecule id less than that of the currentDuplicateSet,\n+        // the input bam is not sorted properly by the MI tag\n+        if (duplicateSetMoleculeNumber > readMoleculeNumber){\n+            throw new UserException(String.format(\"The input bam must be sorted by the molecule ID (%s) tag.\", SAMTag.MI.name()));\n+        }\n+\n+        if (duplicateSetMoleculeNumber < readMoleculeNumber) {\n+            // The incoming read's molecule ID does not match that of the current duplicate, meaning we've reached the end of the current set.\n+            // Call the apply() method to process the current set and start a new set.\n+            if (rejectSet(currentReadsWithSameUMI)){\n+                currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+                return;\n+            }\n+\n+            apply(currentReadsWithSameUMI,\n+                    new ReferenceContext(reference, currentReadsWithSameUMI.getInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentReadsWithSameUMI.getInterval()));\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        // The incoming read has the same UMI as the current set; simply add to the current set", "originalCommit": "231aa413502db013f8d3473355e37e2a2d784c1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3MzQzMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r414073431", "bodyText": "Yea I didn't like the way the if else blocks looked so I did it this way, hope that's ok.", "author": "takutosato", "createdAt": "2020-04-23T19:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NTI1OA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex fcd28d633..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -3,11 +3,17 @@ package org.broadinstitute.hellbender.engine;\n import htsjdk.samtools.SAMTag;\n import org.apache.commons.lang3.tuple.Pair;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n import org.broadinstitute.hellbender.exceptions.UserException;\n import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n /**\n  * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NTc2Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413955762", "bodyText": "Is there a todo to make this smarter in the future or is % a good enough check?", "author": "lbergelson", "createdAt": "2020-04-23T16:44:16Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to keep read sets containing both strands (i.d. duplex evidence) only by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecule ID, at which point we pass the list to the {@code apply} method,\n+     * process the set based on the child class's implementation of the method, and clear the {@code currentDuplicateSet} variable and start collecting reads again.\n+     *\n+     * Notice there are two apply() methods in this class:\n+     * This apply() inherited from ReadWalker is marked final to discourage subclassing.\n+     * A subclass must override the other apply() method that takes in the DuplicateSet.\n+     */\n+    @Override\n+    public final void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentReadsWithSameUMI == null){ // evaluates to true for the very first read\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        final int readMoleculeNumber = MoleculeID.getMoleculeNumberOfRead(read);\n+        final int duplicateSetMoleculeNumber = currentReadsWithSameUMI.getMoleculeNumber();\n+\n+        // If the incoming read has the molecule id less than that of the currentDuplicateSet,\n+        // the input bam is not sorted properly by the MI tag\n+        if (duplicateSetMoleculeNumber > readMoleculeNumber){\n+            throw new UserException(String.format(\"The input bam must be sorted by the molecule ID (%s) tag.\", SAMTag.MI.name()));\n+        }\n+\n+        if (duplicateSetMoleculeNumber < readMoleculeNumber) {\n+            // The incoming read's molecule ID does not match that of the current duplicate, meaning we've reached the end of the current set.\n+            // Call the apply() method to process the current set and start a new set.\n+            if (rejectSet(currentReadsWithSameUMI)){\n+                currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+                return;\n+            }\n+\n+            apply(currentReadsWithSameUMI,\n+                    new ReferenceContext(reference, currentReadsWithSameUMI.getInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentReadsWithSameUMI.getInterval()));\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        // The incoming read has the same UMI as the current set; simply add to the current set\n+        currentReadsWithSameUMI.addRead(read);\n+    }\n+\n+    /**\n+     * A subclass must specify how to process the duplicate sets by overriding this method.\n+     *\n+     * @param readsWithSameUMI A set of reads with the matching UMIs with the same fragment start and end\n+     * @param referenceContext A reference context object over the intervals determined by the duplicate set.\n+     * @param featureContext Entries from a secondary feature file (e.g. vcf) if provided\n+     *\n+     */\n+    public abstract void apply(ReadsWithSameUMI readsWithSameUMI, ReferenceContext referenceContext, FeatureContext featureContext );\n+\n+\n+    /**\n+     * Returns true for duplicate sets that does not meet required criteria for further processing.\n+     * We encourage the user to override this method to meet their needs.\n+     */\n+    protected boolean rejectSet(final ReadsWithSameUMI readsWithSameUMI){\n+        // Check that the set contains the minimum required number of reads in each strand\n+        final Pair<Integer, Integer> strandCounts = MoleculeID.countStrands(readsWithSameUMI.getReads());\n+        if (Math.min(strandCounts.getLeft(), strandCounts.getRight()) < minimumRequiredReadsPerStrand){\n+            return true;\n+        }\n+\n+        // Check that the read set is paired (this check may not reject some sets that contain unpaired reads)", "originalCommit": "231aa413502db013f8d3473355e37e2a2d784c1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3NDkyNA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r414074924", "bodyText": "I think this is good enough for now", "author": "takutosato", "createdAt": "2020-04-23T19:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NTc2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex fcd28d633..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -3,11 +3,17 @@ package org.broadinstitute.hellbender.engine;\n import htsjdk.samtools.SAMTag;\n import org.apache.commons.lang3.tuple.Pair;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n import org.broadinstitute.hellbender.exceptions.UserException;\n import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n /**\n  * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjczOA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413956738", "bodyText": "This is a bit inconsistent with the rest of the framework.  Lets consider changing this in a future refactor.", "author": "lbergelson", "createdAt": "2020-04-23T16:45:39Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to keep read sets containing both strands (i.d. duplex evidence) only by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecule ID, at which point we pass the list to the {@code apply} method,\n+     * process the set based on the child class's implementation of the method, and clear the {@code currentDuplicateSet} variable and start collecting reads again.\n+     *\n+     * Notice there are two apply() methods in this class:\n+     * This apply() inherited from ReadWalker is marked final to discourage subclassing.\n+     * A subclass must override the other apply() method that takes in the DuplicateSet.\n+     */\n+    @Override\n+    public final void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentReadsWithSameUMI == null){ // evaluates to true for the very first read\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        final int readMoleculeNumber = MoleculeID.getMoleculeNumberOfRead(read);\n+        final int duplicateSetMoleculeNumber = currentReadsWithSameUMI.getMoleculeNumber();\n+\n+        // If the incoming read has the molecule id less than that of the currentDuplicateSet,\n+        // the input bam is not sorted properly by the MI tag\n+        if (duplicateSetMoleculeNumber > readMoleculeNumber){\n+            throw new UserException(String.format(\"The input bam must be sorted by the molecule ID (%s) tag.\", SAMTag.MI.name()));\n+        }\n+\n+        if (duplicateSetMoleculeNumber < readMoleculeNumber) {\n+            // The incoming read's molecule ID does not match that of the current duplicate, meaning we've reached the end of the current set.\n+            // Call the apply() method to process the current set and start a new set.\n+            if (rejectSet(currentReadsWithSameUMI)){\n+                currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+                return;\n+            }\n+\n+            apply(currentReadsWithSameUMI,\n+                    new ReferenceContext(reference, currentReadsWithSameUMI.getInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentReadsWithSameUMI.getInterval()));\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        // The incoming read has the same UMI as the current set; simply add to the current set\n+        currentReadsWithSameUMI.addRead(read);\n+    }\n+\n+    /**\n+     * A subclass must specify how to process the duplicate sets by overriding this method.\n+     *\n+     * @param readsWithSameUMI A set of reads with the matching UMIs with the same fragment start and end\n+     * @param referenceContext A reference context object over the intervals determined by the duplicate set.\n+     * @param featureContext Entries from a secondary feature file (e.g. vcf) if provided\n+     *\n+     */\n+    public abstract void apply(ReadsWithSameUMI readsWithSameUMI, ReferenceContext referenceContext, FeatureContext featureContext );\n+\n+    /**\n+     * A child tool class that override onTraversalSuccess() *must* call super.onTraversalSuccess() in order", "originalCommit": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3NTIxNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r414075217", "bodyText": "Refactor done", "author": "takutosato", "createdAt": "2020-04-23T19:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjczOA=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\nindex 424f25c1f..152bd6876 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java\n\n@@ -3,11 +3,17 @@ package org.broadinstitute.hellbender.engine;\n import htsjdk.samtools.SAMTag;\n import org.apache.commons.lang3.tuple.Pair;\n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.engine.filters.WellformedReadFilter;\n import org.broadinstitute.hellbender.exceptions.UserException;\n import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n import org.broadinstitute.hellbender.utils.read.GATKRead;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n /**\n  * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NzIyNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413957227", "bodyText": "Some pointless leftover whitespace changes.", "author": "lbergelson", "createdAt": "2020-04-23T16:46:20Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -99,7 +99,6 @@ public void traverse() {\n \n                     progressMeter.update(readInterval);\n                 });\n-\n         logger.info(countedFilter.getSummaryLine());\n     }", "originalCommit": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3NTcyNA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r414075724", "bodyText": "boy scout rule done", "author": "takutosato", "createdAt": "2020-04-23T19:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NzIyNw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java b/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\nindex 16331e1c2..e3d6c52fd 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java\n\n@@ -99,6 +99,7 @@ public abstract class ReadWalker extends WalkerBase {\n \n                     progressMeter.update(readInterval);\n                 });\n+\n         logger.info(countedFilter.getSummaryLine());\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1ODEwOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413958109", "bodyText": "I would just initialize this where you declare rng and make the variable final.", "author": "lbergelson", "createdAt": "2020-04-23T16:47:36Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n+ *\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n+ *\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the reads from the above\n+ * 5% of the cell population moves near the top of the flowcell. This population must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this population with 5% ramdonly chosen from the *entire* flowcell of another sample that was prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool will help address the above problem by dropping a set fraction of _molecules_, or duplicate sets, rather than reads, at random.\n+ *\n+ * Example Usage:\n+ *\n+ * Keep 95 percent of the molecules.\n+ *\n+ * gatk DownsampleByDuplicateSet \\ \\\n+ * -I umiGrouped.bam \\\n+ * --fraction-to-keep 0.95 \\\n+ * -O umiGrouped_0.95.bam\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public GATKPathSpecifier outputBam;\n+\n+    public static final String FRACTION_TO_KEEP_NAME = \"fraction-to-keep\";\n+    @Argument(fullName = FRACTION_TO_KEEP_NAME, doc = \"This fraction of molecules in the input bam will be retained\", minValue = 0.0, maxValue = 1.0)\n+    public double fractionToKeep;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private Random rng;\n+    private int numDuplicateReadSets;\n+    private int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        rng = new Random(RANDOM_SEED);", "originalCommit": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3NjE4NA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r414076184", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-23T19:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1ODEwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\nindex d6ab145b6..ccb5d70ed 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java\n\n@@ -1,13 +1,16 @@\n package org.broadinstitute.hellbender.tools.walkers.consensus;\n \n import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n import org.broadinstitute.hellbender.engine.FeatureContext;\n import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.engine.ReferenceContext;\n import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import org.glassfish.jersey.Beta;\n import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n \n import java.util.Random;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1OTEwNg==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413959106", "bodyText": "These should probably have javadoc too even though they're pretty self explanatory.", "author": "lbergelson", "createdAt": "2020-04-23T16:49:04Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/MoleculeID.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+\n+/**\n+ * A container class for the molecule ID, which consists of an integer ID and a binary strand.\n+ * For example, Reads with the tags 12/A and 12/B originated from the same DNA fragment before PCR,\n+ * (i.e. from the same library) but they originated from different strands in that library.\n+ * In other words, one read is F1R2 and the other F2R1.\n+ *\n+ * The word \"molecule\" here refers to the original DNA fragment with barcode before undergoing\n+ * PCR and sequencing. We amplify this molecule through PCR and end up with many duplicate _fragments_.\n+ */\n+public class MoleculeID {\n+    private int moleculeNumber;\n+    private String strand;\n+\n+    public MoleculeID(final GATKRead read){\n+        this.moleculeNumber = getMoleculeNumberOfRead(read);\n+        this.strand = getStrandOfRead(read);\n+    }\n+\n+    public MoleculeID(final int moleculeNumber, final String strand){\n+        this.moleculeNumber = moleculeNumber;\n+        this.strand = strand;\n+    }\n+\n+    public int getMoleculeNumber() {\n+        return moleculeNumber;\n+    }\n+\n+    public String getStrand() {\n+        return strand;\n+    }\n+\n+    /** Format the molecule ID as stored in the sam/bam/cram file under the {@link SAMTag.MI} tag **/\n+    public String getSAMField(){\n+        return moleculeNumber + ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER + strand;\n+    }\n+\n+    public static int getMoleculeNumberOfRead(final GATKRead read){", "originalCommit": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA4MTI5Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r414081297", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-23T19:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1OTEwNg=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/MoleculeID.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/MoleculeID.java\nindex 42c851a83..6d2701676 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/MoleculeID.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/MoleculeID.java\n\n@@ -43,11 +43,13 @@ public class MoleculeID {\n         return moleculeNumber + ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER + strand;\n     }\n \n+    /** Extracts the molecule number portion of the {@link SAMTag.MI} field of the read **/\n     public static int getMoleculeNumberOfRead(final GATKRead read){\n         final String MITag = read.getAttributeAsString(SAMTag.MI.name());\n         return Integer.parseInt(MITag.split(ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER)[0]);\n     }\n \n+    /** Extracts the strand portion of the {@link SAMTag.MI} field of the read **/\n     public static String getStrandOfRead(final GATKRead read){\n         final String MITag = read.getAttributeAsString(SAMTag.MI.name());\n         return MITag.split(ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER)[1];\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2MTE1OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413961159", "bodyText": "There's definitely a more efficient way of doing this that only loops through once but this is fine.", "author": "lbergelson", "createdAt": "2020-04-23T16:51:53Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/MoleculeID.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+\n+/**\n+ * A container class for the molecule ID, which consists of an integer ID and a binary strand.\n+ * For example, Reads with the tags 12/A and 12/B originated from the same DNA fragment before PCR,\n+ * (i.e. from the same library) but they originated from different strands in that library.\n+ * In other words, one read is F1R2 and the other F2R1.\n+ *\n+ * The word \"molecule\" here refers to the original DNA fragment with barcode before undergoing\n+ * PCR and sequencing. We amplify this molecule through PCR and end up with many duplicate _fragments_.\n+ */\n+public class MoleculeID {\n+    private int moleculeNumber;\n+    private String strand;\n+\n+    public MoleculeID(final GATKRead read){\n+        this.moleculeNumber = getMoleculeNumberOfRead(read);\n+        this.strand = getStrandOfRead(read);\n+    }\n+\n+    public MoleculeID(final int moleculeNumber, final String strand){\n+        this.moleculeNumber = moleculeNumber;\n+        this.strand = strand;\n+    }\n+\n+    public int getMoleculeNumber() {\n+        return moleculeNumber;\n+    }\n+\n+    public String getStrand() {\n+        return strand;\n+    }\n+\n+    /** Format the molecule ID as stored in the sam/bam/cram file under the {@link SAMTag.MI} tag **/\n+    public String getSAMField(){\n+        return moleculeNumber + ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER + strand;\n+    }\n+\n+    public static int getMoleculeNumberOfRead(final GATKRead read){\n+        final String MITag = read.getAttributeAsString(SAMTag.MI.name());\n+        return Integer.parseInt(MITag.split(ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    public static String getStrandOfRead(final GATKRead read){\n+        final String MITag = read.getAttributeAsString(SAMTag.MI.name());\n+        return MITag.split(ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER)[1];\n+    }\n+\n+    /**\n+     * Assumes that the input reads have the same molecule number in the {@link SAMTag.MI} tag\n+     * @returns Counts of reads from each strand, the first element is always larger than the second\n+     **/\n+    public static Pair<Integer, Integer> countStrands(final List<GATKRead> reads){\n+        final int strandACount = (int) reads.stream().filter(r -> getStrandOfRead(r).equals(\"A\")).count();", "originalCommit": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/MoleculeID.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/MoleculeID.java\nindex 42c851a83..6d2701676 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/MoleculeID.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/MoleculeID.java\n\n@@ -43,11 +43,13 @@ public class MoleculeID {\n         return moleculeNumber + ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER + strand;\n     }\n \n+    /** Extracts the molecule number portion of the {@link SAMTag.MI} field of the read **/\n     public static int getMoleculeNumberOfRead(final GATKRead read){\n         final String MITag = read.getAttributeAsString(SAMTag.MI.name());\n         return Integer.parseInt(MITag.split(ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER)[0]);\n     }\n \n+    /** Extracts the strand portion of the {@link SAMTag.MI} field of the read **/\n     public static String getStrandOfRead(final GATKRead read){\n         final String MITag = read.getAttributeAsString(SAMTag.MI.name());\n         return MITag.split(ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER)[1];\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2NDAxOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413964019", "bodyText": "There's a interval.contigsMatch(read) method that makes this slightly less verbose (and could be implemented slightly more efficiently than getContig.equals(getContig) in some cases.", "author": "lbergelson", "createdAt": "2020-04-23T16:55:59Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/ReadsWithSameUMI.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import htsjdk.samtools.SAMTag;\n+import htsjdk.samtools.util.Locatable;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A container class for a set of reads that share the same unique molecular identifier (UMI) as judged by\n+ * FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html)\n+ *\n+ * Examples of molecule IDs (MI tag):\n+ *\n+ * \"0/A\" (The first molecule in the bam, A strand)\n+ * \"0/B\" (The first molecule in the bam, B strand)\n+ * \"99/A\" (100th molecule in the bam, A strand)\n+ *\n+ * For a given set of reads with the same molecule number, the strand with a larger number of reads is defined as the A strand.\n+ * i.e. A and B strand doesn't map to top or bottom strand.\n+ *\n+ * I use \"top strand\" as a synonym for \"F1R2\". \"Bottom strand\" is synonymous to \"F2R1.\"\n+ *\n+ * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+ * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+ *\n+ * All reads in the set must share the same molecular number; this allows for reads that originated from the same fragment before PCR\n+ * but from the different strands to be grouped in the same set.\n+ * For instance, 1/A and 1/B may be in the same set, as they share the same UMI.\n+ * But 2/A and 3/A may not be in the same set.\n+ */\n+public class ReadsWithSameUMI implements Locatable {\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    public MoleculeID moleculeID;\n+\n+    private SimpleInterval interval;\n+\n+    private List<GATKRead> reads;\n+\n+    public ReadsWithSameUMI(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+    }\n+\n+    private void init(GATKRead read){\n+        Utils.validate(reads.isEmpty(), String.format(\"Initializing a non-empty set\"));\n+        moleculeID = new MoleculeID(read);\n+        interval = new SimpleInterval(read.getContig(), read.getStart(), read.getEnd());\n+        reads.add(read);\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return Collections.unmodifiableList(reads);\n+    }\n+\n+    /**\n+     * Add a read to the set. Throws an error if the molecule ID doens't match.\n+     * **/\n+    public void addRead(final GATKRead read){\n+        Utils.validate(reads.isEmpty() || moleculeID.getMoleculeNumber() == MoleculeID.getMoleculeNumberOfRead(read),\n+                String.format(\"Molecule number of the set and that of the new read don't match: set number = %d, read number = %d\", moleculeID.getMoleculeNumber(), MoleculeID.getMoleculeNumberOfRead(read)));\n+        Utils.validate(interval.getContig().equals(read.getContig()),", "originalCommit": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3OTkyNw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r414079927", "bodyText": "done", "author": "takutosato", "createdAt": "2020-04-23T19:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2NDAxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/ReadsWithSameUMI.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/ReadsWithSameUMI.java\nindex c86b619d8..0ee31c947 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/ReadsWithSameUMI.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/ReadsWithSameUMI.java\n\n@@ -50,7 +50,7 @@ public class ReadsWithSameUMI implements Locatable {\n     private void init(GATKRead read){\n         Utils.validate(reads.isEmpty(), String.format(\"Initializing a non-empty set\"));\n         moleculeID = new MoleculeID(read);\n-        interval = new SimpleInterval(read.getContig(), read.getStart(), read.getEnd());\n+        interval = new SimpleInterval(read);\n         reads.add(read);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2NDk4Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413964987", "bodyText": "I think you can just write this as new SimpleInterval(read)", "author": "lbergelson", "createdAt": "2020-04-23T16:57:14Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/ReadsWithSameUMI.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import htsjdk.samtools.SAMTag;\n+import htsjdk.samtools.util.Locatable;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A container class for a set of reads that share the same unique molecular identifier (UMI) as judged by\n+ * FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html)\n+ *\n+ * Examples of molecule IDs (MI tag):\n+ *\n+ * \"0/A\" (The first molecule in the bam, A strand)\n+ * \"0/B\" (The first molecule in the bam, B strand)\n+ * \"99/A\" (100th molecule in the bam, A strand)\n+ *\n+ * For a given set of reads with the same molecule number, the strand with a larger number of reads is defined as the A strand.\n+ * i.e. A and B strand doesn't map to top or bottom strand.\n+ *\n+ * I use \"top strand\" as a synonym for \"F1R2\". \"Bottom strand\" is synonymous to \"F2R1.\"\n+ *\n+ * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+ * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+ *\n+ * All reads in the set must share the same molecular number; this allows for reads that originated from the same fragment before PCR\n+ * but from the different strands to be grouped in the same set.\n+ * For instance, 1/A and 1/B may be in the same set, as they share the same UMI.\n+ * But 2/A and 3/A may not be in the same set.\n+ */\n+public class ReadsWithSameUMI implements Locatable {\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    public MoleculeID moleculeID;\n+\n+    private SimpleInterval interval;\n+\n+    private List<GATKRead> reads;\n+\n+    public ReadsWithSameUMI(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+    }\n+\n+    private void init(GATKRead read){\n+        Utils.validate(reads.isEmpty(), String.format(\"Initializing a non-empty set\"));\n+        moleculeID = new MoleculeID(read);\n+        interval = new SimpleInterval(read.getContig(), read.getStart(), read.getEnd());", "originalCommit": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3OTI4OA==", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r414079288", "bodyText": "beautiful", "author": "takutosato", "createdAt": "2020-04-23T19:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2NDk4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/ReadsWithSameUMI.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/ReadsWithSameUMI.java\nindex c86b619d8..0ee31c947 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/ReadsWithSameUMI.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/ReadsWithSameUMI.java\n\n@@ -50,7 +50,7 @@ public class ReadsWithSameUMI implements Locatable {\n     private void init(GATKRead read){\n         Utils.validate(reads.isEmpty(), String.format(\"Initializing a non-empty set\"));\n         moleculeID = new MoleculeID(read);\n-        interval = new SimpleInterval(read.getContig(), read.getStart(), read.getEnd());\n+        interval = new SimpleInterval(read);\n         reads.add(read);\n     }\n \n"}}, {"oid": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "url": "https://github.com/broadinstitute/gatk/commit/44557b96b5c930b9afe281b4f1d626ae4fac14cf", "message": "A new tool to randomly sample a fraction of an input bam sorted by UMI.", "committedDate": "2020-04-23T20:26:53Z", "type": "commit"}, {"oid": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "url": "https://github.com/broadinstitute/gatk/commit/44557b96b5c930b9afe281b4f1d626ae4fac14cf", "message": "A new tool to randomly sample a fraction of an input bam sorted by UMI.", "committedDate": "2020-04-23T20:26:53Z", "type": "forcePushed"}]}