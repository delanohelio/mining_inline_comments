{"pr_number": 6973, "pr_title": "Switch VariantEval to MultiVariantWalkerGroupedOnStart", "pr_createdAt": "2020-11-19T20:42:34Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6973", "timeline": [{"oid": "a4433f3d7b779a94137b190d309a7a66cd507d1a", "url": "https://github.com/broadinstitute/gatk/commit/a4433f3d7b779a94137b190d309a7a66cd507d1a", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nAdditional removal of reference to walker\n\nFixes NPE and adds debugging code\n\nIdentify behavior difference between MultiVariantWalkerGroupedOnStart as compared to the old behavior of setting up a whitelist of start sites and then re-querying variants based on those sites.\n\n- Remove debugging code\n- Since MultiVariantWalkerGroupedOnStart requires a reference, make VariantEval require a reference and remove tests related to failing without one\n\nUpdate test expectations related to comp overlaps\n\nUpdate test expectations: this test was switch from using a truncated genome to the full genome, since the input data includes variants on other chromosomes. The previous code probably should have errored", "committedDate": "2020-12-04T21:58:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4Mjg3Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547282873", "bodyText": "This is somewhat more idiomatic, and only creates ArrayLists when they're needed:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Map<FeatureInput<VariantContext>, List<VariantContext>> ret = new HashMap<>();\n          \n          \n            \n                    variants.forEach(vc -> {\n          \n          \n            \n                        FeatureInput<VariantContext> fi = sourceMap.get(vc.getSource());\n          \n          \n            \n                        if (fi == null) {\n          \n          \n            \n                            throw new GATKException.ShouldNeverReachHereException(\"Variant could not be mapped to a source: \" + vc);\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                        List<VariantContext> l = ret.getOrDefault(fi, new ArrayList<>());\n          \n          \n            \n                        l.add(vc);\n          \n          \n            \n                        ret.put(fi, l);\n          \n          \n            \n                    });\n          \n          \n            \n            \n          \n          \n            \n                    return ret;\n          \n          \n            \n                    final Map<FeatureInput<VariantContext>, List<VariantContext>> byFeatureInput = new HashMap<>();\n          \n          \n            \n                    variants.forEach(vc -> byFeatureInput.compute(sourceMap.get(vc.getSource()),\n          \n          \n            \n                            (k, v) -> {\n          \n          \n            \n                                final List<VariantContext> variantList = v == null ? new ArrayList<>() : v;\n          \n          \n            \n                                variantList.add(vc);\n          \n          \n            \n                                return variantList;\n          \n          \n            \n                            }\n          \n          \n            \n                        ));\n          \n          \n            \n            \n          \n          \n            \n                    return byFeatureInput;", "author": "cmnbroad", "createdAt": "2020-12-22T13:39:36Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java", "diffHunk": "@@ -114,6 +116,25 @@ public final void apply(VariantContext variant, ReadsContext readsContext, Refer\n         lastCurrentVariantStart = variant.getStart();\n     }\n \n+    protected Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(List<VariantContext> variants) {\n+        Map<String, FeatureInput<VariantContext>> sourceMap = new HashMap<>();\n+        getDrivingVariantsFeatureInputs().forEach(x -> sourceMap.put(x.getName(), x));\n+\n+        Map<FeatureInput<VariantContext>, List<VariantContext>> ret = new HashMap<>();\n+        variants.forEach(vc -> {\n+            FeatureInput<VariantContext> fi = sourceMap.get(vc.getSource());\n+            if (fi == null) {\n+                throw new GATKException.ShouldNeverReachHereException(\"Variant could not be mapped to a source: \" + vc);\n+            }\n+\n+            List<VariantContext> l = ret.getOrDefault(fi, new ArrayList<>());\n+            l.add(vc);\n+            ret.put(fi, l);\n+        });\n+\n+        return ret;", "originalCommit": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMzI0MA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547533240", "bodyText": "ok", "author": "bbimber", "createdAt": "2020-12-22T22:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4Mjg3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java b/src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java\nindex 68a1957c3..eaff95b71 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java\n\n@@ -116,25 +116,6 @@ public abstract class MultiVariantWalkerGroupedOnStart extends MultiVariantWalke\n         lastCurrentVariantStart = variant.getStart();\n     }\n \n-    protected Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(List<VariantContext> variants) {\n-        Map<String, FeatureInput<VariantContext>> sourceMap = new HashMap<>();\n-        getDrivingVariantsFeatureInputs().forEach(x -> sourceMap.put(x.getName(), x));\n-\n-        Map<FeatureInput<VariantContext>, List<VariantContext>> ret = new HashMap<>();\n-        variants.forEach(vc -> {\n-            FeatureInput<VariantContext> fi = sourceMap.get(vc.getSource());\n-            if (fi == null) {\n-                throw new GATKException.ShouldNeverReachHereException(\"Variant could not be mapped to a source: \" + vc);\n-            }\n-\n-            List<VariantContext> l = ret.getOrDefault(fi, new ArrayList<>());\n-            l.add(vc);\n-            ret.put(fi, l);\n-        });\n-\n-        return ret;\n-    }\n-\n     /**\n      * This method must be implemented by tool authors.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4NDE5Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547284197", "bodyText": "variants param should be final", "author": "cmnbroad", "createdAt": "2020-12-22T13:42:25Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java", "diffHunk": "@@ -114,6 +116,25 @@ public final void apply(VariantContext variant, ReadsContext readsContext, Refer\n         lastCurrentVariantStart = variant.getStart();\n     }\n \n+    protected Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(List<VariantContext> variants) {", "originalCommit": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4NDI0OA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547284248", "bodyText": "This (return) type should be replaced with a class that can be used in its place. If as you indicated in your comments you can't do that for some reason, then this method should be pushed down as private into VariantEval so it doesn't proliferate as part of MultiVariantWalkerGroupedOnStart.", "author": "cmnbroad", "createdAt": "2020-12-22T13:42:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4NDE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzNjgzNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547536835", "bodyText": "I'll move to VariantEval", "author": "bbimber", "createdAt": "2020-12-22T22:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4NDE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java b/src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java\nindex 68a1957c3..eaff95b71 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java\n\n@@ -116,25 +116,6 @@ public abstract class MultiVariantWalkerGroupedOnStart extends MultiVariantWalke\n         lastCurrentVariantStart = variant.getStart();\n     }\n \n-    protected Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(List<VariantContext> variants) {\n-        Map<String, FeatureInput<VariantContext>> sourceMap = new HashMap<>();\n-        getDrivingVariantsFeatureInputs().forEach(x -> sourceMap.put(x.getName(), x));\n-\n-        Map<FeatureInput<VariantContext>, List<VariantContext>> ret = new HashMap<>();\n-        variants.forEach(vc -> {\n-            FeatureInput<VariantContext> fi = sourceMap.get(vc.getSource());\n-            if (fi == null) {\n-                throw new GATKException.ShouldNeverReachHereException(\"Variant could not be mapped to a source: \" + vc);\n-            }\n-\n-            List<VariantContext> l = ret.getOrDefault(fi, new ArrayList<>());\n-            l.add(vc);\n-            ret.put(fi, l);\n-        });\n-\n-        return ret;\n-    }\n-\n     /**\n      * This method must be implemented by tool authors.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4NTk5OA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547285998", "bodyText": "This map should be precomputed once on start, and cached.", "author": "cmnbroad", "createdAt": "2020-12-22T13:46:08Z", "path": "src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java", "diffHunk": "@@ -114,6 +116,25 @@ public final void apply(VariantContext variant, ReadsContext readsContext, Refer\n         lastCurrentVariantStart = variant.getStart();\n     }\n \n+    protected Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(List<VariantContext> variants) {\n+        Map<String, FeatureInput<VariantContext>> sourceMap = new HashMap<>();\n+        getDrivingVariantsFeatureInputs().forEach(x -> sourceMap.put(x.getName(), x));", "originalCommit": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzODA2OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547538069", "bodyText": "ok", "author": "bbimber", "createdAt": "2020-12-22T22:29:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4NTk5OA=="}], "type": "inlineReview", "revised_code": {"commit": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java b/src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java\nindex 68a1957c3..eaff95b71 100644\n--- a/src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java\n+++ b/src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java\n\n@@ -116,25 +116,6 @@ public abstract class MultiVariantWalkerGroupedOnStart extends MultiVariantWalke\n         lastCurrentVariantStart = variant.getStart();\n     }\n \n-    protected Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(List<VariantContext> variants) {\n-        Map<String, FeatureInput<VariantContext>> sourceMap = new HashMap<>();\n-        getDrivingVariantsFeatureInputs().forEach(x -> sourceMap.put(x.getName(), x));\n-\n-        Map<FeatureInput<VariantContext>, List<VariantContext>> ret = new HashMap<>();\n-        variants.forEach(vc -> {\n-            FeatureInput<VariantContext> fi = sourceMap.get(vc.getSource());\n-            if (fi == null) {\n-                throw new GATKException.ShouldNeverReachHereException(\"Variant could not be mapped to a source: \" + vc);\n-            }\n-\n-            List<VariantContext> l = ret.getOrDefault(fi, new ArrayList<>());\n-            l.add(vc);\n-            ret.put(fi, l);\n-        });\n-\n-        return ret;\n-    }\n-\n     /**\n      * This method must be implemented by tool authors.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzMTIyMg==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547331222", "bodyText": "Argument collection classes are intended to be standalone containers for argument declarations that can be used in other tools/contexts. These tool inputs (evals, comps, goldStandard, knowns) depend on code in VariantEval that prevents them from being treated as driving variants. Is moving these into the arg collection, necessary or can that be deferred to a subsequent PR when we have an VariantEvalEngine class ?", "author": "cmnbroad", "createdAt": "2020-12-22T15:10:22Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -126,125 +123,27 @@\n )\n @DocumentedFeature\n @BetaFeature\n-public class VariantEval extends MultiVariantWalker {\n+public class VariantEval extends MultiVariantWalkerGroupedOnStart {\n     public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n \n     @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n             shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n             doc=\"File to which variants should be written\")\n     protected File outFile;\n \n-    /**\n-     * The variant file(s) to evaluate.\n-     */\n-    @Argument(fullName=\"eval\", shortName = \"eval\", doc=\"Input evaluation file(s)\", optional=false)\n-    public List<FeatureInput<VariantContext>> evals;", "originalCommit": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU2NTIxNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547565215", "bodyText": "Yes - this was trying to make a compromise and move toward the goal of creating the standalone VariantEvalEngine.\nWhat about letting the ArgumentCollection encapsulate some of logic around creating DrivingVariants? In theory one might want different walkers based around this, and it would be helpful to have one piece of code that does that? Or do you think the better pattern is to make the VariantEvalEngine class that takes the ArgumentCollection in the constructor, and then perhaps that provides methods to set up DrivingVariants?", "author": "bbimber", "createdAt": "2020-12-23T00:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzMTIyMg=="}], "type": "inlineReview", "revised_code": {"commit": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\nindex 0db5f4b1e..28780906a 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n\n@@ -124,6 +102,8 @@ import java.util.stream.Collectors;\n @DocumentedFeature\n @BetaFeature\n public class VariantEval extends MultiVariantWalkerGroupedOnStart {\n+    protected VariantEvalEngine engine;\n+\n     public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n \n     @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzNzk1MA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547337950", "bodyText": "This needs an access modifier; private if possible. This one also has a getter now, though thats hopefully temporary.", "author": "cmnbroad", "createdAt": "2020-12-22T15:22:42Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -126,125 +123,27 @@\n )\n @DocumentedFeature\n @BetaFeature\n-public class VariantEval extends MultiVariantWalker {\n+public class VariantEval extends MultiVariantWalkerGroupedOnStart {\n     public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n \n     @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n             shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n             doc=\"File to which variants should be written\")\n     protected File outFile;\n \n-    /**\n-     * The variant file(s) to evaluate.\n-     */\n-    @Argument(fullName=\"eval\", shortName = \"eval\", doc=\"Input evaluation file(s)\", optional=false)\n-    public List<FeatureInput<VariantContext>> evals;\n-\n-    /**\n-     * The variant file(s) to compare against.\n-     */\n-    @Argument(fullName = StandardArgumentDefinitions.COMPARISON_LONG_NAME, shortName = StandardArgumentDefinitions.COMPARISON_SHORT_NAME, doc=\"Input comparison file(s)\", optional=true)\n-    public List<FeatureInput<VariantContext>> compsProvided = new ArrayList<>();\n-    private List<FeatureInput<VariantContext>> comps = new ArrayList<>();\n-\n-    /**\n-     * dbSNP comparison VCF.  By default, the dbSNP file is used to specify the set of \"known\" variants.\n-     * Other sets can be specified with the -known-name (--known_names) argument.\n-     */\n     @ArgumentCollection\n-    protected DbsnpArgumentCollection dbsnp = new DbsnpArgumentCollection();\n-\n-    /**\n-     * Some analyses want to count overlap not with dbSNP (which is in general very open) but\n-     * actually want to itemize their overlap specifically with a set of gold standard sites\n-     * such as HapMap, OMNI, or the gold standard indels.  This argument provides a mechanism\n-     * for communicating which file to use\n-     */\n-    @Argument(fullName=\"gold-standard\", shortName = \"gold\", doc=\"Evaluations that count calls at sites of true variation (e.g., indel calls) will use this argument as their gold standard for comparison\", optional=true)\n-    public FeatureInput<VariantContext> goldStandard = null;\n+    VariantEvalArgumentCollection variantEvalArgs = new VariantEvalArgumentCollection();", "originalCommit": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzOTQyMg==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547539422", "bodyText": "it is now private, but does have the getter. As noted, the PR isnt perfect, but neither was the original code.", "author": "bbimber", "createdAt": "2020-12-22T22:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzNzk1MA=="}], "type": "inlineReview", "revised_code": {"commit": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\nindex 0db5f4b1e..28780906a 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n\n@@ -124,6 +102,8 @@ import java.util.stream.Collectors;\n @DocumentedFeature\n @BetaFeature\n public class VariantEval extends MultiVariantWalkerGroupedOnStart {\n+    protected VariantEvalEngine engine;\n+\n     public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n \n     @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM0ODgxNg==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547348816", "bodyText": "Where we're changing code anyway, we might as well use a symbolic name for these lambda args.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    variantEvalArgs.compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n          \n          \n            \n                    variantEvalArgs.compsProvided.forEach(comp -> inputToNameMap.put(comp, comp.hasUserSuppliedName() ? comp.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));", "author": "cmnbroad", "createdAt": "2020-12-22T15:41:30Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -318,60 +213,60 @@ public void onTraversalStart() {\n \n         sampleDB = initializeSampleDB();\n \n-        comps.addAll(compsProvided);\n-        compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n-        if ( dbsnp.dbsnp != null ) {\n-            comps.add(dbsnp.dbsnp);\n-            inputToNameMap.put(dbsnp.dbsnp, \"dbsnp\");\n-            knowns.add(dbsnp.dbsnp);\n+        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n+        variantEvalArgs.compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));", "originalCommit": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzOTcxMg==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547539712", "bodyText": "ok", "author": "bbimber", "createdAt": "2020-12-22T22:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM0ODgxNg=="}], "type": "inlineReview", "revised_code": {"commit": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\nindex 0db5f4b1e..28780906a 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n\n@@ -163,474 +135,55 @@ public class VariantEval extends MultiVariantWalkerGroupedOnStart {\n \n     @Override\n     protected void initializeDrivingVariants() {\n-        getDrivingVariantsFeatureInputs().addAll(variantEvalArgs.getEvals());\n-        if (variantEvalArgs.dbsnp.dbsnp != null) {\n-            getDrivingVariantsFeatureInputs().add(variantEvalArgs.dbsnp.dbsnp);\n-        }\n-\n-        getDrivingVariantsFeatureInputs().addAll(variantEvalArgs.compsProvided);\n+        getDrivingVariantsFeatureInputs().addAll(VariantEvalEngine.getFeatureInputsForDrivingVariants(variantEvalArgs));\n \n         super.initializeDrivingVariants();\n     }\n \n-    // Variables\n-    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n-\n-    private boolean isSubsettingSamples;\n-    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n-    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n-    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n-    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n-\n-    // important stratifications\n-    private boolean byFilterIsEnabled = false;\n-    private boolean perSampleIsEnabled = false;\n-    private boolean perFamilyIsEnabled = false;\n-\n-    // Utility class\n-    private final VariantEvalUtils variantEvalUtils = new VariantEvalUtils(this);\n-\n-    // Ancestral alignments\n-    private ReferenceSequenceFile ancestralAlignments = null;\n-\n-    // The set of all possible evaluation contexts\n-    StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n-\n-    private SampleDB sampleDB = null;\n-\n-    // maintain the mapping of FeatureInput to name used in output file\n-    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n-\n-    /**\n-     * Initialize the stratifications, evaluations, evaluation contexts, and reporting object\n-     */\n     @Override\n     public void onTraversalStart() {\n-        Utils.nonNull(outFile);\n-\n         // Just list the modules, and exit quickly.\n-        if (LIST) { variantEvalUtils.listModulesAndExit(); }\n-\n-        sampleDB = initializeSampleDB();\n-\n-        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n-        variantEvalArgs.compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n-        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n-            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n-            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n-            variantEvalArgs.knowns.add(variantEvalArgs.dbsnp.dbsnp);\n-        }\n-\n-        variantEvalArgs.evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));\n-\n-        // Set up set of additional knowns. dbSNP was addressed above, so use compsProvided, not comps\n-        for ( FeatureInput<VariantContext> compInput : variantEvalArgs.compsProvided ) {\n-            if (variantEvalArgs.KNOWN_NAMES.contains(getNameForInput(compInput)))\n-                variantEvalArgs.knowns.add(compInput);\n-        }\n-\n-        // Now that we have all the inputs categorized, determine the sample list from the eval inputs.\n-        Map<String, VCFHeader> vcfInputs = new HashMap<>();\n-        variantEvalArgs.evals.forEach(x -> vcfInputs.put(x.getName(), (VCFHeader)getHeaderForFeatures(x)));\n-\n-        Set<String> vcfSamples = new HashSet<>();\n-        vcfInputs.forEach((k,v) -> vcfSamples.addAll(v.getSampleNamesInOrder()));\n-\n-        // Load the sample list, using an intermediate tree set to sort the samples\n-        final Set<String> allSampleNames = new HashSet<>(vcfSamples);\n-        sampleNamesForEvaluation.addAll(new TreeSet<>(variantEvalArgs.SAMPLE_EXPRESSIONS.isEmpty() ? vcfSamples : Utils.filterCollectionByExpressions(vcfSamples, variantEvalArgs.SAMPLE_EXPRESSIONS, false)));\n-\n-        isSubsettingSamples = ! sampleNamesForEvaluation.containsAll(allSampleNames);\n-        familyNamesForEvaluation.addAll(sampleDB.getFamilyIDs());\n-\n-        //If stratifying by sample name, assign a stratification for each sample we're evaluating (based on commandline args)...\n-        if (variantEvalArgs.STRATIFICATIONS_TO_USE.contains(\"Sample\") ) {\n-            sampleNamesForStratification.addAll(sampleNamesForEvaluation);\n-        }\n-        //...and also a stratification for the sum over all samples\n-        sampleNamesForStratification.add(VariantEvalArgumentCollection.ALL_SAMPLE_NAME);\n-\n-        //If stratifying by sample name, assign a stratification for each family...\n-        if ( variantEvalArgs.STRATIFICATIONS_TO_USE.contains(\"Family\") ) {\n-            familyNamesForStratification.addAll(familyNamesForEvaluation);\n-        }\n-        //...and also a stratification for the sum over all families\n-        familyNamesForStratification.add(VariantEvalArgumentCollection.ALL_FAMILY_NAME);\n-\n-        // Initialize select expressions\n-        for (VariantContextUtils.JexlVCMatchExp jexl : VariantContextUtils.initializeMatchExps(variantEvalArgs.SELECT_NAMES, variantEvalArgs.SELECT_EXPS)) {\n-            SortableJexlVCMatchExp sjexl = new SortableJexlVCMatchExp(jexl.name, jexl.exp);\n-            jexlExpressions.add(sjexl);\n-        }\n-\n-        // Initialize the set of stratifications and evaluations to use\n-        // The list of stratifiers and evaluators to use\n-        final List<VariantStratifier> stratificationObjects = variantEvalUtils.initializeStratificationObjects(variantEvalArgs.NO_STANDARD_STRATIFICATIONS, variantEvalArgs.STRATIFICATIONS_TO_USE);\n-        final Set<Class<? extends VariantEvaluator>> evaluationClasses = variantEvalUtils.initializeEvaluationObjects(variantEvalArgs.NO_STANDARD_MODULES, variantEvalArgs.MODULES_TO_USE);\n-\n-        checkForIncompatibleEvaluatorsAndStratifiers(stratificationObjects, evaluationClasses);\n-\n-        for ( VariantStratifier vs : stratificationObjects ) {\n-            if ( vs.getName().equals(\"Filter\") )\n-                byFilterIsEnabled = true;\n-            else if ( vs.getName().equals(\"Sample\") )\n-                perSampleIsEnabled = true;\n-            else if ( vs.getName().equals(\"Family\"))\n-                perFamilyIsEnabled = true;\n-        }\n-\n-        if (perSampleIsEnabled && perFamilyIsEnabled)\n-            throw new CommandLineException.BadArgumentValue(\"ST\", \"Variants cannot be stratified by sample and family at the same time\");\n-\n-        if (perFamilyIsEnabled && sampleDB.getTrios().isEmpty())\n-            throw new CommandLineException.BadArgumentValue(\"ST\", \"Cannot stratify by family without *.ped file\");\n-\n-\n-        if ( variantEvalArgs.intervalsFile != null ) {\n-            boolean fail = true;\n-            for ( final VariantStratifier vs : stratificationObjects ) {\n-                if ( vs.getClass().equals(IntervalStratification.class) )\n-                    fail = false;\n-            }\n-            if ( fail )\n-                throw new CommandLineException.BadArgumentValue(\"ST\", \"stratIntervals argument provided but -ST IntervalStratification not provided\");\n-        }\n-\n-        // Initialize the evaluation contexts\n-        createStratificationStates(stratificationObjects, evaluationClasses);\n-\n-        // Load ancestral alignments\n-        if (variantEvalArgs.ancestralAlignmentsFile != null) {\n-            try {\n-                ancestralAlignments = new IndexedFastaSequenceFile(variantEvalArgs.ancestralAlignmentsFile.toPath());\n-            } catch (FileNotFoundException e) {\n-                throw new GATKException(String.format(\"The ancestral alignments file, '%s', could not be found\", variantEvalArgs.ancestralAlignmentsFile.getAbsolutePath()));\n-            }\n-        }\n-\n-        assertThatTerritoryIsSpecifiedIfNecessary();\n-    }\n-\n-    private void assertThatTerritoryIsSpecifiedIfNecessary() {\n-        final Set<String> evaluatorsWhichRequireTerritory = stratManager.values()\n-                .stream()\n-                .flatMap(ctx -> ctx.getVariantEvaluators().stream())\n-                .filter(Objects::nonNull)\n-                .filter(VariantEvaluator::requiresTerritoryToBeSpecified)\n-                .map(VariantEvaluator::getSimpleName)\n-                .collect(Collectors.toSet());\n-        if(!evaluatorsWhichRequireTerritory.isEmpty() && getTraversalIntervals() == null){\n-            throw new UserException(\"You specified evaluators which require a covered territory to be specified.  \" +\n-                    \"\\nPlease specify intervals or a reference file or disable all of the following evaluators:\" +\n-                    evaluatorsWhichRequireTerritory.stream()\n-                            .collect(Collectors.joining(\", \")));\n-        }\n-    }\n-\n-    private void checkForIncompatibleEvaluatorsAndStratifiers( final List<VariantStratifier> stratificationObjects,\n-                                                             Set<Class<? extends VariantEvaluator>> evaluationClasses) {\n-        for ( final VariantStratifier vs : stratificationObjects ) {\n-            for ( Class<? extends VariantEvaluator> ec : evaluationClasses )\n-                if ( vs.getIncompatibleEvaluators().contains(ec) )\n-                    throw new CommandLineException.BadArgumentValue(\"ST and ET\",\n-                            \"The selected stratification \" + vs.getName() +\n-                                    \" and evaluator \" + ec.getSimpleName() +\n-                                    \" are incompatible due to combinatorial memory requirements.\" +\n-                                    \" Please disable one\");\n-        }\n-    }\n+        if (LIST) { listModulesAndExit(); }\n \n-    final void createStratificationStates(final List<VariantStratifier> stratificationObjects, final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n-        final List<VariantStratifier> strats = new ArrayList<VariantStratifier>(stratificationObjects);\n-        stratManager = new StratificationManager<>(strats);\n+        Utils.nonNull(outFile);\n+        IOUtil.assertFileIsWritable(outFile);\n \n-        logger.info(\"Creating \" + stratManager.size() + \" combinatorial stratification states\");\n-        for ( int i = 0; i < stratManager.size(); i++ ) {\n-            EvaluationContext ec = createEvaluationContext(evaluationObjects);\n-            stratManager.set(i, ec);\n-        }\n+        engine = new VariantEvalEngine(variantEvalArgs, this, getSequenceDictionaryForDrivingVariants(), getSamplesForVariants(), logger);\n     }\n \n     /**\n-     * Create the EvaluationContext (new instance) for the provided set of VariantEvaluators.\n-     *\n-     * @param evaluationObjects The list of VariantEvaluator classes\n-     * @return The EvaluationContext for this set of VariantEvaluator classes\n+     * List all of the available evaluation modules, then exit successfully\n      */\n-    protected EvaluationContext createEvaluationContext(final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n-        return new EvaluationContext(this, evaluationObjects);\n-    }\n-\n-    public String getNameForInput(FeatureInput<VariantContext> input) {\n-        return inputToNameMap.get(input);\n-    }\n-\n-    @Override\n-    public void apply(List<VariantContext> variantContexts, ReferenceContext referenceContext, List<ReadsContext> readsContexts) {\n-        Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap = groupVariantsByFeatureInput(variantContexts);\n-\n-        List<VariantContext> allEvals = new ArrayList<>();\n-        for (FeatureInput<VariantContext> eval : variantEvalArgs.getEvals()) {\n-            if (variantMap.containsKey(eval)) {\n-                allEvals.addAll(variantMap.get(eval));\n-            }\n-        }\n-\n-        List<VariantContext> allComps = new ArrayList<>();\n-        if (variantEvalArgs.getComps() != null) {\n-            for (FeatureInput<VariantContext> comp : variantEvalArgs.getComps()) {\n-                if (variantMap.containsKey(comp)) {\n-                    allComps.addAll(variantMap.get(comp));\n-                }\n-            }\n-        }\n-\n-        SimpleInterval interval = allEvals.isEmpty() ? new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), variantContexts.get(0).getStart()) : generateContextInterval(allEvals);\n-        FeatureContext featureContext = new FeatureContext(features, interval);\n-\n-        Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> evalVCs = allEvals.isEmpty() ? Collections.emptyMap() : variantEvalUtils.bindVariantContexts(variantMap, variantEvalArgs.getEvals(), byFilterIsEnabled, true, perSampleIsEnabled, perFamilyIsEnabled, variantEvalArgs.mergeEvals);\n-        Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs = allComps.isEmpty() ? Collections.emptyMap() : variantEvalUtils.bindVariantContexts(variantMap, variantEvalArgs.getComps(), byFilterIsEnabled, false, false, false, false);\n-\n-        VariantEvalContext variantEvalContext = new VariantEvalContext(referenceContext, featureContext, variantMap, getVariantEvalArgs(), this);\n-\n-        // for each eval track\n-        for ( final FeatureInput<VariantContext> evalInput : variantEvalArgs.getEvals() ) {\n-            final Map<String, Collection<VariantContext>> evalSet = evalVCs.containsKey(evalInput) ? evalVCs.get(evalInput) : Collections.emptyMap();\n-\n-            Set<String> statificationLevels;\n+    public void listModulesAndExit() {\n+        logger.info(\"Available stratification modules:\");\n+        logger.info(\"(Standard modules are starred)\");\n \n-            // for each sample stratifier\n-            if (perFamilyIsEnabled)\n-                statificationLevels = familyNamesForStratification;\n-            else\n-                statificationLevels = sampleNamesForStratification;\n-            for ( final String stratLevelName : statificationLevels ) {\n-                Collection<VariantContext> evalSetBySample = evalSet.get(stratLevelName);\n+        for (String name: VariantEvalEngine.getStratifierClasses().keySet()) {\n \n-                if ( evalSetBySample == null ) {\n-                    evalSetBySample = new HashSet<>(1);\n-                    evalSetBySample.add(null);\n-                }\n-\n-                // for each eval in the track\n-                for ( VariantContext eval : evalSetBySample ) {\n-                    String aastr = (ancestralAlignments == null) ? null : new String(ancestralAlignments.getSubsequenceAt(eval.getContig(), eval.getStart(), eval.getEnd()).getBases());\n-\n-                    // deal with ancestral alleles if requested\n-                    if ( eval != null && aastr != null ) {\n-                        eval = new VariantContextBuilder(eval).attribute(\"ANCESTRALALLELE\", aastr).make();\n-                    }\n-\n-                    String evalName = getNameForInput(evalInput);\n-\n-                    // for each comp track\n-                    for ( final FeatureInput<VariantContext> compInput : variantEvalArgs.comps ) {\n-                        processComp(variantEvalContext, eval, evalName, compInput, stratLevelName, compVCs, evalSetBySample);\n-                    }\n-\n-                    if (variantEvalArgs.comps.isEmpty()) {\n-                        processComp(variantEvalContext, eval, evalName, null, stratLevelName, compVCs, evalSetBySample);\n-                    }\n-                }\n-            }\n-\n-            if ( variantEvalArgs.mergeEvals ) break; // stop processing the eval tracks\n+            logger.info(\"\\t\" + name + (VariantEvalEngine.getRequiredStratificationNames().contains(name) || VariantEvalEngine.getStandardStratificationNames().contains(name) ? \"*\" : \"\"));\n         }\n-    }\n+        logger.info(\"\");\n \n-    private SimpleInterval generateContextInterval(List<VariantContext> variantContexts) {\n-        int maxEnd = variantContexts.stream().map(VariantContext::getEnd).max(Integer::compareTo).get();\n-\n-        return new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), maxEnd);\n-    }\n-\n-    private void processComp(VariantEvalContext vec, VariantContext eval, String evalName, FeatureInput<VariantContext> compInput, String stratLevelName, Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs, Collection<VariantContext> evalSetBySample) {\n-        String compName = getNameForInput(compInput);\n-\n-        // no sample stratification for comps\n-        final HashMap<String, Collection<VariantContext>> compSetHash = compInput == null ? null : compVCs.get(compInput);\n-        final Collection<VariantContext> compSet = (compSetHash == null || compSetHash.isEmpty()) ? Collections.<VariantContext>emptyList() : compVCs.get(compInput).values().iterator().next();\n-\n-        // find the comp\n-        final VariantContext comp = findMatchingComp(eval, compSet);\n-\n-        Collection<EvaluationContext> contextsForStratification;\n-        if (perFamilyIsEnabled)\n-            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, null, stratLevelName);\n-        else {\n-            String familyID;\n-            if (stratLevelName.equals(\"all\"))\n-                familyID = \"all\";\n-            else\n-                familyID = sampleDB.getSample(stratLevelName).getFamilyID();\n-            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, stratLevelName, familyID);\n+        logger.info(\"Available evaluation modules:\");\n+        logger.info(\"(Standard modules are starred)\");\n+        for (String veName : VariantEvalEngine.getEvaluatorClasses().keySet()) {\n+            logger.info(\"\\t\" + veName + (VariantEvalEngine.getStandardEvaluatorNames().contains(veName) ? \"*\" : \"\"));\n         }\n-        for ( EvaluationContext nec : contextsForStratification ) {\n+        logger.info(\"\");\n \n-            // eval against the comp\n-            synchronized (nec) {\n-                nec.apply(vec, comp, eval);\n-            }\n-\n-            // eval=null against all comps of different type that aren't bound to another eval\n-            for ( VariantContext otherComp : compSet ) {\n-                if ( otherComp != comp && ! compHasMatchingEval(otherComp, evalSetBySample) ) {\n-                    synchronized (nec) {\n-                        nec.apply(vec, otherComp, null);\n-                    }\n-                }\n-            }\n-        }\n+        System.exit(0);\n     }\n \n-    /**\n-     * Given specific eval and comp VCs and the sample name, return an iterable\n-     * over all of the applicable state keys.\n-     *\n-     * this code isn't structured yet for efficiency.  Here we currently are\n-     * doing the following inefficient algorithm:\n-     *\n-     * for each strat:\n-     *   get list of relevant states that eval and comp according to strat\n-     *   add this list of states to a list of list states\n-     *\n-     * then\n-     *\n-     * ask the strat manager to look up all of the keys associated with the combinations\n-     * of these states.  For example, suppose we have a single variant S.  We have active\n-     * strats EvalFeatureInput, CompFeatureInput, and Novelty.  We produce a list that looks like:\n-     *\n-     *   L = [[Eval], [Comp], [All, Novel]]\n-     *\n-     * We then go through the strat manager tree to produce the keys associated with these states:\n-     *\n-     *   K = [0, 1] where EVAL x COMP x ALL = 0 and EVAL x COMP x NOVEL = 1\n-     *\n-     * It's clear that a better\n-     *\n-     *\n-     * @param vec\n-     * @param eval\n-     * @param evalName\n-     * @param comp\n-     * @param compName\n-     * @param sampleName\n-     * @return\n-     */\n-    protected Collection<EvaluationContext> getEvaluationContexts(final VariantEvalContext vec,\n-                                                                  final VariantContext eval,\n-                                                                  final String evalName,\n-                                                                  final VariantContext comp,\n-                                                                  final String compName,\n-                                                                  final String sampleName,\n-                                                                  final String familyName) {\n-        final List<List<Object>> states = new LinkedList<>();\n-        for ( final VariantStratifier vs : stratManager.getStratifiers() ) {\n-            states.add(vs.getRelevantStates(vec, comp, compName, eval, evalName, sampleName, familyName));\n-        }\n-        return stratManager.values(states);\n-    }\n-\n-\n-    private boolean compHasMatchingEval(final VariantContext comp, final Collection<VariantContext> evals) {\n-        // find all of the matching comps\n-        for ( final VariantContext eval : evals ) {\n-            if ( eval != null && doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) != EvalCompMatchType.NO_MATCH )\n-                return true;\n-        }\n-\n-        // nothing matched\n-        return false;\n-    }\n-\n-    private enum EvalCompMatchType { NO_MATCH, STRICT, LENIENT }\n-\n-    private EvalCompMatchType doEvalAndCompMatch(final VariantContext eval, final VariantContext comp, boolean requireStrictAlleleMatch) {\n-        if ( comp.getType() == VariantContext.Type.NO_VARIATION || eval.getType() == VariantContext.Type.NO_VARIATION )\n-            // if either of these are NO_VARIATION they are LENIENT matches\n-            return EvalCompMatchType.LENIENT;\n-\n-        if ( comp.getType() != eval.getType() )\n-            return EvalCompMatchType.NO_MATCH;\n-\n-        // find the comp which matches both the reference allele and alternate allele from eval\n-        final Allele altEval = eval.getAlternateAlleles().size() == 0 ? null : eval.getAlternateAllele(0);\n-        final Allele altComp = comp.getAlternateAlleles().size() == 0 ? null : comp.getAlternateAllele(0);\n-        if ((altEval == null && altComp == null) || (altEval != null && altEval.equals(altComp) && eval.getReference().equals(comp.getReference())))\n-            return EvalCompMatchType.STRICT;\n-        else\n-            return requireStrictAlleleMatch ? EvalCompMatchType.NO_MATCH : EvalCompMatchType.LENIENT;\n-    }\n-\n-    private VariantContext findMatchingComp(final VariantContext eval, final Collection<VariantContext> comps) {\n-        // if no comps, return null\n-        if ( comps == null || comps.isEmpty() )\n-            return null;\n-\n-        // if no eval, return any comp\n-        if ( eval == null )\n-            return comps.iterator().next();\n-\n-        // find all of the matching comps\n-        VariantContext lenientMatch = null;\n-        for ( final VariantContext comp : comps ) {\n-            switch ( doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) ) {\n-                case STRICT:\n-                    return comp;\n-                case LENIENT:\n-                    if ( lenientMatch == null ) lenientMatch = comp;\n-                    break;\n-                case NO_MATCH:\n-                    // do nothing\n-            }\n-        }\n-\n-        // nothing matched, just return lenientMatch, which might be null\n-        return lenientMatch;\n+    @Override\n+    public void apply(final List<VariantContext> variantContexts, final ReferenceContext referenceContext, final List<ReadsContext> readsContexts) {\n+        engine.apply(variantContexts, referenceContext);\n     }\n \n     @Override\n     public Object onTraversalSuccess() {\n         logger.info(\"Finalizing variant report\");\n-        \n-        // go through the evaluations and finalize them\n-        for ( final EvaluationContext nec : stratManager.values() )\n-            for ( final VariantEvaluator ve : nec.getVariantEvaluators() )\n-                ve.finalizeEvaluation(this);\n-\n-        //send data to MetricsCollection\n-        CompOverlap compOverlap = null;\n-        IndelSummary indelSummary = null;\n-        CountVariants countVariants = null;\n-        MultiallelicSummary multiallelicSummary = null;\n-        TiTvVariantEvaluator tiTvVariantEvaluator = null;\n-        MetricsCollection metricsCollection = null;\n-        for(final EvaluationContext nec: stratManager.values()) {\n-            for(final VariantEvaluator ve : nec.getVariantEvaluators()) {\n-                if (ve instanceof CompOverlap)\n-                    compOverlap = (CompOverlap) ve;\n-                else if (ve instanceof IndelSummary)\n-                    indelSummary = (IndelSummary) ve;\n-                else if (ve instanceof CountVariants)\n-                    countVariants = (CountVariants) ve;\n-                else if (ve instanceof MultiallelicSummary)\n-                    multiallelicSummary = (MultiallelicSummary) ve;\n-                else if (ve instanceof TiTvVariantEvaluator)\n-                    tiTvVariantEvaluator = (TiTvVariantEvaluator) ve;\n-                else if (ve instanceof MetricsCollection)\n-                    metricsCollection = (MetricsCollection) ve;\n-            }\n-\n-            if(metricsCollection != null)\n-                metricsCollection.setData(compOverlap.concordantRate, indelSummary.n_SNPs, countVariants.nSNPs, indelSummary.n_indels, multiallelicSummary.nIndels, indelSummary.insertion_to_deletion_ratio, countVariants.insertionDeletionRatio, tiTvVariantEvaluator.tiTvRatio);\n-        }\n \n-        try (PrintStream out = IOUtils.makePrintStreamMaybeGzipped(new GATKPath(outFile.getAbsolutePath()))) {\n-            VariantEvalReportWriter.writeReport(out, stratManager, stratManager.getStratifiers(), stratManager.get(0).getVariantEvaluators());\n-        }\n-        catch(IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(e.getMessage(), e);\n-        }\n+        engine.finalizeReport(outFile);\n \n         return null;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM0OTY3NA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547349674", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    variantEvalArgs.evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));\n          \n          \n            \n                    variantEvalArgs.evals.forEach(eval -> inputToNameMap.put(eval, eval.hasUserSuppliedName() ? eval.getName() : \"eval\"));```", "author": "cmnbroad", "createdAt": "2020-12-22T15:43:04Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -318,60 +213,60 @@ public void onTraversalStart() {\n \n         sampleDB = initializeSampleDB();\n \n-        comps.addAll(compsProvided);\n-        compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n-        if ( dbsnp.dbsnp != null ) {\n-            comps.add(dbsnp.dbsnp);\n-            inputToNameMap.put(dbsnp.dbsnp, \"dbsnp\");\n-            knowns.add(dbsnp.dbsnp);\n+        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n+        variantEvalArgs.compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n+        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n+            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n+            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n+            variantEvalArgs.knowns.add(variantEvalArgs.dbsnp.dbsnp);\n         }\n \n-        evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));\n+        variantEvalArgs.evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));", "originalCommit": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\nindex 0db5f4b1e..28780906a 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n\n@@ -163,474 +135,55 @@ public class VariantEval extends MultiVariantWalkerGroupedOnStart {\n \n     @Override\n     protected void initializeDrivingVariants() {\n-        getDrivingVariantsFeatureInputs().addAll(variantEvalArgs.getEvals());\n-        if (variantEvalArgs.dbsnp.dbsnp != null) {\n-            getDrivingVariantsFeatureInputs().add(variantEvalArgs.dbsnp.dbsnp);\n-        }\n-\n-        getDrivingVariantsFeatureInputs().addAll(variantEvalArgs.compsProvided);\n+        getDrivingVariantsFeatureInputs().addAll(VariantEvalEngine.getFeatureInputsForDrivingVariants(variantEvalArgs));\n \n         super.initializeDrivingVariants();\n     }\n \n-    // Variables\n-    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n-\n-    private boolean isSubsettingSamples;\n-    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n-    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n-    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n-    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n-\n-    // important stratifications\n-    private boolean byFilterIsEnabled = false;\n-    private boolean perSampleIsEnabled = false;\n-    private boolean perFamilyIsEnabled = false;\n-\n-    // Utility class\n-    private final VariantEvalUtils variantEvalUtils = new VariantEvalUtils(this);\n-\n-    // Ancestral alignments\n-    private ReferenceSequenceFile ancestralAlignments = null;\n-\n-    // The set of all possible evaluation contexts\n-    StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n-\n-    private SampleDB sampleDB = null;\n-\n-    // maintain the mapping of FeatureInput to name used in output file\n-    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n-\n-    /**\n-     * Initialize the stratifications, evaluations, evaluation contexts, and reporting object\n-     */\n     @Override\n     public void onTraversalStart() {\n-        Utils.nonNull(outFile);\n-\n         // Just list the modules, and exit quickly.\n-        if (LIST) { variantEvalUtils.listModulesAndExit(); }\n-\n-        sampleDB = initializeSampleDB();\n-\n-        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n-        variantEvalArgs.compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n-        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n-            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n-            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n-            variantEvalArgs.knowns.add(variantEvalArgs.dbsnp.dbsnp);\n-        }\n-\n-        variantEvalArgs.evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));\n-\n-        // Set up set of additional knowns. dbSNP was addressed above, so use compsProvided, not comps\n-        for ( FeatureInput<VariantContext> compInput : variantEvalArgs.compsProvided ) {\n-            if (variantEvalArgs.KNOWN_NAMES.contains(getNameForInput(compInput)))\n-                variantEvalArgs.knowns.add(compInput);\n-        }\n-\n-        // Now that we have all the inputs categorized, determine the sample list from the eval inputs.\n-        Map<String, VCFHeader> vcfInputs = new HashMap<>();\n-        variantEvalArgs.evals.forEach(x -> vcfInputs.put(x.getName(), (VCFHeader)getHeaderForFeatures(x)));\n-\n-        Set<String> vcfSamples = new HashSet<>();\n-        vcfInputs.forEach((k,v) -> vcfSamples.addAll(v.getSampleNamesInOrder()));\n-\n-        // Load the sample list, using an intermediate tree set to sort the samples\n-        final Set<String> allSampleNames = new HashSet<>(vcfSamples);\n-        sampleNamesForEvaluation.addAll(new TreeSet<>(variantEvalArgs.SAMPLE_EXPRESSIONS.isEmpty() ? vcfSamples : Utils.filterCollectionByExpressions(vcfSamples, variantEvalArgs.SAMPLE_EXPRESSIONS, false)));\n-\n-        isSubsettingSamples = ! sampleNamesForEvaluation.containsAll(allSampleNames);\n-        familyNamesForEvaluation.addAll(sampleDB.getFamilyIDs());\n-\n-        //If stratifying by sample name, assign a stratification for each sample we're evaluating (based on commandline args)...\n-        if (variantEvalArgs.STRATIFICATIONS_TO_USE.contains(\"Sample\") ) {\n-            sampleNamesForStratification.addAll(sampleNamesForEvaluation);\n-        }\n-        //...and also a stratification for the sum over all samples\n-        sampleNamesForStratification.add(VariantEvalArgumentCollection.ALL_SAMPLE_NAME);\n-\n-        //If stratifying by sample name, assign a stratification for each family...\n-        if ( variantEvalArgs.STRATIFICATIONS_TO_USE.contains(\"Family\") ) {\n-            familyNamesForStratification.addAll(familyNamesForEvaluation);\n-        }\n-        //...and also a stratification for the sum over all families\n-        familyNamesForStratification.add(VariantEvalArgumentCollection.ALL_FAMILY_NAME);\n-\n-        // Initialize select expressions\n-        for (VariantContextUtils.JexlVCMatchExp jexl : VariantContextUtils.initializeMatchExps(variantEvalArgs.SELECT_NAMES, variantEvalArgs.SELECT_EXPS)) {\n-            SortableJexlVCMatchExp sjexl = new SortableJexlVCMatchExp(jexl.name, jexl.exp);\n-            jexlExpressions.add(sjexl);\n-        }\n-\n-        // Initialize the set of stratifications and evaluations to use\n-        // The list of stratifiers and evaluators to use\n-        final List<VariantStratifier> stratificationObjects = variantEvalUtils.initializeStratificationObjects(variantEvalArgs.NO_STANDARD_STRATIFICATIONS, variantEvalArgs.STRATIFICATIONS_TO_USE);\n-        final Set<Class<? extends VariantEvaluator>> evaluationClasses = variantEvalUtils.initializeEvaluationObjects(variantEvalArgs.NO_STANDARD_MODULES, variantEvalArgs.MODULES_TO_USE);\n-\n-        checkForIncompatibleEvaluatorsAndStratifiers(stratificationObjects, evaluationClasses);\n-\n-        for ( VariantStratifier vs : stratificationObjects ) {\n-            if ( vs.getName().equals(\"Filter\") )\n-                byFilterIsEnabled = true;\n-            else if ( vs.getName().equals(\"Sample\") )\n-                perSampleIsEnabled = true;\n-            else if ( vs.getName().equals(\"Family\"))\n-                perFamilyIsEnabled = true;\n-        }\n-\n-        if (perSampleIsEnabled && perFamilyIsEnabled)\n-            throw new CommandLineException.BadArgumentValue(\"ST\", \"Variants cannot be stratified by sample and family at the same time\");\n-\n-        if (perFamilyIsEnabled && sampleDB.getTrios().isEmpty())\n-            throw new CommandLineException.BadArgumentValue(\"ST\", \"Cannot stratify by family without *.ped file\");\n-\n-\n-        if ( variantEvalArgs.intervalsFile != null ) {\n-            boolean fail = true;\n-            for ( final VariantStratifier vs : stratificationObjects ) {\n-                if ( vs.getClass().equals(IntervalStratification.class) )\n-                    fail = false;\n-            }\n-            if ( fail )\n-                throw new CommandLineException.BadArgumentValue(\"ST\", \"stratIntervals argument provided but -ST IntervalStratification not provided\");\n-        }\n-\n-        // Initialize the evaluation contexts\n-        createStratificationStates(stratificationObjects, evaluationClasses);\n-\n-        // Load ancestral alignments\n-        if (variantEvalArgs.ancestralAlignmentsFile != null) {\n-            try {\n-                ancestralAlignments = new IndexedFastaSequenceFile(variantEvalArgs.ancestralAlignmentsFile.toPath());\n-            } catch (FileNotFoundException e) {\n-                throw new GATKException(String.format(\"The ancestral alignments file, '%s', could not be found\", variantEvalArgs.ancestralAlignmentsFile.getAbsolutePath()));\n-            }\n-        }\n-\n-        assertThatTerritoryIsSpecifiedIfNecessary();\n-    }\n-\n-    private void assertThatTerritoryIsSpecifiedIfNecessary() {\n-        final Set<String> evaluatorsWhichRequireTerritory = stratManager.values()\n-                .stream()\n-                .flatMap(ctx -> ctx.getVariantEvaluators().stream())\n-                .filter(Objects::nonNull)\n-                .filter(VariantEvaluator::requiresTerritoryToBeSpecified)\n-                .map(VariantEvaluator::getSimpleName)\n-                .collect(Collectors.toSet());\n-        if(!evaluatorsWhichRequireTerritory.isEmpty() && getTraversalIntervals() == null){\n-            throw new UserException(\"You specified evaluators which require a covered territory to be specified.  \" +\n-                    \"\\nPlease specify intervals or a reference file or disable all of the following evaluators:\" +\n-                    evaluatorsWhichRequireTerritory.stream()\n-                            .collect(Collectors.joining(\", \")));\n-        }\n-    }\n-\n-    private void checkForIncompatibleEvaluatorsAndStratifiers( final List<VariantStratifier> stratificationObjects,\n-                                                             Set<Class<? extends VariantEvaluator>> evaluationClasses) {\n-        for ( final VariantStratifier vs : stratificationObjects ) {\n-            for ( Class<? extends VariantEvaluator> ec : evaluationClasses )\n-                if ( vs.getIncompatibleEvaluators().contains(ec) )\n-                    throw new CommandLineException.BadArgumentValue(\"ST and ET\",\n-                            \"The selected stratification \" + vs.getName() +\n-                                    \" and evaluator \" + ec.getSimpleName() +\n-                                    \" are incompatible due to combinatorial memory requirements.\" +\n-                                    \" Please disable one\");\n-        }\n-    }\n+        if (LIST) { listModulesAndExit(); }\n \n-    final void createStratificationStates(final List<VariantStratifier> stratificationObjects, final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n-        final List<VariantStratifier> strats = new ArrayList<VariantStratifier>(stratificationObjects);\n-        stratManager = new StratificationManager<>(strats);\n+        Utils.nonNull(outFile);\n+        IOUtil.assertFileIsWritable(outFile);\n \n-        logger.info(\"Creating \" + stratManager.size() + \" combinatorial stratification states\");\n-        for ( int i = 0; i < stratManager.size(); i++ ) {\n-            EvaluationContext ec = createEvaluationContext(evaluationObjects);\n-            stratManager.set(i, ec);\n-        }\n+        engine = new VariantEvalEngine(variantEvalArgs, this, getSequenceDictionaryForDrivingVariants(), getSamplesForVariants(), logger);\n     }\n \n     /**\n-     * Create the EvaluationContext (new instance) for the provided set of VariantEvaluators.\n-     *\n-     * @param evaluationObjects The list of VariantEvaluator classes\n-     * @return The EvaluationContext for this set of VariantEvaluator classes\n+     * List all of the available evaluation modules, then exit successfully\n      */\n-    protected EvaluationContext createEvaluationContext(final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n-        return new EvaluationContext(this, evaluationObjects);\n-    }\n-\n-    public String getNameForInput(FeatureInput<VariantContext> input) {\n-        return inputToNameMap.get(input);\n-    }\n-\n-    @Override\n-    public void apply(List<VariantContext> variantContexts, ReferenceContext referenceContext, List<ReadsContext> readsContexts) {\n-        Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap = groupVariantsByFeatureInput(variantContexts);\n-\n-        List<VariantContext> allEvals = new ArrayList<>();\n-        for (FeatureInput<VariantContext> eval : variantEvalArgs.getEvals()) {\n-            if (variantMap.containsKey(eval)) {\n-                allEvals.addAll(variantMap.get(eval));\n-            }\n-        }\n-\n-        List<VariantContext> allComps = new ArrayList<>();\n-        if (variantEvalArgs.getComps() != null) {\n-            for (FeatureInput<VariantContext> comp : variantEvalArgs.getComps()) {\n-                if (variantMap.containsKey(comp)) {\n-                    allComps.addAll(variantMap.get(comp));\n-                }\n-            }\n-        }\n-\n-        SimpleInterval interval = allEvals.isEmpty() ? new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), variantContexts.get(0).getStart()) : generateContextInterval(allEvals);\n-        FeatureContext featureContext = new FeatureContext(features, interval);\n-\n-        Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> evalVCs = allEvals.isEmpty() ? Collections.emptyMap() : variantEvalUtils.bindVariantContexts(variantMap, variantEvalArgs.getEvals(), byFilterIsEnabled, true, perSampleIsEnabled, perFamilyIsEnabled, variantEvalArgs.mergeEvals);\n-        Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs = allComps.isEmpty() ? Collections.emptyMap() : variantEvalUtils.bindVariantContexts(variantMap, variantEvalArgs.getComps(), byFilterIsEnabled, false, false, false, false);\n-\n-        VariantEvalContext variantEvalContext = new VariantEvalContext(referenceContext, featureContext, variantMap, getVariantEvalArgs(), this);\n-\n-        // for each eval track\n-        for ( final FeatureInput<VariantContext> evalInput : variantEvalArgs.getEvals() ) {\n-            final Map<String, Collection<VariantContext>> evalSet = evalVCs.containsKey(evalInput) ? evalVCs.get(evalInput) : Collections.emptyMap();\n-\n-            Set<String> statificationLevels;\n+    public void listModulesAndExit() {\n+        logger.info(\"Available stratification modules:\");\n+        logger.info(\"(Standard modules are starred)\");\n \n-            // for each sample stratifier\n-            if (perFamilyIsEnabled)\n-                statificationLevels = familyNamesForStratification;\n-            else\n-                statificationLevels = sampleNamesForStratification;\n-            for ( final String stratLevelName : statificationLevels ) {\n-                Collection<VariantContext> evalSetBySample = evalSet.get(stratLevelName);\n+        for (String name: VariantEvalEngine.getStratifierClasses().keySet()) {\n \n-                if ( evalSetBySample == null ) {\n-                    evalSetBySample = new HashSet<>(1);\n-                    evalSetBySample.add(null);\n-                }\n-\n-                // for each eval in the track\n-                for ( VariantContext eval : evalSetBySample ) {\n-                    String aastr = (ancestralAlignments == null) ? null : new String(ancestralAlignments.getSubsequenceAt(eval.getContig(), eval.getStart(), eval.getEnd()).getBases());\n-\n-                    // deal with ancestral alleles if requested\n-                    if ( eval != null && aastr != null ) {\n-                        eval = new VariantContextBuilder(eval).attribute(\"ANCESTRALALLELE\", aastr).make();\n-                    }\n-\n-                    String evalName = getNameForInput(evalInput);\n-\n-                    // for each comp track\n-                    for ( final FeatureInput<VariantContext> compInput : variantEvalArgs.comps ) {\n-                        processComp(variantEvalContext, eval, evalName, compInput, stratLevelName, compVCs, evalSetBySample);\n-                    }\n-\n-                    if (variantEvalArgs.comps.isEmpty()) {\n-                        processComp(variantEvalContext, eval, evalName, null, stratLevelName, compVCs, evalSetBySample);\n-                    }\n-                }\n-            }\n-\n-            if ( variantEvalArgs.mergeEvals ) break; // stop processing the eval tracks\n+            logger.info(\"\\t\" + name + (VariantEvalEngine.getRequiredStratificationNames().contains(name) || VariantEvalEngine.getStandardStratificationNames().contains(name) ? \"*\" : \"\"));\n         }\n-    }\n+        logger.info(\"\");\n \n-    private SimpleInterval generateContextInterval(List<VariantContext> variantContexts) {\n-        int maxEnd = variantContexts.stream().map(VariantContext::getEnd).max(Integer::compareTo).get();\n-\n-        return new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), maxEnd);\n-    }\n-\n-    private void processComp(VariantEvalContext vec, VariantContext eval, String evalName, FeatureInput<VariantContext> compInput, String stratLevelName, Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs, Collection<VariantContext> evalSetBySample) {\n-        String compName = getNameForInput(compInput);\n-\n-        // no sample stratification for comps\n-        final HashMap<String, Collection<VariantContext>> compSetHash = compInput == null ? null : compVCs.get(compInput);\n-        final Collection<VariantContext> compSet = (compSetHash == null || compSetHash.isEmpty()) ? Collections.<VariantContext>emptyList() : compVCs.get(compInput).values().iterator().next();\n-\n-        // find the comp\n-        final VariantContext comp = findMatchingComp(eval, compSet);\n-\n-        Collection<EvaluationContext> contextsForStratification;\n-        if (perFamilyIsEnabled)\n-            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, null, stratLevelName);\n-        else {\n-            String familyID;\n-            if (stratLevelName.equals(\"all\"))\n-                familyID = \"all\";\n-            else\n-                familyID = sampleDB.getSample(stratLevelName).getFamilyID();\n-            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, stratLevelName, familyID);\n+        logger.info(\"Available evaluation modules:\");\n+        logger.info(\"(Standard modules are starred)\");\n+        for (String veName : VariantEvalEngine.getEvaluatorClasses().keySet()) {\n+            logger.info(\"\\t\" + veName + (VariantEvalEngine.getStandardEvaluatorNames().contains(veName) ? \"*\" : \"\"));\n         }\n-        for ( EvaluationContext nec : contextsForStratification ) {\n+        logger.info(\"\");\n \n-            // eval against the comp\n-            synchronized (nec) {\n-                nec.apply(vec, comp, eval);\n-            }\n-\n-            // eval=null against all comps of different type that aren't bound to another eval\n-            for ( VariantContext otherComp : compSet ) {\n-                if ( otherComp != comp && ! compHasMatchingEval(otherComp, evalSetBySample) ) {\n-                    synchronized (nec) {\n-                        nec.apply(vec, otherComp, null);\n-                    }\n-                }\n-            }\n-        }\n+        System.exit(0);\n     }\n \n-    /**\n-     * Given specific eval and comp VCs and the sample name, return an iterable\n-     * over all of the applicable state keys.\n-     *\n-     * this code isn't structured yet for efficiency.  Here we currently are\n-     * doing the following inefficient algorithm:\n-     *\n-     * for each strat:\n-     *   get list of relevant states that eval and comp according to strat\n-     *   add this list of states to a list of list states\n-     *\n-     * then\n-     *\n-     * ask the strat manager to look up all of the keys associated with the combinations\n-     * of these states.  For example, suppose we have a single variant S.  We have active\n-     * strats EvalFeatureInput, CompFeatureInput, and Novelty.  We produce a list that looks like:\n-     *\n-     *   L = [[Eval], [Comp], [All, Novel]]\n-     *\n-     * We then go through the strat manager tree to produce the keys associated with these states:\n-     *\n-     *   K = [0, 1] where EVAL x COMP x ALL = 0 and EVAL x COMP x NOVEL = 1\n-     *\n-     * It's clear that a better\n-     *\n-     *\n-     * @param vec\n-     * @param eval\n-     * @param evalName\n-     * @param comp\n-     * @param compName\n-     * @param sampleName\n-     * @return\n-     */\n-    protected Collection<EvaluationContext> getEvaluationContexts(final VariantEvalContext vec,\n-                                                                  final VariantContext eval,\n-                                                                  final String evalName,\n-                                                                  final VariantContext comp,\n-                                                                  final String compName,\n-                                                                  final String sampleName,\n-                                                                  final String familyName) {\n-        final List<List<Object>> states = new LinkedList<>();\n-        for ( final VariantStratifier vs : stratManager.getStratifiers() ) {\n-            states.add(vs.getRelevantStates(vec, comp, compName, eval, evalName, sampleName, familyName));\n-        }\n-        return stratManager.values(states);\n-    }\n-\n-\n-    private boolean compHasMatchingEval(final VariantContext comp, final Collection<VariantContext> evals) {\n-        // find all of the matching comps\n-        for ( final VariantContext eval : evals ) {\n-            if ( eval != null && doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) != EvalCompMatchType.NO_MATCH )\n-                return true;\n-        }\n-\n-        // nothing matched\n-        return false;\n-    }\n-\n-    private enum EvalCompMatchType { NO_MATCH, STRICT, LENIENT }\n-\n-    private EvalCompMatchType doEvalAndCompMatch(final VariantContext eval, final VariantContext comp, boolean requireStrictAlleleMatch) {\n-        if ( comp.getType() == VariantContext.Type.NO_VARIATION || eval.getType() == VariantContext.Type.NO_VARIATION )\n-            // if either of these are NO_VARIATION they are LENIENT matches\n-            return EvalCompMatchType.LENIENT;\n-\n-        if ( comp.getType() != eval.getType() )\n-            return EvalCompMatchType.NO_MATCH;\n-\n-        // find the comp which matches both the reference allele and alternate allele from eval\n-        final Allele altEval = eval.getAlternateAlleles().size() == 0 ? null : eval.getAlternateAllele(0);\n-        final Allele altComp = comp.getAlternateAlleles().size() == 0 ? null : comp.getAlternateAllele(0);\n-        if ((altEval == null && altComp == null) || (altEval != null && altEval.equals(altComp) && eval.getReference().equals(comp.getReference())))\n-            return EvalCompMatchType.STRICT;\n-        else\n-            return requireStrictAlleleMatch ? EvalCompMatchType.NO_MATCH : EvalCompMatchType.LENIENT;\n-    }\n-\n-    private VariantContext findMatchingComp(final VariantContext eval, final Collection<VariantContext> comps) {\n-        // if no comps, return null\n-        if ( comps == null || comps.isEmpty() )\n-            return null;\n-\n-        // if no eval, return any comp\n-        if ( eval == null )\n-            return comps.iterator().next();\n-\n-        // find all of the matching comps\n-        VariantContext lenientMatch = null;\n-        for ( final VariantContext comp : comps ) {\n-            switch ( doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) ) {\n-                case STRICT:\n-                    return comp;\n-                case LENIENT:\n-                    if ( lenientMatch == null ) lenientMatch = comp;\n-                    break;\n-                case NO_MATCH:\n-                    // do nothing\n-            }\n-        }\n-\n-        // nothing matched, just return lenientMatch, which might be null\n-        return lenientMatch;\n+    @Override\n+    public void apply(final List<VariantContext> variantContexts, final ReferenceContext referenceContext, final List<ReadsContext> readsContexts) {\n+        engine.apply(variantContexts, referenceContext);\n     }\n \n     @Override\n     public Object onTraversalSuccess() {\n         logger.info(\"Finalizing variant report\");\n-        \n-        // go through the evaluations and finalize them\n-        for ( final EvaluationContext nec : stratManager.values() )\n-            for ( final VariantEvaluator ve : nec.getVariantEvaluators() )\n-                ve.finalizeEvaluation(this);\n-\n-        //send data to MetricsCollection\n-        CompOverlap compOverlap = null;\n-        IndelSummary indelSummary = null;\n-        CountVariants countVariants = null;\n-        MultiallelicSummary multiallelicSummary = null;\n-        TiTvVariantEvaluator tiTvVariantEvaluator = null;\n-        MetricsCollection metricsCollection = null;\n-        for(final EvaluationContext nec: stratManager.values()) {\n-            for(final VariantEvaluator ve : nec.getVariantEvaluators()) {\n-                if (ve instanceof CompOverlap)\n-                    compOverlap = (CompOverlap) ve;\n-                else if (ve instanceof IndelSummary)\n-                    indelSummary = (IndelSummary) ve;\n-                else if (ve instanceof CountVariants)\n-                    countVariants = (CountVariants) ve;\n-                else if (ve instanceof MultiallelicSummary)\n-                    multiallelicSummary = (MultiallelicSummary) ve;\n-                else if (ve instanceof TiTvVariantEvaluator)\n-                    tiTvVariantEvaluator = (TiTvVariantEvaluator) ve;\n-                else if (ve instanceof MetricsCollection)\n-                    metricsCollection = (MetricsCollection) ve;\n-            }\n-\n-            if(metricsCollection != null)\n-                metricsCollection.setData(compOverlap.concordantRate, indelSummary.n_SNPs, countVariants.nSNPs, indelSummary.n_indels, multiallelicSummary.nIndels, indelSummary.insertion_to_deletion_ratio, countVariants.insertionDeletionRatio, tiTvVariantEvaluator.tiTvRatio);\n-        }\n \n-        try (PrintStream out = IOUtils.makePrintStreamMaybeGzipped(new GATKPath(outFile.getAbsolutePath()))) {\n-            VariantEvalReportWriter.writeReport(out, stratManager, stratManager.getStratifiers(), stratManager.get(0).getVariantEvaluators());\n-        }\n-        catch(IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(e.getMessage(), e);\n-        }\n+        engine.finalizeReport(outFile);\n \n         return null;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MDIyNg==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547350226", "bodyText": "Same here.", "author": "cmnbroad", "createdAt": "2020-12-22T15:44:00Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -318,60 +213,60 @@ public void onTraversalStart() {\n \n         sampleDB = initializeSampleDB();\n \n-        comps.addAll(compsProvided);\n-        compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n-        if ( dbsnp.dbsnp != null ) {\n-            comps.add(dbsnp.dbsnp);\n-            inputToNameMap.put(dbsnp.dbsnp, \"dbsnp\");\n-            knowns.add(dbsnp.dbsnp);\n+        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n+        variantEvalArgs.compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n+        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n+            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n+            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n+            variantEvalArgs.knowns.add(variantEvalArgs.dbsnp.dbsnp);\n         }\n \n-        evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));\n+        variantEvalArgs.evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));\n \n-        // Set up set of additional knowns\n-        for ( FeatureInput<VariantContext> compInput : comps ) {\n-            if ( KNOWN_NAMES.contains(getNameForInput(compInput)))\n-                knowns.add(compInput);\n+        // Set up set of additional knowns. dbSNP was addressed above, so use compsProvided, not comps\n+        for ( FeatureInput<VariantContext> compInput : variantEvalArgs.compsProvided ) {\n+            if (variantEvalArgs.KNOWN_NAMES.contains(getNameForInput(compInput)))\n+                variantEvalArgs.knowns.add(compInput);\n         }\n \n         // Now that we have all the inputs categorized, determine the sample list from the eval inputs.\n         Map<String, VCFHeader> vcfInputs = new HashMap<>();\n-        evals.forEach(x -> vcfInputs.put(x.getName(), (VCFHeader)getHeaderForFeatures(x)));\n+        variantEvalArgs.evals.forEach(x -> vcfInputs.put(x.getName(), (VCFHeader)getHeaderForFeatures(x)));", "originalCommit": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\nindex 0db5f4b1e..28780906a 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n\n@@ -163,474 +135,55 @@ public class VariantEval extends MultiVariantWalkerGroupedOnStart {\n \n     @Override\n     protected void initializeDrivingVariants() {\n-        getDrivingVariantsFeatureInputs().addAll(variantEvalArgs.getEvals());\n-        if (variantEvalArgs.dbsnp.dbsnp != null) {\n-            getDrivingVariantsFeatureInputs().add(variantEvalArgs.dbsnp.dbsnp);\n-        }\n-\n-        getDrivingVariantsFeatureInputs().addAll(variantEvalArgs.compsProvided);\n+        getDrivingVariantsFeatureInputs().addAll(VariantEvalEngine.getFeatureInputsForDrivingVariants(variantEvalArgs));\n \n         super.initializeDrivingVariants();\n     }\n \n-    // Variables\n-    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n-\n-    private boolean isSubsettingSamples;\n-    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n-    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n-    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n-    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n-\n-    // important stratifications\n-    private boolean byFilterIsEnabled = false;\n-    private boolean perSampleIsEnabled = false;\n-    private boolean perFamilyIsEnabled = false;\n-\n-    // Utility class\n-    private final VariantEvalUtils variantEvalUtils = new VariantEvalUtils(this);\n-\n-    // Ancestral alignments\n-    private ReferenceSequenceFile ancestralAlignments = null;\n-\n-    // The set of all possible evaluation contexts\n-    StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n-\n-    private SampleDB sampleDB = null;\n-\n-    // maintain the mapping of FeatureInput to name used in output file\n-    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n-\n-    /**\n-     * Initialize the stratifications, evaluations, evaluation contexts, and reporting object\n-     */\n     @Override\n     public void onTraversalStart() {\n-        Utils.nonNull(outFile);\n-\n         // Just list the modules, and exit quickly.\n-        if (LIST) { variantEvalUtils.listModulesAndExit(); }\n-\n-        sampleDB = initializeSampleDB();\n-\n-        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n-        variantEvalArgs.compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n-        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n-            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n-            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n-            variantEvalArgs.knowns.add(variantEvalArgs.dbsnp.dbsnp);\n-        }\n-\n-        variantEvalArgs.evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));\n-\n-        // Set up set of additional knowns. dbSNP was addressed above, so use compsProvided, not comps\n-        for ( FeatureInput<VariantContext> compInput : variantEvalArgs.compsProvided ) {\n-            if (variantEvalArgs.KNOWN_NAMES.contains(getNameForInput(compInput)))\n-                variantEvalArgs.knowns.add(compInput);\n-        }\n-\n-        // Now that we have all the inputs categorized, determine the sample list from the eval inputs.\n-        Map<String, VCFHeader> vcfInputs = new HashMap<>();\n-        variantEvalArgs.evals.forEach(x -> vcfInputs.put(x.getName(), (VCFHeader)getHeaderForFeatures(x)));\n-\n-        Set<String> vcfSamples = new HashSet<>();\n-        vcfInputs.forEach((k,v) -> vcfSamples.addAll(v.getSampleNamesInOrder()));\n-\n-        // Load the sample list, using an intermediate tree set to sort the samples\n-        final Set<String> allSampleNames = new HashSet<>(vcfSamples);\n-        sampleNamesForEvaluation.addAll(new TreeSet<>(variantEvalArgs.SAMPLE_EXPRESSIONS.isEmpty() ? vcfSamples : Utils.filterCollectionByExpressions(vcfSamples, variantEvalArgs.SAMPLE_EXPRESSIONS, false)));\n-\n-        isSubsettingSamples = ! sampleNamesForEvaluation.containsAll(allSampleNames);\n-        familyNamesForEvaluation.addAll(sampleDB.getFamilyIDs());\n-\n-        //If stratifying by sample name, assign a stratification for each sample we're evaluating (based on commandline args)...\n-        if (variantEvalArgs.STRATIFICATIONS_TO_USE.contains(\"Sample\") ) {\n-            sampleNamesForStratification.addAll(sampleNamesForEvaluation);\n-        }\n-        //...and also a stratification for the sum over all samples\n-        sampleNamesForStratification.add(VariantEvalArgumentCollection.ALL_SAMPLE_NAME);\n-\n-        //If stratifying by sample name, assign a stratification for each family...\n-        if ( variantEvalArgs.STRATIFICATIONS_TO_USE.contains(\"Family\") ) {\n-            familyNamesForStratification.addAll(familyNamesForEvaluation);\n-        }\n-        //...and also a stratification for the sum over all families\n-        familyNamesForStratification.add(VariantEvalArgumentCollection.ALL_FAMILY_NAME);\n-\n-        // Initialize select expressions\n-        for (VariantContextUtils.JexlVCMatchExp jexl : VariantContextUtils.initializeMatchExps(variantEvalArgs.SELECT_NAMES, variantEvalArgs.SELECT_EXPS)) {\n-            SortableJexlVCMatchExp sjexl = new SortableJexlVCMatchExp(jexl.name, jexl.exp);\n-            jexlExpressions.add(sjexl);\n-        }\n-\n-        // Initialize the set of stratifications and evaluations to use\n-        // The list of stratifiers and evaluators to use\n-        final List<VariantStratifier> stratificationObjects = variantEvalUtils.initializeStratificationObjects(variantEvalArgs.NO_STANDARD_STRATIFICATIONS, variantEvalArgs.STRATIFICATIONS_TO_USE);\n-        final Set<Class<? extends VariantEvaluator>> evaluationClasses = variantEvalUtils.initializeEvaluationObjects(variantEvalArgs.NO_STANDARD_MODULES, variantEvalArgs.MODULES_TO_USE);\n-\n-        checkForIncompatibleEvaluatorsAndStratifiers(stratificationObjects, evaluationClasses);\n-\n-        for ( VariantStratifier vs : stratificationObjects ) {\n-            if ( vs.getName().equals(\"Filter\") )\n-                byFilterIsEnabled = true;\n-            else if ( vs.getName().equals(\"Sample\") )\n-                perSampleIsEnabled = true;\n-            else if ( vs.getName().equals(\"Family\"))\n-                perFamilyIsEnabled = true;\n-        }\n-\n-        if (perSampleIsEnabled && perFamilyIsEnabled)\n-            throw new CommandLineException.BadArgumentValue(\"ST\", \"Variants cannot be stratified by sample and family at the same time\");\n-\n-        if (perFamilyIsEnabled && sampleDB.getTrios().isEmpty())\n-            throw new CommandLineException.BadArgumentValue(\"ST\", \"Cannot stratify by family without *.ped file\");\n-\n-\n-        if ( variantEvalArgs.intervalsFile != null ) {\n-            boolean fail = true;\n-            for ( final VariantStratifier vs : stratificationObjects ) {\n-                if ( vs.getClass().equals(IntervalStratification.class) )\n-                    fail = false;\n-            }\n-            if ( fail )\n-                throw new CommandLineException.BadArgumentValue(\"ST\", \"stratIntervals argument provided but -ST IntervalStratification not provided\");\n-        }\n-\n-        // Initialize the evaluation contexts\n-        createStratificationStates(stratificationObjects, evaluationClasses);\n-\n-        // Load ancestral alignments\n-        if (variantEvalArgs.ancestralAlignmentsFile != null) {\n-            try {\n-                ancestralAlignments = new IndexedFastaSequenceFile(variantEvalArgs.ancestralAlignmentsFile.toPath());\n-            } catch (FileNotFoundException e) {\n-                throw new GATKException(String.format(\"The ancestral alignments file, '%s', could not be found\", variantEvalArgs.ancestralAlignmentsFile.getAbsolutePath()));\n-            }\n-        }\n-\n-        assertThatTerritoryIsSpecifiedIfNecessary();\n-    }\n-\n-    private void assertThatTerritoryIsSpecifiedIfNecessary() {\n-        final Set<String> evaluatorsWhichRequireTerritory = stratManager.values()\n-                .stream()\n-                .flatMap(ctx -> ctx.getVariantEvaluators().stream())\n-                .filter(Objects::nonNull)\n-                .filter(VariantEvaluator::requiresTerritoryToBeSpecified)\n-                .map(VariantEvaluator::getSimpleName)\n-                .collect(Collectors.toSet());\n-        if(!evaluatorsWhichRequireTerritory.isEmpty() && getTraversalIntervals() == null){\n-            throw new UserException(\"You specified evaluators which require a covered territory to be specified.  \" +\n-                    \"\\nPlease specify intervals or a reference file or disable all of the following evaluators:\" +\n-                    evaluatorsWhichRequireTerritory.stream()\n-                            .collect(Collectors.joining(\", \")));\n-        }\n-    }\n-\n-    private void checkForIncompatibleEvaluatorsAndStratifiers( final List<VariantStratifier> stratificationObjects,\n-                                                             Set<Class<? extends VariantEvaluator>> evaluationClasses) {\n-        for ( final VariantStratifier vs : stratificationObjects ) {\n-            for ( Class<? extends VariantEvaluator> ec : evaluationClasses )\n-                if ( vs.getIncompatibleEvaluators().contains(ec) )\n-                    throw new CommandLineException.BadArgumentValue(\"ST and ET\",\n-                            \"The selected stratification \" + vs.getName() +\n-                                    \" and evaluator \" + ec.getSimpleName() +\n-                                    \" are incompatible due to combinatorial memory requirements.\" +\n-                                    \" Please disable one\");\n-        }\n-    }\n+        if (LIST) { listModulesAndExit(); }\n \n-    final void createStratificationStates(final List<VariantStratifier> stratificationObjects, final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n-        final List<VariantStratifier> strats = new ArrayList<VariantStratifier>(stratificationObjects);\n-        stratManager = new StratificationManager<>(strats);\n+        Utils.nonNull(outFile);\n+        IOUtil.assertFileIsWritable(outFile);\n \n-        logger.info(\"Creating \" + stratManager.size() + \" combinatorial stratification states\");\n-        for ( int i = 0; i < stratManager.size(); i++ ) {\n-            EvaluationContext ec = createEvaluationContext(evaluationObjects);\n-            stratManager.set(i, ec);\n-        }\n+        engine = new VariantEvalEngine(variantEvalArgs, this, getSequenceDictionaryForDrivingVariants(), getSamplesForVariants(), logger);\n     }\n \n     /**\n-     * Create the EvaluationContext (new instance) for the provided set of VariantEvaluators.\n-     *\n-     * @param evaluationObjects The list of VariantEvaluator classes\n-     * @return The EvaluationContext for this set of VariantEvaluator classes\n+     * List all of the available evaluation modules, then exit successfully\n      */\n-    protected EvaluationContext createEvaluationContext(final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n-        return new EvaluationContext(this, evaluationObjects);\n-    }\n-\n-    public String getNameForInput(FeatureInput<VariantContext> input) {\n-        return inputToNameMap.get(input);\n-    }\n-\n-    @Override\n-    public void apply(List<VariantContext> variantContexts, ReferenceContext referenceContext, List<ReadsContext> readsContexts) {\n-        Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap = groupVariantsByFeatureInput(variantContexts);\n-\n-        List<VariantContext> allEvals = new ArrayList<>();\n-        for (FeatureInput<VariantContext> eval : variantEvalArgs.getEvals()) {\n-            if (variantMap.containsKey(eval)) {\n-                allEvals.addAll(variantMap.get(eval));\n-            }\n-        }\n-\n-        List<VariantContext> allComps = new ArrayList<>();\n-        if (variantEvalArgs.getComps() != null) {\n-            for (FeatureInput<VariantContext> comp : variantEvalArgs.getComps()) {\n-                if (variantMap.containsKey(comp)) {\n-                    allComps.addAll(variantMap.get(comp));\n-                }\n-            }\n-        }\n-\n-        SimpleInterval interval = allEvals.isEmpty() ? new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), variantContexts.get(0).getStart()) : generateContextInterval(allEvals);\n-        FeatureContext featureContext = new FeatureContext(features, interval);\n-\n-        Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> evalVCs = allEvals.isEmpty() ? Collections.emptyMap() : variantEvalUtils.bindVariantContexts(variantMap, variantEvalArgs.getEvals(), byFilterIsEnabled, true, perSampleIsEnabled, perFamilyIsEnabled, variantEvalArgs.mergeEvals);\n-        Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs = allComps.isEmpty() ? Collections.emptyMap() : variantEvalUtils.bindVariantContexts(variantMap, variantEvalArgs.getComps(), byFilterIsEnabled, false, false, false, false);\n-\n-        VariantEvalContext variantEvalContext = new VariantEvalContext(referenceContext, featureContext, variantMap, getVariantEvalArgs(), this);\n-\n-        // for each eval track\n-        for ( final FeatureInput<VariantContext> evalInput : variantEvalArgs.getEvals() ) {\n-            final Map<String, Collection<VariantContext>> evalSet = evalVCs.containsKey(evalInput) ? evalVCs.get(evalInput) : Collections.emptyMap();\n-\n-            Set<String> statificationLevels;\n+    public void listModulesAndExit() {\n+        logger.info(\"Available stratification modules:\");\n+        logger.info(\"(Standard modules are starred)\");\n \n-            // for each sample stratifier\n-            if (perFamilyIsEnabled)\n-                statificationLevels = familyNamesForStratification;\n-            else\n-                statificationLevels = sampleNamesForStratification;\n-            for ( final String stratLevelName : statificationLevels ) {\n-                Collection<VariantContext> evalSetBySample = evalSet.get(stratLevelName);\n+        for (String name: VariantEvalEngine.getStratifierClasses().keySet()) {\n \n-                if ( evalSetBySample == null ) {\n-                    evalSetBySample = new HashSet<>(1);\n-                    evalSetBySample.add(null);\n-                }\n-\n-                // for each eval in the track\n-                for ( VariantContext eval : evalSetBySample ) {\n-                    String aastr = (ancestralAlignments == null) ? null : new String(ancestralAlignments.getSubsequenceAt(eval.getContig(), eval.getStart(), eval.getEnd()).getBases());\n-\n-                    // deal with ancestral alleles if requested\n-                    if ( eval != null && aastr != null ) {\n-                        eval = new VariantContextBuilder(eval).attribute(\"ANCESTRALALLELE\", aastr).make();\n-                    }\n-\n-                    String evalName = getNameForInput(evalInput);\n-\n-                    // for each comp track\n-                    for ( final FeatureInput<VariantContext> compInput : variantEvalArgs.comps ) {\n-                        processComp(variantEvalContext, eval, evalName, compInput, stratLevelName, compVCs, evalSetBySample);\n-                    }\n-\n-                    if (variantEvalArgs.comps.isEmpty()) {\n-                        processComp(variantEvalContext, eval, evalName, null, stratLevelName, compVCs, evalSetBySample);\n-                    }\n-                }\n-            }\n-\n-            if ( variantEvalArgs.mergeEvals ) break; // stop processing the eval tracks\n+            logger.info(\"\\t\" + name + (VariantEvalEngine.getRequiredStratificationNames().contains(name) || VariantEvalEngine.getStandardStratificationNames().contains(name) ? \"*\" : \"\"));\n         }\n-    }\n+        logger.info(\"\");\n \n-    private SimpleInterval generateContextInterval(List<VariantContext> variantContexts) {\n-        int maxEnd = variantContexts.stream().map(VariantContext::getEnd).max(Integer::compareTo).get();\n-\n-        return new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), maxEnd);\n-    }\n-\n-    private void processComp(VariantEvalContext vec, VariantContext eval, String evalName, FeatureInput<VariantContext> compInput, String stratLevelName, Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs, Collection<VariantContext> evalSetBySample) {\n-        String compName = getNameForInput(compInput);\n-\n-        // no sample stratification for comps\n-        final HashMap<String, Collection<VariantContext>> compSetHash = compInput == null ? null : compVCs.get(compInput);\n-        final Collection<VariantContext> compSet = (compSetHash == null || compSetHash.isEmpty()) ? Collections.<VariantContext>emptyList() : compVCs.get(compInput).values().iterator().next();\n-\n-        // find the comp\n-        final VariantContext comp = findMatchingComp(eval, compSet);\n-\n-        Collection<EvaluationContext> contextsForStratification;\n-        if (perFamilyIsEnabled)\n-            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, null, stratLevelName);\n-        else {\n-            String familyID;\n-            if (stratLevelName.equals(\"all\"))\n-                familyID = \"all\";\n-            else\n-                familyID = sampleDB.getSample(stratLevelName).getFamilyID();\n-            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, stratLevelName, familyID);\n+        logger.info(\"Available evaluation modules:\");\n+        logger.info(\"(Standard modules are starred)\");\n+        for (String veName : VariantEvalEngine.getEvaluatorClasses().keySet()) {\n+            logger.info(\"\\t\" + veName + (VariantEvalEngine.getStandardEvaluatorNames().contains(veName) ? \"*\" : \"\"));\n         }\n-        for ( EvaluationContext nec : contextsForStratification ) {\n+        logger.info(\"\");\n \n-            // eval against the comp\n-            synchronized (nec) {\n-                nec.apply(vec, comp, eval);\n-            }\n-\n-            // eval=null against all comps of different type that aren't bound to another eval\n-            for ( VariantContext otherComp : compSet ) {\n-                if ( otherComp != comp && ! compHasMatchingEval(otherComp, evalSetBySample) ) {\n-                    synchronized (nec) {\n-                        nec.apply(vec, otherComp, null);\n-                    }\n-                }\n-            }\n-        }\n+        System.exit(0);\n     }\n \n-    /**\n-     * Given specific eval and comp VCs and the sample name, return an iterable\n-     * over all of the applicable state keys.\n-     *\n-     * this code isn't structured yet for efficiency.  Here we currently are\n-     * doing the following inefficient algorithm:\n-     *\n-     * for each strat:\n-     *   get list of relevant states that eval and comp according to strat\n-     *   add this list of states to a list of list states\n-     *\n-     * then\n-     *\n-     * ask the strat manager to look up all of the keys associated with the combinations\n-     * of these states.  For example, suppose we have a single variant S.  We have active\n-     * strats EvalFeatureInput, CompFeatureInput, and Novelty.  We produce a list that looks like:\n-     *\n-     *   L = [[Eval], [Comp], [All, Novel]]\n-     *\n-     * We then go through the strat manager tree to produce the keys associated with these states:\n-     *\n-     *   K = [0, 1] where EVAL x COMP x ALL = 0 and EVAL x COMP x NOVEL = 1\n-     *\n-     * It's clear that a better\n-     *\n-     *\n-     * @param vec\n-     * @param eval\n-     * @param evalName\n-     * @param comp\n-     * @param compName\n-     * @param sampleName\n-     * @return\n-     */\n-    protected Collection<EvaluationContext> getEvaluationContexts(final VariantEvalContext vec,\n-                                                                  final VariantContext eval,\n-                                                                  final String evalName,\n-                                                                  final VariantContext comp,\n-                                                                  final String compName,\n-                                                                  final String sampleName,\n-                                                                  final String familyName) {\n-        final List<List<Object>> states = new LinkedList<>();\n-        for ( final VariantStratifier vs : stratManager.getStratifiers() ) {\n-            states.add(vs.getRelevantStates(vec, comp, compName, eval, evalName, sampleName, familyName));\n-        }\n-        return stratManager.values(states);\n-    }\n-\n-\n-    private boolean compHasMatchingEval(final VariantContext comp, final Collection<VariantContext> evals) {\n-        // find all of the matching comps\n-        for ( final VariantContext eval : evals ) {\n-            if ( eval != null && doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) != EvalCompMatchType.NO_MATCH )\n-                return true;\n-        }\n-\n-        // nothing matched\n-        return false;\n-    }\n-\n-    private enum EvalCompMatchType { NO_MATCH, STRICT, LENIENT }\n-\n-    private EvalCompMatchType doEvalAndCompMatch(final VariantContext eval, final VariantContext comp, boolean requireStrictAlleleMatch) {\n-        if ( comp.getType() == VariantContext.Type.NO_VARIATION || eval.getType() == VariantContext.Type.NO_VARIATION )\n-            // if either of these are NO_VARIATION they are LENIENT matches\n-            return EvalCompMatchType.LENIENT;\n-\n-        if ( comp.getType() != eval.getType() )\n-            return EvalCompMatchType.NO_MATCH;\n-\n-        // find the comp which matches both the reference allele and alternate allele from eval\n-        final Allele altEval = eval.getAlternateAlleles().size() == 0 ? null : eval.getAlternateAllele(0);\n-        final Allele altComp = comp.getAlternateAlleles().size() == 0 ? null : comp.getAlternateAllele(0);\n-        if ((altEval == null && altComp == null) || (altEval != null && altEval.equals(altComp) && eval.getReference().equals(comp.getReference())))\n-            return EvalCompMatchType.STRICT;\n-        else\n-            return requireStrictAlleleMatch ? EvalCompMatchType.NO_MATCH : EvalCompMatchType.LENIENT;\n-    }\n-\n-    private VariantContext findMatchingComp(final VariantContext eval, final Collection<VariantContext> comps) {\n-        // if no comps, return null\n-        if ( comps == null || comps.isEmpty() )\n-            return null;\n-\n-        // if no eval, return any comp\n-        if ( eval == null )\n-            return comps.iterator().next();\n-\n-        // find all of the matching comps\n-        VariantContext lenientMatch = null;\n-        for ( final VariantContext comp : comps ) {\n-            switch ( doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) ) {\n-                case STRICT:\n-                    return comp;\n-                case LENIENT:\n-                    if ( lenientMatch == null ) lenientMatch = comp;\n-                    break;\n-                case NO_MATCH:\n-                    // do nothing\n-            }\n-        }\n-\n-        // nothing matched, just return lenientMatch, which might be null\n-        return lenientMatch;\n+    @Override\n+    public void apply(final List<VariantContext> variantContexts, final ReferenceContext referenceContext, final List<ReadsContext> readsContexts) {\n+        engine.apply(variantContexts, referenceContext);\n     }\n \n     @Override\n     public Object onTraversalSuccess() {\n         logger.info(\"Finalizing variant report\");\n-        \n-        // go through the evaluations and finalize them\n-        for ( final EvaluationContext nec : stratManager.values() )\n-            for ( final VariantEvaluator ve : nec.getVariantEvaluators() )\n-                ve.finalizeEvaluation(this);\n-\n-        //send data to MetricsCollection\n-        CompOverlap compOverlap = null;\n-        IndelSummary indelSummary = null;\n-        CountVariants countVariants = null;\n-        MultiallelicSummary multiallelicSummary = null;\n-        TiTvVariantEvaluator tiTvVariantEvaluator = null;\n-        MetricsCollection metricsCollection = null;\n-        for(final EvaluationContext nec: stratManager.values()) {\n-            for(final VariantEvaluator ve : nec.getVariantEvaluators()) {\n-                if (ve instanceof CompOverlap)\n-                    compOverlap = (CompOverlap) ve;\n-                else if (ve instanceof IndelSummary)\n-                    indelSummary = (IndelSummary) ve;\n-                else if (ve instanceof CountVariants)\n-                    countVariants = (CountVariants) ve;\n-                else if (ve instanceof MultiallelicSummary)\n-                    multiallelicSummary = (MultiallelicSummary) ve;\n-                else if (ve instanceof TiTvVariantEvaluator)\n-                    tiTvVariantEvaluator = (TiTvVariantEvaluator) ve;\n-                else if (ve instanceof MetricsCollection)\n-                    metricsCollection = (MetricsCollection) ve;\n-            }\n-\n-            if(metricsCollection != null)\n-                metricsCollection.setData(compOverlap.concordantRate, indelSummary.n_SNPs, countVariants.nSNPs, indelSummary.n_indels, multiallelicSummary.nIndels, indelSummary.insertion_to_deletion_ratio, countVariants.insertionDeletionRatio, tiTvVariantEvaluator.tiTvRatio);\n-        }\n \n-        try (PrintStream out = IOUtils.makePrintStreamMaybeGzipped(new GATKPath(outFile.getAbsolutePath()))) {\n-            VariantEvalReportWriter.writeReport(out, stratManager, stratManager.getStratifiers(), stratManager.get(0).getVariantEvaluators());\n-        }\n-        catch(IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(e.getMessage(), e);\n-        }\n+        engine.finalizeReport(outFile);\n \n         return null;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjcwMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547352701", "bodyText": "So long, PositionAggregator.", "author": "cmnbroad", "createdAt": "2020-12-22T15:48:32Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -466,66 +361,41 @@ protected EvaluationContext createEvaluationContext(final Set<Class<? extends Va\n         return new EvaluationContext(this, evaluationObjects);\n     }\n \n-    private class PositionAggregator {", "originalCommit": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\nindex 0db5f4b1e..28780906a 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n\n@@ -163,474 +135,55 @@ public class VariantEval extends MultiVariantWalkerGroupedOnStart {\n \n     @Override\n     protected void initializeDrivingVariants() {\n-        getDrivingVariantsFeatureInputs().addAll(variantEvalArgs.getEvals());\n-        if (variantEvalArgs.dbsnp.dbsnp != null) {\n-            getDrivingVariantsFeatureInputs().add(variantEvalArgs.dbsnp.dbsnp);\n-        }\n-\n-        getDrivingVariantsFeatureInputs().addAll(variantEvalArgs.compsProvided);\n+        getDrivingVariantsFeatureInputs().addAll(VariantEvalEngine.getFeatureInputsForDrivingVariants(variantEvalArgs));\n \n         super.initializeDrivingVariants();\n     }\n \n-    // Variables\n-    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n-\n-    private boolean isSubsettingSamples;\n-    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n-    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n-    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n-    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n-\n-    // important stratifications\n-    private boolean byFilterIsEnabled = false;\n-    private boolean perSampleIsEnabled = false;\n-    private boolean perFamilyIsEnabled = false;\n-\n-    // Utility class\n-    private final VariantEvalUtils variantEvalUtils = new VariantEvalUtils(this);\n-\n-    // Ancestral alignments\n-    private ReferenceSequenceFile ancestralAlignments = null;\n-\n-    // The set of all possible evaluation contexts\n-    StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n-\n-    private SampleDB sampleDB = null;\n-\n-    // maintain the mapping of FeatureInput to name used in output file\n-    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n-\n-    /**\n-     * Initialize the stratifications, evaluations, evaluation contexts, and reporting object\n-     */\n     @Override\n     public void onTraversalStart() {\n-        Utils.nonNull(outFile);\n-\n         // Just list the modules, and exit quickly.\n-        if (LIST) { variantEvalUtils.listModulesAndExit(); }\n-\n-        sampleDB = initializeSampleDB();\n-\n-        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n-        variantEvalArgs.compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n-        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n-            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n-            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n-            variantEvalArgs.knowns.add(variantEvalArgs.dbsnp.dbsnp);\n-        }\n-\n-        variantEvalArgs.evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));\n-\n-        // Set up set of additional knowns. dbSNP was addressed above, so use compsProvided, not comps\n-        for ( FeatureInput<VariantContext> compInput : variantEvalArgs.compsProvided ) {\n-            if (variantEvalArgs.KNOWN_NAMES.contains(getNameForInput(compInput)))\n-                variantEvalArgs.knowns.add(compInput);\n-        }\n-\n-        // Now that we have all the inputs categorized, determine the sample list from the eval inputs.\n-        Map<String, VCFHeader> vcfInputs = new HashMap<>();\n-        variantEvalArgs.evals.forEach(x -> vcfInputs.put(x.getName(), (VCFHeader)getHeaderForFeatures(x)));\n-\n-        Set<String> vcfSamples = new HashSet<>();\n-        vcfInputs.forEach((k,v) -> vcfSamples.addAll(v.getSampleNamesInOrder()));\n-\n-        // Load the sample list, using an intermediate tree set to sort the samples\n-        final Set<String> allSampleNames = new HashSet<>(vcfSamples);\n-        sampleNamesForEvaluation.addAll(new TreeSet<>(variantEvalArgs.SAMPLE_EXPRESSIONS.isEmpty() ? vcfSamples : Utils.filterCollectionByExpressions(vcfSamples, variantEvalArgs.SAMPLE_EXPRESSIONS, false)));\n-\n-        isSubsettingSamples = ! sampleNamesForEvaluation.containsAll(allSampleNames);\n-        familyNamesForEvaluation.addAll(sampleDB.getFamilyIDs());\n-\n-        //If stratifying by sample name, assign a stratification for each sample we're evaluating (based on commandline args)...\n-        if (variantEvalArgs.STRATIFICATIONS_TO_USE.contains(\"Sample\") ) {\n-            sampleNamesForStratification.addAll(sampleNamesForEvaluation);\n-        }\n-        //...and also a stratification for the sum over all samples\n-        sampleNamesForStratification.add(VariantEvalArgumentCollection.ALL_SAMPLE_NAME);\n-\n-        //If stratifying by sample name, assign a stratification for each family...\n-        if ( variantEvalArgs.STRATIFICATIONS_TO_USE.contains(\"Family\") ) {\n-            familyNamesForStratification.addAll(familyNamesForEvaluation);\n-        }\n-        //...and also a stratification for the sum over all families\n-        familyNamesForStratification.add(VariantEvalArgumentCollection.ALL_FAMILY_NAME);\n-\n-        // Initialize select expressions\n-        for (VariantContextUtils.JexlVCMatchExp jexl : VariantContextUtils.initializeMatchExps(variantEvalArgs.SELECT_NAMES, variantEvalArgs.SELECT_EXPS)) {\n-            SortableJexlVCMatchExp sjexl = new SortableJexlVCMatchExp(jexl.name, jexl.exp);\n-            jexlExpressions.add(sjexl);\n-        }\n-\n-        // Initialize the set of stratifications and evaluations to use\n-        // The list of stratifiers and evaluators to use\n-        final List<VariantStratifier> stratificationObjects = variantEvalUtils.initializeStratificationObjects(variantEvalArgs.NO_STANDARD_STRATIFICATIONS, variantEvalArgs.STRATIFICATIONS_TO_USE);\n-        final Set<Class<? extends VariantEvaluator>> evaluationClasses = variantEvalUtils.initializeEvaluationObjects(variantEvalArgs.NO_STANDARD_MODULES, variantEvalArgs.MODULES_TO_USE);\n-\n-        checkForIncompatibleEvaluatorsAndStratifiers(stratificationObjects, evaluationClasses);\n-\n-        for ( VariantStratifier vs : stratificationObjects ) {\n-            if ( vs.getName().equals(\"Filter\") )\n-                byFilterIsEnabled = true;\n-            else if ( vs.getName().equals(\"Sample\") )\n-                perSampleIsEnabled = true;\n-            else if ( vs.getName().equals(\"Family\"))\n-                perFamilyIsEnabled = true;\n-        }\n-\n-        if (perSampleIsEnabled && perFamilyIsEnabled)\n-            throw new CommandLineException.BadArgumentValue(\"ST\", \"Variants cannot be stratified by sample and family at the same time\");\n-\n-        if (perFamilyIsEnabled && sampleDB.getTrios().isEmpty())\n-            throw new CommandLineException.BadArgumentValue(\"ST\", \"Cannot stratify by family without *.ped file\");\n-\n-\n-        if ( variantEvalArgs.intervalsFile != null ) {\n-            boolean fail = true;\n-            for ( final VariantStratifier vs : stratificationObjects ) {\n-                if ( vs.getClass().equals(IntervalStratification.class) )\n-                    fail = false;\n-            }\n-            if ( fail )\n-                throw new CommandLineException.BadArgumentValue(\"ST\", \"stratIntervals argument provided but -ST IntervalStratification not provided\");\n-        }\n-\n-        // Initialize the evaluation contexts\n-        createStratificationStates(stratificationObjects, evaluationClasses);\n-\n-        // Load ancestral alignments\n-        if (variantEvalArgs.ancestralAlignmentsFile != null) {\n-            try {\n-                ancestralAlignments = new IndexedFastaSequenceFile(variantEvalArgs.ancestralAlignmentsFile.toPath());\n-            } catch (FileNotFoundException e) {\n-                throw new GATKException(String.format(\"The ancestral alignments file, '%s', could not be found\", variantEvalArgs.ancestralAlignmentsFile.getAbsolutePath()));\n-            }\n-        }\n-\n-        assertThatTerritoryIsSpecifiedIfNecessary();\n-    }\n-\n-    private void assertThatTerritoryIsSpecifiedIfNecessary() {\n-        final Set<String> evaluatorsWhichRequireTerritory = stratManager.values()\n-                .stream()\n-                .flatMap(ctx -> ctx.getVariantEvaluators().stream())\n-                .filter(Objects::nonNull)\n-                .filter(VariantEvaluator::requiresTerritoryToBeSpecified)\n-                .map(VariantEvaluator::getSimpleName)\n-                .collect(Collectors.toSet());\n-        if(!evaluatorsWhichRequireTerritory.isEmpty() && getTraversalIntervals() == null){\n-            throw new UserException(\"You specified evaluators which require a covered territory to be specified.  \" +\n-                    \"\\nPlease specify intervals or a reference file or disable all of the following evaluators:\" +\n-                    evaluatorsWhichRequireTerritory.stream()\n-                            .collect(Collectors.joining(\", \")));\n-        }\n-    }\n-\n-    private void checkForIncompatibleEvaluatorsAndStratifiers( final List<VariantStratifier> stratificationObjects,\n-                                                             Set<Class<? extends VariantEvaluator>> evaluationClasses) {\n-        for ( final VariantStratifier vs : stratificationObjects ) {\n-            for ( Class<? extends VariantEvaluator> ec : evaluationClasses )\n-                if ( vs.getIncompatibleEvaluators().contains(ec) )\n-                    throw new CommandLineException.BadArgumentValue(\"ST and ET\",\n-                            \"The selected stratification \" + vs.getName() +\n-                                    \" and evaluator \" + ec.getSimpleName() +\n-                                    \" are incompatible due to combinatorial memory requirements.\" +\n-                                    \" Please disable one\");\n-        }\n-    }\n+        if (LIST) { listModulesAndExit(); }\n \n-    final void createStratificationStates(final List<VariantStratifier> stratificationObjects, final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n-        final List<VariantStratifier> strats = new ArrayList<VariantStratifier>(stratificationObjects);\n-        stratManager = new StratificationManager<>(strats);\n+        Utils.nonNull(outFile);\n+        IOUtil.assertFileIsWritable(outFile);\n \n-        logger.info(\"Creating \" + stratManager.size() + \" combinatorial stratification states\");\n-        for ( int i = 0; i < stratManager.size(); i++ ) {\n-            EvaluationContext ec = createEvaluationContext(evaluationObjects);\n-            stratManager.set(i, ec);\n-        }\n+        engine = new VariantEvalEngine(variantEvalArgs, this, getSequenceDictionaryForDrivingVariants(), getSamplesForVariants(), logger);\n     }\n \n     /**\n-     * Create the EvaluationContext (new instance) for the provided set of VariantEvaluators.\n-     *\n-     * @param evaluationObjects The list of VariantEvaluator classes\n-     * @return The EvaluationContext for this set of VariantEvaluator classes\n+     * List all of the available evaluation modules, then exit successfully\n      */\n-    protected EvaluationContext createEvaluationContext(final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n-        return new EvaluationContext(this, evaluationObjects);\n-    }\n-\n-    public String getNameForInput(FeatureInput<VariantContext> input) {\n-        return inputToNameMap.get(input);\n-    }\n-\n-    @Override\n-    public void apply(List<VariantContext> variantContexts, ReferenceContext referenceContext, List<ReadsContext> readsContexts) {\n-        Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap = groupVariantsByFeatureInput(variantContexts);\n-\n-        List<VariantContext> allEvals = new ArrayList<>();\n-        for (FeatureInput<VariantContext> eval : variantEvalArgs.getEvals()) {\n-            if (variantMap.containsKey(eval)) {\n-                allEvals.addAll(variantMap.get(eval));\n-            }\n-        }\n-\n-        List<VariantContext> allComps = new ArrayList<>();\n-        if (variantEvalArgs.getComps() != null) {\n-            for (FeatureInput<VariantContext> comp : variantEvalArgs.getComps()) {\n-                if (variantMap.containsKey(comp)) {\n-                    allComps.addAll(variantMap.get(comp));\n-                }\n-            }\n-        }\n-\n-        SimpleInterval interval = allEvals.isEmpty() ? new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), variantContexts.get(0).getStart()) : generateContextInterval(allEvals);\n-        FeatureContext featureContext = new FeatureContext(features, interval);\n-\n-        Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> evalVCs = allEvals.isEmpty() ? Collections.emptyMap() : variantEvalUtils.bindVariantContexts(variantMap, variantEvalArgs.getEvals(), byFilterIsEnabled, true, perSampleIsEnabled, perFamilyIsEnabled, variantEvalArgs.mergeEvals);\n-        Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs = allComps.isEmpty() ? Collections.emptyMap() : variantEvalUtils.bindVariantContexts(variantMap, variantEvalArgs.getComps(), byFilterIsEnabled, false, false, false, false);\n-\n-        VariantEvalContext variantEvalContext = new VariantEvalContext(referenceContext, featureContext, variantMap, getVariantEvalArgs(), this);\n-\n-        // for each eval track\n-        for ( final FeatureInput<VariantContext> evalInput : variantEvalArgs.getEvals() ) {\n-            final Map<String, Collection<VariantContext>> evalSet = evalVCs.containsKey(evalInput) ? evalVCs.get(evalInput) : Collections.emptyMap();\n-\n-            Set<String> statificationLevels;\n+    public void listModulesAndExit() {\n+        logger.info(\"Available stratification modules:\");\n+        logger.info(\"(Standard modules are starred)\");\n \n-            // for each sample stratifier\n-            if (perFamilyIsEnabled)\n-                statificationLevels = familyNamesForStratification;\n-            else\n-                statificationLevels = sampleNamesForStratification;\n-            for ( final String stratLevelName : statificationLevels ) {\n-                Collection<VariantContext> evalSetBySample = evalSet.get(stratLevelName);\n+        for (String name: VariantEvalEngine.getStratifierClasses().keySet()) {\n \n-                if ( evalSetBySample == null ) {\n-                    evalSetBySample = new HashSet<>(1);\n-                    evalSetBySample.add(null);\n-                }\n-\n-                // for each eval in the track\n-                for ( VariantContext eval : evalSetBySample ) {\n-                    String aastr = (ancestralAlignments == null) ? null : new String(ancestralAlignments.getSubsequenceAt(eval.getContig(), eval.getStart(), eval.getEnd()).getBases());\n-\n-                    // deal with ancestral alleles if requested\n-                    if ( eval != null && aastr != null ) {\n-                        eval = new VariantContextBuilder(eval).attribute(\"ANCESTRALALLELE\", aastr).make();\n-                    }\n-\n-                    String evalName = getNameForInput(evalInput);\n-\n-                    // for each comp track\n-                    for ( final FeatureInput<VariantContext> compInput : variantEvalArgs.comps ) {\n-                        processComp(variantEvalContext, eval, evalName, compInput, stratLevelName, compVCs, evalSetBySample);\n-                    }\n-\n-                    if (variantEvalArgs.comps.isEmpty()) {\n-                        processComp(variantEvalContext, eval, evalName, null, stratLevelName, compVCs, evalSetBySample);\n-                    }\n-                }\n-            }\n-\n-            if ( variantEvalArgs.mergeEvals ) break; // stop processing the eval tracks\n+            logger.info(\"\\t\" + name + (VariantEvalEngine.getRequiredStratificationNames().contains(name) || VariantEvalEngine.getStandardStratificationNames().contains(name) ? \"*\" : \"\"));\n         }\n-    }\n+        logger.info(\"\");\n \n-    private SimpleInterval generateContextInterval(List<VariantContext> variantContexts) {\n-        int maxEnd = variantContexts.stream().map(VariantContext::getEnd).max(Integer::compareTo).get();\n-\n-        return new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), maxEnd);\n-    }\n-\n-    private void processComp(VariantEvalContext vec, VariantContext eval, String evalName, FeatureInput<VariantContext> compInput, String stratLevelName, Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs, Collection<VariantContext> evalSetBySample) {\n-        String compName = getNameForInput(compInput);\n-\n-        // no sample stratification for comps\n-        final HashMap<String, Collection<VariantContext>> compSetHash = compInput == null ? null : compVCs.get(compInput);\n-        final Collection<VariantContext> compSet = (compSetHash == null || compSetHash.isEmpty()) ? Collections.<VariantContext>emptyList() : compVCs.get(compInput).values().iterator().next();\n-\n-        // find the comp\n-        final VariantContext comp = findMatchingComp(eval, compSet);\n-\n-        Collection<EvaluationContext> contextsForStratification;\n-        if (perFamilyIsEnabled)\n-            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, null, stratLevelName);\n-        else {\n-            String familyID;\n-            if (stratLevelName.equals(\"all\"))\n-                familyID = \"all\";\n-            else\n-                familyID = sampleDB.getSample(stratLevelName).getFamilyID();\n-            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, stratLevelName, familyID);\n+        logger.info(\"Available evaluation modules:\");\n+        logger.info(\"(Standard modules are starred)\");\n+        for (String veName : VariantEvalEngine.getEvaluatorClasses().keySet()) {\n+            logger.info(\"\\t\" + veName + (VariantEvalEngine.getStandardEvaluatorNames().contains(veName) ? \"*\" : \"\"));\n         }\n-        for ( EvaluationContext nec : contextsForStratification ) {\n+        logger.info(\"\");\n \n-            // eval against the comp\n-            synchronized (nec) {\n-                nec.apply(vec, comp, eval);\n-            }\n-\n-            // eval=null against all comps of different type that aren't bound to another eval\n-            for ( VariantContext otherComp : compSet ) {\n-                if ( otherComp != comp && ! compHasMatchingEval(otherComp, evalSetBySample) ) {\n-                    synchronized (nec) {\n-                        nec.apply(vec, otherComp, null);\n-                    }\n-                }\n-            }\n-        }\n+        System.exit(0);\n     }\n \n-    /**\n-     * Given specific eval and comp VCs and the sample name, return an iterable\n-     * over all of the applicable state keys.\n-     *\n-     * this code isn't structured yet for efficiency.  Here we currently are\n-     * doing the following inefficient algorithm:\n-     *\n-     * for each strat:\n-     *   get list of relevant states that eval and comp according to strat\n-     *   add this list of states to a list of list states\n-     *\n-     * then\n-     *\n-     * ask the strat manager to look up all of the keys associated with the combinations\n-     * of these states.  For example, suppose we have a single variant S.  We have active\n-     * strats EvalFeatureInput, CompFeatureInput, and Novelty.  We produce a list that looks like:\n-     *\n-     *   L = [[Eval], [Comp], [All, Novel]]\n-     *\n-     * We then go through the strat manager tree to produce the keys associated with these states:\n-     *\n-     *   K = [0, 1] where EVAL x COMP x ALL = 0 and EVAL x COMP x NOVEL = 1\n-     *\n-     * It's clear that a better\n-     *\n-     *\n-     * @param vec\n-     * @param eval\n-     * @param evalName\n-     * @param comp\n-     * @param compName\n-     * @param sampleName\n-     * @return\n-     */\n-    protected Collection<EvaluationContext> getEvaluationContexts(final VariantEvalContext vec,\n-                                                                  final VariantContext eval,\n-                                                                  final String evalName,\n-                                                                  final VariantContext comp,\n-                                                                  final String compName,\n-                                                                  final String sampleName,\n-                                                                  final String familyName) {\n-        final List<List<Object>> states = new LinkedList<>();\n-        for ( final VariantStratifier vs : stratManager.getStratifiers() ) {\n-            states.add(vs.getRelevantStates(vec, comp, compName, eval, evalName, sampleName, familyName));\n-        }\n-        return stratManager.values(states);\n-    }\n-\n-\n-    private boolean compHasMatchingEval(final VariantContext comp, final Collection<VariantContext> evals) {\n-        // find all of the matching comps\n-        for ( final VariantContext eval : evals ) {\n-            if ( eval != null && doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) != EvalCompMatchType.NO_MATCH )\n-                return true;\n-        }\n-\n-        // nothing matched\n-        return false;\n-    }\n-\n-    private enum EvalCompMatchType { NO_MATCH, STRICT, LENIENT }\n-\n-    private EvalCompMatchType doEvalAndCompMatch(final VariantContext eval, final VariantContext comp, boolean requireStrictAlleleMatch) {\n-        if ( comp.getType() == VariantContext.Type.NO_VARIATION || eval.getType() == VariantContext.Type.NO_VARIATION )\n-            // if either of these are NO_VARIATION they are LENIENT matches\n-            return EvalCompMatchType.LENIENT;\n-\n-        if ( comp.getType() != eval.getType() )\n-            return EvalCompMatchType.NO_MATCH;\n-\n-        // find the comp which matches both the reference allele and alternate allele from eval\n-        final Allele altEval = eval.getAlternateAlleles().size() == 0 ? null : eval.getAlternateAllele(0);\n-        final Allele altComp = comp.getAlternateAlleles().size() == 0 ? null : comp.getAlternateAllele(0);\n-        if ((altEval == null && altComp == null) || (altEval != null && altEval.equals(altComp) && eval.getReference().equals(comp.getReference())))\n-            return EvalCompMatchType.STRICT;\n-        else\n-            return requireStrictAlleleMatch ? EvalCompMatchType.NO_MATCH : EvalCompMatchType.LENIENT;\n-    }\n-\n-    private VariantContext findMatchingComp(final VariantContext eval, final Collection<VariantContext> comps) {\n-        // if no comps, return null\n-        if ( comps == null || comps.isEmpty() )\n-            return null;\n-\n-        // if no eval, return any comp\n-        if ( eval == null )\n-            return comps.iterator().next();\n-\n-        // find all of the matching comps\n-        VariantContext lenientMatch = null;\n-        for ( final VariantContext comp : comps ) {\n-            switch ( doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) ) {\n-                case STRICT:\n-                    return comp;\n-                case LENIENT:\n-                    if ( lenientMatch == null ) lenientMatch = comp;\n-                    break;\n-                case NO_MATCH:\n-                    // do nothing\n-            }\n-        }\n-\n-        // nothing matched, just return lenientMatch, which might be null\n-        return lenientMatch;\n+    @Override\n+    public void apply(final List<VariantContext> variantContexts, final ReferenceContext referenceContext, final List<ReadsContext> readsContexts) {\n+        engine.apply(variantContexts, referenceContext);\n     }\n \n     @Override\n     public Object onTraversalSuccess() {\n         logger.info(\"Finalizing variant report\");\n-        \n-        // go through the evaluations and finalize them\n-        for ( final EvaluationContext nec : stratManager.values() )\n-            for ( final VariantEvaluator ve : nec.getVariantEvaluators() )\n-                ve.finalizeEvaluation(this);\n-\n-        //send data to MetricsCollection\n-        CompOverlap compOverlap = null;\n-        IndelSummary indelSummary = null;\n-        CountVariants countVariants = null;\n-        MultiallelicSummary multiallelicSummary = null;\n-        TiTvVariantEvaluator tiTvVariantEvaluator = null;\n-        MetricsCollection metricsCollection = null;\n-        for(final EvaluationContext nec: stratManager.values()) {\n-            for(final VariantEvaluator ve : nec.getVariantEvaluators()) {\n-                if (ve instanceof CompOverlap)\n-                    compOverlap = (CompOverlap) ve;\n-                else if (ve instanceof IndelSummary)\n-                    indelSummary = (IndelSummary) ve;\n-                else if (ve instanceof CountVariants)\n-                    countVariants = (CountVariants) ve;\n-                else if (ve instanceof MultiallelicSummary)\n-                    multiallelicSummary = (MultiallelicSummary) ve;\n-                else if (ve instanceof TiTvVariantEvaluator)\n-                    tiTvVariantEvaluator = (TiTvVariantEvaluator) ve;\n-                else if (ve instanceof MetricsCollection)\n-                    metricsCollection = (MetricsCollection) ve;\n-            }\n-\n-            if(metricsCollection != null)\n-                metricsCollection.setData(compOverlap.concordantRate, indelSummary.n_SNPs, countVariants.nSNPs, indelSummary.n_indels, multiallelicSummary.nIndels, indelSummary.insertion_to_deletion_ratio, countVariants.insertionDeletionRatio, tiTvVariantEvaluator.tiTvRatio);\n-        }\n \n-        try (PrintStream out = IOUtils.makePrintStreamMaybeGzipped(new GATKPath(outFile.getAbsolutePath()))) {\n-            VariantEvalReportWriter.writeReport(out, stratManager, stratManager.getStratifiers(), stratManager.get(0).getVariantEvaluators());\n-        }\n-        catch(IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(e.getMessage(), e);\n-        }\n+        engine.finalizeReport(outFile);\n \n         return null;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjkwNA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547352904", "bodyText": "final", "author": "cmnbroad", "createdAt": "2020-12-22T15:48:50Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -466,66 +361,41 @@ protected EvaluationContext createEvaluationContext(final Set<Class<? extends Va\n         return new EvaluationContext(this, evaluationObjects);\n     }\n \n-    private class PositionAggregator {\n-        private SimpleInterval i = null;\n-\n-        private ReadsContext readsContext;\n-        private ReferenceContext referenceContext;\n-        private FeatureContext featureContext;\n-\n-        private void addVariant(VariantContext vc, ReadsContext readsContext, ReferenceContext referenceContext, FeatureContext featureContext) {\n-            if (i == null || !vc.getContig().equals(i.getContig()) || vc.getStart() != i.getStart()) {\n-                callDoApply();\n+    public String getNameForInput(FeatureInput<VariantContext> input) {\n+        return inputToNameMap.get(input);\n+    }\n \n-                i = new SimpleInterval(vc.getContig(), vc.getStart(), vc.getEnd());\n-                this.readsContext = readsContext;\n-                this.referenceContext = referenceContext;\n-                this.featureContext = featureContext;\n-            }\n-            else if (vc.getEnd() > i.getEnd()) {\n-                //expand region\n-                i = new SimpleInterval(i.getContig(), i.getStart(), vc.getEnd());\n+    @Override\n+    public void apply(List<VariantContext> variantContexts, ReferenceContext referenceContext, List<ReadsContext> readsContexts) {\n+        Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap = groupVariantsByFeatureInput(variantContexts);", "originalCommit": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzNTIxOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547535219", "bodyText": "OK. for the record, other subclasses of MultiVariantWalkerGroupedOnStart, like FilterAlignmentArtifacts and CombineGVCFs dont have final either. I assume everyone just let Intellij auto-generate the method, so it would inherit the argument pattern from MultiVariantWalkerGroupedOnStart...", "author": "bbimber", "createdAt": "2020-12-22T22:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjkwNA=="}], "type": "inlineReview", "revised_code": {"commit": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\nindex 0db5f4b1e..28780906a 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java\n\n@@ -163,474 +135,55 @@ public class VariantEval extends MultiVariantWalkerGroupedOnStart {\n \n     @Override\n     protected void initializeDrivingVariants() {\n-        getDrivingVariantsFeatureInputs().addAll(variantEvalArgs.getEvals());\n-        if (variantEvalArgs.dbsnp.dbsnp != null) {\n-            getDrivingVariantsFeatureInputs().add(variantEvalArgs.dbsnp.dbsnp);\n-        }\n-\n-        getDrivingVariantsFeatureInputs().addAll(variantEvalArgs.compsProvided);\n+        getDrivingVariantsFeatureInputs().addAll(VariantEvalEngine.getFeatureInputsForDrivingVariants(variantEvalArgs));\n \n         super.initializeDrivingVariants();\n     }\n \n-    // Variables\n-    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n-\n-    private boolean isSubsettingSamples;\n-    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n-    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n-    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n-    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n-\n-    // important stratifications\n-    private boolean byFilterIsEnabled = false;\n-    private boolean perSampleIsEnabled = false;\n-    private boolean perFamilyIsEnabled = false;\n-\n-    // Utility class\n-    private final VariantEvalUtils variantEvalUtils = new VariantEvalUtils(this);\n-\n-    // Ancestral alignments\n-    private ReferenceSequenceFile ancestralAlignments = null;\n-\n-    // The set of all possible evaluation contexts\n-    StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n-\n-    private SampleDB sampleDB = null;\n-\n-    // maintain the mapping of FeatureInput to name used in output file\n-    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n-\n-    /**\n-     * Initialize the stratifications, evaluations, evaluation contexts, and reporting object\n-     */\n     @Override\n     public void onTraversalStart() {\n-        Utils.nonNull(outFile);\n-\n         // Just list the modules, and exit quickly.\n-        if (LIST) { variantEvalUtils.listModulesAndExit(); }\n-\n-        sampleDB = initializeSampleDB();\n-\n-        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n-        variantEvalArgs.compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n-        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n-            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n-            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n-            variantEvalArgs.knowns.add(variantEvalArgs.dbsnp.dbsnp);\n-        }\n-\n-        variantEvalArgs.evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));\n-\n-        // Set up set of additional knowns. dbSNP was addressed above, so use compsProvided, not comps\n-        for ( FeatureInput<VariantContext> compInput : variantEvalArgs.compsProvided ) {\n-            if (variantEvalArgs.KNOWN_NAMES.contains(getNameForInput(compInput)))\n-                variantEvalArgs.knowns.add(compInput);\n-        }\n-\n-        // Now that we have all the inputs categorized, determine the sample list from the eval inputs.\n-        Map<String, VCFHeader> vcfInputs = new HashMap<>();\n-        variantEvalArgs.evals.forEach(x -> vcfInputs.put(x.getName(), (VCFHeader)getHeaderForFeatures(x)));\n-\n-        Set<String> vcfSamples = new HashSet<>();\n-        vcfInputs.forEach((k,v) -> vcfSamples.addAll(v.getSampleNamesInOrder()));\n-\n-        // Load the sample list, using an intermediate tree set to sort the samples\n-        final Set<String> allSampleNames = new HashSet<>(vcfSamples);\n-        sampleNamesForEvaluation.addAll(new TreeSet<>(variantEvalArgs.SAMPLE_EXPRESSIONS.isEmpty() ? vcfSamples : Utils.filterCollectionByExpressions(vcfSamples, variantEvalArgs.SAMPLE_EXPRESSIONS, false)));\n-\n-        isSubsettingSamples = ! sampleNamesForEvaluation.containsAll(allSampleNames);\n-        familyNamesForEvaluation.addAll(sampleDB.getFamilyIDs());\n-\n-        //If stratifying by sample name, assign a stratification for each sample we're evaluating (based on commandline args)...\n-        if (variantEvalArgs.STRATIFICATIONS_TO_USE.contains(\"Sample\") ) {\n-            sampleNamesForStratification.addAll(sampleNamesForEvaluation);\n-        }\n-        //...and also a stratification for the sum over all samples\n-        sampleNamesForStratification.add(VariantEvalArgumentCollection.ALL_SAMPLE_NAME);\n-\n-        //If stratifying by sample name, assign a stratification for each family...\n-        if ( variantEvalArgs.STRATIFICATIONS_TO_USE.contains(\"Family\") ) {\n-            familyNamesForStratification.addAll(familyNamesForEvaluation);\n-        }\n-        //...and also a stratification for the sum over all families\n-        familyNamesForStratification.add(VariantEvalArgumentCollection.ALL_FAMILY_NAME);\n-\n-        // Initialize select expressions\n-        for (VariantContextUtils.JexlVCMatchExp jexl : VariantContextUtils.initializeMatchExps(variantEvalArgs.SELECT_NAMES, variantEvalArgs.SELECT_EXPS)) {\n-            SortableJexlVCMatchExp sjexl = new SortableJexlVCMatchExp(jexl.name, jexl.exp);\n-            jexlExpressions.add(sjexl);\n-        }\n-\n-        // Initialize the set of stratifications and evaluations to use\n-        // The list of stratifiers and evaluators to use\n-        final List<VariantStratifier> stratificationObjects = variantEvalUtils.initializeStratificationObjects(variantEvalArgs.NO_STANDARD_STRATIFICATIONS, variantEvalArgs.STRATIFICATIONS_TO_USE);\n-        final Set<Class<? extends VariantEvaluator>> evaluationClasses = variantEvalUtils.initializeEvaluationObjects(variantEvalArgs.NO_STANDARD_MODULES, variantEvalArgs.MODULES_TO_USE);\n-\n-        checkForIncompatibleEvaluatorsAndStratifiers(stratificationObjects, evaluationClasses);\n-\n-        for ( VariantStratifier vs : stratificationObjects ) {\n-            if ( vs.getName().equals(\"Filter\") )\n-                byFilterIsEnabled = true;\n-            else if ( vs.getName().equals(\"Sample\") )\n-                perSampleIsEnabled = true;\n-            else if ( vs.getName().equals(\"Family\"))\n-                perFamilyIsEnabled = true;\n-        }\n-\n-        if (perSampleIsEnabled && perFamilyIsEnabled)\n-            throw new CommandLineException.BadArgumentValue(\"ST\", \"Variants cannot be stratified by sample and family at the same time\");\n-\n-        if (perFamilyIsEnabled && sampleDB.getTrios().isEmpty())\n-            throw new CommandLineException.BadArgumentValue(\"ST\", \"Cannot stratify by family without *.ped file\");\n-\n-\n-        if ( variantEvalArgs.intervalsFile != null ) {\n-            boolean fail = true;\n-            for ( final VariantStratifier vs : stratificationObjects ) {\n-                if ( vs.getClass().equals(IntervalStratification.class) )\n-                    fail = false;\n-            }\n-            if ( fail )\n-                throw new CommandLineException.BadArgumentValue(\"ST\", \"stratIntervals argument provided but -ST IntervalStratification not provided\");\n-        }\n-\n-        // Initialize the evaluation contexts\n-        createStratificationStates(stratificationObjects, evaluationClasses);\n-\n-        // Load ancestral alignments\n-        if (variantEvalArgs.ancestralAlignmentsFile != null) {\n-            try {\n-                ancestralAlignments = new IndexedFastaSequenceFile(variantEvalArgs.ancestralAlignmentsFile.toPath());\n-            } catch (FileNotFoundException e) {\n-                throw new GATKException(String.format(\"The ancestral alignments file, '%s', could not be found\", variantEvalArgs.ancestralAlignmentsFile.getAbsolutePath()));\n-            }\n-        }\n-\n-        assertThatTerritoryIsSpecifiedIfNecessary();\n-    }\n-\n-    private void assertThatTerritoryIsSpecifiedIfNecessary() {\n-        final Set<String> evaluatorsWhichRequireTerritory = stratManager.values()\n-                .stream()\n-                .flatMap(ctx -> ctx.getVariantEvaluators().stream())\n-                .filter(Objects::nonNull)\n-                .filter(VariantEvaluator::requiresTerritoryToBeSpecified)\n-                .map(VariantEvaluator::getSimpleName)\n-                .collect(Collectors.toSet());\n-        if(!evaluatorsWhichRequireTerritory.isEmpty() && getTraversalIntervals() == null){\n-            throw new UserException(\"You specified evaluators which require a covered territory to be specified.  \" +\n-                    \"\\nPlease specify intervals or a reference file or disable all of the following evaluators:\" +\n-                    evaluatorsWhichRequireTerritory.stream()\n-                            .collect(Collectors.joining(\", \")));\n-        }\n-    }\n-\n-    private void checkForIncompatibleEvaluatorsAndStratifiers( final List<VariantStratifier> stratificationObjects,\n-                                                             Set<Class<? extends VariantEvaluator>> evaluationClasses) {\n-        for ( final VariantStratifier vs : stratificationObjects ) {\n-            for ( Class<? extends VariantEvaluator> ec : evaluationClasses )\n-                if ( vs.getIncompatibleEvaluators().contains(ec) )\n-                    throw new CommandLineException.BadArgumentValue(\"ST and ET\",\n-                            \"The selected stratification \" + vs.getName() +\n-                                    \" and evaluator \" + ec.getSimpleName() +\n-                                    \" are incompatible due to combinatorial memory requirements.\" +\n-                                    \" Please disable one\");\n-        }\n-    }\n+        if (LIST) { listModulesAndExit(); }\n \n-    final void createStratificationStates(final List<VariantStratifier> stratificationObjects, final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n-        final List<VariantStratifier> strats = new ArrayList<VariantStratifier>(stratificationObjects);\n-        stratManager = new StratificationManager<>(strats);\n+        Utils.nonNull(outFile);\n+        IOUtil.assertFileIsWritable(outFile);\n \n-        logger.info(\"Creating \" + stratManager.size() + \" combinatorial stratification states\");\n-        for ( int i = 0; i < stratManager.size(); i++ ) {\n-            EvaluationContext ec = createEvaluationContext(evaluationObjects);\n-            stratManager.set(i, ec);\n-        }\n+        engine = new VariantEvalEngine(variantEvalArgs, this, getSequenceDictionaryForDrivingVariants(), getSamplesForVariants(), logger);\n     }\n \n     /**\n-     * Create the EvaluationContext (new instance) for the provided set of VariantEvaluators.\n-     *\n-     * @param evaluationObjects The list of VariantEvaluator classes\n-     * @return The EvaluationContext for this set of VariantEvaluator classes\n+     * List all of the available evaluation modules, then exit successfully\n      */\n-    protected EvaluationContext createEvaluationContext(final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n-        return new EvaluationContext(this, evaluationObjects);\n-    }\n-\n-    public String getNameForInput(FeatureInput<VariantContext> input) {\n-        return inputToNameMap.get(input);\n-    }\n-\n-    @Override\n-    public void apply(List<VariantContext> variantContexts, ReferenceContext referenceContext, List<ReadsContext> readsContexts) {\n-        Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap = groupVariantsByFeatureInput(variantContexts);\n-\n-        List<VariantContext> allEvals = new ArrayList<>();\n-        for (FeatureInput<VariantContext> eval : variantEvalArgs.getEvals()) {\n-            if (variantMap.containsKey(eval)) {\n-                allEvals.addAll(variantMap.get(eval));\n-            }\n-        }\n-\n-        List<VariantContext> allComps = new ArrayList<>();\n-        if (variantEvalArgs.getComps() != null) {\n-            for (FeatureInput<VariantContext> comp : variantEvalArgs.getComps()) {\n-                if (variantMap.containsKey(comp)) {\n-                    allComps.addAll(variantMap.get(comp));\n-                }\n-            }\n-        }\n-\n-        SimpleInterval interval = allEvals.isEmpty() ? new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), variantContexts.get(0).getStart()) : generateContextInterval(allEvals);\n-        FeatureContext featureContext = new FeatureContext(features, interval);\n-\n-        Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> evalVCs = allEvals.isEmpty() ? Collections.emptyMap() : variantEvalUtils.bindVariantContexts(variantMap, variantEvalArgs.getEvals(), byFilterIsEnabled, true, perSampleIsEnabled, perFamilyIsEnabled, variantEvalArgs.mergeEvals);\n-        Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs = allComps.isEmpty() ? Collections.emptyMap() : variantEvalUtils.bindVariantContexts(variantMap, variantEvalArgs.getComps(), byFilterIsEnabled, false, false, false, false);\n-\n-        VariantEvalContext variantEvalContext = new VariantEvalContext(referenceContext, featureContext, variantMap, getVariantEvalArgs(), this);\n-\n-        // for each eval track\n-        for ( final FeatureInput<VariantContext> evalInput : variantEvalArgs.getEvals() ) {\n-            final Map<String, Collection<VariantContext>> evalSet = evalVCs.containsKey(evalInput) ? evalVCs.get(evalInput) : Collections.emptyMap();\n-\n-            Set<String> statificationLevels;\n+    public void listModulesAndExit() {\n+        logger.info(\"Available stratification modules:\");\n+        logger.info(\"(Standard modules are starred)\");\n \n-            // for each sample stratifier\n-            if (perFamilyIsEnabled)\n-                statificationLevels = familyNamesForStratification;\n-            else\n-                statificationLevels = sampleNamesForStratification;\n-            for ( final String stratLevelName : statificationLevels ) {\n-                Collection<VariantContext> evalSetBySample = evalSet.get(stratLevelName);\n+        for (String name: VariantEvalEngine.getStratifierClasses().keySet()) {\n \n-                if ( evalSetBySample == null ) {\n-                    evalSetBySample = new HashSet<>(1);\n-                    evalSetBySample.add(null);\n-                }\n-\n-                // for each eval in the track\n-                for ( VariantContext eval : evalSetBySample ) {\n-                    String aastr = (ancestralAlignments == null) ? null : new String(ancestralAlignments.getSubsequenceAt(eval.getContig(), eval.getStart(), eval.getEnd()).getBases());\n-\n-                    // deal with ancestral alleles if requested\n-                    if ( eval != null && aastr != null ) {\n-                        eval = new VariantContextBuilder(eval).attribute(\"ANCESTRALALLELE\", aastr).make();\n-                    }\n-\n-                    String evalName = getNameForInput(evalInput);\n-\n-                    // for each comp track\n-                    for ( final FeatureInput<VariantContext> compInput : variantEvalArgs.comps ) {\n-                        processComp(variantEvalContext, eval, evalName, compInput, stratLevelName, compVCs, evalSetBySample);\n-                    }\n-\n-                    if (variantEvalArgs.comps.isEmpty()) {\n-                        processComp(variantEvalContext, eval, evalName, null, stratLevelName, compVCs, evalSetBySample);\n-                    }\n-                }\n-            }\n-\n-            if ( variantEvalArgs.mergeEvals ) break; // stop processing the eval tracks\n+            logger.info(\"\\t\" + name + (VariantEvalEngine.getRequiredStratificationNames().contains(name) || VariantEvalEngine.getStandardStratificationNames().contains(name) ? \"*\" : \"\"));\n         }\n-    }\n+        logger.info(\"\");\n \n-    private SimpleInterval generateContextInterval(List<VariantContext> variantContexts) {\n-        int maxEnd = variantContexts.stream().map(VariantContext::getEnd).max(Integer::compareTo).get();\n-\n-        return new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), maxEnd);\n-    }\n-\n-    private void processComp(VariantEvalContext vec, VariantContext eval, String evalName, FeatureInput<VariantContext> compInput, String stratLevelName, Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs, Collection<VariantContext> evalSetBySample) {\n-        String compName = getNameForInput(compInput);\n-\n-        // no sample stratification for comps\n-        final HashMap<String, Collection<VariantContext>> compSetHash = compInput == null ? null : compVCs.get(compInput);\n-        final Collection<VariantContext> compSet = (compSetHash == null || compSetHash.isEmpty()) ? Collections.<VariantContext>emptyList() : compVCs.get(compInput).values().iterator().next();\n-\n-        // find the comp\n-        final VariantContext comp = findMatchingComp(eval, compSet);\n-\n-        Collection<EvaluationContext> contextsForStratification;\n-        if (perFamilyIsEnabled)\n-            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, null, stratLevelName);\n-        else {\n-            String familyID;\n-            if (stratLevelName.equals(\"all\"))\n-                familyID = \"all\";\n-            else\n-                familyID = sampleDB.getSample(stratLevelName).getFamilyID();\n-            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, stratLevelName, familyID);\n+        logger.info(\"Available evaluation modules:\");\n+        logger.info(\"(Standard modules are starred)\");\n+        for (String veName : VariantEvalEngine.getEvaluatorClasses().keySet()) {\n+            logger.info(\"\\t\" + veName + (VariantEvalEngine.getStandardEvaluatorNames().contains(veName) ? \"*\" : \"\"));\n         }\n-        for ( EvaluationContext nec : contextsForStratification ) {\n+        logger.info(\"\");\n \n-            // eval against the comp\n-            synchronized (nec) {\n-                nec.apply(vec, comp, eval);\n-            }\n-\n-            // eval=null against all comps of different type that aren't bound to another eval\n-            for ( VariantContext otherComp : compSet ) {\n-                if ( otherComp != comp && ! compHasMatchingEval(otherComp, evalSetBySample) ) {\n-                    synchronized (nec) {\n-                        nec.apply(vec, otherComp, null);\n-                    }\n-                }\n-            }\n-        }\n+        System.exit(0);\n     }\n \n-    /**\n-     * Given specific eval and comp VCs and the sample name, return an iterable\n-     * over all of the applicable state keys.\n-     *\n-     * this code isn't structured yet for efficiency.  Here we currently are\n-     * doing the following inefficient algorithm:\n-     *\n-     * for each strat:\n-     *   get list of relevant states that eval and comp according to strat\n-     *   add this list of states to a list of list states\n-     *\n-     * then\n-     *\n-     * ask the strat manager to look up all of the keys associated with the combinations\n-     * of these states.  For example, suppose we have a single variant S.  We have active\n-     * strats EvalFeatureInput, CompFeatureInput, and Novelty.  We produce a list that looks like:\n-     *\n-     *   L = [[Eval], [Comp], [All, Novel]]\n-     *\n-     * We then go through the strat manager tree to produce the keys associated with these states:\n-     *\n-     *   K = [0, 1] where EVAL x COMP x ALL = 0 and EVAL x COMP x NOVEL = 1\n-     *\n-     * It's clear that a better\n-     *\n-     *\n-     * @param vec\n-     * @param eval\n-     * @param evalName\n-     * @param comp\n-     * @param compName\n-     * @param sampleName\n-     * @return\n-     */\n-    protected Collection<EvaluationContext> getEvaluationContexts(final VariantEvalContext vec,\n-                                                                  final VariantContext eval,\n-                                                                  final String evalName,\n-                                                                  final VariantContext comp,\n-                                                                  final String compName,\n-                                                                  final String sampleName,\n-                                                                  final String familyName) {\n-        final List<List<Object>> states = new LinkedList<>();\n-        for ( final VariantStratifier vs : stratManager.getStratifiers() ) {\n-            states.add(vs.getRelevantStates(vec, comp, compName, eval, evalName, sampleName, familyName));\n-        }\n-        return stratManager.values(states);\n-    }\n-\n-\n-    private boolean compHasMatchingEval(final VariantContext comp, final Collection<VariantContext> evals) {\n-        // find all of the matching comps\n-        for ( final VariantContext eval : evals ) {\n-            if ( eval != null && doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) != EvalCompMatchType.NO_MATCH )\n-                return true;\n-        }\n-\n-        // nothing matched\n-        return false;\n-    }\n-\n-    private enum EvalCompMatchType { NO_MATCH, STRICT, LENIENT }\n-\n-    private EvalCompMatchType doEvalAndCompMatch(final VariantContext eval, final VariantContext comp, boolean requireStrictAlleleMatch) {\n-        if ( comp.getType() == VariantContext.Type.NO_VARIATION || eval.getType() == VariantContext.Type.NO_VARIATION )\n-            // if either of these are NO_VARIATION they are LENIENT matches\n-            return EvalCompMatchType.LENIENT;\n-\n-        if ( comp.getType() != eval.getType() )\n-            return EvalCompMatchType.NO_MATCH;\n-\n-        // find the comp which matches both the reference allele and alternate allele from eval\n-        final Allele altEval = eval.getAlternateAlleles().size() == 0 ? null : eval.getAlternateAllele(0);\n-        final Allele altComp = comp.getAlternateAlleles().size() == 0 ? null : comp.getAlternateAllele(0);\n-        if ((altEval == null && altComp == null) || (altEval != null && altEval.equals(altComp) && eval.getReference().equals(comp.getReference())))\n-            return EvalCompMatchType.STRICT;\n-        else\n-            return requireStrictAlleleMatch ? EvalCompMatchType.NO_MATCH : EvalCompMatchType.LENIENT;\n-    }\n-\n-    private VariantContext findMatchingComp(final VariantContext eval, final Collection<VariantContext> comps) {\n-        // if no comps, return null\n-        if ( comps == null || comps.isEmpty() )\n-            return null;\n-\n-        // if no eval, return any comp\n-        if ( eval == null )\n-            return comps.iterator().next();\n-\n-        // find all of the matching comps\n-        VariantContext lenientMatch = null;\n-        for ( final VariantContext comp : comps ) {\n-            switch ( doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) ) {\n-                case STRICT:\n-                    return comp;\n-                case LENIENT:\n-                    if ( lenientMatch == null ) lenientMatch = comp;\n-                    break;\n-                case NO_MATCH:\n-                    // do nothing\n-            }\n-        }\n-\n-        // nothing matched, just return lenientMatch, which might be null\n-        return lenientMatch;\n+    @Override\n+    public void apply(final List<VariantContext> variantContexts, final ReferenceContext referenceContext, final List<ReadsContext> readsContexts) {\n+        engine.apply(variantContexts, referenceContext);\n     }\n \n     @Override\n     public Object onTraversalSuccess() {\n         logger.info(\"Finalizing variant report\");\n-        \n-        // go through the evaluations and finalize them\n-        for ( final EvaluationContext nec : stratManager.values() )\n-            for ( final VariantEvaluator ve : nec.getVariantEvaluators() )\n-                ve.finalizeEvaluation(this);\n-\n-        //send data to MetricsCollection\n-        CompOverlap compOverlap = null;\n-        IndelSummary indelSummary = null;\n-        CountVariants countVariants = null;\n-        MultiallelicSummary multiallelicSummary = null;\n-        TiTvVariantEvaluator tiTvVariantEvaluator = null;\n-        MetricsCollection metricsCollection = null;\n-        for(final EvaluationContext nec: stratManager.values()) {\n-            for(final VariantEvaluator ve : nec.getVariantEvaluators()) {\n-                if (ve instanceof CompOverlap)\n-                    compOverlap = (CompOverlap) ve;\n-                else if (ve instanceof IndelSummary)\n-                    indelSummary = (IndelSummary) ve;\n-                else if (ve instanceof CountVariants)\n-                    countVariants = (CountVariants) ve;\n-                else if (ve instanceof MultiallelicSummary)\n-                    multiallelicSummary = (MultiallelicSummary) ve;\n-                else if (ve instanceof TiTvVariantEvaluator)\n-                    tiTvVariantEvaluator = (TiTvVariantEvaluator) ve;\n-                else if (ve instanceof MetricsCollection)\n-                    metricsCollection = (MetricsCollection) ve;\n-            }\n-\n-            if(metricsCollection != null)\n-                metricsCollection.setData(compOverlap.concordantRate, indelSummary.n_SNPs, countVariants.nSNPs, indelSummary.n_indels, multiallelicSummary.nIndels, indelSummary.insertion_to_deletion_ratio, countVariants.insertionDeletionRatio, tiTvVariantEvaluator.tiTvRatio);\n-        }\n \n-        try (PrintStream out = IOUtils.makePrintStreamMaybeGzipped(new GATKPath(outFile.getAbsolutePath()))) {\n-            VariantEvalReportWriter.writeReport(out, stratManager, stratManager.getStratifiers(), stratManager.get(0).getVariantEvaluators());\n-        }\n-        catch(IOException e) {\n-            throw new UserException.CouldNotCreateOutputFile(e.getMessage(), e);\n-        }\n+        engine.finalizeReport(outFile);\n \n         return null;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NDkxMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547354911", "bodyText": "The comment doesn't match the declaration. These should just be public statics, without the getter, and the comment should be fixed.", "author": "cmnbroad", "createdAt": "2020-12-22T15:52:28Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.ArgumentCollection;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.argumentcollections.DbsnpArgumentCollection;\n+import org.broadinstitute.hellbender.engine.FeatureInput;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.utils.variant.GATKVariantContextUtils;\n+\n+import java.io.File;\n+import java.util.*;\n+\n+/**\n+ * The collection of arguments for VariantEval\n+ */\n+public class VariantEvalArgumentCollection {\n+\n+    // Public constants\n+    final protected static String ALL_SAMPLE_NAME = \"all\";\n+    final protected static String ALL_FAMILY_NAME = \"all\";", "originalCommit": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzMDkwNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547530905", "bodyText": "point taken, but a lot of this predates this PR", "author": "bbimber", "createdAt": "2020-12-22T22:09:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NDkxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java\nindex 57ee33418..e5f3ec0a6 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java\n\n@@ -4,6 +4,7 @@ import htsjdk.tribble.Feature;\n import htsjdk.variant.variantcontext.VariantContext;\n import org.broadinstitute.barclay.argparser.Argument;\n import org.broadinstitute.barclay.argparser.ArgumentCollection;\n+import org.broadinstitute.barclay.argparser.Hidden;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.cmdline.argumentcollections.DbsnpArgumentCollection;\n import org.broadinstitute.hellbender.engine.FeatureInput;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1OTM2Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547359362", "bodyText": "The access modifiers for all of the args in this class should be made consistent (there seems to be a mix of protected, package protected, and public access, and some are public with public getters). I'd suggest just using public with no getters.", "author": "cmnbroad", "createdAt": "2020-12-22T16:00:15Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.ArgumentCollection;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.argumentcollections.DbsnpArgumentCollection;\n+import org.broadinstitute.hellbender.engine.FeatureInput;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.utils.variant.GATKVariantContextUtils;\n+\n+import java.io.File;\n+import java.util.*;\n+\n+/**\n+ * The collection of arguments for VariantEval\n+ */\n+public class VariantEvalArgumentCollection {\n+\n+    // Public constants\n+    final protected static String ALL_SAMPLE_NAME = \"all\";\n+    final protected static String ALL_FAMILY_NAME = \"all\";\n+\n+    /**\n+     * The variant file(s) to evaluate.\n+     */\n+    @Argument(fullName=\"eval\", shortName = \"eval\", doc=\"Input evaluation file(s)\", optional=false)\n+    public List<FeatureInput<VariantContext>> evals;\n+\n+    /**\n+     * The variant file(s) to compare against.\n+     */\n+    @Argument(fullName = StandardArgumentDefinitions.COMPARISON_LONG_NAME, shortName = StandardArgumentDefinitions.COMPARISON_SHORT_NAME, doc=\"Input comparison file(s)\", optional=true)\n+    public List<FeatureInput<VariantContext>> compsProvided = new ArrayList<>();\n+    public List<FeatureInput<VariantContext>> comps = new ArrayList<>();\n+\n+    /**\n+     * dbSNP comparison VCF.  By default, the dbSNP file is used to specify the set of \"known\" variants.\n+     * Other sets can be specified with the -known-name (--known_names) argument.\n+     */\n+    @ArgumentCollection\n+    protected DbsnpArgumentCollection dbsnp = new DbsnpArgumentCollection();", "originalCommit": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU0NjEzNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547546135", "bodyText": "I did this and also a little more cleanup between VariantEval and VariantEvalArgumentCollection in expectation of introducing a new VariantEvalEngine after this PR is resolved", "author": "bbimber", "createdAt": "2020-12-22T22:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1OTM2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java\nindex 57ee33418..e5f3ec0a6 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java\n\n@@ -4,6 +4,7 @@ import htsjdk.tribble.Feature;\n import htsjdk.variant.variantcontext.VariantContext;\n import org.broadinstitute.barclay.argparser.Argument;\n import org.broadinstitute.barclay.argparser.ArgumentCollection;\n+import org.broadinstitute.barclay.argparser.Hidden;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.cmdline.argumentcollections.DbsnpArgumentCollection;\n import org.broadinstitute.hellbender.engine.FeatureInput;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2MTgxMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547361811", "bodyText": "All of the all caps variable names in this file should be changed to camel case (IntelliJ will change all call sites automatically for you: right click -> refactor -> rename).", "author": "cmnbroad", "createdAt": "2020-12-22T16:04:50Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.ArgumentCollection;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.argumentcollections.DbsnpArgumentCollection;\n+import org.broadinstitute.hellbender.engine.FeatureInput;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.utils.variant.GATKVariantContextUtils;\n+\n+import java.io.File;\n+import java.util.*;\n+\n+/**\n+ * The collection of arguments for VariantEval\n+ */\n+public class VariantEvalArgumentCollection {\n+\n+    // Public constants\n+    final protected static String ALL_SAMPLE_NAME = \"all\";\n+    final protected static String ALL_FAMILY_NAME = \"all\";\n+\n+    /**\n+     * The variant file(s) to evaluate.\n+     */\n+    @Argument(fullName=\"eval\", shortName = \"eval\", doc=\"Input evaluation file(s)\", optional=false)\n+    public List<FeatureInput<VariantContext>> evals;\n+\n+    /**\n+     * The variant file(s) to compare against.\n+     */\n+    @Argument(fullName = StandardArgumentDefinitions.COMPARISON_LONG_NAME, shortName = StandardArgumentDefinitions.COMPARISON_SHORT_NAME, doc=\"Input comparison file(s)\", optional=true)\n+    public List<FeatureInput<VariantContext>> compsProvided = new ArrayList<>();\n+    public List<FeatureInput<VariantContext>> comps = new ArrayList<>();\n+\n+    /**\n+     * dbSNP comparison VCF.  By default, the dbSNP file is used to specify the set of \"known\" variants.\n+     * Other sets can be specified with the -known-name (--known_names) argument.\n+     */\n+    @ArgumentCollection\n+    protected DbsnpArgumentCollection dbsnp = new DbsnpArgumentCollection();\n+\n+    /**\n+     * Some analyses want to count overlap not with dbSNP (which is in general very open) but\n+     * actually want to itemize their overlap specifically with a set of gold standard sites\n+     * such as HapMap, OMNI, or the gold standard indels.  This argument provides a mechanism\n+     * for communicating which file to use\n+     */\n+    @Argument(fullName=\"gold-standard\", shortName = \"gold\", doc=\"Evaluations that count calls at sites of true variation (e.g., indel calls) will use this argument as their gold standard for comparison\", optional=true)\n+    public FeatureInput<VariantContext> goldStandard = null;\n+\n+    // Partitioning the data arguments\n+    @Argument(shortName=\"select\", doc=\"One or more stratifications to use when evaluating the data\", optional=true)\n+    protected ArrayList<String> SELECT_EXPS = new ArrayList<String>();", "originalCommit": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU0NTgyMg==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547545822", "bodyText": "ok", "author": "bbimber", "createdAt": "2020-12-22T22:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2MTgxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java\nindex 57ee33418..e5f3ec0a6 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java\n\n@@ -4,6 +4,7 @@ import htsjdk.tribble.Feature;\n import htsjdk.variant.variantcontext.VariantContext;\n import org.broadinstitute.barclay.argparser.Argument;\n import org.broadinstitute.barclay.argparser.ArgumentCollection;\n+import org.broadinstitute.barclay.argparser.Hidden;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.cmdline.argumentcollections.DbsnpArgumentCollection;\n import org.broadinstitute.hellbender.engine.FeatureInput;\n"}}, {"oid": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "url": "https://github.com/broadinstitute/gatk/commit/c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class", "committedDate": "2020-12-23T18:36:56Z", "type": "forcePushed"}, {"oid": "35b969d0158466e6a6ac4130d46f8192136860ee", "url": "https://github.com/broadinstitute/gatk/commit/35b969d0158466e6a6ac4130d46f8192136860ee", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class", "committedDate": "2020-12-23T18:41:08Z", "type": "forcePushed"}, {"oid": "48d87916e7739526294ee39a72c6a1f32694bfde", "url": "https://github.com/broadinstitute/gatk/commit/48d87916e7739526294ee39a72c6a1f32694bfde", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class", "committedDate": "2021-01-04T14:50:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4NDY1NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r551584655", "bodyText": "This method can be a (non static instance) method on VariantEvalArgumentCollection.", "author": "cmnbroad", "createdAt": "2021-01-04T21:41:00Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,940 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+    private final GATKTool owner;\n+    private final Logger logger;\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n+\n+    private SampleDB sampleDB = null;\n+\n+    private List<FeatureInput<VariantContext>> knowns = new ArrayList<>();\n+\n+    // maintain the mapping of FeatureInput to name used in output file\n+    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n+\n+    // Variables\n+    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n+\n+    private boolean isSubsettingSamples;\n+    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n+    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n+\n+    // important stratifications\n+    private boolean byFilterIsEnabled = false;\n+    private boolean perSampleIsEnabled = false;\n+    private boolean perFamilyIsEnabled = false;\n+\n+    private AlleleFrequency.StratifyingScale AFScale = AlleleFrequency.StratifyingScale.LINEAR;\n+    private boolean useCompAFStratifier = false;\n+\n+    // maintain the mapping of source name (from VC) to FeatureInput name\n+    private Map<String, FeatureInput<VariantContext>> drivingVariantSourceMap;\n+\n+    // No args constructor for unit testing only\n+    @VisibleForTesting\n+    protected VariantEvalEngine(Logger logger) {\n+        this.variantEvalArgs = new VariantEvalArgumentCollection();\n+        this.owner = null;\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = null;\n+    }\n+\n+    public VariantEvalEngine(VariantEvalArgumentCollection variantEvalArgs, GATKTool owner, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable Collection<String> samples, Logger logger) {\n+        this.variantEvalArgs = variantEvalArgs;\n+        this.owner = owner;\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = samSequenceDictionaryForDrivingVariants;\n+\n+        // Cache map of source name -> FeatureInput\n+        drivingVariantSourceMap = new HashMap<>();\n+        VariantEvalEngine.getFeatureInputsForDrivingVariants(variantEvalArgs).forEach(x -> drivingVariantSourceMap.put(x.getName(), x));\n+\n+        validateAndInitialize(samples);\n+    }\n+\n+    /**\n+     * Initialize the stratifications, evaluations, evaluation contexts, and reporting object\n+     */\n+    private void validateAndInitialize(@Nullable Collection<String> samples) {\n+        sampleDB = SampleDB.createSampleDBFromPedigreeAndDataSources(variantEvalArgs.pedigreeFile, samples, PedigreeValidationType.STRICT);\n+\n+        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n+        variantEvalArgs.compsProvided.forEach(comp -> inputToNameMap.put(comp, comp.hasUserSuppliedName() ? comp.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n+        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n+            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n+            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n+            knowns.add(variantEvalArgs.dbsnp.dbsnp);\n+        }\n+\n+        variantEvalArgs.evals.forEach(eval -> inputToNameMap.put(eval, eval.hasUserSuppliedName() ? eval.getName() : \"eval\"));\n+\n+        // Set up set of additional knowns. dbSNP was addressed above, so use compsProvided, not comps\n+        for ( FeatureInput<VariantContext> compInput : variantEvalArgs.compsProvided ) {\n+            if (variantEvalArgs.knownNames.contains(getNameForInput(compInput)))\n+                knowns.add(compInput);\n+        }\n+\n+        // Now that we have all the inputs categorized, determine the sample list from the eval inputs.\n+        Map<String, VCFHeader> vcfInputs = new HashMap<>();\n+        variantEvalArgs.evals.forEach(eval -> vcfInputs.put(eval.getName(), (VCFHeader)owner.getHeaderForFeatures(eval)));\n+\n+        Set<String> vcfSamples = new HashSet<>();\n+        vcfInputs.forEach((k,v) -> vcfSamples.addAll(v.getSampleNamesInOrder()));\n+\n+        // Load the sample list, using an intermediate tree set to sort the samples\n+        final Set<String> allSampleNames = new HashSet<>(vcfSamples);\n+        sampleNamesForEvaluation.addAll(new TreeSet<>(variantEvalArgs.sampleExpressions.isEmpty() ? vcfSamples : Utils.filterCollectionByExpressions(vcfSamples, variantEvalArgs.sampleExpressions, false)));\n+\n+        isSubsettingSamples = ! sampleNamesForEvaluation.containsAll(allSampleNames);\n+        familyNamesForEvaluation.addAll(sampleDB.getFamilyIDs());\n+\n+        //If stratifying by sample name, assign a stratification for each sample we're evaluating (based on commandline args)...\n+        if (variantEvalArgs.stratificationsToUse.contains(\"Sample\") ) {\n+            sampleNamesForStratification.addAll(sampleNamesForEvaluation);\n+        }\n+        //...and also a stratification for the sum over all samples\n+        sampleNamesForStratification.add(VariantEvalArgumentCollection.ALL_SAMPLE_NAME);\n+\n+\n+        //If stratifying by sample name, assign a stratification for each family...\n+        if ( variantEvalArgs.stratificationsToUse.contains(\"Family\") ) {\n+            familyNamesForStratification.addAll(familyNamesForEvaluation);\n+        }\n+        //...and also a stratification for the sum over all families\n+        familyNamesForStratification.add(VariantEvalArgumentCollection.ALL_FAMILY_NAME);\n+\n+        // Initialize select expressions\n+        for (VariantContextUtils.JexlVCMatchExp jexl : VariantContextUtils.initializeMatchExps(variantEvalArgs.selectNames, variantEvalArgs.selectExps)) {\n+            SortableJexlVCMatchExp sjexl = new SortableJexlVCMatchExp(jexl.name, jexl.exp);\n+            jexlExpressions.add(sjexl);\n+        }\n+\n+        // Initialize the set of stratifications and evaluations to use\n+        // The list of stratifiers and evaluators to use\n+        final List<VariantStratifier> stratificationObjects = initializeStratificationObjects(variantEvalArgs.noStandardStratifications, variantEvalArgs.stratificationsToUse);\n+        final Set<Class<? extends VariantEvaluator>> evaluationClasses = initializeEvaluationObjects(variantEvalArgs.noStandardModules, variantEvalArgs.modulesToUse);\n+\n+        checkForIncompatibleEvaluatorsAndStratifiers(stratificationObjects, evaluationClasses);\n+\n+\n+        for ( VariantStratifier vs : stratificationObjects ) {\n+            if ( vs.getName().equals(\"Filter\") )\n+                byFilterIsEnabled = true;\n+            else if ( vs.getName().equals(\"Sample\") )\n+                perSampleIsEnabled = true;\n+            else if ( vs.getName().equals(\"Family\"))\n+                perFamilyIsEnabled = true;\n+        }\n+\n+        if (perSampleIsEnabled && perFamilyIsEnabled)\n+            throw new CommandLineException.BadArgumentValue(\"ST\", \"Variants cannot be stratified by sample and family at the same time\");\n+\n+        if (perFamilyIsEnabled && sampleDB.getTrios().isEmpty())\n+            throw new CommandLineException.BadArgumentValue(\"ST\", \"Cannot stratify by family without *.ped file\");\n+\n+\n+        if ( variantEvalArgs.intervalsFile != null ) {\n+            boolean fail = true;\n+            for ( final VariantStratifier vs : stratificationObjects ) {\n+                if ( vs.getClass().equals(IntervalStratification.class) )\n+                    fail = false;\n+            }\n+            if ( fail )\n+                throw new CommandLineException.BadArgumentValue(\"ST\", \"stratIntervals argument provided but -ST IntervalStratification not provided\");\n+        }\n+\n+\n+        // Initialize the evaluation contexts\n+        createStratificationStates(stratificationObjects, evaluationClasses);\n+\n+        // Load ancestral alignments\n+        if (variantEvalArgs.ancestralAlignmentsFile != null) {\n+            try {\n+                ancestralAlignments = new IndexedFastaSequenceFile(variantEvalArgs.ancestralAlignmentsFile.toPath());\n+            } catch (FileNotFoundException e) {\n+                throw new GATKException(String.format(\"The ancestral alignments file, '%s', could not be found\", variantEvalArgs.ancestralAlignmentsFile.getAbsolutePath()));\n+            }\n+        }\n+\n+        assertThatTerritoryIsSpecifiedIfNecessary();\n+    }\n+\n+    public String getNameForInput(FeatureInput<VariantContext> input) {\n+        return inputToNameMap.get(input);\n+    }\n+\n+    private void assertThatTerritoryIsSpecifiedIfNecessary() {\n+        final Set<String> evaluatorsWhichRequireTerritory = stratManager.values()\n+                .stream()\n+                .flatMap(ctx -> ctx.getVariantEvaluators().stream())\n+                .filter(Objects::nonNull)\n+                .filter(VariantEvaluator::requiresTerritoryToBeSpecified)\n+                .map(VariantEvaluator::getSimpleName)\n+                .collect(Collectors.toSet());\n+        if(!evaluatorsWhichRequireTerritory.isEmpty() && owner.getTraversalIntervals() == null){\n+            throw new UserException(\"You specified evaluators which require a covered territory to be specified.  \" +\n+                    \"\\nPlease specify intervals or a reference file or disable all of the following evaluators:\" +\n+                    evaluatorsWhichRequireTerritory.stream()\n+                            .collect(Collectors.joining(\", \")));\n+        }\n+    }\n+\n+    private void checkForIncompatibleEvaluatorsAndStratifiers( final List<VariantStratifier> stratificationObjects,\n+                                                               Set<Class<? extends VariantEvaluator>> evaluationClasses) {\n+        for ( final VariantStratifier vs : stratificationObjects ) {\n+            for ( Class<? extends VariantEvaluator> ec : evaluationClasses )\n+                if ( vs.getIncompatibleEvaluators().contains(ec) )\n+                    throw new CommandLineException.BadArgumentValue(\"ST and ET\",\n+                            \"The selected stratification \" + vs.getName() +\n+                                    \" and evaluator \" + ec.getSimpleName() +\n+                                    \" are incompatible due to combinatorial memory requirements.\" +\n+                                    \" Please disable one\");\n+        }\n+    }\n+\n+    protected void createStratificationStates(final List<VariantStratifier> stratificationObjects, final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n+        final List<VariantStratifier> strats = new ArrayList<VariantStratifier>(stratificationObjects);\n+        stratManager = new StratificationManager<>(strats);\n+\n+        logger.info(\"Creating \" + stratManager.size() + \" combinatorial stratification states\");\n+        for ( int i = 0; i < stratManager.size(); i++ ) {\n+            EvaluationContext ec = createEvaluationContext(evaluationObjects);\n+            stratManager.set(i, ec);\n+        }\n+    }\n+\n+    public static List<FeatureInput<VariantContext>> getFeatureInputsForDrivingVariants(VariantEvalArgumentCollection variantEvalArgs) {", "originalCommit": "48d87916e7739526294ee39a72c6a1f32694bfde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYwMzEzMg==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r551603132", "bodyText": "yes, good point", "author": "bbimber", "createdAt": "2021-01-04T22:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4NDY1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "58fec234a4f95ac93fe370f9ee2439a278425e6d", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\nindex efe30e6f7..6f912f939 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n\n@@ -11,6 +11,7 @@ import htsjdk.variant.variantcontext.VariantContextBuilder;\n import htsjdk.variant.variantcontext.VariantContextUtils;\n import htsjdk.variant.vcf.VCFConstants;\n import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.broadinstitute.barclay.argparser.CommandLineException;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5MjkzOA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r551592938", "bodyText": "It looks like the main reason you still need the GATK tool is to access user features and user intervals. You should be able to eliminate it by passing both (user intervals and the feature manager) in to the engine constructor instead of the tool.", "author": "cmnbroad", "createdAt": "2021-01-04T21:57:18Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,940 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+    private final GATKTool owner;\n+    private final Logger logger;\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n+\n+    private SampleDB sampleDB = null;\n+\n+    private List<FeatureInput<VariantContext>> knowns = new ArrayList<>();\n+\n+    // maintain the mapping of FeatureInput to name used in output file\n+    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n+\n+    // Variables\n+    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n+\n+    private boolean isSubsettingSamples;\n+    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n+    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n+\n+    // important stratifications\n+    private boolean byFilterIsEnabled = false;\n+    private boolean perSampleIsEnabled = false;\n+    private boolean perFamilyIsEnabled = false;\n+\n+    private AlleleFrequency.StratifyingScale AFScale = AlleleFrequency.StratifyingScale.LINEAR;\n+    private boolean useCompAFStratifier = false;\n+\n+    // maintain the mapping of source name (from VC) to FeatureInput name\n+    private Map<String, FeatureInput<VariantContext>> drivingVariantSourceMap;\n+\n+    // No args constructor for unit testing only\n+    @VisibleForTesting\n+    protected VariantEvalEngine(Logger logger) {\n+        this.variantEvalArgs = new VariantEvalArgumentCollection();\n+        this.owner = null;\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = null;\n+    }\n+\n+    public VariantEvalEngine(VariantEvalArgumentCollection variantEvalArgs, GATKTool owner, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable Collection<String> samples, Logger logger) {\n+        this.variantEvalArgs = variantEvalArgs;\n+        this.owner = owner;", "originalCommit": "48d87916e7739526294ee39a72c6a1f32694bfde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYwNTg1Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r551605857", "bodyText": "ok", "author": "bbimber", "createdAt": "2021-01-04T22:26:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5MjkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYwNzg0Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r551607843", "bodyText": "Note: I dont know how intentional you phrased that, but I'm proposing to pass the value of getTraversalIntervals(), so we dont duplicate that logic", "author": "bbimber", "createdAt": "2021-01-04T22:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5MjkzOA=="}], "type": "inlineReview", "revised_code": {"commit": "58fec234a4f95ac93fe370f9ee2439a278425e6d", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\nindex efe30e6f7..6f912f939 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n\n@@ -11,6 +11,7 @@ import htsjdk.variant.variantcontext.VariantContextBuilder;\n import htsjdk.variant.variantcontext.VariantContextUtils;\n import htsjdk.variant.vcf.VCFConstants;\n import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.broadinstitute.barclay.argparser.CommandLineException;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5NDc4Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r551594787", "bodyText": "It looks like there are only a couple of tests that access this - can  it be replaced with methods on the engine that delegate to the stratManager so it can be private?", "author": "cmnbroad", "createdAt": "2021-01-04T21:59:39Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,940 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+    private final GATKTool owner;\n+    private final Logger logger;\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    StratificationManager<VariantStratifier, EvaluationContext> stratManager;", "originalCommit": "48d87916e7739526294ee39a72c6a1f32694bfde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYwNzYxMA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r551607610", "bodyText": "How about a protected getter for now?", "author": "bbimber", "createdAt": "2021-01-04T22:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5NDc4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "58fec234a4f95ac93fe370f9ee2439a278425e6d", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\nindex efe30e6f7..6f912f939 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n\n@@ -11,6 +11,7 @@ import htsjdk.variant.variantcontext.VariantContextBuilder;\n import htsjdk.variant.variantcontext.VariantContextUtils;\n import htsjdk.variant.vcf.VCFConstants;\n import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.broadinstitute.barclay.argparser.CommandLineException;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEyNzU0Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556127546", "bodyText": "Some of the evaluators get the engine as a constructor arg, and some get it in finalizeEvaluation. I think it would make more sense to always pass it to the constructors.", "author": "cmnbroad", "createdAt": "2021-01-12T22:08:12Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/IndelLengthHistogram.java", "diffHunk": "@@ -44,7 +43,7 @@ private void initializeCounts(int size) {\n     }\n \n     @Override\n-    public void finalizeEvaluation() {\n+    public void finalizeEvaluation(final VariantEvalEngine engine) {", "originalCommit": "9a8836fdfeb635d275ce71f365bef469718e782a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE1OTI2OA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556159268", "bodyText": "ok", "author": "bbimber", "createdAt": "2021-01-12T23:15:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEyNzU0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "58fec234a4f95ac93fe370f9ee2439a278425e6d", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/IndelLengthHistogram.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/IndelLengthHistogram.java\nindex b85c1f8a6..5c6811fff 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/IndelLengthHistogram.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/IndelLengthHistogram.java\n\n@@ -43,7 +44,7 @@ public class IndelLengthHistogram extends VariantEvaluator implements StandardEv\n     }\n \n     @Override\n-    public void finalizeEvaluation(final VariantEvalEngine engine) {\n+    public void finalizeEvaluation() {\n         if ( asFrequencies ) {\n             results = new TreeMap<>();\n             for ( final int len : counts.keySet() ) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEyOTkyNA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556129924", "bodyText": "It seems like each subclass should have a constructor that takes an engine, and delegates it here. This can cache the engine and expose a getEngine method so that subclasses can access it.", "author": "cmnbroad", "createdAt": "2021-01-12T22:12:50Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java", "diffHunk": "@@ -19,26 +16,22 @@ protected VariantEvaluator() {\n         this.simpleName = getClass().getSimpleName();\n     }\n \n-    public void initialize(VariantEval walker) {\n-        this.walker = walker;\n-    }\n+    public void initialize(final VariantEvalEngine engine) {", "originalCommit": "9a8836fdfeb635d275ce71f365bef469718e782a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE2Mjg5NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556162895", "bodyText": "Yes, I see your point on pushing that into the constructor. I see GATK has a ClassUtils set of helpers, but I dont see anything that helps you find a constructor by arguments. I assume you want me to do something like this in EvauationContext?\nCurrent:\n    for ( final Class<? extends VariantEvaluator> c : evaluationClasses ) {\n        final VariantEvaluator eval = ClassUtils.makeInstanceOf(c);\n        //c.getDeclaredConstructor(VariantEvalEngine.class)\n        if ( doInitialize ) eval.initialize(engine);\n        evaluationInstances.add(eval);\n    }\n\nNew pattern:\npublic VariantStratifier createVariantStratifier(Class<? extends VariantStratifier> clazz) {\n    return createClass(clazz);\n}\n\npublic VariantEvaluator createVariantEvaluator(Class<? extends VariantEvaluator> clazz) {\n    return createClass(clazz);\n}\n\nprivate <T> T createClass(Class<? extends T> clazz) {\n    try {\n        return clazz.getDeclaredConstructor(VariantEvalEngine.class).newInstance(this);\n    }\n    catch (final InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n        throw new GATKException(\"Problem making an instance of \" + clazz + \" Do check that the class has a constructor that accepts VariantEvalEngine\", e);\n    }\n}\n\nOnly reason I ask is that I dont see similar examples on reflection like that in GATK4 and wasnt sure if there was a different pattern to use.", "author": "bbimber", "createdAt": "2021-01-12T23:24:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEyOTkyNA=="}], "type": "inlineReview", "revised_code": {"commit": "58fec234a4f95ac93fe370f9ee2439a278425e6d", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java\nindex d825ad91d..e6268f25a 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java\n\n@@ -7,17 +7,25 @@ import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalC\n \n public abstract class VariantEvaluator implements Comparable<VariantEvaluator> {\n     private final String simpleName;\n+    private final VariantEvalEngine engine;\n \n-    protected VariantEvaluator(String simpleName) {\n-        this.simpleName = simpleName;\n+    public VariantEvaluator(VariantEvalEngine engine) {\n+        this.engine = engine;\n+        this.simpleName = getClass().getSimpleName();\n     }\n \n-    protected VariantEvaluator() {\n-        this.simpleName = getClass().getSimpleName();\n+    //Note: this is used by DISCVR-seq / VariantQC\n+    public VariantEvaluator(VariantEvalEngine engine, final String simpleName) {\n+        this.engine = engine;\n+        this.simpleName = simpleName;\n     }\n \n-    public void initialize(final VariantEvalEngine engine) {\n+    public void initialize() {\n+\n+    }\n \n+    protected VariantEvalEngine getEngine() {\n+        return engine;\n     }\n \n     // Should return the number of VariantContexts expected as inputs to update.  Can be 1 or 2\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEzMDI2MA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556130260", "bodyText": "This appears to be unused. Is there some compelling use case for it ? Can it be removed ? This should really have only one constructor that takes the engine (see my related comment elsewhere).", "author": "cmnbroad", "createdAt": "2021-01-12T22:13:34Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java", "diffHunk": "@@ -1,14 +1,11 @@\n package org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators;\n \n import htsjdk.variant.variantcontext.VariantContext;\n-import org.broadinstitute.hellbender.engine.FeatureContext;\n-import org.broadinstitute.hellbender.engine.ReadsContext;\n-import org.broadinstitute.hellbender.engine.ReferenceContext;\n import org.broadinstitute.hellbender.exceptions.GATKException;\n-import org.broadinstitute.hellbender.tools.walkers.varianteval.VariantEval;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.VariantEvalEngine;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n \n public abstract class VariantEvaluator implements Comparable<VariantEvaluator> {\n-    private VariantEval walker;\n     private final String simpleName;\n \n     protected VariantEvaluator(String simpleName) {", "originalCommit": "9a8836fdfeb635d275ce71f365bef469718e782a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE2NjY1NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556166655", "bodyText": "ok", "author": "bbimber", "createdAt": "2021-01-12T23:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEzMDI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3OTEzNg==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556879136", "bodyText": "When I checked out VariantQC, I see I created it to support that tool.  I added a comment to that effect - any concerns about keeping it? I could think about other ways to approach this. The easiest would be to add a setSimpleName(), but I'm not sure that's really better than this.", "author": "bbimber", "createdAt": "2021-01-13T21:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEzMDI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "58fec234a4f95ac93fe370f9ee2439a278425e6d", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java\nindex d825ad91d..e6268f25a 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java\n\n@@ -7,17 +7,25 @@ import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalC\n \n public abstract class VariantEvaluator implements Comparable<VariantEvaluator> {\n     private final String simpleName;\n+    private final VariantEvalEngine engine;\n \n-    protected VariantEvaluator(String simpleName) {\n-        this.simpleName = simpleName;\n+    public VariantEvaluator(VariantEvalEngine engine) {\n+        this.engine = engine;\n+        this.simpleName = getClass().getSimpleName();\n     }\n \n-    protected VariantEvaluator() {\n-        this.simpleName = getClass().getSimpleName();\n+    //Note: this is used by DISCVR-seq / VariantQC\n+    public VariantEvaluator(VariantEvalEngine engine, final String simpleName) {\n+        this.engine = engine;\n+        this.simpleName = simpleName;\n     }\n \n-    public void initialize(final VariantEvalEngine engine) {\n+    public void initialize() {\n+\n+    }\n \n+    protected VariantEvalEngine getEngine() {\n+        return engine;\n     }\n \n     // Should return the number of VariantContexts expected as inputs to update.  Can be 1 or 2\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEzNjkxOA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556136918", "bodyText": "There are quite a few methods here that are just pass-through wrappers to VariantEvalArgs. Instead of exposing them again, just add a VariantEvalArgs getter here, and move the safe methods (preserving the unmodifiable collections) to VariantEvalArgs.", "author": "cmnbroad", "createdAt": "2021-01-12T22:25:59Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,937 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+\n+    private final Logger logger;\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+    private final List<SimpleInterval> traversalIntervals;\n+    private final FeatureManager features;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    private StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n+\n+    private SampleDB sampleDB = null;\n+\n+    private List<FeatureInput<VariantContext>> knowns = new ArrayList<>();\n+\n+    // maintain the mapping of FeatureInput to name used in output file\n+    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n+\n+    // Variables\n+    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n+\n+    private boolean isSubsettingSamples;\n+    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n+    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n+\n+    // important stratifications\n+    private boolean byFilterIsEnabled = false;\n+    private boolean perSampleIsEnabled = false;\n+    private boolean perFamilyIsEnabled = false;\n+\n+    private AlleleFrequency.StratifyingScale AFScale = AlleleFrequency.StratifyingScale.LINEAR;\n+    private boolean useCompAFStratifier = false;\n+\n+    // maintain the mapping of source name (from VC) to FeatureInput name\n+    private Map<String, FeatureInput<VariantContext>> drivingVariantSourceMap;\n+\n+    // No args constructor for unit testing only\n+    @VisibleForTesting\n+    protected VariantEvalEngine(Logger logger) {\n+        this.variantEvalArgs = new VariantEvalArgumentCollection();\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = null;\n+        this.traversalIntervals = null;\n+        this.features = null;\n+    }\n+\n+    public VariantEvalEngine(VariantEvalArgumentCollection variantEvalArgs, FeatureManager features, List<SimpleInterval> traversalIntervals, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable Collection<String> samples, Logger logger) {\n+        this.variantEvalArgs = variantEvalArgs;\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = samSequenceDictionaryForDrivingVariants;\n+        this.traversalIntervals = traversalIntervals;\n+        this.features = features;\n+\n+        // Cache map of source name -> FeatureInput\n+        drivingVariantSourceMap = new HashMap<>();\n+        variantEvalArgs.getFeatureInputsForDrivingVariants().forEach(x -> drivingVariantSourceMap.put(x.getName(), x));\n+\n+        validateAndInitialize(samples);\n+    }\n+\n+    /**\n+     * Initialize the stratifications, evaluations, evaluation contexts, and reporting object\n+     */\n+    private void validateAndInitialize(@Nullable Collection<String> samples) {\n+        sampleDB = SampleDB.createSampleDBFromPedigreeAndDataSources(variantEvalArgs.pedigreeFile, samples, PedigreeValidationType.STRICT);\n+\n+        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n+        variantEvalArgs.compsProvided.forEach(comp -> inputToNameMap.put(comp, comp.hasUserSuppliedName() ? comp.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n+        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n+            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n+            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n+            knowns.add(variantEvalArgs.dbsnp.dbsnp);\n+        }\n+\n+        variantEvalArgs.evals.forEach(eval -> inputToNameMap.put(eval, eval.hasUserSuppliedName() ? eval.getName() : \"eval\"));\n+\n+        // Set up set of additional knowns. dbSNP was addressed above, so use compsProvided, not comps\n+        for ( FeatureInput<VariantContext> compInput : variantEvalArgs.compsProvided ) {\n+            if (variantEvalArgs.knownNames.contains(getNameForInput(compInput)))\n+                knowns.add(compInput);\n+        }\n+\n+        // Now that we have all the inputs categorized, determine the sample list from the eval inputs.\n+        Map<String, VCFHeader> vcfInputs = new HashMap<>();\n+        variantEvalArgs.evals.forEach(eval -> vcfInputs.put(eval.getName(), (VCFHeader)features.getHeader(eval)));\n+\n+        Set<String> vcfSamples = new HashSet<>();\n+        vcfInputs.forEach((k,v) -> vcfSamples.addAll(v.getSampleNamesInOrder()));\n+\n+        // Load the sample list, using an intermediate tree set to sort the samples\n+        final Set<String> allSampleNames = new HashSet<>(vcfSamples);\n+        sampleNamesForEvaluation.addAll(new TreeSet<>(variantEvalArgs.sampleExpressions.isEmpty() ? vcfSamples : Utils.filterCollectionByExpressions(vcfSamples, variantEvalArgs.sampleExpressions, false)));\n+\n+        isSubsettingSamples = ! sampleNamesForEvaluation.containsAll(allSampleNames);\n+        familyNamesForEvaluation.addAll(sampleDB.getFamilyIDs());\n+\n+        //If stratifying by sample name, assign a stratification for each sample we're evaluating (based on commandline args)...\n+        if (variantEvalArgs.stratificationsToUse.contains(\"Sample\") ) {\n+            sampleNamesForStratification.addAll(sampleNamesForEvaluation);\n+        }\n+        //...and also a stratification for the sum over all samples\n+        sampleNamesForStratification.add(VariantEvalArgumentCollection.ALL_SAMPLE_NAME);\n+\n+\n+        //If stratifying by sample name, assign a stratification for each family...\n+        if ( variantEvalArgs.stratificationsToUse.contains(\"Family\") ) {\n+            familyNamesForStratification.addAll(familyNamesForEvaluation);\n+        }\n+        //...and also a stratification for the sum over all families\n+        familyNamesForStratification.add(VariantEvalArgumentCollection.ALL_FAMILY_NAME);\n+\n+        // Initialize select expressions\n+        for (VariantContextUtils.JexlVCMatchExp jexl : VariantContextUtils.initializeMatchExps(variantEvalArgs.selectNames, variantEvalArgs.selectExps)) {\n+            SortableJexlVCMatchExp sjexl = new SortableJexlVCMatchExp(jexl.name, jexl.exp);\n+            jexlExpressions.add(sjexl);\n+        }\n+\n+        // Initialize the set of stratifications and evaluations to use\n+        // The list of stratifiers and evaluators to use\n+        final List<VariantStratifier> stratificationObjects = initializeStratificationObjects(variantEvalArgs.noStandardStratifications, variantEvalArgs.stratificationsToUse);\n+        final Set<Class<? extends VariantEvaluator>> evaluationClasses = initializeEvaluationObjects(variantEvalArgs.noStandardModules, variantEvalArgs.modulesToUse);\n+\n+        checkForIncompatibleEvaluatorsAndStratifiers(stratificationObjects, evaluationClasses);\n+\n+\n+        for ( VariantStratifier vs : stratificationObjects ) {\n+            if ( vs.getName().equals(\"Filter\") )\n+                byFilterIsEnabled = true;\n+            else if ( vs.getName().equals(\"Sample\") )\n+                perSampleIsEnabled = true;\n+            else if ( vs.getName().equals(\"Family\"))\n+                perFamilyIsEnabled = true;\n+        }\n+\n+        if (perSampleIsEnabled && perFamilyIsEnabled)\n+            throw new CommandLineException.BadArgumentValue(\"ST\", \"Variants cannot be stratified by sample and family at the same time\");\n+\n+        if (perFamilyIsEnabled && sampleDB.getTrios().isEmpty())\n+            throw new CommandLineException.BadArgumentValue(\"ST\", \"Cannot stratify by family without *.ped file\");\n+\n+\n+        if ( variantEvalArgs.intervalsFile != null ) {\n+            boolean fail = true;\n+            for ( final VariantStratifier vs : stratificationObjects ) {\n+                if ( vs.getClass().equals(IntervalStratification.class) )\n+                    fail = false;\n+            }\n+            if ( fail )\n+                throw new CommandLineException.BadArgumentValue(\"ST\", \"stratIntervals argument provided but -ST IntervalStratification not provided\");\n+        }\n+\n+\n+        // Initialize the evaluation contexts\n+        createStratificationStates(stratificationObjects, evaluationClasses);\n+\n+        // Load ancestral alignments\n+        if (variantEvalArgs.ancestralAlignmentsFile != null) {\n+            try {\n+                ancestralAlignments = new IndexedFastaSequenceFile(variantEvalArgs.ancestralAlignmentsFile.toPath());\n+            } catch (FileNotFoundException e) {\n+                throw new GATKException(String.format(\"The ancestral alignments file, '%s', could not be found\", variantEvalArgs.ancestralAlignmentsFile.getAbsolutePath()));\n+            }\n+        }\n+\n+        assertThatTerritoryIsSpecifiedIfNecessary();\n+    }\n+\n+    public String getNameForInput(FeatureInput<VariantContext> input) {\n+        return inputToNameMap.get(input);\n+    }\n+\n+    private void assertThatTerritoryIsSpecifiedIfNecessary() {\n+        final Set<String> evaluatorsWhichRequireTerritory = stratManager.values()\n+                .stream()\n+                .flatMap(ctx -> ctx.getVariantEvaluators().stream())\n+                .filter(Objects::nonNull)\n+                .filter(VariantEvaluator::requiresTerritoryToBeSpecified)\n+                .map(VariantEvaluator::getSimpleName)\n+                .collect(Collectors.toSet());\n+        if (!evaluatorsWhichRequireTerritory.isEmpty() && traversalIntervals == null){\n+            throw new UserException(\"You specified evaluators which require a covered territory to be specified.  \" +\n+                    \"\\nPlease specify intervals or a reference file or disable all of the following evaluators:\" +\n+                    evaluatorsWhichRequireTerritory.stream()\n+                            .collect(Collectors.joining(\", \")));\n+        }\n+    }\n+\n+    private void checkForIncompatibleEvaluatorsAndStratifiers( final List<VariantStratifier> stratificationObjects,\n+                                                               Set<Class<? extends VariantEvaluator>> evaluationClasses) {\n+        for ( final VariantStratifier vs : stratificationObjects ) {\n+            for ( Class<? extends VariantEvaluator> ec : evaluationClasses )\n+                if ( vs.getIncompatibleEvaluators().contains(ec) )\n+                    throw new CommandLineException.BadArgumentValue(\"ST and ET\",\n+                            \"The selected stratification \" + vs.getName() +\n+                                    \" and evaluator \" + ec.getSimpleName() +\n+                                    \" are incompatible due to combinatorial memory requirements.\" +\n+                                    \" Please disable one\");\n+        }\n+    }\n+\n+    protected void createStratificationStates(final List<VariantStratifier> stratificationObjects, final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n+        final List<VariantStratifier> strats = new ArrayList<VariantStratifier>(stratificationObjects);\n+        stratManager = new StratificationManager<>(strats);\n+\n+        logger.info(\"Creating \" + stratManager.size() + \" combinatorial stratification states\");\n+        for ( int i = 0; i < stratManager.size(); i++ ) {\n+            EvaluationContext ec = createEvaluationContext(evaluationObjects);\n+            stratManager.set(i, ec);\n+        }\n+    }\n+\n+    public void finalizeReport(File outFile) {\n+        // go through the evaluations and finalize them\n+        for ( final EvaluationContext nec : stratManager.values() )\n+            for ( final VariantEvaluator ve : nec.getVariantEvaluators() )\n+                ve.finalizeEvaluation(this);\n+\n+        //send data to MetricsCollection\n+        CompOverlap compOverlap = null;\n+        IndelSummary indelSummary = null;\n+        CountVariants countVariants = null;\n+        MultiallelicSummary multiallelicSummary = null;\n+        TiTvVariantEvaluator tiTvVariantEvaluator = null;\n+        MetricsCollection metricsCollection = null;\n+        for (final EvaluationContext nec: stratManager.values()) {\n+            for (final VariantEvaluator ve : nec.getVariantEvaluators()) {\n+                if (ve instanceof CompOverlap)\n+                    compOverlap = (CompOverlap) ve;\n+                else if (ve instanceof IndelSummary)\n+                    indelSummary = (IndelSummary) ve;\n+                else if (ve instanceof CountVariants)\n+                    countVariants = (CountVariants) ve;\n+                else if (ve instanceof MultiallelicSummary)\n+                    multiallelicSummary = (MultiallelicSummary) ve;\n+                else if (ve instanceof TiTvVariantEvaluator)\n+                    tiTvVariantEvaluator = (TiTvVariantEvaluator) ve;\n+                else if (ve instanceof MetricsCollection)\n+                    metricsCollection = (MetricsCollection) ve;\n+            }\n+\n+            if (metricsCollection != null)\n+                metricsCollection.setData(compOverlap.concordantRate, indelSummary.n_SNPs, countVariants.nSNPs, indelSummary.n_indels, multiallelicSummary.nIndels, indelSummary.insertion_to_deletion_ratio, countVariants.insertionDeletionRatio, tiTvVariantEvaluator.tiTvRatio);\n+        }\n+\n+        try (PrintStream out = IOUtils.makePrintStreamMaybeGzipped(new GATKPath(outFile.getAbsolutePath()))) {\n+            VariantEvalReportWriter.writeReport(out, stratManager, stratManager.getStratifiers(), stratManager.get(0).getVariantEvaluators());\n+        }\n+        catch(IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(e.getMessage(), e);\n+        }\n+    }\n+\n+    private Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(final List<VariantContext> variants) {\n+        final Map<FeatureInput<VariantContext>, List<VariantContext>> byFeatureInput = new HashMap<>();\n+        variants.forEach(vc -> byFeatureInput.compute(drivingVariantSourceMap.get(vc.getSource()),\n+                (k, v) -> {\n+                    final List<VariantContext> variantList = v == null ? new ArrayList<>() : v;\n+                    variantList.add(vc);\n+                    return variantList;\n+                }\n+        ));\n+        return byFeatureInput;\n+    }\n+\n+    public void apply(final List<VariantContext> variantContexts, final ReferenceContext referenceContext) {\n+        final Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap = groupVariantsByFeatureInput(variantContexts);\n+\n+        final List<VariantContext> allEvals = new ArrayList<>();\n+        for (FeatureInput<VariantContext> eval : variantEvalArgs.evals) {\n+            if (variantMap.containsKey(eval)) {\n+                allEvals.addAll(variantMap.get(eval));\n+            }\n+        }\n+\n+        final List<VariantContext> allComps = new ArrayList<>();\n+        if (variantEvalArgs.comps != null) {\n+            for (FeatureInput<VariantContext> comp : variantEvalArgs.comps) {\n+                if (variantMap.containsKey(comp)) {\n+                    allComps.addAll(variantMap.get(comp));\n+                }\n+            }\n+        }\n+\n+        final SimpleInterval interval = allEvals.isEmpty() ? new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), variantContexts.get(0).getStart()) : generateContextInterval(allEvals);\n+        final FeatureContext featureContext = new FeatureContext(features, interval);\n+\n+        final Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> evalVCs = allEvals.isEmpty() ? Collections.emptyMap() : bindVariantContexts(variantMap, variantEvalArgs.evals, byFilterIsEnabled, true, perSampleIsEnabled, perFamilyIsEnabled, variantEvalArgs.mergeEvals);\n+        final Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs = allComps.isEmpty() ? Collections.emptyMap() : bindVariantContexts(variantMap, variantEvalArgs.comps, byFilterIsEnabled, false, false, false, false);\n+\n+        final VariantEvalContext variantEvalContext = new VariantEvalContext(referenceContext, featureContext, variantMap, this);\n+\n+        // for each eval track\n+        for ( final FeatureInput<VariantContext> evalInput : variantEvalArgs.evals ) {\n+            final Map<String, Collection<VariantContext>> evalSet = evalVCs.containsKey(evalInput) ? evalVCs.get(evalInput) : Collections.emptyMap();\n+\n+            Set<String> statificationLevels;\n+\n+            // for each sample stratifier\n+            if (perFamilyIsEnabled)\n+                statificationLevels = familyNamesForStratification;\n+            else\n+                statificationLevels = sampleNamesForStratification;\n+            for ( final String stratLevelName : statificationLevels ) {\n+                Collection<VariantContext> evalSetBySample = evalSet.get(stratLevelName);\n+\n+                if ( evalSetBySample == null ) {\n+                    evalSetBySample = new HashSet<>(1);\n+                    evalSetBySample.add(null);\n+                }\n+\n+                // for each eval in the track\n+                for ( VariantContext eval : evalSetBySample ) {\n+                    String aastr = (ancestralAlignments == null) ? null : new String(ancestralAlignments.getSubsequenceAt(eval.getContig(), eval.getStart(), eval.getEnd()).getBases());\n+\n+                    // deal with ancestral alleles if requested\n+                    if ( eval != null && aastr != null ) {\n+                        eval = new VariantContextBuilder(eval).attribute(\"ANCESTRALALLELE\", aastr).make();\n+                    }\n+\n+                    String evalName = getNameForInput(evalInput);\n+\n+                    // for each comp track\n+                    for ( final FeatureInput<VariantContext> compInput : variantEvalArgs.comps ) {\n+                        processComp(variantEvalContext, eval, evalName, compInput, stratLevelName, compVCs, evalSetBySample);\n+                    }\n+\n+                    if (variantEvalArgs.comps.isEmpty()) {\n+                        processComp(variantEvalContext, eval, evalName, null, stratLevelName, compVCs, evalSetBySample);\n+                    }\n+                }\n+            }\n+\n+            if ( variantEvalArgs.mergeEvals ) break; // stop processing the eval tracks\n+        }\n+    }\n+\n+\n+    /**\n+     * Create the EvaluationContext (new instance) for the provided set of VariantEvaluators.\n+     *\n+     * @param evaluationObjects The list of VariantEvaluator classes\n+     * @return The EvaluationContext for this set of VariantEvaluator classes\n+     */\n+    protected EvaluationContext createEvaluationContext(final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n+        return new EvaluationContext(this, evaluationObjects);\n+    }\n+\n+    public boolean isSubsettingToSpecificSamples() { return isSubsettingSamples; }\n+\n+    public Set<String> getSampleNamesForEvaluation() { return sampleNamesForEvaluation; }\n+\n+    public Set<String> getFamilyNamesForEvaluation() { return familyNamesForEvaluation; }\n+\n+    public int getNumberOfSamplesForEvaluation() {\n+        if (sampleNamesForEvaluation!= null &&  !sampleNamesForEvaluation.isEmpty())\n+            return sampleNamesForEvaluation.size();\n+        else {\n+            return variantEvalArgs.numSamplesFromArgument;\n+        }\n+    }\n+    public Set<String> getSampleNamesForStratification() { return sampleNamesForStratification; }\n+\n+    public Set<String> getFamilyNamesForStratification() { return familyNamesForStratification; }\n+\n+    public Set<SortableJexlVCMatchExp> getJexlExpressions() { return jexlExpressions; }\n+\n+\n+    public AlleleFrequency.StratifyingScale getAFScale() { return AFScale; }\n+    public boolean getCompAFStratifier() { return useCompAFStratifier; }\n+\n+    public SampleDB getSampleDB() {\n+        return sampleDB;\n+    }\n+\n+    public List<FeatureInput<VariantContext>> getKnowns() {\n+        return knowns;\n+    }\n+\n+    /**\n+     * If an evaluator calls this method it must override {@link VariantEvaluator#requiresTerritoryToBeSpecified()} to return true.\n+     * @return either the size of the interval list given to the tool or the size of the reference given to the tool\n+     */\n+    public long getnProcessedLoci() {\n+        if (traversalIntervals == null){\n+            throw new GATKException(\"BUG: One of the evaluators used should have overriden requiresTerritoryToBeSpecified, please report this to the developers.\" +\n+                    \"\\nEvaluators: \" + stratManager.values()\n+                    .stream()\n+                    .flatMap(evaluator -> evaluator.getVariantEvaluators().stream())\n+                    .map(VariantEvaluator::getSimpleName)\n+                    .sorted()\n+                    .distinct()\n+                    .collect(Collectors.joining(\", \")));\n+        }\n+        return traversalIntervals.stream().mapToLong(SimpleInterval::size).sum();\n+    }\n+\n+    private boolean compHasMatchingEval(final VariantContext comp, final Collection<VariantContext> evals) {\n+        // find all of the matching comps\n+        for ( final VariantContext eval : evals ) {\n+            if ( eval != null && doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) != EvalCompMatchType.NO_MATCH )\n+                return true;\n+        }\n+\n+        // nothing matched\n+        return false;\n+    }\n+\n+    private enum EvalCompMatchType { NO_MATCH, STRICT, LENIENT }\n+\n+    private EvalCompMatchType doEvalAndCompMatch(final VariantContext eval, final VariantContext comp, boolean requireStrictAlleleMatch) {\n+        if ( comp.getType() == VariantContext.Type.NO_VARIATION || eval.getType() == VariantContext.Type.NO_VARIATION )\n+            // if either of these are NO_VARIATION they are LENIENT matches\n+            return EvalCompMatchType.LENIENT;\n+\n+        if ( comp.getType() != eval.getType() )\n+            return EvalCompMatchType.NO_MATCH;\n+\n+        // find the comp which matches both the reference allele and alternate allele from eval\n+        final Allele altEval = eval.getAlternateAlleles().size() == 0 ? null : eval.getAlternateAllele(0);\n+        final Allele altComp = comp.getAlternateAlleles().size() == 0 ? null : comp.getAlternateAllele(0);\n+        if ((altEval == null && altComp == null) || (altEval != null && altEval.equals(altComp) && eval.getReference().equals(comp.getReference())))\n+            return EvalCompMatchType.STRICT;\n+        else\n+            return requireStrictAlleleMatch ? EvalCompMatchType.NO_MATCH : EvalCompMatchType.LENIENT;\n+    }\n+\n+    private VariantContext findMatchingComp(final VariantContext eval, final Collection<VariantContext> comps) {\n+        // if no comps, return null\n+        if ( comps == null || comps.isEmpty() )\n+            return null;\n+\n+        // if no eval, return any comp\n+        if ( eval == null )\n+            return comps.iterator().next();\n+\n+        // find all of the matching comps\n+        VariantContext lenientMatch = null;\n+        for ( final VariantContext comp : comps ) {\n+            switch ( doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) ) {\n+                case STRICT:\n+                    return comp;\n+                case LENIENT:\n+                    if ( lenientMatch == null ) lenientMatch = comp;\n+                    break;\n+                case NO_MATCH:\n+                    // do nothing\n+            }\n+        }\n+\n+        // nothing matched, just return lenientMatch, which might be null\n+        return lenientMatch;\n+    }\n+\n+    private SimpleInterval generateContextInterval(List<VariantContext> variantContexts) {\n+        final int maxEnd = variantContexts.stream().map(VariantContext::getEnd).max(Integer::compareTo).get();\n+\n+        return new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), maxEnd);\n+    }\n+\n+    private void processComp(VariantEvalContext vec, VariantContext eval, String evalName, FeatureInput<VariantContext> compInput, String stratLevelName, Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs, Collection<VariantContext> evalSetBySample) {\n+        String compName = getNameForInput(compInput);\n+\n+        // no sample stratification for comps\n+        final HashMap<String, Collection<VariantContext>> compSetHash = compInput == null ? null : compVCs.get(compInput);\n+        final Collection<VariantContext> compSet = (compSetHash == null || compSetHash.isEmpty()) ? Collections.<VariantContext>emptyList() : compVCs.get(compInput).values().iterator().next();\n+\n+        // find the comp\n+        final VariantContext comp = findMatchingComp(eval, compSet);\n+\n+        Collection<EvaluationContext> contextsForStratification;\n+        if (perFamilyIsEnabled)\n+            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, null, stratLevelName);\n+        else {\n+            String familyID;\n+            if (stratLevelName.equals(\"all\"))\n+                familyID = \"all\";\n+            else\n+                familyID = sampleDB.getSample(stratLevelName).getFamilyID();\n+            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, stratLevelName, familyID);\n+        }\n+        for ( EvaluationContext nec : contextsForStratification ) {\n+\n+            // eval against the comp\n+            synchronized (nec) {\n+                nec.apply(vec, comp, eval);\n+            }\n+\n+            // eval=null against all comps of different type that aren't bound to another eval\n+            for ( VariantContext otherComp : compSet ) {\n+                if ( otherComp != comp && ! compHasMatchingEval(otherComp, evalSetBySample) ) {\n+                    synchronized (nec) {\n+                        nec.apply(vec, otherComp, null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Given specific eval and comp VCs and the sample name, return an iterable\n+     * over all of the applicable state keys.\n+     *\n+     * this code isn't structured yet for efficiency.  Here we currently are\n+     * doing the following inefficient algorithm:\n+     *\n+     * for each strat:\n+     *   get list of relevant states that eval and comp according to strat\n+     *   add this list of states to a list of list states\n+     *\n+     * then\n+     *\n+     * ask the strat manager to look up all of the keys associated with the combinations\n+     * of these states.  For example, suppose we have a single variant S.  We have active\n+     * strats EvalFeatureInput, CompFeatureInput, and Novelty.  We produce a list that looks like:\n+     *\n+     *   L = [[Eval], [Comp], [All, Novel]]\n+     *\n+     * We then go through the strat manager tree to produce the keys associated with these states:\n+     *\n+     *   K = [0, 1] where EVAL x COMP x ALL = 0 and EVAL x COMP x NOVEL = 1\n+     *\n+     * It's clear that a better\n+     *\n+     *\n+     * @param vec\n+     * @param eval\n+     * @param evalName\n+     * @param comp\n+     * @param compName\n+     * @param sampleName\n+     * @return\n+     */\n+    protected Collection<EvaluationContext> getEvaluationContexts(final VariantEvalContext vec,\n+                                                                  final VariantContext eval,\n+                                                                  final String evalName,\n+                                                                  final VariantContext comp,\n+                                                                  final String compName,\n+                                                                  final String sampleName,\n+                                                                  final String familyName) {\n+        final List<List<Object>> states = new LinkedList<>();\n+        for ( final VariantStratifier vs : stratManager.getStratifiers() ) {\n+            states.add(vs.getRelevantStates(vec, comp, compName, eval, evalName, sampleName, familyName));\n+        }\n+        return stratManager.values(states);\n+    }\n+\n+    protected List<String> getModulesToUse() {\n+        return Collections.unmodifiableList(variantEvalArgs.modulesToUse);\n+    }\n+\n+    /**\n+     * For a list of track names, bind the variant contexts to a trackName->sampleName->VariantContext mapping.\n+     * Additional variant contexts per sample are automatically generated and added to the map unless the sample name\n+     * matches the ALL_SAMPLE_NAME constant.\n+     *\n+     * @return the mapping of track to VC list that should be populated\n+     */\n+    public HashMap<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>>\n+    bindVariantContexts(Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap,\n+                        List<FeatureInput<VariantContext>> tracks,\n+                        boolean byFilter,\n+                        boolean subsetBySample,\n+                        boolean trackPerSample,\n+                        boolean trackPerFamily,\n+                        boolean mergeTracks) {\n+        HashMap<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> bindings = new HashMap<>();\n+\n+        FeatureInput<VariantContext> firstTrack = tracks.isEmpty() ? null : tracks.get(0);\n+        for (FeatureInput<VariantContext> track : tracks) {\n+            HashMap<String, Collection<VariantContext>> mapping = new HashMap<>();\n+\n+            if (variantMap.containsKey(track)) {\n+                //Note: these are limiting to only those w/ the same start, as was the GATK3 behavior.\n+                for (VariantContext vc : variantMap.get(track)) {\n+\n+                    // First, filter the VariantContext to represent only the samples for evaluation\n+                    VariantContext vcsub = vc;\n+\n+                    if ((subsetBySample) && vc.hasGenotypes())\n+                        vcsub = getSubsetOfVariantContext(vc, getSampleNamesForEvaluation());\n+\n+                    //always add a mapping for all samples together\n+                    if ((byFilter || !vcsub.isFiltered())) {\n+                        addMapping(mapping, VariantEvalArgumentCollection.ALL_SAMPLE_NAME, vcsub);\n+                    }\n+\n+                    // Now, if stratifying, split the subsetted vc per sample and add each as a new context\n+                    if (vc.hasGenotypes() && trackPerSample) {\n+                        for (String sampleName : getSampleNamesForEvaluation()) {\n+                            final VariantContext samplevc = getSubsetOfVariantContext(vc, sampleName);\n+\n+                            if (byFilter || !samplevc.isFiltered()) {\n+                                addMapping(mapping, sampleName, samplevc);\n+                            }\n+                        }\n+                    } else if (vc.hasGenotypes() && trackPerFamily) {\n+                        for (final String familyName : getFamilyNamesForEvaluation()) {\n+                            Set<String> familyMemberNames;\n+                            //if the current stratification family name is \"all\", then add all the families to the VC for evaluation here\n+                            if (familyName.equals(VariantEvalArgumentCollection.ALL_FAMILY_NAME)) {\n+                                familyMemberNames = getSampleNamesForEvaluation();\n+                            } else {\n+                                familyMemberNames = getSampleDB().getFamily(familyName).stream().map(Sample::getID).collect(Collectors.toSet());\n+                            }\n+                            final VariantContext samplevc = getSubsetOfVariantContext(vc, familyMemberNames);\n+\n+                            if (byFilter || !samplevc.isFiltered()) {\n+                                addMapping(mapping, familyName, samplevc);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (mergeTracks && bindings.containsKey(firstTrack)) {\n+                // go through each binding of sample -> value and add all of the bindings from this entry\n+                HashMap<String, Collection<VariantContext>> firstMapping = bindings.get(firstTrack);\n+                for (Map.Entry<String, Collection<VariantContext>> elt : mapping.entrySet()) {\n+                    Collection<VariantContext> firstMappingSet = firstMapping.get(elt.getKey());\n+                    if (firstMappingSet != null) {\n+                        firstMappingSet.addAll(elt.getValue());\n+                    } else {\n+                        firstMapping.put(elt.getKey(), elt.getValue());\n+                    }\n+                }\n+            } else {\n+                bindings.put(track, mapping);\n+            }\n+        }\n+\n+        return bindings;\n+    }\n+\n+    private void addMapping(HashMap<String, Collection<VariantContext>> mappings, String sample, VariantContext vc) {\n+        if (!mappings.containsKey(sample))\n+            mappings.put(sample, new ArrayList<>(1));\n+        mappings.get(sample).add(vc);\n+    }\n+\n+    /**\n+     * Subset a VariantContext to a single sample\n+     *\n+     * @param vc         the VariantContext object containing multiple samples\n+     * @param sampleName the sample to pull out of the VariantContext\n+     * @return a new VariantContext with just the requested sample\n+     */\n+    public VariantContext getSubsetOfVariantContext(VariantContext vc, String sampleName) {\n+        return getSubsetOfVariantContext(vc, Collections.singleton(sampleName));\n+    }\n+\n+    /**\n+     * Subset a VariantContext to a set of samples\n+     *\n+     * @param vc          the VariantContext object containing multiple samples\n+     * @param sampleNames the samples to pull out of the VariantContext\n+     * @return a new VariantContext with just the requested samples\n+     */\n+    public VariantContext getSubsetOfVariantContext(VariantContext vc, Set<String> sampleNames) {\n+        // if we want to preserve AC0 sites as polymorphic we need to not rederive alleles\n+        final boolean deriveAlleles = ignoreAC0Sites();\n+        return ensureAnnotations(vc, vc.subContextFromSamples(sampleNames, deriveAlleles));\n+    }\n+\n+    public VariantContext ensureAnnotations(final VariantContext vc, final VariantContext vcsub) {\n+        final int originalAlleleCount = vc.getHetCount() + 2 * vc.getHomVarCount();\n+        final int newAlleleCount = vcsub.getHetCount() + 2 * vcsub.getHomVarCount();\n+        final boolean isSingleton = originalAlleleCount == newAlleleCount && newAlleleCount == 1;\n+        final boolean hasChrCountAnnotations = vcsub.hasAttribute(VCFConstants.ALLELE_COUNT_KEY) &&\n+                vcsub.hasAttribute(VCFConstants.ALLELE_FREQUENCY_KEY) &&\n+                vcsub.hasAttribute(VCFConstants.ALLELE_NUMBER_KEY);\n+\n+        if ( ! isSingleton && hasChrCountAnnotations ) {\n+            // nothing to update\n+            return vcsub;\n+        } else {\n+            // have to do the work\n+            VariantContextBuilder builder = new VariantContextBuilder(vcsub);\n+\n+            if ( isSingleton )\n+                builder.attribute(IS_SINGLETON_KEY, true);\n+\n+            if ( ! hasChrCountAnnotations )\n+                VariantContextUtils.calculateChromosomeCounts(builder, true);\n+\n+            return builder.make();\n+        }\n+    }\n+\n+    /**\n+     * Initialize required, standard and user-specified stratification objects\n+     *\n+     * @param noStandardStrats  don't use the standard stratifications\n+     * @param modulesToUse      the list of stratification modules to use\n+     * @return set of stratifications to use\n+     */\n+    public List<VariantStratifier> initializeStratificationObjects(boolean noStandardStrats, List<String> modulesToUse) {\n+        TreeSet<VariantStratifier> strats = new TreeSet<>();\n+        Set<String> stratsToUse = new HashSet<>(requiredStratificationNames);\n+\n+        // By default, use standard stratification modules.\n+        if (!noStandardStrats) {\n+            stratsToUse.addAll(standardStratificationNames);\n+        }\n+\n+        // Now add the user-selected modules\n+        stratsToUse.addAll(modulesToUse);\n+\n+        // Instantiate the stratifications\n+        for (String module : stratsToUse) {\n+            if (!stratifierClasses.containsKey(module)) {\n+                throw new CommandLineException(\"Module \" + module + \" could not be found; please check that you have specified the class name correctly\");\n+            }\n+\n+            if (stratifierClasses.containsKey(module)) {\n+                Class<? extends VariantStratifier> c = stratifierClasses.get(module);\n+\n+                VariantStratifier vs = ClassUtils.makeInstanceOf(c);\n+                vs.initialize(this);\n+                strats.add(vs);\n+            }\n+        }\n+\n+        return new ArrayList<>(strats);\n+    }\n+\n+    /**\n+     * Initialize required, standard and user-specified evaluation objects\n+     *\n+     * @param noStandardEvals don't use the standard evaluations\n+     * @param modulesToUse    the list of evaluation modules to use\n+     * @return set of evaluations to use\n+     */\n+    public Set<Class<? extends VariantEvaluator>> initializeEvaluationObjects(boolean noStandardEvals, List<String> modulesToUse) {\n+        Set<String> evalsToUse = new TreeSet<>(modulesToUse);\n+\n+        // By default, use standard eval modules.\n+        if (!noStandardEvals) {\n+            evalsToUse.addAll(standardEvaluatorNames);\n+        }\n+\n+        // Get the specific classes provided.\n+        Set<Class<? extends VariantEvaluator>> evals = new HashSet<>();\n+        for (String module : evalsToUse) {\n+            if (!evaluatorClasses.containsKey(module)) {\n+                throw new CommandLineException(\"Module \" + module + \" could not be found; please check that you have specified the class name correctly\");\n+            }\n+\n+            evals.add(evaluatorClasses.get(module));\n+        }\n+\n+        //add MetricsCollection if required modules are included\n+        if (evals.contains(evaluatorClasses.get(\"CompOverlap\")) && evals.contains(evaluatorClasses.get(\"IndelSummary\")) && evals.contains(evaluatorClasses.get(\"TiTvVariantEvaluator\")) && evals.contains(evaluatorClasses.get(\"CountVariants\")) && evals.contains(evaluatorClasses.get(\"MultiallelicSummary\")) )\n+            evals.add(evaluatorClasses.get(\"MetricsCollection\"));\n+\n+        return evals;\n+    }\n+\n+    public static Map<String, Class<? extends VariantStratifier>> getStratifierClasses() {\n+        return Collections.unmodifiableMap(stratifierClasses);\n+    }\n+\n+    public static Set<String> getStandardStratificationNames() {\n+        return Collections.unmodifiableSet(standardStratificationNames);\n+    }\n+\n+    public static Set<String> getRequiredStratificationNames() {\n+        return Collections.unmodifiableSet(requiredStratificationNames);\n+    }\n+\n+    public static Map<String, Class<? extends VariantEvaluator>> getEvaluatorClasses() {\n+        return Collections.unmodifiableMap(evaluatorClasses);\n+    }\n+\n+    public static Set<String> getStandardEvaluatorNames() {\n+        return Collections.unmodifiableSet(standardEvaluatorNames);\n+    }\n+\n+    public FeatureInput<Feature> getKnownCNVsFile() {", "originalCommit": "9a8836fdfeb635d275ce71f365bef469718e782a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE2NjUzNg==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556166536", "bodyText": "ok", "author": "bbimber", "createdAt": "2021-01-12T23:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEzNjkxOA=="}], "type": "inlineReview", "revised_code": {"commit": "58fec234a4f95ac93fe370f9ee2439a278425e6d", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\nindex 35a3ab766..6f912f939 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n\n@@ -11,6 +11,7 @@ import htsjdk.variant.variantcontext.VariantContextBuilder;\n import htsjdk.variant.variantcontext.VariantContextUtils;\n import htsjdk.variant.vcf.VCFConstants;\n import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.broadinstitute.barclay.argparser.CommandLineException;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEzODA4Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556138087", "bodyText": "This logger sharing no longer makes sense (it was weird before but it was left over from GATK3). Each class should just use its own logger rather than trying to share one.", "author": "cmnbroad", "createdAt": "2021-01-12T22:28:11Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,937 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+\n+    private final Logger logger;\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+    private final List<SimpleInterval> traversalIntervals;\n+    private final FeatureManager features;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    private StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n+\n+    private SampleDB sampleDB = null;\n+\n+    private List<FeatureInput<VariantContext>> knowns = new ArrayList<>();\n+\n+    // maintain the mapping of FeatureInput to name used in output file\n+    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n+\n+    // Variables\n+    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n+\n+    private boolean isSubsettingSamples;\n+    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n+    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n+\n+    // important stratifications\n+    private boolean byFilterIsEnabled = false;\n+    private boolean perSampleIsEnabled = false;\n+    private boolean perFamilyIsEnabled = false;\n+\n+    private AlleleFrequency.StratifyingScale AFScale = AlleleFrequency.StratifyingScale.LINEAR;\n+    private boolean useCompAFStratifier = false;\n+\n+    // maintain the mapping of source name (from VC) to FeatureInput name\n+    private Map<String, FeatureInput<VariantContext>> drivingVariantSourceMap;\n+\n+    // No args constructor for unit testing only\n+    @VisibleForTesting\n+    protected VariantEvalEngine(Logger logger) {\n+        this.variantEvalArgs = new VariantEvalArgumentCollection();\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = null;\n+        this.traversalIntervals = null;\n+        this.features = null;\n+    }\n+\n+    public VariantEvalEngine(VariantEvalArgumentCollection variantEvalArgs, FeatureManager features, List<SimpleInterval> traversalIntervals, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable Collection<String> samples, Logger logger) {\n+        this.variantEvalArgs = variantEvalArgs;\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = samSequenceDictionaryForDrivingVariants;\n+        this.traversalIntervals = traversalIntervals;\n+        this.features = features;\n+\n+        // Cache map of source name -> FeatureInput\n+        drivingVariantSourceMap = new HashMap<>();\n+        variantEvalArgs.getFeatureInputsForDrivingVariants().forEach(x -> drivingVariantSourceMap.put(x.getName(), x));\n+\n+        validateAndInitialize(samples);\n+    }\n+\n+    /**\n+     * Initialize the stratifications, evaluations, evaluation contexts, and reporting object\n+     */\n+    private void validateAndInitialize(@Nullable Collection<String> samples) {\n+        sampleDB = SampleDB.createSampleDBFromPedigreeAndDataSources(variantEvalArgs.pedigreeFile, samples, PedigreeValidationType.STRICT);\n+\n+        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n+        variantEvalArgs.compsProvided.forEach(comp -> inputToNameMap.put(comp, comp.hasUserSuppliedName() ? comp.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n+        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n+            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n+            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n+            knowns.add(variantEvalArgs.dbsnp.dbsnp);\n+        }\n+\n+        variantEvalArgs.evals.forEach(eval -> inputToNameMap.put(eval, eval.hasUserSuppliedName() ? eval.getName() : \"eval\"));\n+\n+        // Set up set of additional knowns. dbSNP was addressed above, so use compsProvided, not comps\n+        for ( FeatureInput<VariantContext> compInput : variantEvalArgs.compsProvided ) {\n+            if (variantEvalArgs.knownNames.contains(getNameForInput(compInput)))\n+                knowns.add(compInput);\n+        }\n+\n+        // Now that we have all the inputs categorized, determine the sample list from the eval inputs.\n+        Map<String, VCFHeader> vcfInputs = new HashMap<>();\n+        variantEvalArgs.evals.forEach(eval -> vcfInputs.put(eval.getName(), (VCFHeader)features.getHeader(eval)));\n+\n+        Set<String> vcfSamples = new HashSet<>();\n+        vcfInputs.forEach((k,v) -> vcfSamples.addAll(v.getSampleNamesInOrder()));\n+\n+        // Load the sample list, using an intermediate tree set to sort the samples\n+        final Set<String> allSampleNames = new HashSet<>(vcfSamples);\n+        sampleNamesForEvaluation.addAll(new TreeSet<>(variantEvalArgs.sampleExpressions.isEmpty() ? vcfSamples : Utils.filterCollectionByExpressions(vcfSamples, variantEvalArgs.sampleExpressions, false)));\n+\n+        isSubsettingSamples = ! sampleNamesForEvaluation.containsAll(allSampleNames);\n+        familyNamesForEvaluation.addAll(sampleDB.getFamilyIDs());\n+\n+        //If stratifying by sample name, assign a stratification for each sample we're evaluating (based on commandline args)...\n+        if (variantEvalArgs.stratificationsToUse.contains(\"Sample\") ) {\n+            sampleNamesForStratification.addAll(sampleNamesForEvaluation);\n+        }\n+        //...and also a stratification for the sum over all samples\n+        sampleNamesForStratification.add(VariantEvalArgumentCollection.ALL_SAMPLE_NAME);\n+\n+\n+        //If stratifying by sample name, assign a stratification for each family...\n+        if ( variantEvalArgs.stratificationsToUse.contains(\"Family\") ) {\n+            familyNamesForStratification.addAll(familyNamesForEvaluation);\n+        }\n+        //...and also a stratification for the sum over all families\n+        familyNamesForStratification.add(VariantEvalArgumentCollection.ALL_FAMILY_NAME);\n+\n+        // Initialize select expressions\n+        for (VariantContextUtils.JexlVCMatchExp jexl : VariantContextUtils.initializeMatchExps(variantEvalArgs.selectNames, variantEvalArgs.selectExps)) {\n+            SortableJexlVCMatchExp sjexl = new SortableJexlVCMatchExp(jexl.name, jexl.exp);\n+            jexlExpressions.add(sjexl);\n+        }\n+\n+        // Initialize the set of stratifications and evaluations to use\n+        // The list of stratifiers and evaluators to use\n+        final List<VariantStratifier> stratificationObjects = initializeStratificationObjects(variantEvalArgs.noStandardStratifications, variantEvalArgs.stratificationsToUse);\n+        final Set<Class<? extends VariantEvaluator>> evaluationClasses = initializeEvaluationObjects(variantEvalArgs.noStandardModules, variantEvalArgs.modulesToUse);\n+\n+        checkForIncompatibleEvaluatorsAndStratifiers(stratificationObjects, evaluationClasses);\n+\n+\n+        for ( VariantStratifier vs : stratificationObjects ) {\n+            if ( vs.getName().equals(\"Filter\") )\n+                byFilterIsEnabled = true;\n+            else if ( vs.getName().equals(\"Sample\") )\n+                perSampleIsEnabled = true;\n+            else if ( vs.getName().equals(\"Family\"))\n+                perFamilyIsEnabled = true;\n+        }\n+\n+        if (perSampleIsEnabled && perFamilyIsEnabled)\n+            throw new CommandLineException.BadArgumentValue(\"ST\", \"Variants cannot be stratified by sample and family at the same time\");\n+\n+        if (perFamilyIsEnabled && sampleDB.getTrios().isEmpty())\n+            throw new CommandLineException.BadArgumentValue(\"ST\", \"Cannot stratify by family without *.ped file\");\n+\n+\n+        if ( variantEvalArgs.intervalsFile != null ) {\n+            boolean fail = true;\n+            for ( final VariantStratifier vs : stratificationObjects ) {\n+                if ( vs.getClass().equals(IntervalStratification.class) )\n+                    fail = false;\n+            }\n+            if ( fail )\n+                throw new CommandLineException.BadArgumentValue(\"ST\", \"stratIntervals argument provided but -ST IntervalStratification not provided\");\n+        }\n+\n+\n+        // Initialize the evaluation contexts\n+        createStratificationStates(stratificationObjects, evaluationClasses);\n+\n+        // Load ancestral alignments\n+        if (variantEvalArgs.ancestralAlignmentsFile != null) {\n+            try {\n+                ancestralAlignments = new IndexedFastaSequenceFile(variantEvalArgs.ancestralAlignmentsFile.toPath());\n+            } catch (FileNotFoundException e) {\n+                throw new GATKException(String.format(\"The ancestral alignments file, '%s', could not be found\", variantEvalArgs.ancestralAlignmentsFile.getAbsolutePath()));\n+            }\n+        }\n+\n+        assertThatTerritoryIsSpecifiedIfNecessary();\n+    }\n+\n+    public String getNameForInput(FeatureInput<VariantContext> input) {\n+        return inputToNameMap.get(input);\n+    }\n+\n+    private void assertThatTerritoryIsSpecifiedIfNecessary() {\n+        final Set<String> evaluatorsWhichRequireTerritory = stratManager.values()\n+                .stream()\n+                .flatMap(ctx -> ctx.getVariantEvaluators().stream())\n+                .filter(Objects::nonNull)\n+                .filter(VariantEvaluator::requiresTerritoryToBeSpecified)\n+                .map(VariantEvaluator::getSimpleName)\n+                .collect(Collectors.toSet());\n+        if (!evaluatorsWhichRequireTerritory.isEmpty() && traversalIntervals == null){\n+            throw new UserException(\"You specified evaluators which require a covered territory to be specified.  \" +\n+                    \"\\nPlease specify intervals or a reference file or disable all of the following evaluators:\" +\n+                    evaluatorsWhichRequireTerritory.stream()\n+                            .collect(Collectors.joining(\", \")));\n+        }\n+    }\n+\n+    private void checkForIncompatibleEvaluatorsAndStratifiers( final List<VariantStratifier> stratificationObjects,\n+                                                               Set<Class<? extends VariantEvaluator>> evaluationClasses) {\n+        for ( final VariantStratifier vs : stratificationObjects ) {\n+            for ( Class<? extends VariantEvaluator> ec : evaluationClasses )\n+                if ( vs.getIncompatibleEvaluators().contains(ec) )\n+                    throw new CommandLineException.BadArgumentValue(\"ST and ET\",\n+                            \"The selected stratification \" + vs.getName() +\n+                                    \" and evaluator \" + ec.getSimpleName() +\n+                                    \" are incompatible due to combinatorial memory requirements.\" +\n+                                    \" Please disable one\");\n+        }\n+    }\n+\n+    protected void createStratificationStates(final List<VariantStratifier> stratificationObjects, final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n+        final List<VariantStratifier> strats = new ArrayList<VariantStratifier>(stratificationObjects);\n+        stratManager = new StratificationManager<>(strats);\n+\n+        logger.info(\"Creating \" + stratManager.size() + \" combinatorial stratification states\");\n+        for ( int i = 0; i < stratManager.size(); i++ ) {\n+            EvaluationContext ec = createEvaluationContext(evaluationObjects);\n+            stratManager.set(i, ec);\n+        }\n+    }\n+\n+    public void finalizeReport(File outFile) {\n+        // go through the evaluations and finalize them\n+        for ( final EvaluationContext nec : stratManager.values() )\n+            for ( final VariantEvaluator ve : nec.getVariantEvaluators() )\n+                ve.finalizeEvaluation(this);\n+\n+        //send data to MetricsCollection\n+        CompOverlap compOverlap = null;\n+        IndelSummary indelSummary = null;\n+        CountVariants countVariants = null;\n+        MultiallelicSummary multiallelicSummary = null;\n+        TiTvVariantEvaluator tiTvVariantEvaluator = null;\n+        MetricsCollection metricsCollection = null;\n+        for (final EvaluationContext nec: stratManager.values()) {\n+            for (final VariantEvaluator ve : nec.getVariantEvaluators()) {\n+                if (ve instanceof CompOverlap)\n+                    compOverlap = (CompOverlap) ve;\n+                else if (ve instanceof IndelSummary)\n+                    indelSummary = (IndelSummary) ve;\n+                else if (ve instanceof CountVariants)\n+                    countVariants = (CountVariants) ve;\n+                else if (ve instanceof MultiallelicSummary)\n+                    multiallelicSummary = (MultiallelicSummary) ve;\n+                else if (ve instanceof TiTvVariantEvaluator)\n+                    tiTvVariantEvaluator = (TiTvVariantEvaluator) ve;\n+                else if (ve instanceof MetricsCollection)\n+                    metricsCollection = (MetricsCollection) ve;\n+            }\n+\n+            if (metricsCollection != null)\n+                metricsCollection.setData(compOverlap.concordantRate, indelSummary.n_SNPs, countVariants.nSNPs, indelSummary.n_indels, multiallelicSummary.nIndels, indelSummary.insertion_to_deletion_ratio, countVariants.insertionDeletionRatio, tiTvVariantEvaluator.tiTvRatio);\n+        }\n+\n+        try (PrintStream out = IOUtils.makePrintStreamMaybeGzipped(new GATKPath(outFile.getAbsolutePath()))) {\n+            VariantEvalReportWriter.writeReport(out, stratManager, stratManager.getStratifiers(), stratManager.get(0).getVariantEvaluators());\n+        }\n+        catch(IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(e.getMessage(), e);\n+        }\n+    }\n+\n+    private Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(final List<VariantContext> variants) {\n+        final Map<FeatureInput<VariantContext>, List<VariantContext>> byFeatureInput = new HashMap<>();\n+        variants.forEach(vc -> byFeatureInput.compute(drivingVariantSourceMap.get(vc.getSource()),\n+                (k, v) -> {\n+                    final List<VariantContext> variantList = v == null ? new ArrayList<>() : v;\n+                    variantList.add(vc);\n+                    return variantList;\n+                }\n+        ));\n+        return byFeatureInput;\n+    }\n+\n+    public void apply(final List<VariantContext> variantContexts, final ReferenceContext referenceContext) {\n+        final Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap = groupVariantsByFeatureInput(variantContexts);\n+\n+        final List<VariantContext> allEvals = new ArrayList<>();\n+        for (FeatureInput<VariantContext> eval : variantEvalArgs.evals) {\n+            if (variantMap.containsKey(eval)) {\n+                allEvals.addAll(variantMap.get(eval));\n+            }\n+        }\n+\n+        final List<VariantContext> allComps = new ArrayList<>();\n+        if (variantEvalArgs.comps != null) {\n+            for (FeatureInput<VariantContext> comp : variantEvalArgs.comps) {\n+                if (variantMap.containsKey(comp)) {\n+                    allComps.addAll(variantMap.get(comp));\n+                }\n+            }\n+        }\n+\n+        final SimpleInterval interval = allEvals.isEmpty() ? new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), variantContexts.get(0).getStart()) : generateContextInterval(allEvals);\n+        final FeatureContext featureContext = new FeatureContext(features, interval);\n+\n+        final Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> evalVCs = allEvals.isEmpty() ? Collections.emptyMap() : bindVariantContexts(variantMap, variantEvalArgs.evals, byFilterIsEnabled, true, perSampleIsEnabled, perFamilyIsEnabled, variantEvalArgs.mergeEvals);\n+        final Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs = allComps.isEmpty() ? Collections.emptyMap() : bindVariantContexts(variantMap, variantEvalArgs.comps, byFilterIsEnabled, false, false, false, false);\n+\n+        final VariantEvalContext variantEvalContext = new VariantEvalContext(referenceContext, featureContext, variantMap, this);\n+\n+        // for each eval track\n+        for ( final FeatureInput<VariantContext> evalInput : variantEvalArgs.evals ) {\n+            final Map<String, Collection<VariantContext>> evalSet = evalVCs.containsKey(evalInput) ? evalVCs.get(evalInput) : Collections.emptyMap();\n+\n+            Set<String> statificationLevels;\n+\n+            // for each sample stratifier\n+            if (perFamilyIsEnabled)\n+                statificationLevels = familyNamesForStratification;\n+            else\n+                statificationLevels = sampleNamesForStratification;\n+            for ( final String stratLevelName : statificationLevels ) {\n+                Collection<VariantContext> evalSetBySample = evalSet.get(stratLevelName);\n+\n+                if ( evalSetBySample == null ) {\n+                    evalSetBySample = new HashSet<>(1);\n+                    evalSetBySample.add(null);\n+                }\n+\n+                // for each eval in the track\n+                for ( VariantContext eval : evalSetBySample ) {\n+                    String aastr = (ancestralAlignments == null) ? null : new String(ancestralAlignments.getSubsequenceAt(eval.getContig(), eval.getStart(), eval.getEnd()).getBases());\n+\n+                    // deal with ancestral alleles if requested\n+                    if ( eval != null && aastr != null ) {\n+                        eval = new VariantContextBuilder(eval).attribute(\"ANCESTRALALLELE\", aastr).make();\n+                    }\n+\n+                    String evalName = getNameForInput(evalInput);\n+\n+                    // for each comp track\n+                    for ( final FeatureInput<VariantContext> compInput : variantEvalArgs.comps ) {\n+                        processComp(variantEvalContext, eval, evalName, compInput, stratLevelName, compVCs, evalSetBySample);\n+                    }\n+\n+                    if (variantEvalArgs.comps.isEmpty()) {\n+                        processComp(variantEvalContext, eval, evalName, null, stratLevelName, compVCs, evalSetBySample);\n+                    }\n+                }\n+            }\n+\n+            if ( variantEvalArgs.mergeEvals ) break; // stop processing the eval tracks\n+        }\n+    }\n+\n+\n+    /**\n+     * Create the EvaluationContext (new instance) for the provided set of VariantEvaluators.\n+     *\n+     * @param evaluationObjects The list of VariantEvaluator classes\n+     * @return The EvaluationContext for this set of VariantEvaluator classes\n+     */\n+    protected EvaluationContext createEvaluationContext(final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n+        return new EvaluationContext(this, evaluationObjects);\n+    }\n+\n+    public boolean isSubsettingToSpecificSamples() { return isSubsettingSamples; }\n+\n+    public Set<String> getSampleNamesForEvaluation() { return sampleNamesForEvaluation; }\n+\n+    public Set<String> getFamilyNamesForEvaluation() { return familyNamesForEvaluation; }\n+\n+    public int getNumberOfSamplesForEvaluation() {\n+        if (sampleNamesForEvaluation!= null &&  !sampleNamesForEvaluation.isEmpty())\n+            return sampleNamesForEvaluation.size();\n+        else {\n+            return variantEvalArgs.numSamplesFromArgument;\n+        }\n+    }\n+    public Set<String> getSampleNamesForStratification() { return sampleNamesForStratification; }\n+\n+    public Set<String> getFamilyNamesForStratification() { return familyNamesForStratification; }\n+\n+    public Set<SortableJexlVCMatchExp> getJexlExpressions() { return jexlExpressions; }\n+\n+\n+    public AlleleFrequency.StratifyingScale getAFScale() { return AFScale; }\n+    public boolean getCompAFStratifier() { return useCompAFStratifier; }\n+\n+    public SampleDB getSampleDB() {\n+        return sampleDB;\n+    }\n+\n+    public List<FeatureInput<VariantContext>> getKnowns() {\n+        return knowns;\n+    }\n+\n+    /**\n+     * If an evaluator calls this method it must override {@link VariantEvaluator#requiresTerritoryToBeSpecified()} to return true.\n+     * @return either the size of the interval list given to the tool or the size of the reference given to the tool\n+     */\n+    public long getnProcessedLoci() {\n+        if (traversalIntervals == null){\n+            throw new GATKException(\"BUG: One of the evaluators used should have overriden requiresTerritoryToBeSpecified, please report this to the developers.\" +\n+                    \"\\nEvaluators: \" + stratManager.values()\n+                    .stream()\n+                    .flatMap(evaluator -> evaluator.getVariantEvaluators().stream())\n+                    .map(VariantEvaluator::getSimpleName)\n+                    .sorted()\n+                    .distinct()\n+                    .collect(Collectors.joining(\", \")));\n+        }\n+        return traversalIntervals.stream().mapToLong(SimpleInterval::size).sum();\n+    }\n+\n+    private boolean compHasMatchingEval(final VariantContext comp, final Collection<VariantContext> evals) {\n+        // find all of the matching comps\n+        for ( final VariantContext eval : evals ) {\n+            if ( eval != null && doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) != EvalCompMatchType.NO_MATCH )\n+                return true;\n+        }\n+\n+        // nothing matched\n+        return false;\n+    }\n+\n+    private enum EvalCompMatchType { NO_MATCH, STRICT, LENIENT }\n+\n+    private EvalCompMatchType doEvalAndCompMatch(final VariantContext eval, final VariantContext comp, boolean requireStrictAlleleMatch) {\n+        if ( comp.getType() == VariantContext.Type.NO_VARIATION || eval.getType() == VariantContext.Type.NO_VARIATION )\n+            // if either of these are NO_VARIATION they are LENIENT matches\n+            return EvalCompMatchType.LENIENT;\n+\n+        if ( comp.getType() != eval.getType() )\n+            return EvalCompMatchType.NO_MATCH;\n+\n+        // find the comp which matches both the reference allele and alternate allele from eval\n+        final Allele altEval = eval.getAlternateAlleles().size() == 0 ? null : eval.getAlternateAllele(0);\n+        final Allele altComp = comp.getAlternateAlleles().size() == 0 ? null : comp.getAlternateAllele(0);\n+        if ((altEval == null && altComp == null) || (altEval != null && altEval.equals(altComp) && eval.getReference().equals(comp.getReference())))\n+            return EvalCompMatchType.STRICT;\n+        else\n+            return requireStrictAlleleMatch ? EvalCompMatchType.NO_MATCH : EvalCompMatchType.LENIENT;\n+    }\n+\n+    private VariantContext findMatchingComp(final VariantContext eval, final Collection<VariantContext> comps) {\n+        // if no comps, return null\n+        if ( comps == null || comps.isEmpty() )\n+            return null;\n+\n+        // if no eval, return any comp\n+        if ( eval == null )\n+            return comps.iterator().next();\n+\n+        // find all of the matching comps\n+        VariantContext lenientMatch = null;\n+        for ( final VariantContext comp : comps ) {\n+            switch ( doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) ) {\n+                case STRICT:\n+                    return comp;\n+                case LENIENT:\n+                    if ( lenientMatch == null ) lenientMatch = comp;\n+                    break;\n+                case NO_MATCH:\n+                    // do nothing\n+            }\n+        }\n+\n+        // nothing matched, just return lenientMatch, which might be null\n+        return lenientMatch;\n+    }\n+\n+    private SimpleInterval generateContextInterval(List<VariantContext> variantContexts) {\n+        final int maxEnd = variantContexts.stream().map(VariantContext::getEnd).max(Integer::compareTo).get();\n+\n+        return new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), maxEnd);\n+    }\n+\n+    private void processComp(VariantEvalContext vec, VariantContext eval, String evalName, FeatureInput<VariantContext> compInput, String stratLevelName, Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs, Collection<VariantContext> evalSetBySample) {\n+        String compName = getNameForInput(compInput);\n+\n+        // no sample stratification for comps\n+        final HashMap<String, Collection<VariantContext>> compSetHash = compInput == null ? null : compVCs.get(compInput);\n+        final Collection<VariantContext> compSet = (compSetHash == null || compSetHash.isEmpty()) ? Collections.<VariantContext>emptyList() : compVCs.get(compInput).values().iterator().next();\n+\n+        // find the comp\n+        final VariantContext comp = findMatchingComp(eval, compSet);\n+\n+        Collection<EvaluationContext> contextsForStratification;\n+        if (perFamilyIsEnabled)\n+            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, null, stratLevelName);\n+        else {\n+            String familyID;\n+            if (stratLevelName.equals(\"all\"))\n+                familyID = \"all\";\n+            else\n+                familyID = sampleDB.getSample(stratLevelName).getFamilyID();\n+            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, stratLevelName, familyID);\n+        }\n+        for ( EvaluationContext nec : contextsForStratification ) {\n+\n+            // eval against the comp\n+            synchronized (nec) {\n+                nec.apply(vec, comp, eval);\n+            }\n+\n+            // eval=null against all comps of different type that aren't bound to another eval\n+            for ( VariantContext otherComp : compSet ) {\n+                if ( otherComp != comp && ! compHasMatchingEval(otherComp, evalSetBySample) ) {\n+                    synchronized (nec) {\n+                        nec.apply(vec, otherComp, null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Given specific eval and comp VCs and the sample name, return an iterable\n+     * over all of the applicable state keys.\n+     *\n+     * this code isn't structured yet for efficiency.  Here we currently are\n+     * doing the following inefficient algorithm:\n+     *\n+     * for each strat:\n+     *   get list of relevant states that eval and comp according to strat\n+     *   add this list of states to a list of list states\n+     *\n+     * then\n+     *\n+     * ask the strat manager to look up all of the keys associated with the combinations\n+     * of these states.  For example, suppose we have a single variant S.  We have active\n+     * strats EvalFeatureInput, CompFeatureInput, and Novelty.  We produce a list that looks like:\n+     *\n+     *   L = [[Eval], [Comp], [All, Novel]]\n+     *\n+     * We then go through the strat manager tree to produce the keys associated with these states:\n+     *\n+     *   K = [0, 1] where EVAL x COMP x ALL = 0 and EVAL x COMP x NOVEL = 1\n+     *\n+     * It's clear that a better\n+     *\n+     *\n+     * @param vec\n+     * @param eval\n+     * @param evalName\n+     * @param comp\n+     * @param compName\n+     * @param sampleName\n+     * @return\n+     */\n+    protected Collection<EvaluationContext> getEvaluationContexts(final VariantEvalContext vec,\n+                                                                  final VariantContext eval,\n+                                                                  final String evalName,\n+                                                                  final VariantContext comp,\n+                                                                  final String compName,\n+                                                                  final String sampleName,\n+                                                                  final String familyName) {\n+        final List<List<Object>> states = new LinkedList<>();\n+        for ( final VariantStratifier vs : stratManager.getStratifiers() ) {\n+            states.add(vs.getRelevantStates(vec, comp, compName, eval, evalName, sampleName, familyName));\n+        }\n+        return stratManager.values(states);\n+    }\n+\n+    protected List<String> getModulesToUse() {\n+        return Collections.unmodifiableList(variantEvalArgs.modulesToUse);\n+    }\n+\n+    /**\n+     * For a list of track names, bind the variant contexts to a trackName->sampleName->VariantContext mapping.\n+     * Additional variant contexts per sample are automatically generated and added to the map unless the sample name\n+     * matches the ALL_SAMPLE_NAME constant.\n+     *\n+     * @return the mapping of track to VC list that should be populated\n+     */\n+    public HashMap<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>>\n+    bindVariantContexts(Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap,\n+                        List<FeatureInput<VariantContext>> tracks,\n+                        boolean byFilter,\n+                        boolean subsetBySample,\n+                        boolean trackPerSample,\n+                        boolean trackPerFamily,\n+                        boolean mergeTracks) {\n+        HashMap<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> bindings = new HashMap<>();\n+\n+        FeatureInput<VariantContext> firstTrack = tracks.isEmpty() ? null : tracks.get(0);\n+        for (FeatureInput<VariantContext> track : tracks) {\n+            HashMap<String, Collection<VariantContext>> mapping = new HashMap<>();\n+\n+            if (variantMap.containsKey(track)) {\n+                //Note: these are limiting to only those w/ the same start, as was the GATK3 behavior.\n+                for (VariantContext vc : variantMap.get(track)) {\n+\n+                    // First, filter the VariantContext to represent only the samples for evaluation\n+                    VariantContext vcsub = vc;\n+\n+                    if ((subsetBySample) && vc.hasGenotypes())\n+                        vcsub = getSubsetOfVariantContext(vc, getSampleNamesForEvaluation());\n+\n+                    //always add a mapping for all samples together\n+                    if ((byFilter || !vcsub.isFiltered())) {\n+                        addMapping(mapping, VariantEvalArgumentCollection.ALL_SAMPLE_NAME, vcsub);\n+                    }\n+\n+                    // Now, if stratifying, split the subsetted vc per sample and add each as a new context\n+                    if (vc.hasGenotypes() && trackPerSample) {\n+                        for (String sampleName : getSampleNamesForEvaluation()) {\n+                            final VariantContext samplevc = getSubsetOfVariantContext(vc, sampleName);\n+\n+                            if (byFilter || !samplevc.isFiltered()) {\n+                                addMapping(mapping, sampleName, samplevc);\n+                            }\n+                        }\n+                    } else if (vc.hasGenotypes() && trackPerFamily) {\n+                        for (final String familyName : getFamilyNamesForEvaluation()) {\n+                            Set<String> familyMemberNames;\n+                            //if the current stratification family name is \"all\", then add all the families to the VC for evaluation here\n+                            if (familyName.equals(VariantEvalArgumentCollection.ALL_FAMILY_NAME)) {\n+                                familyMemberNames = getSampleNamesForEvaluation();\n+                            } else {\n+                                familyMemberNames = getSampleDB().getFamily(familyName).stream().map(Sample::getID).collect(Collectors.toSet());\n+                            }\n+                            final VariantContext samplevc = getSubsetOfVariantContext(vc, familyMemberNames);\n+\n+                            if (byFilter || !samplevc.isFiltered()) {\n+                                addMapping(mapping, familyName, samplevc);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (mergeTracks && bindings.containsKey(firstTrack)) {\n+                // go through each binding of sample -> value and add all of the bindings from this entry\n+                HashMap<String, Collection<VariantContext>> firstMapping = bindings.get(firstTrack);\n+                for (Map.Entry<String, Collection<VariantContext>> elt : mapping.entrySet()) {\n+                    Collection<VariantContext> firstMappingSet = firstMapping.get(elt.getKey());\n+                    if (firstMappingSet != null) {\n+                        firstMappingSet.addAll(elt.getValue());\n+                    } else {\n+                        firstMapping.put(elt.getKey(), elt.getValue());\n+                    }\n+                }\n+            } else {\n+                bindings.put(track, mapping);\n+            }\n+        }\n+\n+        return bindings;\n+    }\n+\n+    private void addMapping(HashMap<String, Collection<VariantContext>> mappings, String sample, VariantContext vc) {\n+        if (!mappings.containsKey(sample))\n+            mappings.put(sample, new ArrayList<>(1));\n+        mappings.get(sample).add(vc);\n+    }\n+\n+    /**\n+     * Subset a VariantContext to a single sample\n+     *\n+     * @param vc         the VariantContext object containing multiple samples\n+     * @param sampleName the sample to pull out of the VariantContext\n+     * @return a new VariantContext with just the requested sample\n+     */\n+    public VariantContext getSubsetOfVariantContext(VariantContext vc, String sampleName) {\n+        return getSubsetOfVariantContext(vc, Collections.singleton(sampleName));\n+    }\n+\n+    /**\n+     * Subset a VariantContext to a set of samples\n+     *\n+     * @param vc          the VariantContext object containing multiple samples\n+     * @param sampleNames the samples to pull out of the VariantContext\n+     * @return a new VariantContext with just the requested samples\n+     */\n+    public VariantContext getSubsetOfVariantContext(VariantContext vc, Set<String> sampleNames) {\n+        // if we want to preserve AC0 sites as polymorphic we need to not rederive alleles\n+        final boolean deriveAlleles = ignoreAC0Sites();\n+        return ensureAnnotations(vc, vc.subContextFromSamples(sampleNames, deriveAlleles));\n+    }\n+\n+    public VariantContext ensureAnnotations(final VariantContext vc, final VariantContext vcsub) {\n+        final int originalAlleleCount = vc.getHetCount() + 2 * vc.getHomVarCount();\n+        final int newAlleleCount = vcsub.getHetCount() + 2 * vcsub.getHomVarCount();\n+        final boolean isSingleton = originalAlleleCount == newAlleleCount && newAlleleCount == 1;\n+        final boolean hasChrCountAnnotations = vcsub.hasAttribute(VCFConstants.ALLELE_COUNT_KEY) &&\n+                vcsub.hasAttribute(VCFConstants.ALLELE_FREQUENCY_KEY) &&\n+                vcsub.hasAttribute(VCFConstants.ALLELE_NUMBER_KEY);\n+\n+        if ( ! isSingleton && hasChrCountAnnotations ) {\n+            // nothing to update\n+            return vcsub;\n+        } else {\n+            // have to do the work\n+            VariantContextBuilder builder = new VariantContextBuilder(vcsub);\n+\n+            if ( isSingleton )\n+                builder.attribute(IS_SINGLETON_KEY, true);\n+\n+            if ( ! hasChrCountAnnotations )\n+                VariantContextUtils.calculateChromosomeCounts(builder, true);\n+\n+            return builder.make();\n+        }\n+    }\n+\n+    /**\n+     * Initialize required, standard and user-specified stratification objects\n+     *\n+     * @param noStandardStrats  don't use the standard stratifications\n+     * @param modulesToUse      the list of stratification modules to use\n+     * @return set of stratifications to use\n+     */\n+    public List<VariantStratifier> initializeStratificationObjects(boolean noStandardStrats, List<String> modulesToUse) {\n+        TreeSet<VariantStratifier> strats = new TreeSet<>();\n+        Set<String> stratsToUse = new HashSet<>(requiredStratificationNames);\n+\n+        // By default, use standard stratification modules.\n+        if (!noStandardStrats) {\n+            stratsToUse.addAll(standardStratificationNames);\n+        }\n+\n+        // Now add the user-selected modules\n+        stratsToUse.addAll(modulesToUse);\n+\n+        // Instantiate the stratifications\n+        for (String module : stratsToUse) {\n+            if (!stratifierClasses.containsKey(module)) {\n+                throw new CommandLineException(\"Module \" + module + \" could not be found; please check that you have specified the class name correctly\");\n+            }\n+\n+            if (stratifierClasses.containsKey(module)) {\n+                Class<? extends VariantStratifier> c = stratifierClasses.get(module);\n+\n+                VariantStratifier vs = ClassUtils.makeInstanceOf(c);\n+                vs.initialize(this);\n+                strats.add(vs);\n+            }\n+        }\n+\n+        return new ArrayList<>(strats);\n+    }\n+\n+    /**\n+     * Initialize required, standard and user-specified evaluation objects\n+     *\n+     * @param noStandardEvals don't use the standard evaluations\n+     * @param modulesToUse    the list of evaluation modules to use\n+     * @return set of evaluations to use\n+     */\n+    public Set<Class<? extends VariantEvaluator>> initializeEvaluationObjects(boolean noStandardEvals, List<String> modulesToUse) {\n+        Set<String> evalsToUse = new TreeSet<>(modulesToUse);\n+\n+        // By default, use standard eval modules.\n+        if (!noStandardEvals) {\n+            evalsToUse.addAll(standardEvaluatorNames);\n+        }\n+\n+        // Get the specific classes provided.\n+        Set<Class<? extends VariantEvaluator>> evals = new HashSet<>();\n+        for (String module : evalsToUse) {\n+            if (!evaluatorClasses.containsKey(module)) {\n+                throw new CommandLineException(\"Module \" + module + \" could not be found; please check that you have specified the class name correctly\");\n+            }\n+\n+            evals.add(evaluatorClasses.get(module));\n+        }\n+\n+        //add MetricsCollection if required modules are included\n+        if (evals.contains(evaluatorClasses.get(\"CompOverlap\")) && evals.contains(evaluatorClasses.get(\"IndelSummary\")) && evals.contains(evaluatorClasses.get(\"TiTvVariantEvaluator\")) && evals.contains(evaluatorClasses.get(\"CountVariants\")) && evals.contains(evaluatorClasses.get(\"MultiallelicSummary\")) )\n+            evals.add(evaluatorClasses.get(\"MetricsCollection\"));\n+\n+        return evals;\n+    }\n+\n+    public static Map<String, Class<? extends VariantStratifier>> getStratifierClasses() {\n+        return Collections.unmodifiableMap(stratifierClasses);\n+    }\n+\n+    public static Set<String> getStandardStratificationNames() {\n+        return Collections.unmodifiableSet(standardStratificationNames);\n+    }\n+\n+    public static Set<String> getRequiredStratificationNames() {\n+        return Collections.unmodifiableSet(requiredStratificationNames);\n+    }\n+\n+    public static Map<String, Class<? extends VariantEvaluator>> getEvaluatorClasses() {\n+        return Collections.unmodifiableMap(evaluatorClasses);\n+    }\n+\n+    public static Set<String> getStandardEvaluatorNames() {\n+        return Collections.unmodifiableSet(standardEvaluatorNames);\n+    }\n+\n+    public FeatureInput<Feature> getKnownCNVsFile() {\n+        return variantEvalArgs.knownCNVsFile;\n+    }\n+\n+    public List<FeatureInput<VariantContext>> getEvals() {\n+        return Collections.unmodifiableList(variantEvalArgs.evals);\n+    }\n+\n+    public List<FeatureInput<VariantContext>> getComps() {\n+        return Collections.unmodifiableList(variantEvalArgs.comps);\n+    }\n+\n+    public boolean ignoreAC0Sites() {\n+        return ! variantEvalArgs.keepSitesWithAC0;\n+    }\n+\n+    public FeatureInput<VariantContext> getGoldStand() {\n+        return variantEvalArgs.goldStandard;\n+    }\n+\n+    public List<FeatureInput<VariantContext>> getCompsProvided() {\n+        return Collections.unmodifiableList(variantEvalArgs.compsProvided);\n+    }\n+\n+    public boolean isMergeEvals() {\n+        return variantEvalArgs.mergeEvals;\n+    }\n+\n+    public int getPloidy() {\n+        return variantEvalArgs.ploidy;\n+    }\n+\n+    public Logger getLogger() {", "originalCommit": "9a8836fdfeb635d275ce71f365bef469718e782a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE2NDc2NA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556164764", "bodyText": "ok", "author": "bbimber", "createdAt": "2021-01-12T23:29:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEzODA4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "58fec234a4f95ac93fe370f9ee2439a278425e6d", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\nindex 35a3ab766..6f912f939 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n\n@@ -11,6 +11,7 @@ import htsjdk.variant.variantcontext.VariantContextBuilder;\n import htsjdk.variant.variantcontext.VariantContextUtils;\n import htsjdk.variant.vcf.VCFConstants;\n import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.broadinstitute.barclay.argparser.CommandLineException;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE0OTQ1OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556149459", "bodyText": "I know you didn't add this, but carrying this logger around is a leftover gatk3-ism. This arg here and below, and class state can be removed, and each class can use its own logger.", "author": "cmnbroad", "createdAt": "2021-01-12T22:52:05Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,937 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+\n+    private final Logger logger;\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+    private final List<SimpleInterval> traversalIntervals;\n+    private final FeatureManager features;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    private StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n+\n+    private SampleDB sampleDB = null;\n+\n+    private List<FeatureInput<VariantContext>> knowns = new ArrayList<>();\n+\n+    // maintain the mapping of FeatureInput to name used in output file\n+    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n+\n+    // Variables\n+    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n+\n+    private boolean isSubsettingSamples;\n+    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n+    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n+\n+    // important stratifications\n+    private boolean byFilterIsEnabled = false;\n+    private boolean perSampleIsEnabled = false;\n+    private boolean perFamilyIsEnabled = false;\n+\n+    private AlleleFrequency.StratifyingScale AFScale = AlleleFrequency.StratifyingScale.LINEAR;\n+    private boolean useCompAFStratifier = false;\n+\n+    // maintain the mapping of source name (from VC) to FeatureInput name\n+    private Map<String, FeatureInput<VariantContext>> drivingVariantSourceMap;\n+\n+    // No args constructor for unit testing only\n+    @VisibleForTesting\n+    protected VariantEvalEngine(Logger logger) {", "originalCommit": "9a8836fdfeb635d275ce71f365bef469718e782a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE2NTIxOA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556165218", "bodyText": "ok", "author": "bbimber", "createdAt": "2021-01-12T23:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE0OTQ1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "58fec234a4f95ac93fe370f9ee2439a278425e6d", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\nindex 35a3ab766..6f912f939 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n\n@@ -11,6 +11,7 @@ import htsjdk.variant.variantcontext.VariantContextBuilder;\n import htsjdk.variant.variantcontext.VariantContextUtils;\n import htsjdk.variant.vcf.VCFConstants;\n import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.broadinstitute.barclay.argparser.CommandLineException;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk1MTcwOA==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r568951708", "bodyText": "I thought we were getting close, but this deferred initialization state seems complicating - whats the reason for needing it (both here, and in the evaluators, which still have an \"initialize\" method) ? Is there any alternative ?\nDepending on the answer, we'll need to rationalize these constructors - having one that controls initialization and one that doesn't seems problematic. There are 3 constructors now, each of which leaves the object in a slightly different non-obvious state. We really need to get rid of the boolean if at all possible.", "author": "cmnbroad", "createdAt": "2021-02-02T21:44:07Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,922 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+\n+    private final Logger logger = LogManager.getLogger(VariantEvalEngine.class);\n+\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+    private final List<SimpleInterval> traversalIntervals;\n+    private final FeatureManager features;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    private StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n+\n+    private SampleDB sampleDB = null;\n+\n+    private List<FeatureInput<VariantContext>> knowns = new ArrayList<>();\n+\n+    // maintain the mapping of FeatureInput to name used in output file\n+    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n+\n+    // Variables\n+    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n+\n+    private boolean isSubsettingSamples;\n+    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n+    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n+\n+    // important stratifications\n+    private boolean byFilterIsEnabled = false;\n+    private boolean perSampleIsEnabled = false;\n+    private boolean perFamilyIsEnabled = false;\n+\n+    private AlleleFrequency.StratifyingScale AFScale = AlleleFrequency.StratifyingScale.LINEAR;\n+    private boolean useCompAFStratifier = false;\n+\n+    // maintain the mapping of source name (from VC) to FeatureInput name\n+    private Map<String, FeatureInput<VariantContext>> drivingVariantSourceMap;\n+\n+    // No args constructor for unit testing only\n+    @VisibleForTesting\n+    protected VariantEvalEngine() {\n+        this.variantEvalArgs = new VariantEvalArgumentCollection();\n+        this.samSequenceDictionaryForDrivingVariants = null;\n+        this.traversalIntervals = null;\n+        this.features = null;\n+    }\n+\n+    public VariantEvalEngine(final VariantEvalArgumentCollection variantEvalArgs, final FeatureManager features, final List<SimpleInterval> traversalIntervals, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable final Collection<String> samples) {\n+        this(variantEvalArgs, features, traversalIntervals, samSequenceDictionaryForDrivingVariants, samples, false);\n+    }\n+\n+    // Note: this protected constructor with deferred initialization exists for DISCVR-seq/VariantQC\n+    protected VariantEvalEngine(VariantEvalArgumentCollection variantEvalArgs, FeatureManager features, List<SimpleInterval> traversalIntervals, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable Collection<String> samples, boolean skipInitialize) {\n+        this.variantEvalArgs = variantEvalArgs;\n+        this.samSequenceDictionaryForDrivingVariants = samSequenceDictionaryForDrivingVariants;\n+        this.traversalIntervals = traversalIntervals;\n+        this.features = features;\n+\n+        // Cache map of source name -> FeatureInput\n+        drivingVariantSourceMap = new HashMap<>();\n+        variantEvalArgs.getFeatureInputsForDrivingVariants().forEach(x -> drivingVariantSourceMap.put(x.getName(), x));\n+\n+        if (!skipInitialize) {", "originalCommit": "ae50ac009bd7bdad128571fea91f0dd71cf489ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYzNTY0Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r569635642", "bodyText": "The reason for this is listed in the comment above that method: it was to make this work with our VariantQC tool. I need to delay creation of EvaluationContext for some things our tool does. However, I took a look at my code and I think I have a solution that doesnt need this, so I removed it here.", "author": "bbimber", "createdAt": "2021-02-03T18:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk1MTcwOA=="}], "type": "inlineReview", "revised_code": {"commit": "58fec234a4f95ac93fe370f9ee2439a278425e6d", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\nindex 52a0969ba..6f912f939 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java\n\n@@ -141,12 +141,7 @@ public class VariantEvalEngine {\n         this.features = null;\n     }\n \n-    public VariantEvalEngine(final VariantEvalArgumentCollection variantEvalArgs, final FeatureManager features, final List<SimpleInterval> traversalIntervals, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable final Collection<String> samples) {\n-        this(variantEvalArgs, features, traversalIntervals, samSequenceDictionaryForDrivingVariants, samples, false);\n-    }\n-\n-    // Note: this protected constructor with deferred initialization exists for DISCVR-seq/VariantQC\n-    protected VariantEvalEngine(VariantEvalArgumentCollection variantEvalArgs, FeatureManager features, List<SimpleInterval> traversalIntervals, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable Collection<String> samples, boolean skipInitialize) {\n+    public VariantEvalEngine(VariantEvalArgumentCollection variantEvalArgs, FeatureManager features, List<SimpleInterval> traversalIntervals, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable Collection<String> samples) {\n         this.variantEvalArgs = variantEvalArgs;\n         this.samSequenceDictionaryForDrivingVariants = samSequenceDictionaryForDrivingVariants;\n         this.traversalIntervals = traversalIntervals;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk1NTUwMw==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r568955503", "bodyText": "I thought passing the engine to constructors would eliminate the need for this initialize method. Can it be removed ?", "author": "cmnbroad", "createdAt": "2021-02-02T21:51:00Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java", "diffHunk": "@@ -1,41 +1,42 @@\n package org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators;\n \n import htsjdk.variant.variantcontext.VariantContext;\n-import org.broadinstitute.hellbender.engine.FeatureContext;\n-import org.broadinstitute.hellbender.engine.ReadsContext;\n-import org.broadinstitute.hellbender.engine.ReferenceContext;\n import org.broadinstitute.hellbender.exceptions.GATKException;\n-import org.broadinstitute.hellbender.tools.walkers.varianteval.VariantEval;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.VariantEvalEngine;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n \n public abstract class VariantEvaluator implements Comparable<VariantEvaluator> {\n-    private VariantEval walker;\n     private final String simpleName;\n+    private final VariantEvalEngine engine;\n \n-    protected VariantEvaluator(String simpleName) {\n-        this.simpleName = simpleName;\n+    public VariantEvaluator(VariantEvalEngine engine) {\n+        this.engine = engine;\n+        this.simpleName = getClass().getSimpleName();\n     }\n \n-    protected VariantEvaluator() {\n-        this.simpleName = getClass().getSimpleName();\n+    //Note: this is used by DISCVR-seq / VariantQC\n+    public VariantEvaluator(VariantEvalEngine engine, final String simpleName) {\n+        this.engine = engine;\n+        this.simpleName = simpleName;\n     }\n \n-    public void initialize(VariantEval walker) {\n-        this.walker = walker;\n+    public void initialize() {\n+", "originalCommit": "ae50ac009bd7bdad128571fea91f0dd71cf489ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYyMjgzNg==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r569622836", "bodyText": "VariantSummary is an example of one class using this to initialize variables. It doesnt seem crazy to me to keep this? In theory this class could store some internal \"hasInitialized\" boolean, and lazily do this work in the update() method, but initialize() doesnt seem that harmful to exist? Example below:\n    @Override\n    public void initialize() {\n        this.knownCNVs = getEngine().getVariantEvalArgs().getKnownCNVsFile();\n\n        nSamples = getEngine().getSampleNamesForEvaluation().size();\n        countsPerSample = new TypeSampleMap(getEngine().getSampleNamesForEvaluation());\n        transitionsPerSample = new TypeSampleMap(getEngine().getSampleNamesForEvaluation());\n        transversionsPerSample = new TypeSampleMap(getEngine().getSampleNamesForEvaluation());\n        allVariantCounts = new TypeSampleMap(getEngine().getSampleNamesForEvaluation());\n        knownVariantCounts = new TypeSampleMap(getEngine().getSampleNamesForEvaluation());\n        depthPerSample = new TypeSampleMap(getEngine().getSampleNamesForEvaluation());\n    }", "author": "bbimber", "createdAt": "2021-02-03T17:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk1NTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDcyOTUwMw==", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r570729503", "bodyText": "I thought about this and I agree - initialize() doesnt really need to exist. I moved the two classes that were actually using it to do that work in their constructors.", "author": "bbimber", "createdAt": "2021-02-05T05:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk1NTUwMw=="}], "type": "inlineReview", "revised_code": {"commit": "94b2c6a24763a88ae8d30ed242e843f9c1399757", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java\nindex e6268f25a..681e0d4f3 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java\n\n@@ -20,10 +20,6 @@ public abstract class VariantEvaluator implements Comparable<VariantEvaluator> {\n         this.simpleName = simpleName;\n     }\n \n-    public void initialize() {\n-\n-    }\n-\n     protected VariantEvalEngine getEngine() {\n         return engine;\n     }\n"}}, {"oid": "58fec234a4f95ac93fe370f9ee2439a278425e6d", "url": "https://github.com/broadinstitute/gatk/commit/58fec234a4f95ac93fe370f9ee2439a278425e6d", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class\n\nRespond to code review\n\nRespond to code review\n\nRestore alternate constructor used by VariantQC\n\nAllow deferred VariantEvalEngine initialization for VariantQC\n\nNot necessary to track sampleDB internally\n\nRemove custom constructor and deferred initialization", "committedDate": "2021-02-03T18:12:31Z", "type": "forcePushed"}, {"oid": "94b2c6a24763a88ae8d30ed242e843f9c1399757", "url": "https://github.com/broadinstitute/gatk/commit/94b2c6a24763a88ae8d30ed242e843f9c1399757", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class\n\nRespond to code review\n\nRespond to code review\n\nRestore alternate constructor used by VariantQC\n\nAllow deferred VariantEvalEngine initialization for VariantQC\n\nNot necessary to track sampleDB internally\n\nRemove custom constructor and deferred initialization\n\nRemove VariantEvaluator.initialize()\n\nRemove VariantStratifier.initialize()", "committedDate": "2021-02-09T18:13:35Z", "type": "forcePushed"}, {"oid": "c78cdacb6df01b766a50ef198001444aacaa4e29", "url": "https://github.com/broadinstitute/gatk/commit/c78cdacb6df01b766a50ef198001444aacaa4e29", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class\n\nRespond to code review\n\nRespond to code review\n\nRestore alternate constructor used by VariantQC\n\nAllow deferred VariantEvalEngine initialization for VariantQC\n\nNot necessary to track sampleDB internally\n\nRemove custom constructor and deferred initialization\n\nRemove VariantEvaluator.initialize()\n\nRemove VariantStratifier.initialize()", "committedDate": "2021-02-09T18:14:50Z", "type": "forcePushed"}, {"oid": "13bbf0ae8a6938688a2a8c8f92cbfbd2928f337d", "url": "https://github.com/broadinstitute/gatk/commit/13bbf0ae8a6938688a2a8c8f92cbfbd2928f337d", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class\n\nRespond to code review\n\nRespond to code review\n\nRestore alternate constructor used by VariantQC\n\nAllow deferred VariantEvalEngine initialization for VariantQC\n\nNot necessary to track sampleDB internally\n\nRemove custom constructor and deferred initialization\n\nRemove VariantEvaluator.initialize()\n\nRemove VariantStratifier.initialize()", "committedDate": "2021-04-27T17:01:41Z", "type": "forcePushed"}, {"oid": "fafe4d187ea9aa1dd1343990007456096ea1a3d3", "url": "https://github.com/broadinstitute/gatk/commit/fafe4d187ea9aa1dd1343990007456096ea1a3d3", "message": "Another approach to conditionally store FeatureInput name in VC\n\nFix test\n\nSource is actually always non-null so test specific string\n\nAdd dedicated test", "committedDate": "2021-04-28T12:50:49Z", "type": "commit"}, {"oid": "965cb75f45623af5c881f46d748a49db953d0fee", "url": "https://github.com/broadinstitute/gatk/commit/965cb75f45623af5c881f46d748a49db953d0fee", "message": "Code review", "committedDate": "2021-04-28T12:50:50Z", "type": "commit"}, {"oid": "b6b22e21bc3357d2496439376766e0f2d88549bf", "url": "https://github.com/broadinstitute/gatk/commit/b6b22e21bc3357d2496439376766e0f2d88549bf", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class\n\nRespond to code review\n\nRespond to code review\n\nRestore alternate constructor used by VariantQC\n\nAllow deferred VariantEvalEngine initialization for VariantQC\n\nNot necessary to track sampleDB internally\n\nRemove custom constructor and deferred initialization\n\nRemove VariantEvaluator.initialize()\n\nRemove VariantStratifier.initialize()", "committedDate": "2021-04-28T12:50:50Z", "type": "commit"}, {"oid": "996fb5d70de7dc8d1788807960e9ceccff220b27", "url": "https://github.com/broadinstitute/gatk/commit/996fb5d70de7dc8d1788807960e9ceccff220b27", "message": "Add import missed in merge", "committedDate": "2021-04-28T12:50:50Z", "type": "commit"}, {"oid": "cf17c7d16825187b341d0d087e4754d763b8146e", "url": "https://github.com/broadinstitute/gatk/commit/cf17c7d16825187b341d0d087e4754d763b8146e", "message": "Solution for validation error thrown in AlleleCount constructor", "committedDate": "2021-04-28T12:50:51Z", "type": "commit"}, {"oid": "fedde9dc8ea975643df44659389cda2d0fa36f1f", "url": "https://github.com/broadinstitute/gatk/commit/fedde9dc8ea975643df44659389cda2d0fa36f1f", "message": "Cleaner method for VariantStratifier classes to validate arguments", "committedDate": "2021-04-28T12:50:51Z", "type": "commit"}, {"oid": "e8d2d72a5c085c90c8715f3e44adba6e6fc8eed1", "url": "https://github.com/broadinstitute/gatk/commit/e8d2d72a5c085c90c8715f3e44adba6e6fc8eed1", "message": "- Avoid NPE in AlleleFrequencyQC test\n- Also dont store useCompAFStratifier and scale in AlleleFrequency, so we can set their values after instantiation", "committedDate": "2021-04-28T12:50:51Z", "type": "commit"}, {"oid": "698a9c0fc48abef17c2b7e95959ecffbd75f9853", "url": "https://github.com/broadinstitute/gatk/commit/698a9c0fc48abef17c2b7e95959ecffbd75f9853", "message": "Revert \"Cleaner method for VariantStratifier classes to validate arguments\"\n\nThis reverts commit 1569a909", "committedDate": "2021-04-28T12:50:51Z", "type": "commit"}, {"oid": "3ec0a0be8e10d03bb5541652408875f1418f0a65", "url": "https://github.com/broadinstitute/gatk/commit/3ec0a0be8e10d03bb5541652408875f1418f0a65", "message": "Propagate CommandLineException during creation of VariantEvaluator and VariantStratifier", "committedDate": "2021-04-28T12:50:51Z", "type": "commit"}, {"oid": "de27877a235613f200150502b1106daa773e1aee", "url": "https://github.com/broadinstitute/gatk/commit/de27877a235613f200150502b1106daa773e1aee", "message": "Exception is now re-thrown as CommandLineException", "committedDate": "2021-04-28T12:50:51Z", "type": "commit"}, {"oid": "4625432ae25cbad59f39266dea897a97ee041f80", "url": "https://github.com/broadinstitute/gatk/commit/4625432ae25cbad59f39266dea897a97ee041f80", "message": "Move options to VariantEvalArgumentCollection, to allow setting values more easily by AlleleFrequencyQC", "committedDate": "2021-04-28T12:50:52Z", "type": "commit"}, {"oid": "35995be77bb4adc1430c0f0a05ef9b7f9991193a", "url": "https://github.com/broadinstitute/gatk/commit/35995be77bb4adc1430c0f0a05ef9b7f9991193a", "message": "Fix merge", "committedDate": "2021-04-28T12:54:49Z", "type": "commit"}, {"oid": "35995be77bb4adc1430c0f0a05ef9b7f9991193a", "url": "https://github.com/broadinstitute/gatk/commit/35995be77bb4adc1430c0f0a05ef9b7f9991193a", "message": "Fix merge", "committedDate": "2021-04-28T12:54:49Z", "type": "forcePushed"}]}