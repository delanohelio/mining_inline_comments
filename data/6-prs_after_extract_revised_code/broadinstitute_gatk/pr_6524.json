{"pr_number": 6524, "pr_title": "Migrate reference arguments and downstream code to GATKPathSpecifier.", "pr_createdAt": "2020-03-24T22:04:14Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6524", "timeline": [{"oid": "cd05e5bf27e0331c21a097313723e8fc74934104", "url": "https://github.com/broadinstitute/gatk/commit/cd05e5bf27e0331c21a097313723e8fc74934104", "message": "Migrate reference command line arguments, and downstream code, to use GATKPathSpecifier.", "committedDate": "2020-03-30T13:43:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5MTI2Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6524#discussion_r407691267", "bodyText": "The previous implementation fell back on getBestAvailableSequenceDictionary() here -- was there any point to having that as a fallback, or was it pointless?", "author": "droazen", "createdAt": "2020-04-13T20:09:38Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/VariantAnnotator.java", "diffHunk": "@@ -188,23 +189,27 @@\n      */\n     public void onTraversalStart() {\n         // get the list of all sample names from the variant VCF, if applicable\n-        final  List<String> samples = getHeaderForVariants().getGenotypeSamples();\n+        final List<String> samples = getHeaderForVariants().getGenotypeSamples();\n         variantSamples = new IndexedSampleList(samples);\n \n         annotatorEngine = new VariantAnnotatorEngine(makeVariantAnnotations(), dbsnp.dbsnp, comps, false, false);\n-        annotatorEngine.addExpressions(expressionsToUse, resources, expressionAlleleConcordance );\n+        annotatorEngine.addExpressions(expressionsToUse, resources, expressionAlleleConcordance);\n \n         // setup the header fields\n         // note that if any of the definitions conflict with our new ones, then we want to overwrite the old ones\n-        final Set<VCFHeaderLine> hInfo = new HashSet<>();\n-\n+        Set<VCFHeaderLine> hInfo = new HashSet<>();\n         hInfo.addAll(annotatorEngine.getVCFAnnotationDescriptions(false));\n         hInfo.addAll(getHeaderForVariants().getMetaDataInInputOrder());\n \n-        // TODO ask reviewer, VCFUtils.withUpdatedContigs is what GATK3 calls into, it isn't used anywhere in 4 though so should it be used here?\n-        VCFHeader vcfHeader = new VCFHeader(hInfo, samples);\n+        if (hasReference()) {\n+            hInfo = VcfUtils.updateHeaderContigLines(\n+                    hInfo,\n+                    referenceArguments.getReferencePath(),\n+                    getReferenceDictionary(),", "originalCommit": "40d6ac3f030f630c191b15e5e1246dda7eabe3b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE0NzA2MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6524#discussion_r408147061", "bodyText": "I think its mostly pointless, but there are cases where not doing so would alter behavior (ie when a master sequence dictionary is provided but not a reference). So I'm going to restore the fallback for now. (Unifying the various patterns for output VCFHeader creation is another candidate for a refactoring project at some point).", "author": "cmnbroad", "createdAt": "2020-04-14T13:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5MTI2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "22ae7e23d51c59991af2dbae1827228bcd1bd667", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/VariantAnnotator.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/VariantAnnotator.java\nindex 7b4cf317e..038ee4e2d 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/VariantAnnotator.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/VariantAnnotator.java\n\n@@ -200,14 +200,12 @@ public class VariantAnnotator extends VariantWalker {\n         Set<VCFHeaderLine> hInfo = new HashSet<>();\n         hInfo.addAll(annotatorEngine.getVCFAnnotationDescriptions(false));\n         hInfo.addAll(getHeaderForVariants().getMetaDataInInputOrder());\n+        hInfo = VcfUtils.updateHeaderContigLines(\n+                hInfo,\n+                hasReference() ? referenceArguments.getReferencePath() : null,\n+                hasReference() ? getReferenceDictionary() : getBestAvailableSequenceDictionary(),\n+                false);\n \n-        if (hasReference()) {\n-            hInfo = VcfUtils.updateHeaderContigLines(\n-                    hInfo,\n-                    referenceArguments.getReferencePath(),\n-                    getReferenceDictionary(),\n-                    false);\n-        }\n         vcfWriter = createVCFWriter(outputFile);\n         vcfWriter.writeHeader(new VCFHeader(hInfo, samples));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5MjA5MA==", "url": "https://github.com/broadinstitute/gatk/pull/6524#discussion_r407692090", "bodyText": "Is there a reason why the CachingIndexedFastaSequenceFile can't accept a GATKPathSpecifier directly? (since it lives in GATK, even though its parent class is in HTSJDK)", "author": "droazen", "createdAt": "2020-04-13T20:11:08Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/HaplotypeCaller.java", "diffHunk": "@@ -202,9 +202,7 @@ public void onTraversalStart() {\n     }\n \n     private static CachingIndexedFastaSequenceFile getReferenceReader(ReferenceInputArgumentCollection referenceArguments) {\n-        // TODO: this code is duplicated in AssemblyBasedCallerUtils\n-        final Path reference = IOUtils.getPath(referenceArguments.getReferenceFileName());\n-        return new CachingIndexedFastaSequenceFile(reference);\n+        return new CachingIndexedFastaSequenceFile(referenceArguments.getReferencePath());", "originalCommit": "40d6ac3f030f630c191b15e5e1246dda7eabe3b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODExMTYzMg==", "url": "https://github.com/broadinstitute/gatk/pull/6524#discussion_r408111632", "bodyText": "Sounds right - I'll add a constructor.", "author": "cmnbroad", "createdAt": "2020-04-14T12:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5MjA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE0Mzk5Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6524#discussion_r408143993", "bodyText": "Actually, I started going down this path and it would enable ReferenceFileSource to use GATKPathSpecifier as well. I'm going to do the simple change and add the constructor for this one case in this PR, and then do the rest in another PR.", "author": "cmnbroad", "createdAt": "2020-04-14T13:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5MjA5MA=="}], "type": "inlineReview", "revised_code": {"commit": "22ae7e23d51c59991af2dbae1827228bcd1bd667", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/HaplotypeCaller.java b/src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/HaplotypeCaller.java\nindex 9dcda88e1..f75f6ca67 100644\n--- a/src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/HaplotypeCaller.java\n+++ b/src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/HaplotypeCaller.java\n\n@@ -202,7 +202,7 @@ public final class HaplotypeCaller extends AssemblyRegionWalker {\n     }\n \n     private static CachingIndexedFastaSequenceFile getReferenceReader(ReferenceInputArgumentCollection referenceArguments) {\n-        return new CachingIndexedFastaSequenceFile(referenceArguments.getReferencePath());\n+        return new CachingIndexedFastaSequenceFile(referenceArguments.getReferenceSpecifier());\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5MzA5NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6524#discussion_r407693095", "bodyText": "Perhaps this sort of method (querying the type of URL) should live in GATKPathSpecifier itself.", "author": "droazen", "createdAt": "2020-04-13T20:13:09Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/gcs/BucketUtils.java", "diffHunk": "@@ -69,6 +70,13 @@ public static boolean isCloudStorageUrl(final java.nio.file.Path path) {\n         return (\"\" + path.toUri().getScheme() + \"://\").equals(GCS_PREFIX);\n     }\n \n+    /**\n+     * Returns true if the given path is a HDFS (Hadoop filesystem) URL.\n+     */\n+    public static boolean isHadoopUrl(GATKPathSpecifier pathSpecifier) {\n+        return pathSpecifier == null ? false : pathSpecifier.getURI().getScheme().equals(HDFS_SCHEME);", "originalCommit": "40d6ac3f030f630c191b15e5e1246dda7eabe3b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE0NzYwOA==", "url": "https://github.com/broadinstitute/gatk/pull/6524#discussion_r408147608", "bodyText": "Yes. I'll migrate them there with tests in the next PR.", "author": "cmnbroad", "createdAt": "2020-04-14T13:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5MzA5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "5115030c8d58bff6111ef301616cc984c454f576", "chunk": "diff --git a/src/main/java/org/broadinstitute/hellbender/utils/gcs/BucketUtils.java b/src/main/java/org/broadinstitute/hellbender/utils/gcs/BucketUtils.java\nindex 0868876c6..e78014fea 100644\n--- a/src/main/java/org/broadinstitute/hellbender/utils/gcs/BucketUtils.java\n+++ b/src/main/java/org/broadinstitute/hellbender/utils/gcs/BucketUtils.java\n\n@@ -15,59 +19,81 @@ import org.apache.hadoop.conf.Configuration;\n import org.apache.hadoop.fs.FileStatus;\n import org.apache.hadoop.fs.FileSystem;\n import org.apache.hadoop.fs.Path;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n import org.broadinstitute.hellbender.exceptions.GATKException;\n import org.broadinstitute.hellbender.exceptions.UserException;\n import org.broadinstitute.hellbender.utils.Utils;\n import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.http.nio.HttpFileSystemProvider;\n+import org.broadinstitute.http.nio.HttpsFileSystemProvider;\n import shaded.cloud_nio.com.google.api.gax.retrying.RetrySettings;\n import shaded.cloud_nio.com.google.auth.oauth2.GoogleCredentials;\n import shaded.cloud_nio.com.google.cloud.http.HttpTransportOptions;\n import shaded.cloud_nio.org.threeten.bp.Duration;\n \n import java.io.*;\n+import java.net.URL;\n import java.nio.channels.SeekableByteChannel;\n import java.nio.file.Files;\n import java.util.Arrays;\n import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n import java.util.function.Function;\n \n /**\n  * Utilities for dealing with google buckets.\n  */\n public final class BucketUtils {\n-    public static final String GCS_SCHEME = \"gs\";\n-    public static final String GCS_PREFIX = GCS_SCHEME + \"://\";\n+    public static final String GCS_PREFIX = GoogleCloudStorageFileSystem.SCHEME + \"://\";\n+    public static final String HTTP_PREFIX = HttpFileSystemProvider.SCHEME + \"://\";\n+    public static final String HTTPS_PREFIX = HttpsFileSystemProvider.SCHEME +\"://\";\n     public static final String HDFS_SCHEME = \"hdfs\";\n     public static final String HDFS_PREFIX = HDFS_SCHEME + \"://\";\n \n     // slashes omitted since hdfs paths seem to only have 1 slash which would be weirder to include than no slashes\n     public static final String FILE_PREFIX = \"file:\";\n \n-    public static final Logger logger = LogManager.getLogger(\"org.broadinstitute.hellbender.utils.gcs\");\n-\n     private BucketUtils(){} //private so that no one will instantiate this class\n \n-    public static boolean isCloudStorageUrl(final String path) {\n+    /**\n+     * @param path path to inspect\n+     * @return true if this path represents a gcs location\n+     */\n+    public static boolean isGcsUrl(final String path) {\n         Utils.nonNull(path);\n         return path.startsWith(GCS_PREFIX);\n     }\n \n     /**\n-     * Return true if this {@code GATKPathSpecifier} represents a gcs URI.\n      * @param pathSpec specifier to inspect\n-     * @return true if this {@code GATKPathSpecifier} represents a gcs URI.\n+     * @return true if this {@code GATKPathSpecifier} represents a remote storage system which may benefit from prefetching (gcs or http(s))\n      */\n-    public static boolean isCloudStorageUrl(final GATKPathSpecifier pathSpec) {\n+    public static boolean isEligibleForPrefetching(final GATKPathSpecifier pathSpec) {\n         Utils.nonNull(pathSpec);\n-        return pathSpec.getScheme().equals(GCS_SCHEME);\n+        return isEligibleForPrefetching(pathSpec.getScheme());\n+     }\n+\n+    /**\n+     * @param path path to inspect\n+     * @return true if this {@code Path} represents a remote storage system which may benefit from prefetching (gcs or http(s))\n+     */\n+    public static boolean isEligibleForPrefetching(final java.nio.file.Path path) {\n+        Utils.nonNull(path);\n+        return isEligibleForPrefetching(path.toUri().getScheme());\n     }\n \n-    public static boolean isCloudStorageUrl(final java.nio.file.Path path) {\n-        // the initial \"\" protects us against a null scheme\n-        return (\"\" + path.toUri().getScheme() + \"://\").equals(GCS_PREFIX);\n+    private static boolean isEligibleForPrefetching(final String scheme){\n+        return scheme != null\n+                && (scheme.equals(GoogleCloudStorageFileSystem.SCHEME)\n+                || scheme.equals(HttpFileSystemProvider.SCHEME)\n+                || scheme.equals(HttpsFileSystemProvider.SCHEME));\n+    }\n+\n+    /**\n+     * @return true if the given path is an http or https Url.\n+     */\n+    public static boolean isHttpUrl(String path){\n+        return path.startsWith(HTTP_PREFIX) || path.startsWith(HTTPS_PREFIX);\n     }\n \n     /**\n"}}, {"oid": "22ae7e23d51c59991af2dbae1827228bcd1bd667", "url": "https://github.com/broadinstitute/gatk/commit/22ae7e23d51c59991af2dbae1827228bcd1bd667", "message": "Respond to review comments.", "committedDate": "2020-04-14T13:47:35Z", "type": "forcePushed"}, {"oid": "5115030c8d58bff6111ef301616cc984c454f576", "url": "https://github.com/broadinstitute/gatk/commit/5115030c8d58bff6111ef301616cc984c454f576", "message": "Fix a test with too many slashes.", "committedDate": "2020-04-21T12:20:30Z", "type": "forcePushed"}, {"oid": "d289336d3638f67ab83b27dfb6f296291724acfd", "url": "https://github.com/broadinstitute/gatk/commit/d289336d3638f67ab83b27dfb6f296291724acfd", "message": "Migrate reference command line arguments, and downstream code, to use GATKPathSpecifier.", "committedDate": "2020-04-21T19:00:13Z", "type": "commit"}, {"oid": "450a22f48c7ee887780bdfd0355fc336e9b41cad", "url": "https://github.com/broadinstitute/gatk/commit/450a22f48c7ee887780bdfd0355fc336e9b41cad", "message": "Remove obsolete comments, sanitize ReferenceMultiSparkSource and friends.", "committedDate": "2020-04-21T19:00:13Z", "type": "commit"}, {"oid": "b9c859d923e113fcd7c6b00c4628fc3d3d87a906", "url": "https://github.com/broadinstitute/gatk/commit/b9c859d923e113fcd7c6b00c4628fc3d3d87a906", "message": "Respond to review comments.", "committedDate": "2020-04-21T19:00:13Z", "type": "commit"}, {"oid": "66771e0e2c58ff53d02f63dadb2456361b2ed849", "url": "https://github.com/broadinstitute/gatk/commit/66771e0e2c58ff53d02f63dadb2456361b2ed849", "message": "Fix a test with too many slashes.", "committedDate": "2020-04-21T19:00:13Z", "type": "commit"}, {"oid": "93729f4ce7b8935103482bf92fe890101f351709", "url": "https://github.com/broadinstitute/gatk/commit/93729f4ce7b8935103482bf92fe890101f351709", "message": "Fix the other test with too many slashes.", "committedDate": "2020-04-21T19:00:13Z", "type": "commit"}, {"oid": "93729f4ce7b8935103482bf92fe890101f351709", "url": "https://github.com/broadinstitute/gatk/commit/93729f4ce7b8935103482bf92fe890101f351709", "message": "Fix the other test with too many slashes.", "committedDate": "2020-04-21T19:00:13Z", "type": "forcePushed"}]}