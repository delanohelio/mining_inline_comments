{"pr_number": 979, "pr_title": "Add builder support to Compose object api", "pr_createdAt": "2020-06-11T21:15:54Z", "pr_url": "https://github.com/minio/minio-java/pull/979", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMzMzE3MA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r439333170", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected void validateNullOrEmpty(Long arg, String argName) {\n          \n          \n            \n                protected void validateNullOrPositive(Number arg, String argName) {\n          \n      \n    \n    \n  \n\n\nEmpty doesn't make sense for Long\nChange the type of the first argument to Number so that it can be used to validate other numeric types as well.", "author": "anjalshireesh", "createdAt": "2020-06-12T10:16:41Z", "path": "api/src/main/java/io/minio/BaseArgs.java", "diffHunk": "@@ -65,6 +65,12 @@ protected void validateNullOrNotEmptyString(String arg, String argName) {\n       }\n     }\n \n+    protected void validateNullOrEmpty(Long arg, String argName) {", "originalCommit": "11cd1aa8822a05c9aeb11838caf908d1f4bbee91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0cf5205af174cff84e8bceb1bd9b7172df3dadf0", "chunk": "diff --git a/api/src/main/java/io/minio/BaseArgs.java b/api/src/main/java/io/minio/BaseArgs.java\nindex bb521a5f..1c6c070e 100644\n--- a/api/src/main/java/io/minio/BaseArgs.java\n+++ b/api/src/main/java/io/minio/BaseArgs.java\n\n@@ -65,8 +65,8 @@ public abstract class BaseArgs {\n       }\n     }\n \n-    protected void validateNullOrEmpty(Long arg, String argName) {\n-      if (arg != null && arg < 0) {\n+    protected void validateNullOrPositive(Number arg, String argName) {\n+      if (arg != null && arg.longValue() < 0) {\n         throw new IllegalArgumentException(argName + \" cannot be non-negative.\");\n       }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMzNTY1Nw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r439335657", "bodyText": "Override the validate(args) method and call validateSources from it (and any other validations that might be required before making the API call).", "author": "anjalshireesh", "createdAt": "2020-06-12T10:22:26Z", "path": "api/src/main/java/io/minio/ComposeObjectArgs.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.minio;\n+\n+import java.util.List;\n+\n+public class ComposeObjectArgs extends ObjectWriteArgs {\n+  List<ComposeSourceArgs> sources;\n+\n+  public List<ComposeSourceArgs> sources() {\n+    return sources;\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder extends ObjectWriteArgs.Builder<Builder, ComposeObjectArgs> {\n+    public Builder sources(List<ComposeSourceArgs> sources) {\n+      validateSources(sources);\n+      operations.add(args -> args.sources = sources);\n+      return this;\n+    }\n+\n+    private void validateSources(List<ComposeSourceArgs> sources) {\n+      if (sources.isEmpty()) {\n+        throw new IllegalArgumentException(\"compose sources cannot be empty\");\n+      }\n+    }\n+  }", "originalCommit": "11cd1aa8822a05c9aeb11838caf908d1f4bbee91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0cf5205af174cff84e8bceb1bd9b7172df3dadf0", "chunk": "diff --git a/api/src/main/java/io/minio/ComposeObjectArgs.java b/api/src/main/java/io/minio/ComposeObjectArgs.java\nindex 9f53b396..588bc181 100644\n--- a/api/src/main/java/io/minio/ComposeObjectArgs.java\n+++ b/api/src/main/java/io/minio/ComposeObjectArgs.java\n\n@@ -19,9 +19,9 @@ package io.minio;\n import java.util.List;\n \n public class ComposeObjectArgs extends ObjectWriteArgs {\n-  List<ComposeSourceArgs> sources;\n+  List<ComposeSource> sources;\n \n-  public List<ComposeSourceArgs> sources() {\n+  public List<ComposeSource> sources() {\n     return sources;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0Mzc5MQ==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r439343791", "bodyText": "This line is not required as super.validateSse(url) internally does the same.", "author": "anjalshireesh", "createdAt": "2020-06-12T10:42:02Z", "path": "api/src/main/java/io/minio/ComposeSourceArgs.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.minio;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n+import java.time.ZonedDateTime;\n+import okhttp3.HttpUrl;\n+\n+/** Argument class of MinioClient.composeObject(). */\n+public class ComposeSourceArgs extends ObjectWriteArgs {\n+  private String srcVersionId;\n+  private Long srcOffset;\n+  private Long srcLength;\n+  private long srcObjectSize;\n+  private ServerSideEncryptionCustomerKey srcSsec;\n+  private Multimap<String, String> headers;\n+\n+  private String srcMatchETag;\n+  private String srcNotMatchETag;\n+  private ZonedDateTime srcModifiedSince;\n+  private ZonedDateTime srcUnmodifiedSince;\n+  private Directive metadataDirective;\n+  private Directive taggingDirective;\n+\n+  public String srcBucket() {\n+    return bucketName;\n+  }\n+\n+  public String srcObject() {\n+    return objectName;\n+  }\n+\n+  public String srcVersionId() {\n+    return srcVersionId;\n+  }\n+\n+  public Long srcOffset() {\n+    return srcOffset;\n+  }\n+\n+  public Long srcLength() {\n+    return srcLength;\n+  }\n+\n+  public long objectSize() {\n+    return srcObjectSize;\n+  }\n+\n+  public ServerSideEncryptionCustomerKey srcSsec() {\n+    return srcSsec;\n+  }\n+\n+  public String srcMatchETag() {\n+    return srcMatchETag;\n+  }\n+\n+  public String srcNotMatchETag() {\n+    return srcNotMatchETag;\n+  }\n+\n+  public ZonedDateTime srcModifiedSince() {\n+    return srcModifiedSince;\n+  }\n+\n+  public ZonedDateTime srcUnmodifiedSince() {\n+    return srcUnmodifiedSince;\n+  }\n+\n+  public Directive metadataDirective() {\n+    return metadataDirective;\n+  }\n+\n+  public Directive taggingDirective() {\n+    return taggingDirective;\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  @Override\n+  public void validateSse(HttpUrl url) {\n+    super.validateSse(url);\n+    checkSse(srcSsec, url);", "originalCommit": "11cd1aa8822a05c9aeb11838caf908d1f4bbee91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0cf5205af174cff84e8bceb1bd9b7172df3dadf0", "chunk": "diff --git a/api/src/main/java/io/minio/ComposeSourceArgs.java b/api/src/main/java/io/minio/ComposeSourceArgs.java\ndeleted file mode 100644\nindex 7e214e98..00000000\n--- a/api/src/main/java/io/minio/ComposeSourceArgs.java\n+++ /dev/null\n\n@@ -1,266 +0,0 @@\n-/*\n- * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.minio;\n-\n-import com.google.common.collect.HashMultimap;\n-import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n-import java.time.ZonedDateTime;\n-import okhttp3.HttpUrl;\n-\n-/** Argument class of MinioClient.composeObject(). */\n-public class ComposeSourceArgs extends ObjectWriteArgs {\n-  private String srcVersionId;\n-  private Long srcOffset;\n-  private Long srcLength;\n-  private long srcObjectSize;\n-  private ServerSideEncryptionCustomerKey srcSsec;\n-  private Multimap<String, String> headers;\n-\n-  private String srcMatchETag;\n-  private String srcNotMatchETag;\n-  private ZonedDateTime srcModifiedSince;\n-  private ZonedDateTime srcUnmodifiedSince;\n-  private Directive metadataDirective;\n-  private Directive taggingDirective;\n-\n-  public String srcBucket() {\n-    return bucketName;\n-  }\n-\n-  public String srcObject() {\n-    return objectName;\n-  }\n-\n-  public String srcVersionId() {\n-    return srcVersionId;\n-  }\n-\n-  public Long srcOffset() {\n-    return srcOffset;\n-  }\n-\n-  public Long srcLength() {\n-    return srcLength;\n-  }\n-\n-  public long objectSize() {\n-    return srcObjectSize;\n-  }\n-\n-  public ServerSideEncryptionCustomerKey srcSsec() {\n-    return srcSsec;\n-  }\n-\n-  public String srcMatchETag() {\n-    return srcMatchETag;\n-  }\n-\n-  public String srcNotMatchETag() {\n-    return srcNotMatchETag;\n-  }\n-\n-  public ZonedDateTime srcModifiedSince() {\n-    return srcModifiedSince;\n-  }\n-\n-  public ZonedDateTime srcUnmodifiedSince() {\n-    return srcUnmodifiedSince;\n-  }\n-\n-  public Directive metadataDirective() {\n-    return metadataDirective;\n-  }\n-\n-  public Directive taggingDirective() {\n-    return taggingDirective;\n-  }\n-\n-  public static Builder builder() {\n-    return new Builder();\n-  }\n-\n-  @Override\n-  public void validateSse(HttpUrl url) {\n-    super.validateSse(url);\n-    checkSse(srcSsec, url);\n-  }\n-\n-  public Multimap<String, String> headers() {\n-    return headers;\n-  }\n-\n-  /** Constructs header . */\n-  public void buildHeaders(long objectSize, String etag) throws IllegalArgumentException {\n-    if (srcOffset != null && srcOffset >= objectSize) {\n-      throw new IllegalArgumentException(\n-          \"source \"\n-              + bucketName\n-              + \"/\"\n-              + objectName\n-              + \": offset \"\n-              + srcOffset\n-              + \" is beyond object size \"\n-              + objectSize);\n-    }\n-\n-    if (srcLength != null) {\n-      if (srcLength > objectSize) {\n-        throw new IllegalArgumentException(\n-            \"source \"\n-                + bucketName\n-                + \"/\"\n-                + objectName\n-                + \": length \"\n-                + srcLength\n-                + \" is beyond object size \"\n-                + objectSize);\n-      }\n-\n-      if (srcOffset + srcLength > objectSize) {\n-        throw new IllegalArgumentException(\n-            \"source \"\n-                + bucketName\n-                + \"/\"\n-                + objectName\n-                + \": compose size \"\n-                + (srcOffset + srcLength)\n-                + \" is beyond object size \"\n-                + objectSize);\n-      }\n-    }\n-\n-    Multimap<String, String> headers = HashMultimap.create();\n-    headers.put(\"x-amz-copy-source\", S3Escaper.encodePath(bucketName + \"/\" + objectName));\n-    headers.put(\"x-amz-copy-source-if-match\", etag);\n-\n-    if (extraHeaders() != null) {\n-      headers.putAll(extraHeaders());\n-    }\n-\n-    if (srcMatchETag != null) {\n-      headers.put(\"x-amz-copy-source-if-match\", srcMatchETag);\n-    }\n-\n-    if (srcSsec != null) {\n-      headers.putAll(Multimaps.forMap(srcSsec.copySourceHeaders()));\n-    }\n-\n-    if (srcNotMatchETag != null) {\n-      headers.put(\"x-amz-copy-source-if-none-match\", srcNotMatchETag);\n-    }\n-\n-    if (srcModifiedSince != null) {\n-      headers.put(\n-          \"x-amz-copy-source-if-modified-since\",\n-          srcModifiedSince.format(Time.HTTP_HEADER_DATE_FORMAT));\n-    }\n-\n-    if (srcUnmodifiedSince != null) {\n-      headers.put(\n-          \"x-amz-copy-source-if-unmodified-since\",\n-          srcUnmodifiedSince.format(Time.HTTP_HEADER_DATE_FORMAT));\n-    }\n-\n-    if (metadataDirective != null) {\n-      headers.put(\"x-amz-metadata-directive\", metadataDirective.name());\n-    }\n-\n-    if (taggingDirective != null) {\n-      headers.put(\"x-amz-tagging-directive\", taggingDirective.name());\n-    }\n-\n-    this.srcObjectSize = objectSize;\n-    this.headers = headers;\n-  }\n-\n-  /** Argument builder of {@link ComposeSourceArgs}. */\n-  public static final class Builder extends ObjectWriteArgs.Builder<Builder, ComposeSourceArgs> {\n-    @Override\n-    protected void validate(ComposeSourceArgs args) {\n-      super.validate(args);\n-      validateBucketName(args.bucket());\n-    }\n-\n-    public Builder srcBucket(String srcBucket) {\n-      validateBucketName(srcBucket);\n-      operations.add(args -> args.bucketName = srcBucket);\n-      return this;\n-    }\n-\n-    public Builder srcObject(String srcObject) {\n-      validateNullOrNotEmptyString(srcObject, \"source object\");\n-      operations.add(args -> args.objectName = srcObject);\n-      return this;\n-    }\n-\n-    public Builder srcVersionId(String srcVersionId) {\n-      validateNullOrNotEmptyString(srcVersionId, \"source version ID\");\n-      operations.add(args -> args.srcVersionId = srcVersionId);\n-      return this;\n-    }\n-\n-    public Builder srcOffset(long offset) {\n-      validateNullOrEmpty(offset, \"offset\");\n-      operations.add(args -> args.srcOffset = offset);\n-      return this;\n-    }\n-\n-    public Builder srcLength(long length) {\n-      validateNullOrEmpty(length, \"length\");\n-      operations.add(args -> args.srcLength = length);\n-      return this;\n-    }\n-\n-    public Builder srcSsec(ServerSideEncryptionCustomerKey ssec) {\n-      operations.add(args -> args.srcSsec = ssec);\n-      return this;\n-    }\n-\n-    public Builder srcMatchETag(String etag) {\n-      validateNullOrNotEmptyString(etag, \"etag\");\n-      operations.add(args -> args.srcMatchETag = etag);\n-      return this;\n-    }\n-\n-    public Builder srcNotMatchETag(String etag) {\n-      validateNullOrNotEmptyString(etag, \"etag\");\n-      operations.add(args -> args.srcNotMatchETag = etag);\n-      return this;\n-    }\n-\n-    public Builder srcModifiedSince(ZonedDateTime modifiedTime) {\n-      operations.add(args -> args.srcModifiedSince = modifiedTime);\n-      return this;\n-    }\n-\n-    public Builder srcUnmodifiedSince(ZonedDateTime modifiedTime) {\n-      operations.add(args -> args.srcUnmodifiedSince = modifiedTime);\n-      return this;\n-    }\n-\n-    public Builder metadataDirective(Directive directive) {\n-      operations.add(args -> args.metadataDirective = directive);\n-      return this;\n-    }\n-\n-    public Builder taggingDirective(Directive directive) {\n-      operations.add(args -> args.taggingDirective = directive);\n-      return this;\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0NTEwOA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r439345108", "bodyText": "Validations can be moved to a separate method", "author": "anjalshireesh", "createdAt": "2020-06-12T10:44:55Z", "path": "api/src/main/java/io/minio/ComposeSourceArgs.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.minio;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n+import java.time.ZonedDateTime;\n+import okhttp3.HttpUrl;\n+\n+/** Argument class of MinioClient.composeObject(). */\n+public class ComposeSourceArgs extends ObjectWriteArgs {\n+  private String srcVersionId;\n+  private Long srcOffset;\n+  private Long srcLength;\n+  private long srcObjectSize;\n+  private ServerSideEncryptionCustomerKey srcSsec;\n+  private Multimap<String, String> headers;\n+\n+  private String srcMatchETag;\n+  private String srcNotMatchETag;\n+  private ZonedDateTime srcModifiedSince;\n+  private ZonedDateTime srcUnmodifiedSince;\n+  private Directive metadataDirective;\n+  private Directive taggingDirective;\n+\n+  public String srcBucket() {\n+    return bucketName;\n+  }\n+\n+  public String srcObject() {\n+    return objectName;\n+  }\n+\n+  public String srcVersionId() {\n+    return srcVersionId;\n+  }\n+\n+  public Long srcOffset() {\n+    return srcOffset;\n+  }\n+\n+  public Long srcLength() {\n+    return srcLength;\n+  }\n+\n+  public long objectSize() {\n+    return srcObjectSize;\n+  }\n+\n+  public ServerSideEncryptionCustomerKey srcSsec() {\n+    return srcSsec;\n+  }\n+\n+  public String srcMatchETag() {\n+    return srcMatchETag;\n+  }\n+\n+  public String srcNotMatchETag() {\n+    return srcNotMatchETag;\n+  }\n+\n+  public ZonedDateTime srcModifiedSince() {\n+    return srcModifiedSince;\n+  }\n+\n+  public ZonedDateTime srcUnmodifiedSince() {\n+    return srcUnmodifiedSince;\n+  }\n+\n+  public Directive metadataDirective() {\n+    return metadataDirective;\n+  }\n+\n+  public Directive taggingDirective() {\n+    return taggingDirective;\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  @Override\n+  public void validateSse(HttpUrl url) {\n+    super.validateSse(url);\n+    checkSse(srcSsec, url);\n+  }\n+\n+  public Multimap<String, String> headers() {\n+    return headers;\n+  }\n+\n+  /** Constructs header . */\n+  public void buildHeaders(long objectSize, String etag) throws IllegalArgumentException {\n+    if (srcOffset != null && srcOffset >= objectSize) {\n+      throw new IllegalArgumentException(\n+          \"source \"\n+              + bucketName\n+              + \"/\"\n+              + objectName\n+              + \": offset \"\n+              + srcOffset\n+              + \" is beyond object size \"\n+              + objectSize);\n+    }\n+\n+    if (srcLength != null) {\n+      if (srcLength > objectSize) {\n+        throw new IllegalArgumentException(\n+            \"source \"\n+                + bucketName\n+                + \"/\"\n+                + objectName\n+                + \": length \"\n+                + srcLength\n+                + \" is beyond object size \"\n+                + objectSize);\n+      }\n+\n+      if (srcOffset + srcLength > objectSize) {\n+        throw new IllegalArgumentException(\n+            \"source \"\n+                + bucketName\n+                + \"/\"\n+                + objectName\n+                + \": compose size \"\n+                + (srcOffset + srcLength)\n+                + \" is beyond object size \"\n+                + objectSize);\n+      }\n+    }", "originalCommit": "11cd1aa8822a05c9aeb11838caf908d1f4bbee91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0cf5205af174cff84e8bceb1bd9b7172df3dadf0", "chunk": "diff --git a/api/src/main/java/io/minio/ComposeSourceArgs.java b/api/src/main/java/io/minio/ComposeSourceArgs.java\ndeleted file mode 100644\nindex 7e214e98..00000000\n--- a/api/src/main/java/io/minio/ComposeSourceArgs.java\n+++ /dev/null\n\n@@ -1,266 +0,0 @@\n-/*\n- * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.minio;\n-\n-import com.google.common.collect.HashMultimap;\n-import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n-import java.time.ZonedDateTime;\n-import okhttp3.HttpUrl;\n-\n-/** Argument class of MinioClient.composeObject(). */\n-public class ComposeSourceArgs extends ObjectWriteArgs {\n-  private String srcVersionId;\n-  private Long srcOffset;\n-  private Long srcLength;\n-  private long srcObjectSize;\n-  private ServerSideEncryptionCustomerKey srcSsec;\n-  private Multimap<String, String> headers;\n-\n-  private String srcMatchETag;\n-  private String srcNotMatchETag;\n-  private ZonedDateTime srcModifiedSince;\n-  private ZonedDateTime srcUnmodifiedSince;\n-  private Directive metadataDirective;\n-  private Directive taggingDirective;\n-\n-  public String srcBucket() {\n-    return bucketName;\n-  }\n-\n-  public String srcObject() {\n-    return objectName;\n-  }\n-\n-  public String srcVersionId() {\n-    return srcVersionId;\n-  }\n-\n-  public Long srcOffset() {\n-    return srcOffset;\n-  }\n-\n-  public Long srcLength() {\n-    return srcLength;\n-  }\n-\n-  public long objectSize() {\n-    return srcObjectSize;\n-  }\n-\n-  public ServerSideEncryptionCustomerKey srcSsec() {\n-    return srcSsec;\n-  }\n-\n-  public String srcMatchETag() {\n-    return srcMatchETag;\n-  }\n-\n-  public String srcNotMatchETag() {\n-    return srcNotMatchETag;\n-  }\n-\n-  public ZonedDateTime srcModifiedSince() {\n-    return srcModifiedSince;\n-  }\n-\n-  public ZonedDateTime srcUnmodifiedSince() {\n-    return srcUnmodifiedSince;\n-  }\n-\n-  public Directive metadataDirective() {\n-    return metadataDirective;\n-  }\n-\n-  public Directive taggingDirective() {\n-    return taggingDirective;\n-  }\n-\n-  public static Builder builder() {\n-    return new Builder();\n-  }\n-\n-  @Override\n-  public void validateSse(HttpUrl url) {\n-    super.validateSse(url);\n-    checkSse(srcSsec, url);\n-  }\n-\n-  public Multimap<String, String> headers() {\n-    return headers;\n-  }\n-\n-  /** Constructs header . */\n-  public void buildHeaders(long objectSize, String etag) throws IllegalArgumentException {\n-    if (srcOffset != null && srcOffset >= objectSize) {\n-      throw new IllegalArgumentException(\n-          \"source \"\n-              + bucketName\n-              + \"/\"\n-              + objectName\n-              + \": offset \"\n-              + srcOffset\n-              + \" is beyond object size \"\n-              + objectSize);\n-    }\n-\n-    if (srcLength != null) {\n-      if (srcLength > objectSize) {\n-        throw new IllegalArgumentException(\n-            \"source \"\n-                + bucketName\n-                + \"/\"\n-                + objectName\n-                + \": length \"\n-                + srcLength\n-                + \" is beyond object size \"\n-                + objectSize);\n-      }\n-\n-      if (srcOffset + srcLength > objectSize) {\n-        throw new IllegalArgumentException(\n-            \"source \"\n-                + bucketName\n-                + \"/\"\n-                + objectName\n-                + \": compose size \"\n-                + (srcOffset + srcLength)\n-                + \" is beyond object size \"\n-                + objectSize);\n-      }\n-    }\n-\n-    Multimap<String, String> headers = HashMultimap.create();\n-    headers.put(\"x-amz-copy-source\", S3Escaper.encodePath(bucketName + \"/\" + objectName));\n-    headers.put(\"x-amz-copy-source-if-match\", etag);\n-\n-    if (extraHeaders() != null) {\n-      headers.putAll(extraHeaders());\n-    }\n-\n-    if (srcMatchETag != null) {\n-      headers.put(\"x-amz-copy-source-if-match\", srcMatchETag);\n-    }\n-\n-    if (srcSsec != null) {\n-      headers.putAll(Multimaps.forMap(srcSsec.copySourceHeaders()));\n-    }\n-\n-    if (srcNotMatchETag != null) {\n-      headers.put(\"x-amz-copy-source-if-none-match\", srcNotMatchETag);\n-    }\n-\n-    if (srcModifiedSince != null) {\n-      headers.put(\n-          \"x-amz-copy-source-if-modified-since\",\n-          srcModifiedSince.format(Time.HTTP_HEADER_DATE_FORMAT));\n-    }\n-\n-    if (srcUnmodifiedSince != null) {\n-      headers.put(\n-          \"x-amz-copy-source-if-unmodified-since\",\n-          srcUnmodifiedSince.format(Time.HTTP_HEADER_DATE_FORMAT));\n-    }\n-\n-    if (metadataDirective != null) {\n-      headers.put(\"x-amz-metadata-directive\", metadataDirective.name());\n-    }\n-\n-    if (taggingDirective != null) {\n-      headers.put(\"x-amz-tagging-directive\", taggingDirective.name());\n-    }\n-\n-    this.srcObjectSize = objectSize;\n-    this.headers = headers;\n-  }\n-\n-  /** Argument builder of {@link ComposeSourceArgs}. */\n-  public static final class Builder extends ObjectWriteArgs.Builder<Builder, ComposeSourceArgs> {\n-    @Override\n-    protected void validate(ComposeSourceArgs args) {\n-      super.validate(args);\n-      validateBucketName(args.bucket());\n-    }\n-\n-    public Builder srcBucket(String srcBucket) {\n-      validateBucketName(srcBucket);\n-      operations.add(args -> args.bucketName = srcBucket);\n-      return this;\n-    }\n-\n-    public Builder srcObject(String srcObject) {\n-      validateNullOrNotEmptyString(srcObject, \"source object\");\n-      operations.add(args -> args.objectName = srcObject);\n-      return this;\n-    }\n-\n-    public Builder srcVersionId(String srcVersionId) {\n-      validateNullOrNotEmptyString(srcVersionId, \"source version ID\");\n-      operations.add(args -> args.srcVersionId = srcVersionId);\n-      return this;\n-    }\n-\n-    public Builder srcOffset(long offset) {\n-      validateNullOrEmpty(offset, \"offset\");\n-      operations.add(args -> args.srcOffset = offset);\n-      return this;\n-    }\n-\n-    public Builder srcLength(long length) {\n-      validateNullOrEmpty(length, \"length\");\n-      operations.add(args -> args.srcLength = length);\n-      return this;\n-    }\n-\n-    public Builder srcSsec(ServerSideEncryptionCustomerKey ssec) {\n-      operations.add(args -> args.srcSsec = ssec);\n-      return this;\n-    }\n-\n-    public Builder srcMatchETag(String etag) {\n-      validateNullOrNotEmptyString(etag, \"etag\");\n-      operations.add(args -> args.srcMatchETag = etag);\n-      return this;\n-    }\n-\n-    public Builder srcNotMatchETag(String etag) {\n-      validateNullOrNotEmptyString(etag, \"etag\");\n-      operations.add(args -> args.srcNotMatchETag = etag);\n-      return this;\n-    }\n-\n-    public Builder srcModifiedSince(ZonedDateTime modifiedTime) {\n-      operations.add(args -> args.srcModifiedSince = modifiedTime);\n-      return this;\n-    }\n-\n-    public Builder srcUnmodifiedSince(ZonedDateTime modifiedTime) {\n-      operations.add(args -> args.srcUnmodifiedSince = modifiedTime);\n-      return this;\n-    }\n-\n-    public Builder metadataDirective(Directive directive) {\n-      operations.add(args -> args.metadataDirective = directive);\n-      return this;\n-    }\n-\n-    public Builder taggingDirective(Directive directive) {\n-      operations.add(args -> args.taggingDirective = directive);\n-      return this;\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM1MTkzMw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r439351933", "bodyText": "This is not required as super.validate(args) internally invokes validateBucketName anyway", "author": "anjalshireesh", "createdAt": "2020-06-12T10:59:25Z", "path": "api/src/main/java/io/minio/ComposeSourceArgs.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.minio;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n+import java.time.ZonedDateTime;\n+import okhttp3.HttpUrl;\n+\n+/** Argument class of MinioClient.composeObject(). */\n+public class ComposeSourceArgs extends ObjectWriteArgs {\n+  private String srcVersionId;\n+  private Long srcOffset;\n+  private Long srcLength;\n+  private long srcObjectSize;\n+  private ServerSideEncryptionCustomerKey srcSsec;\n+  private Multimap<String, String> headers;\n+\n+  private String srcMatchETag;\n+  private String srcNotMatchETag;\n+  private ZonedDateTime srcModifiedSince;\n+  private ZonedDateTime srcUnmodifiedSince;\n+  private Directive metadataDirective;\n+  private Directive taggingDirective;\n+\n+  public String srcBucket() {\n+    return bucketName;\n+  }\n+\n+  public String srcObject() {\n+    return objectName;\n+  }\n+\n+  public String srcVersionId() {\n+    return srcVersionId;\n+  }\n+\n+  public Long srcOffset() {\n+    return srcOffset;\n+  }\n+\n+  public Long srcLength() {\n+    return srcLength;\n+  }\n+\n+  public long objectSize() {\n+    return srcObjectSize;\n+  }\n+\n+  public ServerSideEncryptionCustomerKey srcSsec() {\n+    return srcSsec;\n+  }\n+\n+  public String srcMatchETag() {\n+    return srcMatchETag;\n+  }\n+\n+  public String srcNotMatchETag() {\n+    return srcNotMatchETag;\n+  }\n+\n+  public ZonedDateTime srcModifiedSince() {\n+    return srcModifiedSince;\n+  }\n+\n+  public ZonedDateTime srcUnmodifiedSince() {\n+    return srcUnmodifiedSince;\n+  }\n+\n+  public Directive metadataDirective() {\n+    return metadataDirective;\n+  }\n+\n+  public Directive taggingDirective() {\n+    return taggingDirective;\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  @Override\n+  public void validateSse(HttpUrl url) {\n+    super.validateSse(url);\n+    checkSse(srcSsec, url);\n+  }\n+\n+  public Multimap<String, String> headers() {\n+    return headers;\n+  }\n+\n+  /** Constructs header . */\n+  public void buildHeaders(long objectSize, String etag) throws IllegalArgumentException {\n+    if (srcOffset != null && srcOffset >= objectSize) {\n+      throw new IllegalArgumentException(\n+          \"source \"\n+              + bucketName\n+              + \"/\"\n+              + objectName\n+              + \": offset \"\n+              + srcOffset\n+              + \" is beyond object size \"\n+              + objectSize);\n+    }\n+\n+    if (srcLength != null) {\n+      if (srcLength > objectSize) {\n+        throw new IllegalArgumentException(\n+            \"source \"\n+                + bucketName\n+                + \"/\"\n+                + objectName\n+                + \": length \"\n+                + srcLength\n+                + \" is beyond object size \"\n+                + objectSize);\n+      }\n+\n+      if (srcOffset + srcLength > objectSize) {\n+        throw new IllegalArgumentException(\n+            \"source \"\n+                + bucketName\n+                + \"/\"\n+                + objectName\n+                + \": compose size \"\n+                + (srcOffset + srcLength)\n+                + \" is beyond object size \"\n+                + objectSize);\n+      }\n+    }\n+\n+    Multimap<String, String> headers = HashMultimap.create();\n+    headers.put(\"x-amz-copy-source\", S3Escaper.encodePath(bucketName + \"/\" + objectName));\n+    headers.put(\"x-amz-copy-source-if-match\", etag);\n+\n+    if (extraHeaders() != null) {\n+      headers.putAll(extraHeaders());\n+    }\n+\n+    if (srcMatchETag != null) {\n+      headers.put(\"x-amz-copy-source-if-match\", srcMatchETag);\n+    }\n+\n+    if (srcSsec != null) {\n+      headers.putAll(Multimaps.forMap(srcSsec.copySourceHeaders()));\n+    }\n+\n+    if (srcNotMatchETag != null) {\n+      headers.put(\"x-amz-copy-source-if-none-match\", srcNotMatchETag);\n+    }\n+\n+    if (srcModifiedSince != null) {\n+      headers.put(\n+          \"x-amz-copy-source-if-modified-since\",\n+          srcModifiedSince.format(Time.HTTP_HEADER_DATE_FORMAT));\n+    }\n+\n+    if (srcUnmodifiedSince != null) {\n+      headers.put(\n+          \"x-amz-copy-source-if-unmodified-since\",\n+          srcUnmodifiedSince.format(Time.HTTP_HEADER_DATE_FORMAT));\n+    }\n+\n+    if (metadataDirective != null) {\n+      headers.put(\"x-amz-metadata-directive\", metadataDirective.name());\n+    }\n+\n+    if (taggingDirective != null) {\n+      headers.put(\"x-amz-tagging-directive\", taggingDirective.name());\n+    }\n+\n+    this.srcObjectSize = objectSize;\n+    this.headers = headers;\n+  }\n+\n+  /** Argument builder of {@link ComposeSourceArgs}. */\n+  public static final class Builder extends ObjectWriteArgs.Builder<Builder, ComposeSourceArgs> {\n+    @Override\n+    protected void validate(ComposeSourceArgs args) {\n+      super.validate(args);\n+      validateBucketName(args.bucket());", "originalCommit": "11cd1aa8822a05c9aeb11838caf908d1f4bbee91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0cf5205af174cff84e8bceb1bd9b7172df3dadf0", "chunk": "diff --git a/api/src/main/java/io/minio/ComposeSourceArgs.java b/api/src/main/java/io/minio/ComposeSourceArgs.java\ndeleted file mode 100644\nindex 7e214e98..00000000\n--- a/api/src/main/java/io/minio/ComposeSourceArgs.java\n+++ /dev/null\n\n@@ -1,266 +0,0 @@\n-/*\n- * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.minio;\n-\n-import com.google.common.collect.HashMultimap;\n-import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n-import java.time.ZonedDateTime;\n-import okhttp3.HttpUrl;\n-\n-/** Argument class of MinioClient.composeObject(). */\n-public class ComposeSourceArgs extends ObjectWriteArgs {\n-  private String srcVersionId;\n-  private Long srcOffset;\n-  private Long srcLength;\n-  private long srcObjectSize;\n-  private ServerSideEncryptionCustomerKey srcSsec;\n-  private Multimap<String, String> headers;\n-\n-  private String srcMatchETag;\n-  private String srcNotMatchETag;\n-  private ZonedDateTime srcModifiedSince;\n-  private ZonedDateTime srcUnmodifiedSince;\n-  private Directive metadataDirective;\n-  private Directive taggingDirective;\n-\n-  public String srcBucket() {\n-    return bucketName;\n-  }\n-\n-  public String srcObject() {\n-    return objectName;\n-  }\n-\n-  public String srcVersionId() {\n-    return srcVersionId;\n-  }\n-\n-  public Long srcOffset() {\n-    return srcOffset;\n-  }\n-\n-  public Long srcLength() {\n-    return srcLength;\n-  }\n-\n-  public long objectSize() {\n-    return srcObjectSize;\n-  }\n-\n-  public ServerSideEncryptionCustomerKey srcSsec() {\n-    return srcSsec;\n-  }\n-\n-  public String srcMatchETag() {\n-    return srcMatchETag;\n-  }\n-\n-  public String srcNotMatchETag() {\n-    return srcNotMatchETag;\n-  }\n-\n-  public ZonedDateTime srcModifiedSince() {\n-    return srcModifiedSince;\n-  }\n-\n-  public ZonedDateTime srcUnmodifiedSince() {\n-    return srcUnmodifiedSince;\n-  }\n-\n-  public Directive metadataDirective() {\n-    return metadataDirective;\n-  }\n-\n-  public Directive taggingDirective() {\n-    return taggingDirective;\n-  }\n-\n-  public static Builder builder() {\n-    return new Builder();\n-  }\n-\n-  @Override\n-  public void validateSse(HttpUrl url) {\n-    super.validateSse(url);\n-    checkSse(srcSsec, url);\n-  }\n-\n-  public Multimap<String, String> headers() {\n-    return headers;\n-  }\n-\n-  /** Constructs header . */\n-  public void buildHeaders(long objectSize, String etag) throws IllegalArgumentException {\n-    if (srcOffset != null && srcOffset >= objectSize) {\n-      throw new IllegalArgumentException(\n-          \"source \"\n-              + bucketName\n-              + \"/\"\n-              + objectName\n-              + \": offset \"\n-              + srcOffset\n-              + \" is beyond object size \"\n-              + objectSize);\n-    }\n-\n-    if (srcLength != null) {\n-      if (srcLength > objectSize) {\n-        throw new IllegalArgumentException(\n-            \"source \"\n-                + bucketName\n-                + \"/\"\n-                + objectName\n-                + \": length \"\n-                + srcLength\n-                + \" is beyond object size \"\n-                + objectSize);\n-      }\n-\n-      if (srcOffset + srcLength > objectSize) {\n-        throw new IllegalArgumentException(\n-            \"source \"\n-                + bucketName\n-                + \"/\"\n-                + objectName\n-                + \": compose size \"\n-                + (srcOffset + srcLength)\n-                + \" is beyond object size \"\n-                + objectSize);\n-      }\n-    }\n-\n-    Multimap<String, String> headers = HashMultimap.create();\n-    headers.put(\"x-amz-copy-source\", S3Escaper.encodePath(bucketName + \"/\" + objectName));\n-    headers.put(\"x-amz-copy-source-if-match\", etag);\n-\n-    if (extraHeaders() != null) {\n-      headers.putAll(extraHeaders());\n-    }\n-\n-    if (srcMatchETag != null) {\n-      headers.put(\"x-amz-copy-source-if-match\", srcMatchETag);\n-    }\n-\n-    if (srcSsec != null) {\n-      headers.putAll(Multimaps.forMap(srcSsec.copySourceHeaders()));\n-    }\n-\n-    if (srcNotMatchETag != null) {\n-      headers.put(\"x-amz-copy-source-if-none-match\", srcNotMatchETag);\n-    }\n-\n-    if (srcModifiedSince != null) {\n-      headers.put(\n-          \"x-amz-copy-source-if-modified-since\",\n-          srcModifiedSince.format(Time.HTTP_HEADER_DATE_FORMAT));\n-    }\n-\n-    if (srcUnmodifiedSince != null) {\n-      headers.put(\n-          \"x-amz-copy-source-if-unmodified-since\",\n-          srcUnmodifiedSince.format(Time.HTTP_HEADER_DATE_FORMAT));\n-    }\n-\n-    if (metadataDirective != null) {\n-      headers.put(\"x-amz-metadata-directive\", metadataDirective.name());\n-    }\n-\n-    if (taggingDirective != null) {\n-      headers.put(\"x-amz-tagging-directive\", taggingDirective.name());\n-    }\n-\n-    this.srcObjectSize = objectSize;\n-    this.headers = headers;\n-  }\n-\n-  /** Argument builder of {@link ComposeSourceArgs}. */\n-  public static final class Builder extends ObjectWriteArgs.Builder<Builder, ComposeSourceArgs> {\n-    @Override\n-    protected void validate(ComposeSourceArgs args) {\n-      super.validate(args);\n-      validateBucketName(args.bucket());\n-    }\n-\n-    public Builder srcBucket(String srcBucket) {\n-      validateBucketName(srcBucket);\n-      operations.add(args -> args.bucketName = srcBucket);\n-      return this;\n-    }\n-\n-    public Builder srcObject(String srcObject) {\n-      validateNullOrNotEmptyString(srcObject, \"source object\");\n-      operations.add(args -> args.objectName = srcObject);\n-      return this;\n-    }\n-\n-    public Builder srcVersionId(String srcVersionId) {\n-      validateNullOrNotEmptyString(srcVersionId, \"source version ID\");\n-      operations.add(args -> args.srcVersionId = srcVersionId);\n-      return this;\n-    }\n-\n-    public Builder srcOffset(long offset) {\n-      validateNullOrEmpty(offset, \"offset\");\n-      operations.add(args -> args.srcOffset = offset);\n-      return this;\n-    }\n-\n-    public Builder srcLength(long length) {\n-      validateNullOrEmpty(length, \"length\");\n-      operations.add(args -> args.srcLength = length);\n-      return this;\n-    }\n-\n-    public Builder srcSsec(ServerSideEncryptionCustomerKey ssec) {\n-      operations.add(args -> args.srcSsec = ssec);\n-      return this;\n-    }\n-\n-    public Builder srcMatchETag(String etag) {\n-      validateNullOrNotEmptyString(etag, \"etag\");\n-      operations.add(args -> args.srcMatchETag = etag);\n-      return this;\n-    }\n-\n-    public Builder srcNotMatchETag(String etag) {\n-      validateNullOrNotEmptyString(etag, \"etag\");\n-      operations.add(args -> args.srcNotMatchETag = etag);\n-      return this;\n-    }\n-\n-    public Builder srcModifiedSince(ZonedDateTime modifiedTime) {\n-      operations.add(args -> args.srcModifiedSince = modifiedTime);\n-      return this;\n-    }\n-\n-    public Builder srcUnmodifiedSince(ZonedDateTime modifiedTime) {\n-      operations.add(args -> args.srcUnmodifiedSince = modifiedTime);\n-      return this;\n-    }\n-\n-    public Builder metadataDirective(Directive directive) {\n-      operations.add(args -> args.metadataDirective = directive);\n-      return this;\n-    }\n-\n-    public Builder taggingDirective(Directive directive) {\n-      operations.add(args -> args.taggingDirective = directive);\n-      return this;\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2MDU1Mw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r439360553", "bodyText": "Needs to be updated with the new builder based syntax", "author": "anjalshireesh", "createdAt": "2020-06-12T11:18:20Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2751,6 +2753,258 @@ public void composeObject(\n     }\n   }\n \n+  /**\n+   * Creates an object by combining data from different source objects using server-side copy.\n+   *\n+   * <pre>Example:{@code\n+   * List<ComposeSource> sourceObjectList = new ArrayList<ComposeSource>();\n+   * sourceObjectList.add(new ComposeSource(\"my-job-bucket\", \"my-objectname-part-one\"));\n+   * sourceObjectList.add(new ComposeSource(\"my-job-bucket\", \"my-objectname-part-two\"));\n+   * sourceObjectList.add(new ComposeSource(\"my-job-bucket\", \"my-objectname-part-three\"));\n+   *\n+   * // Create my-bucketname/my-objectname by combining source object list.\n+   * minioClient.composeObject(\"my-bucketname\", \"my-objectname\", sourceObjectList,\n+   *     null, null);\n+   *\n+   * // Create my-bucketname/my-objectname with user metadata by combining source object\n+   * // list.\n+   * minioClient.composeObject(\"my-bucketname\", \"my-objectname\", sourceObjectList,\n+   *     userMetadata, null);\n+   *\n+   * // Create my-bucketname/my-objectname with user metadata and server-side encryption\n+   * // by combining source object list.\n+   * minioClient.composeObject(\"my-bucketname\", \"my-objectname\", sourceObjectList,\n+   *     userMetadata, sse);", "originalCommit": "11cd1aa8822a05c9aeb11838caf908d1f4bbee91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0cf5205af174cff84e8bceb1bd9b7172df3dadf0", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 4d52797d..9cf7ad6a 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2555,202 +2555,16 @@ public class MinioClient {\n           InternalException, InvalidBucketNameException, InvalidKeyException,\n           InvalidResponseException, IOException, NoSuchAlgorithmException, ServerException,\n           XmlParserException {\n-    if ((bucketName == null) || (bucketName.isEmpty())) {\n-      throw new IllegalArgumentException(\"bucket name cannot be empty\");\n-    }\n-\n-    checkObjectName(objectName);\n-\n-    if (sources.isEmpty()) {\n-      throw new IllegalArgumentException(\"compose sources cannot be empty\");\n-    }\n-\n-    checkWriteRequestSse(sse);\n-\n-    long objectSize = 0;\n-    int partsCount = 0;\n-    for (int i = 0; i < sources.size(); i++) {\n-      ComposeSource src = sources.get(i);\n-\n-      checkReadRequestSse(src.ssec());\n-\n-      ObjectStat stat = statObject(src.bucketName(), src.objectName(), src.ssec());\n-      src.buildHeaders(stat.length(), stat.etag());\n-\n-      if (i != 0 && src.headers().containsKey(\"x-amz-meta-x-amz-key\")) {\n-        throw new IllegalArgumentException(\n-            \"Client side encryption is not supported for more than one source\");\n-      }\n-\n-      long size = stat.length();\n-      if (src.length() != null) {\n-        size = src.length();\n-      } else if (src.offset() != null) {\n-        size -= src.offset();\n-      }\n-\n-      if (size < PutObjectOptions.MIN_MULTIPART_SIZE\n-          && sources.size() != 1\n-          && i != (sources.size() - 1)) {\n-        throw new IllegalArgumentException(\n-            \"source \"\n-                + src.bucketName()\n-                + \"/\"\n-                + src.objectName()\n-                + \": size \"\n-                + size\n-                + \" must be greater than \"\n-                + PutObjectOptions.MIN_MULTIPART_SIZE);\n-      }\n-\n-      objectSize += size;\n-      if (objectSize > PutObjectOptions.MAX_OBJECT_SIZE) {\n-        throw new IllegalArgumentException(\n-            \"Destination object size must be less than \" + PutObjectOptions.MAX_OBJECT_SIZE);\n-      }\n-\n-      if (size > PutObjectOptions.MAX_PART_SIZE) {\n-        long count = size / PutObjectOptions.MAX_PART_SIZE;\n-        long lastPartSize = size - (count * PutObjectOptions.MAX_PART_SIZE);\n-        if (lastPartSize > 0) {\n-          count++;\n-        } else {\n-          lastPartSize = PutObjectOptions.MAX_PART_SIZE;\n-        }\n-\n-        if (lastPartSize < PutObjectOptions.MIN_MULTIPART_SIZE\n-            && sources.size() != 1\n-            && i != (sources.size() - 1)) {\n-          throw new IllegalArgumentException(\n-              \"source \"\n-                  + src.bucketName()\n-                  + \"/\"\n-                  + src.objectName()\n-                  + \": \"\n-                  + \"for multipart split upload of \"\n-                  + size\n-                  + \", last part size is less than \"\n-                  + PutObjectOptions.MIN_MULTIPART_SIZE);\n-        }\n-\n-        partsCount += (int) count;\n-      } else {\n-        partsCount++;\n-      }\n-\n-      if (partsCount > PutObjectOptions.MAX_MULTIPART_COUNT) {\n-        throw new IllegalArgumentException(\n-            \"Compose sources create more than allowed multipart count \"\n-                + PutObjectOptions.MAX_MULTIPART_COUNT);\n-      }\n-    }\n \n-    if (partsCount == 1) {\n-      ComposeSource src = sources.get(0);\n-      if (headerMap == null) {\n-        headerMap = new HashMap<>();\n-      }\n-      if ((src.offset() != null) && (src.length() == null)) {\n-        headerMap.put(\"x-amz-copy-source-range\", \"bytes=\" + src.offset() + \"-\");\n-      }\n-\n-      if ((src.offset() != null) && (src.length() != null)) {\n-        headerMap.put(\n-            \"x-amz-copy-source-range\",\n-            \"bytes=\" + src.offset() + \"-\" + (src.offset() + src.length() - 1));\n-      }\n-      copyObject(\n-          bucketName,\n-          objectName,\n-          headerMap,\n-          sse,\n-          src.bucketName(),\n-          src.objectName(),\n-          src.ssec(),\n-          src.copyConditions());\n-      return;\n-    }\n-\n-    Map<String, String> sseHeaders = null;\n-    if (sse != null) {\n-      sseHeaders = sse.headers();\n-      if (headerMap == null) {\n-        headerMap = new HashMap<>();\n-      }\n-      headerMap.putAll(sseHeaders);\n-    }\n-\n-    String uploadId = createMultipartUpload(bucketName, objectName, headerMap);\n-\n-    int partNumber = 0;\n-    Part[] totalParts = new Part[partsCount];\n-    try {\n-      for (int i = 0; i < sources.size(); i++) {\n-        ComposeSource src = sources.get(i);\n-\n-        long size = src.objectSize();\n-        if (src.length() != null) {\n-          size = src.length();\n-        } else if (src.offset() != null) {\n-          size -= src.offset();\n-        }\n-        long offset = 0;\n-        if (src.offset() != null) {\n-          offset = src.offset();\n-        }\n-\n-        if (size <= PutObjectOptions.MAX_PART_SIZE) {\n-          partNumber++;\n-          Map<String, String> headers = new HashMap<>();\n-          if (src.headers() != null) {\n-            headers.putAll(src.headers());\n-          }\n-          if (src.length() != null) {\n-            headers.put(\n-                \"x-amz-copy-source-range\", \"bytes=\" + offset + \"-\" + (offset + src.length() - 1));\n-          } else if (src.offset() != null) {\n-            headers.put(\"x-amz-copy-source-range\", \"bytes=\" + offset + \"-\" + (offset + size - 1));\n-          }\n-          if (sseHeaders != null) {\n-            headers.putAll(sseHeaders);\n-          }\n-          String eTag = uploadPartCopy(bucketName, objectName, uploadId, partNumber, headers);\n-\n-          totalParts[partNumber - 1] = new Part(partNumber, eTag);\n-          continue;\n-        }\n-\n-        while (size > 0) {\n-          partNumber++;\n-\n-          long startBytes = offset;\n-          long endBytes = startBytes + PutObjectOptions.MAX_PART_SIZE;\n-          if (size < PutObjectOptions.MAX_PART_SIZE) {\n-            endBytes = startBytes + size;\n-          }\n-\n-          Map<String, String> headers = src.headers();\n-          headers.put(\"x-amz-copy-source-range\", \"bytes=\" + startBytes + \"-\" + endBytes);\n-          if (sseHeaders != null) {\n-            headers.putAll(sseHeaders);\n-          }\n-          String eTag = uploadPartCopy(bucketName, objectName, uploadId, partNumber, headers);\n-\n-          totalParts[partNumber - 1] = new Part(partNumber, eTag);\n-\n-          offset = startBytes;\n-          size -= (endBytes - startBytes);\n-        }\n-      }\n+    ComposeObjectArgs.Builder builder =\n+        ComposeObjectArgs.builder()\n+            .bucket(bucketName)\n+            .object(objectName)\n+            .extraHeaders(Multimaps.forMap(headerMap))\n+            .sources(sources)\n+            .sse(sse);\n \n-      completeMultipartUpload(bucketName, objectName, uploadId, totalParts);\n-    } catch (RuntimeException e) {\n-      abortMultipartUpload(bucketName, objectName, uploadId);\n-      throw e;\n-    } catch (Exception e) {\n-      abortMultipartUpload(bucketName, objectName, uploadId);\n-      throw e;\n-    }\n+    composeObject(builder.build());\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2MDc4Mw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r439360783", "bodyText": "This method should internally call the new one.", "author": "anjalshireesh", "createdAt": "2020-06-12T11:19:05Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2542,7 +2542,9 @@ public void copyObject(CopyObjectArgs args)\n    * @throws IOException thrown to indicate I/O error on S3 operation.\n    * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n    * @throws XmlParserException thrown to indicate XML parsing error.\n+   * @deprecated use {@link #composeObject(ComposeObjectArgs)}\n    */\n+  @Deprecated", "originalCommit": "11cd1aa8822a05c9aeb11838caf908d1f4bbee91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2MTI4MA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r439361280", "bodyText": "Add the javadoc deprecation comment as well\nCan this method internally call the new one?", "author": "anjalshireesh", "createdAt": "2020-06-12T11:20:30Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -7251,6 +7505,7 @@ protected void completeMultipartUpload(\n    * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n    * @throws XmlParserException thrown to indicate XML parsing error.\n    */\n+  @Deprecated", "originalCommit": "11cd1aa8822a05c9aeb11838caf908d1f4bbee91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0cf5205af174cff84e8bceb1bd9b7172df3dadf0", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 4d52797d..9cf7ad6a 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -7505,27 +7423,16 @@ public class MinioClient {\n    * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n    * @throws XmlParserException thrown to indicate XML parsing error.\n    */\n-  @Deprecated\n   protected String createMultipartUpload(\n       String bucketName, String objectName, Map<String, String> headerMap)\n       throws InvalidBucketNameException, IllegalArgumentException, NoSuchAlgorithmException,\n           InsufficientDataException, IOException, InvalidKeyException, ServerException,\n           XmlParserException, ErrorResponseException, InternalException, InvalidResponseException {\n-    // set content type if not set already\n-    if ((headerMap != null) && (headerMap.get(\"Content-Type\") == null)) {\n-      headerMap.put(\"Content-Type\", \"application/octet-stream\");\n-    }\n-\n-    Map<String, String> queryParamMap = new HashMap<>();\n-    queryParamMap.put(\"uploads\", \"\");\n-\n-    Response response = executePost(bucketName, objectName, headerMap, queryParamMap, \"\");\n-\n-    try (ResponseBody body = response.body()) {\n-      InitiateMultipartUploadResult result =\n-          Xml.unmarshal(InitiateMultipartUploadResult.class, body.charStream());\n-      return result.uploadId();\n-    }\n+    return createMultipartUpload(\n+        bucketName,\n+        getRegion(bucketName),\n+        objectName,\n+        Multimaps.forMap(normalizeHeaders(headerMap)));\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2MTY3Mg==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r439361672", "bodyText": "All arguments are not covered", "author": "anjalshireesh", "createdAt": "2020-06-12T11:21:32Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -7273,6 +7528,67 @@ protected String createMultipartUpload(\n     }\n   }\n \n+  /**\n+   * Do <a\n+   * href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html\">CreateMultipartUpload\n+   * S3 API</a>.\n+   *\n+   * @param bucketName Name of the bucket.\n+   * @param objectName Object name in the bucket.\n+   * @param headers Request headers.", "originalCommit": "11cd1aa8822a05c9aeb11838caf908d1f4bbee91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0cf5205af174cff84e8bceb1bd9b7172df3dadf0", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 4d52797d..9cf7ad6a 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -7505,27 +7423,16 @@ public class MinioClient {\n    * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n    * @throws XmlParserException thrown to indicate XML parsing error.\n    */\n-  @Deprecated\n   protected String createMultipartUpload(\n       String bucketName, String objectName, Map<String, String> headerMap)\n       throws InvalidBucketNameException, IllegalArgumentException, NoSuchAlgorithmException,\n           InsufficientDataException, IOException, InvalidKeyException, ServerException,\n           XmlParserException, ErrorResponseException, InternalException, InvalidResponseException {\n-    // set content type if not set already\n-    if ((headerMap != null) && (headerMap.get(\"Content-Type\") == null)) {\n-      headerMap.put(\"Content-Type\", \"application/octet-stream\");\n-    }\n-\n-    Map<String, String> queryParamMap = new HashMap<>();\n-    queryParamMap.put(\"uploads\", \"\");\n-\n-    Response response = executePost(bucketName, objectName, headerMap, queryParamMap, \"\");\n-\n-    try (ResponseBody body = response.body()) {\n-      InitiateMultipartUploadResult result =\n-          Xml.unmarshal(InitiateMultipartUploadResult.class, body.charStream());\n-      return result.uploadId();\n-    }\n+    return createMultipartUpload(\n+        bucketName,\n+        getRegion(bucketName),\n+        objectName,\n+        Multimaps.forMap(normalizeHeaders(headerMap)));\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2MjczNw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r439362737", "bodyText": "Can be private if being used only from the same class.", "author": "anjalshireesh", "createdAt": "2020-06-12T11:24:34Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -7645,4 +7961,56 @@ protected String uploadPartCopy(\n       return result.etag();\n     }\n   }\n+\n+  /**\n+   * Do <a\n+   * href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPartCopy.html\">UploadPartCopy\n+   * S3 API</a>.\n+   *\n+   * @param bucketName Name of the bucket.\n+   * @param objectName Object name in the bucket.\n+   * @param uploadId Upload ID.\n+   * @param partNumber Part number.\n+   * @param headerMap Source object definitions.\n+   * @return String - Contains ETag.\n+   * @throws ErrorResponseException thrown to indicate S3 service returned an error response.\n+   * @throws IllegalArgumentException throws to indicate invalid argument passed.\n+   * @throws InsufficientDataException thrown to indicate not enough data available in InputStream.\n+   * @throws InternalException thrown to indicate internal library error.\n+   * @throws InvalidBucketNameException thrown to indicate invalid bucket name passed.\n+   * @throws InvalidKeyException thrown to indicate missing of HMAC SHA-256 library.\n+   * @throws InvalidResponseException thrown to indicate S3 service returned invalid or no error\n+   *     response.\n+   * @throws IOException thrown to indicate I/O error on S3 operation.\n+   * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n+   * @throws XmlParserException thrown to indicate XML parsing error.\n+   */\n+  protected String uploadPartCopy(", "originalCommit": "11cd1aa8822a05c9aeb11838caf908d1f4bbee91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0cf5205af174cff84e8bceb1bd9b7172df3dadf0", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 4d52797d..9cf7ad6a 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -7943,49 +7844,7 @@ public class MinioClient {\n    * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n    * @throws XmlParserException thrown to indicate XML parsing error.\n    */\n-  protected String uploadPartCopy(\n-      String bucketName,\n-      String objectName,\n-      String uploadId,\n-      int partNumber,\n-      Map<String, String> headerMap)\n-      throws InvalidBucketNameException, IllegalArgumentException, NoSuchAlgorithmException,\n-          InsufficientDataException, IOException, InvalidKeyException, ServerException,\n-          XmlParserException, ErrorResponseException, InternalException, InvalidResponseException {\n-    Map<String, String> queryParamMap = new HashMap<>();\n-    queryParamMap.put(\"partNumber\", Integer.toString(partNumber));\n-    queryParamMap.put(\"uploadId\", uploadId);\n-    Response response = executePut(bucketName, objectName, headerMap, queryParamMap, \"\", 0);\n-    try (ResponseBody body = response.body()) {\n-      CopyPartResult result = Xml.unmarshal(CopyPartResult.class, body.charStream());\n-      return result.etag();\n-    }\n-  }\n-\n-  /**\n-   * Do <a\n-   * href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPartCopy.html\">UploadPartCopy\n-   * S3 API</a>.\n-   *\n-   * @param bucketName Name of the bucket.\n-   * @param objectName Object name in the bucket.\n-   * @param uploadId Upload ID.\n-   * @param partNumber Part number.\n-   * @param headerMap Source object definitions.\n-   * @return String - Contains ETag.\n-   * @throws ErrorResponseException thrown to indicate S3 service returned an error response.\n-   * @throws IllegalArgumentException throws to indicate invalid argument passed.\n-   * @throws InsufficientDataException thrown to indicate not enough data available in InputStream.\n-   * @throws InternalException thrown to indicate internal library error.\n-   * @throws InvalidBucketNameException thrown to indicate invalid bucket name passed.\n-   * @throws InvalidKeyException thrown to indicate missing of HMAC SHA-256 library.\n-   * @throws InvalidResponseException thrown to indicate S3 service returned invalid or no error\n-   *     response.\n-   * @throws IOException thrown to indicate I/O error on S3 operation.\n-   * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n-   * @throws XmlParserException thrown to indicate XML parsing error.\n-   */\n-  protected String uploadPartCopy(\n+  private String uploadPartCopy(\n       String bucketName,\n       String objectName,\n       String uploadId,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NTQ2Mw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r439475463", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /** Test: ccomposeObject(ComposeObjectArgs args). */\n          \n          \n            \n              /** Test: composeObject(ComposeObjectArgs args). */", "author": "anjalshireesh", "createdAt": "2020-06-12T15:04:58Z", "path": "functional/FunctionalTest.java", "diffHunk": "@@ -2669,17 +2677,14 @@ public static void copyObject_test11() throws Exception {\n         false);\n   }\n \n-  /**\n-   * Test: composeObject(String bucketName, String objectName, List&lt;ComposeSource&gt;\n-   * composeSources,Map &lt;String, String&gt; headerMap, ServerSideEncryption sseTarget).\n-   */\n+  /** Test: ccomposeObject(ComposeObjectArgs args). */", "originalCommit": "11cd1aa8822a05c9aeb11838caf908d1f4bbee91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0cf5205af174cff84e8bceb1bd9b7172df3dadf0", "chunk": "diff --git a/functional/FunctionalTest.java b/functional/FunctionalTest.java\nindex fc7c3813..57adc354 100644\n--- a/functional/FunctionalTest.java\n+++ b/functional/FunctionalTest.java\n\n@@ -2677,7 +2671,7 @@ public class FunctionalTest {\n         false);\n   }\n \n-  /** Test: ccomposeObject(ComposeObjectArgs args). */\n+  /** Test: composeObject(ComposeObjectArgs args). */\n   public static void composeObject_test1() throws Exception {\n     String methodName = \"composeObject(ComposeObjectArgs args)\";\n     if (!mintEnv) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3ODMzOQ==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r439478339", "bodyText": "Did you mean testArgs ?", "author": "anjalshireesh", "createdAt": "2020-06-12T15:10:04Z", "path": "functional/FunctionalTest.java", "diffHunk": "@@ -2755,130 +2738,90 @@ public static void composeObject_test2() throws Exception {\n       PutObjectOptions options = new PutObjectOptions(6 * MB, -1);\n       client.putObject(bucketName, filename1, filename1, options);\n       client.putObject(bucketName, filename2, filename2, options);\n-      ComposeSource s1 = new ComposeSource(bucketName, filename1, 10L, 6291436L, null, null, null);\n-      ComposeSource s2 = new ComposeSource(bucketName, filename2, null, null, null, null, null);\n+      ComposeSourceArgs s1 =\n+          ComposeSourceArgs.builder()\n+              .bucket(bucketName)\n+              .object(filename1)\n+              .srcOffset(10L)\n+              .srcLength(6291436L)\n+              .build();\n+      ComposeSourceArgs s2 =\n+          ComposeSourceArgs.builder().bucket(bucketName).object(filename2).build();\n \n-      List<ComposeSource> listSourceObjects = new ArrayList<ComposeSource>();\n+      List<ComposeSourceArgs> listSourceObjects = new ArrayList<ComposeSourceArgs>();\n       listSourceObjects.add(s1);\n       listSourceObjects.add(s2);\n-\n-      client.composeObject(bucketName, destinationObjectName, listSourceObjects, null, null);\n-      Files.delete(Paths.get(filename1));\n-      Files.delete(Paths.get(filename2));\n-\n-      client.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(filename1).build());\n-      client.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(filename2).build());\n-      client.removeObject(\n-          RemoveObjectArgs.builder().bucket(bucketName).object(destinationObjectName).build());\n-\n-      mintSuccessLog(\n-          \"composeObject(String bucketName, String objectName,List<ComposeSource> composeSources, \"\n-              + \"Map <String,String > headerMap, ServerSideEncryption sseTarget)\",\n-          \"with offset and length.\",\n-          startTime);\n-\n-    } catch (Exception e) {\n-      ErrorResponse errorResponse = null;\n-      if (e instanceof ErrorResponseException) {\n-        ErrorResponseException exp = (ErrorResponseException) e;\n-        errorResponse = exp.errorResponse();\n-      }\n-\n-      // Ignore NotImplemented error\n-      if (errorResponse != null && errorResponse.errorCode() == ErrorCode.NOT_IMPLEMENTED) {\n-        mintIgnoredLog(\n-            \"composeObject(String bucketName, String objectName,List<ComposeSource> composeSources, \"\n-                + \"Map <String,String > headerMap, ServerSideEncryption sseTarget)\"\n-                + \"with offset and length.\",\n-            null,\n-            startTime);\n-      } else {\n-        mintFailedLog(\n-            \"composeObject(String bucketName, String objectName,List<ComposeSource> composeSources, \"\n-                + \"Map <String,String > headerMap, ServerSideEncryption sseTarget)\",\n-            \"with offset and length.\",\n-            startTime,\n-            null,\n-            e.toString() + \" >>> \" + Arrays.toString(e.getStackTrace()));\n-        throw e;\n+      try {\n+        client.composeObject(\n+            ComposeObjectArgs.builder()\n+                .bucket(bucketName)\n+                .object(destinationObjectName)\n+                .sources(listSourceObjects)\n+                .build());\n+        client.removeObject(\n+            RemoveObjectArgs.builder().bucket(bucketName).object(destinationObjectName).build());\n+      } finally {\n+        deleteFilesAndObjects(bucketName, new String[] {filename1, filename2});\n       }\n+      mintSuccessLog(methodName, mintArgs, startTime);\n+    } catch (Exception e) {\n+      handleException(methodName, mintArgs, startTime, e);\n     }\n   }\n \n-  /**\n-   * Test: composeObject(String bucketName, String objectName, List&lt;ComposeSource&gt;\n-   * composeSources,Map &lt;String, String&gt; headerMap, ServerSideEncryption sseTarget).\n-   */\n+  /** Test: composeObject(ComposeObjectArgs args) with one source. */\n   public static void composeObject_test3() throws Exception {\n+    String methodName = \"composeObject(ComposeObjectArgs args)\";\n+    String testTags = \"with one source\";", "originalCommit": "11cd1aa8822a05c9aeb11838caf908d1f4bbee91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwNTk1Mw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r440005953", "bodyText": "These are just tags not the arguments for mint so testArgs seems logical. Its done in copyObject too.", "author": "sinhaashish", "createdAt": "2020-06-15T08:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3ODMzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "0cf5205af174cff84e8bceb1bd9b7172df3dadf0", "chunk": "diff --git a/functional/FunctionalTest.java b/functional/FunctionalTest.java\nindex fc7c3813..57adc354 100644\n--- a/functional/FunctionalTest.java\n+++ b/functional/FunctionalTest.java\n\n@@ -2738,17 +2730,16 @@ public class FunctionalTest {\n       PutObjectOptions options = new PutObjectOptions(6 * MB, -1);\n       client.putObject(bucketName, filename1, filename1, options);\n       client.putObject(bucketName, filename2, filename2, options);\n-      ComposeSourceArgs s1 =\n-          ComposeSourceArgs.builder()\n+      ComposeSource s1 =\n+          ComposeSource.builder()\n               .bucket(bucketName)\n               .object(filename1)\n-              .srcOffset(10L)\n-              .srcLength(6291436L)\n+              .offset(10L)\n+              .length(6291436L)\n               .build();\n-      ComposeSourceArgs s2 =\n-          ComposeSourceArgs.builder().bucket(bucketName).object(filename2).build();\n+      ComposeSource s2 = ComposeSource.builder().bucket(bucketName).object(filename2).build();\n \n-      List<ComposeSourceArgs> listSourceObjects = new ArrayList<ComposeSourceArgs>();\n+      List<ComposeSource> listSourceObjects = new ArrayList<ComposeSource>();\n       listSourceObjects.add(s1);\n       listSourceObjects.add(s2);\n       try {\n"}}, {"oid": "0cf5205af174cff84e8bceb1bd9b7172df3dadf0", "url": "https://github.com/minio/minio-java/commit/0cf5205af174cff84e8bceb1bd9b7172df3dadf0", "message": "Address review comments", "committedDate": "2020-06-15T08:05:27Z", "type": "forcePushed"}, {"oid": "8c65613eab24dbd3cc34536515d73df366f282fc", "url": "https://github.com/minio/minio-java/commit/8c65613eab24dbd3cc34536515d73df366f282fc", "message": "Address review comments", "committedDate": "2020-06-15T09:53:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg4NDI0NQ==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r440884245", "bodyText": "Since this method is not doing anything apart from calling the super method, it is not required anymore.", "author": "anjalshireesh", "createdAt": "2020-06-16T14:14:32Z", "path": "api/src/main/java/io/minio/ComposeSource.java", "diffHunk": "@@ -153,56 +152,52 @@ public void buildHeaders(long objectSize, String etag) throws IllegalArgumentExc\n                 + objectSize);\n       }\n     }\n+  }\n \n-    Map<String, String> headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n-    headers.put(\"x-amz-copy-source\", S3Escaper.encodePath(bucketName + \"/\" + objectName));\n-    headers.put(\"x-amz-copy-source-if-match\", etag);\n-\n-    if (headerMap != null) {\n-      headers.putAll(headerMap);\n+  /** Argument builder of {@link ComposeSource}. */\n+  public static final class Builder extends ObjectVersionArgs.Builder<Builder, ComposeSource> {\n+    @Override\n+    protected void validate(ComposeSource args) {", "originalCommit": "8c65613eab24dbd3cc34536515d73df366f282fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "31168c12e1dd9a69237286aff08da5705db50d8e", "chunk": "diff --git a/api/src/main/java/io/minio/ComposeSource.java b/api/src/main/java/io/minio/ComposeSource.java\nindex c31ce2eb..85f3ab50 100644\n--- a/api/src/main/java/io/minio/ComposeSource.java\n+++ b/api/src/main/java/io/minio/ComposeSource.java\n\n@@ -156,10 +156,6 @@ public class ComposeSource extends ObjectVersionArgs {\n \n   /** Argument builder of {@link ComposeSource}. */\n   public static final class Builder extends ObjectVersionArgs.Builder<Builder, ComposeSource> {\n-    @Override\n-    protected void validate(ComposeSource args) {\n-      super.validate(args);\n-    }\n \n     public Builder offset(long offset) {\n       validateNullOrPositive(offset, \"offset\");\n"}}, {"oid": "3b5d42f70c0a906002002148c25c84bee13be223", "url": "https://github.com/minio/minio-java/commit/3b5d42f70c0a906002002148c25c84bee13be223", "message": "ObjectWriteResponse from composeObject & copyObject", "committedDate": "2020-06-17T09:31:08Z", "type": "forcePushed"}, {"oid": "ea96a3aa90dce8b6568183d34d767ea3252bba3b", "url": "https://github.com/minio/minio-java/commit/ea96a3aa90dce8b6568183d34d767ea3252bba3b", "message": "ObjectWriteResponse from composeObject & copyObject", "committedDate": "2020-06-17T09:57:50Z", "type": "forcePushed"}, {"oid": "31168c12e1dd9a69237286aff08da5705db50d8e", "url": "https://github.com/minio/minio-java/commit/31168c12e1dd9a69237286aff08da5705db50d8e", "message": "Modify ObjectWriteResponse", "committedDate": "2020-06-17T13:20:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5NjkxOA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r441696918", "bodyText": "null check needs to be done for sources", "author": "balamurugana", "createdAt": "2020-06-17T17:06:18Z", "path": "api/src/main/java/io/minio/ComposeObjectArgs.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * MinIO Java SDK for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.minio;\n+\n+import java.util.List;\n+\n+public class ComposeObjectArgs extends ObjectWriteArgs {\n+  List<ComposeSource> sources;\n+\n+  public List<ComposeSource> sources() {\n+    return sources;\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder extends ObjectWriteArgs.Builder<Builder, ComposeObjectArgs> {\n+    @Override\n+    protected void validate(ComposeObjectArgs args) {\n+      super.validate(args);\n+      validateSources(args.sources);\n+    }\n+\n+    public Builder sources(List<ComposeSource> sources) {\n+      validateSources(sources);\n+      operations.add(args -> args.sources = sources);\n+      return this;\n+    }\n+\n+    private void validateSources(List<ComposeSource> sources) {\n+      if (sources.isEmpty()) {", "originalCommit": "31168c12e1dd9a69237286aff08da5705db50d8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/api/src/main/java/io/minio/ComposeObjectArgs.java b/api/src/main/java/io/minio/ComposeObjectArgs.java\nindex 588bc181..9f53b396 100644\n--- a/api/src/main/java/io/minio/ComposeObjectArgs.java\n+++ b/api/src/main/java/io/minio/ComposeObjectArgs.java\n\n@@ -19,9 +19,9 @@ package io.minio;\n import java.util.List;\n \n public class ComposeObjectArgs extends ObjectWriteArgs {\n-  List<ComposeSource> sources;\n+  List<ComposeSourceArgs> sources;\n \n-  public List<ComposeSource> sources() {\n+  public List<ComposeSourceArgs> sources() {\n     return sources;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5ODQ0MQ==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r441698441", "bodyText": "Remove unwanted white spaces.", "author": "balamurugana", "createdAt": "2020-06-17T17:08:50Z", "path": "api/src/main/java/io/minio/ComposeSource.java", "diffHunk": "@@ -17,105 +17,104 @@\n \n package io.minio;\n \n-import java.util.Collections;\n-import java.util.Map;\n-import java.util.TreeMap;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n+import java.time.ZonedDateTime;\n \n /** Source information to compose object. */\n-public class ComposeSource {\n-  private String bucketName;\n-  private String objectName;\n+public class ComposeSource extends ObjectVersionArgs {\n   private Long offset;\n   private Long length;\n-  private Map<String, String> headerMap;\n-  private CopyConditions copyConditions;\n-  private ServerSideEncryptionCustomerKey ssec;\n   private long objectSize;\n-  private Map<String, String> headers;\n+  private String matchETag;\n+  private String notMatchETag;\n+  private ZonedDateTime modifiedSince;\n+  private ZonedDateTime unmodifiedSince;\n+  private ServerSideEncryptionCustomerKey ssec;\n+\n+  private Multimap<String, String> headers;\n \n-  /** Create new ComposeSource for given bucket and object. */\n-  public ComposeSource(String bucketName, String objectName) throws IllegalArgumentException {\n-    this(bucketName, objectName, null, null, null, null, null);\n+  public Long offset() {\n+    return offset;\n   }\n \n-  /** Create new ComposeSource for given bucket, object, offset and length. */\n-  public ComposeSource(String bucketName, String objectName, Long offset, Long length)\n-      throws IllegalArgumentException {\n-    this(bucketName, objectName, offset, length, null, null, null);\n+  public Long length() {\n+    return length;\n   }\n \n-  /** Create new ComposeSource for given bucket, object, offset, length and headerMap. */\n-  public ComposeSource(\n-      String bucketName, String objectName, Long offset, Long length, Map<String, String> headerMap)\n-      throws IllegalArgumentException {\n-    this(bucketName, objectName, offset, length, headerMap, null, null);\n+  public long objectSize() {\n+    return objectSize;\n   }\n \n-  /**\n-   * Create new ComposeSource for given bucket, object, offset, length, headerMap and\n-   * CopyConditions.\n-   */\n-  public ComposeSource(\n-      String bucketName,\n-      String objectName,\n-      Long offset,\n-      Long length,\n-      Map<String, String> headerMap,\n-      CopyConditions copyConditions)\n-      throws IllegalArgumentException {\n-    this(bucketName, objectName, offset, length, headerMap, copyConditions, null);\n+  public String matchETag() {\n+    return matchETag;\n   }\n \n-  /**\n-   * Creates new ComposeSource for given bucket, object, offset, length, headerMap, CopyConditions\n-   * and server side encryption.\n-   *\n-   * @throws IllegalArgumentException upon invalid value is passed to a method.\n-   */\n-  public ComposeSource(\n-      String bucketName,\n-      String objectName,\n-      Long offset,\n-      Long length,\n-      Map<String, String> headerMap,\n-      CopyConditions copyConditions,\n-      ServerSideEncryptionCustomerKey ssec)\n-      throws IllegalArgumentException {\n-    if (bucketName == null) {\n-      throw new IllegalArgumentException(\"Source bucket name cannot be empty\");\n+  public String notMatchETag() {\n+    return notMatchETag;\n+  }\n+\n+  public ZonedDateTime modifiedSince() {\n+    return modifiedSince;\n+  }\n+\n+  public ZonedDateTime unmodifiedSince() {\n+    return unmodifiedSince;\n+  }\n+\n+  public Multimap<String, String> headers() {\n+    return headers;\n+  }\n+\n+  public ServerSideEncryptionCustomerKey ssec() {\n+    return ssec;\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  /** Constructs header . */", "originalCommit": "31168c12e1dd9a69237286aff08da5705db50d8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/api/src/main/java/io/minio/ComposeSource.java b/api/src/main/java/io/minio/ComposeSource.java\nindex 85f3ab50..2ff5c9b6 100644\n--- a/api/src/main/java/io/minio/ComposeSource.java\n+++ b/api/src/main/java/io/minio/ComposeSource.java\n\n@@ -17,104 +17,105 @@\n \n package io.minio;\n \n-import com.google.common.collect.HashMultimap;\n-import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n-import java.time.ZonedDateTime;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.TreeMap;\n \n /** Source information to compose object. */\n-public class ComposeSource extends ObjectVersionArgs {\n+public class ComposeSource {\n+  private String bucketName;\n+  private String objectName;\n   private Long offset;\n   private Long length;\n-  private long objectSize;\n-  private String matchETag;\n-  private String notMatchETag;\n-  private ZonedDateTime modifiedSince;\n-  private ZonedDateTime unmodifiedSince;\n+  private Map<String, String> headerMap;\n+  private CopyConditions copyConditions;\n   private ServerSideEncryptionCustomerKey ssec;\n+  private long objectSize;\n+  private Map<String, String> headers;\n \n-  private Multimap<String, String> headers;\n-\n-  public Long offset() {\n-    return offset;\n-  }\n-\n-  public Long length() {\n-    return length;\n-  }\n-\n-  public long objectSize() {\n-    return objectSize;\n-  }\n-\n-  public String matchETag() {\n-    return matchETag;\n-  }\n-\n-  public String notMatchETag() {\n-    return notMatchETag;\n-  }\n-\n-  public ZonedDateTime modifiedSince() {\n-    return modifiedSince;\n-  }\n-\n-  public ZonedDateTime unmodifiedSince() {\n-    return unmodifiedSince;\n+  /** Create new ComposeSource for given bucket and object. */\n+  public ComposeSource(String bucketName, String objectName) throws IllegalArgumentException {\n+    this(bucketName, objectName, null, null, null, null, null);\n   }\n \n-  public Multimap<String, String> headers() {\n-    return headers;\n+  /** Create new ComposeSource for given bucket, object, offset and length. */\n+  public ComposeSource(String bucketName, String objectName, Long offset, Long length)\n+      throws IllegalArgumentException {\n+    this(bucketName, objectName, offset, length, null, null, null);\n   }\n \n-  public ServerSideEncryptionCustomerKey ssec() {\n-    return ssec;\n+  /** Create new ComposeSource for given bucket, object, offset, length and headerMap. */\n+  public ComposeSource(\n+      String bucketName, String objectName, Long offset, Long length, Map<String, String> headerMap)\n+      throws IllegalArgumentException {\n+    this(bucketName, objectName, offset, length, headerMap, null, null);\n   }\n \n-  public static Builder builder() {\n-    return new Builder();\n+  /**\n+   * Create new ComposeSource for given bucket, object, offset, length, headerMap and\n+   * CopyConditions.\n+   */\n+  public ComposeSource(\n+      String bucketName,\n+      String objectName,\n+      Long offset,\n+      Long length,\n+      Map<String, String> headerMap,\n+      CopyConditions copyConditions)\n+      throws IllegalArgumentException {\n+    this(bucketName, objectName, offset, length, headerMap, copyConditions, null);\n   }\n \n-  /** Constructs header . */\n-  public void buildHeaders(long objectSize, String etag) throws IllegalArgumentException {\n-    validateSize(objectSize);\n-    Multimap<String, String> headers = HashMultimap.create();\n-    headers.put(\"x-amz-copy-source\", S3Escaper.encodePath(bucketName + \"/\" + objectName));\n-    headers.put(\"x-amz-copy-source-if-match\", etag);\n-\n-    if (extraHeaders() != null) {\n-      headers.putAll(extraHeaders());\n+  /**\n+   * Creates new ComposeSource for given bucket, object, offset, length, headerMap, CopyConditions\n+   * and server side encryption.\n+   *\n+   * @throws IllegalArgumentException upon invalid value is passed to a method.\n+   */\n+  public ComposeSource(\n+      String bucketName,\n+      String objectName,\n+      Long offset,\n+      Long length,\n+      Map<String, String> headerMap,\n+      CopyConditions copyConditions,\n+      ServerSideEncryptionCustomerKey ssec)\n+      throws IllegalArgumentException {\n+    if (bucketName == null) {\n+      throw new IllegalArgumentException(\"Source bucket name cannot be empty\");\n     }\n \n-    if (matchETag != null) {\n-      headers.put(\"x-amz-copy-source-if-match\", matchETag);\n+    if (objectName == null) {\n+      throw new IllegalArgumentException(\"Source object name cannot be empty\");\n     }\n \n-    if (ssec != null) {\n-      headers.putAll(Multimaps.forMap(ssec.copySourceHeaders()));\n+    if (offset != null && offset < 0) {\n+      throw new IllegalArgumentException(\"Offset cannot be negative\");\n     }\n \n-    if (notMatchETag != null) {\n-      headers.put(\"x-amz-copy-source-if-none-match\", notMatchETag);\n+    if (length != null && length < 0) {\n+      throw new IllegalArgumentException(\"Length cannot be negative\");\n     }\n \n-    if (modifiedSince != null) {\n-      headers.put(\n-          \"x-amz-copy-source-if-modified-since\",\n-          modifiedSince.format(Time.HTTP_HEADER_DATE_FORMAT));\n+    if (length != null && offset == null) {\n+      offset = 0L;\n     }\n \n-    if (unmodifiedSince != null) {\n-      headers.put(\n-          \"x-amz-copy-source-if-unmodified-since\",\n-          unmodifiedSince.format(Time.HTTP_HEADER_DATE_FORMAT));\n+    this.bucketName = bucketName;\n+    this.objectName = objectName;\n+    this.offset = offset;\n+    this.length = length;\n+    if (headerMap != null) {\n+      this.headerMap = Collections.unmodifiableMap(headerMap);\n+    } else {\n+      this.headerMap = null;\n     }\n-\n-    this.objectSize = objectSize;\n-    this.headers = headers;\n+    this.copyConditions = copyConditions;\n+    this.ssec = ssec;\n   }\n \n-  private void validateSize(long objectSize) throws IllegalArgumentException {\n+  /** Constructs header . */\n+  public void buildHeaders(long objectSize, String etag) throws IllegalArgumentException {\n     if (offset != null && offset >= objectSize) {\n       throw new IllegalArgumentException(\n           \"source \"\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzNzMzNw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r441937337", "bodyText": "This is CompleteMultipartUpload behaviour i.e. Error is returned with 200 OK. Here, you need to do XML parsing for CopyObjectResult", "author": "balamurugana", "createdAt": "2020-06-18T02:45:20Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2499,8 +2499,42 @@ public void copyObject(CopyObjectArgs args)\n             null,\n             null,\n             0)) {\n-      // For now ignore the copyObjectResult, just read and parse it.\n-      Xml.unmarshal(CopyObjectResult.class, response.body().charStream());\n+\n+      String bodyContent = new String(response.body().bytes(), StandardCharsets.UTF_8);\n+      bodyContent = bodyContent.trim();\n+      if (!bodyContent.isEmpty()) {\n+        try {\n+          if (Xml.validate(ErrorResponse.class, bodyContent)) {\n+            ErrorResponse errorResponse = Xml.unmarshal(ErrorResponse.class, bodyContent);\n+            throw new ErrorResponseException(errorResponse, response);\n+          }\n+        } catch (XmlParserException e) {\n+          // As it is not <Error> message, fall-back to parse CopyObjectResult XML.", "originalCommit": "31168c12e1dd9a69237286aff08da5705db50d8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 26be18c4..a125509d 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2499,42 +2501,8 @@ public class MinioClient {\n             null,\n             null,\n             0)) {\n-\n-      String bodyContent = new String(response.body().bytes(), StandardCharsets.UTF_8);\n-      bodyContent = bodyContent.trim();\n-      if (!bodyContent.isEmpty()) {\n-        try {\n-          if (Xml.validate(ErrorResponse.class, bodyContent)) {\n-            ErrorResponse errorResponse = Xml.unmarshal(ErrorResponse.class, bodyContent);\n-            throw new ErrorResponseException(errorResponse, response);\n-          }\n-        } catch (XmlParserException e) {\n-          // As it is not <Error> message, fall-back to parse CopyObjectResult XML.\n-        }\n-\n-        try {\n-          CopyObjectResult result = Xml.unmarshal(CopyObjectResult.class, bodyContent);\n-          return new ObjectWriteResponse(\n-              response.headers(),\n-              args.bucket(),\n-              getRegion(args.bucket()),\n-              args.object(),\n-              result.etag(),\n-              response.header(\"x-amz-version-id\"));\n-        } catch (XmlParserException e) {\n-          // As this CopyObjectResult REST call succeeded, just log it.\n-          Logger.getLogger(MinioClient.class.getName())\n-              .warning(\n-                  \"S3 service returned unknown XML for CopyObjectResult REST API. \" + bodyContent);\n-        }\n-      }\n-      return new ObjectWriteResponse(\n-          response.headers(),\n-          args.bucket(),\n-          getRegion(args.bucket()),\n-          args.object(),\n-          null,\n-          response.header(\"x-amz-version-id\"));\n+      // For now ignore the copyObjectResult, just read and parse it.\n+      Xml.unmarshal(CopyObjectResult.class, response.body().charStream());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzNzUxMw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r441937513", "bodyText": "You need to pass ``args.region()` here.", "author": "balamurugana", "createdAt": "2020-06-18T02:45:57Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2499,8 +2499,42 @@ public void copyObject(CopyObjectArgs args)\n             null,\n             null,\n             0)) {\n-      // For now ignore the copyObjectResult, just read and parse it.\n-      Xml.unmarshal(CopyObjectResult.class, response.body().charStream());\n+\n+      String bodyContent = new String(response.body().bytes(), StandardCharsets.UTF_8);\n+      bodyContent = bodyContent.trim();\n+      if (!bodyContent.isEmpty()) {\n+        try {\n+          if (Xml.validate(ErrorResponse.class, bodyContent)) {\n+            ErrorResponse errorResponse = Xml.unmarshal(ErrorResponse.class, bodyContent);\n+            throw new ErrorResponseException(errorResponse, response);\n+          }\n+        } catch (XmlParserException e) {\n+          // As it is not <Error> message, fall-back to parse CopyObjectResult XML.\n+        }\n+\n+        try {\n+          CopyObjectResult result = Xml.unmarshal(CopyObjectResult.class, bodyContent);\n+          return new ObjectWriteResponse(\n+              response.headers(),\n+              args.bucket(),\n+              getRegion(args.bucket()),", "originalCommit": "31168c12e1dd9a69237286aff08da5705db50d8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 26be18c4..a125509d 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2499,42 +2501,8 @@ public class MinioClient {\n             null,\n             null,\n             0)) {\n-\n-      String bodyContent = new String(response.body().bytes(), StandardCharsets.UTF_8);\n-      bodyContent = bodyContent.trim();\n-      if (!bodyContent.isEmpty()) {\n-        try {\n-          if (Xml.validate(ErrorResponse.class, bodyContent)) {\n-            ErrorResponse errorResponse = Xml.unmarshal(ErrorResponse.class, bodyContent);\n-            throw new ErrorResponseException(errorResponse, response);\n-          }\n-        } catch (XmlParserException e) {\n-          // As it is not <Error> message, fall-back to parse CopyObjectResult XML.\n-        }\n-\n-        try {\n-          CopyObjectResult result = Xml.unmarshal(CopyObjectResult.class, bodyContent);\n-          return new ObjectWriteResponse(\n-              response.headers(),\n-              args.bucket(),\n-              getRegion(args.bucket()),\n-              args.object(),\n-              result.etag(),\n-              response.header(\"x-amz-version-id\"));\n-        } catch (XmlParserException e) {\n-          // As this CopyObjectResult REST call succeeded, just log it.\n-          Logger.getLogger(MinioClient.class.getName())\n-              .warning(\n-                  \"S3 service returned unknown XML for CopyObjectResult REST API. \" + bodyContent);\n-        }\n-      }\n-      return new ObjectWriteResponse(\n-          response.headers(),\n-          args.bucket(),\n-          getRegion(args.bucket()),\n-          args.object(),\n-          null,\n-          response.header(\"x-amz-version-id\"));\n+      // For now ignore the copyObjectResult, just read and parse it.\n+      Xml.unmarshal(CopyObjectResult.class, response.body().charStream());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzODMzOA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r441938338", "bodyText": "ObjectWriteArgs comes with headers and userMetadata. You would need to avoid extraHeaders and extraQueryParams usage unless required in examples and references.", "author": "balamurugana", "createdAt": "2020-06-18T02:49:12Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2555,29 +2591,104 @@ public void composeObject(\n           InternalException, InvalidBucketNameException, InvalidKeyException,\n           InvalidResponseException, IOException, NoSuchAlgorithmException, ServerException,\n           XmlParserException {\n-    if ((bucketName == null) || (bucketName.isEmpty())) {\n-      throw new IllegalArgumentException(\"bucket name cannot be empty\");\n-    }\n \n-    checkObjectName(objectName);\n+    ComposeObjectArgs.Builder builder =\n+        ComposeObjectArgs.builder()\n+            .bucket(bucketName)\n+            .object(objectName)\n+            .extraHeaders(Multimaps.forMap(headerMap))\n+            .sources(sources)\n+            .sse(sse);\n \n-    if (sources.isEmpty()) {\n-      throw new IllegalArgumentException(\"compose sources cannot be empty\");\n-    }\n+    composeObject(builder.build());\n+  }\n \n-    checkWriteRequestSse(sse);\n+  /**\n+   * Creates an object by combining data from different source objects using server-side copy.\n+   *\n+   * <pre>Example:{@code\n+   * List<ComposeSource> sourceObjectList = new ArrayList<ComposeSource>();\n+   *\n+   * sourceObjectList.add(\n+   *    ComposeSource.builder().bucket(\"my-job-bucket\").object(\"my-objectname-part-one\").build());\n+   * sourceObjectList.add(\n+   *    ComposeSource.builder().bucket(\"my-job-bucket\").object(\"my-objectname-part-two\").build());\n+   * sourceObjectList.add(\n+   *    ComposeSource.builder().bucket(\"my-job-bucket\").object(\"my-objectname-part-three\").build());\n+   *\n+   * // Create my-bucketname/my-objectname by combining source object list.\n+   * minioClient.composeObject(\n+   *    ComposeObjectArgs.builder()\n+   *        .bucket(\"my-bucketname\")\n+   *        .object(\"my-objectname\")\n+   *        .sources(sourceObjectList)\n+   *        .build());\n+   *\n+   * // Create my-bucketname/my-objectname with user metadata by combining source object\n+   * // list.\n+   * minioClient.composeObject(\n+   *     ComposeObjectArgs.builder()\n+   *        .bucket(\"my-bucketname\")\n+   *        .object(\"my-objectname\")\n+   *        .sources(sourceObjectList)\n+   *        .extraHeaders(Multimaps.forMap(userMetadata))\n+   *        .build());\n+   *\n+   * // Create my-bucketname/my-objectname with user metadata and server-side encryption\n+   * // by combining source object list.\n+   * minioClient.composeObject(\n+   *   ComposeObjectArgs.builder()\n+   *        .bucket(\"my-bucketname\")\n+   *        .object(\"my-objectname\")\n+   *        .sources(sourceObjectList)\n+   *        .extraHeaders(Multimaps.forMap(userMetadata))", "originalCommit": "31168c12e1dd9a69237286aff08da5705db50d8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 26be18c4..a125509d 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2591,16 +2559,202 @@ public class MinioClient {\n           InternalException, InvalidBucketNameException, InvalidKeyException,\n           InvalidResponseException, IOException, NoSuchAlgorithmException, ServerException,\n           XmlParserException {\n+    if ((bucketName == null) || (bucketName.isEmpty())) {\n+      throw new IllegalArgumentException(\"bucket name cannot be empty\");\n+    }\n \n-    ComposeObjectArgs.Builder builder =\n-        ComposeObjectArgs.builder()\n-            .bucket(bucketName)\n-            .object(objectName)\n-            .extraHeaders(Multimaps.forMap(headerMap))\n-            .sources(sources)\n-            .sse(sse);\n+    checkObjectName(objectName);\n+\n+    if (sources.isEmpty()) {\n+      throw new IllegalArgumentException(\"compose sources cannot be empty\");\n+    }\n+\n+    checkWriteRequestSse(sse);\n+\n+    long objectSize = 0;\n+    int partsCount = 0;\n+    for (int i = 0; i < sources.size(); i++) {\n+      ComposeSource src = sources.get(i);\n+\n+      checkReadRequestSse(src.ssec());\n+\n+      ObjectStat stat = statObject(src.bucketName(), src.objectName(), src.ssec());\n+      src.buildHeaders(stat.length(), stat.etag());\n+\n+      if (i != 0 && src.headers().containsKey(\"x-amz-meta-x-amz-key\")) {\n+        throw new IllegalArgumentException(\n+            \"Client side encryption is not supported for more than one source\");\n+      }\n+\n+      long size = stat.length();\n+      if (src.length() != null) {\n+        size = src.length();\n+      } else if (src.offset() != null) {\n+        size -= src.offset();\n+      }\n+\n+      if (size < ObjectWriteArgs.MIN_MULTIPART_SIZE\n+          && sources.size() != 1\n+          && i != (sources.size() - 1)) {\n+        throw new IllegalArgumentException(\n+            \"source \"\n+                + src.bucketName()\n+                + \"/\"\n+                + src.objectName()\n+                + \": size \"\n+                + size\n+                + \" must be greater than \"\n+                + ObjectWriteArgs.MIN_MULTIPART_SIZE);\n+      }\n+\n+      objectSize += size;\n+      if (objectSize > ObjectWriteArgs.MAX_OBJECT_SIZE) {\n+        throw new IllegalArgumentException(\n+            \"Destination object size must be less than \" + ObjectWriteArgs.MAX_OBJECT_SIZE);\n+      }\n+\n+      if (size > ObjectWriteArgs.MAX_PART_SIZE) {\n+        long count = size / ObjectWriteArgs.MAX_PART_SIZE;\n+        long lastPartSize = size - (count * ObjectWriteArgs.MAX_PART_SIZE);\n+        if (lastPartSize > 0) {\n+          count++;\n+        } else {\n+          lastPartSize = ObjectWriteArgs.MAX_PART_SIZE;\n+        }\n+\n+        if (lastPartSize < ObjectWriteArgs.MIN_MULTIPART_SIZE\n+            && sources.size() != 1\n+            && i != (sources.size() - 1)) {\n+          throw new IllegalArgumentException(\n+              \"source \"\n+                  + src.bucketName()\n+                  + \"/\"\n+                  + src.objectName()\n+                  + \": \"\n+                  + \"for multipart split upload of \"\n+                  + size\n+                  + \", last part size is less than \"\n+                  + ObjectWriteArgs.MIN_MULTIPART_SIZE);\n+        }\n+\n+        partsCount += (int) count;\n+      } else {\n+        partsCount++;\n+      }\n+\n+      if (partsCount > ObjectWriteArgs.MAX_MULTIPART_COUNT) {\n+        throw new IllegalArgumentException(\n+            \"Compose sources create more than allowed multipart count \"\n+                + ObjectWriteArgs.MAX_MULTIPART_COUNT);\n+      }\n+    }\n+\n+    if (partsCount == 1) {\n+      ComposeSource src = sources.get(0);\n+      if (headerMap == null) {\n+        headerMap = new HashMap<>();\n+      }\n+      if ((src.offset() != null) && (src.length() == null)) {\n+        headerMap.put(\"x-amz-copy-source-range\", \"bytes=\" + src.offset() + \"-\");\n+      }\n+\n+      if ((src.offset() != null) && (src.length() != null)) {\n+        headerMap.put(\n+            \"x-amz-copy-source-range\",\n+            \"bytes=\" + src.offset() + \"-\" + (src.offset() + src.length() - 1));\n+      }\n+      copyObject(\n+          bucketName,\n+          objectName,\n+          headerMap,\n+          sse,\n+          src.bucketName(),\n+          src.objectName(),\n+          src.ssec(),\n+          src.copyConditions());\n+      return;\n+    }\n+\n+    Map<String, String> sseHeaders = null;\n+    if (sse != null) {\n+      sseHeaders = sse.headers();\n+      if (headerMap == null) {\n+        headerMap = new HashMap<>();\n+      }\n+      headerMap.putAll(sseHeaders);\n+    }\n+\n+    String uploadId = createMultipartUpload(bucketName, objectName, headerMap);\n+\n+    int partNumber = 0;\n+    Part[] totalParts = new Part[partsCount];\n+    try {\n+      for (int i = 0; i < sources.size(); i++) {\n+        ComposeSource src = sources.get(i);\n+\n+        long size = src.objectSize();\n+        if (src.length() != null) {\n+          size = src.length();\n+        } else if (src.offset() != null) {\n+          size -= src.offset();\n+        }\n+        long offset = 0;\n+        if (src.offset() != null) {\n+          offset = src.offset();\n+        }\n \n-    composeObject(builder.build());\n+        if (size <= ObjectWriteArgs.MAX_PART_SIZE) {\n+          partNumber++;\n+          Map<String, String> headers = new HashMap<>();\n+          if (src.headers() != null) {\n+            headers.putAll(src.headers());\n+          }\n+          if (src.length() != null) {\n+            headers.put(\n+                \"x-amz-copy-source-range\", \"bytes=\" + offset + \"-\" + (offset + src.length() - 1));\n+          } else if (src.offset() != null) {\n+            headers.put(\"x-amz-copy-source-range\", \"bytes=\" + offset + \"-\" + (offset + size - 1));\n+          }\n+          if (sseHeaders != null) {\n+            headers.putAll(sseHeaders);\n+          }\n+          String eTag = uploadPartCopy(bucketName, objectName, uploadId, partNumber, headers);\n+\n+          totalParts[partNumber - 1] = new Part(partNumber, eTag);\n+          continue;\n+        }\n+\n+        while (size > 0) {\n+          partNumber++;\n+\n+          long startBytes = offset;\n+          long endBytes = startBytes + ObjectWriteArgs.MAX_PART_SIZE;\n+          if (size < ObjectWriteArgs.MAX_PART_SIZE) {\n+            endBytes = startBytes + size;\n+          }\n+\n+          Map<String, String> headers = src.headers();\n+          headers.put(\"x-amz-copy-source-range\", \"bytes=\" + startBytes + \"-\" + endBytes);\n+          if (sseHeaders != null) {\n+            headers.putAll(sseHeaders);\n+          }\n+          String eTag = uploadPartCopy(bucketName, objectName, uploadId, partNumber, headers);\n+\n+          totalParts[partNumber - 1] = new Part(partNumber, eTag);\n+\n+          offset = startBytes;\n+          size -= (endBytes - startBytes);\n+        }\n+      }\n+\n+      completeMultipartUpload(bucketName, objectName, uploadId, totalParts);\n+    } catch (RuntimeException e) {\n+      abortMultipartUpload(bucketName, objectName, uploadId);\n+      throw e;\n+    } catch (Exception e) {\n+      abortMultipartUpload(bucketName, objectName, uploadId);\n+      throw e;\n+    }\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzODYxMw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r441938613", "bodyText": "You would need to use these constants from ObjectWriteArgs", "author": "balamurugana", "createdAt": "2020-06-18T02:50:17Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2589,105 +2700,111 @@ public void composeObject(\n         size -= src.offset();\n       }\n \n-      if (size < ObjectWriteArgs.MIN_MULTIPART_SIZE\n+      if (size < PutObjectOptions.MIN_MULTIPART_SIZE\n           && sources.size() != 1\n           && i != (sources.size() - 1)) {\n         throw new IllegalArgumentException(\n             \"source \"\n-                + src.bucketName()\n+                + src.bucket()\n                 + \"/\"\n-                + src.objectName()\n+                + src.object()\n                 + \": size \"\n                 + size\n                 + \" must be greater than \"\n-                + ObjectWriteArgs.MIN_MULTIPART_SIZE);\n+                + PutObjectOptions.MIN_MULTIPART_SIZE);\n       }\n \n       objectSize += size;\n-      if (objectSize > ObjectWriteArgs.MAX_OBJECT_SIZE) {\n+      if (objectSize > PutObjectOptions.MAX_OBJECT_SIZE) {\n         throw new IllegalArgumentException(\n-            \"Destination object size must be less than \" + ObjectWriteArgs.MAX_OBJECT_SIZE);\n+            \"Destination object size must be less than \" + PutObjectOptions.MAX_OBJECT_SIZE);\n       }\n \n-      if (size > ObjectWriteArgs.MAX_PART_SIZE) {\n-        long count = size / ObjectWriteArgs.MAX_PART_SIZE;\n-        long lastPartSize = size - (count * ObjectWriteArgs.MAX_PART_SIZE);\n+      if (size > PutObjectOptions.MAX_PART_SIZE) {", "originalCommit": "31168c12e1dd9a69237286aff08da5705db50d8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 26be18c4..a125509d 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2694,10 +2827,10 @@ public class MinioClient {\n       }\n \n       long size = stat.length();\n-      if (src.length() != null) {\n-        size = src.length();\n-      } else if (src.offset() != null) {\n-        size -= src.offset();\n+      if (src.srcLength() != null) {\n+        size = src.srcLength();\n+      } else if (src.srcOffset() != null) {\n+        size -= src.srcOffset();\n       }\n \n       if (size < PutObjectOptions.MIN_MULTIPART_SIZE\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzODkxOA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r441938918", "bodyText": "extraHeaders and extraQueryParams are always non-null. You would need to use them directly.", "author": "balamurugana", "createdAt": "2020-06-18T02:51:22Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2589,105 +2700,111 @@ public void composeObject(\n         size -= src.offset();\n       }\n \n-      if (size < ObjectWriteArgs.MIN_MULTIPART_SIZE\n+      if (size < PutObjectOptions.MIN_MULTIPART_SIZE\n           && sources.size() != 1\n           && i != (sources.size() - 1)) {\n         throw new IllegalArgumentException(\n             \"source \"\n-                + src.bucketName()\n+                + src.bucket()\n                 + \"/\"\n-                + src.objectName()\n+                + src.object()\n                 + \": size \"\n                 + size\n                 + \" must be greater than \"\n-                + ObjectWriteArgs.MIN_MULTIPART_SIZE);\n+                + PutObjectOptions.MIN_MULTIPART_SIZE);\n       }\n \n       objectSize += size;\n-      if (objectSize > ObjectWriteArgs.MAX_OBJECT_SIZE) {\n+      if (objectSize > PutObjectOptions.MAX_OBJECT_SIZE) {\n         throw new IllegalArgumentException(\n-            \"Destination object size must be less than \" + ObjectWriteArgs.MAX_OBJECT_SIZE);\n+            \"Destination object size must be less than \" + PutObjectOptions.MAX_OBJECT_SIZE);\n       }\n \n-      if (size > ObjectWriteArgs.MAX_PART_SIZE) {\n-        long count = size / ObjectWriteArgs.MAX_PART_SIZE;\n-        long lastPartSize = size - (count * ObjectWriteArgs.MAX_PART_SIZE);\n+      if (size > PutObjectOptions.MAX_PART_SIZE) {\n+        long count = size / PutObjectOptions.MAX_PART_SIZE;\n+        long lastPartSize = size - (count * PutObjectOptions.MAX_PART_SIZE);\n         if (lastPartSize > 0) {\n           count++;\n         } else {\n-          lastPartSize = ObjectWriteArgs.MAX_PART_SIZE;\n+          lastPartSize = PutObjectOptions.MAX_PART_SIZE;\n         }\n \n-        if (lastPartSize < ObjectWriteArgs.MIN_MULTIPART_SIZE\n+        if (lastPartSize < PutObjectOptions.MIN_MULTIPART_SIZE\n             && sources.size() != 1\n             && i != (sources.size() - 1)) {\n           throw new IllegalArgumentException(\n               \"source \"\n-                  + src.bucketName()\n+                  + src.bucket()\n                   + \"/\"\n-                  + src.objectName()\n+                  + src.object()\n                   + \": \"\n                   + \"for multipart split upload of \"\n                   + size\n                   + \", last part size is less than \"\n-                  + ObjectWriteArgs.MIN_MULTIPART_SIZE);\n+                  + PutObjectOptions.MIN_MULTIPART_SIZE);\n         }\n \n         partsCount += (int) count;\n       } else {\n         partsCount++;\n       }\n \n-      if (partsCount > ObjectWriteArgs.MAX_MULTIPART_COUNT) {\n+      if (partsCount > PutObjectOptions.MAX_MULTIPART_COUNT) {\n         throw new IllegalArgumentException(\n             \"Compose sources create more than allowed multipart count \"\n-                + ObjectWriteArgs.MAX_MULTIPART_COUNT);\n+                + PutObjectOptions.MAX_MULTIPART_COUNT);\n       }\n     }\n \n     if (partsCount == 1) {\n       ComposeSource src = sources.get(0);\n-      if (headerMap == null) {\n-        headerMap = new HashMap<>();\n+      Multimap<String, String> headers = HashMultimap.create();\n+      if (args.extraHeaders() != null) {", "originalCommit": "31168c12e1dd9a69237286aff08da5705db50d8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 26be18c4..a125509d 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2694,10 +2827,10 @@ public class MinioClient {\n       }\n \n       long size = stat.length();\n-      if (src.length() != null) {\n-        size = src.length();\n-      } else if (src.offset() != null) {\n-        size -= src.offset();\n+      if (src.srcLength() != null) {\n+        size = src.srcLength();\n+      } else if (src.srcOffset() != null) {\n+        size -= src.srcOffset();\n       }\n \n       if (size < PutObjectOptions.MIN_MULTIPART_SIZE\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzOTQ2Nw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r441939467", "bodyText": "We should deprecate this method and use other one.", "author": "balamurugana", "createdAt": "2020-06-18T02:53:33Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -7515,17 +7643,16 @@ protected ObjectWriteResponse completeMultipartUpload(\n    * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n    * @throws XmlParserException thrown to indicate XML parsing error.\n    */\n-  @Deprecated", "originalCommit": "31168c12e1dd9a69237286aff08da5705db50d8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 26be18c4..a125509d 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -7643,6 +7844,7 @@ public class MinioClient {\n    * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n    * @throws XmlParserException thrown to indicate XML parsing error.\n    */\n+  @Deprecated\n   protected String createMultipartUpload(\n       String bucketName, String objectName, Map<String, String> headerMap)\n       throws InvalidBucketNameException, IllegalArgumentException, NoSuchAlgorithmException,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzOTk5NA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r441939994", "bodyText": "Use String[] files. I prefer filenames instread of files", "author": "balamurugana", "createdAt": "2020-06-18T02:55:43Z", "path": "functional/FunctionalTest.java", "diffHunk": "@@ -421,6 +422,13 @@ private static void handleException(String methodName, String args, long startTi\n     throw e;\n   }\n \n+  private static void deleteFilesAndObjects(String bucketName, String files[]) throws Exception {", "originalCommit": "31168c12e1dd9a69237286aff08da5705db50d8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1b5f96f5de48145521966124ab0f0291fca0e368", "chunk": "diff --git a/functional/FunctionalTest.java b/functional/FunctionalTest.java\nindex 592b1c4f..21cb3e60 100644\n--- a/functional/FunctionalTest.java\n+++ b/functional/FunctionalTest.java\n\n@@ -422,10 +423,31 @@ public class FunctionalTest {\n     throw e;\n   }\n \n-  private static void deleteFilesAndObjects(String bucketName, String files[]) throws Exception {\n-    for (String filename : files) {\n+  // private static void deleteFilesAndObjects(String bucketName, String[] filenames) throws\n+  // Exception {\n+  //   for (String filename : filenames) {\n+  //     Files.delete(Paths.get(filename));\n+  //\n+  // client.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(filename).build());\n+  //   }\n+  // }\n+\n+  private static void deleteFilesAndObjects(String bucketName, String[] filenames)\n+      throws Exception {\n+    for (String filename : filenames) {\n       Files.delete(Paths.get(filename));\n-      client.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(filename).build());\n+    }\n+    List<DeleteObject> objects =\n+        Arrays.stream(filenames)\n+            .map(\n+                name -> {\n+                  return new DeleteObject(name);\n+                })\n+            .collect(Collectors.toList());\n+    for (Result<?> r :\n+        client.removeObjects(\n+            RemoveObjectsArgs.builder().bucket(bucketName).objects(objects).build())) {\n+      ignore(r.get());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk0MDUwNg==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r441940506", "bodyText": "This method is not necessary. you could use removeObjects() then this for", "author": "balamurugana", "createdAt": "2020-06-18T02:57:44Z", "path": "functional/FunctionalTest.java", "diffHunk": "@@ -421,6 +422,13 @@ private static void handleException(String methodName, String args, long startTi\n     throw e;\n   }\n \n+  private static void deleteFilesAndObjects(String bucketName, String files[]) throws Exception {\n+    for (String filename : files) {\n+      Files.delete(Paths.get(filename));\n+      client.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(filename).build());", "originalCommit": "31168c12e1dd9a69237286aff08da5705db50d8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMyMjU3MQ==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r442322571", "bodyText": "This method is used to make the functional Test less verbose as the same code was repeating  6 composeObject test . I have used removeObjects now.", "author": "sinhaashish", "createdAt": "2020-06-18T15:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk0MDUwNg=="}], "type": "inlineReview", "revised_code": {"commit": "1b5f96f5de48145521966124ab0f0291fca0e368", "chunk": "diff --git a/functional/FunctionalTest.java b/functional/FunctionalTest.java\nindex 592b1c4f..21cb3e60 100644\n--- a/functional/FunctionalTest.java\n+++ b/functional/FunctionalTest.java\n\n@@ -422,10 +423,31 @@ public class FunctionalTest {\n     throw e;\n   }\n \n-  private static void deleteFilesAndObjects(String bucketName, String files[]) throws Exception {\n-    for (String filename : files) {\n+  // private static void deleteFilesAndObjects(String bucketName, String[] filenames) throws\n+  // Exception {\n+  //   for (String filename : filenames) {\n+  //     Files.delete(Paths.get(filename));\n+  //\n+  // client.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(filename).build());\n+  //   }\n+  // }\n+\n+  private static void deleteFilesAndObjects(String bucketName, String[] filenames)\n+      throws Exception {\n+    for (String filename : filenames) {\n       Files.delete(Paths.get(filename));\n-      client.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(filename).build());\n+    }\n+    List<DeleteObject> objects =\n+        Arrays.stream(filenames)\n+            .map(\n+                name -> {\n+                  return new DeleteObject(name);\n+                })\n+            .collect(Collectors.toList());\n+    for (Result<?> r :\n+        client.removeObjects(\n+            RemoveObjectsArgs.builder().bucket(bucketName).objects(objects).build())) {\n+      ignore(r.get());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYyMzQyMA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r442623420", "bodyText": "Sources should not be null or empty.", "author": "balamurugana", "createdAt": "2020-06-19T04:23:44Z", "path": "api/src/main/java/io/minio/ComposeObjectArgs.java", "diffHunk": "@@ -43,7 +43,7 @@ public Builder sources(List<ComposeSource> sources) {\n     }\n \n     private void validateSources(List<ComposeSource> sources) {\n-      if (sources.isEmpty()) {\n+      if (sources == null) {", "originalCommit": "99b7354724fb6d660dfb738ca2142c1201da039b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/api/src/main/java/io/minio/ComposeObjectArgs.java b/api/src/main/java/io/minio/ComposeObjectArgs.java\nindex 14fbf4d6..9f53b396 100644\n--- a/api/src/main/java/io/minio/ComposeObjectArgs.java\n+++ b/api/src/main/java/io/minio/ComposeObjectArgs.java\n\n@@ -30,20 +30,14 @@ public class ComposeObjectArgs extends ObjectWriteArgs {\n   }\n \n   public static final class Builder extends ObjectWriteArgs.Builder<Builder, ComposeObjectArgs> {\n-    @Override\n-    protected void validate(ComposeObjectArgs args) {\n-      super.validate(args);\n-      validateSources(args.sources);\n-    }\n-\n-    public Builder sources(List<ComposeSource> sources) {\n+    public Builder sources(List<ComposeSourceArgs> sources) {\n       validateSources(sources);\n       operations.add(args -> args.sources = sources);\n       return this;\n     }\n \n-    private void validateSources(List<ComposeSource> sources) {\n-      if (sources == null) {\n+    private void validateSources(List<ComposeSourceArgs> sources) {\n+      if (sources.isEmpty()) {\n         throw new IllegalArgumentException(\"compose sources cannot be empty\");\n       }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYyNTQwNg==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r442625406", "bodyText": "Why can't it be just  Xml.unmarshal(CopyObjectResult.class, response.body().charStream()); ? There is no need to read the body to a string and parse it later.", "author": "balamurugana", "createdAt": "2020-06-19T04:32:40Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2499,8 +2499,33 @@ public void copyObject(CopyObjectArgs args)\n             null,\n             null,\n             0)) {\n-      // For now ignore the copyObjectResult, just read and parse it.\n-      Xml.unmarshal(CopyObjectResult.class, response.body().charStream());\n+\n+      String bodyContent = new String(response.body().bytes(), StandardCharsets.UTF_8);", "originalCommit": "99b7354724fb6d660dfb738ca2142c1201da039b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 02b7cece..a125509d 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2499,33 +2501,8 @@ public class MinioClient {\n             null,\n             null,\n             0)) {\n-\n-      String bodyContent = new String(response.body().bytes(), StandardCharsets.UTF_8);\n-      bodyContent = bodyContent.trim();\n-      if (!bodyContent.isEmpty()) {\n-        try {\n-          CopyObjectResult result = Xml.unmarshal(CopyObjectResult.class, bodyContent);\n-          return new ObjectWriteResponse(\n-              response.headers(),\n-              args.bucket(),\n-              args.region(),\n-              args.object(),\n-              result.etag(),\n-              response.header(\"x-amz-version-id\"));\n-        } catch (XmlParserException e) {\n-          // As this CopyObjectResult REST call succeeded, just log it.\n-          Logger.getLogger(MinioClient.class.getName())\n-              .warning(\n-                  \"S3 service returned unknown XML for CopyObjectResult REST API. \" + bodyContent);\n-        }\n-      }\n-      return new ObjectWriteResponse(\n-          response.headers(),\n-          args.bucket(),\n-          getRegion(args.bucket()),\n-          args.object(),\n-          null,\n-          response.header(\"x-amz-version-id\"));\n+      // For now ignore the copyObjectResult, just read and parse it.\n+      Xml.unmarshal(CopyObjectResult.class, response.body().charStream());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYyNTU4OA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r442625588", "bodyText": "Do not call getRegion() for ObjectWriteResponse. You need to use args.region(). This is applicable everywhere.", "author": "balamurugana", "createdAt": "2020-06-19T04:33:39Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2499,8 +2499,33 @@ public void copyObject(CopyObjectArgs args)\n             null,\n             null,\n             0)) {\n-      // For now ignore the copyObjectResult, just read and parse it.\n-      Xml.unmarshal(CopyObjectResult.class, response.body().charStream());\n+\n+      String bodyContent = new String(response.body().bytes(), StandardCharsets.UTF_8);\n+      bodyContent = bodyContent.trim();\n+      if (!bodyContent.isEmpty()) {\n+        try {\n+          CopyObjectResult result = Xml.unmarshal(CopyObjectResult.class, bodyContent);\n+          return new ObjectWriteResponse(\n+              response.headers(),\n+              args.bucket(),\n+              args.region(),\n+              args.object(),\n+              result.etag(),\n+              response.header(\"x-amz-version-id\"));\n+        } catch (XmlParserException e) {\n+          // As this CopyObjectResult REST call succeeded, just log it.\n+          Logger.getLogger(MinioClient.class.getName())\n+              .warning(\n+                  \"S3 service returned unknown XML for CopyObjectResult REST API. \" + bodyContent);\n+        }\n+      }\n+      return new ObjectWriteResponse(\n+          response.headers(),\n+          args.bucket(),\n+          getRegion(args.bucket()),", "originalCommit": "99b7354724fb6d660dfb738ca2142c1201da039b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 02b7cece..a125509d 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2499,33 +2501,8 @@ public class MinioClient {\n             null,\n             null,\n             0)) {\n-\n-      String bodyContent = new String(response.body().bytes(), StandardCharsets.UTF_8);\n-      bodyContent = bodyContent.trim();\n-      if (!bodyContent.isEmpty()) {\n-        try {\n-          CopyObjectResult result = Xml.unmarshal(CopyObjectResult.class, bodyContent);\n-          return new ObjectWriteResponse(\n-              response.headers(),\n-              args.bucket(),\n-              args.region(),\n-              args.object(),\n-              result.etag(),\n-              response.header(\"x-amz-version-id\"));\n-        } catch (XmlParserException e) {\n-          // As this CopyObjectResult REST call succeeded, just log it.\n-          Logger.getLogger(MinioClient.class.getName())\n-              .warning(\n-                  \"S3 service returned unknown XML for CopyObjectResult REST API. \" + bodyContent);\n-        }\n-      }\n-      return new ObjectWriteResponse(\n-          response.headers(),\n-          args.bucket(),\n-          getRegion(args.bucket()),\n-          args.object(),\n-          null,\n-          response.header(\"x-amz-version-id\"));\n+      // For now ignore the copyObjectResult, just read and parse it.\n+      Xml.unmarshal(CopyObjectResult.class, response.body().charStream());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYyNTY5OQ==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r442625699", "bodyText": "Why not setting etag?", "author": "balamurugana", "createdAt": "2020-06-19T04:34:07Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2499,8 +2499,33 @@ public void copyObject(CopyObjectArgs args)\n             null,\n             null,\n             0)) {\n-      // For now ignore the copyObjectResult, just read and parse it.\n-      Xml.unmarshal(CopyObjectResult.class, response.body().charStream());\n+\n+      String bodyContent = new String(response.body().bytes(), StandardCharsets.UTF_8);\n+      bodyContent = bodyContent.trim();\n+      if (!bodyContent.isEmpty()) {\n+        try {\n+          CopyObjectResult result = Xml.unmarshal(CopyObjectResult.class, bodyContent);\n+          return new ObjectWriteResponse(\n+              response.headers(),\n+              args.bucket(),\n+              args.region(),\n+              args.object(),\n+              result.etag(),\n+              response.header(\"x-amz-version-id\"));\n+        } catch (XmlParserException e) {\n+          // As this CopyObjectResult REST call succeeded, just log it.\n+          Logger.getLogger(MinioClient.class.getName())\n+              .warning(\n+                  \"S3 service returned unknown XML for CopyObjectResult REST API. \" + bodyContent);\n+        }\n+      }\n+      return new ObjectWriteResponse(\n+          response.headers(),\n+          args.bucket(),\n+          getRegion(args.bucket()),\n+          args.object(),\n+          null,", "originalCommit": "99b7354724fb6d660dfb738ca2142c1201da039b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 02b7cece..a125509d 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2499,33 +2501,8 @@ public class MinioClient {\n             null,\n             null,\n             0)) {\n-\n-      String bodyContent = new String(response.body().bytes(), StandardCharsets.UTF_8);\n-      bodyContent = bodyContent.trim();\n-      if (!bodyContent.isEmpty()) {\n-        try {\n-          CopyObjectResult result = Xml.unmarshal(CopyObjectResult.class, bodyContent);\n-          return new ObjectWriteResponse(\n-              response.headers(),\n-              args.bucket(),\n-              args.region(),\n-              args.object(),\n-              result.etag(),\n-              response.header(\"x-amz-version-id\"));\n-        } catch (XmlParserException e) {\n-          // As this CopyObjectResult REST call succeeded, just log it.\n-          Logger.getLogger(MinioClient.class.getName())\n-              .warning(\n-                  \"S3 service returned unknown XML for CopyObjectResult REST API. \" + bodyContent);\n-        }\n-      }\n-      return new ObjectWriteResponse(\n-          response.headers(),\n-          args.bucket(),\n-          getRegion(args.bucket()),\n-          args.object(),\n-          null,\n-          response.header(\"x-amz-version-id\"));\n+      // For now ignore the copyObjectResult, just read and parse it.\n+      Xml.unmarshal(CopyObjectResult.class, response.body().charStream());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYyNjQ4NQ==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r442626485", "bodyText": "remove this commented code.", "author": "balamurugana", "createdAt": "2020-06-19T04:37:50Z", "path": "functional/FunctionalTest.java", "diffHunk": "@@ -421,6 +422,34 @@ private static void handleException(String methodName, String args, long startTi\n     throw e;\n   }\n \n+  // private static void deleteFilesAndObjects(String bucketName, String[] filenames) throws\n+  // Exception {\n+  //   for (String filename : filenames) {\n+  //     Files.delete(Paths.get(filename));\n+  //\n+  // client.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(filename).build());\n+  //   }\n+  // }", "originalCommit": "99b7354724fb6d660dfb738ca2142c1201da039b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/functional/FunctionalTest.java b/functional/FunctionalTest.java\nindex 660f4f45..102e21f2 100644\n--- a/functional/FunctionalTest.java\n+++ b/functional/FunctionalTest.java\n\n@@ -422,31 +423,10 @@ public class FunctionalTest {\n     throw e;\n   }\n \n-  // private static void deleteFilesAndObjects(String bucketName, String[] filenames) throws\n-  // Exception {\n-  //   for (String filename : filenames) {\n-  //     Files.delete(Paths.get(filename));\n-  //\n-  // client.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(filename).build());\n-  //   }\n-  // }\n-\n-  private static void deleteFilesAndObjects(String bucketName, String[] filenames)\n-      throws Exception {\n-    for (String filename : filenames) {\n+  private static void deleteFilesAndObjects(String bucketName, String files[]) throws Exception {\n+    for (String filename : files) {\n       Files.delete(Paths.get(filename));\n-    }\n-    List<DeleteObject> objects =\n-        Arrays.stream(filenames)\n-            .map(\n-                name -> {\n-                  return new DeleteObject(name);\n-                })\n-            .collect(Collectors.toList());\n-    for (Result<?> r :\n-        client.removeObjects(\n-            RemoveObjectsArgs.builder().bucket(bucketName).objects(objects).build())) {\n-      ignore(r.get());\n+      client.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(filename).build());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYyNjY3NA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r442626674", "bodyText": "Can't you use removeObjects() method available in this class?\nIts better to call object removal first, then file removal later.", "author": "balamurugana", "createdAt": "2020-06-19T04:38:49Z", "path": "functional/FunctionalTest.java", "diffHunk": "@@ -421,6 +422,34 @@ private static void handleException(String methodName, String args, long startTi\n     throw e;\n   }\n \n+  // private static void deleteFilesAndObjects(String bucketName, String[] filenames) throws\n+  // Exception {\n+  //   for (String filename : filenames) {\n+  //     Files.delete(Paths.get(filename));\n+  //\n+  // client.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(filename).build());\n+  //   }\n+  // }\n+\n+  private static void deleteFilesAndObjects(String bucketName, String[] filenames)\n+      throws Exception {\n+    for (String filename : filenames) {\n+      Files.delete(Paths.get(filename));\n+    }\n+    List<DeleteObject> objects =", "originalCommit": "99b7354724fb6d660dfb738ca2142c1201da039b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53866d15c676ab84062d9e357fc19a786b1790c8", "chunk": "diff --git a/functional/FunctionalTest.java b/functional/FunctionalTest.java\nindex 660f4f45..102e21f2 100644\n--- a/functional/FunctionalTest.java\n+++ b/functional/FunctionalTest.java\n\n@@ -422,31 +423,10 @@ public class FunctionalTest {\n     throw e;\n   }\n \n-  // private static void deleteFilesAndObjects(String bucketName, String[] filenames) throws\n-  // Exception {\n-  //   for (String filename : filenames) {\n-  //     Files.delete(Paths.get(filename));\n-  //\n-  // client.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(filename).build());\n-  //   }\n-  // }\n-\n-  private static void deleteFilesAndObjects(String bucketName, String[] filenames)\n-      throws Exception {\n-    for (String filename : filenames) {\n+  private static void deleteFilesAndObjects(String bucketName, String files[]) throws Exception {\n+    for (String filename : files) {\n       Files.delete(Paths.get(filename));\n-    }\n-    List<DeleteObject> objects =\n-        Arrays.stream(filenames)\n-            .map(\n-                name -> {\n-                  return new DeleteObject(name);\n-                })\n-            .collect(Collectors.toList());\n-    for (Result<?> r :\n-        client.removeObjects(\n-            RemoveObjectsArgs.builder().bucket(bucketName).objects(objects).build())) {\n-      ignore(r.get());\n+      client.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(filename).build());\n     }\n   }\n \n"}}, {"oid": "53866d15c676ab84062d9e357fc19a786b1790c8", "url": "https://github.com/minio/minio-java/commit/53866d15c676ab84062d9e357fc19a786b1790c8", "message": "Add builder support to Compose object api", "committedDate": "2020-06-20T09:05:11Z", "type": "commit"}, {"oid": "d105addf9980f55203b71970b7ba91446e34a943", "url": "https://github.com/minio/minio-java/commit/d105addf9980f55203b71970b7ba91446e34a943", "message": "Address review comments", "committedDate": "2020-06-20T09:05:11Z", "type": "commit"}, {"oid": "099e360a9930be0cff1016029b3401a6ae226b83", "url": "https://github.com/minio/minio-java/commit/099e360a9930be0cff1016029b3401a6ae226b83", "message": "ObjectWriteResponse from composeObject & copyObject", "committedDate": "2020-06-20T09:05:11Z", "type": "commit"}, {"oid": "cfe2334e2f10a0b023ad510c60e7cc9f6d481943", "url": "https://github.com/minio/minio-java/commit/cfe2334e2f10a0b023ad510c60e7cc9f6d481943", "message": "Modify ObjectWriteResponse", "committedDate": "2020-06-20T09:05:11Z", "type": "commit"}, {"oid": "1b5f96f5de48145521966124ab0f0291fca0e368", "url": "https://github.com/minio/minio-java/commit/1b5f96f5de48145521966124ab0f0291fca0e368", "message": "Address Bala's review comment", "committedDate": "2020-06-20T09:05:11Z", "type": "commit"}, {"oid": "21d5df86a3f012df68a83414c63c78158ecdd3b6", "url": "https://github.com/minio/minio-java/commit/21d5df86a3f012df68a83414c63c78158ecdd3b6", "message": "Address more comments", "committedDate": "2020-06-20T17:36:37Z", "type": "commit"}, {"oid": "21d5df86a3f012df68a83414c63c78158ecdd3b6", "url": "https://github.com/minio/minio-java/commit/21d5df86a3f012df68a83414c63c78158ecdd3b6", "message": "Address more comments", "committedDate": "2020-06-20T17:36:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NzQ1Ng==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r443177456", "bodyText": "You would need to use args.validateSse(this.baseUrl);", "author": "balamurugana", "createdAt": "2020-06-21T03:21:45Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2557,29 +2566,102 @@ public void composeObject(\n           InternalException, InvalidBucketNameException, InvalidKeyException,\n           InvalidResponseException, IOException, NoSuchAlgorithmException, ServerException,\n           XmlParserException {\n-    if ((bucketName == null) || (bucketName.isEmpty())) {\n-      throw new IllegalArgumentException(\"bucket name cannot be empty\");\n-    }\n \n-    checkObjectName(objectName);\n+    ComposeObjectArgs.Builder builder =\n+        ComposeObjectArgs.builder()\n+            .bucket(bucketName)\n+            .object(objectName)\n+            .headers(Multimaps.forMap(headerMap))\n+            .sources(sources)\n+            .sse(sse);\n \n-    if (sources.isEmpty()) {\n-      throw new IllegalArgumentException(\"compose sources cannot be empty\");\n-    }\n+    composeObject(builder.build());\n+  }\n \n-    checkWriteRequestSse(sse);\n+  /**\n+   * Creates an object by combining data from different source objects using server-side copy.\n+   *\n+   * <pre>Example:{@code\n+   * List<ComposeSource> sourceObjectList = new ArrayList<ComposeSource>();\n+   *\n+   * sourceObjectList.add(\n+   *    ComposeSource.builder().bucket(\"my-job-bucket\").object(\"my-objectname-part-one\").build());\n+   * sourceObjectList.add(\n+   *    ComposeSource.builder().bucket(\"my-job-bucket\").object(\"my-objectname-part-two\").build());\n+   * sourceObjectList.add(\n+   *    ComposeSource.builder().bucket(\"my-job-bucket\").object(\"my-objectname-part-three\").build());\n+   *\n+   * // Create my-bucketname/my-objectname by combining source object list.\n+   * minioClient.composeObject(\n+   *    ComposeObjectArgs.builder()\n+   *        .bucket(\"my-bucketname\")\n+   *        .object(\"my-objectname\")\n+   *        .sources(sourceObjectList)\n+   *        .build());\n+   *\n+   * // Create my-bucketname/my-objectname with user metadata by combining source object\n+   * // list.\n+   * minioClient.composeObject(\n+   *     ComposeObjectArgs.builder()\n+   *        .bucket(\"my-bucketname\")\n+   *        .object(\"my-objectname\")\n+   *        .sources(sourceObjectList)\n+   *        .build());\n+   *\n+   * // Create my-bucketname/my-objectname with user metadata and server-side encryption\n+   * // by combining source object list.\n+   * minioClient.composeObject(\n+   *   ComposeObjectArgs.builder()\n+   *        .bucket(\"my-bucketname\")\n+   *        .object(\"my-objectname\")\n+   *        .sources(sourceObjectList)\n+   *        .ssec(sse)\n+   *        .build());\n+   *\n+   * }</pre>\n+   *\n+   * @param args {@link ComposeObjectArgs} object.\n+   * @return {@link ObjectWriteResponse} object.\n+   * @throws ErrorResponseException thrown to indicate S3 service returned an error response.\n+   * @throws IllegalArgumentException throws to indicate invalid argument passed.\n+   * @throws InsufficientDataException thrown to indicate not enough data available in InputStream.\n+   * @throws InternalException thrown to indicate internal library error.\n+   * @throws InvalidBucketNameException thrown to indicate invalid bucket name passed.\n+   * @throws InvalidKeyException thrown to indicate missing of HMAC SHA-256 library.\n+   * @throws InvalidResponseException thrown to indicate S3 service returned invalid or no error\n+   *     response.\n+   * @throws IOException thrown to indicate I/O error on S3 operation.\n+   * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n+   * @throws XmlParserException thrown to indicate XML parsing error.\n+   */\n+  public ObjectWriteResponse composeObject(ComposeObjectArgs args)\n+      throws ErrorResponseException, IllegalArgumentException, InsufficientDataException,\n+          InternalException, InvalidBucketNameException, InvalidKeyException,\n+          InvalidResponseException, IOException, NoSuchAlgorithmException, ServerException,\n+          XmlParserException {\n+\n+    checkWriteRequestSse(args.sse());", "originalCommit": "21d5df86a3f012df68a83414c63c78158ecdd3b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a93db625381c0497fc96ae0c6e15eb858823069", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 0a72ca58..8777b968 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2640,16 +2629,14 @@ public class MinioClient {\n           InvalidResponseException, IOException, NoSuchAlgorithmException, ServerException,\n           XmlParserException {\n \n-    checkWriteRequestSse(args.sse());\n+    args.validateSse(this.baseUrl);\n \n     long objectSize = 0;\n     int partsCount = 0;\n     List<ComposeSource> sources = args.sources();\n     for (int i = 0; i < sources.size(); i++) {\n       ComposeSource src = sources.get(i);\n-\n-      checkReadRequestSse(src.ssec());\n-\n+      src.validateSse(this.baseUrl);\n       ObjectStat stat =\n           statObject(\n               StatObjectArgs.builder()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NzgyOQ==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r443177829", "bodyText": "You would need to have below method in ComposeSource class and use it here.\n`\n  public void validateSse(HttpUrl url) {\n    checkSse(srcSsec, url);\n  }", "author": "balamurugana", "createdAt": "2020-06-21T03:30:05Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2557,29 +2566,102 @@ public void composeObject(\n           InternalException, InvalidBucketNameException, InvalidKeyException,\n           InvalidResponseException, IOException, NoSuchAlgorithmException, ServerException,\n           XmlParserException {\n-    if ((bucketName == null) || (bucketName.isEmpty())) {\n-      throw new IllegalArgumentException(\"bucket name cannot be empty\");\n-    }\n \n-    checkObjectName(objectName);\n+    ComposeObjectArgs.Builder builder =\n+        ComposeObjectArgs.builder()\n+            .bucket(bucketName)\n+            .object(objectName)\n+            .headers(Multimaps.forMap(headerMap))\n+            .sources(sources)\n+            .sse(sse);\n \n-    if (sources.isEmpty()) {\n-      throw new IllegalArgumentException(\"compose sources cannot be empty\");\n-    }\n+    composeObject(builder.build());\n+  }\n \n-    checkWriteRequestSse(sse);\n+  /**\n+   * Creates an object by combining data from different source objects using server-side copy.\n+   *\n+   * <pre>Example:{@code\n+   * List<ComposeSource> sourceObjectList = new ArrayList<ComposeSource>();\n+   *\n+   * sourceObjectList.add(\n+   *    ComposeSource.builder().bucket(\"my-job-bucket\").object(\"my-objectname-part-one\").build());\n+   * sourceObjectList.add(\n+   *    ComposeSource.builder().bucket(\"my-job-bucket\").object(\"my-objectname-part-two\").build());\n+   * sourceObjectList.add(\n+   *    ComposeSource.builder().bucket(\"my-job-bucket\").object(\"my-objectname-part-three\").build());\n+   *\n+   * // Create my-bucketname/my-objectname by combining source object list.\n+   * minioClient.composeObject(\n+   *    ComposeObjectArgs.builder()\n+   *        .bucket(\"my-bucketname\")\n+   *        .object(\"my-objectname\")\n+   *        .sources(sourceObjectList)\n+   *        .build());\n+   *\n+   * // Create my-bucketname/my-objectname with user metadata by combining source object\n+   * // list.\n+   * minioClient.composeObject(\n+   *     ComposeObjectArgs.builder()\n+   *        .bucket(\"my-bucketname\")\n+   *        .object(\"my-objectname\")\n+   *        .sources(sourceObjectList)\n+   *        .build());\n+   *\n+   * // Create my-bucketname/my-objectname with user metadata and server-side encryption\n+   * // by combining source object list.\n+   * minioClient.composeObject(\n+   *   ComposeObjectArgs.builder()\n+   *        .bucket(\"my-bucketname\")\n+   *        .object(\"my-objectname\")\n+   *        .sources(sourceObjectList)\n+   *        .ssec(sse)\n+   *        .build());\n+   *\n+   * }</pre>\n+   *\n+   * @param args {@link ComposeObjectArgs} object.\n+   * @return {@link ObjectWriteResponse} object.\n+   * @throws ErrorResponseException thrown to indicate S3 service returned an error response.\n+   * @throws IllegalArgumentException throws to indicate invalid argument passed.\n+   * @throws InsufficientDataException thrown to indicate not enough data available in InputStream.\n+   * @throws InternalException thrown to indicate internal library error.\n+   * @throws InvalidBucketNameException thrown to indicate invalid bucket name passed.\n+   * @throws InvalidKeyException thrown to indicate missing of HMAC SHA-256 library.\n+   * @throws InvalidResponseException thrown to indicate S3 service returned invalid or no error\n+   *     response.\n+   * @throws IOException thrown to indicate I/O error on S3 operation.\n+   * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n+   * @throws XmlParserException thrown to indicate XML parsing error.\n+   */\n+  public ObjectWriteResponse composeObject(ComposeObjectArgs args)\n+      throws ErrorResponseException, IllegalArgumentException, InsufficientDataException,\n+          InternalException, InvalidBucketNameException, InvalidKeyException,\n+          InvalidResponseException, IOException, NoSuchAlgorithmException, ServerException,\n+          XmlParserException {\n+\n+    checkWriteRequestSse(args.sse());\n \n     long objectSize = 0;\n     int partsCount = 0;\n+    List<ComposeSource> sources = args.sources();\n     for (int i = 0; i < sources.size(); i++) {\n       ComposeSource src = sources.get(i);\n \n       checkReadRequestSse(src.ssec());", "originalCommit": "21d5df86a3f012df68a83414c63c78158ecdd3b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a93db625381c0497fc96ae0c6e15eb858823069", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 0a72ca58..8777b968 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2640,16 +2629,14 @@ public class MinioClient {\n           InvalidResponseException, IOException, NoSuchAlgorithmException, ServerException,\n           XmlParserException {\n \n-    checkWriteRequestSse(args.sse());\n+    args.validateSse(this.baseUrl);\n \n     long objectSize = 0;\n     int partsCount = 0;\n     List<ComposeSource> sources = args.sources();\n     for (int i = 0; i < sources.size(); i++) {\n       ComposeSource src = sources.get(i);\n-\n-      checkReadRequestSse(src.ssec());\n-\n+      src.validateSse(this.baseUrl);\n       ObjectStat stat =\n           statObject(\n               StatObjectArgs.builder()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3ODA1NA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r443178054", "bodyText": "You would need to use headers() not extraHeaders(). headers member data is updated in ComposeSource.buildHeaders()", "author": "balamurugana", "createdAt": "2020-06-21T03:34:48Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2557,29 +2566,102 @@ public void composeObject(\n           InternalException, InvalidBucketNameException, InvalidKeyException,\n           InvalidResponseException, IOException, NoSuchAlgorithmException, ServerException,\n           XmlParserException {\n-    if ((bucketName == null) || (bucketName.isEmpty())) {\n-      throw new IllegalArgumentException(\"bucket name cannot be empty\");\n-    }\n \n-    checkObjectName(objectName);\n+    ComposeObjectArgs.Builder builder =\n+        ComposeObjectArgs.builder()\n+            .bucket(bucketName)\n+            .object(objectName)\n+            .headers(Multimaps.forMap(headerMap))\n+            .sources(sources)\n+            .sse(sse);\n \n-    if (sources.isEmpty()) {\n-      throw new IllegalArgumentException(\"compose sources cannot be empty\");\n-    }\n+    composeObject(builder.build());\n+  }\n \n-    checkWriteRequestSse(sse);\n+  /**\n+   * Creates an object by combining data from different source objects using server-side copy.\n+   *\n+   * <pre>Example:{@code\n+   * List<ComposeSource> sourceObjectList = new ArrayList<ComposeSource>();\n+   *\n+   * sourceObjectList.add(\n+   *    ComposeSource.builder().bucket(\"my-job-bucket\").object(\"my-objectname-part-one\").build());\n+   * sourceObjectList.add(\n+   *    ComposeSource.builder().bucket(\"my-job-bucket\").object(\"my-objectname-part-two\").build());\n+   * sourceObjectList.add(\n+   *    ComposeSource.builder().bucket(\"my-job-bucket\").object(\"my-objectname-part-three\").build());\n+   *\n+   * // Create my-bucketname/my-objectname by combining source object list.\n+   * minioClient.composeObject(\n+   *    ComposeObjectArgs.builder()\n+   *        .bucket(\"my-bucketname\")\n+   *        .object(\"my-objectname\")\n+   *        .sources(sourceObjectList)\n+   *        .build());\n+   *\n+   * // Create my-bucketname/my-objectname with user metadata by combining source object\n+   * // list.\n+   * minioClient.composeObject(\n+   *     ComposeObjectArgs.builder()\n+   *        .bucket(\"my-bucketname\")\n+   *        .object(\"my-objectname\")\n+   *        .sources(sourceObjectList)\n+   *        .build());\n+   *\n+   * // Create my-bucketname/my-objectname with user metadata and server-side encryption\n+   * // by combining source object list.\n+   * minioClient.composeObject(\n+   *   ComposeObjectArgs.builder()\n+   *        .bucket(\"my-bucketname\")\n+   *        .object(\"my-objectname\")\n+   *        .sources(sourceObjectList)\n+   *        .ssec(sse)\n+   *        .build());\n+   *\n+   * }</pre>\n+   *\n+   * @param args {@link ComposeObjectArgs} object.\n+   * @return {@link ObjectWriteResponse} object.\n+   * @throws ErrorResponseException thrown to indicate S3 service returned an error response.\n+   * @throws IllegalArgumentException throws to indicate invalid argument passed.\n+   * @throws InsufficientDataException thrown to indicate not enough data available in InputStream.\n+   * @throws InternalException thrown to indicate internal library error.\n+   * @throws InvalidBucketNameException thrown to indicate invalid bucket name passed.\n+   * @throws InvalidKeyException thrown to indicate missing of HMAC SHA-256 library.\n+   * @throws InvalidResponseException thrown to indicate S3 service returned invalid or no error\n+   *     response.\n+   * @throws IOException thrown to indicate I/O error on S3 operation.\n+   * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n+   * @throws XmlParserException thrown to indicate XML parsing error.\n+   */\n+  public ObjectWriteResponse composeObject(ComposeObjectArgs args)\n+      throws ErrorResponseException, IllegalArgumentException, InsufficientDataException,\n+          InternalException, InvalidBucketNameException, InvalidKeyException,\n+          InvalidResponseException, IOException, NoSuchAlgorithmException, ServerException,\n+          XmlParserException {\n+\n+    checkWriteRequestSse(args.sse());\n \n     long objectSize = 0;\n     int partsCount = 0;\n+    List<ComposeSource> sources = args.sources();\n     for (int i = 0; i < sources.size(); i++) {\n       ComposeSource src = sources.get(i);\n \n       checkReadRequestSse(src.ssec());\n \n-      ObjectStat stat = statObject(src.bucketName(), src.objectName(), src.ssec());\n+      ObjectStat stat =\n+          statObject(\n+              StatObjectArgs.builder()\n+                  .bucket(src.bucket())\n+                  .object(src.object())\n+                  .versionId(src.versionId())\n+                  .ssec(src.ssec())\n+                  .build());\n+\n       src.buildHeaders(stat.length(), stat.etag());\n \n-      if (i != 0 && src.headers().containsKey(\"x-amz-meta-x-amz-key\")) {\n+      if (i != 0 && src.extraHeaders().containsKey(\"x-amz-meta-x-amz-key\")) {", "originalCommit": "21d5df86a3f012df68a83414c63c78158ecdd3b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a93db625381c0497fc96ae0c6e15eb858823069", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 0a72ca58..8777b968 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2640,16 +2629,14 @@ public class MinioClient {\n           InvalidResponseException, IOException, NoSuchAlgorithmException, ServerException,\n           XmlParserException {\n \n-    checkWriteRequestSse(args.sse());\n+    args.validateSse(this.baseUrl);\n \n     long objectSize = 0;\n     int partsCount = 0;\n     List<ComposeSource> sources = args.sources();\n     for (int i = 0; i < sources.size(); i++) {\n       ComposeSource src = sources.get(i);\n-\n-      checkReadRequestSse(src.ssec());\n-\n+      src.validateSse(this.baseUrl);\n       ObjectStat stat =\n           statObject(\n               StatObjectArgs.builder()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3ODI0Mw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r443178243", "bodyText": "sseHeaders is always empty. We don't need to add that.", "author": "balamurugana", "createdAt": "2020-06-21T03:38:54Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2649,47 +2731,51 @@ public void composeObject(\n \n     if (partsCount == 1) {\n       ComposeSource src = sources.get(0);\n-      if (headerMap == null) {\n-        headerMap = new HashMap<>();\n-      }\n+      Multimap<String, String> headers = HashMultimap.create();\n+      headers.putAll(args.extraHeaders());\n+      headers.putAll(args.headers);\n       if ((src.offset() != null) && (src.length() == null)) {\n-        headerMap.put(\"x-amz-copy-source-range\", \"bytes=\" + src.offset() + \"-\");\n+        headers.put(\"x-amz-copy-source-range\", \"bytes=\" + src.offset() + \"-\");\n       }\n \n       if ((src.offset() != null) && (src.length() != null)) {\n-        headerMap.put(\n+        headers.put(\n             \"x-amz-copy-source-range\",\n             \"bytes=\" + src.offset() + \"-\" + (src.offset() + src.length() - 1));\n       }\n-      copyObject(\n-          bucketName,\n-          objectName,\n-          headerMap,\n-          sse,\n-          src.bucketName(),\n-          src.objectName(),\n-          src.ssec(),\n-          src.copyConditions());\n-      return;\n-    }\n-\n-    Map<String, String> sseHeaders = null;\n-    if (sse != null) {\n-      sseHeaders = sse.headers();\n-      if (headerMap == null) {\n-        headerMap = new HashMap<>();\n-      }\n+      return copyObject(\n+          CopyObjectArgs.builder()\n+              .bucket(args.bucket())\n+              .object(args.object())\n+              .headers(args.extraHeaders)\n+              .sse(args.sse())\n+              .srcBucket(src.bucket())\n+              .srcObject(src.object())\n+              .srcVersionId(src.versionId())\n+              .srcSsec(src.ssec())\n+              .srcMatchETag(src.matchETag())\n+              .srcNotMatchETag(src.notMatchETag())\n+              .srcModifiedSince(src.modifiedSince())\n+              .srcUnmodifiedSince(src.unmodifiedSince())\n+              .build());\n+    }\n+\n+    Multimap<String, String> sseHeaders = HashMultimap.create();\n+    Multimap<String, String> headerMap = HashMultimap.create();\n+    if (args.sse() != null) {\n+      sseHeaders.putAll(Multimaps.forMap(args.sse().headers()));\n+      headerMap.putAll(args.extraHeaders());\n+      headerMap.putAll(args.headers);\n       headerMap.putAll(sseHeaders);", "originalCommit": "21d5df86a3f012df68a83414c63c78158ecdd3b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a93db625381c0497fc96ae0c6e15eb858823069", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 0a72ca58..8777b968 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2729,35 +2715,28 @@ public class MinioClient {\n       }\n     }\n \n-    if (partsCount == 1) {\n+    if (args.sources().size() == 1) {\n       ComposeSource src = sources.get(0);\n       Multimap<String, String> headers = HashMultimap.create();\n       headers.putAll(args.extraHeaders());\n       headers.putAll(args.headers);\n-      if ((src.offset() != null) && (src.length() == null)) {\n-        headers.put(\"x-amz-copy-source-range\", \"bytes=\" + src.offset() + \"-\");\n-      }\n-\n-      if ((src.offset() != null) && (src.length() != null)) {\n-        headers.put(\n-            \"x-amz-copy-source-range\",\n-            \"bytes=\" + src.offset() + \"-\" + (src.offset() + src.length() - 1));\n+      if (src.offset() == null && src.length() == null) {\n+        return copyObject(\n+            CopyObjectArgs.builder()\n+                .bucket(args.bucket())\n+                .object(args.object())\n+                .headers(args.extraHeaders())\n+                .sse(args.sse())\n+                .srcBucket(src.bucket())\n+                .srcObject(src.object())\n+                .srcVersionId(src.versionId())\n+                .srcSsec(src.ssec())\n+                .srcMatchETag(src.matchETag())\n+                .srcNotMatchETag(src.notMatchETag())\n+                .srcModifiedSince(src.modifiedSince())\n+                .srcUnmodifiedSince(src.unmodifiedSince())\n+                .build());\n       }\n-      return copyObject(\n-          CopyObjectArgs.builder()\n-              .bucket(args.bucket())\n-              .object(args.object())\n-              .headers(args.extraHeaders)\n-              .sse(args.sse())\n-              .srcBucket(src.bucket())\n-              .srcObject(src.object())\n-              .srcVersionId(src.versionId())\n-              .srcSsec(src.ssec())\n-              .srcMatchETag(src.matchETag())\n-              .srcNotMatchETag(src.notMatchETag())\n-              .srcModifiedSince(src.modifiedSince())\n-              .srcUnmodifiedSince(src.unmodifiedSince())\n-              .build());\n     }\n \n     Multimap<String, String> sseHeaders = HashMultimap.create();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3ODgyNQ==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r443178825", "bodyText": "copyObject() only works with one source and without range. You would need to fix it accordingly.", "author": "balamurugana", "createdAt": "2020-06-21T03:51:28Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2649,47 +2731,51 @@ public void composeObject(\n \n     if (partsCount == 1) {\n       ComposeSource src = sources.get(0);\n-      if (headerMap == null) {\n-        headerMap = new HashMap<>();\n-      }\n+      Multimap<String, String> headers = HashMultimap.create();\n+      headers.putAll(args.extraHeaders());\n+      headers.putAll(args.headers);\n       if ((src.offset() != null) && (src.length() == null)) {\n-        headerMap.put(\"x-amz-copy-source-range\", \"bytes=\" + src.offset() + \"-\");\n+        headers.put(\"x-amz-copy-source-range\", \"bytes=\" + src.offset() + \"-\");\n       }\n \n       if ((src.offset() != null) && (src.length() != null)) {\n-        headerMap.put(\n+        headers.put(\n             \"x-amz-copy-source-range\",\n             \"bytes=\" + src.offset() + \"-\" + (src.offset() + src.length() - 1));\n       }\n-      copyObject(\n-          bucketName,\n-          objectName,\n-          headerMap,\n-          sse,\n-          src.bucketName(),\n-          src.objectName(),\n-          src.ssec(),\n-          src.copyConditions());\n-      return;\n-    }\n-\n-    Map<String, String> sseHeaders = null;\n-    if (sse != null) {\n-      sseHeaders = sse.headers();\n-      if (headerMap == null) {\n-        headerMap = new HashMap<>();\n-      }\n+      return copyObject(", "originalCommit": "21d5df86a3f012df68a83414c63c78158ecdd3b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a93db625381c0497fc96ae0c6e15eb858823069", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 0a72ca58..8777b968 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2729,35 +2715,28 @@ public class MinioClient {\n       }\n     }\n \n-    if (partsCount == 1) {\n+    if (args.sources().size() == 1) {\n       ComposeSource src = sources.get(0);\n       Multimap<String, String> headers = HashMultimap.create();\n       headers.putAll(args.extraHeaders());\n       headers.putAll(args.headers);\n-      if ((src.offset() != null) && (src.length() == null)) {\n-        headers.put(\"x-amz-copy-source-range\", \"bytes=\" + src.offset() + \"-\");\n-      }\n-\n-      if ((src.offset() != null) && (src.length() != null)) {\n-        headers.put(\n-            \"x-amz-copy-source-range\",\n-            \"bytes=\" + src.offset() + \"-\" + (src.offset() + src.length() - 1));\n+      if (src.offset() == null && src.length() == null) {\n+        return copyObject(\n+            CopyObjectArgs.builder()\n+                .bucket(args.bucket())\n+                .object(args.object())\n+                .headers(args.extraHeaders())\n+                .sse(args.sse())\n+                .srcBucket(src.bucket())\n+                .srcObject(src.object())\n+                .srcVersionId(src.versionId())\n+                .srcSsec(src.ssec())\n+                .srcMatchETag(src.matchETag())\n+                .srcNotMatchETag(src.notMatchETag())\n+                .srcModifiedSince(src.modifiedSince())\n+                .srcUnmodifiedSince(src.unmodifiedSince())\n+                .build());\n       }\n-      return copyObject(\n-          CopyObjectArgs.builder()\n-              .bucket(args.bucket())\n-              .object(args.object())\n-              .headers(args.extraHeaders)\n-              .sse(args.sse())\n-              .srcBucket(src.bucket())\n-              .srcObject(src.object())\n-              .srcVersionId(src.versionId())\n-              .srcSsec(src.ssec())\n-              .srcMatchETag(src.matchETag())\n-              .srcNotMatchETag(src.notMatchETag())\n-              .srcModifiedSince(src.modifiedSince())\n-              .srcUnmodifiedSince(src.unmodifiedSince())\n-              .build());\n     }\n \n     Multimap<String, String> sseHeaders = HashMultimap.create();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3ODkwMw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r443178903", "bodyText": "We are providing core level support by protected. Any reason ti change it to private?\nCreate one more method with Multimap than change it here.", "author": "balamurugana", "createdAt": "2020-06-21T03:53:15Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -8156,19 +8244,29 @@ protected String uploadPart(\n    * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n    * @throws XmlParserException thrown to indicate XML parsing error.\n    */\n-  protected String uploadPartCopy(\n+  private String uploadPartCopy(", "originalCommit": "21d5df86a3f012df68a83414c63c78158ecdd3b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a93db625381c0497fc96ae0c6e15eb858823069", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 0a72ca58..8777b968 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -8244,7 +8222,7 @@ public class MinioClient {\n    * @throws NoSuchAlgorithmException thrown to indicate missing of MD5 or SHA-256 digest library.\n    * @throws XmlParserException thrown to indicate XML parsing error.\n    */\n-  private String uploadPartCopy(\n+  protected String uploadPartCopy(\n       String bucketName,\n       String objectName,\n       String uploadId,\n"}}, {"oid": "0a93db625381c0497fc96ae0c6e15eb858823069", "url": "https://github.com/minio/minio-java/commit/0a93db625381c0497fc96ae0c6e15eb858823069", "message": "resolving comments", "committedDate": "2020-06-22T02:32:35Z", "type": "forcePushed"}, {"oid": "40934b06150fbe6cb431b906087680a23cf1b756", "url": "https://github.com/minio/minio-java/commit/40934b06150fbe6cb431b906087680a23cf1b756", "message": "resolving comments", "committedDate": "2020-06-22T02:40:22Z", "type": "commit"}, {"oid": "40934b06150fbe6cb431b906087680a23cf1b756", "url": "https://github.com/minio/minio-java/commit/40934b06150fbe6cb431b906087680a23cf1b756", "message": "resolving comments", "committedDate": "2020-06-22T02:40:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI5NzQyNg==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r443297426", "bodyText": "You would need to do if (args.sources.size() == 1 && src.offset() == null && src.length() == null) {\nNo need to use sources.get(0) because src is already pointing to sources.get(0)", "author": "balamurugana", "createdAt": "2020-06-22T03:09:42Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2647,49 +2715,45 @@ public void composeObject(\n       }\n     }\n \n-    if (partsCount == 1) {\n+    if (args.sources().size() == 1) {", "originalCommit": "40934b06150fbe6cb431b906087680a23cf1b756", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "105b906739bf92b980e7fa30da035e1d80ea0b2e", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 8777b968..e1942aa2 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2719,7 +2713,7 @@ public class MinioClient {\n       ComposeSource src = sources.get(0);\n       Multimap<String, String> headers = HashMultimap.create();\n       headers.putAll(args.extraHeaders());\n-      headers.putAll(args.headers);\n+      headers.putAll(args.headers());\n       if (src.offset() == null && src.length() == null) {\n         return copyObject(\n             CopyObjectArgs.builder()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI5ODA4NA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r443298084", "bodyText": "Isn't it headers.putAll(args.headers()) ? Not sure why there is no compiler error to this line.\nWhy is it required to create combined headers here? Can't you use them directly like .extraHeaders(args.extraHeaders()).headers(args.headers()) ?", "author": "balamurugana", "createdAt": "2020-06-22T03:13:03Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2647,49 +2715,45 @@ public void composeObject(\n       }\n     }\n \n-    if (partsCount == 1) {\n+    if (args.sources().size() == 1) {\n       ComposeSource src = sources.get(0);\n-      if (headerMap == null) {\n-        headerMap = new HashMap<>();\n-      }\n-      if ((src.offset() != null) && (src.length() == null)) {\n-        headerMap.put(\"x-amz-copy-source-range\", \"bytes=\" + src.offset() + \"-\");\n-      }\n-\n-      if ((src.offset() != null) && (src.length() != null)) {\n-        headerMap.put(\n-            \"x-amz-copy-source-range\",\n-            \"bytes=\" + src.offset() + \"-\" + (src.offset() + src.length() - 1));\n+      Multimap<String, String> headers = HashMultimap.create();\n+      headers.putAll(args.extraHeaders());\n+      headers.putAll(args.headers);", "originalCommit": "40934b06150fbe6cb431b906087680a23cf1b756", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "105b906739bf92b980e7fa30da035e1d80ea0b2e", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 8777b968..e1942aa2 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2719,7 +2713,7 @@ public class MinioClient {\n       ComposeSource src = sources.get(0);\n       Multimap<String, String> headers = HashMultimap.create();\n       headers.putAll(args.extraHeaders());\n-      headers.putAll(args.headers);\n+      headers.putAll(args.headers());\n       if (src.offset() == null && src.length() == null) {\n         return copyObject(\n             CopyObjectArgs.builder()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMwMDU5NA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r443300594", "bodyText": "use createMultipartUpload() like String uploadId = createMultipartUpload(args.bucket(), args.region(), args.object(), args.genHeaders(), args.extraQueryParams());\nmove this line at 1242", "author": "balamurugana", "createdAt": "2020-06-22T03:27:13Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2647,49 +2715,45 @@ public void composeObject(\n       }\n     }\n \n-    if (partsCount == 1) {\n+    if (args.sources().size() == 1) {\n       ComposeSource src = sources.get(0);\n-      if (headerMap == null) {\n-        headerMap = new HashMap<>();\n-      }\n-      if ((src.offset() != null) && (src.length() == null)) {\n-        headerMap.put(\"x-amz-copy-source-range\", \"bytes=\" + src.offset() + \"-\");\n-      }\n-\n-      if ((src.offset() != null) && (src.length() != null)) {\n-        headerMap.put(\n-            \"x-amz-copy-source-range\",\n-            \"bytes=\" + src.offset() + \"-\" + (src.offset() + src.length() - 1));\n+      Multimap<String, String> headers = HashMultimap.create();\n+      headers.putAll(args.extraHeaders());\n+      headers.putAll(args.headers);\n+      if (src.offset() == null && src.length() == null) {\n+        return copyObject(\n+            CopyObjectArgs.builder()\n+                .bucket(args.bucket())\n+                .object(args.object())\n+                .headers(args.extraHeaders())\n+                .sse(args.sse())\n+                .srcBucket(src.bucket())\n+                .srcObject(src.object())\n+                .srcVersionId(src.versionId())\n+                .srcSsec(src.ssec())\n+                .srcMatchETag(src.matchETag())\n+                .srcNotMatchETag(src.notMatchETag())\n+                .srcModifiedSince(src.modifiedSince())\n+                .srcUnmodifiedSince(src.unmodifiedSince())\n+                .build());\n       }\n-      copyObject(\n-          bucketName,\n-          objectName,\n-          headerMap,\n-          sse,\n-          src.bucketName(),\n-          src.objectName(),\n-          src.ssec(),\n-          src.copyConditions());\n-      return;\n     }\n \n-    Map<String, String> sseHeaders = null;\n-    if (sse != null) {\n-      sseHeaders = sse.headers();\n-      if (headerMap == null) {\n-        headerMap = new HashMap<>();\n-      }\n-      headerMap.putAll(sseHeaders);\n+    Multimap<String, String> sseHeaders = HashMultimap.create();\n+    Multimap<String, String> headerMap = HashMultimap.create();\n+    if (args.sse() != null) {\n+      sseHeaders.putAll(Multimaps.forMap(args.sse().headers()));\n+      headerMap.putAll(args.extraHeaders());\n+      headerMap.putAll(args.headers);\n     }\n \n-    String uploadId = createMultipartUpload(bucketName, objectName, headerMap);\n+    String uploadId = createMultipartUpload(args.bucket(), null, args.object(), headerMap, null);", "originalCommit": "40934b06150fbe6cb431b906087680a23cf1b756", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "105b906739bf92b980e7fa30da035e1d80ea0b2e", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 8777b968..e1942aa2 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2719,7 +2713,7 @@ public class MinioClient {\n       ComposeSource src = sources.get(0);\n       Multimap<String, String> headers = HashMultimap.create();\n       headers.putAll(args.extraHeaders());\n-      headers.putAll(args.headers);\n+      headers.putAll(args.headers());\n       if (src.offset() == null && src.length() == null) {\n         return copyObject(\n             CopyObjectArgs.builder()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMwMTUxNQ==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r443301515", "bodyText": "Isn't it headers.putAll(args.headers()) ? Not sure why there is no compiler error to this line.", "author": "balamurugana", "createdAt": "2020-06-22T03:32:23Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2647,49 +2715,45 @@ public void composeObject(\n       }\n     }\n \n-    if (partsCount == 1) {\n+    if (args.sources().size() == 1) {\n       ComposeSource src = sources.get(0);\n-      if (headerMap == null) {\n-        headerMap = new HashMap<>();\n-      }\n-      if ((src.offset() != null) && (src.length() == null)) {\n-        headerMap.put(\"x-amz-copy-source-range\", \"bytes=\" + src.offset() + \"-\");\n-      }\n-\n-      if ((src.offset() != null) && (src.length() != null)) {\n-        headerMap.put(\n-            \"x-amz-copy-source-range\",\n-            \"bytes=\" + src.offset() + \"-\" + (src.offset() + src.length() - 1));\n+      Multimap<String, String> headers = HashMultimap.create();\n+      headers.putAll(args.extraHeaders());\n+      headers.putAll(args.headers);\n+      if (src.offset() == null && src.length() == null) {\n+        return copyObject(\n+            CopyObjectArgs.builder()\n+                .bucket(args.bucket())\n+                .object(args.object())\n+                .headers(args.extraHeaders())\n+                .sse(args.sse())\n+                .srcBucket(src.bucket())\n+                .srcObject(src.object())\n+                .srcVersionId(src.versionId())\n+                .srcSsec(src.ssec())\n+                .srcMatchETag(src.matchETag())\n+                .srcNotMatchETag(src.notMatchETag())\n+                .srcModifiedSince(src.modifiedSince())\n+                .srcUnmodifiedSince(src.unmodifiedSince())\n+                .build());\n       }\n-      copyObject(\n-          bucketName,\n-          objectName,\n-          headerMap,\n-          sse,\n-          src.bucketName(),\n-          src.objectName(),\n-          src.ssec(),\n-          src.copyConditions());\n-      return;\n     }\n \n-    Map<String, String> sseHeaders = null;\n-    if (sse != null) {\n-      sseHeaders = sse.headers();\n-      if (headerMap == null) {\n-        headerMap = new HashMap<>();\n-      }\n-      headerMap.putAll(sseHeaders);\n+    Multimap<String, String> sseHeaders = HashMultimap.create();\n+    Multimap<String, String> headerMap = HashMultimap.create();\n+    if (args.sse() != null) {\n+      sseHeaders.putAll(Multimaps.forMap(args.sse().headers()));\n+      headerMap.putAll(args.extraHeaders());\n+      headerMap.putAll(args.headers);", "originalCommit": "40934b06150fbe6cb431b906087680a23cf1b756", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "105b906739bf92b980e7fa30da035e1d80ea0b2e", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 8777b968..e1942aa2 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2719,7 +2713,7 @@ public class MinioClient {\n       ComposeSource src = sources.get(0);\n       Multimap<String, String> headers = HashMultimap.create();\n       headers.putAll(args.extraHeaders());\n-      headers.putAll(args.headers);\n+      headers.putAll(args.headers());\n       if (src.offset() == null && src.length() == null) {\n         return copyObject(\n             CopyObjectArgs.builder()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMwMTk0NA==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r443301944", "bodyText": "abortMultipartUpload() should be called  not if (args.sources.size() == 1 && src.offset() == null && src.length() == null) {", "author": "balamurugana", "createdAt": "2020-06-22T03:34:55Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2745,12 +2809,13 @@ public void composeObject(\n         }\n       }\n \n-      completeMultipartUpload(bucketName, objectName, uploadId, totalParts);\n+      return completeMultipartUpload(\n+          args.bucket(), getRegion(args.bucket()), args.object(), uploadId, totalParts, null, null);\n     } catch (RuntimeException e) {\n-      abortMultipartUpload(bucketName, objectName, uploadId);\n+      abortMultipartUpload(args.bucket(), args.object(), uploadId);\n       throw e;\n     } catch (Exception e) {\n-      abortMultipartUpload(bucketName, objectName, uploadId);\n+      abortMultipartUpload(args.bucket(), args.object(), uploadId);", "originalCommit": "40934b06150fbe6cb431b906087680a23cf1b756", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "105b906739bf92b980e7fa30da035e1d80ea0b2e", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 8777b968..e1942aa2 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2797,13 +2797,11 @@ public class MinioClient {\n \n           Multimap<String, String> headers = src.headers();\n           headers.put(\"x-amz-copy-source-range\", \"bytes=\" + startBytes + \"-\" + endBytes);\n-          if (sseHeaders != null) {\n-            headers.putAll(sseHeaders);\n+          if (ssecHeaders != null) {\n+            headers.putAll(ssecHeaders);\n           }\n           String eTag = uploadPartCopy(args.bucket(), args.object(), uploadId, partNumber, headers);\n-\n           totalParts[partNumber - 1] = new Part(partNumber, eTag);\n-\n           offset = startBytes;\n           size -= (endBytes - startBytes);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMwMTk3Nw==", "url": "https://github.com/minio/minio-java/pull/979#discussion_r443301977", "bodyText": "abortMultipartUpload() should be called  not if (args.sources.size() == 1 && src.offset() == null && src.length() == null) {", "author": "balamurugana", "createdAt": "2020-06-22T03:35:06Z", "path": "api/src/main/java/io/minio/MinioClient.java", "diffHunk": "@@ -2745,12 +2809,13 @@ public void composeObject(\n         }\n       }\n \n-      completeMultipartUpload(bucketName, objectName, uploadId, totalParts);\n+      return completeMultipartUpload(\n+          args.bucket(), getRegion(args.bucket()), args.object(), uploadId, totalParts, null, null);\n     } catch (RuntimeException e) {\n-      abortMultipartUpload(bucketName, objectName, uploadId);\n+      abortMultipartUpload(args.bucket(), args.object(), uploadId);", "originalCommit": "40934b06150fbe6cb431b906087680a23cf1b756", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "105b906739bf92b980e7fa30da035e1d80ea0b2e", "chunk": "diff --git a/api/src/main/java/io/minio/MinioClient.java b/api/src/main/java/io/minio/MinioClient.java\nindex 8777b968..e1942aa2 100755\n--- a/api/src/main/java/io/minio/MinioClient.java\n+++ b/api/src/main/java/io/minio/MinioClient.java\n\n@@ -2797,13 +2797,11 @@ public class MinioClient {\n \n           Multimap<String, String> headers = src.headers();\n           headers.put(\"x-amz-copy-source-range\", \"bytes=\" + startBytes + \"-\" + endBytes);\n-          if (sseHeaders != null) {\n-            headers.putAll(sseHeaders);\n+          if (ssecHeaders != null) {\n+            headers.putAll(ssecHeaders);\n           }\n           String eTag = uploadPartCopy(args.bucket(), args.object(), uploadId, partNumber, headers);\n-\n           totalParts[partNumber - 1] = new Part(partNumber, eTag);\n-\n           offset = startBytes;\n           size -= (endBytes - startBytes);\n         }\n"}}, {"oid": "105b906739bf92b980e7fa30da035e1d80ea0b2e", "url": "https://github.com/minio/minio-java/commit/105b906739bf92b980e7fa30da035e1d80ea0b2e", "message": "Handle sse", "committedDate": "2020-06-22T09:47:45Z", "type": "commit"}, {"oid": "105b906739bf92b980e7fa30da035e1d80ea0b2e", "url": "https://github.com/minio/minio-java/commit/105b906739bf92b980e7fa30da035e1d80ea0b2e", "message": "Handle sse", "committedDate": "2020-06-22T09:47:45Z", "type": "forcePushed"}]}