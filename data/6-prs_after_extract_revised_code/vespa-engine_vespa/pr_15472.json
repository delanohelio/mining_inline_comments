{"pr_number": 15472, "pr_title": "Bjorncs/config convergence checker", "pr_createdAt": "2020-11-25T15:25:36Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/15472", "timeline": [{"oid": "93e887cb2d7ae0177eb70450b50007b1bff66985", "url": "https://github.com/vespa-engine/vespa/commit/93e887cb2d7ae0177eb70450b50007b1bff66985", "message": "Rewrite config convergence checker to use async http client", "committedDate": "2020-11-25T15:05:52Z", "type": "commit"}, {"oid": "41c6840d3cd4f164d582794af18932c33ef4db12", "url": "https://github.com/vespa-engine/vespa/commit/41c6840d3cd4f164d582794af18932c33ef4db12", "message": "Don't reuse clients\n\nThe unit tests never closes the config convergence checker, causing stale connections to eventually exhaust the limit for max open files.", "committedDate": "2020-11-25T15:19:30Z", "type": "commit"}, {"oid": "cf5ea2ca2f6c897c8fb888a3bbe7fd86bd162af6", "url": "https://github.com/vespa-engine/vespa/commit/cf5ea2ca2f6c897c8fb888a3bbe7fd86bd162af6", "message": "Specify that connection manager is not shared", "committedDate": "2020-11-25T15:22:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2ODg1OA==", "url": "https://github.com/vespa-engine/vespa/pull/15472#discussion_r530468858", "bodyText": "Level.FINE", "author": "jonmv", "createdAt": "2020-11-25T15:43:51Z", "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/ConfigConvergenceChecker.java", "diffHunk": "@@ -108,46 +117,67 @@ public JSONResponse getServiceConfigGenerationResponse(Application application,\n \n     @Override\n     public void deconstruct() {\n-        clientBuilderFactory.close();\n-    }\n-\n-    @Path(statePath)\n-    public interface StateApi {\n-        @Path(configSubPath)\n-        @GET\n-        JsonNode config();\n-    }\n-\n-    public interface StateApiFactory {\n-        StateApi createStateApi(Client client, URI serviceUri);\n+        try {\n+            client.close();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n     }\n \n     /** Gets service generation for a list of services (in parallel). */\n     private Map<ServiceInfo, Long> getServiceGenerations(List<ServiceInfo> services, Duration timeout) {\n-        return services.parallelStream()\n-                       .collect(Collectors.toMap(service -> service,\n-                                                 service -> {\n-                                                     try {\n-                                                         return getServiceGeneration(URI.create(\"http://\" + service.getHostName()\n-                                                                                                + \":\" + getStatePort(service).get()), timeout);\n-                                                     }\n-                                                     catch (ProcessingException e) { // Cannot connect to service to determine service generation\n-                                                         return -1L;\n-                                                     }\n-                                                 },\n-                                                 (v1, v2) -> { throw new IllegalStateException(\"Duplicate keys for values '\" + v1 + \"' and '\" + v2 + \"'.\"); },\n-                                                 LinkedHashMap::new\n-                                                ));\n+        List<CompletableFuture<Void>> inprogressRequests = new ArrayList<>();\n+        ConcurrentMap<ServiceInfo, Long> temporaryResult = new ConcurrentHashMap<>();\n+        for (ServiceInfo service : services) {\n+            int statePort = getStatePort(service).orElse(0);\n+            if (statePort <= 0) continue;\n+\n+            URI uri = URI.create(\"http://\" + service.getHostName() + \":\" + statePort);\n+            CompletableFuture<Void> inprogressRequest = getServiceGeneration(uri, timeout)\n+                    .handle((result, error) -> {\n+                        if (result != null) {\n+                            temporaryResult.put(service, result);\n+                        } else {\n+                            log.log(\n+                                    LogLevel.DEBUG,", "originalCommit": "93e887cb2d7ae0177eb70450b50007b1bff66985", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3MDI1Mw==", "url": "https://github.com/vespa-engine/vespa/pull/15472#discussion_r530470253", "bodyText": "I think they are equivalent (LogLevel being the Vespa wrapper for Level). Any benefits using Level instead?", "author": "bjorncs", "createdAt": "2020-11-25T15:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2ODg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NDc4NQ==", "url": "https://github.com/vespa-engine/vespa/pull/15472#discussion_r530474785", "bodyText": "I know @gjoranv went to great lengths to replace with Level values some time ago. I don't know why, though.", "author": "jonmv", "createdAt": "2020-11-25T15:51:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2ODg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUwMzIxNw==", "url": "https://github.com/vespa-engine/vespa/pull/15472#discussion_r530503217", "bodyText": "Ok, I removed use of LogLevel in new PR.", "author": "bjorncs", "createdAt": "2020-11-25T16:32:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2ODg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxNTk3NQ==", "url": "https://github.com/vespa-engine/vespa/pull/15472#discussion_r532515975", "bodyText": "I had to remove LogLevel from config in order to use config inside vespalog, and then it was proposed to remove LogLevel usage from all modules. I think the motivation was that custom log levels are unnecessary and a bit odd.", "author": "gjoranv", "createdAt": "2020-11-30T11:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2ODg1OA=="}], "type": "inlineReview", "revised_code": null}]}