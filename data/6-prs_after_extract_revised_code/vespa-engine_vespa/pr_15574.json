{"pr_number": 15574, "pr_title": "Bjorncs/cluster controller reindexing status", "pr_createdAt": "2020-12-01T17:06:26Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/15574", "timeline": [{"oid": "f2599280846073b144c4065bf25478138cc38b67", "url": "https://github.com/vespa-engine/vespa/commit/f2599280846073b144c4065bf25478138cc38b67", "message": "Add helper for combining multiple completable futures", "committedDate": "2020-12-01T16:49:22Z", "type": "commit"}, {"oid": "0b8d21fe0c915057e6c88cab1b2e988d60c5a16f", "url": "https://github.com/vespa-engine/vespa/commit/0b8d21fe0c915057e6c88cab1b2e988d60c5a16f", "message": "Add helper method to rethrow checked as unchecked", "committedDate": "2020-12-01T16:49:22Z", "type": "commit"}, {"oid": "8ed17bd76ac1acb51b6d1e13b3f2414d36aa2aff", "url": "https://github.com/vespa-engine/vespa/commit/8ed17bd76ac1acb51b6d1e13b3f2414d36aa2aff", "message": "Move serialized value definition to State enum", "committedDate": "2020-12-01T16:49:22Z", "type": "commit"}, {"oid": "26429fb170a455760a20e2a9b8a20371c4962f54", "url": "https://github.com/vespa-engine/vespa/commit/26429fb170a455760a20e2a9b8a20371c4962f54", "message": "Fetch cluster reindexing status from cluster controllers", "committedDate": "2020-12-01T17:05:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMjg1Mw==", "url": "https://github.com/vespa-engine/vespa/pull/15574#discussion_r533622853", "bodyText": "Neat.", "author": "jonmv", "createdAt": "2020-12-01T18:16:18Z", "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/DefaultClusterReindexingStatusClient.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.config.server.application;\n+\n+import ai.vespa.util.http.VespaAsyncHttpClientBuilder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.yahoo.concurrent.CompletableFutures;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.config.model.api.PortInfo;\n+import com.yahoo.config.model.api.ServiceInfo;\n+import com.yahoo.vespa.applicationmodel.ClusterId;\n+import com.yahoo.vespa.config.server.modelfactory.ModelResult;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpRequests;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\n+import org.apache.hc.client5.http.config.RequestConfig;\n+import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\n+import org.apache.hc.core5.concurrent.FutureCallback;\n+import org.apache.hc.core5.http.HttpStatus;\n+import org.apache.hc.core5.reactor.IOReactorConfig;\n+import org.apache.hc.core5.util.Timeout;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.config.model.api.container.ContainerServiceType.CLUSTERCONTROLLER_CONTAINER;\n+import static com.yahoo.yolean.Exceptions.throwUnchecked;\n+import static com.yahoo.yolean.Exceptions.uncheck;\n+\n+/**\n+ * Retrieves reindexing status from cluster controllers over HTTP\n+ *\n+ * @author bjorncs\n+ */\n+public class DefaultClusterReindexingStatusClient implements ClusterReindexingStatusClient {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private final Executor executor =\n+            Executors.newSingleThreadExecutor(new DaemonThreadFactory(\"cluster-controller-reindexing-client-\"));\n+    private final CloseableHttpAsyncClient httpClient = createHttpClient();\n+\n+    public DefaultClusterReindexingStatusClient() {\n+        httpClient.start();\n+    }\n+\n+    @Override\n+    public Map<String, ClusterReindexing> getReindexingStatus(ModelResult application) throws IOException {\n+        Map<ClusterId, List<ServiceInfo>> clusters = clusterControllerClusters(application);\n+        Map<ClusterId, CompletableFuture<ClusterReindexing>> futureStatusPerCluster = new HashMap<>();\n+        clusters.forEach((clusterId, clusterNodes) -> {\n+            var parallelRequests = clusterNodes.stream()\n+                    .map(this::getReindexingStatus)\n+                    .collect(Collectors.toList());\n+            CompletableFuture<ClusterReindexing> combinedRequest = CompletableFutures.firstOf(parallelRequests);", "originalCommit": "26429fb170a455760a20e2a9b8a20371c4962f54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyNDkyMA==", "url": "https://github.com/vespa-engine/vespa/pull/15574#discussion_r533624920", "bodyText": "Perhaps we could return status from first successful, if the first to return a response is non-200?", "author": "jonmv", "createdAt": "2020-12-01T18:19:36Z", "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/DefaultClusterReindexingStatusClient.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.config.server.application;\n+\n+import ai.vespa.util.http.VespaAsyncHttpClientBuilder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.yahoo.concurrent.CompletableFutures;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.config.model.api.PortInfo;\n+import com.yahoo.config.model.api.ServiceInfo;\n+import com.yahoo.vespa.applicationmodel.ClusterId;\n+import com.yahoo.vespa.config.server.modelfactory.ModelResult;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpRequests;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\n+import org.apache.hc.client5.http.config.RequestConfig;\n+import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\n+import org.apache.hc.core5.concurrent.FutureCallback;\n+import org.apache.hc.core5.http.HttpStatus;\n+import org.apache.hc.core5.reactor.IOReactorConfig;\n+import org.apache.hc.core5.util.Timeout;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.config.model.api.container.ContainerServiceType.CLUSTERCONTROLLER_CONTAINER;\n+import static com.yahoo.yolean.Exceptions.throwUnchecked;\n+import static com.yahoo.yolean.Exceptions.uncheck;\n+\n+/**\n+ * Retrieves reindexing status from cluster controllers over HTTP\n+ *\n+ * @author bjorncs\n+ */\n+public class DefaultClusterReindexingStatusClient implements ClusterReindexingStatusClient {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private final Executor executor =\n+            Executors.newSingleThreadExecutor(new DaemonThreadFactory(\"cluster-controller-reindexing-client-\"));\n+    private final CloseableHttpAsyncClient httpClient = createHttpClient();\n+\n+    public DefaultClusterReindexingStatusClient() {\n+        httpClient.start();\n+    }\n+\n+    @Override\n+    public Map<String, ClusterReindexing> getReindexingStatus(ModelResult application) throws IOException {\n+        Map<ClusterId, List<ServiceInfo>> clusters = clusterControllerClusters(application);\n+        Map<ClusterId, CompletableFuture<ClusterReindexing>> futureStatusPerCluster = new HashMap<>();\n+        clusters.forEach((clusterId, clusterNodes) -> {\n+            var parallelRequests = clusterNodes.stream()\n+                    .map(this::getReindexingStatus)\n+                    .collect(Collectors.toList());\n+            CompletableFuture<ClusterReindexing> combinedRequest = CompletableFutures.firstOf(parallelRequests);\n+            futureStatusPerCluster.put(clusterId, combinedRequest);\n+        });\n+\n+        try {\n+            Map<String, ClusterReindexing> statusPerCluster = new HashMap<>();\n+            futureStatusPerCluster.forEach((clusterId, futureStatus) -> {\n+                statusPerCluster.put(clusterId.s(), futureStatus.join());\n+            });\n+            return statusPerCluster;\n+        } catch (Exception e) {\n+            throw new IOException(\"Failed to get reindexing status from cluster controllers: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override public void close() { uncheck(() -> httpClient.close()); }\n+\n+    private CompletableFuture<ClusterReindexing> getReindexingStatus(ServiceInfo service) {\n+        URI uri = URI.create(String.format(\"http://%s:%d/reindexing/v1/status\", service.getHostName(), getStatePort(service)));\n+        CompletableFuture<SimpleHttpResponse> responsePromise = new CompletableFuture<>();\n+        httpClient.execute(SimpleHttpRequests.get(uri), new FutureCallback<>() {\n+            @Override public void completed(SimpleHttpResponse result) { responsePromise.complete(result); }\n+            @Override public void failed(Exception ex) { responsePromise.completeExceptionally(ex); }\n+            @Override public void cancelled() { responsePromise.cancel(false); }\n+        });\n+        return responsePromise.handleAsync((response, error) ->  {\n+            if (response != null) {\n+                return uncheck(() -> toClusterReindexing(response));\n+            } else {\n+                throw throwUnchecked(new IOException(String.format(\"For '%s': %s\", uri, error.getMessage()), error));\n+            }\n+        }, executor);\n+    }\n+\n+    private static ClusterReindexing toClusterReindexing(SimpleHttpResponse response) throws IOException {\n+        if (response.getCode() != HttpStatus.SC_OK) throw new IOException(\"Expected status code 200, got \" + response.getCode());", "originalCommit": "26429fb170a455760a20e2a9b8a20371c4962f54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyNTg2MA==", "url": "https://github.com/vespa-engine/vespa/pull/15574#discussion_r533625860", "bodyText": "Whenever I see property and name in the same sentence I get really excited :)))", "author": "jonmv", "createdAt": "2020-12-01T18:21:05Z", "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/DefaultClusterReindexingStatusClient.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.config.server.application;\n+\n+import ai.vespa.util.http.VespaAsyncHttpClientBuilder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.yahoo.concurrent.CompletableFutures;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.config.model.api.PortInfo;\n+import com.yahoo.config.model.api.ServiceInfo;\n+import com.yahoo.vespa.applicationmodel.ClusterId;\n+import com.yahoo.vespa.config.server.modelfactory.ModelResult;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpRequests;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\n+import org.apache.hc.client5.http.config.RequestConfig;\n+import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\n+import org.apache.hc.core5.concurrent.FutureCallback;\n+import org.apache.hc.core5.http.HttpStatus;\n+import org.apache.hc.core5.reactor.IOReactorConfig;\n+import org.apache.hc.core5.util.Timeout;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.config.model.api.container.ContainerServiceType.CLUSTERCONTROLLER_CONTAINER;\n+import static com.yahoo.yolean.Exceptions.throwUnchecked;\n+import static com.yahoo.yolean.Exceptions.uncheck;\n+\n+/**\n+ * Retrieves reindexing status from cluster controllers over HTTP\n+ *\n+ * @author bjorncs\n+ */\n+public class DefaultClusterReindexingStatusClient implements ClusterReindexingStatusClient {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private final Executor executor =\n+            Executors.newSingleThreadExecutor(new DaemonThreadFactory(\"cluster-controller-reindexing-client-\"));\n+    private final CloseableHttpAsyncClient httpClient = createHttpClient();\n+\n+    public DefaultClusterReindexingStatusClient() {\n+        httpClient.start();\n+    }\n+\n+    @Override\n+    public Map<String, ClusterReindexing> getReindexingStatus(ModelResult application) throws IOException {\n+        Map<ClusterId, List<ServiceInfo>> clusters = clusterControllerClusters(application);\n+        Map<ClusterId, CompletableFuture<ClusterReindexing>> futureStatusPerCluster = new HashMap<>();\n+        clusters.forEach((clusterId, clusterNodes) -> {\n+            var parallelRequests = clusterNodes.stream()\n+                    .map(this::getReindexingStatus)\n+                    .collect(Collectors.toList());\n+            CompletableFuture<ClusterReindexing> combinedRequest = CompletableFutures.firstOf(parallelRequests);\n+            futureStatusPerCluster.put(clusterId, combinedRequest);\n+        });\n+\n+        try {\n+            Map<String, ClusterReindexing> statusPerCluster = new HashMap<>();\n+            futureStatusPerCluster.forEach((clusterId, futureStatus) -> {\n+                statusPerCluster.put(clusterId.s(), futureStatus.join());\n+            });\n+            return statusPerCluster;\n+        } catch (Exception e) {\n+            throw new IOException(\"Failed to get reindexing status from cluster controllers: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override public void close() { uncheck(() -> httpClient.close()); }\n+\n+    private CompletableFuture<ClusterReindexing> getReindexingStatus(ServiceInfo service) {\n+        URI uri = URI.create(String.format(\"http://%s:%d/reindexing/v1/status\", service.getHostName(), getStatePort(service)));\n+        CompletableFuture<SimpleHttpResponse> responsePromise = new CompletableFuture<>();\n+        httpClient.execute(SimpleHttpRequests.get(uri), new FutureCallback<>() {\n+            @Override public void completed(SimpleHttpResponse result) { responsePromise.complete(result); }\n+            @Override public void failed(Exception ex) { responsePromise.completeExceptionally(ex); }\n+            @Override public void cancelled() { responsePromise.cancel(false); }\n+        });\n+        return responsePromise.handleAsync((response, error) ->  {\n+            if (response != null) {\n+                return uncheck(() -> toClusterReindexing(response));\n+            } else {\n+                throw throwUnchecked(new IOException(String.format(\"For '%s': %s\", uri, error.getMessage()), error));\n+            }\n+        }, executor);\n+    }\n+\n+    private static ClusterReindexing toClusterReindexing(SimpleHttpResponse response) throws IOException {\n+        if (response.getCode() != HttpStatus.SC_OK) throw new IOException(\"Expected status code 200, got \" + response.getCode());\n+        if (response.getBody() == null) throw new IOException(\"Response has no content\");\n+        return toClusterReindexing(response.getBodyBytes());\n+    }\n+\n+    private static ClusterReindexing toClusterReindexing(byte[] requestBody) throws IOException {\n+        JsonNode jsonNode = mapper.readTree(requestBody);\n+        Map<String, ClusterReindexing.Status> documentStatuses = new HashMap<>();\n+        for (JsonNode statusJson : jsonNode.get(\"status\")) {\n+            String type = statusJson.get(\"type\").textValue();\n+            Instant startedMillis = Instant.ofEpochMilli(statusJson.get(\"startedMillis\").longValue());\n+            Instant endedMillis = Instant.ofEpochMilli(statusJson.get(\"endedMillis\").longValue());\n+            String progressToken = statusJson.get(\"progress\").textValue();\n+            ClusterReindexing.State state = ClusterReindexing.State.fromString(statusJson.get(\"state\").textValue());\n+            String message = statusJson.get(\"message\").textValue();\n+            documentStatuses.put(type, new ClusterReindexing.Status(startedMillis, endedMillis, state, message, progressToken));\n+        }\n+        return new ClusterReindexing(documentStatuses);\n+    }\n+\n+    private static int getStatePort(ServiceInfo service) {\n+        return service.getPorts().stream()\n+                .filter(port -> port.getTags().contains(\"state\"))\n+                .map(PortInfo::getPort)\n+                .findAny()\n+                .orElseThrow(() -> new IllegalStateException(\"Cluster controller container has no container port\"));\n+    }\n+\n+    private static Map<ClusterId, List<ServiceInfo>> clusterControllerClusters(ModelResult application) {\n+        return application.getModel().getHosts().stream()\n+                .flatMap(host -> host.getServices().stream())\n+                .filter(service -> service.getServiceType().equals(CLUSTERCONTROLLER_CONTAINER.serviceName))\n+                .collect(Collectors.groupingBy(service -> new ClusterId(service.getProperty(\"clustername\").get())));", "originalCommit": "26429fb170a455760a20e2a9b8a20371c4962f54", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}