{"pr_number": 15183, "pr_title": "Distinguish between \"no opinion\" and \"keep current allocation\"", "pr_createdAt": "2020-11-04T21:09:28Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/15183", "timeline": [{"oid": "318f9e54453f4fa5e8e0337f2054bd0fc309906e", "url": "https://github.com/vespa-engine/vespa/commit/318f9e54453f4fa5e8e0337f2054bd0fc309906e", "message": "Distinguish between \"no opinion\" and \"keep current allocation\"\n\nThis is necessary when multiple config servers runs autoscaling in\nparallel and redeployment takes along time.", "committedDate": "2020-11-04T21:07:30Z", "type": "commit"}, {"oid": "bf20b55ec384aac5810dc7dcc1ba2653328730ce", "url": "https://github.com/vespa-engine/vespa/commit/bf20b55ec384aac5810dc7dcc1ba2653328730ce", "message": "Add javadoc", "committedDate": "2020-11-04T21:13:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY0Nzg1Nw==", "url": "https://github.com/vespa-engine/vespa/pull/15183#discussion_r517647857", "bodyText": "Shouldn't this return currentAllocation?\nIn the case this is meant to fix:\n\ncfg1 calculates a new target, t1, and deploys with it\ncfg2 decides that the new target, t2, which is not sufficiently different from the current, so it returns empty, which means that target t1 is cleared\nOn the next deploy, on any cfg: There is no target and the nodes provisioned with t1 are not yet active, so it will revert back to the previous target (per NodeRepositoryProvsioner::currentResources)", "author": "freva", "createdAt": "2020-11-04T21:42:19Z", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/autoscale/Autoscaler.java", "diffHunk": "@@ -70,14 +66,14 @@ public Autoscaler(MetricsDb metricsDb, NodeRepository nodeRepository) {\n         Optional<Double> cpuLoad    = clusterTimeseries.averageLoad(Resource.cpu);\n         Optional<Double> memoryLoad = clusterTimeseries.averageLoad(Resource.memory);\n         Optional<Double> diskLoad   = clusterTimeseries.averageLoad(Resource.disk);\n-        if (cpuLoad.isEmpty() || memoryLoad.isEmpty() || diskLoad.isEmpty()) return Optional.empty();\n+        if (cpuLoad.isEmpty() || memoryLoad.isEmpty() || diskLoad.isEmpty()) return Advice.none();\n         var target = ResourceTarget.idealLoad(cpuLoad.get(), memoryLoad.get(), diskLoad.get(), currentAllocation);\n \n         Optional<AllocatableClusterResources> bestAllocation =\n                 allocationOptimizer.findBestAllocation(target, currentAllocation, limits, exclusive);\n-        if (bestAllocation.isEmpty()) return Optional.empty();\n-        if (similar(bestAllocation.get(), currentAllocation)) return Optional.empty();\n-        return bestAllocation;\n+        if (bestAllocation.isEmpty()) return Advice.dontScale();\n+        if (similar(bestAllocation.get(), currentAllocation)) return Advice.dontScale();", "originalCommit": "bf20b55ec384aac5810dc7dcc1ba2653328730ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY2ODYwMg==", "url": "https://github.com/vespa-engine/vespa/pull/15183#discussion_r517668602", "bodyText": "Current isn't the current target but the current allocation (active nodes).", "author": "bratseth", "createdAt": "2020-11-04T22:28:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY0Nzg1Nw=="}], "type": "inlineReview", "revised_code": null}]}