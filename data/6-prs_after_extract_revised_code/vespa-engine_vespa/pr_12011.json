{"pr_number": 12011, "pr_title": "use refreshed certificates when available (and feature flag is set)", "pr_createdAt": "2020-01-30T13:50:37Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/12011", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk2MDA1OA==", "url": "https://github.com/vespa-engine/vespa/pull/12011#discussion_r372960058", "bodyText": "This will select the highest keyversion and certversion. We should only consider cert since we might be in the middle of a refresh (where keyversion might be incremented, but certversion still not ready)", "author": "tokle", "createdAt": "2020-01-30T13:54:55Z", "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java", "diffHunk": "@@ -42,32 +51,58 @@\n     private final SecretStore secretStore;\n     private final ApplicationCertificateProvider applicationCertificateProvider;\n     private final Clock clock;\n+    private final FlagSource flagSource;\n \n     public EndpointCertificateManager(ZoneRegistry zoneRegistry,\n                                       CuratorDb curator,\n                                       SecretStore secretStore,\n                                       ApplicationCertificateProvider applicationCertificateProvider,\n-                                      Clock clock) {\n+                                      Clock clock, FlagSource flagSource) {\n         this.zoneRegistry = zoneRegistry;\n         this.curator = curator;\n         this.secretStore = secretStore;\n         this.applicationCertificateProvider = applicationCertificateProvider;\n         this.clock = clock;\n+        this.flagSource = flagSource;\n     }\n \n     public Optional<EndpointCertificateMetadata> getEndpointCertificateMetadata(Instance instance, ZoneId zone) {\n \n         if (!zoneRegistry.zones().directlyRouted().ids().contains(zone)) return Optional.empty();\n \n-        // Re-use certificate if already provisioned\n-        Optional<EndpointCertificateMetadata> endpointCertificateMetadata =\n+        // Re-use existing certificate if already provisioned\n+        var endpointCertificateMetadata =\n                 curator.readEndpointCertificateMetadata(instance.id())\n-                        .or(() -> Optional.of(provisionEndpointCertificate(instance)));\n+                        .orElse(provisionEndpointCertificate(instance));\n+\n+        // If feature flag set for application, look for and use refreshed certificate\n+        var useRefreshedEndpointCertificate = Flags.USE_REFRESHED_ENDPOINT_CERTIFICATE.bindTo(flagSource);\n+        if (useRefreshedEndpointCertificate.with(FetchVector.Dimension.APPLICATION_ID, instance.id().serializedForm()).value()) {\n+            var latestAvailableVersion = greatestVersionInSecretStore(endpointCertificateMetadata);\n+\n+            if (latestAvailableVersion.isPresent() && latestAvailableVersion.getAsInt() > endpointCertificateMetadata.version()) {\n+                var refreshedCertificateMetadata = new EndpointCertificateMetadata(\n+                        endpointCertificateMetadata.keyName(),\n+                        endpointCertificateMetadata.certName(),\n+                        latestAvailableVersion.getAsInt()\n+                );\n+\n+                if (verifyEndpointCertificate(refreshedCertificateMetadata, instance, zone, \"Did not refresh, problems with refreshed certificate: \"))\n+                    return Optional.of(refreshedCertificateMetadata);\n+            }\n+        }\n+\n+        // Only log warnings\n+        verifyEndpointCertificate(endpointCertificateMetadata, instance, zone, \"Problems while verifying certificate: \");\n+\n+        return Optional.of(endpointCertificateMetadata);\n+    }\n \n-        // Only logs warnings for now\n-        endpointCertificateMetadata.ifPresent(certificateMetadata -> verifyEndpointCertificate(certificateMetadata, instance, zone));\n+    private OptionalInt greatestVersionInSecretStore(EndpointCertificateMetadata originalCertificateMetadata) {\n+        var certVersions = new HashSet<>(secretStore.listSecretVersions(originalCertificateMetadata.certName()));\n+        var keyVersions = new HashSet<>(secretStore.listSecretVersions(originalCertificateMetadata.keyName()));\n \n-        return endpointCertificateMetadata;\n+        return Sets.union(certVersions, keyVersions).stream().mapToInt(Integer::intValue).max();", "originalCommit": "edb072d91c404d74a2c0cedc564a38e4f7a4dbac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "477cb81f22b2ec9c62427e64d1ac7f07076d1cab", "chunk": "diff --git a/controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java b/controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java\nindex 8ca741a1fa..27af226327 100644\n--- a/controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java\n+++ b/controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java\n\n@@ -102,7 +102,7 @@ public class EndpointCertificateManager {\n         var certVersions = new HashSet<>(secretStore.listSecretVersions(originalCertificateMetadata.certName()));\n         var keyVersions = new HashSet<>(secretStore.listSecretVersions(originalCertificateMetadata.keyName()));\n \n-        return Sets.union(certVersions, keyVersions).stream().mapToInt(Integer::intValue).max();\n+        return Sets.intersection(certVersions, keyVersions).stream().mapToInt(Integer::intValue).max();\n     }\n \n     private EndpointCertificateMetadata provisionEndpointCertificate(Instance instance) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk2MjAzNQ==", "url": "https://github.com/vespa-engine/vespa/pull/12011#discussion_r372962035", "bodyText": "Consider moving this to the constructor.", "author": "tokle", "createdAt": "2020-01-30T13:58:35Z", "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java", "diffHunk": "@@ -42,32 +51,58 @@\n     private final SecretStore secretStore;\n     private final ApplicationCertificateProvider applicationCertificateProvider;\n     private final Clock clock;\n+    private final FlagSource flagSource;\n \n     public EndpointCertificateManager(ZoneRegistry zoneRegistry,\n                                       CuratorDb curator,\n                                       SecretStore secretStore,\n                                       ApplicationCertificateProvider applicationCertificateProvider,\n-                                      Clock clock) {\n+                                      Clock clock, FlagSource flagSource) {\n         this.zoneRegistry = zoneRegistry;\n         this.curator = curator;\n         this.secretStore = secretStore;\n         this.applicationCertificateProvider = applicationCertificateProvider;\n         this.clock = clock;\n+        this.flagSource = flagSource;\n     }\n \n     public Optional<EndpointCertificateMetadata> getEndpointCertificateMetadata(Instance instance, ZoneId zone) {\n \n         if (!zoneRegistry.zones().directlyRouted().ids().contains(zone)) return Optional.empty();\n \n-        // Re-use certificate if already provisioned\n-        Optional<EndpointCertificateMetadata> endpointCertificateMetadata =\n+        // Re-use existing certificate if already provisioned\n+        var endpointCertificateMetadata =\n                 curator.readEndpointCertificateMetadata(instance.id())\n-                        .or(() -> Optional.of(provisionEndpointCertificate(instance)));\n+                        .orElse(provisionEndpointCertificate(instance));\n+\n+        // If feature flag set for application, look for and use refreshed certificate\n+        var useRefreshedEndpointCertificate = Flags.USE_REFRESHED_ENDPOINT_CERTIFICATE.bindTo(flagSource);", "originalCommit": "edb072d91c404d74a2c0cedc564a38e4f7a4dbac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "477cb81f22b2ec9c62427e64d1ac7f07076d1cab", "chunk": "diff --git a/controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java b/controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java\nindex 8ca741a1fa..27af226327 100644\n--- a/controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java\n+++ b/controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java\n\n@@ -102,7 +102,7 @@ public class EndpointCertificateManager {\n         var certVersions = new HashSet<>(secretStore.listSecretVersions(originalCertificateMetadata.certName()));\n         var keyVersions = new HashSet<>(secretStore.listSecretVersions(originalCertificateMetadata.keyName()));\n \n-        return Sets.union(certVersions, keyVersions).stream().mapToInt(Integer::intValue).max();\n+        return Sets.intersection(certVersions, keyVersions).stream().mapToInt(Integer::intValue).max();\n     }\n \n     private EndpointCertificateMetadata provisionEndpointCertificate(Instance instance) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk2MjQ2Mg==", "url": "https://github.com/vespa-engine/vespa/pull/12011#discussion_r372962462", "bodyText": "rename greatest -> latest ?", "author": "tokle", "createdAt": "2020-01-30T13:59:14Z", "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java", "diffHunk": "@@ -42,32 +51,58 @@\n     private final SecretStore secretStore;\n     private final ApplicationCertificateProvider applicationCertificateProvider;\n     private final Clock clock;\n+    private final FlagSource flagSource;\n \n     public EndpointCertificateManager(ZoneRegistry zoneRegistry,\n                                       CuratorDb curator,\n                                       SecretStore secretStore,\n                                       ApplicationCertificateProvider applicationCertificateProvider,\n-                                      Clock clock) {\n+                                      Clock clock, FlagSource flagSource) {\n         this.zoneRegistry = zoneRegistry;\n         this.curator = curator;\n         this.secretStore = secretStore;\n         this.applicationCertificateProvider = applicationCertificateProvider;\n         this.clock = clock;\n+        this.flagSource = flagSource;\n     }\n \n     public Optional<EndpointCertificateMetadata> getEndpointCertificateMetadata(Instance instance, ZoneId zone) {\n \n         if (!zoneRegistry.zones().directlyRouted().ids().contains(zone)) return Optional.empty();\n \n-        // Re-use certificate if already provisioned\n-        Optional<EndpointCertificateMetadata> endpointCertificateMetadata =\n+        // Re-use existing certificate if already provisioned\n+        var endpointCertificateMetadata =\n                 curator.readEndpointCertificateMetadata(instance.id())\n-                        .or(() -> Optional.of(provisionEndpointCertificate(instance)));\n+                        .orElse(provisionEndpointCertificate(instance));\n+\n+        // If feature flag set for application, look for and use refreshed certificate\n+        var useRefreshedEndpointCertificate = Flags.USE_REFRESHED_ENDPOINT_CERTIFICATE.bindTo(flagSource);\n+        if (useRefreshedEndpointCertificate.with(FetchVector.Dimension.APPLICATION_ID, instance.id().serializedForm()).value()) {\n+            var latestAvailableVersion = greatestVersionInSecretStore(endpointCertificateMetadata);\n+\n+            if (latestAvailableVersion.isPresent() && latestAvailableVersion.getAsInt() > endpointCertificateMetadata.version()) {\n+                var refreshedCertificateMetadata = new EndpointCertificateMetadata(\n+                        endpointCertificateMetadata.keyName(),\n+                        endpointCertificateMetadata.certName(),\n+                        latestAvailableVersion.getAsInt()\n+                );\n+\n+                if (verifyEndpointCertificate(refreshedCertificateMetadata, instance, zone, \"Did not refresh, problems with refreshed certificate: \"))\n+                    return Optional.of(refreshedCertificateMetadata);\n+            }\n+        }\n+\n+        // Only log warnings\n+        verifyEndpointCertificate(endpointCertificateMetadata, instance, zone, \"Problems while verifying certificate: \");\n+\n+        return Optional.of(endpointCertificateMetadata);\n+    }\n \n-        // Only logs warnings for now\n-        endpointCertificateMetadata.ifPresent(certificateMetadata -> verifyEndpointCertificate(certificateMetadata, instance, zone));\n+    private OptionalInt greatestVersionInSecretStore(EndpointCertificateMetadata originalCertificateMetadata) {", "originalCommit": "edb072d91c404d74a2c0cedc564a38e4f7a4dbac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "477cb81f22b2ec9c62427e64d1ac7f07076d1cab", "chunk": "diff --git a/controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java b/controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java\nindex 8ca741a1fa..27af226327 100644\n--- a/controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java\n+++ b/controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java\n\n@@ -102,7 +102,7 @@ public class EndpointCertificateManager {\n         var certVersions = new HashSet<>(secretStore.listSecretVersions(originalCertificateMetadata.certName()));\n         var keyVersions = new HashSet<>(secretStore.listSecretVersions(originalCertificateMetadata.keyName()));\n \n-        return Sets.union(certVersions, keyVersions).stream().mapToInt(Integer::intValue).max();\n+        return Sets.intersection(certVersions, keyVersions).stream().mapToInt(Integer::intValue).max();\n     }\n \n     private EndpointCertificateMetadata provisionEndpointCertificate(Instance instance) {\n"}}, {"oid": "1d83371f0eff1f9ee4cc42db705d5ec32bddfe92", "url": "https://github.com/vespa-engine/vespa/commit/1d83371f0eff1f9ee4cc42db705d5ec32bddfe92", "message": "use refreshed certificates when available (and feature flag is set)", "committedDate": "2020-01-30T14:00:57Z", "type": "commit"}, {"oid": "1d83371f0eff1f9ee4cc42db705d5ec32bddfe92", "url": "https://github.com/vespa-engine/vespa/commit/1d83371f0eff1f9ee4cc42db705d5ec32bddfe92", "message": "use refreshed certificates when available (and feature flag is set)", "committedDate": "2020-01-30T14:00:57Z", "type": "forcePushed"}, {"oid": "477cb81f22b2ec9c62427e64d1ac7f07076d1cab", "url": "https://github.com/vespa-engine/vespa/commit/477cb81f22b2ec9c62427e64d1ac7f07076d1cab", "message": "look at intersection of key/cert versions, not union ...", "committedDate": "2020-01-30T14:04:59Z", "type": "commit"}, {"oid": "7b7925115a7177ff5220787d0e1f92fb288a81e3", "url": "https://github.com/vespa-engine/vespa/commit/7b7925115a7177ff5220787d0e1f92fb288a81e3", "message": "find latest key/cert version, not greatest", "committedDate": "2020-01-30T14:07:44Z", "type": "commit"}, {"oid": "e544725b3de5044ca0b2e8af3c60479ba3216718", "url": "https://github.com/vespa-engine/vespa/commit/e544725b3de5044ca0b2e8af3c60479ba3216718", "message": "bind flag in constructor", "committedDate": "2020-01-30T14:07:59Z", "type": "commit"}, {"oid": "580f13711f075d584806e2969eefb7fb8c11ea66", "url": "https://github.com/vespa-engine/vespa/commit/580f13711f075d584806e2969eefb7fb8c11ea66", "message": "whitespace fix", "committedDate": "2020-01-30T14:33:15Z", "type": "commit"}, {"oid": "3c73cda13478d182dfedeee61e802df35889a48c", "url": "https://github.com/vespa-engine/vespa/commit/3c73cda13478d182dfedeee61e802df35889a48c", "message": "don't provision certificate if we already have one ...", "committedDate": "2020-01-30T15:05:48Z", "type": "commit"}]}