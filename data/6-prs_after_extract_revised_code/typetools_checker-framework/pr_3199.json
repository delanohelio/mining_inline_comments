{"pr_number": 3199, "pr_title": "Returns Receiver Checker", "pr_createdAt": "2020-03-26T20:09:27Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3199", "timeline": [{"oid": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "url": "https://github.com/typetools/checker-framework/commit/e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "message": "add method ref test", "committedDate": "2020-04-23T04:20:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTA2NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r414901065", "bodyText": "You could meta-annotate all your qualifiers as org.checkerframework.framework.qual.TargetLocations for RETURN and RECEIVER. The annotation isn't enforced yet, but it might already be good documentation.", "author": "wmdietl", "createdAt": "2020-04-24T22:37:47Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return type, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent\n+ * to:\n+ *\n+ * <pre><code>\n+ * &#064;This MyBuilder setName(@This MyBuilder this, String name) {\n+ *   this.name = name;\n+ *   return this;\n+ * }\n+ * </code></pre>\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ * @checker_framework.manual #qualifier-polymorphism Qualifier polymorphism\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})", "originalCommit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwNTA0Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416305042", "bodyText": "It is also allowed in a downcast.  Would that be prohibited if we add the @TargetLocations meta-annotation?", "author": "msridhar", "createdAt": "2020-04-28T03:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0NjMwMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416746301", "bodyText": "I went ahead and added the @TargetLocations annotation, under the assumption that a qualifier is always allowed to appear in a downcast", "author": "msridhar", "createdAt": "2020-04-28T16:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTA2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java\nindex 90fb40393..a2206be62 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java\n\n@@ -4,7 +4,9 @@ import java.lang.annotation.ElementType;\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.DefaultFor;\n import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n \n /**\n  * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n"}}, {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "url": "https://github.com/typetools/checker-framework/commit/0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "message": "Modified @This declaration", "committedDate": "2020-04-27T21:10:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1Nzk2Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416157966", "bodyText": "Please delete this code rather than commenting it out", "author": "msridhar", "createdAt": "2020-04-27T21:22:30Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            //            // If return type is annotated with @This, add @This annotation", "originalCommit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "37668822ca8f01dc2be35df6dae920ed4451eec4", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\nindex ce112ac44..f5ad162b3 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n\n@@ -14,6 +14,7 @@ import org.checkerframework.framework.type.AnnotatedTypeMirror;\n import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n \n /** The type factory for the Returns Receiver Checker. */\n public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1OTA1Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416159052", "bodyText": "What is the error in this file?  I don't see any method references", "author": "msridhar", "createdAt": "2020-04-27T21:24:12Z", "path": "framework/tests/all-systems/java8/lambda/Issue450.java", "diffHunk": "@@ -1,3 +1,4 @@\n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\") // See Issue #2931", "originalCommit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "37668822ca8f01dc2be35df6dae920ed4451eec4", "chunk": "diff --git a/framework/tests/all-systems/java8/lambda/Issue450.java b/framework/tests/all-systems/java8/lambda/Issue450.java\nindex a0c0341df..ed4cdb868 100644\n--- a/framework/tests/all-systems/java8/lambda/Issue450.java\n+++ b/framework/tests/all-systems/java8/lambda/Issue450.java\n\n@@ -1,4 +1,3 @@\n-@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\") // See Issue #2931\n class Issue450 {\n \n     Issue450(int i, Runnable... runnables) {}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1OTMwOA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416159308", "bodyText": "Please include // See Issue #2931 at the end of the line.  Also can you move the suppression just before the specific line causing the problem?  You should be able to write a @SuppressWarnings annotation just before a method declaration", "author": "msridhar", "createdAt": "2020-04-27T21:24:38Z", "path": "framework/tests/all-systems/java8/memberref/MemberReferences.java", "diffHunk": "@@ -112,6 +112,7 @@ void context(Bound bound) {\n     }\n }\n \n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")", "originalCommit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "37668822ca8f01dc2be35df6dae920ed4451eec4", "chunk": "diff --git a/framework/tests/all-systems/java8/memberref/MemberReferences.java b/framework/tests/all-systems/java8/memberref/MemberReferences.java\nindex e9eb442b6..ab2480150 100644\n--- a/framework/tests/all-systems/java8/memberref/MemberReferences.java\n+++ b/framework/tests/all-systems/java8/memberref/MemberReferences.java\n\n@@ -112,7 +112,6 @@ class Bound {\n     }\n }\n \n-@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")\n class BoundWithArg<U> {\n     void func1(U param) {}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MDAwNA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416160004", "bodyText": "Please include // See Issue #2931 at the end of the line.  Also can you move the suppression just before the specific line causing the problem?  You should be able to write a @SuppressWarnings annotation just before a method declaration", "author": "msridhar", "createdAt": "2020-04-27T21:25:52Z", "path": "framework/tests/all-systems/java8/memberref/Receivers.java", "diffHunk": "@@ -11,6 +11,7 @@\n     R supply();\n }\n \n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")", "originalCommit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "37668822ca8f01dc2be35df6dae920ed4451eec4", "chunk": "diff --git a/framework/tests/all-systems/java8/memberref/Receivers.java b/framework/tests/all-systems/java8/memberref/Receivers.java\nindex 4c230c702..53437bdc9 100644\n--- a/framework/tests/all-systems/java8/memberref/Receivers.java\n+++ b/framework/tests/all-systems/java8/memberref/Receivers.java\n\n@@ -11,7 +11,6 @@ interface SupplierR<R> {\n     R supply();\n }\n \n-@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")\n class MyClass {\n \n     void take(/*6*/ MyClass this, String s) {}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MDM3Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416160376", "bodyText": "Please include // See Issue #2931 at the end of the line.", "author": "msridhar", "createdAt": "2020-04-27T21:26:22Z", "path": "framework/tests/all-systems/java8inference/Issue1715.java", "diffHunk": "@@ -1,6 +1,7 @@\n import java.util.List;\n import java.util.function.Function;\n \n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")", "originalCommit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "37668822ca8f01dc2be35df6dae920ed4451eec4", "chunk": "diff --git a/framework/tests/all-systems/java8inference/Issue1715.java b/framework/tests/all-systems/java8inference/Issue1715.java\nindex 45227fd42..f5e1aed84 100644\n--- a/framework/tests/all-systems/java8inference/Issue1715.java\n+++ b/framework/tests/all-systems/java8inference/Issue1715.java\n\n@@ -1,7 +1,6 @@\n import java.util.List;\n import java.util.function.Function;\n \n-@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")\n public class Issue1715 {\n \n     static final class A {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MTU3NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416161575", "bodyText": "This is not a valid error.  We should either use @SuppressWarnings or add a comment indicating this is not a valid error, pointing to #2931", "author": "msridhar", "createdAt": "2020-04-27T21:28:24Z", "path": "framework/tests/returnsreceiverlombok/BuilderMethodRef.java", "diffHunk": "@@ -0,0 +1,31 @@\n+import java.util.Optional;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import org.checkerframework.common.returnsreceiver.qual.*;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderMethodRef {\n+    @Getter @Setter @lombok.NonNull String foo;\n+    @Getter @Setter Object bar;\n+\n+    public static void test(Optional<Object> opt) {\n+        BuilderMethodRefBuilder b = builder().foo(\"Hello\");\n+        // :: error: (methodref.receiver.bound.invalid)", "originalCommit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "37668822ca8f01dc2be35df6dae920ed4451eec4", "chunk": "diff --git a/framework/tests/returnsreceiverlombok/BuilderMethodRef.java b/framework/tests/returnsreceiverlombok/BuilderMethodRef.java\nindex baf916224..6fb9093dc 100644\n--- a/framework/tests/returnsreceiverlombok/BuilderMethodRef.java\n+++ b/framework/tests/returnsreceiverlombok/BuilderMethodRef.java\n\n@@ -13,7 +13,6 @@ public class BuilderMethodRef {\n \n     public static void test(Optional<Object> opt) {\n         BuilderMethodRefBuilder b = builder().foo(\"Hello\");\n-        // :: error: (methodref.receiver.bound.invalid)\n         opt.ifPresent(b::bar);\n         b.build();\n     }\n"}}, {"oid": "37668822ca8f01dc2be35df6dae920ed4451eec4", "url": "https://github.com/typetools/checker-framework/commit/37668822ca8f01dc2be35df6dae920ed4451eec4", "message": "Revert \"Modified @This declaration\"\n\nThis reverts commit 0fd9d340e568332c0c33346e1d9c2e2e05b17ec2.", "committedDate": "2020-04-28T01:58:35Z", "type": "commit"}, {"oid": "ba6c8cb4c06191abd19265bf006b92e2d1e13bb9", "url": "https://github.com/typetools/checker-framework/commit/ba6c8cb4c06191abd19265bf006b92e2d1e13bb9", "message": "comments on why we don't use @DefaultFor(RECEIVER)", "committedDate": "2020-04-28T03:14:38Z", "type": "commit"}, {"oid": "8fc8625f339a3090951413d14b87a9fed718b164", "url": "https://github.com/typetools/checker-framework/commit/8fc8625f339a3090951413d14b87a9fed718b164", "message": "Allow writing @This on receiver type", "committedDate": "2020-04-28T03:30:25Z", "type": "commit"}, {"oid": "74e562cf35bad6b7526b5f58c612f009458777e0", "url": "https://github.com/typetools/checker-framework/commit/74e562cf35bad6b7526b5f58c612f009458777e0", "message": "disallow @This on return type of static method", "committedDate": "2020-04-28T03:41:35Z", "type": "commit"}, {"oid": "33306f3d1f3914fa185f4d0f87a0e7e4a82c468d", "url": "https://github.com/typetools/checker-framework/commit/33306f3d1f3914fa185f4d0f87a0e7e4a82c468d", "message": "Merge branch 'master' into returnsrcvr-checker", "committedDate": "2020-04-28T16:02:48Z", "type": "commit"}, {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34", "url": "https://github.com/typetools/checker-framework/commit/0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34", "message": "add @TargetLocations annotation", "committedDate": "2020-04-28T16:16:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjIxMA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416946210", "bodyText": "Use {@code @This} or a link?", "author": "wmdietl", "createdAt": "2020-04-28T21:52:13Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return", "originalCommit": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0bd569d6bb54ef4843f000e75a45ca5ce3192997", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex b52b0ab7a..7d25cd6ec 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -13,15 +13,15 @@ import org.checkerframework.javacutil.TypesUtils;\n \n /**\n  * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n- * is to support fluent API generators so the checker can add @This annotations on method return\n- * types when these generators has been used. To check whether a method is created by any of the\n- * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n- * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ * is to support fluent API generators so the checker can add {@code @This} annotations on method\n+ * return types when these generators has been used. To check whether a method is created by any of\n+ * the generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply\n+ * call the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n  */\n public class FluentAPIGenerator {\n \n     /**\n-     * This is the only public method of this class\n+     * Check if a method was generated by a known fluent API generator and returns its receiver.\n      *\n      * @param t the annotated type of the method signature\n      * @return {@code true} if the method was created by any of the generators defined in {@link\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjY2NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416946664", "bodyText": "I'm not sure that's the best description of the method you could come up with...", "author": "wmdietl", "createdAt": "2020-04-28T21:53:15Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * This is the only public method of this class", "originalCommit": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0bd569d6bb54ef4843f000e75a45ca5ce3192997", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex b52b0ab7a..7d25cd6ec 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -13,15 +13,15 @@ import org.checkerframework.javacutil.TypesUtils;\n \n /**\n  * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n- * is to support fluent API generators so the checker can add @This annotations on method return\n- * types when these generators has been used. To check whether a method is created by any of the\n- * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n- * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ * is to support fluent API generators so the checker can add {@code @This} annotations on method\n+ * return types when these generators has been used. To check whether a method is created by any of\n+ * the generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply\n+ * call the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n  */\n public class FluentAPIGenerator {\n \n     /**\n-     * This is the only public method of this class\n+     * Check if a method was generated by a known fluent API generator and returns its receiver.\n      *\n      * @param t the annotated type of the method signature\n      * @return {@code true} if the method was created by any of the generators defined in {@link\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416949094", "bodyText": "Maybe add the note about the automatic defaulting here also. Maybe file a follow-up issue to keep track of method reference handling and the false positives.", "author": "wmdietl", "createdAt": "2020-04-28T21:58:23Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation\n+            // to the receiver type.", "originalCommit": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MzEyMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416973121", "bodyText": "Do we need an issue separate from #2931?", "author": "msridhar", "createdAt": "2020-04-28T22:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3OTg4MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416979881", "bodyText": "Now that there is a reference to that issue, this is fine.", "author": "wmdietl", "createdAt": "2020-04-28T23:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MDQ5NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416980495", "bodyText": "Oh, there is none here. Can you add one, to make it easier to find all places that should be touched once #2931 is fixed?", "author": "wmdietl", "createdAt": "2020-04-28T23:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MTI4OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416981288", "bodyText": "It's there:  https://github.com/typetools/checker-framework/pull/3199/files#diff-4fedb1e93f819c78e6268bc5f23478b1R82-R83  The GitHub UI is confusing with outdated views", "author": "msridhar", "createdAt": "2020-04-28T23:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MzA4MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416983081", "bodyText": "Oh, I specifically tried to look on a reload and didn't see it... thanks, so that's good then.", "author": "wmdietl", "createdAt": "2020-04-28T23:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}], "type": "inlineReview", "revised_code": {"commit": "0bd569d6bb54ef4843f000e75a45ca5ce3192997", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\nindex 764df7adf..92670a878 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n\n@@ -79,7 +79,8 @@ public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactor\n             }\n \n             // If return type is annotated with @This, add @This annotation\n-            // to the receiver type.\n+            // to the receiver type.  We cannot yet default all receivers to be\n+            // @This due to https://github.com/typetools/checker-framework/issues/2931\n             AnnotationMirror retAnnotation = returnType.getAnnotationInHierarchy(THIS_ANNOTATION);\n             if (retAnnotation != null && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n                 AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n"}}, {"oid": "0bd569d6bb54ef4843f000e75a45ca5ce3192997", "url": "https://github.com/typetools/checker-framework/commit/0bd569d6bb54ef4843f000e75a45ca5ce3192997", "message": "address comments", "committedDate": "2020-04-28T22:56:20Z", "type": "commit"}, {"oid": "cbc22a2451a78beedd97e49a61a4e55762557225", "url": "https://github.com/typetools/checker-framework/commit/cbc22a2451a78beedd97e49a61a4e55762557225", "message": "Fix typo", "committedDate": "2020-04-28T23:14:16Z", "type": "commit"}, {"oid": "0760f52cda8e565368e55c7bfee44678c28509d3", "url": "https://github.com/typetools/checker-framework/commit/0760f52cda8e565368e55c7bfee44678c28509d3", "message": "tweak to manual", "committedDate": "2020-04-29T18:48:57Z", "type": "commit"}, {"oid": "beffa549428ba139408bb29bcdb899941b33294b", "url": "https://github.com/typetools/checker-framework/commit/beffa549428ba139408bb29bcdb899941b33294b", "message": "Initialization", "committedDate": "2020-03-25T18:16:00Z", "type": "commit"}, {"oid": "9b63699b1dcb6aa74e0913a770a3b4012f774428", "url": "https://github.com/typetools/checker-framework/commit/9b63699b1dcb6aa74e0913a770a3b4012f774428", "message": "resolved comments", "committedDate": "2020-03-26T19:35:59Z", "type": "commit"}, {"oid": "bc4298b92e91330a1c62f162bb32956c2018c756", "url": "https://github.com/typetools/checker-framework/commit/bc4298b92e91330a1c62f162bb32956c2018c756", "message": "resolved comments", "committedDate": "2020-03-26T19:41:34Z", "type": "commit"}, {"oid": "a77dd34f6a7a54defb7a186be322f7d276ece232", "url": "https://github.com/typetools/checker-framework/commit/a77dd34f6a7a54defb7a186be322f7d276ece232", "message": "resolved comments", "committedDate": "2020-03-26T20:01:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2ODUzMg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r398968532", "bodyText": "@kelloggm do we want these tests and the test data in returnsrcvr sub-folders?  Or should we keep everything at the top level, in which case we should rename tests, e.g., to ReturnsRcvrAutoValueTest?", "author": "msridhar", "createdAt": "2020-03-27T00:23:33Z", "path": "framework/src/test/java/tests/AutoValueTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package tests;\n+\n+import static org.checkerframework.framework.test.TestConfigurationBuilder.buildDefaultConfiguration;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.List;\n+import org.checkerframework.framework.test.*;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+public class AutoValueTest extends CheckerFrameworkPerDirectoryTest {", "originalCommit": "a77dd34f6a7a54defb7a186be322f7d276ece232", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3Nzc1Nw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399377757", "bodyText": "I think keeping them at the top level is fine, but we should rename them as you suggested. The actual test data should definitely be in a returnsrcvr folder, though", "author": "kelloggm", "createdAt": "2020-03-27T16:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2ODUzMg=="}], "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/test/java/tests/AutoValueTest.java b/framework/src/test/java/tests/ReturnsReceiverAutoValueTest.java\nsimilarity index 78%\nrename from framework/src/test/java/tests/AutoValueTest.java\nrename to framework/src/test/java/tests/ReturnsReceiverAutoValueTest.java\nindex 24c20866e..6318f15d2 100644\n--- a/framework/src/test/java/tests/AutoValueTest.java\n+++ b/framework/src/test/java/tests/ReturnsReceiverAutoValueTest.java\n\n@@ -9,7 +9,8 @@ import java.util.List;\n import org.checkerframework.framework.test.*;\n import org.junit.runners.Parameterized.Parameters;\n \n-public class AutoValueTest extends CheckerFrameworkPerDirectoryTest {\n+/** tests the returns receiver checker's AutoValue integration. */\n+public class ReturnsReceiverAutoValueTest extends CheckerFrameworkPerDirectoryTest {\n \n     private static final ImmutableList<String> ANNOTATION_PROCS =\n             ImmutableList.of(\n"}}, {"oid": "71f08dc67b501f0072ec03a27fa3892c4801d3e1", "url": "https://github.com/typetools/checker-framework/commit/71f08dc67b501f0072ec03a27fa3892c4801d3e1", "message": "test git", "committedDate": "2020-03-27T17:17:25Z", "type": "commit"}, {"oid": "f9f9e3fd725fcca36f0a09656fcb771229d4200d", "url": "https://github.com/typetools/checker-framework/commit/f9f9e3fd725fcca36f0a09656fcb771229d4200d", "message": "test git", "committedDate": "2020-03-27T17:20:38Z", "type": "commit"}, {"oid": "4d347ef8e293aa126c4cdf05d8f91e65d50b860e", "url": "https://github.com/typetools/checker-framework/commit/4d347ef8e293aa126c4cdf05d8f91e65d50b860e", "message": "resolved issues and passed git pre-commit hooks", "committedDate": "2020-03-28T02:05:04Z", "type": "commit"}, {"oid": "aa5e28fdd814f8ca415872b2cb13d3282455c2ed", "url": "https://github.com/typetools/checker-framework/commit/aa5e28fdd814f8ca415872b2cb13d3282455c2ed", "message": "fixed issue with checkBasicStyle task", "committedDate": "2020-03-28T05:21:31Z", "type": "commit"}, {"oid": "415adda9cee3ff9ad56a0e6d1f2cd9ce9734366e", "url": "https://github.com/typetools/checker-framework/commit/415adda9cee3ff9ad56a0e6d1f2cd9ce9734366e", "message": "fixed all-test-jdk8 and all-test-jdk11 jobs in pipeline", "committedDate": "2020-03-28T06:36:20Z", "type": "commit"}, {"oid": "91d0d101663a5731c4d4751c9275fef4a6c7f3ea", "url": "https://github.com/typetools/checker-framework/commit/91d0d101663a5731c4d4751c9275fef4a6c7f3ea", "message": "git test", "committedDate": "2020-03-28T06:50:42Z", "type": "commit"}, {"oid": "e005df3b5c841dbe272b502dc07bab3d2a41af98", "url": "https://github.com/typetools/checker-framework/commit/e005df3b5c841dbe272b502dc07bab3d2a41af98", "message": "fixed checkInterning task", "committedDate": "2020-03-28T07:37:32Z", "type": "commit"}, {"oid": "7690604d845c8331ce3e03232f192a5525f601b6", "url": "https://github.com/typetools/checker-framework/commit/7690604d845c8331ce3e03232f192a5525f601b6", "message": "misc_jdk8", "committedDate": "2020-03-28T08:27:05Z", "type": "commit"}, {"oid": "b98126aa8349b0b61f00841a2bc6f7f6e4d56dc0", "url": "https://github.com/typetools/checker-framework/commit/b98126aa8349b0b61f00841a2bc6f7f6e4d56dc0", "message": "misc_jdk8", "committedDate": "2020-03-28T08:39:37Z", "type": "commit"}, {"oid": "27843ff602ba06a52db49498675e3be561fa1828", "url": "https://github.com/typetools/checker-framework/commit/27843ff602ba06a52db49498675e3be561fa1828", "message": "Merge branch 'master' into returnsrcvr-checker", "committedDate": "2020-03-28T19:08:15Z", "type": "commit"}, {"oid": "5b27d78bfe2a9a74d570a2eac2865b19a5724fad", "url": "https://github.com/typetools/checker-framework/commit/5b27d78bfe2a9a74d570a2eac2865b19a5724fad", "message": "fix javadoc", "committedDate": "2020-03-28T19:17:38Z", "type": "commit"}, {"oid": "8b9f5f03bc186fb0cf0629eb44745ffb90f21346", "url": "https://github.com/typetools/checker-framework/commit/8b9f5f03bc186fb0cf0629eb44745ffb90f21346", "message": "returns receiver manual", "committedDate": "2020-03-28T21:33:17Z", "type": "commit"}, {"oid": "ed02ca65fd427780a729589976818098433543f1", "url": "https://github.com/typetools/checker-framework/commit/ed02ca65fd427780a729589976818098433543f1", "message": "trailing whitespace", "committedDate": "2020-03-28T21:34:03Z", "type": "commit"}, {"oid": "9b5171fe0730113b1248680c19a97e5c3c75c953", "url": "https://github.com/typetools/checker-framework/commit/9b5171fe0730113b1248680c19a97e5c3c75c953", "message": "Add final newline", "committedDate": "2020-03-29T00:28:07Z", "type": "commit"}, {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "url": "https://github.com/typetools/checker-framework/commit/5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "message": "Capitalization fixes", "committedDate": "2020-03-29T00:37:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzQ5NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399727494", "bodyText": "Each annotation's Javadoc should link to its manual chapter, to enable users to learn more.\nThe bottom type should additionally link to https://checkerframework.org/manual/#bottom-type.\nSee how other qualifiers do this, for example https://checkerframework.org/api/org/checkerframework/checker/nullness/qual/KeyForBottom.html .\nEven more importantly, say what the annotation means.  (The fact that it's the bottom type is relevant but isn't the most important information.)  For example, is null the only value of this type?\nThese comments apply to other annotations as well.", "author": "mernst", "createdAt": "2020-03-29T00:39:58Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/BottomThis.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package org.checkerframework.common.returnsrcvr.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.framework.qual.TargetLocations;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+\n+/** The bottom type for the Returns Receiver Checker's type system. */", "originalCommit": "9b5171fe0730113b1248680c19a97e5c3c75c953", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDMxNjI4OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r400316288", "bodyText": "Hi @mernst, I see this documentation in the manual for other bottom types:\n\nThis is the bottom type for the XYZ type system. It should never need to be written by the programmer.\n\nIs that sufficient here?  I'm honestly not even sure what values (if any) take on the bottom type in the returns receiver type system.", "author": "msridhar", "createdAt": "2020-03-30T16:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzQ5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0NTQwMA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r400345400", "bodyText": "Yes, that is often sufficient.  Usually the only value of the bottom type is null, but sometimes that is different.  Knowing what values helps readers to understand the type.  If you can't figure it out, you could leave that off.", "author": "mernst", "createdAt": "2020-03-30T16:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzQ5NA=="}], "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/BottomThis.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/BottomThis.java\nsimilarity index 61%\nrename from framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/BottomThis.java\nrename to framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/BottomThis.java\nindex 998f55fb1..99dd4fcb5 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/BottomThis.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/BottomThis.java\n\n@@ -1,4 +1,4 @@\n-package org.checkerframework.common.returnsrcvr.qual;\n+package org.checkerframework.common.returnsreceiver.qual;\n \n import java.lang.annotation.ElementType;\n import java.lang.annotation.Retention;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzY5OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399727698", "bodyText": "The @This annotation does not represent a method.  Please rephrase.\nNit: please end sentences with punctuation.", "author": "mernst", "createdAt": "2020-03-29T00:43:17Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/This.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package org.checkerframework.common.returnsrcvr.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/** This represent methods that returns {@code this} */", "originalCommit": "9b5171fe0730113b1248680c19a97e5c3c75c953", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/This.java b/framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/This.java\ndeleted file mode 100644\nindex 0f503eef5..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/This.java\n+++ /dev/null\n\n@@ -1,13 +0,0 @@\n-package org.checkerframework.common.returnsrcvr.qual;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-import org.checkerframework.framework.qual.PolymorphicQualifier;\n-\n-/** This represent methods that returns {@code this} */\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n-@PolymorphicQualifier\n-public @interface This {}\n"}}, {"oid": "f4532df793fc199e7a440efa35c3051b0abc2e6b", "url": "https://github.com/typetools/checker-framework/commit/f4532df793fc199e7a440efa35c3051b0abc2e6b", "message": "Improve naming.  Make switch statements report errors.", "committedDate": "2020-03-29T15:24:30Z", "type": "commit"}, {"oid": "ce4f098f11080d20257088603aae6c1b4a23bc51", "url": "https://github.com/typetools/checker-framework/commit/ce4f098f11080d20257088603aae6c1b4a23bc51", "message": "Remove unnecessary text", "committedDate": "2020-03-29T15:41:40Z", "type": "commit"}, {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5", "url": "https://github.com/typetools/checker-framework/commit/eff17315021c4d2899189b30c6a25149548d5fe5", "message": "Improve naming", "committedDate": "2020-03-29T15:41:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzEwMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813101", "bodyText": "From this documentation, I cannot tell what a FrameworkSupport is.  Documentation for a type should indicate what it represents.  (And possibly should include other information such as how to use it.)\nFrom later reading, I'm not sure why this needs to be an interface with multiple implementations.\nWhy not just have a method in the Returns Receiver Checker that takes a framework as an argument, or takes a list of frameworks as an argument, and has a switch statement and inlines the definitions?  Or why not put the method in the Framework class?  Either of these designs seems simpler than the FrameworkSupport interface.", "author": "mernst", "createdAt": "2020-03-29T15:28:33Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupport.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/** To add support for frameworks that need to have {@code @This} in certain generated methods */", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxNzg4MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r401217880", "bodyText": "Our plan here is to just put the method inside each enum element in the Framework class; thanks for pointing this out.", "author": "msridhar", "createdAt": "2020-03-31T21:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzEwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupport.java b/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupport.java\ndeleted file mode 100644\nindex ab55c7ae0..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupport.java\n+++ /dev/null\n\n@@ -1,12 +0,0 @@\n-package org.checkerframework.common.returnsrcvr.framework;\n-\n-import org.checkerframework.framework.type.AnnotatedTypeMirror;\n-\n-/** To add support for frameworks that need to have {@code @This} in certain generated methods */\n-public interface FrameworkSupport {\n-    /**\n-     * @param t the method to check\n-     * @return {@code true} if the method is generated by framework and returns {@code this}\n-     */\n-    boolean knownToReturnThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzIyNA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813224", "bodyText": "Please indicate what the class does or is used for.  This comment doesn't tell the reader anything that the class name does not.", "author": "mernst", "createdAt": "2020-03-29T15:29:22Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java b/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java\ndeleted file mode 100644\nindex 3d44b9f5a..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java\n+++ /dev/null\n\n@@ -1,71 +0,0 @@\n-package org.checkerframework.common.returnsrcvr.framework;\n-\n-import java.lang.annotation.Annotation;\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n-import org.checkerframework.javacutil.AnnotationUtils;\n-\n-/** A utility class for framework support in returns receiver checker */\n-public class FrameworkSupportUtils {\n-\n-    /** this class is non-instantiable */\n-    private FrameworkSupportUtils() {}\n-\n-    /** enum of supported frameworks */\n-    public enum Framework {\n-        /** Auto Value framework */\n-        AUTO_VALUE,\n-        /** LOMBOK framework */\n-        LOMBOK;\n-    }\n-\n-    /**\n-     * Determine the framework supports that should be disabled according to the flag {@code\n-     * disableFrameworkSupports}, return a EnumSet containing the framework supports in use\n-     *\n-     * @param option a comma-separated list of frameworks whose support should be disabled\n-     * @return an EnumSet of all framework supports in use\n-     */\n-    public static EnumSet<Framework> getFrameworkSet(String option) {\n-        EnumSet<Framework> frameworkSet = EnumSet.allOf(Framework.class);\n-\n-        if (option != null) {\n-            for (String disabledFrameworkSupport : option.split(\"\\\\s?,\\\\s?\")) {\n-                switch (disabledFrameworkSupport.toUpperCase()) {\n-                    case ReturnsRcvrChecker.AUTOVALUE_SUPPORT:\n-                        frameworkSet.remove(Framework.AUTO_VALUE);\n-                        break;\n-                    case ReturnsRcvrChecker.LOMBOK_SUPPORT:\n-                        frameworkSet.remove(Framework.LOMBOK);\n-                        break;\n-                }\n-            }\n-        }\n-        return frameworkSet;\n-    }\n-\n-    /**\n-     * Given an annotation class, return true if the element has the annotation\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClass the class of the annotation that might be present\n-     * @return true if the element has the annotation\n-     */\n-    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByClass(anm, annotClass));\n-    }\n-\n-    /**\n-     * Given an annotation name, return true if the element has the annotation of that name\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClassName the class of the annotation that might be present\n-     * @return true if the element has the annotation of that class\n-     */\n-    public static boolean hasAnnotationByName(Element element, String annotClassName) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotClassName));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzM3MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813370", "bodyText": "If it is non-instantiable, the constructor must throw an error.  Making the constructor return normally lets errors creep in later.", "author": "mernst", "createdAt": "2020-03-29T15:30:24Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java b/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java\ndeleted file mode 100644\nindex 3d44b9f5a..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java\n+++ /dev/null\n\n@@ -1,71 +0,0 @@\n-package org.checkerframework.common.returnsrcvr.framework;\n-\n-import java.lang.annotation.Annotation;\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n-import org.checkerframework.javacutil.AnnotationUtils;\n-\n-/** A utility class for framework support in returns receiver checker */\n-public class FrameworkSupportUtils {\n-\n-    /** this class is non-instantiable */\n-    private FrameworkSupportUtils() {}\n-\n-    /** enum of supported frameworks */\n-    public enum Framework {\n-        /** Auto Value framework */\n-        AUTO_VALUE,\n-        /** LOMBOK framework */\n-        LOMBOK;\n-    }\n-\n-    /**\n-     * Determine the framework supports that should be disabled according to the flag {@code\n-     * disableFrameworkSupports}, return a EnumSet containing the framework supports in use\n-     *\n-     * @param option a comma-separated list of frameworks whose support should be disabled\n-     * @return an EnumSet of all framework supports in use\n-     */\n-    public static EnumSet<Framework> getFrameworkSet(String option) {\n-        EnumSet<Framework> frameworkSet = EnumSet.allOf(Framework.class);\n-\n-        if (option != null) {\n-            for (String disabledFrameworkSupport : option.split(\"\\\\s?,\\\\s?\")) {\n-                switch (disabledFrameworkSupport.toUpperCase()) {\n-                    case ReturnsRcvrChecker.AUTOVALUE_SUPPORT:\n-                        frameworkSet.remove(Framework.AUTO_VALUE);\n-                        break;\n-                    case ReturnsRcvrChecker.LOMBOK_SUPPORT:\n-                        frameworkSet.remove(Framework.LOMBOK);\n-                        break;\n-                }\n-            }\n-        }\n-        return frameworkSet;\n-    }\n-\n-    /**\n-     * Given an annotation class, return true if the element has the annotation\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClass the class of the annotation that might be present\n-     * @return true if the element has the annotation\n-     */\n-    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByClass(anm, annotClass));\n-    }\n-\n-    /**\n-     * Given an annotation name, return true if the element has the annotation of that name\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClassName the class of the annotation that might be present\n-     * @return true if the element has the annotation of that class\n-     */\n-    public static boolean hasAnnotationByName(Element element, String annotClassName) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotClassName));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzQzOA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813438", "bodyText": "Please spell names correctly.  There should be no space in \"AutoValue\".", "author": "mernst", "createdAt": "2020-03-29T15:30:57Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {\n+        /** Auto Value framework */", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java b/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java\ndeleted file mode 100644\nindex 3d44b9f5a..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java\n+++ /dev/null\n\n@@ -1,71 +0,0 @@\n-package org.checkerframework.common.returnsrcvr.framework;\n-\n-import java.lang.annotation.Annotation;\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n-import org.checkerframework.javacutil.AnnotationUtils;\n-\n-/** A utility class for framework support in returns receiver checker */\n-public class FrameworkSupportUtils {\n-\n-    /** this class is non-instantiable */\n-    private FrameworkSupportUtils() {}\n-\n-    /** enum of supported frameworks */\n-    public enum Framework {\n-        /** Auto Value framework */\n-        AUTO_VALUE,\n-        /** LOMBOK framework */\n-        LOMBOK;\n-    }\n-\n-    /**\n-     * Determine the framework supports that should be disabled according to the flag {@code\n-     * disableFrameworkSupports}, return a EnumSet containing the framework supports in use\n-     *\n-     * @param option a comma-separated list of frameworks whose support should be disabled\n-     * @return an EnumSet of all framework supports in use\n-     */\n-    public static EnumSet<Framework> getFrameworkSet(String option) {\n-        EnumSet<Framework> frameworkSet = EnumSet.allOf(Framework.class);\n-\n-        if (option != null) {\n-            for (String disabledFrameworkSupport : option.split(\"\\\\s?,\\\\s?\")) {\n-                switch (disabledFrameworkSupport.toUpperCase()) {\n-                    case ReturnsRcvrChecker.AUTOVALUE_SUPPORT:\n-                        frameworkSet.remove(Framework.AUTO_VALUE);\n-                        break;\n-                    case ReturnsRcvrChecker.LOMBOK_SUPPORT:\n-                        frameworkSet.remove(Framework.LOMBOK);\n-                        break;\n-                }\n-            }\n-        }\n-        return frameworkSet;\n-    }\n-\n-    /**\n-     * Given an annotation class, return true if the element has the annotation\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClass the class of the annotation that might be present\n-     * @return true if the element has the annotation\n-     */\n-    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByClass(anm, annotClass));\n-    }\n-\n-    /**\n-     * Given an annotation name, return true if the element has the annotation of that name\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClassName the class of the annotation that might be present\n-     * @return true if the element has the annotation of that class\n-     */\n-    public static boolean hasAnnotationByName(Element element, String annotClassName) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotClassName));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzQ2MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813461", "bodyText": "Please spell names correctly.", "author": "mernst", "createdAt": "2020-03-29T15:31:11Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {\n+        /** Auto Value framework */\n+        AUTO_VALUE,\n+        /** LOMBOK framework */", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java b/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java\ndeleted file mode 100644\nindex 3d44b9f5a..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java\n+++ /dev/null\n\n@@ -1,71 +0,0 @@\n-package org.checkerframework.common.returnsrcvr.framework;\n-\n-import java.lang.annotation.Annotation;\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n-import org.checkerframework.javacutil.AnnotationUtils;\n-\n-/** A utility class for framework support in returns receiver checker */\n-public class FrameworkSupportUtils {\n-\n-    /** this class is non-instantiable */\n-    private FrameworkSupportUtils() {}\n-\n-    /** enum of supported frameworks */\n-    public enum Framework {\n-        /** Auto Value framework */\n-        AUTO_VALUE,\n-        /** LOMBOK framework */\n-        LOMBOK;\n-    }\n-\n-    /**\n-     * Determine the framework supports that should be disabled according to the flag {@code\n-     * disableFrameworkSupports}, return a EnumSet containing the framework supports in use\n-     *\n-     * @param option a comma-separated list of frameworks whose support should be disabled\n-     * @return an EnumSet of all framework supports in use\n-     */\n-    public static EnumSet<Framework> getFrameworkSet(String option) {\n-        EnumSet<Framework> frameworkSet = EnumSet.allOf(Framework.class);\n-\n-        if (option != null) {\n-            for (String disabledFrameworkSupport : option.split(\"\\\\s?,\\\\s?\")) {\n-                switch (disabledFrameworkSupport.toUpperCase()) {\n-                    case ReturnsRcvrChecker.AUTOVALUE_SUPPORT:\n-                        frameworkSet.remove(Framework.AUTO_VALUE);\n-                        break;\n-                    case ReturnsRcvrChecker.LOMBOK_SUPPORT:\n-                        frameworkSet.remove(Framework.LOMBOK);\n-                        break;\n-                }\n-            }\n-        }\n-        return frameworkSet;\n-    }\n-\n-    /**\n-     * Given an annotation class, return true if the element has the annotation\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClass the class of the annotation that might be present\n-     * @return true if the element has the annotation\n-     */\n-    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByClass(anm, annotClass));\n-    }\n-\n-    /**\n-     * Given an annotation name, return true if the element has the annotation of that name\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClassName the class of the annotation that might be present\n-     * @return true if the element has the annotation of that class\n-     */\n-    public static boolean hasAnnotationByName(Element element, String annotClassName) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotClassName));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzcwNQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813705", "bodyText": "It seems inside-out to make the framework class a nested class and the utilities be the top-level class.\nAlso, why is this an inner class rather than a static nested class?", "author": "mernst", "createdAt": "2020-03-29T15:33:10Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java b/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java\ndeleted file mode 100644\nindex 3d44b9f5a..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java\n+++ /dev/null\n\n@@ -1,71 +0,0 @@\n-package org.checkerframework.common.returnsrcvr.framework;\n-\n-import java.lang.annotation.Annotation;\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n-import org.checkerframework.javacutil.AnnotationUtils;\n-\n-/** A utility class for framework support in returns receiver checker */\n-public class FrameworkSupportUtils {\n-\n-    /** this class is non-instantiable */\n-    private FrameworkSupportUtils() {}\n-\n-    /** enum of supported frameworks */\n-    public enum Framework {\n-        /** Auto Value framework */\n-        AUTO_VALUE,\n-        /** LOMBOK framework */\n-        LOMBOK;\n-    }\n-\n-    /**\n-     * Determine the framework supports that should be disabled according to the flag {@code\n-     * disableFrameworkSupports}, return a EnumSet containing the framework supports in use\n-     *\n-     * @param option a comma-separated list of frameworks whose support should be disabled\n-     * @return an EnumSet of all framework supports in use\n-     */\n-    public static EnumSet<Framework> getFrameworkSet(String option) {\n-        EnumSet<Framework> frameworkSet = EnumSet.allOf(Framework.class);\n-\n-        if (option != null) {\n-            for (String disabledFrameworkSupport : option.split(\"\\\\s?,\\\\s?\")) {\n-                switch (disabledFrameworkSupport.toUpperCase()) {\n-                    case ReturnsRcvrChecker.AUTOVALUE_SUPPORT:\n-                        frameworkSet.remove(Framework.AUTO_VALUE);\n-                        break;\n-                    case ReturnsRcvrChecker.LOMBOK_SUPPORT:\n-                        frameworkSet.remove(Framework.LOMBOK);\n-                        break;\n-                }\n-            }\n-        }\n-        return frameworkSet;\n-    }\n-\n-    /**\n-     * Given an annotation class, return true if the element has the annotation\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClass the class of the annotation that might be present\n-     * @return true if the element has the annotation\n-     */\n-    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByClass(anm, annotClass));\n-    }\n-\n-    /**\n-     * Given an annotation name, return true if the element has the annotation of that name\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClassName the class of the annotation that might be present\n-     * @return true if the element has the annotation of that class\n-     */\n-    public static boolean hasAnnotationByName(Element element, String annotClassName) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotClassName));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzc5NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813794", "bodyText": "Really, if it has an annotation of the given class.", "author": "mernst", "createdAt": "2020-03-29T15:33:41Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {\n+        /** Auto Value framework */\n+        AUTO_VALUE,\n+        /** LOMBOK framework */\n+        LOMBOK;\n+    }\n+\n+    /**\n+     * Determine the framework supports that should be disabled according to the flag {@code\n+     * disableFrameworkSupports}, return a EnumSet containing the framework supports in use\n+     *\n+     * @param option a comma-separated list of frameworks whose support should be disabled\n+     * @return an EnumSet of all framework supports in use\n+     */\n+    public static EnumSet<Framework> getFrameworkSet(String option) {\n+        EnumSet<Framework> frameworkSet = EnumSet.allOf(Framework.class);\n+\n+        if (option != null) {\n+            for (String disabledFrameworkSupport : option.split(\"\\\\s?,\\\\s?\")) {\n+                switch (disabledFrameworkSupport.toUpperCase()) {\n+                    case ReturnsRcvrChecker.AUTOVALUE_SUPPORT:\n+                        frameworkSet.remove(Framework.AUTO_VALUE);\n+                        break;\n+                    case ReturnsRcvrChecker.LOMBOK_SUPPORT:\n+                        frameworkSet.remove(Framework.LOMBOK);\n+                        break;\n+                }\n+            }\n+        }\n+        return frameworkSet;\n+    }\n+\n+    /**\n+     * Given an annotation class, return true if the element has the annotation", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java b/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java\ndeleted file mode 100644\nindex 3d44b9f5a..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java\n+++ /dev/null\n\n@@ -1,71 +0,0 @@\n-package org.checkerframework.common.returnsrcvr.framework;\n-\n-import java.lang.annotation.Annotation;\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n-import org.checkerframework.javacutil.AnnotationUtils;\n-\n-/** A utility class for framework support in returns receiver checker */\n-public class FrameworkSupportUtils {\n-\n-    /** this class is non-instantiable */\n-    private FrameworkSupportUtils() {}\n-\n-    /** enum of supported frameworks */\n-    public enum Framework {\n-        /** Auto Value framework */\n-        AUTO_VALUE,\n-        /** LOMBOK framework */\n-        LOMBOK;\n-    }\n-\n-    /**\n-     * Determine the framework supports that should be disabled according to the flag {@code\n-     * disableFrameworkSupports}, return a EnumSet containing the framework supports in use\n-     *\n-     * @param option a comma-separated list of frameworks whose support should be disabled\n-     * @return an EnumSet of all framework supports in use\n-     */\n-    public static EnumSet<Framework> getFrameworkSet(String option) {\n-        EnumSet<Framework> frameworkSet = EnumSet.allOf(Framework.class);\n-\n-        if (option != null) {\n-            for (String disabledFrameworkSupport : option.split(\"\\\\s?,\\\\s?\")) {\n-                switch (disabledFrameworkSupport.toUpperCase()) {\n-                    case ReturnsRcvrChecker.AUTOVALUE_SUPPORT:\n-                        frameworkSet.remove(Framework.AUTO_VALUE);\n-                        break;\n-                    case ReturnsRcvrChecker.LOMBOK_SUPPORT:\n-                        frameworkSet.remove(Framework.LOMBOK);\n-                        break;\n-                }\n-            }\n-        }\n-        return frameworkSet;\n-    }\n-\n-    /**\n-     * Given an annotation class, return true if the element has the annotation\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClass the class of the annotation that might be present\n-     * @return true if the element has the annotation\n-     */\n-    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByClass(anm, annotClass));\n-    }\n-\n-    /**\n-     * Given an annotation name, return true if the element has the annotation of that name\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClassName the class of the annotation that might be present\n-     * @return true if the element has the annotation of that class\n-     */\n-    public static boolean hasAnnotationByName(Element element, String annotClassName) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotClassName));\n-    }\n-}\n"}}, {"oid": "d13fe35aeee5b038c375da84e9377835b2dd5a84", "url": "https://github.com/typetools/checker-framework/commit/d13fe35aeee5b038c375da84e9377835b2dd5a84", "message": "Fixed contructor throw RuntimeException and javadoc", "committedDate": "2020-03-30T16:24:48Z", "type": "commit"}, {"oid": "fd8c8609a4541267ce05fe26dd3ec335a2823ea4", "url": "https://github.com/typetools/checker-framework/commit/fd8c8609a4541267ce05fe26dd3ec335a2823ea4", "message": "fix misc-jdk8 and misc-jdk11", "committedDate": "2020-03-30T19:33:55Z", "type": "commit"}, {"oid": "85682f77cf4b561fb948799f672369f9238d2fd3", "url": "https://github.com/typetools/checker-framework/commit/85682f77cf4b561fb948799f672369f9238d2fd3", "message": "working on manual", "committedDate": "2020-04-01T17:28:07Z", "type": "commit"}, {"oid": "f897ece84d1d0742df8a5d44218f975ff0a800c0", "url": "https://github.com/typetools/checker-framework/commit/f897ece84d1d0742df8a5d44218f975ff0a800c0", "message": "pass on manual", "committedDate": "2020-04-01T17:38:52Z", "type": "commit"}, {"oid": "2c326d568f2b94e6e3417c27fefac8ad955dab9b", "url": "https://github.com/typetools/checker-framework/commit/2c326d568f2b94e6e3417c27fefac8ad955dab9b", "message": "changed framework support to enums", "committedDate": "2020-04-01T17:41:45Z", "type": "commit"}, {"oid": "65e4454b2d36b6e9a6809ba9b1b2cbadb83aabfd", "url": "https://github.com/typetools/checker-framework/commit/65e4454b2d36b6e9a6809ba9b1b2cbadb83aabfd", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker", "committedDate": "2020-04-01T17:42:00Z", "type": "commit"}, {"oid": "748a84c18498ee263accd07d5107af4927db474d", "url": "https://github.com/typetools/checker-framework/commit/748a84c18498ee263accd07d5107af4927db474d", "message": "remove paragraph on disabling framework support", "committedDate": "2020-04-01T17:50:09Z", "type": "commit"}, {"oid": "30c2d5eb1b0ae317c00bdd89d8fb5c96299d4d34", "url": "https://github.com/typetools/checker-framework/commit/30c2d5eb1b0ae317c00bdd89d8fb5c96299d4d34", "message": "Merge branch 'master' into returnsrcvr-checker", "committedDate": "2020-04-01T21:10:47Z", "type": "commit"}, {"oid": "d1c028fade3062f9cba9fbb3019984ca38b30171", "url": "https://github.com/typetools/checker-framework/commit/d1c028fade3062f9cba9fbb3019984ca38b30171", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker", "committedDate": "2020-04-02T01:13:35Z", "type": "commit"}, {"oid": "482809a6694b522ffd7c97ca7676a5db936c4866", "url": "https://github.com/typetools/checker-framework/commit/482809a6694b522ffd7c97ca7676a5db936c4866", "message": "Rename MaybeThis to UnknownThis.\n\nThe name MaybeThis isn't bad, but the rest of the Checker Framework uses\nthe naming convention \"Unknown\" for the top type.", "committedDate": "2020-04-02T01:28:44Z", "type": "commit"}, {"oid": "cc7a321c3c288e4e3a377edf683fe8f0559b6026", "url": "https://github.com/typetools/checker-framework/commit/cc7a321c3c288e4e3a377edf683fe8f0559b6026", "message": "Improve Javadoc: add explanations, examples, links", "committedDate": "2020-04-02T01:51:44Z", "type": "commit"}, {"oid": "cf31b932ea22fb758a113f144732cb39bdab46fa", "url": "https://github.com/typetools/checker-framework/commit/cf31b932ea22fb758a113f144732cb39bdab46fa", "message": "Edits to manual section", "committedDate": "2020-04-02T02:17:57Z", "type": "commit"}, {"oid": "b8e6b7290aad40d59affcf1e0e2113be79188368", "url": "https://github.com/typetools/checker-framework/commit/b8e6b7290aad40d59affcf1e0e2113be79188368", "message": "Mention terminology \"fluent API\"", "committedDate": "2020-04-02T02:19:05Z", "type": "commit"}, {"oid": "941d35b64856461dca9c5ae04b253f3f9ec66b4e", "url": "https://github.com/typetools/checker-framework/commit/941d35b64856461dca9c5ae04b253f3f9ec66b4e", "message": "Tweak message", "committedDate": "2020-04-02T03:56:38Z", "type": "commit"}, {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "url": "https://github.com/typetools/checker-framework/commit/daafb8f1937dcf9ba1c78f58a69a675465cc62be", "message": "Edits from code review", "committedDate": "2020-04-02T05:19:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3Nzg0OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402277848", "bodyText": "I find it surprising that this block is skipped for constructors, but the above block is not.  What is the reason for the discrepancy?", "author": "mernst", "createdAt": "2020-04-02T12:34:54Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;\n+\n+    /** The supported frameworks (the built-in ones minus any that were disabled). */\n+    Collection<FrameworkSupport> frameworks;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        frameworks =\n+                FrameworkSupportUtils.getSupportedFrameworks(\n+                        checker.getOption(ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT));\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new ReturnsReceiverTypeAnnotator(this));\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+            AnnotationMirror unknownThisAnnot =\n+                    AnnotationBuilder.fromClass(elements, UnknownThis.class);\n+            AnnotationMirror retAnnotation = returnType.getAnnotationInHierarchy(unknownThisAnnot);\n+            if (retAnnotation != null && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n+                // add @This to the receiver type\n+                AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n+                receiverType.replaceAnnotation(THIS_ANNOTATION);\n+            }\n+\n+            // skip constructors\n+            if (!isConstructor(t)) {", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxODcxNw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r404518717", "bodyText": "Restructured the logic so both blocks are skipped for constructors", "author": "msridhar", "createdAt": "2020-04-07T03:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3Nzg0OA=="}], "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\nindex 180282a2a..f5ad162b3 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n\n@@ -1,14 +1,11 @@\n package org.checkerframework.common.returnsreceiver;\n \n import java.lang.annotation.Annotation;\n-import java.util.Collection;\n import java.util.Set;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.element.ElementKind;\n import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n import org.checkerframework.common.basetype.BaseTypeChecker;\n-import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n-import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n import org.checkerframework.common.returnsreceiver.qual.This;\n import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3ODE4OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402278188", "bodyText": "Make a field like THIS_ANNOTATION.", "author": "mernst", "createdAt": "2020-04-02T12:35:29Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;\n+\n+    /** The supported frameworks (the built-in ones minus any that were disabled). */\n+    Collection<FrameworkSupport> frameworks;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        frameworks =\n+                FrameworkSupportUtils.getSupportedFrameworks(\n+                        checker.getOption(ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT));\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new ReturnsReceiverTypeAnnotator(this));\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+            AnnotationMirror unknownThisAnnot =", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\nindex 180282a2a..f5ad162b3 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n\n@@ -1,14 +1,11 @@\n package org.checkerframework.common.returnsreceiver;\n \n import java.lang.annotation.Annotation;\n-import java.util.Collection;\n import java.util.Set;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.element.ElementKind;\n import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n import org.checkerframework.common.basetype.BaseTypeChecker;\n-import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n-import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n import org.checkerframework.common.returnsreceiver.qual.This;\n import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3ODg3MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402278871", "bodyText": "If you move the supported frameworks block first in the method, then you can delete these lines as they will be redundant.", "author": "mernst", "createdAt": "2020-04-02T12:36:41Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;\n+\n+    /** The supported frameworks (the built-in ones minus any that were disabled). */\n+    Collection<FrameworkSupport> frameworks;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        frameworks =\n+                FrameworkSupportUtils.getSupportedFrameworks(\n+                        checker.getOption(ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT));\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new ReturnsReceiverTypeAnnotator(this));\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+            AnnotationMirror unknownThisAnnot =\n+                    AnnotationBuilder.fromClass(elements, UnknownThis.class);\n+            AnnotationMirror retAnnotation = returnType.getAnnotationInHierarchy(unknownThisAnnot);\n+            if (retAnnotation != null && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n+                // add @This to the receiver type\n+                AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n+                receiverType.replaceAnnotation(THIS_ANNOTATION);\n+            }\n+\n+            // skip constructors\n+            if (!isConstructor(t)) {\n+                // check each supported framework\n+                for (FrameworkSupport frameworkSupport : frameworks) {\n+                    // see if the method in the framework should return this\n+                    if (frameworkSupport.returnsThis(t)) {\n+                        // add @This annotation\n+                        returnType.replaceAnnotation(THIS_ANNOTATION);\n+                        AnnotatedTypeMirror.AnnotatedDeclaredType receiverType =\n+                                t.getReceiverType();\n+                        receiverType.replaceAnnotation(THIS_ANNOTATION);", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\nindex 180282a2a..f5ad162b3 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n\n@@ -1,14 +1,11 @@\n package org.checkerframework.common.returnsreceiver;\n \n import java.lang.annotation.Annotation;\n-import java.util.Collection;\n import java.util.Set;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.element.ElementKind;\n import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n import org.checkerframework.common.basetype.BaseTypeChecker;\n-import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n-import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n import org.checkerframework.common.returnsreceiver.qual.This;\n import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4MDQxOQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402280419", "bodyText": "These comments are vacuous:  LOMBOK_SUPPORT is the string representation for LOMBOK_SUPPORT.\nUpon reading the code, I found out that these are the string representation of enum constants.\nIf so, they should be defined near the enum constants, not here in a different package.  Furthermore, there is no need for the enum constants.  It would be better to either iterate through the enum constants getting their toString representation.  (Or maybe create a method that takes a string and returns a matching enum constant.)\nBut, maybe these aren't needed at all if the Returns Receiver Checker doesn't need to support a --disableFrameworks command-line option.", "author": "mernst", "createdAt": "2020-04-02T12:39:12Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverChecker.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.framework.source.SupportedOptions;\n+\n+/** Entry point for the Returns Receiver Checker. */\n+@SupportedOptions({ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT})\n+public class ReturnsReceiverChecker extends BaseTypeChecker {\n+    /** String representation for DISABLE_FRAMEWORK_SUPPORTS. */\n+    public static final String DISABLE_FRAMEWORK_SUPPORT = \"disableFrameworks\";\n+    /** String representation for LOMBOK_SUPPORT. */", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverChecker.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverChecker.java\nindex c5bdfd264..1fb043ba7 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverChecker.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverChecker.java\n\n@@ -1,15 +1,6 @@\n package org.checkerframework.common.returnsreceiver;\n \n import org.checkerframework.common.basetype.BaseTypeChecker;\n-import org.checkerframework.framework.source.SupportedOptions;\n \n /** Entry point for the Returns Receiver Checker. */\n-@SupportedOptions({ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT})\n-public class ReturnsReceiverChecker extends BaseTypeChecker {\n-    /** String representation for DISABLE_FRAMEWORK_SUPPORTS. */\n-    public static final String DISABLE_FRAMEWORK_SUPPORT = \"disableFrameworks\";\n-    /** String representation for LOMBOK_SUPPORT. */\n-    public static final String LOMBOK_SUPPORT = \"LOMBOK\";\n-    /** String representation for AUTOVALUE_SUPPORT. */\n-    public static final String AUTOVALUE_SUPPORT = \"AUTOVALUE\";\n-}\n+public class ReturnsReceiverChecker extends BaseTypeChecker {}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4MTE0OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402281148", "bodyText": "This is a weird name.  What is a \"FrameworkSupport\"?  Each class should represent some clearly-defined concept.\nHere, I think that concept is a framework.  You could name this IFramework, but it would be better to structure the code not to need this class.", "author": "mernst", "createdAt": "2020-04-02T12:40:32Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupport.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * A framework supported by the Returns Receiver Checker. That is, some methods generated by the\n+ * framework return their receiver.\n+ */\n+public interface FrameworkSupport {", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupport.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupport.java\ndeleted file mode 100644\nindex a1b6d3aa1..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupport.java\n+++ /dev/null\n\n@@ -1,15 +0,0 @@\n-package org.checkerframework.common.returnsreceiver.framework;\n-\n-import org.checkerframework.framework.type.AnnotatedTypeMirror;\n-\n-/**\n- * A framework supported by the Returns Receiver Checker. That is, some methods generated by the\n- * framework return their receiver.\n- */\n-public interface FrameworkSupport {\n-    /**\n-     * @param t the method to check\n-     * @return {@code true} if the method is generated by framework and returns {@code this}\n-     */\n-    boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4MjI2Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402282266", "bodyText": "How can the return type be null?\nI think it would be a bug in this method if inAnnotationValueBuilder is true but returnType is null.  In that case, I think it's better to throw an exception.  The same comment applies later in this file.", "author": "mernst", "createdAt": "2020-04-02T12:42:28Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Enum of supported frameworks. */\n+public enum Framework implements FrameworkSupport {\n+    /** AutoValue framework. */\n+    AUTO_VALUE {\n+        @Override\n+        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+            ExecutableElement element = t.getElement();\n+            Element enclosingElement = element.getEnclosingElement();\n+            boolean inAutoValueBuilder =\n+                    FrameworkSupportUtils.hasAnnotation(enclosingElement, AutoValue.Builder.class);\n+\n+            if (!inAutoValueBuilder) {\n+                // see if superclass is an AutoValue Builder, to handle generated code\n+                TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                // if enclosingType is an interface, the superclass has TypeKind NONE\n+                if (superclass.getKind() != TypeKind.NONE) {\n+                    // update enclosingElement to be for the superclass for this case\n+                    enclosingElement = TypesUtils.getTypeElement(superclass);\n+                    inAutoValueBuilder =\n+                            enclosingElement.getAnnotation(AutoValue.Builder.class) != null;\n+                }\n+            }\n+\n+            if (inAutoValueBuilder) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+                return returnType != null", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java\ndeleted file mode 100644\nindex b6e94ee6c..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java\n+++ /dev/null\n\n@@ -1,67 +0,0 @@\n-package org.checkerframework.common.returnsreceiver.framework;\n-\n-import com.google.auto.value.AutoValue;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeKind;\n-import javax.lang.model.type.TypeMirror;\n-import org.checkerframework.framework.type.AnnotatedTypeMirror;\n-import org.checkerframework.javacutil.TypesUtils;\n-\n-/** Enum of supported frameworks. */\n-public enum Framework implements FrameworkSupport {\n-    /** AutoValue framework. */\n-    AUTO_VALUE {\n-        @Override\n-        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n-            ExecutableElement element = t.getElement();\n-            Element enclosingElement = element.getEnclosingElement();\n-            boolean inAutoValueBuilder =\n-                    FrameworkSupportUtils.hasAnnotation(enclosingElement, AutoValue.Builder.class);\n-\n-            if (!inAutoValueBuilder) {\n-                // see if superclass is an AutoValue Builder, to handle generated code\n-                TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n-                // if enclosingType is an interface, the superclass has TypeKind NONE\n-                if (superclass.getKind() != TypeKind.NONE) {\n-                    // update enclosingElement to be for the superclass for this case\n-                    enclosingElement = TypesUtils.getTypeElement(superclass);\n-                    inAutoValueBuilder =\n-                            enclosingElement.getAnnotation(AutoValue.Builder.class) != null;\n-                }\n-            }\n-\n-            if (inAutoValueBuilder) {\n-                AnnotatedTypeMirror returnType = t.getReturnType();\n-                return returnType != null\n-                        && enclosingElement.equals(\n-                                TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n-            }\n-\n-            return false;\n-        }\n-    },\n-    /** Lombok framework. */\n-    LOMBOK {\n-        @Override\n-        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n-            ExecutableElement element = t.getElement();\n-            Element enclosingElement = element.getEnclosingElement();\n-            boolean inLombokBuilder =\n-                    (FrameworkSupportUtils.hasAnnotationByName(enclosingElement, \"lombok.Generated\")\n-                                    || FrameworkSupportUtils.hasAnnotationByName(\n-                                            element, \"lombok.Generated\"))\n-                            && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n-\n-            if (inLombokBuilder) {\n-                AnnotatedTypeMirror returnType = t.getReturnType();\n-                return returnType != null\n-                        && enclosingElement.equals(\n-                                TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n-            }\n-\n-            return false;\n-        }\n-    };\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NDA5OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402284098", "bodyText": "There is no documentation of this in the manual.  It should either be documented or removed.  I thought we agreed to remove it, so I'm not sure why it is still here in the code.\nIf it is retained, this logic belongs in the checker, not here in a separate package, because it is logically part of the checker.", "author": "mernst", "createdAt": "2020-04-02T12:45:27Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java\ndeleted file mode 100644\nindex 36df648d4..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java\n+++ /dev/null\n\n@@ -1,74 +0,0 @@\n-package org.checkerframework.common.returnsreceiver.framework;\n-\n-import java.lang.annotation.Annotation;\n-import java.util.ArrayDeque;\n-import java.util.Collection;\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n-import org.checkerframework.javacutil.AnnotationUtils;\n-import org.checkerframework.javacutil.UserError;\n-\n-/** A utility class for framework support in the Returns Receiver Checker. */\n-public class FrameworkSupportUtils {\n-\n-    /** this class is non-instantiable */\n-    private FrameworkSupportUtils() {\n-        throw new RuntimeException();\n-    }\n-\n-    /**\n-     * Return which frameworks should be supported, respecting the command-line argument {@code\n-     * --disableFrameworkSupport}.\n-     *\n-     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n-     *     disabled; may be null\n-     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n-     */\n-    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n-        Collection<FrameworkSupport> frameworkSupports =\n-                new ArrayDeque<>(EnumSet.allOf(Framework.class));\n-\n-        if (disabledFrameworks != null) {\n-            for (String disabledFramework : disabledFrameworks.split(\"\\\\s?,\\\\s?\")) {\n-                switch (disabledFramework.toUpperCase()) {\n-                    case ReturnsReceiverChecker.AUTOVALUE_SUPPORT:\n-                        frameworkSupports.remove(Framework.AUTO_VALUE);\n-                        break;\n-                    case ReturnsReceiverChecker.LOMBOK_SUPPORT:\n-                        frameworkSupports.remove(Framework.LOMBOK);\n-                        break;\n-                    default:\n-                        throw new UserError(\n-                                \"Unrecognized framework in --disabledFrameworkSupport: \"\n-                                        + disabledFrameworks);\n-                }\n-            }\n-        }\n-        return frameworkSupports;\n-    }\n-\n-    /**\n-     * Given an annotation class, return true if the element has an annotation of that class.\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClass the class of the annotation that might be present\n-     * @return true if the element has the annotation\n-     */\n-    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByClass(anm, annotClass));\n-    }\n-\n-    /**\n-     * Given an annotation name, return true if the element has an annotation of that name.\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClassName the class of the annotation that might be present\n-     * @return true if the element has the annotation of that class\n-     */\n-    public static boolean hasAnnotationByName(Element element, String annotClassName) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotClassName));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NDU3Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402284572", "bodyText": "Eliminate these constant values and instead iterate through all frameworks, using their toString representation.", "author": "mernst", "createdAt": "2020-04-02T12:46:20Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.\n+     *\n+     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n+     *     disabled; may be null\n+     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n+     */\n+    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n+        Collection<FrameworkSupport> frameworkSupports =\n+                new ArrayDeque<>(EnumSet.allOf(Framework.class));\n+\n+        if (disabledFrameworks != null) {\n+            for (String disabledFramework : disabledFrameworks.split(\"\\\\s?,\\\\s?\")) {\n+                switch (disabledFramework.toUpperCase()) {\n+                    case ReturnsReceiverChecker.AUTOVALUE_SUPPORT:\n+                        frameworkSupports.remove(Framework.AUTO_VALUE);", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java\ndeleted file mode 100644\nindex 36df648d4..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java\n+++ /dev/null\n\n@@ -1,74 +0,0 @@\n-package org.checkerframework.common.returnsreceiver.framework;\n-\n-import java.lang.annotation.Annotation;\n-import java.util.ArrayDeque;\n-import java.util.Collection;\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n-import org.checkerframework.javacutil.AnnotationUtils;\n-import org.checkerframework.javacutil.UserError;\n-\n-/** A utility class for framework support in the Returns Receiver Checker. */\n-public class FrameworkSupportUtils {\n-\n-    /** this class is non-instantiable */\n-    private FrameworkSupportUtils() {\n-        throw new RuntimeException();\n-    }\n-\n-    /**\n-     * Return which frameworks should be supported, respecting the command-line argument {@code\n-     * --disableFrameworkSupport}.\n-     *\n-     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n-     *     disabled; may be null\n-     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n-     */\n-    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n-        Collection<FrameworkSupport> frameworkSupports =\n-                new ArrayDeque<>(EnumSet.allOf(Framework.class));\n-\n-        if (disabledFrameworks != null) {\n-            for (String disabledFramework : disabledFrameworks.split(\"\\\\s?,\\\\s?\")) {\n-                switch (disabledFramework.toUpperCase()) {\n-                    case ReturnsReceiverChecker.AUTOVALUE_SUPPORT:\n-                        frameworkSupports.remove(Framework.AUTO_VALUE);\n-                        break;\n-                    case ReturnsReceiverChecker.LOMBOK_SUPPORT:\n-                        frameworkSupports.remove(Framework.LOMBOK);\n-                        break;\n-                    default:\n-                        throw new UserError(\n-                                \"Unrecognized framework in --disabledFrameworkSupport: \"\n-                                        + disabledFrameworks);\n-                }\n-            }\n-        }\n-        return frameworkSupports;\n-    }\n-\n-    /**\n-     * Given an annotation class, return true if the element has an annotation of that class.\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClass the class of the annotation that might be present\n-     * @return true if the element has the annotation\n-     */\n-    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByClass(anm, annotClass));\n-    }\n-\n-    /**\n-     * Given an annotation name, return true if the element has an annotation of that name.\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClassName the class of the annotation that might be present\n-     * @return true if the element has the annotation of that class\n-     */\n-    public static boolean hasAnnotationByName(Element element, String annotClassName) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotClassName));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NDkxMg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402284912", "bodyText": "What is the point of using an ArrayDeque, which is a more expensive data structure than an EnumSet?", "author": "mernst", "createdAt": "2020-04-02T12:46:55Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.\n+     *\n+     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n+     *     disabled; may be null\n+     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n+     */\n+    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n+        Collection<FrameworkSupport> frameworkSupports =\n+                new ArrayDeque<>(EnumSet.allOf(Framework.class));", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java\ndeleted file mode 100644\nindex 36df648d4..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java\n+++ /dev/null\n\n@@ -1,74 +0,0 @@\n-package org.checkerframework.common.returnsreceiver.framework;\n-\n-import java.lang.annotation.Annotation;\n-import java.util.ArrayDeque;\n-import java.util.Collection;\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n-import org.checkerframework.javacutil.AnnotationUtils;\n-import org.checkerframework.javacutil.UserError;\n-\n-/** A utility class for framework support in the Returns Receiver Checker. */\n-public class FrameworkSupportUtils {\n-\n-    /** this class is non-instantiable */\n-    private FrameworkSupportUtils() {\n-        throw new RuntimeException();\n-    }\n-\n-    /**\n-     * Return which frameworks should be supported, respecting the command-line argument {@code\n-     * --disableFrameworkSupport}.\n-     *\n-     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n-     *     disabled; may be null\n-     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n-     */\n-    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n-        Collection<FrameworkSupport> frameworkSupports =\n-                new ArrayDeque<>(EnumSet.allOf(Framework.class));\n-\n-        if (disabledFrameworks != null) {\n-            for (String disabledFramework : disabledFrameworks.split(\"\\\\s?,\\\\s?\")) {\n-                switch (disabledFramework.toUpperCase()) {\n-                    case ReturnsReceiverChecker.AUTOVALUE_SUPPORT:\n-                        frameworkSupports.remove(Framework.AUTO_VALUE);\n-                        break;\n-                    case ReturnsReceiverChecker.LOMBOK_SUPPORT:\n-                        frameworkSupports.remove(Framework.LOMBOK);\n-                        break;\n-                    default:\n-                        throw new UserError(\n-                                \"Unrecognized framework in --disabledFrameworkSupport: \"\n-                                        + disabledFrameworks);\n-                }\n-            }\n-        }\n-        return frameworkSupports;\n-    }\n-\n-    /**\n-     * Given an annotation class, return true if the element has an annotation of that class.\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClass the class of the annotation that might be present\n-     * @return true if the element has the annotation\n-     */\n-    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByClass(anm, annotClass));\n-    }\n-\n-    /**\n-     * Given an annotation name, return true if the element has an annotation of that name.\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClassName the class of the annotation that might be present\n-     * @return true if the element has the annotation of that class\n-     */\n-    public static boolean hasAnnotationByName(Element element, String annotClassName) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotClassName));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMwMTI5Nw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402301297", "bodyText": "Can you use the containsSameByClass method from AnnotationUtils or from AnnotatedTypeFactory?\nSame question for the implementation below (AnnotatedTypeFactory has no containsSameByName, but we could add it if needed).", "author": "mernst", "createdAt": "2020-04-02T13:12:50Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.\n+     *\n+     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n+     *     disabled; may be null\n+     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n+     */\n+    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n+        Collection<FrameworkSupport> frameworkSupports =\n+                new ArrayDeque<>(EnumSet.allOf(Framework.class));\n+\n+        if (disabledFrameworks != null) {\n+            for (String disabledFramework : disabledFrameworks.split(\"\\\\s?,\\\\s?\")) {\n+                switch (disabledFramework.toUpperCase()) {\n+                    case ReturnsReceiverChecker.AUTOVALUE_SUPPORT:\n+                        frameworkSupports.remove(Framework.AUTO_VALUE);\n+                        break;\n+                    case ReturnsReceiverChecker.LOMBOK_SUPPORT:\n+                        frameworkSupports.remove(Framework.LOMBOK);\n+                        break;\n+                    default:\n+                        throw new UserError(\n+                                \"Unrecognized framework in --disabledFrameworkSupport: \"\n+                                        + disabledFrameworks);\n+                }\n+            }\n+        }\n+        return frameworkSupports;\n+    }\n+\n+    /**\n+     * Given an annotation class, return true if the element has an annotation of that class.\n+     *\n+     * @param element the element that might have an annotation\n+     * @param annotClass the class of the annotation that might be present\n+     * @return true if the element has the annotation\n+     */\n+    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n+        return element.getAnnotationMirrors().stream()", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java\ndeleted file mode 100644\nindex 36df648d4..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java\n+++ /dev/null\n\n@@ -1,74 +0,0 @@\n-package org.checkerframework.common.returnsreceiver.framework;\n-\n-import java.lang.annotation.Annotation;\n-import java.util.ArrayDeque;\n-import java.util.Collection;\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n-import org.checkerframework.javacutil.AnnotationUtils;\n-import org.checkerframework.javacutil.UserError;\n-\n-/** A utility class for framework support in the Returns Receiver Checker. */\n-public class FrameworkSupportUtils {\n-\n-    /** this class is non-instantiable */\n-    private FrameworkSupportUtils() {\n-        throw new RuntimeException();\n-    }\n-\n-    /**\n-     * Return which frameworks should be supported, respecting the command-line argument {@code\n-     * --disableFrameworkSupport}.\n-     *\n-     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n-     *     disabled; may be null\n-     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n-     */\n-    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n-        Collection<FrameworkSupport> frameworkSupports =\n-                new ArrayDeque<>(EnumSet.allOf(Framework.class));\n-\n-        if (disabledFrameworks != null) {\n-            for (String disabledFramework : disabledFrameworks.split(\"\\\\s?,\\\\s?\")) {\n-                switch (disabledFramework.toUpperCase()) {\n-                    case ReturnsReceiverChecker.AUTOVALUE_SUPPORT:\n-                        frameworkSupports.remove(Framework.AUTO_VALUE);\n-                        break;\n-                    case ReturnsReceiverChecker.LOMBOK_SUPPORT:\n-                        frameworkSupports.remove(Framework.LOMBOK);\n-                        break;\n-                    default:\n-                        throw new UserError(\n-                                \"Unrecognized framework in --disabledFrameworkSupport: \"\n-                                        + disabledFrameworks);\n-                }\n-            }\n-        }\n-        return frameworkSupports;\n-    }\n-\n-    /**\n-     * Given an annotation class, return true if the element has an annotation of that class.\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClass the class of the annotation that might be present\n-     * @return true if the element has the annotation\n-     */\n-    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByClass(anm, annotClass));\n-    }\n-\n-    /**\n-     * Given an annotation name, return true if the element has an annotation of that name.\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClassName the class of the annotation that might be present\n-     * @return true if the element has the annotation of that class\n-     */\n-    public static boolean hasAnnotationByName(Element element, String annotClassName) {\n-        return element.getAnnotationMirrors().stream()\n-                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotClassName));\n-    }\n-}\n"}}, {"oid": "fa3c48b363b6f243f9a98ccf356324f8f9d1cdae", "url": "https://github.com/typetools/checker-framework/commit/fa3c48b363b6f243f9a98ccf356324f8f9d1cdae", "message": "Update changelog", "committedDate": "2020-04-02T19:28:31Z", "type": "commit"}, {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "url": "https://github.com/typetools/checker-framework/commit/84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "message": "removed frameworkSupport Interface and resolved comments", "committedDate": "2020-04-03T07:28:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1NTM5MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403055390", "bodyText": "The fields in this class should have visibility modifiers.\nCan they be final?", "author": "wmdietl", "createdAt": "2020-04-03T14:42:39Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.Framework;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;", "originalCommit": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\nindex 7d506343c..f5ad162b3 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n\n@@ -1,14 +1,11 @@\n package org.checkerframework.common.returnsreceiver;\n \n import java.lang.annotation.Annotation;\n-import java.util.EnumSet;\n import java.util.Set;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.element.ElementKind;\n import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n import org.checkerframework.common.basetype.BaseTypeChecker;\n-import org.checkerframework.common.returnsreceiver.framework.Framework;\n-import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n import org.checkerframework.common.returnsreceiver.qual.This;\n import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403061882", "bodyText": "Note that this only validates explicit annotations in source code.\nYou could instead validate all methods/fields to ensure correct usage to also ensure stub files are correct.", "author": "wmdietl", "createdAt": "2020-04-03T14:52:05Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.tools.Diagnostic;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.framework.source.DiagMessage;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {", "originalCommit": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExODU4MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405118581", "bodyText": "@wmdietl can we handle validation of stub files in a follow-up task?  I'm afraid we will end up going down a bit of a rabbit hole if we do that here (what about classes?  or generic type arguments?).  Or maybe I am misunderstanding and it's a simple change?", "author": "msridhar", "createdAt": "2020-04-07T21:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTM0NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410455345", "bodyText": "Sure. Maybe we don't have a nice way to validate executable types at the moment. So maybe file a follow-up issue.", "author": "wmdietl", "createdAt": "2020-04-17T20:31:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4Mjc2Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413182766", "bodyText": "Will file the follow-up after this lands", "author": "msridhar", "createdAt": "2020-04-22T17:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java\nindex 0e0a3f67d..01feb7b46 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java\n\n@@ -3,10 +3,8 @@ package org.checkerframework.common.returnsreceiver;\n import com.sun.source.tree.*;\n import com.sun.source.util.TreePath;\n import javax.lang.model.element.AnnotationMirror;\n-import javax.tools.Diagnostic;\n import org.checkerframework.common.basetype.BaseTypeChecker;\n import org.checkerframework.common.basetype.BaseTypeVisitor;\n-import org.checkerframework.framework.source.DiagMessage;\n import org.checkerframework.javacutil.AnnotationUtils;\n import org.checkerframework.javacutil.TreeUtils;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2NDY0NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403064645", "bodyText": "Framework is a very vague name. Could you find a better name? SupportedReturnsReceiverSpecialCases is a bit long.", "author": "wmdietl", "createdAt": "2020-04-03T14:55:46Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Enum of supported frameworks. */\n+public enum Framework {", "originalCommit": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java\ndeleted file mode 100644\nindex c2e8d9653..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java\n+++ /dev/null\n\n@@ -1,67 +0,0 @@\n-package org.checkerframework.common.returnsreceiver.framework;\n-\n-import com.google.auto.value.AutoValue;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeKind;\n-import javax.lang.model.type.TypeMirror;\n-import org.checkerframework.framework.type.AnnotatedTypeMirror;\n-import org.checkerframework.javacutil.TypesUtils;\n-\n-/** Enum of supported frameworks. */\n-public enum Framework {\n-    /** AutoValue framework. */\n-    AUTO_VALUE {\n-        @Override\n-        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n-            ExecutableElement element = t.getElement();\n-            Element enclosingElement = element.getEnclosingElement();\n-            boolean inAutoValueBuilder =\n-                    FrameworkSupportUtils.hasAnnotation(enclosingElement, AutoValue.Builder.class);\n-\n-            if (!inAutoValueBuilder) {\n-                // see if superclass is an AutoValue Builder, to handle generated code\n-                TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n-                // if enclosingType is an interface, the superclass has TypeKind NONE\n-                if (superclass.getKind() != TypeKind.NONE) {\n-                    // update enclosingElement to be for the superclass for this case\n-                    enclosingElement = TypesUtils.getTypeElement(superclass);\n-                    inAutoValueBuilder =\n-                            enclosingElement.getAnnotation(AutoValue.Builder.class) != null;\n-                }\n-            }\n-\n-            if (inAutoValueBuilder) {\n-                AnnotatedTypeMirror returnType = t.getReturnType();\n-                if (returnType == null) throw new RuntimeException(\"Return type cannot be null\");\n-                return enclosingElement.equals(\n-                        TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n-            }\n-            return false;\n-        }\n-    },\n-    /** Lombok framework. */\n-    LOMBOK {\n-        @Override\n-        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n-            ExecutableElement element = t.getElement();\n-            Element enclosingElement = element.getEnclosingElement();\n-            boolean inLombokBuilder =\n-                    (FrameworkSupportUtils.hasAnnotationByName(enclosingElement, \"lombok.Generated\")\n-                                    || FrameworkSupportUtils.hasAnnotationByName(\n-                                            element, \"lombok.Generated\"))\n-                            && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n-\n-            if (inLombokBuilder) {\n-                AnnotatedTypeMirror returnType = t.getReturnType();\n-                if (returnType == null) throw new RuntimeException(\"Return type cannot be null\");\n-                return enclosingElement.equals(\n-                        TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n-            }\n-            return false;\n-        }\n-    };\n-\n-    public abstract boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2NjY2MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403066661", "bodyText": "Is this class really worth it?\ngetSupportedFrameworks could be in Frameworks and the other two methods are very simple wrappers. (And I would like to remove the version that uses a Class, to not require a compile-time dependency on each framework.)", "author": "wmdietl", "createdAt": "2020-04-03T14:58:36Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {", "originalCommit": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEyMTQyMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403121421", "bodyText": "I agree this class is not worth it.  @wmdietl I think hasAnnotation and hasAnnotationByName belong in some other Checker Framework utility class, if they are not already there.  Do you have a suggestion on where they should go, or whether they should just be inlined?", "author": "msridhar", "createdAt": "2020-04-03T16:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2NjY2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java\ndeleted file mode 100644\nindex 62d46f720..000000000\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java\n+++ /dev/null\n\n@@ -1,42 +0,0 @@\n-package org.checkerframework.common.returnsreceiver.framework;\n-\n-import java.lang.annotation.Annotation;\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-import org.checkerframework.javacutil.AnnotationUtils;\n-\n-/** A utility class for framework support in the Returns Receiver Checker. */\n-public class FrameworkSupportUtils {\n-\n-    /** this class is non-instantiable */\n-    private FrameworkSupportUtils() {\n-        throw new RuntimeException();\n-    }\n-\n-    /** @return the frameworks supported by this instantiation of the Returns Receiver Checker */\n-    public static EnumSet<Framework> getSupportedFrameworks() {\n-        return EnumSet.allOf(Framework.class);\n-    }\n-\n-    /**\n-     * Given an annotation class, return true if the element has an annotation of that class.\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClass the class of the annotation that might be present\n-     * @return true if the element has the annotation\n-     */\n-    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n-        return AnnotationUtils.containsSameByClass(element.getAnnotationMirrors(), annotClass);\n-    }\n-\n-    /**\n-     * Given an annotation name, return true if the element has an annotation of that name.\n-     *\n-     * @param element the element that might have an annotation\n-     * @param annotClassName the class of the annotation that might be present\n-     * @return true if the element has the annotation of that class\n-     */\n-    public static boolean hasAnnotationByName(Element element, String annotClassName) {\n-        return AnnotationUtils.containsSameByName(element.getAnnotationMirrors(), annotClassName);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403067780", "bodyText": "Is there a reason to use the top type for null, Void, or lower bounds? It would be more standard to use the bottom type for these locations.", "author": "wmdietl", "createdAt": "2020-04-03T15:00:06Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/UnknownThis.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.*;\n+\n+/**\n+ * The top type for the Returns Receiver Checker's type system. Values of the annotated type might\n+ * be the receiver ({@code this}) or might not. Programmers should rarely write this type.\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n+@DefaultQualifierInHierarchy\n+@SubtypeOf({})\n+@QualifierForLiterals(LiteralKind.NULL)", "originalCommit": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzExNDE5NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403114194", "bodyText": "For null, we want to get an error for code like this (from a test):\n        @This B dontRetThis() {\n            // :: error: return.type.incompatible\n            return null;\n        }\nWithout using the top type for null we don't get an error.\nFor Void and lower bounds, I am less sure, but I'm pretty confident weird errors showed up in large benchmarks that motivated these additions.  I can try to track those down and add corresponding unit tests.", "author": "msridhar", "createdAt": "2020-04-03T16:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1MTExNg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405251116", "bodyText": "Looked into this.  Because we want to use the top type for null, we also need to use it for generic type lower bounds.  Otherwise, the GenericNull test case from the all-systems tests fails.  I could not find a case where using @UnknownThis for Void was required, so I removed that.", "author": "msridhar", "createdAt": "2020-04-08T04:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NzY5MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406377690", "bodyText": "Void can't be initialized, so its type probably doesn't matter.", "author": "kelloggm", "createdAt": "2020-04-09T17:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA=="}], "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/UnknownThis.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/UnknownThis.java\nindex 7252f2f50..107d5f837 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/UnknownThis.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/UnknownThis.java\n\n@@ -17,5 +17,5 @@ import org.checkerframework.framework.qual.*;\n @DefaultQualifierInHierarchy\n @SubtypeOf({})\n @QualifierForLiterals(LiteralKind.NULL)\n-@DefaultFor(types = Void.class, value = TypeUseLocation.LOWER_BOUND)\n+@DefaultFor(value = TypeUseLocation.LOWER_BOUND)\n public @interface UnknownThis {}\n"}}, {"oid": "acfb71a082e2aa5ed579bcad04447d36be7ef724", "url": "https://github.com/typetools/checker-framework/commit/acfb71a082e2aa5ed579bcad04447d36be7ef724", "message": "Don't replace existing annotations.", "committedDate": "2020-04-05T18:20:05Z", "type": "commit"}, {"oid": "d7baf84d2ae3a3ffa40f1df39ff5215f7206ccf0", "url": "https://github.com/typetools/checker-framework/commit/d7baf84d2ae3a3ffa40f1df39ff5215f7206ccf0", "message": "fix misc_jdk8", "committedDate": "2020-04-06T02:20:13Z", "type": "commit"}, {"oid": "b51b9199f33112538d3ecad583c7934248b13495", "url": "https://github.com/typetools/checker-framework/commit/b51b9199f33112538d3ecad583c7934248b13495", "message": "removed FrameworkSupportUtils", "committedDate": "2020-04-06T23:24:54Z", "type": "commit"}, {"oid": "71b5578d5cff91a4a1553eb2ed5a14dc671c9795", "url": "https://github.com/typetools/checker-framework/commit/71b5578d5cff91a4a1553eb2ed5a14dc671c9795", "message": "removed dependecies to AutoValue", "committedDate": "2020-04-07T01:36:46Z", "type": "commit"}, {"oid": "606a7a14aee1fe93c4c80fee489df5a8f7d290e7", "url": "https://github.com/typetools/checker-framework/commit/606a7a14aee1fe93c4c80fee489df5a8f7d290e7", "message": "clean up some logic in type factory", "committedDate": "2020-04-07T03:46:33Z", "type": "commit"}, {"oid": "fe7036cc37fd2929169301e3543ee7aa128683a1", "url": "https://github.com/typetools/checker-framework/commit/fe7036cc37fd2929169301e3543ee7aa128683a1", "message": "fixed modifiers", "committedDate": "2020-04-07T17:18:28Z", "type": "commit"}, {"oid": "d54fc10e5111d30df096277d11619b70e1c478bd", "url": "https://github.com/typetools/checker-framework/commit/d54fc10e5111d30df096277d11619b70e1c478bd", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker", "committedDate": "2020-04-07T17:18:45Z", "type": "commit"}, {"oid": "a3d574a36e96ba5441a729f3cc82b4c87f2179ce", "url": "https://github.com/typetools/checker-framework/commit/a3d574a36e96ba5441a729f3cc82b4c87f2179ce", "message": "test that @This annotations are actually getting inserted", "committedDate": "2020-04-08T00:05:29Z", "type": "commit"}, {"oid": "85b047f3fc43707a1f1db671f92bfaf1d50729fb", "url": "https://github.com/typetools/checker-framework/commit/85b047f3fc43707a1f1db671f92bfaf1d50729fb", "message": "fixed framesupport name & fixed AutoValue string", "committedDate": "2020-04-08T00:54:16Z", "type": "commit"}, {"oid": "96ba71365267951399a1b0314d89d9c7460bd92d", "url": "https://github.com/typetools/checker-framework/commit/96ba71365267951399a1b0314d89d9c7460bd92d", "message": "don't make @UnknownThis default for Void", "committedDate": "2020-04-08T04:25:16Z", "type": "commit"}, {"oid": "8235bfe8873bd936ef456dcbb1996b3e1239c24f", "url": "https://github.com/typetools/checker-framework/commit/8235bfe8873bd936ef456dcbb1996b3e1239c24f", "message": "fix javadoc and variable names", "committedDate": "2020-04-08T04:34:21Z", "type": "commit"}, {"oid": "319154ff04a573308c2589fbdf61281ca2fb86fa", "url": "https://github.com/typetools/checker-framework/commit/319154ff04a573308c2589fbdf61281ca2fb86fa", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker", "committedDate": "2020-04-08T05:06:12Z", "type": "commit"}, {"oid": "74d8beb7b29d1acdb2eed153f6796020e594f9fd", "url": "https://github.com/typetools/checker-framework/commit/74d8beb7b29d1acdb2eed153f6796020e594f9fd", "message": "Don't make a package for just one file", "committedDate": "2020-04-08T05:10:41Z", "type": "commit"}, {"oid": "b1c71dd1ed17252292e9afdb2c8194ed1f47dd53", "url": "https://github.com/typetools/checker-framework/commit/b1c71dd1ed17252292e9afdb2c8194ed1f47dd53", "message": "javadoc", "committedDate": "2020-04-08T16:08:14Z", "type": "commit"}, {"oid": "f7eb1483dfa88db86fb4103e9feff8a0eab619c9", "url": "https://github.com/typetools/checker-framework/commit/f7eb1483dfa88db86fb4103e9feff8a0eab619c9", "message": "narrow visibility", "committedDate": "2020-04-08T16:11:58Z", "type": "commit"}, {"oid": "87ce086428cbe7931c5964e77f3c7999598d049a", "url": "https://github.com/typetools/checker-framework/commit/87ce086428cbe7931c5964e77f3c7999598d049a", "message": "Code review improvements", "committedDate": "2020-04-08T16:16:35Z", "type": "commit"}, {"oid": "15c4a33975b813a0efa9fbee05ca7a1633adca9a", "url": "https://github.com/typetools/checker-framework/commit/15c4a33975b813a0efa9fbee05ca7a1633adca9a", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker", "committedDate": "2020-04-08T16:17:15Z", "type": "commit"}, {"oid": "45df4580377cef06691e8476aa03042e5d6c208b", "url": "https://github.com/typetools/checker-framework/commit/45df4580377cef06691e8476aa03042e5d6c208b", "message": "Code review improvements", "committedDate": "2020-04-08T16:20:35Z", "type": "commit"}, {"oid": "3b9d77c45ecbf32674f6dce632616c3687786485", "url": "https://github.com/typetools/checker-framework/commit/3b9d77c45ecbf32674f6dce632616c3687786485", "message": "Punctuation", "committedDate": "2020-04-08T16:28:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MTQ1NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405651454", "bodyText": "This code doesn't care about the existence of the FluentAPIGenerator class.  I would be inclined to create a method returnsThis and put the for loop within it.  Then the FluentAPIGenerator enum can be private, since it is only used by that method.", "author": "mernst", "createdAt": "2020-04-08T16:23:46Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+                // If any FluentAPIGenerator indicates the method returns this,\n+                // add an @This annotation on the return type.\n+                for (FluentAPIGenerator fluentAPIGenerator :", "originalCommit": "45df4580377cef06691e8476aa03042e5d6c208b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\nindex 8b563ac46..f5ad162b3 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n\n@@ -1,7 +1,6 @@\n package org.checkerframework.common.returnsreceiver;\n \n import java.lang.annotation.Annotation;\n-import java.util.EnumSet;\n import java.util.Set;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.element.ElementKind;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MjA4Nw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405652087", "bodyText": "It is inconsistent that this code uses getAnnotationByName but the below code uses containsSameByName.", "author": "mernst", "createdAt": "2020-04-08T16:24:35Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Enum of supported fluent API generators. For such generators, the checker can automatically\n+ * add @This annotations on method return types in the generated code.\n+ */\n+public enum FluentAPIGenerator {\n+    /**\n+     * The <a\n+     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+     * framework.\n+     */\n+    AUTO_VALUE {\n+\n+        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+        @Override\n+        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+            ExecutableElement element = t.getElement();\n+            Element enclosingElement = element.getEnclosingElement();\n+            boolean inAutoValueBuilder =\n+                    AnnotationUtils.getAnnotationByName(", "originalCommit": "45df4580377cef06691e8476aa03042e5d6c208b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex e64414b2c..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -6,99 +6,131 @@ import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n /**\n- * Enum of supported fluent API generators. For such generators, the checker can automatically\n- * add @This annotations on method return types in the generated code.\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n  */\n-public enum FluentAPIGenerator {\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n-     * The <a\n-     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n-     * framework.\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n      */\n-    AUTO_VALUE {\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n \n-        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needs to be constructed\n+             * dynamically due to a side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n \n-        @Override\n-        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n-            ExecutableElement element = t.getElement();\n-            Element enclosingElement = element.getEnclosingElement();\n-            boolean inAutoValueBuilder =\n-                    AnnotationUtils.getAnnotationByName(\n-                                    enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER)\n-                            != null;\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n \n-            if (!inAutoValueBuilder) {\n-                // see if superclass is an AutoValue Builder, to handle generated code\n-                TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n-                // if enclosingType is an interface, the superclass has TypeKind NONE\n-                if (superclass.getKind() != TypeKind.NONE) {\n-                    // update enclosingElement to be for the superclass for this case\n-                    enclosingElement = TypesUtils.getTypeElement(superclass);\n-                    inAutoValueBuilder =\n-                            AnnotationUtils.getAnnotationByName(\n-                                            enclosingElement.getAnnotationMirrors(),\n-                                            AUTO_VALUE_BUILDER)\n-                                    != null;\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingElement is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n                 }\n-            }\n \n-            if (inAutoValueBuilder) {\n-                AnnotatedTypeMirror returnType = t.getReturnType();\n-                if (returnType == null) {\n-                    throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n                 }\n-                return enclosingElement.equals(\n-                        TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                return false;\n             }\n-            return false;\n-        }\n \n-        /**\n-         * Get the qualified name of the AutoValue Builder annotation. This method constructs the\n-         * String dynamically, to ensure it does not get rewritten due to relocation of the {@code\n-         * \"com.google\"} package during the build process\n-         *\n-         * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n-         */\n-        private String getAutoValueBuilderCanonicalName() {\n-            String com = \"com\";\n-            return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n-        }\n-    },\n-    /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n-    LOMBOK {\n-        @Override\n-        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n-            ExecutableElement element = t.getElement();\n-            Element enclosingElement = element.getEnclosingElement();\n-            boolean inLombokBuilder =\n-                    (AnnotationUtils.containsSameByName(\n-                                            enclosingElement.getAnnotationMirrors(),\n-                                            \"lombok.Generated\")\n-                                    || AnnotationUtils.containsSameByName(\n-                                            element.getAnnotationMirrors(), \"lombok.Generated\"))\n-                            && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n \n-            if (inLombokBuilder) {\n-                AnnotatedTypeMirror returnType = t.getReturnType();\n-                if (returnType == null) {\n-                    throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n                 }\n-                return enclosingElement.equals(\n-                        TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                return false;\n             }\n-            return false;\n-        }\n-    };\n+        };\n \n-    /**\n-     * @param t the method to check\n-     * @return {@code true} if the method was created by this generator and returns {@code this}\n-     */\n-    public abstract boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n+        /**\n+         * @param t the annotated type of the method signature\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedExecutableType t);\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MzgxMg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405653812", "bodyText": "Could you clarify this comment?  Is code generated if the superclass is an AutoValue builder, or if the superclass is not?  What is done with generated code:  ignore it, or be sure to process it too?", "author": "mernst", "createdAt": "2020-04-08T16:27:08Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Enum of supported fluent API generators. For such generators, the checker can automatically\n+ * add @This annotations on method return types in the generated code.\n+ */\n+public enum FluentAPIGenerator {\n+    /**\n+     * The <a\n+     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+     * framework.\n+     */\n+    AUTO_VALUE {\n+\n+        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+        @Override\n+        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+            ExecutableElement element = t.getElement();\n+            Element enclosingElement = element.getEnclosingElement();\n+            boolean inAutoValueBuilder =\n+                    AnnotationUtils.getAnnotationByName(\n+                                    enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER)\n+                            != null;\n+\n+            if (!inAutoValueBuilder) {\n+                // see if superclass is an AutoValue Builder, to handle generated code", "originalCommit": "45df4580377cef06691e8476aa03042e5d6c208b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex e64414b2c..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -6,99 +6,131 @@ import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n /**\n- * Enum of supported fluent API generators. For such generators, the checker can automatically\n- * add @This annotations on method return types in the generated code.\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n  */\n-public enum FluentAPIGenerator {\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n-     * The <a\n-     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n-     * framework.\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n      */\n-    AUTO_VALUE {\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n \n-        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needs to be constructed\n+             * dynamically due to a side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n \n-        @Override\n-        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n-            ExecutableElement element = t.getElement();\n-            Element enclosingElement = element.getEnclosingElement();\n-            boolean inAutoValueBuilder =\n-                    AnnotationUtils.getAnnotationByName(\n-                                    enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER)\n-                            != null;\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n \n-            if (!inAutoValueBuilder) {\n-                // see if superclass is an AutoValue Builder, to handle generated code\n-                TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n-                // if enclosingType is an interface, the superclass has TypeKind NONE\n-                if (superclass.getKind() != TypeKind.NONE) {\n-                    // update enclosingElement to be for the superclass for this case\n-                    enclosingElement = TypesUtils.getTypeElement(superclass);\n-                    inAutoValueBuilder =\n-                            AnnotationUtils.getAnnotationByName(\n-                                            enclosingElement.getAnnotationMirrors(),\n-                                            AUTO_VALUE_BUILDER)\n-                                    != null;\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingElement is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n                 }\n-            }\n \n-            if (inAutoValueBuilder) {\n-                AnnotatedTypeMirror returnType = t.getReturnType();\n-                if (returnType == null) {\n-                    throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n                 }\n-                return enclosingElement.equals(\n-                        TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                return false;\n             }\n-            return false;\n-        }\n \n-        /**\n-         * Get the qualified name of the AutoValue Builder annotation. This method constructs the\n-         * String dynamically, to ensure it does not get rewritten due to relocation of the {@code\n-         * \"com.google\"} package during the build process\n-         *\n-         * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n-         */\n-        private String getAutoValueBuilderCanonicalName() {\n-            String com = \"com\";\n-            return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n-        }\n-    },\n-    /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n-    LOMBOK {\n-        @Override\n-        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n-            ExecutableElement element = t.getElement();\n-            Element enclosingElement = element.getEnclosingElement();\n-            boolean inLombokBuilder =\n-                    (AnnotationUtils.containsSameByName(\n-                                            enclosingElement.getAnnotationMirrors(),\n-                                            \"lombok.Generated\")\n-                                    || AnnotationUtils.containsSameByName(\n-                                            element.getAnnotationMirrors(), \"lombok.Generated\"))\n-                            && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n \n-            if (inLombokBuilder) {\n-                AnnotatedTypeMirror returnType = t.getReturnType();\n-                if (returnType == null) {\n-                    throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n                 }\n-                return enclosingElement.equals(\n-                        TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                return false;\n             }\n-            return false;\n-        }\n-    };\n+        };\n \n-    /**\n-     * @param t the method to check\n-     * @return {@code true} if the method was created by this generator and returns {@code this}\n-     */\n-    public abstract boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n+        /**\n+         * @param t the annotated type of the method signature\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedExecutableType t);\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1NDIyOQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405654229", "bodyText": "Could you document this field?", "author": "mernst", "createdAt": "2020-04-08T16:27:46Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Enum of supported fluent API generators. For such generators, the checker can automatically\n+ * add @This annotations on method return types in the generated code.\n+ */\n+public enum FluentAPIGenerator {\n+    /**\n+     * The <a\n+     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+     * framework.\n+     */\n+    AUTO_VALUE {\n+\n+        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();", "originalCommit": "45df4580377cef06691e8476aa03042e5d6c208b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex e64414b2c..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -6,99 +6,131 @@ import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n /**\n- * Enum of supported fluent API generators. For such generators, the checker can automatically\n- * add @This annotations on method return types in the generated code.\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n  */\n-public enum FluentAPIGenerator {\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n-     * The <a\n-     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n-     * framework.\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n      */\n-    AUTO_VALUE {\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n \n-        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needs to be constructed\n+             * dynamically due to a side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n \n-        @Override\n-        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n-            ExecutableElement element = t.getElement();\n-            Element enclosingElement = element.getEnclosingElement();\n-            boolean inAutoValueBuilder =\n-                    AnnotationUtils.getAnnotationByName(\n-                                    enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER)\n-                            != null;\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n \n-            if (!inAutoValueBuilder) {\n-                // see if superclass is an AutoValue Builder, to handle generated code\n-                TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n-                // if enclosingType is an interface, the superclass has TypeKind NONE\n-                if (superclass.getKind() != TypeKind.NONE) {\n-                    // update enclosingElement to be for the superclass for this case\n-                    enclosingElement = TypesUtils.getTypeElement(superclass);\n-                    inAutoValueBuilder =\n-                            AnnotationUtils.getAnnotationByName(\n-                                            enclosingElement.getAnnotationMirrors(),\n-                                            AUTO_VALUE_BUILDER)\n-                                    != null;\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingElement is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n                 }\n-            }\n \n-            if (inAutoValueBuilder) {\n-                AnnotatedTypeMirror returnType = t.getReturnType();\n-                if (returnType == null) {\n-                    throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n                 }\n-                return enclosingElement.equals(\n-                        TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                return false;\n             }\n-            return false;\n-        }\n \n-        /**\n-         * Get the qualified name of the AutoValue Builder annotation. This method constructs the\n-         * String dynamically, to ensure it does not get rewritten due to relocation of the {@code\n-         * \"com.google\"} package during the build process\n-         *\n-         * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n-         */\n-        private String getAutoValueBuilderCanonicalName() {\n-            String com = \"com\";\n-            return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n-        }\n-    },\n-    /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n-    LOMBOK {\n-        @Override\n-        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n-            ExecutableElement element = t.getElement();\n-            Element enclosingElement = element.getEnclosingElement();\n-            boolean inLombokBuilder =\n-                    (AnnotationUtils.containsSameByName(\n-                                            enclosingElement.getAnnotationMirrors(),\n-                                            \"lombok.Generated\")\n-                                    || AnnotationUtils.containsSameByName(\n-                                            element.getAnnotationMirrors(), \"lombok.Generated\"))\n-                            && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n \n-            if (inLombokBuilder) {\n-                AnnotatedTypeMirror returnType = t.getReturnType();\n-                if (returnType == null) {\n-                    throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n                 }\n-                return enclosingElement.equals(\n-                        TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                return false;\n             }\n-            return false;\n-        }\n-    };\n+        };\n \n-    /**\n-     * @param t the method to check\n-     * @return {@code true} if the method was created by this generator and returns {@code this}\n-     */\n-    public abstract boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n+        /**\n+         * @param t the annotated type of the method signature\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedExecutableType t);\n+    }\n }\n"}}, {"oid": "4941b9e27b1872a2f2b0367fb3877c48fe1fcf22", "url": "https://github.com/typetools/checker-framework/commit/4941b9e27b1872a2f2b0367fb3877c48fe1fcf22", "message": "wrapped FluentAPIGenerators", "committedDate": "2020-04-08T18:40:48Z", "type": "commit"}, {"oid": "92ea24988903262e7a706c9b172c9a2ba2e0d578", "url": "https://github.com/typetools/checker-framework/commit/92ea24988903262e7a706c9b172c9a2ba2e0d578", "message": "fixed javadoc", "committedDate": "2020-04-08T19:08:07Z", "type": "commit"}, {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "url": "https://github.com/typetools/checker-framework/commit/5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "message": "added documantion for AUTO_VALUE_BUILDER field", "committedDate": "2020-04-08T19:21:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTgyNA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406371824", "bodyText": "nit: \"due to a side effect\"", "author": "kelloggm", "createdAt": "2020-04-09T17:45:54Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex 0817c7d9f..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -6,12 +6,36 @@ import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n-/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n public class FluentAPIGenerator {\n \n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Enum of supported fluent API generators. For such generators, the checker can automatically\n      * add @This annotations on method return types in the generated code.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MjQ5MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406372490", "bodyText": "Nit: this code would be easier to read if you imported AnnotatedExecutableType directly rather than qualifying it everywhere it appears. Most of the other code in the CF uses that style.", "author": "kelloggm", "createdAt": "2020-04-09T17:46:59Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex 0817c7d9f..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -6,12 +6,36 @@ import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n-/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n public class FluentAPIGenerator {\n \n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Enum of supported fluent API generators. For such generators, the checker can automatically\n      * add @This annotations on method return types in the generated code.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MzAxOA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406373018", "bodyText": "Why RuntimeException rather than BugInCF?", "author": "kelloggm", "createdAt": "2020-04-09T17:47:54Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex 0817c7d9f..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -6,12 +6,36 @@ import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n-/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n public class FluentAPIGenerator {\n \n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Enum of supported fluent API generators. For such generators, the checker can automatically\n      * add @This annotations on method return types in the generated code.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MzgwMg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406373802", "bodyText": "same question about RuntimeException vs BugInCF", "author": "kelloggm", "createdAt": "2020-04-09T17:49:12Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex 0817c7d9f..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -6,12 +6,36 @@ import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n-/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n public class FluentAPIGenerator {\n \n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Enum of supported fluent API generators. For such generators, the checker can automatically\n      * add @This annotations on method return types in the generated code.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NDI0NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406374245", "bodyText": "Nit: t is the annotated type of the method signature, not the method itself (which would be an ExecutableElement, probably)", "author": "kelloggm", "createdAt": "2020-04-09T17:49:59Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the method to check", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex 0817c7d9f..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -6,12 +6,36 @@ import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n-/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n public class FluentAPIGenerator {\n \n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Enum of supported fluent API generators. For such generators, the checker can automatically\n      * add @This annotations on method return types in the generated code.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NDU0MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406374541", "bodyText": "Same comment as above about t", "author": "kelloggm", "createdAt": "2020-04-09T17:50:31Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the method to check\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n+    }\n+\n+    /**\n+     * @param t the method to check", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex 0817c7d9f..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -6,12 +6,36 @@ import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n-/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n public class FluentAPIGenerator {\n \n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Enum of supported fluent API generators. For such generators, the checker can automatically\n      * add @This annotations on method return types in the generated code.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NTEzOQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406375139", "bodyText": "It is better style to always use { and } to surround the body of an if, even if it is one statement, because the code might change later to include multiple statements.", "author": "kelloggm", "createdAt": "2020-04-09T17:51:35Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the method to check\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n+    }\n+\n+    /**\n+     * @param t the method to check\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean checkForFluentAPIGenerators(\n+            AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) return true;", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex 0817c7d9f..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -6,12 +6,36 @@ import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n-/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n public class FluentAPIGenerator {\n \n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Enum of supported fluent API generators. For such generators, the checker can automatically\n      * add @This annotations on method return types in the generated code.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODE3Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406378172", "bodyText": "Please add a Javadoc comment for this test", "author": "kelloggm", "createdAt": "2020-04-09T17:56:54Z", "path": "framework/src/test/java/tests/ReturnsReceiverAutoValueTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package tests;\n+\n+import static org.checkerframework.framework.test.TestConfigurationBuilder.buildDefaultConfiguration;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.List;\n+import org.checkerframework.framework.test.*;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+public class ReturnsReceiverAutoValueTest extends CheckerFrameworkPerDirectoryTest {", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/test/java/tests/ReturnsReceiverAutoValueTest.java b/framework/src/test/java/tests/ReturnsReceiverAutoValueTest.java\nindex 2b78d007b..6318f15d2 100644\n--- a/framework/src/test/java/tests/ReturnsReceiverAutoValueTest.java\n+++ b/framework/src/test/java/tests/ReturnsReceiverAutoValueTest.java\n\n@@ -9,6 +9,7 @@ import java.util.List;\n import org.checkerframework.framework.test.*;\n import org.junit.runners.Parameterized.Parameters;\n \n+/** tests the returns receiver checker's AutoValue integration. */\n public class ReturnsReceiverAutoValueTest extends CheckerFrameworkPerDirectoryTest {\n \n     private static final ImmutableList<String> ANNOTATION_PROCS =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODU1OQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406378559", "bodyText": "This comment is no longer accurate. It can be shortened to just \"tests the returns receiver checker's lombok integration\" or similar", "author": "kelloggm", "createdAt": "2020-04-09T17:57:29Z", "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test runner for tests of the Returns Receiver Checker.\n+ *\n+ * <p>Tests appear as Java files in the {@code tests/lombok} folder. To add a new test case, create\n+ * a Java file in that directory. The file contains \"// ::\" comments to indicate expected errors and\n+ * warnings; see https://github.com/typetools/checker-framework/blob/master/checker/tests/README .\n+ */", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODc3NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406378774", "bodyText": "It probably ought to also mention that the test files have been delomobok'd", "author": "kelloggm", "createdAt": "2020-04-09T17:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODU1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/test/java/tests/ReturnsReceiverLombokTest.java b/framework/src/test/java/tests/ReturnsReceiverLombokTest.java\nindex 7ce1189d3..7ba9f1d77 100644\n--- a/framework/src/test/java/tests/ReturnsReceiverLombokTest.java\n+++ b/framework/src/test/java/tests/ReturnsReceiverLombokTest.java\n\n@@ -7,25 +7,32 @@ import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n import org.junit.runners.Parameterized.Parameters;\n \n /**\n- * Test runner for tests of the Returns Receiver Checker.\n- *\n- * <p>Tests appear as Java files in the {@code tests/lombok} folder. To add a new test case, create\n- * a Java file in that directory. The file contains \"// ::\" comments to indicate expected errors and\n- * warnings; see https://github.com/typetools/checker-framework/blob/master/checker/tests/README .\n+ * Tests the returns receiver checker's lombok integration, the test files in\n+ * tests/returnsreceiverlombok package will be delomboked into tests/returnsreceiverdelomboked\n+ * package before running the test and the returns receiver checker will run on the generated codes.\n  */\n public class ReturnsReceiverLombokTest extends CheckerFrameworkPerDirectoryTest {\n     public ReturnsReceiverLombokTest(List<File> testFiles) {\n         super(\n                 testFiles,\n                 ReturnsReceiverChecker.class,\n-                \"lombok\",\n+                \"returnsreceiverdelomboked\",\n                 \"-Anomsgtext\",\n                 \"-nowarn\",\n                 \"-AsuppressWarnings=type.anno.before.modifier\");\n     }\n \n+    @Override\n+    public void run() {\n+        // Only run if delomboked codes have been created.\n+        if (!new File(\"tests/returnsreceiverdelomboked/\").exists()) {\n+            throw new RuntimeException(\"delombok task must be run before this test.\");\n+        }\n+        super.run();\n+    }\n+\n     @Parameters\n     public static String[] getTestDirs() {\n-        return new String[] {\"returnsreceiverlombok\"};\n+        return new String[] {\"returnsreceiverdelomboked\"};\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3OTE3Mw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406379173", "bodyText": "We probably don't need this comment here anymore. If nothing else, please change the link so that it's no longer a URL, since these are now in the same repo.", "author": "kelloggm", "createdAt": "2020-04-09T17:58:35Z", "path": "framework/src/test/java/tests/ReturnsReceiverTest.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test runner for tests of the Returns Receiver Checker.\n+ *\n+ * <p>Tests appear as Java files in the {@code tests/returnsreceiver} folder. To add a new test\n+ * case, create a Java file in that directory. The file contains \"// ::\" comments to indicate\n+ * expected errors and warnings; see\n+ * https://github.com/typetools/checker-framework/blob/master/checker/tests/README .\n+ */", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/test/java/tests/ReturnsReceiverTest.java b/framework/src/test/java/tests/ReturnsReceiverTest.java\nindex 63bc894a2..7f5fe8d8d 100644\n--- a/framework/src/test/java/tests/ReturnsReceiverTest.java\n+++ b/framework/src/test/java/tests/ReturnsReceiverTest.java\n\n@@ -10,9 +10,7 @@ import org.junit.runners.Parameterized.Parameters;\n  * Test runner for tests of the Returns Receiver Checker.\n  *\n  * <p>Tests appear as Java files in the {@code tests/returnsreceiver} folder. To add a new test\n- * case, create a Java file in that directory. The file contains \"// ::\" comments to indicate\n- * expected errors and warnings; see\n- * https://github.com/typetools/checker-framework/blob/master/checker/tests/README .\n+ * case, create a Java file in that directory.\n  */\n public class ReturnsReceiverTest extends CheckerFrameworkPerDirectoryTest {\n     public ReturnsReceiverTest(List<File> testFiles) {\n"}}, {"oid": "8484e84d32c6915f92ff03a62ef31812bc176f4b", "url": "https://github.com/typetools/checker-framework/commit/8484e84d32c6915f92ff03a62ef31812bc176f4b", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker", "committedDate": "2020-04-09T21:59:55Z", "type": "commit"}, {"oid": "c99ff12b206151524b2d5941b91ae42664f359a0", "url": "https://github.com/typetools/checker-framework/commit/c99ff12b206151524b2d5941b91ae42664f359a0", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker", "committedDate": "2020-04-09T22:00:36Z", "type": "commit"}, {"oid": "1fc75ded7470e0022c3d543df066fb9f88fe05da", "url": "https://github.com/typetools/checker-framework/commit/1fc75ded7470e0022c3d543df066fb9f88fe05da", "message": "fixed comments", "committedDate": "2020-04-10T22:23:36Z", "type": "commit"}, {"oid": "6b55daa298f92d79a2e0e0bfbaff34ee4438dcca", "url": "https://github.com/typetools/checker-framework/commit/6b55daa298f92d79a2e0e0bfbaff34ee4438dcca", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker", "committedDate": "2020-04-13T20:11:18Z", "type": "commit"}, {"oid": "acada3aca97257d8cb6d01b80c6df509ea6ec91f", "url": "https://github.com/typetools/checker-framework/commit/acada3aca97257d8cb6d01b80c6df509ea6ec91f", "message": "added delombok task", "committedDate": "2020-04-13T23:05:33Z", "type": "commit"}, {"oid": "44d3d96f8da307f1b2341db94e7c79ad5bad02a6", "url": "https://github.com/typetools/checker-framework/commit/44d3d96f8da307f1b2341db94e7c79ad5bad02a6", "message": "cleaned build.gradle file", "committedDate": "2020-04-13T23:12:11Z", "type": "commit"}, {"oid": "d9bab392b39000a5a6973ac69050271684d91d0a", "url": "https://github.com/typetools/checker-framework/commit/d9bab392b39000a5a6973ac69050271684d91d0a", "message": "added newLine for framework/build.gradle", "committedDate": "2020-04-14T00:29:30Z", "type": "commit"}, {"oid": "7995c9e095d48f3297d8d8091a01b567a64c85f7", "url": "https://github.com/typetools/checker-framework/commit/7995c9e095d48f3297d8d8091a01b567a64c85f7", "message": "test configurations", "committedDate": "2020-04-14T01:29:48Z", "type": "commit"}, {"oid": "aceac536d09448a02432560d9cc05414f03ce8a6", "url": "https://github.com/typetools/checker-framework/commit/aceac536d09448a02432560d9cc05414f03ce8a6", "message": "added wrapper methods and fixed gradle cache for delombok task", "committedDate": "2020-04-14T21:48:07Z", "type": "commit"}, {"oid": "199665ad2a8bdcd78eee07f8bcc1029ba98736e6", "url": "https://github.com/typetools/checker-framework/commit/199665ad2a8bdcd78eee07f8bcc1029ba98736e6", "message": "Run delombok as an action, not during configuration time", "committedDate": "2020-04-14T22:29:08Z", "type": "commit"}, {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a", "url": "https://github.com/typetools/checker-framework/commit/a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a", "message": "switch to using testCompileClasspath in delombok task", "committedDate": "2020-04-14T22:51:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMDAyOQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408510029", "bodyText": "not -> note\nAlso, I think this comment needs to be updated given the new strategy for delombok'ing the tests.", "author": "kelloggm", "createdAt": "2020-04-15T00:21:13Z", "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * tests the returns receiver checker's lombok integration, please not that the test files have been", "originalCommit": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/test/java/tests/ReturnsReceiverLombokTest.java b/framework/src/test/java/tests/ReturnsReceiverLombokTest.java\nindex 00803de65..7ba9f1d77 100644\n--- a/framework/src/test/java/tests/ReturnsReceiverLombokTest.java\n+++ b/framework/src/test/java/tests/ReturnsReceiverLombokTest.java\n\n@@ -7,8 +7,9 @@ import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n import org.junit.runners.Parameterized.Parameters;\n \n /**\n- * tests the returns receiver checker's lombok integration, please not that the test files have been\n- * delomobok'd\n+ * Tests the returns receiver checker's lombok integration, the test files in\n+ * tests/returnsreceiverlombok package will be delomboked into tests/returnsreceiverdelomboked\n+ * package before running the test and the returns receiver checker will run on the generated codes.\n  */\n public class ReturnsReceiverLombokTest extends CheckerFrameworkPerDirectoryTest {\n     public ReturnsReceiverLombokTest(List<File> testFiles) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMDg0MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408510840", "bodyText": "These two builders are not \"good\" - they're both incorrect. That comment looks like a holdover from the Object Construction Checker, and should be removed.", "author": "kelloggm", "createdAt": "2020-04-15T00:23:51Z", "path": "framework/tests/returnsreceiverlombok/BuilderTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderTest {\n+    @Getter @Setter private Integer x;\n+    @Getter @Setter @NonNull private Integer y;\n+    @Getter @Setter @NonNull private Integer z;\n+\n+    public static void test_simplePattern() {\n+        BuilderTest.builder().x(0).y(0).build(); // good builder\n+        BuilderTest.builder().y(0).build(); // good builder", "originalCommit": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/tests/returnsreceiverlombok/BuilderTest.java b/framework/tests/returnsreceiverlombok/BuilderTest.java\nindex 8d4f50a41..c9c0dd1c0 100644\n--- a/framework/tests/returnsreceiverlombok/BuilderTest.java\n+++ b/framework/tests/returnsreceiverlombok/BuilderTest.java\n\n@@ -3,6 +3,7 @@ import lombok.Getter;\n import lombok.NonNull;\n import lombok.Setter;\n import lombok.experimental.Accessors;\n+import org.checkerframework.common.returnsreceiver.qual.*;\n \n @Builder\n @Accessors(fluent = true)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMjA1NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408512054", "bodyText": "@kelloggm this subclass has the wrapper methods that ensure that @This annotations are getting inserted correctly for Lombok.  I think this should be sufficient for testing, but let us know if you think they belong elsewhere or need better documentation", "author": "msridhar", "createdAt": "2020-04-15T00:27:54Z", "path": "framework/tests/returnsreceiverlombok/BuilderMethodRef.java", "diffHunk": "@@ -0,0 +1,30 @@\n+import java.util.Optional;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import org.checkerframework.common.returnsreceiver.qual.*;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderMethodRef {\n+    @Getter @Setter @lombok.NonNull String foo;\n+    @Getter @Setter Object bar;\n+\n+    public static void test(Optional<Object> opt) {\n+        BuilderMethodRefBuilder b = builder().foo(\"Hello\");\n+        opt.ifPresent(b::bar);\n+        b.build();\n+    }\n+}\n+\n+class CustomBuilderMethodRefBuilder extends BuilderMethodRef.BuilderMethodRefBuilder {", "originalCommit": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTExMDA2MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r409110060", "bodyText": "These are great. My comment wasn't clear, but I was referring to framework/tests/returnsreceiverlombok/BuilderTest.java, which doesn't test anything other than that the RR checker issues no error on that file. It should check that the setters have @This annotations, too.", "author": "kelloggm", "createdAt": "2020-04-15T20:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMjA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2NzU3NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r409167574", "bodyText": "Now added", "author": "msridhar", "createdAt": "2020-04-15T22:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMjA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2ODEwNQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r409168105", "bodyText": "BTW, these extra tests are how we discovered the need for the extra flag for Lombok.  So they are definitely useful \ud83d\udc4d", "author": "msridhar", "createdAt": "2020-04-15T22:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMjA1NA=="}], "type": "inlineReview", "revised_code": {"commit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "chunk": "diff --git a/framework/tests/returnsreceiverlombok/BuilderMethodRef.java b/framework/tests/returnsreceiverlombok/BuilderMethodRef.java\nindex 6fb9093dc..baf916224 100644\n--- a/framework/tests/returnsreceiverlombok/BuilderMethodRef.java\n+++ b/framework/tests/returnsreceiverlombok/BuilderMethodRef.java\n\n@@ -13,6 +13,7 @@ public class BuilderMethodRef {\n \n     public static void test(Optional<Object> opt) {\n         BuilderMethodRefBuilder b = builder().foo(\"Hello\");\n+        // :: error: (methodref.receiver.bound.invalid)\n         opt.ifPresent(b::bar);\n         b.build();\n     }\n"}}, {"oid": "b879b77b7fde9edd496e668100611e9caafa0f68", "url": "https://github.com/typetools/checker-framework/commit/b879b77b7fde9edd496e668100611e9caafa0f68", "message": "fixed comment", "committedDate": "2020-04-15T17:55:45Z", "type": "commit"}, {"oid": "f67c44be28b04af2e1602cf6afa046d1281086b7", "url": "https://github.com/typetools/checker-framework/commit/f67c44be28b04af2e1602cf6afa046d1281086b7", "message": "Added wrapper methods", "committedDate": "2020-04-15T21:10:40Z", "type": "commit"}, {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "url": "https://github.com/typetools/checker-framework/commit/505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "message": "Merge branch 'master' into returnsrcvr-checker", "committedDate": "2020-04-16T20:52:07Z", "type": "commit"}, {"oid": "9ac96286a2c944ce7b0929bba4dc487e69521bd9", "url": "https://github.com/typetools/checker-framework/commit/9ac96286a2c944ce7b0929bba4dc487e69521bd9", "message": "Fix capitalization.", "committedDate": "2020-04-17T20:45:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410444033", "bodyText": "Documentation of the public purpose of this class would still be useful... is this meant as an opaque token?", "author": "wmdietl", "createdAt": "2020-04-17T20:06:06Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODA5Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410448092", "bodyText": "The point of the class seems to be method checkForFluentAPIGenerators. So I would have liked to see a documentation of that, not the implementation detail about the enum.", "author": "wmdietl", "createdAt": "2020-04-17T20:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODk4Nw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410448987", "bodyText": "(I'm also not sure whether I would repeat the class name in the method name... instead of FluentAPIGenerator.checkForFluentAPIGenerators isn't FluentAPIGenerator.check simpler and as clear?)", "author": "wmdietl", "createdAt": "2020-04-17T20:17:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MzQ2Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410463466", "bodyText": "You could also move the method to the beginning of the class...", "author": "wmdietl", "createdAt": "2020-04-17T20:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw=="}], "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex 4e82e8fd0..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -11,9 +11,31 @@ import org.checkerframework.javacutil.AnnotationUtils;\n import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n-/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n public class FluentAPIGenerator {\n \n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Enum of supported fluent API generators. For such generators, the checker can automatically\n      * add @This annotations on method return types in the generated code.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDU3Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410444572", "bodyText": "Should the needed instead be needs?", "author": "wmdietl", "createdAt": "2020-04-17T20:07:24Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex 4e82e8fd0..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -11,9 +11,31 @@ import org.checkerframework.javacutil.AnnotationUtils;\n import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n-/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n public class FluentAPIGenerator {\n \n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Enum of supported fluent API generators. For such generators, the checker can automatically\n      * add @This annotations on method return types in the generated code.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NTUzMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410445531", "bodyText": "Should enclosingType be enclosingElement or something else?", "author": "wmdietl", "createdAt": "2020-04-17T20:09:33Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to a side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex 4e82e8fd0..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -11,9 +11,31 @@ import org.checkerframework.javacutil.AnnotationUtils;\n import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n-/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n public class FluentAPIGenerator {\n \n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Enum of supported fluent API generators. For such generators, the checker can automatically\n      * add @This annotations on method return types in the generated code.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTI0OQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410449249", "bodyText": "This is the only public method for this class and should be documented.", "author": "wmdietl", "createdAt": "2020-04-17T20:18:00Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to a side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the annotated type of the method signature\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedExecutableType t);\n+    }\n+\n+    /**\n+     * @param t the annotated type of the method signature", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\nindex 4e82e8fd0..b52b0ab7a 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java\n\n@@ -11,9 +11,31 @@ import org.checkerframework.javacutil.AnnotationUtils;\n import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.TypesUtils;\n \n-/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n public class FluentAPIGenerator {\n \n+    /**\n+     * This is the only public method of this class\n+     *\n+     * @param t the annotated type of the method signature\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean check(AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Enum of supported fluent API generators. For such generators, the checker can automatically\n      * add @This annotations on method return types in the generated code.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTUxMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410449511", "bodyText": "Why does this need to be package private? Could it be protected or even private?", "author": "wmdietl", "createdAt": "2020-04-17T20:18:30Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NDA2Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410464062", "bodyText": "I see one usage outside this package, which could just use areSameByClass...\nat least add a comment why you used package private.", "author": "wmdietl", "createdAt": "2020-04-17T20:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTUxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\nindex 6d2c69a5e..f5ad162b3 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n\n@@ -19,7 +19,10 @@ import org.checkerframework.javacutil.AnnotationUtils;\n /** The type factory for the Returns Receiver Checker. */\n public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n \n-    /** The {@code @}{@link This} annotation. */\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n     final AnnotationMirror THIS_ANNOTATION;\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MDY3Nw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410450677", "bodyText": "Why not simply return if it's a constructor? That makes the intent even clearer and reduces the indentation for the rest of the method.", "author": "wmdietl", "createdAt": "2020-04-17T20:20:53Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\nindex 6d2c69a5e..f5ad162b3 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n\n@@ -19,7 +19,10 @@ import org.checkerframework.javacutil.AnnotationUtils;\n /** The type factory for the Returns Receiver Checker. */\n public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n \n-    /** The {@code @}{@link This} annotation. */\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n     final AnnotationMirror THIS_ANNOTATION;\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MTk5MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410451990", "bodyText": "Why do you need this special logic?\nCouldn't you simply add @DefaultFor({TypeUseLocation.RECEIVER}) to the declaration of @This?\nAll receivers are @This. The only extra logic you need is to automatically make the fluent API return types @This.", "author": "wmdietl", "createdAt": "2020-04-17T20:23:46Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+                // If any FluentAPIGenerator indicates the method returns this,\n+                // add an @This annotation on the return type.\n+                if (FluentAPIGenerator.checkForFluentAPIGenerators(t)) {\n+                    if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                        returnType.addAnnotation(THIS_ANNOTATION);\n+                    }\n+                }\n+\n+                // If return type is annotated with @This, add @This annotation", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\nindex 6d2c69a5e..f5ad162b3 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n\n@@ -19,7 +19,10 @@ import org.checkerframework.javacutil.AnnotationUtils;\n /** The type factory for the Returns Receiver Checker. */\n public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n \n-    /** The {@code @}{@link This} annotation. */\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n     final AnnotationMirror THIS_ANNOTATION;\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MzQyNw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410453427", "bodyText": "There is a single use of this method.\nWouldn't it be much simpler to simply write if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) { return; } above? (Addressing my earlier comment about returning early.)", "author": "wmdietl", "createdAt": "2020-04-17T20:26:58Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+                // If any FluentAPIGenerator indicates the method returns this,\n+                // add an @This annotation on the return type.\n+                if (FluentAPIGenerator.checkForFluentAPIGenerators(t)) {\n+                    if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                        returnType.addAnnotation(THIS_ANNOTATION);\n+                    }\n+                }\n+\n+                // If return type is annotated with @This, add @This annotation\n+                // to the receiver type.\n+                AnnotationMirror retAnnotation =\n+                        returnType.getAnnotationInHierarchy(THIS_ANNOTATION);\n+                if (retAnnotation != null\n+                        && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n+                    AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n+                    if (!receiverType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                        receiverType.addAnnotation(THIS_ANNOTATION);\n+                    }\n+                }\n+            }\n+            return super.visitExecutable(t, p);\n+        }\n+    }\n+\n+    /**\n+     * @return {@code true} if the param {@code t} is a {@code Constructor}\n+     * @param t a {@link AnnotatedTypeMirror}\n+     */\n+    private boolean isConstructor(AnnotatedTypeMirror.AnnotatedExecutableType t) {", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\nindex 6d2c69a5e..f5ad162b3 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n\n@@ -19,7 +19,10 @@ import org.checkerframework.javacutil.AnnotationUtils;\n /** The type factory for the Returns Receiver Checker. */\n public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n \n-    /** The {@code @}{@link This} annotation. */\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n     final AnnotationMirror THIS_ANNOTATION;\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTczOQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410455739", "bodyText": "I find !isReturn && !isCastAnnot easier to look at visually and easier to understand... but you might prefer this way.", "author": "wmdietl", "createdAt": "2020-04-17T20:32:31Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {\n+        AnnotationMirror annot = TreeUtils.annotationFromAnnotationTree(node);\n+        // Warn if a @This annotation is in an illegal location.\n+        if (AnnotationUtils.areSame(annot, getTypeFactory().THIS_ANNOTATION)) {\n+            TreePath parentPath = getCurrentPath().getParentPath();\n+            Tree parent = parentPath.getLeaf();\n+            Tree grandparent = parentPath.getParentPath().getLeaf();\n+            boolean isReturnAnnot =\n+                    grandparent instanceof MethodTree\n+                            && (parent.equals(((MethodTree) grandparent).getReturnType())\n+                                    || parent instanceof ModifiersTree);\n+            boolean isCastAnnot =\n+                    grandparent instanceof TypeCastTree\n+                            && parent.equals(((TypeCastTree) grandparent).getType());\n+            if (!(isReturnAnnot || isCastAnnot)) {", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM2OTQ1Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r412369456", "bodyText": "I personally like it this way \ud83d\ude42 I think we will leave it", "author": "msridhar", "createdAt": "2020-04-21T17:54:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNDc5OQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413404799", "bodyText": "Sure, no objection.", "author": "wmdietl", "createdAt": "2020-04-22T23:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTczOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java\nindex 27946907f..01feb7b46 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java\n\n@@ -36,7 +36,7 @@ public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnot\n                     grandparent instanceof TypeCastTree\n                             && parent.equals(((TypeCastTree) grandparent).getType());\n             if (!(isReturnAnnot || isCastAnnot)) {\n-                checker.reportError(node, \"invalid.this.location\");\n+                checker.reportError(node, \"type.invalid.this.location\");\n             }\n         }\n         return super.visitAnnotation(node, p);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1OTY4Nw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410459687", "bodyText": "value -> type", "author": "wmdietl", "createdAt": "2020-04-17T20:42:18Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java\nindex 584c0cba5..90fb40393 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java\n\n@@ -19,7 +19,7 @@ import org.checkerframework.framework.qual.PolymorphicQualifier;\n  * }\n  * </code></pre>\n  *\n- * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return type, the\n  * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent\n  * to:\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410460189", "bodyText": "Instead of putting it so operationally, why not make this simply a default for all receivers.\nIs there any harm if they are always @This?\nIs there any harm in allowing programmers to explicitly mark receivers @This?", "author": "wmdietl", "createdAt": "2020-04-17T20:43:29Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4MDgxNg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413180816", "bodyText": "In terms of explicitly marking receivers @This, I think that just adds confusion with not much gain (probably most programmers don't even know you can annotate the receiver).  But let's see, maybe we'll be able to make it default if we can work out the implementation issues.", "author": "msridhar", "createdAt": "2020-04-22T17:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNzA4Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413407082", "bodyText": "I would see it the other way around: why forbid something that other type systems allow? Conceptually, you want that both the receiver and return type are annotated @This. So if somebody wants to make that explicit, what's the harm? Most users won't care about this, I agree, but it would make the type system follow the common style of the framework.", "author": "wmdietl", "createdAt": "2020-04-22T23:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5NzAyNg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413997026", "bodyText": "@wmdietl what if a programmer writes @This on the receiver but not the return value?  Should we add code to insert @This on the return value in that case?", "author": "msridhar", "createdAt": "2020-04-23T17:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzMzAzMw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r414033033", "bodyText": "I would add @This on the return value exactly when it is currently, regardless of whether @This is explicitly or implicitly written on the receiver.", "author": "mernst", "createdAt": "2020-04-23T18:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0NDMxMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r414644311", "bodyText": "In my mind, the receiver parameter is always @This. The return type is only @This if it is a special method that actually returns the receiver.\nSo no, I don't think there should be logic that adds @This to the return type if the receiver has it.", "author": "wmdietl", "createdAt": "2020-04-24T15:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java\nindex 584c0cba5..90fb40393 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java\n\n@@ -19,7 +19,7 @@ import org.checkerframework.framework.qual.PolymorphicQualifier;\n  * }\n  * </code></pre>\n  *\n- * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return type, the\n  * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent\n  * to:\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MTkxMw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410461913", "bodyText": "You should start javadoc sentences with an upper case letter and end it with a ..", "author": "wmdietl", "createdAt": "2020-04-17T20:47:27Z", "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * tests the returns receiver checker's lombok integration, the test files in", "originalCommit": "9ac96286a2c944ce7b0929bba4dc487e69521bd9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/test/java/tests/ReturnsReceiverLombokTest.java b/framework/src/test/java/tests/ReturnsReceiverLombokTest.java\nindex 5ffa67001..7ba9f1d77 100644\n--- a/framework/src/test/java/tests/ReturnsReceiverLombokTest.java\n+++ b/framework/src/test/java/tests/ReturnsReceiverLombokTest.java\n\n@@ -7,9 +7,9 @@ import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n import org.junit.runners.Parameterized.Parameters;\n \n /**\n- * tests the returns receiver checker's lombok integration, the test files in\n+ * Tests the returns receiver checker's lombok integration, the test files in\n  * tests/returnsreceiverlombok package will be delomboked into tests/returnsreceiverdelomboked\n- * package before running the test and the returns receiver checker will run on the generated codes\n+ * package before running the test and the returns receiver checker will run on the generated codes.\n  */\n public class ReturnsReceiverLombokTest extends CheckerFrameworkPerDirectoryTest {\n     public ReturnsReceiverLombokTest(List<File> testFiles) {\n"}}, {"oid": "63ae99f8b3c757104c221ca87f52c2e56fba693e", "url": "https://github.com/typetools/checker-framework/commit/63ae99f8b3c757104c221ca87f52c2e56fba693e", "message": "resolved comments", "committedDate": "2020-04-20T00:31:54Z", "type": "commit"}, {"oid": "73f6ce9dcf2d274ea08f003243f7db531f446f40", "url": "https://github.com/typetools/checker-framework/commit/73f6ce9dcf2d274ea08f003243f7db531f446f40", "message": "fix javadoc", "committedDate": "2020-04-20T01:24:46Z", "type": "commit"}, {"oid": "9958a0d5cd8552a83e658d07f94e39ba7dd87f82", "url": "https://github.com/typetools/checker-framework/commit/9958a0d5cd8552a83e658d07f94e39ba7dd87f82", "message": "Spell-check", "committedDate": "2020-04-20T20:27:47Z", "type": "commit"}, {"oid": "0a89bed9475226d1cce89e009d15ad7eeb0400f8", "url": "https://github.com/typetools/checker-framework/commit/0a89bed9475226d1cce89e009d15ad7eeb0400f8", "message": "Improve changelog entry", "committedDate": "2020-04-20T20:27:52Z", "type": "commit"}, {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc", "url": "https://github.com/typetools/checker-framework/commit/7242e9cc6bd47f7918d96069f0cfebbe12a930cc", "message": "Rewordings from review", "committedDate": "2020-04-20T20:30:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r411710045", "bodyText": "#3199 (comment)\nDid you try using @DefaultFor({TypeUseLocation.RECEIVER}) on the declaration of @This?", "author": "wmdietl", "createdAt": "2020-04-20T21:38:33Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "originalCommit": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNTIzOA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r412435238", "bodyText": "I tried adding this to the declaration of @This, but below tests fails for this change:\n\nreturnsreceiver\nall-systems/java8/memberref\nall-systems/java8/lambda\nall-systems/java8inference\n\nIs there anything else I should do to make this change or we should keep it as it is ?", "author": "nimakarimipour", "createdAt": "2020-04-21T19:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3OTA0Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413179046", "bodyText": "It seems the primary issue here is with method references.  Here is one false-positive report we get:\ntests/all-systems/java8/memberref/MemberReferences.java:119: error: [methodref.receiver.bound.invalid] Incompatible receiver type\n        Consumer<Number> f1 = bound::func1;\n                              ^\n  Method\n    @UnknownThis BoundWithArg<@UnknownThis Number>\n  is not a valid method reference for\n    void func1(@This BoundWithArg<@UnknownThis Number> this, @UnknownThis Number p0) in BoundWithArg\n  found   : @UnknownThis BoundWithArg<@UnknownThis Number>\n  required: @This BoundWithArg<@UnknownThis Number>\n\n@wmdietl I'm not sure why this is an error; seems like an interaction between polymorphic annotations and generics?  Maybe it's a Checker Framework bug?", "author": "msridhar", "createdAt": "2020-04-22T17:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMzQ3Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413403476", "bodyText": "It looks like you don't have a lot of lambda/method reference tests and running on all-systems with the change revealed that...\nThe following test without generics gives a similar error (incorrectly I named it Lambda, but then I used a method reference... I'm sure you can write something similar that actually uses a lambda):\nimport org.checkerframework.common.returnsreceiver.qual.*;\n\nclass Lambda {\n\n    @This Lambda set(Object o) {\n        return this;\n    }\n\n    interface Setter {\n        @This Object consume(Object p);\n    }\n\n    Setter co = this::set;\n}\ngives:\nLambda.java:13: error: [methodref.receiver.bound.invalid] Incompatible receiver type\n    Setter co = this::set;\n                ^\n  Method\n    @UnknownThis Lambda\n  is not a valid method reference for\n    @This Lambda set(@This Lambda this, @UnknownThis Object p0) in Lambda\n  found   : @UnknownThis Lambda\n  required: @This Lambda\n1 error\n\nThis is with tip of this branch, so independent of the proposed change.\nShould that be an error? What is the allowed interaction between @This and lamdas/method references?", "author": "wmdietl", "createdAt": "2020-04-22T23:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNzI5NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413407295", "bodyText": "Good catch!  I am not sure what is going on here.  Our checker should be adding @This on the receiver of set().  @wmdietl do you happen to know why this error message says @UnknownThis Lambda as opposed to @This Lambda?", "author": "msridhar", "createdAt": "2020-04-22T23:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMDE4OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413410188", "bodyText": "No, I don't. Maybe there is a problem with how polymorphic annotations are resolved on receivers?", "author": "wmdietl", "createdAt": "2020-04-22T23:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMjU4NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413412585", "bodyText": "The error message seems odd, as it says Method @UnknownThis Lambda, which is just a declared type, not a method type.", "author": "wmdietl", "createdAt": "2020-04-22T23:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5NzkwMw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413497903", "bodyText": "I think the error message is just phrased poorly.  What seems to be going on is that there is a subtype check that fails because @UnknownThis Lambda is not a subtype of @This Lambda.  I've added this example as a test case now but renamed it to MethodRef.\nI am not too sure about how to fix this one, and whether it's a bug in our checker or not.  @smillst any chance you could take a look?", "author": "msridhar", "createdAt": "2020-04-23T04:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM3MDAxMw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r415370013", "bodyText": "Thinking more, this example is actually quite subtle, and I'm now not sure if there should be a type error or not.  Consider this extended version of the example:\nimport org.checkerframework.common.returnsreceiver.qual.*;\n\nclass MethodRef {\n\n    @This MethodRef set(Object o) {\n        return this;\n    }\n\n    interface Setter {\n        @This Object consume(Object p);\n    }\n\n    Setter co = this::set;\n\n    public static void main(String[] args) {\n        MethodRef m = new MethodRef();\n        // this assertion fails!\n        assert m.co.consume(new Object()) == m.co : \"not returning receiver\";\n    }\n}\nI read the @This annotation on the Setter.consume() return type as indicating that any implementation of Setter.consume() should return its receiver.  But if we allow the above code to type check, that property does not hold (since this::set will return the value of this bound by the method reference, not the receiver passed into the call to consume()).\nSo maybe there should be an error in this case (perhaps with a better message)?  @wmdietl @kelloggm @mernst thoughts?", "author": "msridhar", "createdAt": "2020-04-26T18:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQzNzk3MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r415437970", "bodyText": "The Checker Framework does not handle polymorphic qualifiers receivers on the functional methods to member references are assigned.  For example, the receiver of Setter#consume has a polymorphic annotation on its receiver so, Setter co = this::set; causes a weird error.  There should be some sort of error, but methodref.receiver.bound.invalid seems to be the wrong one.\nWe have one open issue on the #2931.  I've added an example to that issue using the Tainting Checker that shows this problem.\nI would just work around this problem in this checker, which I think that's why you wrote the defaulting in place to begin with.  So, maybe just add a comment pointing to #2931?", "author": "smillst", "createdAt": "2020-04-27T00:26:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ0NzUzNg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r415447536", "bodyText": "Thanks a lot, @smillst!  It seems like we will run into this issue whether @This is the default for receivers or not.  So I think ideally we should follow @wmdietl's suggestion to use @DefaultFor({TypeUseLocation.RECEIVER}) (which will save us a bit of code).  But then, some of the all-systems tests will fail.  Is there a way to suppress some warnings but still use the all-systems tests?", "author": "msridhar", "createdAt": "2020-04-27T01:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEwMzg0Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416103846", "bodyText": "You can add\n@SuppressWarnings(\"returnsreceiver: methodref.receiver.bound.invalid\") // See Issue #2931\n\nto any all-systems tests that need it.  In general, it is acceptable to suppress a type system specific warning in the all-system test so long as an explanation is given.", "author": "smillst", "createdAt": "2020-04-27T19:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI3NDM1OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416274358", "bodyText": "Unfortunately, it seems that currently, we get too many false positives with method references if we use @DefaultFor({TypeUseLocation.RECEIVER}) on @This.  E.g., with receiver defaulting, we get an error in this variant:\nclass MethodRef {\n    void doNothing() {}\n\n    interface Fun {\n        void run();\n    }\n\n    Fun f = this::doNothing;\n}\nI think any method reference that binds the receiver will yield an error with the returns receiver checker if receivers are defaulted to @This.  I think this is an unacceptable level of false positives, so for now we will not do the defaulting but will leave a comment as to why we don't do it.", "author": "msridhar", "createdAt": "2020-04-28T02:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\nindex 7197dc4b1..f5ad162b3 100644\n--- a/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n+++ b/framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java\n\n@@ -19,7 +19,10 @@ import org.checkerframework.javacutil.AnnotationUtils;\n /** The type factory for the Returns Receiver Checker. */\n public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n \n-    /** The {@code @}{@link This} annotation. */\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n     final AnnotationMirror THIS_ANNOTATION;\n \n     /**\n"}}, {"oid": "aeffa88f34d52e488558c2423c1badc4142192ee", "url": "https://github.com/typetools/checker-framework/commit/aeffa88f34d52e488558c2423c1badc4142192ee", "message": "Merge branch 'master' into returnsrcvr-checker", "committedDate": "2020-04-22T17:18:02Z", "type": "commit"}, {"oid": "e6289b40a4c707268b186464097192be23c668aa", "url": "https://github.com/typetools/checker-framework/commit/e6289b40a4c707268b186464097192be23c668aa", "message": "add a comment", "committedDate": "2020-04-22T17:36:15Z", "type": "commit"}]}