{"pr_number": 3882, "pr_title": "Make an implicit behavior explicit", "pr_createdAt": "2020-11-09T05:54:51Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3882", "timeline": [{"oid": "87facedf64daa6f160363d3e269199d06b7be7b8", "url": "https://github.com/typetools/checker-framework/commit/87facedf64daa6f160363d3e269199d06b7be7b8", "message": "Make an implicit behavior explicit", "committedDate": "2020-11-09T00:53:40Z", "type": "commit"}, {"oid": "9dd0199690f79a3a11238a25fe110ade8a9fb65c", "url": "https://github.com/typetools/checker-framework/commit/9dd0199690f79a3a11238a25fe110ade8a9fb65c", "message": "Add Javadoc", "committedDate": "2020-11-09T05:50:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA0MDYwMQ==", "url": "https://github.com/typetools/checker-framework/pull/3882#discussion_r520040601", "bodyText": "This method operates on AnnotatedTypeMirrors, so instead of, if both annotations this should be if neither annotated type has a primary annotation.", "author": "smillst", "createdAt": "2020-11-09T18:52:24Z", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -215,10 +215,12 @@ protected boolean isPrimarySubtype(AnnotatedTypeMirror subtype, AnnotatedTypeMir\n     /**\n      * Compare the primary annotations of {@code subtype} and {@code supertype}.\n      *\n+     * @param subtype the type that might be a subtype\n+     * @param supertype the type that might be a supertype\n      * @param annosCanBeEmtpy indicates that annotations may be missing from the typemirror\n      * @return true if the primary annotation on subtype {@literal <:} primary annotation on\n-     *     supertype for the current top or both annotations are null. False is returned if one\n-     *     annotation is null and the other is not.\n+     *     supertype for the current top. Returns true if both annotations are null. Returns false", "originalCommit": "9dd0199690f79a3a11238a25fe110ade8a9fb65c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15f9ffbbaf72835294e4f2d019eaa48b98ba90a6", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java b/framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java\nindex cf3183641..a56ce6e78 100644\n--- a/framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java\n+++ b/framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java\n\n@@ -219,8 +219,8 @@ public class DefaultTypeHierarchy extends AbstractAtmComboVisitor<Boolean, Void>\n      * @param supertype the type that might be a supertype\n      * @param annosCanBeEmtpy indicates that annotations may be missing from the typemirror\n      * @return true if the primary annotation on subtype {@literal <:} primary annotation on\n-     *     supertype for the current top. Returns true if both annotations are null. Returns false\n-     *     if one annotation is null and the other is not.\n+     *     supertype for the current top. Returns true if neither annotated type has a primary\n+     *     annotation. Returns false if one annotation is does and the other does not.\n      */\n     protected boolean isPrimarySubtype(\n             AnnotatedTypeMirror subtype, AnnotatedTypeMirror supertype, boolean annosCanBeEmtpy) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA0MjExMw==", "url": "https://github.com/typetools/checker-framework/pull/3882#discussion_r520042113", "bodyText": "Without this change, if only one of the annotations is null,  qualifierHierarchy.isSubtype(subtypeAnno, supertypeAnno); would throw an exception.  But the Javadoc says that false should be returned in that case, so I think this is a good change.", "author": "smillst", "createdAt": "2020-11-09T18:54:49Z", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -247,8 +249,13 @@ protected boolean isAnnoSubtype(\n             @Nullable AnnotationMirror subtypeAnno,\n             @Nullable AnnotationMirror supertypeAnno,\n             boolean annosCanBeEmtpy) {\n-        if (annosCanBeEmtpy && subtypeAnno == null && supertypeAnno == null) {\n-            return true;\n+        if (annosCanBeEmtpy) {", "originalCommit": "9dd0199690f79a3a11238a25fe110ade8a9fb65c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA0NDQxMg==", "url": "https://github.com/typetools/checker-framework/pull/3882#discussion_r520044412", "bodyText": "If that is the case, then no client has ever taken advantage of this documented behavior.  Would it be better to simplify the specification rather than making the implementation more complex?  (I'm not sure which way I lean on that question.)", "author": "mernst", "createdAt": "2020-11-09T18:58:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA0MjExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDExNjUzMQ==", "url": "https://github.com/typetools/checker-framework/pull/3882#discussion_r520116531", "bodyText": "I don't have a good argument for either option.  Really if both annotations are null this method shouldn't be called, so throwing an exception in that case makes sense.  So maybe it is better to change the documentation.", "author": "smillst", "createdAt": "2020-11-09T20:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA0MjExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE1MzA1Mg==", "url": "https://github.com/typetools/checker-framework/pull/3882#discussion_r520153052", "bodyText": "Mention type variables in javadoc.  Change the Javadoc to match implementation.", "author": "smillst", "createdAt": "2020-11-09T22:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA0MjExMw=="}], "type": "inlineReview", "revised_code": {"commit": "5254d570586b4ea9d3c688ae35c2fda475eb9c3f", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java b/framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java\nindex cf3183641..fa30075e4 100644\n--- a/framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java\n+++ b/framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java\n\n@@ -209,87 +208,18 @@ public class DefaultTypeHierarchy extends AbstractAtmComboVisitor<Boolean, Void>\n      *     supertype for the current top.\n      */\n     protected boolean isPrimarySubtype(AnnotatedTypeMirror subtype, AnnotatedTypeMirror supertype) {\n-        return isPrimarySubtype(subtype, supertype, false);\n-    }\n-\n-    /**\n-     * Compare the primary annotations of {@code subtype} and {@code supertype}.\n-     *\n-     * @param subtype the type that might be a subtype\n-     * @param supertype the type that might be a supertype\n-     * @param annosCanBeEmtpy indicates that annotations may be missing from the typemirror\n-     * @return true if the primary annotation on subtype {@literal <:} primary annotation on\n-     *     supertype for the current top. Returns true if both annotations are null. Returns false\n-     *     if one annotation is null and the other is not.\n-     */\n-    protected boolean isPrimarySubtype(\n-            AnnotatedTypeMirror subtype, AnnotatedTypeMirror supertype, boolean annosCanBeEmtpy) {\n         final AnnotationMirror subtypeAnno = subtype.getAnnotationInHierarchy(currentTop);\n         final AnnotationMirror supertypeAnno = supertype.getAnnotationInHierarchy(currentTop);\n         if (checker.getTypeFactory().hasQualifierParameterInHierarchy(supertype, currentTop)\n                 && checker.getTypeFactory().hasQualifierParameterInHierarchy(subtype, currentTop)) {\n             // If the types have a class qualifier parameter, the qualifiers must be equivalent.\n-            return isAnnoSubtype(subtypeAnno, supertypeAnno, annosCanBeEmtpy)\n-                    && isAnnoSubtype(supertypeAnno, subtypeAnno, annosCanBeEmtpy);\n-        }\n-\n-        return isAnnoSubtype(subtypeAnno, supertypeAnno, annosCanBeEmtpy);\n-    }\n-\n-    /**\n-     * Compare the primary annotations of {@code subtype} and {@code supertype}.\n-     *\n-     * @param subtypeAnno annotation that may be a subtype\n-     * @param supertypeAnno annotation that may be a supertype\n-     * @param annosCanBeEmtpy indicates that annotations may be missing from the typemirror\n-     * @return true if subtype {@literal <:} supertype or both annotations are null. False is\n-     *     returned if one annotation is null and the other is not.\n-     */\n-    protected boolean isAnnoSubtype(\n-            @Nullable AnnotationMirror subtypeAnno,\n-            @Nullable AnnotationMirror supertypeAnno,\n-            boolean annosCanBeEmtpy) {\n-        if (annosCanBeEmtpy) {\n-            if (subtypeAnno == null && supertypeAnno == null) {\n-                return true;\n-            }\n-            if (subtypeAnno == null || supertypeAnno == null) {\n-                return false;\n-            }\n+            return qualifierHierarchy.isSubtype(subtypeAnno, supertypeAnno)\n+                    && qualifierHierarchy.isSubtype(supertypeAnno, subtypeAnno);\n         }\n \n         return qualifierHierarchy.isSubtype(subtypeAnno, supertypeAnno);\n     }\n \n-    /**\n-     * Returns true if subtype is the bottom type in the current hierarchy.\n-     *\n-     * @param subtype type to test against bottom\n-     * @return true if subtype's primary annotation is bottom\n-     */\n-    protected boolean isBottom(final AnnotatedTypeMirror subtype) {\n-        final AnnotationMirror bottom = qualifierHierarchy.getBottomAnnotation(currentTop);\n-        if (bottom == null) {\n-            throw new BugInCF(\"getBottomAnnotation(%s) is null\", currentTop);\n-        }\n-\n-        switch (subtype.getKind()) {\n-            case TYPEVAR:\n-                return isBottom(((AnnotatedTypeVariable) subtype).getUpperBound());\n-\n-            case WILDCARD:\n-                final AnnotatedWildcardType subtypeWc = (AnnotatedWildcardType) subtype;\n-                return isBottom(subtypeWc);\n-\n-                // TODO: DO ANYTHING SPECIAL FOR INTERSECTIONS OR UNIONS?\n-                // TODO: ENUMERATE THE VALID CASES?\n-\n-            default:\n-                final AnnotationMirror subtypeAnno = subtype.getAnnotationInHierarchy(currentTop);\n-                return isAnnoSubtype(subtypeAnno, bottom, false);\n-        }\n-    }\n-\n     /**\n      * Like {@link #isSubtype(AnnotatedTypeMirror, AnnotatedTypeMirror)}, but uses a cache to\n      * prevent infinite recursion on recursive types.\n"}}, {"oid": "15f9ffbbaf72835294e4f2d019eaa48b98ba90a6", "url": "https://github.com/typetools/checker-framework/commit/15f9ffbbaf72835294e4f2d019eaa48b98ba90a6", "message": "Tweak wording", "committedDate": "2020-11-09T18:58:46Z", "type": "commit"}, {"oid": "5254d570586b4ea9d3c688ae35c2fda475eb9c3f", "url": "https://github.com/typetools/checker-framework/commit/5254d570586b4ea9d3c688ae35c2fda475eb9c3f", "message": "Remove methods.", "committedDate": "2020-11-12T17:42:07Z", "type": "commit"}, {"oid": "d81b041dd55bf4509821811a387403c01de69a44", "url": "https://github.com/typetools/checker-framework/commit/d81b041dd55bf4509821811a387403c01de69a44", "message": "Merge remote-tracking branch 'origin/master' into defaulttypehierarchy-optimization", "committedDate": "2020-11-12T17:42:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5NjI3MQ==", "url": "https://github.com/typetools/checker-framework/pull/3882#discussion_r522296271", "bodyText": "Both this method and isAnnoSubtype either called with annosCanBeEmtpy = false or the code checked that the annotations were nonnull before calling them.  So I just deleted these methods.", "author": "smillst", "createdAt": "2020-11-12T17:44:42Z", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -209,80 +208,18 @@ protected String defaultErrorMessage(\n      *     supertype for the current top.\n      */\n     protected boolean isPrimarySubtype(AnnotatedTypeMirror subtype, AnnotatedTypeMirror supertype) {\n-        return isPrimarySubtype(subtype, supertype, false);\n-    }\n-\n-    /**\n-     * Compare the primary annotations of {@code subtype} and {@code supertype}.\n-     *\n-     * @param annosCanBeEmtpy indicates that annotations may be missing from the typemirror\n-     * @return true if the primary annotation on subtype {@literal <:} primary annotation on\n-     *     supertype for the current top or both annotations are null. False is returned if one\n-     *     annotation is null and the other is not.\n-     */\n-    protected boolean isPrimarySubtype(", "originalCommit": "d81b041dd55bf4509821811a387403c01de69a44", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "20a1e3c4e7f1006b9d5ccd18c30751195471684c", "chunk": "diff --git a/framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java b/framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java\nindex fa30075e4..32752f0f2 100644\n--- a/framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java\n+++ b/framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java\n\n@@ -204,6 +204,8 @@ public class DefaultTypeHierarchy extends AbstractAtmComboVisitor<Boolean, Void>\n      * Compare the primary annotations of {@code subtype} and {@code supertype}. Neither type can be\n      * missing annotations.\n      *\n+     * @param subtype a type that might be a subtype (with respect to primary annotations)\n+     * @param supertype a type that might be a supertype (with respect to primary annotations)\n      * @return true if the primary annotation on subtype {@literal <:} primary annotation on\n      *     supertype for the current top.\n      */\n"}}, {"oid": "20a1e3c4e7f1006b9d5ccd18c30751195471684c", "url": "https://github.com/typetools/checker-framework/commit/20a1e3c4e7f1006b9d5ccd18c30751195471684c", "message": "Add Javadoc", "committedDate": "2020-11-12T18:10:51Z", "type": "commit"}]}