{"pr_number": 1826, "pr_title": "[LOCKING_STRATEGY] implementing different strategies for diagnose and\u2026", "pr_createdAt": "2020-12-16T17:19:06Z", "pr_url": "https://github.com/kiegroup/jbpm/pull/1826", "timeline": [{"oid": "3fd114fd9adcac8725b104e28cd3cfe6ad87ac65", "url": "https://github.com/kiegroup/jbpm/commit/3fd114fd9adcac8725b104e28cd3cfe6ad87ac65", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution", "committedDate": "2020-12-17T07:41:04Z", "type": "forcePushed"}, {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "url": "https://github.com/kiegroup/jbpm/commit/2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution", "committedDate": "2020-12-17T16:28:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE4MDU4Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545180583", "bodyText": "Maybe putIfAbsent is a perfect fit here?", "author": "MarianMacik", "createdAt": "2020-12-17T15:31:16Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        this.engineLocks = new HashMap<>();\n+    }\n+\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) throws InterruptedException {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            if(!engineLocks.containsKey(id)) {\n+                engineLocks.put(id, new RuntimeManagerLockThreadsInfo(runtimeManagerLockFactory.newRuntimeManagerLock()));\n+            }", "originalCommit": "3fd114fd9adcac8725b104e28cd3cfe6ad87ac65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY2NDYyMg==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545664622", "bodyText": "computeIfAbsent idea from gonzalo.", "author": "elguardian", "createdAt": "2020-12-18T08:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE4MDU4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\nindex d07007e31..01ff1d72a 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n\n@@ -88,7 +88,7 @@ public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManag\n \n         if (lockThreadsInfo.isHeldByCurrentThread()) {\n             unlock(lockThreadsInfo.getRuntimeManagerLock());\n-            logger.debug(\"{} unlocked by {}\", lockThreadsInfo, runtime);\n+            logger.debug(\"[LOCK] process instance id {} with thread info {} unlocked by {}\", id, lockThreadsInfo, runtime);\n         } else {\n             logger.warn(\"[LOCK] trying to unlock for {} for lock {} no lock held by {}\", id, lockThreadsInfo, runtime);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIwMTMwMQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545201301", "bodyText": "When we call unlock, we already must have the lock in the same thread, or not?\nCalling unlock() from the different thread (\"worker\" thread) than the one which called lock() (the \"main\" thread) can happen only if somebody passes an already locked runtimeEngine to the \"worker\" thread and then the \"worker\" thread calls disposeRuntimeEngine. In that case the engine gets disposed (disposed == true), but the lock is not released as the \"worker\" thread doesn't hold the lock. But if the \"main\" thread calls disposeRuntimeEngine afterwards to release the lock, the engine is already disposed, so canDispose will return false and the lock is never released. So maybe we could remove this check and let the IllegalMonitorStateException which will be thrown by the ReentrantLock propagate? So a user at least knows that the runtime engine is leaking to the other thread?\nBut maybe it is just a precaution/best practice to not get an exception... Just thinking out loud.", "author": "MarianMacik", "createdAt": "2020-12-17T15:57:08Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        this.engineLocks = new HashMap<>();\n+    }\n+\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) throws InterruptedException {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            if(!engineLocks.containsKey(id)) {\n+                engineLocks.put(id, new RuntimeManagerLockThreadsInfo(runtimeManagerLockFactory.newRuntimeManagerLock()));\n+            }\n+            lockThreadsInfo = engineLocks.get(id);\n+            lockThreadsInfo.set();\n+        }\n+        logger.debug(\"Trying to get a lock {} for {} by {}\", lockThreadsInfo, id, runtime);\n+        try {\n+            lock(lockThreadsInfo.getRuntimeManagerLock());\n+        } catch(InterruptedException e) {\n+            logger.warn(\"Interrupted lock {}\", lockThreadsInfo.getRuntimeManagerLock());\n+            throw e;\n+        }\n+        logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lockThreadsInfo, id, runtime, lockThreadsInfo.hasQueuedThreads());\n+    }\n+\n+    protected abstract void lock(RuntimeManagerLock lock) throws InterruptedException;\n+    \n+    @Override\n+    public void unlock(Long id, RuntimeEngine runtime) {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            lockThreadsInfo = engineLocks.get(id);\n+            if (lockThreadsInfo == null) {\n+                logger.warn(\"[LOCK] lock {} is already removed for {} unlocked by {}\", id, lockThreadsInfo, runtime);\n+                return;\n+            }\n+            lockThreadsInfo.unset();\n+            if (lockThreadsInfo.count() == 0) {\n+                logger.debug(\"[LOCK] Removing lock for {} for lock  {} from list as non is waiting for it by {}\", id, lockThreadsInfo, runtime);\n+                engineLocks.remove(id);\n+            }\n+        }\n+\n+        if (lockThreadsInfo.isHeldByCurrentThread()) {", "originalCommit": "3fd114fd9adcac8725b104e28cd3cfe6ad87ac65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY2Njk3Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545666977", "bodyText": "Actually there are more threads involved... the thread reaper can try to call the disposable when calls the tx synchronzation after completion. it something that surprised me after testing. I did not understand why that was there.\nIf you throw another exception during after completion the behavior of the tx manager is unknown. at least for me. that is the reason I set a warn message.", "author": "elguardian", "createdAt": "2020-12-18T08:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIwMTMwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\nindex d07007e31..01ff1d72a 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n\n@@ -88,7 +88,7 @@ public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManag\n \n         if (lockThreadsInfo.isHeldByCurrentThread()) {\n             unlock(lockThreadsInfo.getRuntimeManagerLock());\n-            logger.debug(\"{} unlocked by {}\", lockThreadsInfo, runtime);\n+            logger.debug(\"[LOCK] process instance id {} with thread info {} unlocked by {}\", id, lockThreadsInfo, runtime);\n         } else {\n             logger.warn(\"[LOCK] trying to unlock for {} for lock {} no lock held by {}\", id, lockThreadsInfo, runtime);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIwMjY5OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545202699", "bodyText": "Synchronized block + RuntimeManagerLockThreadsInfo wrapper solves the issue with lockThreadsInfo.hasQueuedThreads() + removal of the lock which wasn't atomic, right? More info in my comment in the LegacyRuntimeManagerLockStrategy.", "author": "MarianMacik", "createdAt": "2020-12-17T15:58:52Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        this.engineLocks = new HashMap<>();\n+    }\n+\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) throws InterruptedException {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            if(!engineLocks.containsKey(id)) {\n+                engineLocks.put(id, new RuntimeManagerLockThreadsInfo(runtimeManagerLockFactory.newRuntimeManagerLock()));\n+            }\n+            lockThreadsInfo = engineLocks.get(id);\n+            lockThreadsInfo.set();\n+        }\n+        logger.debug(\"Trying to get a lock {} for {} by {}\", lockThreadsInfo, id, runtime);\n+        try {\n+            lock(lockThreadsInfo.getRuntimeManagerLock());\n+        } catch(InterruptedException e) {\n+            logger.warn(\"Interrupted lock {}\", lockThreadsInfo.getRuntimeManagerLock());\n+            throw e;\n+        }\n+        logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lockThreadsInfo, id, runtime, lockThreadsInfo.hasQueuedThreads());\n+    }\n+\n+    protected abstract void lock(RuntimeManagerLock lock) throws InterruptedException;\n+    \n+    @Override\n+    public void unlock(Long id, RuntimeEngine runtime) {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            lockThreadsInfo = engineLocks.get(id);\n+            if (lockThreadsInfo == null) {\n+                logger.warn(\"[LOCK] lock {} is already removed for {} unlocked by {}\", id, lockThreadsInfo, runtime);\n+                return;\n+            }\n+            lockThreadsInfo.unset();\n+            if (lockThreadsInfo.count() == 0) {\n+                logger.debug(\"[LOCK] Removing lock for {} for lock  {} from list as non is waiting for it by {}\", id, lockThreadsInfo, runtime);\n+                engineLocks.remove(id);\n+            }\n+        }", "originalCommit": "3fd114fd9adcac8725b104e28cd3cfe6ad87ac65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY2OTEwMw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545669103", "bodyText": "see my comment above.", "author": "elguardian", "createdAt": "2020-12-18T08:49:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIwMjY5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\nindex d07007e31..01ff1d72a 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n\n@@ -88,7 +88,7 @@ public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManag\n \n         if (lockThreadsInfo.isHeldByCurrentThread()) {\n             unlock(lockThreadsInfo.getRuntimeManagerLock());\n-            logger.debug(\"{} unlocked by {}\", lockThreadsInfo, runtime);\n+            logger.debug(\"[LOCK] process instance id {} with thread info {} unlocked by {}\", id, lockThreadsInfo, runtime);\n         } else {\n             logger.warn(\"[LOCK] trying to unlock for {} for lock {} no lock held by {}\", id, lockThreadsInfo, runtime);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1MTk2NA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545251964", "bodyText": "In case we can call lock() on the same lock instance more than once in the same thread, we could unify this with the lock method:\nWe can add more and more stack traces for the same thread in case lock() is called more than once by the same thread in succession. But with unlock as soon as there is one unlock(), we throw away all the stacktraces. Maybe we could make use of getHoldCount() to see if this invocation is the last one and clear() only then?", "author": "MarianMacik", "createdAt": "2020-12-17T17:04:31Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/DebugRuntimeManagerLock.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+\n+\n+public class DebugRuntimeManagerLock implements RuntimeManagerLock {\n+\n+    private ReentrantLock lock = new ReentrantLock(true);\n+    private List<StackTraceElement[]> traces;\n+    private long currentThreadId;\n+\n+    public DebugRuntimeManagerLock() {\n+        traces = new ArrayList<>();\n+        currentThreadId = -1;\n+    }\n+    \n+    @Override\n+    public void lock() {\n+        lock.lock();\n+        addTraces();\n+    }\n+\n+    @Override\n+    public boolean tryLock(long units, TimeUnit timeUnit) throws InterruptedException {\n+        boolean outcome = lock.tryLock(units, timeUnit);\n+        if(outcome) {\n+            addTraces();\n+        }\n+        return outcome;\n+    }\n+\n+    @Override\n+    public void lockInterruptible() throws InterruptedException {\n+        lock.lockInterruptibly();\n+        addTraces();\n+    }\n+\n+    private void addTraces() {\n+        long newThreadId = Thread.currentThread().getId();\n+        if(currentThreadId < 0 || currentThreadId != newThreadId) {\n+            currentThreadId = newThreadId;\n+            traces.clear();\n+        }\n+        // we add all stack traces during reentrant lock\n+        traces.add(Thread.currentThread().getStackTrace());\n+    }\n+    @Override\n+    public void unlock() {\n+        if(currentThreadId == Thread.currentThread().getId()) {\n+            traces.clear(); // clean up\n+        }\n+        lock.unlock();", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY3MTI0OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545671249", "bodyText": "if there is a place where lock for the same process instance id in the same thread is calling more than once. the logic of that part is broken. A thread (request execution) should only invoke once the lock. That is also the reason a added more that one stack traces... to add diaganose that possibility (more than one call to lock in one request)\nThat is pretty good idea actually", "author": "elguardian", "createdAt": "2020-12-18T08:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1MTk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY3MzYxOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545673619", "bodyText": "done", "author": "elguardian", "createdAt": "2020-12-18T08:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1MTk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI2Nzg0Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r553267842", "bodyText": "Could we use here just getHoldCount() and clear traces only if it is equals to 1? Maybe we wouldn't need an additional counter for that.", "author": "MarianMacik", "createdAt": "2021-01-07T11:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1MTk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM5MDgzOA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r553390838", "bodyText": "will change", "author": "elguardian", "createdAt": "2021-01-07T15:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1MTk2NA=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/DebugRuntimeManagerLock.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/DebugRuntimeManagerLock.java\nindex 38649ce50..7ba4f3026 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/DebugRuntimeManagerLock.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/DebugRuntimeManagerLock.java\n\n@@ -28,11 +28,13 @@ public class DebugRuntimeManagerLock implements RuntimeManagerLock {\n \n     private ReentrantLock lock = new ReentrantLock(true);\n     private List<StackTraceElement[]> traces;\n+    private int count;\n     private long currentThreadId;\n \n     public DebugRuntimeManagerLock() {\n         traces = new ArrayList<>();\n         currentThreadId = -1;\n+        count = 0;\n     }\n     \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1NDk5Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545254993", "bodyText": "Just for better control we could rather throw here exception. As when a user makes a typo in the system property, they need to be informed ASAP I think. Here it can happen that they choose something, but they make a typo and thus it will work with a different strategy than they might expect. I think the default is already handled well with the default system property value.", "author": "MarianMacik", "createdAt": "2020-12-17T17:08:56Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.Iterator;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class RuntimeManagerLockStrategyFactory {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(RuntimeManagerLockStrategyFactory.class);\n+\n+    public String lockStrategyClassName;\n+    public String lockFactoryClassName;\n+\n+    public RuntimeManagerLockStrategyFactory() {\n+        this(System.getProperty(\"org.kie.jbpm.runtime.manager.lock.strategy\", LegacyRuntimeManagerLockStrategy.class.getName()),\n+             System.getProperty(\"org.kie.jbpm.runtime.manager.lock.factory\", DefaultRuntimeManagerLockFactory.class.getName()));\n+    }\n+\n+    public RuntimeManagerLockStrategyFactory(String strategy, String factory) {\n+        this.lockFactoryClassName = factory;\n+        this.lockStrategyClassName = strategy;\n+    }\n+\n+    public RuntimeManagerLockStrategy createFreeLockStrategy() {\n+        return new FreeRuntimeManagerLockStrategy();\n+    }\n+\n+    public RuntimeManagerLockStrategy createLockStrategy(String identifier) {\n+        RuntimeManagerLockStrategy runtimeManagerLockStrategy = null;\n+\n+        // choose the right locking system\n+        ServiceLoader<RuntimeManagerLockStrategy> loader = ServiceLoader.load(RuntimeManagerLockStrategy.class);\n+        Iterator<RuntimeManagerLockStrategy> iterator = loader.iterator();\n+        while (iterator.hasNext()) {\n+            RuntimeManagerLockStrategy lockStrategy = iterator.next();\n+            if (lockStrategy.getClass().getName().equals(lockStrategyClassName)) {\n+                runtimeManagerLockStrategy = lockStrategy;\n+                break;\n+            }\n+        }\n+\n+\n+        if (runtimeManagerLockStrategy == null) {\n+            runtimeManagerLockStrategy = new LegacyRuntimeManagerLockStrategy();\n+        }", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY3NjAxMA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545676010", "bodyText": "ok makes a lot of sense", "author": "elguardian", "createdAt": "2020-12-18T08:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1NDk5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyFactory.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyFactory.java\nindex e5326ef70..7112f9b9e 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyFactory.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyFactory.java\n\n@@ -61,7 +61,7 @@ public final class RuntimeManagerLockStrategyFactory {\n \n \n         if (runtimeManagerLockStrategy == null) {\n-            runtimeManagerLockStrategy = new LegacyRuntimeManagerLockStrategy();\n+            throw new RuntimeException(\"Could not find a proper RuntimeManagerLockStrategy for value \" + lockStrategyClassName);\n         }\n \n         RuntimeManagerLockFactory runtimeManagerLockFactory = createRuntimeManagerLockFactory();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1NTI3OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545255279", "bodyText": "Same for the lock factory.", "author": "MarianMacik", "createdAt": "2020-12-17T17:09:18Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.Iterator;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class RuntimeManagerLockStrategyFactory {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(RuntimeManagerLockStrategyFactory.class);\n+\n+    public String lockStrategyClassName;\n+    public String lockFactoryClassName;\n+\n+    public RuntimeManagerLockStrategyFactory() {\n+        this(System.getProperty(\"org.kie.jbpm.runtime.manager.lock.strategy\", LegacyRuntimeManagerLockStrategy.class.getName()),\n+             System.getProperty(\"org.kie.jbpm.runtime.manager.lock.factory\", DefaultRuntimeManagerLockFactory.class.getName()));\n+    }\n+\n+    public RuntimeManagerLockStrategyFactory(String strategy, String factory) {\n+        this.lockFactoryClassName = factory;\n+        this.lockStrategyClassName = strategy;\n+    }\n+\n+    public RuntimeManagerLockStrategy createFreeLockStrategy() {\n+        return new FreeRuntimeManagerLockStrategy();\n+    }\n+\n+    public RuntimeManagerLockStrategy createLockStrategy(String identifier) {\n+        RuntimeManagerLockStrategy runtimeManagerLockStrategy = null;\n+\n+        // choose the right locking system\n+        ServiceLoader<RuntimeManagerLockStrategy> loader = ServiceLoader.load(RuntimeManagerLockStrategy.class);\n+        Iterator<RuntimeManagerLockStrategy> iterator = loader.iterator();\n+        while (iterator.hasNext()) {\n+            RuntimeManagerLockStrategy lockStrategy = iterator.next();\n+            if (lockStrategy.getClass().getName().equals(lockStrategyClassName)) {\n+                runtimeManagerLockStrategy = lockStrategy;\n+                break;\n+            }\n+        }\n+\n+\n+        if (runtimeManagerLockStrategy == null) {\n+            runtimeManagerLockStrategy = new LegacyRuntimeManagerLockStrategy();\n+        }\n+\n+        RuntimeManagerLockFactory runtimeManagerLockFactory = createRuntimeManagerLockFactory();\n+        runtimeManagerLockStrategy.init(runtimeManagerLockFactory);\n+        logger.info(\"RuntimeManagerLockStrategy {} with lock factory {} is created for {}\", \n+                    runtimeManagerLockStrategy.getClass().getName(),\n+                    runtimeManagerLockFactory.getClass().getName(), identifier);\n+        return runtimeManagerLockStrategy;\n+    }\n+\n+    private RuntimeManagerLockFactory createRuntimeManagerLockFactory () {\n+        // chose the right factory lock\n+        RuntimeManagerLockFactory runtimeManagerLockFactory = null;\n+\n+        ServiceLoader<RuntimeManagerLockFactory> loader = ServiceLoader.load(RuntimeManagerLockFactory.class);\n+        Iterator<RuntimeManagerLockFactory> iterator = loader.iterator();\n+        while (iterator.hasNext()) {\n+            RuntimeManagerLockFactory currentRuntimeManagerLockFactory = iterator.next();\n+            if (currentRuntimeManagerLockFactory.getClass().getName().equals(lockFactoryClassName)) {\n+                runtimeManagerLockFactory = currentRuntimeManagerLockFactory;\n+                break;\n+            }\n+        }\n+\n+        // fallback to default\n+        if (runtimeManagerLockFactory == null) {\n+            runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        }", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY3NTc4OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545675789", "bodyText": "ok", "author": "elguardian", "createdAt": "2020-12-18T08:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1NTI3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyFactory.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyFactory.java\nindex e5326ef70..7112f9b9e 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyFactory.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyFactory.java\n\n@@ -61,7 +61,7 @@ public final class RuntimeManagerLockStrategyFactory {\n \n \n         if (runtimeManagerLockStrategy == null) {\n-            runtimeManagerLockStrategy = new LegacyRuntimeManagerLockStrategy();\n+            throw new RuntimeException(\"Could not find a proper RuntimeManagerLockStrategy for value \" + lockStrategyClassName);\n         }\n \n         RuntimeManagerLockFactory runtimeManagerLockFactory = createRuntimeManagerLockFactory();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2MTQxMg==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545261412", "bodyText": "Here the action of calling hasQueuedThreads() and removing the lock is not atomic.\nSo it may happen that there are no queued threads, but before the remove is done there is a new thread which calls lock(). So now the lock is removed from the map and is exclusively available to just that one thread. So in case there is yet another thread calling lock() for the same runtime engine, it gets a different lock, a new one, and both threads are now using the same runtime engine in parallel. I think that is what you tried to fix by introducing the synchronized block + the count of threads using, or planning to use the lock (via the RuntimeManagerLockThreadsInfo)? In theory, just a synchronized block was needed with the hasQueuedThreads() method , but it's good to have also the current state of thread ids.", "author": "MarianMacik", "createdAt": "2020-12-17T17:18:13Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/LegacyRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class LegacyRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LegacyRuntimeManagerLockStrategy.class);\n+\n+    protected ConcurrentMap<Long, RuntimeManagerLock> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    \n+    public LegacyRuntimeManagerLockStrategy() {\n+        this.engineLocks = new ConcurrentHashMap<>();\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+    }\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) {\n+        RuntimeManagerLock newLock = runtimeManagerLockFactory.newRuntimeManagerLock();\n+        RuntimeManagerLock lock = engineLocks.putIfAbsent(id, newLock);\n+        if (lock == null) {\n+            lock = newLock;\n+            logger.debug(\"New lock created as it did not exist before\");\n+        } else {\n+            logger.debug(\"Lock exists with {} waiting threads\", lock.internalLock().getQueueLength());\n+        }\n+        logger.debug(\"Trying to get a lock {} for {} by {}\", lock, id, runtime);\n+        lock.lock();\n+        logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lock, id, runtime, lock.internalLock().hasQueuedThreads());\n+\n+    }\n+\n+    @Override\n+    public void unlock(Long id, RuntimeEngine runtime) {\n+        RuntimeManagerLock lock = engineLocks.get(id);\n+        if (lock != null) {\n+            if (!lock.internalLock().hasQueuedThreads()) {\n+                logger.debug(\"Removing lock {} from list as non is waiting for it by {}\", lock, runtime);\n+                engineLocks.remove(id);", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY2NDA1MQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545664051", "bodyText": "Legacy implementation is just taking the old code and putting in here.\nYou are right about the atomicity of those queue threads.\nI had some issues with the thread reaper regarding queue threads. not always the owner of the thread tries to unlock. If that happens i t should not be dequeued. That is the reason you need to avoid the situation holding information about which threads are going to remove it from the set.\n1 thread is operation\n2 thread reaper kicks in and executes a dispose... because detects has queued threads it removes it from the list. (it is not the owner actually). This allows coherence with the next call isHeldByCurrentThread and is consistent with the idea that only threads that lock can unlock and operate the engine locks map.\nThe idea is like only those threads operation locks can unlock.... thread reaper is not one of them.", "author": "elguardian", "createdAt": "2020-12-18T08:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2MTQxMg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMxOTg0OA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545319848", "bodyText": "This will always use the FreeLockStrategy as when the object is created, the child (e.g. PerProcessInstanceRuntimeManager) is not yet initialized, so isUseLocking() will always return false. I guess we can move this into a separate method which can be then called from the init() method?", "author": "MarianMacik", "createdAt": "2020-12-17T18:45:24Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -104,15 +114,22 @@\n     \n     protected SecurityManager securityManager = null;\n     protected ExecutionErrorManager executionErrorManager;\n-        \n-    protected ConcurrentMap<Long, ReentrantLock> engineLocks = new ConcurrentHashMap<Long, ReentrantLock>(); \n+    protected RuntimeManagerLockStrategy runtimeManagerLockStrategy;\n+\n     \n     public AbstractRuntimeManager(RuntimeEnvironment environment, String identifier) {\n         this.environment = environment;\n         this.identifier = identifier;\n         if (registry.isRegistered(identifier)) {\n             throw new IllegalStateException(\"RuntimeManager with id \" + identifier + \" is already active\");\n         }\n+\n+        if (!isUseLocking()) {", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTYzOTEwMA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545639100", "bodyText": "done", "author": "elguardian", "createdAt": "2020-12-18T08:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMxOTg0OA=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\nindex 62d1eab53..5a1f9b039 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n\n@@ -124,12 +116,6 @@ public abstract class AbstractRuntimeManager implements InternalRuntimeManager {\n             throw new IllegalStateException(\"RuntimeManager with id \" + identifier + \" is already active\");\n         }\n \n-        if (!isUseLocking()) {\n-            runtimeManagerLockStrategy = lockStrategyFactory.createFreeLockStrategy();\n-        } else {\n-            runtimeManagerLockStrategy = lockStrategyFactory.createLockStrategy(identifier);\n-        }\n-\n         ((SimpleRuntimeEnvironment)environment).getEnvironmentTemplate().set(EnvironmentName.DEPLOYMENT_ID, this.getIdentifier());\n         internalSetDeploymentDescriptor();\n         internalSetKieContainer();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzOTc0Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545339746", "bodyText": "Can it even happen in the engine that we call lock() more than once in the same thread? By looking at the code when we first get the engine, it is locked and saved to the thread local (saveLocalRuntime method) and then it is reused within the same thread when calling getRuntimeEngine(), so we never reach the line with createLockOnGetEngine(). Just my observation.", "author": "MarianMacik", "createdAt": "2020-12-17T19:16:25Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/DebugRuntimeManagerLock.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+\n+\n+public class DebugRuntimeManagerLock implements RuntimeManagerLock {\n+\n+    private ReentrantLock lock = new ReentrantLock(true);\n+    private List<StackTraceElement[]> traces;\n+    private long currentThreadId;\n+\n+    public DebugRuntimeManagerLock() {\n+        traces = new ArrayList<>();\n+        currentThreadId = -1;\n+    }\n+    \n+    @Override\n+    public void lock() {\n+        lock.lock();\n+        addTraces();\n+    }\n+\n+    @Override\n+    public boolean tryLock(long units, TimeUnit timeUnit) throws InterruptedException {\n+        boolean outcome = lock.tryLock(units, timeUnit);\n+        if(outcome) {\n+            addTraces();\n+        }\n+        return outcome;\n+    }\n+\n+    @Override\n+    public void lockInterruptible() throws InterruptedException {\n+        lock.lockInterruptibly();\n+        addTraces();\n+    }\n+\n+    private void addTraces() {\n+        long newThreadId = Thread.currentThread().getId();\n+        if(currentThreadId < 0 || currentThreadId != newThreadId) {\n+            currentThreadId = newThreadId;\n+            traces.clear();\n+        }\n+        // we add all stack traces during reentrant lock\n+        traces.add(Thread.currentThread().getStackTrace());", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTYzOTgxMw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545639813", "bodyText": "that is correct. Just trying to add the case of missuse of the runtime manager.", "author": "elguardian", "createdAt": "2020-12-18T08:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzOTc0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/DebugRuntimeManagerLock.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/DebugRuntimeManagerLock.java\nindex 38649ce50..7ba4f3026 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/DebugRuntimeManagerLock.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/DebugRuntimeManagerLock.java\n\n@@ -28,11 +28,13 @@ public class DebugRuntimeManagerLock implements RuntimeManagerLock {\n \n     private ReentrantLock lock = new ReentrantLock(true);\n     private List<StackTraceElement[]> traces;\n+    private int count;\n     private long currentThreadId;\n \n     public DebugRuntimeManagerLock() {\n         traces = new ArrayList<>();\n         currentThreadId = -1;\n+        count = 0;\n     }\n     \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzNzg1NA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545337854", "bodyText": "this is not used", "author": "gmunozfe", "createdAt": "2020-12-17T19:13:07Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -15,13 +15,15 @@\n  */\n package org.jbpm.runtime.manager.impl;\n \n+import java.util.Iterator;", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0MTYzOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545641639", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-12-18T08:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzNzg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\nindex 62d1eab53..5a1f9b039 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n\n@@ -15,15 +15,11 @@\n  */\n package org.jbpm.runtime.manager.impl;\n \n-import java.util.Iterator;\n+\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.locks.ReentrantLock;\n \n-import com.sun.tools.javac.util.ServiceLoader;\n import org.drools.core.time.TimerService;\n import org.drools.persistence.api.OrderedTransactionSynchronization;\n import org.drools.persistence.api.TransactionManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzODQxOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545338419", "bodyText": "these 3 imports are not used", "author": "gmunozfe", "createdAt": "2020-12-17T19:14:07Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -15,13 +15,15 @@\n  */\n package org.jbpm.runtime.manager.impl;\n \n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.locks.ReentrantLock;", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0MjkyMw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545642923", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-12-18T08:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzODQxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\nindex 62d1eab53..5a1f9b039 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n\n@@ -15,15 +15,11 @@\n  */\n package org.jbpm.runtime.manager.impl;\n \n-import java.util.Iterator;\n+\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.locks.ReentrantLock;\n \n-import com.sun.tools.javac.util.ServiceLoader;\n import org.drools.core.time.TimerService;\n import org.drools.persistence.api.OrderedTransactionSynchronization;\n import org.drools.persistence.api.TransactionManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzOTQwNg==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545339406", "bodyText": "Use java util instead:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import com.sun.tools.javac.util.ServiceLoader;\n          \n          \n            \n            import java.util.ServiceLoader;", "author": "gmunozfe", "createdAt": "2020-12-17T19:15:48Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -15,13 +15,15 @@\n  */\n package org.jbpm.runtime.manager.impl;\n \n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.locks.ReentrantLock;\n \n+import com.sun.tools.javac.util.ServiceLoader;", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0MTY5OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545641699", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-12-18T08:20:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzOTQwNg=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\nindex 62d1eab53..5a1f9b039 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n\n@@ -15,15 +15,11 @@\n  */\n package org.jbpm.runtime.manager.impl;\n \n-import java.util.Iterator;\n+\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.locks.ReentrantLock;\n \n-import com.sun.tools.javac.util.ServiceLoader;\n import org.drools.core.time.TimerService;\n import org.drools.persistence.api.OrderedTransactionSynchronization;\n import org.drools.persistence.api.TransactionManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MDEyNg==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545340126", "bodyText": "These 3 imports are not used", "author": "gmunozfe", "createdAt": "2020-12-17T19:16:58Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -34,7 +36,13 @@\n import org.jbpm.runtime.manager.api.SchedulerProvider;\n import org.jbpm.runtime.manager.impl.error.DefaultExecutionErrorStorage;\n import org.jbpm.runtime.manager.impl.error.ExecutionErrorManagerImpl;\n+import org.jbpm.runtime.manager.impl.lock.DefaultRuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.impl.lock.FreeRuntimeManagerLockStrategy;\n+import org.jbpm.runtime.manager.impl.lock.LegacyRuntimeManagerLockStrategy;", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0MjgzOA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545642838", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-12-18T08:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MDEyNg=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\nindex 62d1eab53..5a1f9b039 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n\n@@ -36,12 +32,8 @@ import org.jbpm.process.core.timer.impl.GlobalTimerService;\n import org.jbpm.runtime.manager.api.SchedulerProvider;\n import org.jbpm.runtime.manager.impl.error.DefaultExecutionErrorStorage;\n import org.jbpm.runtime.manager.impl.error.ExecutionErrorManagerImpl;\n-import org.jbpm.runtime.manager.impl.lock.DefaultRuntimeManagerLockFactory;\n-import org.jbpm.runtime.manager.impl.lock.FreeRuntimeManagerLockStrategy;\n-import org.jbpm.runtime.manager.impl.lock.LegacyRuntimeManagerLockStrategy;\n import org.jbpm.runtime.manager.impl.lock.RuntimeManagerLockStrategyFactory;\n import org.jbpm.runtime.manager.impl.tx.NoOpTransactionManager;\n-import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n import org.jbpm.services.task.impl.TaskContentRegistry;\n import org.jbpm.services.task.impl.command.CommandBasedTaskService;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MDUwOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545340509", "bodyText": "This is not used", "author": "gmunozfe", "createdAt": "2020-12-17T19:17:35Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -34,7 +36,13 @@\n import org.jbpm.runtime.manager.api.SchedulerProvider;\n import org.jbpm.runtime.manager.impl.error.DefaultExecutionErrorStorage;\n import org.jbpm.runtime.manager.impl.error.ExecutionErrorManagerImpl;\n+import org.jbpm.runtime.manager.impl.lock.DefaultRuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.impl.lock.FreeRuntimeManagerLockStrategy;\n+import org.jbpm.runtime.manager.impl.lock.LegacyRuntimeManagerLockStrategy;\n+import org.jbpm.runtime.manager.impl.lock.RuntimeManagerLockStrategyFactory;\n import org.jbpm.runtime.manager.impl.tx.NoOpTransactionManager;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0MTc4Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545641786", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-12-18T08:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MDUwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\nindex 62d1eab53..5a1f9b039 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n\n@@ -36,12 +32,8 @@ import org.jbpm.process.core.timer.impl.GlobalTimerService;\n import org.jbpm.runtime.manager.api.SchedulerProvider;\n import org.jbpm.runtime.manager.impl.error.DefaultExecutionErrorStorage;\n import org.jbpm.runtime.manager.impl.error.ExecutionErrorManagerImpl;\n-import org.jbpm.runtime.manager.impl.lock.DefaultRuntimeManagerLockFactory;\n-import org.jbpm.runtime.manager.impl.lock.FreeRuntimeManagerLockStrategy;\n-import org.jbpm.runtime.manager.impl.lock.LegacyRuntimeManagerLockStrategy;\n import org.jbpm.runtime.manager.impl.lock.RuntimeManagerLockStrategyFactory;\n import org.jbpm.runtime.manager.impl.tx.NoOpTransactionManager;\n-import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n import org.jbpm.services.task.impl.TaskContentRegistry;\n import org.jbpm.services.task.impl.command.CommandBasedTaskService;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MjE1Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545342153", "bodyText": "Check first if id is null (same as rest of methods)", "author": "gmunozfe", "createdAt": "2020-12-17T19:20:20Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -431,43 +448,31 @@ protected void createLockOnGetEngine(Context<?> context, RuntimeEngine runtime)\n     }\n     \n     protected void createLockOnGetEngine(Long id, RuntimeEngine runtime) {\n-        if (!isUseLocking()) {\n-            logger.debug(\"Locking on runtime manager disabled\");\n+        if (id == null) {\n             return;\n         }\n-        \n-        if (id != null) {\n-            ReentrantLock newLock = new ReentrantLock();\n-            ReentrantLock lock = engineLocks.putIfAbsent(id, newLock);\n-            if (lock == null) {\n-                lock = newLock;\n-                logger.debug(\"New lock created as it did not exist before\");\n-            } else {\n-                logger.debug(\"Lock exists with {} waiting threads\", lock.getQueueLength());\n-            }\n-            logger.debug(\"Trying to get a lock {} for {} by {}\", lock, id, runtime);\n-            lock.lock();\n-            logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lock, id, runtime, lock.hasQueuedThreads());\n-            \n+        try {\n+            runtimeManagerLockStrategy.lock(id, runtime);\n+        } catch(InterruptedException e) {\n+            throw new RuntimeException(\"Runtime manager was not able to lock for {\" + id +\"}\", e);\n         }\n-        \n+    }\n+\n+    protected void releaseAndCleanLock(Long id, RuntimeEngine runtime) {\n+        if (id == null) {\n+            return;\n+        }\n+        runtimeManagerLockStrategy.unlock(id, runtime);\n     }\n     \n     protected void createLockOnNewProcessInstance(Long id, RuntimeEngine runtime) {\n         if (!isUseLocking()) {", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY1MzYxNg==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545653616", "bodyText": "in this case the call is delegated to createLockOnGetEngine... so it is the same thing (it is checked in there.", "author": "elguardian", "createdAt": "2020-12-18T08:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MjE1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\nindex 62d1eab53..5a1f9b039 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java\n\n@@ -466,19 +458,10 @@ public abstract class AbstractRuntimeManager implements InternalRuntimeManager {\n     }\n     \n     protected void createLockOnNewProcessInstance(Long id, RuntimeEngine runtime) {\n-        if (!isUseLocking()) {\n-            logger.debug(\"Locking on runtime manager disabled\");\n-            return;\n-        }\n         createLockOnGetEngine(id, runtime);\n     }\n     \n     protected void releaseAndCleanLock(RuntimeEngine runtime) {\n-        if (!isUseLocking()) {\n-            logger.debug(\"Locking on runtime manager disabled\");\n-            return;\n-        }\n-        \n         if (((RuntimeEngineImpl)runtime).getContext() instanceof ProcessInstanceIdContext) {\n             Long piId = ((ProcessInstanceIdContext) ((RuntimeEngineImpl)runtime).getContext()).getContextId();\n             if (piId != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MzY1MA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545343650", "bodyText": "As it is abstract, it shouldn't be public\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public AbstractRuntimeManagerLockStrategy() {\n          \n          \n            \n                protected AbstractRuntimeManagerLockStrategy() {", "author": "gmunozfe", "createdAt": "2020-12-17T19:22:47Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0MzExOA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545643118", "bodyText": "done", "author": "elguardian", "createdAt": "2020-12-18T08:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MzY1MA=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\nindex 01ff1d72a..3f72fbf7c 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n\n@@ -29,7 +29,7 @@ import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n-public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n \n     protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0NDA5MA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545344090", "bodyText": "consider use \"computeIfAbsent\" instead", "author": "gmunozfe", "createdAt": "2020-12-17T19:23:30Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        this.engineLocks = new HashMap<>();\n+    }\n+\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) throws InterruptedException {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            if(!engineLocks.containsKey(id)) {\n+                engineLocks.put(id, new RuntimeManagerLockThreadsInfo(runtimeManagerLockFactory.newRuntimeManagerLock()));", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY1MDUzMw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545650533", "bodyText": "good catch", "author": "elguardian", "createdAt": "2020-12-18T08:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0NDA5MA=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\nindex 01ff1d72a..3f72fbf7c 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n\n@@ -29,7 +29,7 @@ import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n-public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n \n     protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0NDg4NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545344885", "bodyText": "Check first if id is null to return", "author": "gmunozfe", "createdAt": "2020-12-17T19:24:47Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        this.engineLocks = new HashMap<>();\n+    }\n+\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) throws InterruptedException {", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0MzMwNw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545643307", "bodyText": "no need. it is guaranteed at abstract runtime manager level.", "author": "elguardian", "createdAt": "2020-12-18T08:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0NDg4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\nindex 01ff1d72a..3f72fbf7c 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n\n@@ -29,7 +29,7 @@ import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n-public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n \n     protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0Njg4Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545346883", "bodyText": "Check first if id is null to return", "author": "gmunozfe", "createdAt": "2020-12-17T19:27:58Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        this.engineLocks = new HashMap<>();\n+    }\n+\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) throws InterruptedException {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            if(!engineLocks.containsKey(id)) {\n+                engineLocks.put(id, new RuntimeManagerLockThreadsInfo(runtimeManagerLockFactory.newRuntimeManagerLock()));\n+            }\n+            lockThreadsInfo = engineLocks.get(id);\n+            lockThreadsInfo.set();\n+        }\n+        logger.debug(\"Trying to get a lock {} for {} by {}\", lockThreadsInfo, id, runtime);\n+        try {\n+            lock(lockThreadsInfo.getRuntimeManagerLock());\n+        } catch(InterruptedException e) {\n+            logger.warn(\"Interrupted lock {}\", lockThreadsInfo.getRuntimeManagerLock());\n+            throw e;\n+        }\n+        logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lockThreadsInfo, id, runtime, lockThreadsInfo.hasQueuedThreads());\n+    }\n+\n+    protected abstract void lock(RuntimeManagerLock lock) throws InterruptedException;\n+    \n+    @Override\n+    public void unlock(Long id, RuntimeEngine runtime) {", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0MzU0Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545643543", "bodyText": "id won't be null ... it is guaranteed at runtime manager level", "author": "elguardian", "createdAt": "2020-12-18T08:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0Njg4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\nindex 01ff1d72a..3f72fbf7c 100644\n--- a/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n+++ b/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java\n\n@@ -29,7 +29,7 @@ import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n-public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n \n     protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0OTI4Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545349286", "bodyText": "Check first if id is null to return", "author": "gmunozfe", "createdAt": "2020-12-17T19:31:56Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/LegacyRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class LegacyRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LegacyRuntimeManagerLockStrategy.class);\n+\n+    protected ConcurrentMap<Long, RuntimeManagerLock> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    \n+    public LegacyRuntimeManagerLockStrategy() {\n+        this.engineLocks = new ConcurrentHashMap<>();\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+    }\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) {", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0NjcyMw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545646723", "bodyText": "id cannot me null. it is guaranteed by runtime manager", "author": "elguardian", "createdAt": "2020-12-18T08:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0OTI4Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0OTM2OA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545349368", "bodyText": "Check first if id is null to return", "author": "gmunozfe", "createdAt": "2020-12-17T19:32:03Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/LegacyRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class LegacyRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LegacyRuntimeManagerLockStrategy.class);\n+\n+    protected ConcurrentMap<Long, RuntimeManagerLock> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    \n+    public LegacyRuntimeManagerLockStrategy() {\n+        this.engineLocks = new ConcurrentHashMap<>();\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+    }\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) {\n+        RuntimeManagerLock newLock = runtimeManagerLockFactory.newRuntimeManagerLock();\n+        RuntimeManagerLock lock = engineLocks.putIfAbsent(id, newLock);\n+        if (lock == null) {\n+            lock = newLock;\n+            logger.debug(\"New lock created as it did not exist before\");\n+        } else {\n+            logger.debug(\"Lock exists with {} waiting threads\", lock.internalLock().getQueueLength());\n+        }\n+        logger.debug(\"Trying to get a lock {} for {} by {}\", lock, id, runtime);\n+        lock.lock();\n+        logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lock, id, runtime, lock.internalLock().hasQueuedThreads());\n+\n+    }\n+\n+    @Override\n+    public void unlock(Long id, RuntimeEngine runtime) {", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0NDc1Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545644757", "bodyText": "id cannot be null it is guaranteed at runtime manager level", "author": "elguardian", "createdAt": "2020-12-18T08:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0OTM2OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1MTI1NA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545351254", "bodyText": "Shouldn't it implement \"Serializable\" or is it not necessary?", "author": "gmunozfe", "createdAt": "2020-12-17T19:35:12Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/SerializableRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+\n+\n+public class SerializableRuntimeManagerLockStrategy extends AbstractRuntimeManagerLockStrategy {", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0NDQ0OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545644449", "bodyText": "serializable is in the sense of requests not really about passsivation.", "author": "elguardian", "createdAt": "2020-12-18T08:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1MTI1NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1Mzk1NA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545353954", "bodyText": "timeout could be also added to the test", "author": "gmunozfe", "createdAt": "2020-12-17T19:39:37Z", "path": "jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/CustomRuntimeManagerLockStrategyTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomRuntimeManagerLockStrategyTest {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(CustomRuntimeManagerLockStrategyTest.class);\n+\n+    private static final int NUMBER_OF_WORKING_THREADS = 10;\n+\n+    private ExecutorService executorService;\n+\n+    @Before\n+    public void init() {\n+        executorService = Executors.newFixedThreadPool(NUMBER_OF_WORKING_THREADS);\n+    }\n+\n+    @After\n+    public void destroy() {\n+        executorService.shutdown();\n+        executorService = null;\n+    }\n+\n+    @Test", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0NjQyNQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545646425", "bodyText": "added", "author": "elguardian", "createdAt": "2020-12-18T08:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1Mzk1NA=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/CustomRuntimeManagerLockStrategyTest.java b/jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/CustomRuntimeManagerLockStrategyTest.java\nindex cefb3901c..a8e61d9b3 100644\n--- a/jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/CustomRuntimeManagerLockStrategyTest.java\n+++ b/jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/CustomRuntimeManagerLockStrategyTest.java\n\n@@ -49,7 +49,7 @@ public class CustomRuntimeManagerLockStrategyTest {\n         executorService = null;\n     }\n \n-    @Test\n+    @Test(timeout = 10000)\n     public void testTimeout() throws Exception {\n         final CriticalSectionClash sectionDetection = new CriticalSectionClash();\n         String factory = DebugRuntimeManagerLockFactory.class.getName();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NDAxNA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545354014", "bodyText": "timeout could be also added to the test", "author": "gmunozfe", "createdAt": "2020-12-17T19:39:43Z", "path": "jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/CustomRuntimeManagerLockStrategyTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomRuntimeManagerLockStrategyTest {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(CustomRuntimeManagerLockStrategyTest.class);\n+\n+    private static final int NUMBER_OF_WORKING_THREADS = 10;\n+\n+    private ExecutorService executorService;\n+\n+    @Before\n+    public void init() {\n+        executorService = Executors.newFixedThreadPool(NUMBER_OF_WORKING_THREADS);\n+    }\n+\n+    @After\n+    public void destroy() {\n+        executorService.shutdown();\n+        executorService = null;\n+    }\n+\n+    @Test\n+    public void testTimeout() throws Exception {\n+        final CriticalSectionClash sectionDetection = new CriticalSectionClash();\n+        String factory = DebugRuntimeManagerLockFactory.class.getName();\n+        final RuntimeManagerLockStrategy lockStrategy = new RuntimeManagerLockStrategyFactory(\"org.jbpm.runtime.manager.impl.lock.TimeoutRuntimeManagerLockStrategy\", factory).createLockStrategy(\"timeout\");\n+        AtomicInteger count = new AtomicInteger(0);\n+\n+        executorService.submit(new Runner(count, sectionDetection, lockStrategy, true)).get();\n+        executorService.submit(new Runner(count, sectionDetection, lockStrategy, false));\n+\n+        logger.info(\"finished jobs test TimeoutRuntimeManagerLockStrategy\");\n+        executorService.shutdown();\n+        executorService.awaitTermination(20, TimeUnit.SECONDS);\n+\n+        // assert hangs\n+        Assert.assertTrue(executorService.isTerminated());\n+        logger.info(\"exiting test TimeoutRuntimeManagerLockStrategy\");\n+    }\n+\n+\n+    @Test", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0NjUxMw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545646513", "bodyText": "added", "author": "elguardian", "createdAt": "2020-12-18T08:26:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NDAxNA=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/CustomRuntimeManagerLockStrategyTest.java b/jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/CustomRuntimeManagerLockStrategyTest.java\nindex cefb3901c..a8e61d9b3 100644\n--- a/jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/CustomRuntimeManagerLockStrategyTest.java\n+++ b/jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/CustomRuntimeManagerLockStrategyTest.java\n\n@@ -49,7 +49,7 @@ public class CustomRuntimeManagerLockStrategyTest {\n         executorService = null;\n     }\n \n-    @Test\n+    @Test(timeout = 10000)\n     public void testTimeout() throws Exception {\n         final CriticalSectionClash sectionDetection = new CriticalSectionClash();\n         String factory = DebugRuntimeManagerLockFactory.class.getName();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NDkzMg==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545354932", "bodyText": "more meaningful method name is appreciated, something like testLockStrategy", "author": "gmunozfe", "createdAt": "2020-12-17T19:41:21Z", "path": "jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@RunWith(Parameterized.class)\n+public class RuntimeManagerLockStrategyTest {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(RuntimeManagerLockStrategyTest.class);\n+\n+    private static final int NUMBER_OF_WORKING_THREADS = 10;\n+\n+    @Parameters(name = \"Strategy : {0}\")\n+    public static Collection<Object[]> data() {\n+        return Arrays.asList(new Object[][]{\n+                                            {\"org.jbpm.runtime.manager.impl.lock.SerializableRuntimeManagerLockStrategy\"},\n+                                            {\"org.jbpm.runtime.manager.impl.lock.TimeoutRuntimeManagerLockStrategy\"},\n+                                            {\"org.jbpm.runtime.manager.impl.lock.InterruptibleRuntimeManagerLockStrategy\"},\n+                                            {\"org.jbpm.runtime.manager.impl.lock.LegacyRuntimeManagerLockStrategy\"}\n+        });\n+    }\n+\n+    private String strategy;\n+    private ExecutorService executorService;\n+\n+    public RuntimeManagerLockStrategyTest(String strategy) {\n+        this.strategy = strategy;\n+    }\n+\n+    @Before\n+    public void init() {\n+        executorService = Executors.newFixedThreadPool(NUMBER_OF_WORKING_THREADS);\n+    }\n+\n+    @After\n+    public void destroy() {\n+        executorService.shutdown();\n+        executorService = null;\n+    }\n+\n+    @Test\n+    public void test() throws InterruptedException {", "originalCommit": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY0NTY4Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545645687", "bodyText": "done", "author": "elguardian", "createdAt": "2020-12-18T08:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NDkzMg=="}], "type": "inlineReview", "revised_code": {"commit": "567716305068e6a91c70efdfaf88e6c0bf069043", "chunk": "diff --git a/jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyTest.java b/jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyTest.java\nindex dd583f34f..2f36b47d2 100644\n--- a/jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyTest.java\n+++ b/jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyTest.java\n\n@@ -30,7 +30,6 @@ import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.Parameterized;\n"}}, {"oid": "567716305068e6a91c70efdfaf88e6c0bf069043", "url": "https://github.com/kiegroup/jbpm/commit/567716305068e6a91c70efdfaf88e6c0bf069043", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution", "committedDate": "2020-12-18T08:57:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMTI3Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545731272", "bodyText": "Just a question, why are not we directly using an custom implementation of java.util.concurrent.Lock that delegates into the real lock.", "author": "fjtirado", "createdAt": "2020-12-18T10:10:02Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/spi/RuntimeManagerLock.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*", "originalCommit": "567716305068e6a91c70efdfaf88e6c0bf069043", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczNTA1Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545735057", "bodyText": "Or, just extends Lock and add methods of ReentrantLock that we are using", "author": "fjtirado", "createdAt": "2020-12-18T10:17:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMTI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczODEyOA==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545738128", "bodyText": "because we need a way to ensure that other implementations can do other operations within....example of DebugRuntimeManagerLock which is the one taking data of the owner stacktrace that got the lock", "author": "elguardian", "createdAt": "2020-12-18T10:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMTI3Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczNjgyMw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545736823", "bodyText": "Is that trace right?, last argument is boolean, so is going to pring Lock  taken for  by  for waiting thread by [true|false]", "author": "fjtirado", "createdAt": "2020-12-18T10:20:17Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/LegacyRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class LegacyRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LegacyRuntimeManagerLockStrategy.class);\n+\n+    protected ConcurrentMap<Long, RuntimeManagerLock> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    \n+    public LegacyRuntimeManagerLockStrategy() {\n+        this.engineLocks = new ConcurrentHashMap<>();\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+    }\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) {\n+        RuntimeManagerLock newLock = runtimeManagerLockFactory.newRuntimeManagerLock();\n+        RuntimeManagerLock lock = engineLocks.putIfAbsent(id, newLock);\n+        if (lock == null) {\n+            lock = newLock;\n+            logger.debug(\"New lock created as it did not exist before\");\n+        } else {\n+            logger.debug(\"Lock exists with {} waiting threads\", lock.internalLock().getQueueLength());\n+        }\n+        logger.debug(\"Trying to get a lock {} for {} by {}\", lock, id, runtime);\n+        lock.lock();\n+        logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lock, id, runtime, lock.internalLock().hasQueuedThreads());", "originalCommit": "567716305068e6a91c70efdfaf88e6c0bf069043", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczOTk1OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545739959", "bodyText": "right. needs to be count", "author": "elguardian", "createdAt": "2020-12-18T10:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczNjgyMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczODMzMw==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545738333", "bodyText": "Style, should we throw a more specifc runtime here? For example, IllegalStateException", "author": "fjtirado", "createdAt": "2020-12-18T10:23:08Z", "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -431,49 +440,28 @@ protected void createLockOnGetEngine(Context<?> context, RuntimeEngine runtime)\n     }\n     \n     protected void createLockOnGetEngine(Long id, RuntimeEngine runtime) {\n-        if (!isUseLocking()) {\n-            logger.debug(\"Locking on runtime manager disabled\");\n+        if (id == null) {\n             return;\n         }\n-        \n-        if (id != null) {\n-            ReentrantLock newLock = new ReentrantLock();\n-            ReentrantLock lock = engineLocks.putIfAbsent(id, newLock);\n-            if (lock == null) {\n-                lock = newLock;\n-                logger.debug(\"New lock created as it did not exist before\");\n-            } else {\n-                logger.debug(\"Lock exists with {} waiting threads\", lock.getQueueLength());\n-            }\n-            logger.debug(\"Trying to get a lock {} for {} by {}\", lock, id, runtime);\n-            lock.lock();\n-            logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lock, id, runtime, lock.hasQueuedThreads());\n-            \n+        try {\n+            runtimeManagerLockStrategy.lock(id, runtime);\n+        } catch(InterruptedException e) {\n+            throw new RuntimeException(\"Runtime manager was not able to lock for {\" + id +\"}\", e);", "originalCommit": "567716305068e6a91c70efdfaf88e6c0bf069043", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc0MDkzNQ==", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545740935", "bodyText": "I didn't create any specific actually and it is not really a problem with the state.. should be something like RuntimeManagerLockException but it is quite cumbersome...", "author": "elguardian", "createdAt": "2020-12-18T10:27:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczODMzMw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "5eb0b44cee32fb84ab8bf4e891607d195d443526", "url": "https://github.com/kiegroup/jbpm/commit/5eb0b44cee32fb84ab8bf4e891607d195d443526", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution", "committedDate": "2020-12-18T11:22:01Z", "type": "forcePushed"}, {"oid": "a3bcb20747ce51a528e8894fb4ba343531936b1f", "url": "https://github.com/kiegroup/jbpm/commit/a3bcb20747ce51a528e8894fb4ba343531936b1f", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution", "committedDate": "2021-01-04T07:56:06Z", "type": "forcePushed"}, {"oid": "a02ef1c6d1a18b1f55e63731463ae335e020d769", "url": "https://github.com/kiegroup/jbpm/commit/a02ef1c6d1a18b1f55e63731463ae335e020d769", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution", "committedDate": "2021-01-07T15:36:41Z", "type": "commit"}, {"oid": "a02ef1c6d1a18b1f55e63731463ae335e020d769", "url": "https://github.com/kiegroup/jbpm/commit/a02ef1c6d1a18b1f55e63731463ae335e020d769", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution", "committedDate": "2021-01-07T15:36:41Z", "type": "forcePushed"}]}