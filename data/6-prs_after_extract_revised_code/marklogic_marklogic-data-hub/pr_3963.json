{"pr_number": 3963, "pr_title": "DHFPROD-4956:Migrate flows and mappings to flows and steps", "pr_createdAt": "2020-05-15T22:46:54Z", "pr_url": "https://github.com/marklogic/marklogic-data-hub/pull/3963", "timeline": [{"oid": "224d851480d0bf11d3e0c8d9478bda3d57cb99ae", "url": "https://github.com/marklogic/marklogic-data-hub/commit/224d851480d0bf11d3e0c8d9478bda3d57cb99ae", "message": "DHFPROD-4956:Migrate flows and mappings to flows and steps", "committedDate": "2020-05-17T18:28:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NzEyNg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426277126", "bodyText": "I'm realizing there's a gap in the story now - pinging @bsrikan  about this - what should we do about the pre-5.3 flows and mappings already deployed in ML? I'll open up a new story for that, let's not inflate this story with that question.\nHowever, I do think it's better to make use of installProjectInFolder - that avoids the need to write much code here. And it'll need to be called once we figure out what to do with already-installed files.", "author": "rjrudin", "createdAt": "2020-05-17T16:03:13Z", "path": "marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.marklogic.hub.flow.impl;\n+\n+import com.marklogic.hub.AbstractHubCoreTest;\n+import com.marklogic.hub.HubConfig;\n+import com.marklogic.hub.HubProject;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.skyscreamer.jsonassert.JSONAssert;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+\n+class FlowMigratorTest extends AbstractHubCoreTest {\n+    @BeforeEach\n+    void setUp() {\n+        try {\n+            FileUtils.copyDirectory(getResourceFile(\"flow-migration-test/flows\"), getHubConfig().getFlowsDir().toFile());", "originalCommit": "da04a3b12b1543e7f560133266786818193edb84", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "224d851480d0bf11d3e0c8d9478bda3d57cb99ae", "chunk": "diff --git a/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java b/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java\nindex 8abd8eb6e..d17d6c7c2 100644\n--- a/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java\n+++ b/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java\n\n@@ -43,23 +43,21 @@ class FlowMigratorTest extends AbstractHubCoreTest {\n         Assertions.assertTrue(migratedFlows.resolve(\"flows\").toFile().listFiles().length > 0);\n         Assertions.assertTrue(migratedFlows.resolve(\"mappings\").toFile().listFiles().length > 0);\n \n-        verifyFiles(getResourceFile(\"flow-migration-test/keys/flows\").toPath(), hubProject.getFlowsDir());\n-        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps\").toPath(), hubProject.getProjectDir().resolve(\"steps\"));\n+        verifyFiles(getResourceFile(\"flow-migration-test/keys/flows\"), hubProject.getFlowsDir().toFile());\n+        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps/ingestion\"), hubProject.getProjectDir().resolve(\"steps\").resolve(\"ingestion\").toFile());\n+        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps/mapping\"), hubProject.getProjectDir().resolve(\"steps\").resolve(\"mapping\").toFile());\n     }\n \n-    private void verifyFiles(Path expectedDir, Path actualDir) {\n-        Arrays.stream(expectedDir.toFile().listFiles()).forEach(file ->{\n+    private void verifyFiles(File expectedDir, File actualDir) {\n+        Arrays.stream(expectedDir.listFiles()).forEach(file ->{\n             //Check if file is present in the key directory\n-            if(!file.isDirectory()){\n-                File migratedFile = actualDir.resolve(expectedDir.relativize(file.toPath())).toFile();\n-                Assertions.assertTrue(migratedFile.exists());\n-                try {\n-                    JSONAssert.assertEquals(FileUtils.readFileToString(file),FileUtils.readFileToString(migratedFile), true );\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n+            File migratedFile = new File(actualDir, file.getName());\n+            Assertions.assertTrue(migratedFile.exists());\n+            try {\n+                JSONAssert.assertEquals(FileUtils.readFileToString(file),FileUtils.readFileToString(migratedFile), true );\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n             }\n-\n         });\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NzIyNA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426277224", "bodyText": "No need to do this - in fact, I think deleting the project directory or data from the db is an anti-pattern because if/when the test fails, it's more difficult to figure out what went wrong. That's why it's better to delete stuff when a test starts as opposed to when a test ends.", "author": "rjrudin", "createdAt": "2020-05-17T16:04:29Z", "path": "marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.marklogic.hub.flow.impl;\n+\n+import com.marklogic.hub.AbstractHubCoreTest;\n+import com.marklogic.hub.HubConfig;\n+import com.marklogic.hub.HubProject;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.skyscreamer.jsonassert.JSONAssert;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+\n+class FlowMigratorTest extends AbstractHubCoreTest {\n+    @BeforeEach\n+    void setUp() {\n+        try {\n+            FileUtils.copyDirectory(getResourceFile(\"flow-migration-test/flows\"), getHubConfig().getFlowsDir().toFile());\n+            FileUtils.copyDirectory(getResourceFile(\"flow-migration-test/mappings\"), getHubConfig().getHubMappingsDir().toFile());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @AfterEach\n+    void tearDown() {\n+        deleteProjectDir();", "originalCommit": "da04a3b12b1543e7f560133266786818193edb84", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "224d851480d0bf11d3e0c8d9478bda3d57cb99ae", "chunk": "diff --git a/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java b/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java\nindex 8abd8eb6e..d17d6c7c2 100644\n--- a/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java\n+++ b/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java\n\n@@ -43,23 +43,21 @@ class FlowMigratorTest extends AbstractHubCoreTest {\n         Assertions.assertTrue(migratedFlows.resolve(\"flows\").toFile().listFiles().length > 0);\n         Assertions.assertTrue(migratedFlows.resolve(\"mappings\").toFile().listFiles().length > 0);\n \n-        verifyFiles(getResourceFile(\"flow-migration-test/keys/flows\").toPath(), hubProject.getFlowsDir());\n-        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps\").toPath(), hubProject.getProjectDir().resolve(\"steps\"));\n+        verifyFiles(getResourceFile(\"flow-migration-test/keys/flows\"), hubProject.getFlowsDir().toFile());\n+        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps/ingestion\"), hubProject.getProjectDir().resolve(\"steps\").resolve(\"ingestion\").toFile());\n+        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps/mapping\"), hubProject.getProjectDir().resolve(\"steps\").resolve(\"mapping\").toFile());\n     }\n \n-    private void verifyFiles(Path expectedDir, Path actualDir) {\n-        Arrays.stream(expectedDir.toFile().listFiles()).forEach(file ->{\n+    private void verifyFiles(File expectedDir, File actualDir) {\n+        Arrays.stream(expectedDir.listFiles()).forEach(file ->{\n             //Check if file is present in the key directory\n-            if(!file.isDirectory()){\n-                File migratedFile = actualDir.resolve(expectedDir.relativize(file.toPath())).toFile();\n-                Assertions.assertTrue(migratedFile.exists());\n-                try {\n-                    JSONAssert.assertEquals(FileUtils.readFileToString(file),FileUtils.readFileToString(migratedFile), true );\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n+            File migratedFile = new File(actualDir, file.getName());\n+            Assertions.assertTrue(migratedFile.exists());\n+            try {\n+                JSONAssert.assertEquals(FileUtils.readFileToString(file),FileUtils.readFileToString(migratedFile), true );\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n             }\n-\n         });\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwMzkwNw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426303907", "bodyText": "I ran the test locally (it passed), but I think two changes should be made to the test:\n\nNarrow down the test files to the bare minimum of steps needed to verify that everything is working\nAdd assertions to verify that the step references are correct in every flow, and that each step document was created correctly\n\nFor the first item above - the ingestion_only-flow.flow.json file is testing 7 identical scenarios, because every one of the 7 steps is the same from a QA perspective. So we only need one non-custom ingestion step that has a fileLocations. We also need a non-custom ingestion step that doesn't have inputFileType in it so we can verify that the migrator adds sourceFormat=json.\nAs for the logic of - \"Should this step be migrated?\" - the most effective way to do that is to make \"stepRequiresMigration\" a protected method and that pass different kinds of steps into it, verifying that the result is true or false.\nFor the second item - I think it's best to make an assertion on every stepId in the migrated flow document, and also on every property of every migrated step. We specifically want to verify that everything under \"options\" was migrated to top-level properties; that \"fileLocations\" was handled correctly; and that \"options/mapping\" was not migrated (it currently is being migrated, but should not be).\nI also noticed that a \"namespaces: {}\" was added, even though no namespaces exist in the mappings. If that's something we need to account for, then we need a mapping artifact that has namespaces populated so we can verify that the special handling for it worked.\nNote that we really do not want any issues during this migration process; the last thing we want for new users on 5.3 is to migrate their flows and then run into a problem that requires involving Support and makes them think that 5.3 doesn't work. So we need to be certain to cover every scenario and ensure every line of the migrated flows/steps is correct.", "author": "rjrudin", "createdAt": "2020-05-17T20:54:54Z", "path": "marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.marklogic.hub.flow.impl;\n+\n+import com.marklogic.hub.AbstractHubCoreTest;\n+import com.marklogic.hub.HubConfig;\n+import com.marklogic.hub.HubProject;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.skyscreamer.jsonassert.JSONAssert;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+\n+class FlowMigratorTest extends AbstractHubCoreTest {\n+    @BeforeEach\n+    void setUp() {\n+        try {\n+            FileUtils.copyDirectory(getResourceFile(\"flow-migration-test/flows\"), getHubConfig().getFlowsDir().toFile());\n+            FileUtils.copyDirectory(getResourceFile(\"flow-migration-test/mappings\"), getHubConfig().getHubMappingsDir().toFile());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @AfterEach\n+    void tearDown() {\n+        deleteProjectDir();\n+    }\n+\n+    @Test\n+    void migrateFlows() {\n+        HubConfig hubConfig = getHubConfig();\n+        HubProject hubProject = hubConfig.getHubProject();\n+        FlowMigrator flowMigrator = new FlowMigrator(getHubConfig());\n+        flowMigrator.migrateFlows();\n+        Path migratedFlows = hubProject.getProjectDir().resolve(\"migrated-flows\");\n+\n+        Assertions.assertTrue(migratedFlows.toFile().exists());\n+        Assertions.assertTrue(migratedFlows.resolve(\"flows\").toFile().listFiles().length > 0);\n+        Assertions.assertTrue(migratedFlows.resolve(\"mappings\").toFile().listFiles().length > 0);\n+\n+        verifyFiles(getResourceFile(\"flow-migration-test/keys/flows\"), hubProject.getFlowsDir().toFile());\n+        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps/ingestion\"), hubProject.getProjectDir().resolve(\"steps\").resolve(\"ingestion\").toFile());\n+        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps/mapping\"), hubProject.getProjectDir().resolve(\"steps\").resolve(\"mapping\").toFile());\n+    }\n+\n+    private void verifyFiles(File expectedDir, File actualDir) {", "originalCommit": "224d851480d0bf11d3e0c8d9478bda3d57cb99ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4245e06774cfd086ffaa3100859abf1125940507", "chunk": "diff --git a/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java b/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java\nindex d17d6c7c2..44ef25cf4 100644\n--- a/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java\n+++ b/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java\n\n@@ -1,63 +1,185 @@\n package com.marklogic.hub.flow.impl;\n \n-import com.marklogic.hub.AbstractHubCoreTest;\n-import com.marklogic.hub.HubConfig;\n-import com.marklogic.hub.HubProject;\n-import org.apache.commons.io.FileUtils;\n-import org.junit.jupiter.api.AfterEach;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.marklogic.hub.*;\n+import com.marklogic.hub.flow.Flow;\n+import com.marklogic.hub.impl.FlowManagerImpl;\n+import com.marklogic.hub.impl.MappingManagerImpl;\n+import com.marklogic.hub.mapping.Mapping;\n+import org.junit.Assert;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import org.skyscreamer.jsonassert.JSONAssert;\n \n-import java.io.File;\n import java.io.IOException;\n import java.nio.file.Path;\n-import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n \n class FlowMigratorTest extends AbstractHubCoreTest {\n+\n+    ObjectMapper mapper = new ObjectMapper();\n+\n     @BeforeEach\n     void setUp() {\n-        try {\n-            FileUtils.copyDirectory(getResourceFile(\"flow-migration-test/flows\"), getHubConfig().getFlowsDir().toFile());\n-            FileUtils.copyDirectory(getResourceFile(\"flow-migration-test/mappings\"), getHubConfig().getHubMappingsDir().toFile());\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    @AfterEach\n-    void tearDown() {\n-        deleteProjectDir();\n+        installProjectInFolder(\"flow-migration-test\");\n     }\n \n     @Test\n-    void migrateFlows() {\n+    void migrateFlows() throws IOException {\n+\n         HubConfig hubConfig = getHubConfig();\n         HubProject hubProject = hubConfig.getHubProject();\n-        FlowMigrator flowMigrator = new FlowMigrator(getHubConfig());\n+        MappingManager mappingManager = new MappingManagerImpl(hubConfig);\n+        FlowManager flowManager = new FlowManagerImpl(hubConfig, mappingManager);\n+        Map<String,Flow> flowMap = new HashMap<>();\n+        Map<String, Mapping> mappingMap = new HashMap<>();\n+        flowManager.getLocalFlows().forEach(flow ->flowMap.put(flow.getName(), flow));\n+        mappingManager.getMappings().forEach(mapping -> mappingMap.put(mapping.getName(), mapping));\n+\n+        FlowMigrator flowMigrator = new FlowMigrator(hubConfig);\n+\n+        //custom_only-flow's steps and hence the flow doesn't need migration\n+        Flow custFlow = flowManager.getLocalFlow(\"custom_only-flow\");\n+        Assertions.assertFalse(flowMigrator.flowRequiresMigration(flowManager.getLocalFlow(\"custom_only-flow\")));\n+        Assertions.assertFalse(flowMigrator.stepRequiresMigration(custFlow.getStep(\"1\")));\n+        Assertions.assertFalse(flowMigrator.stepRequiresMigration(custFlow.getStep(\"2\")));\n+\n+\n         flowMigrator.migrateFlows();\n         Path migratedFlows = hubProject.getProjectDir().resolve(\"migrated-flows\");\n \n         Assertions.assertTrue(migratedFlows.toFile().exists());\n+        Assertions.assertFalse(hubProject.getHubMappingsDir().toFile().exists());\n+\n         Assertions.assertTrue(migratedFlows.resolve(\"flows\").toFile().listFiles().length > 0);\n         Assertions.assertTrue(migratedFlows.resolve(\"mappings\").toFile().listFiles().length > 0);\n \n-        verifyFiles(getResourceFile(\"flow-migration-test/keys/flows\"), hubProject.getFlowsDir().toFile());\n-        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps/ingestion\"), hubProject.getProjectDir().resolve(\"steps\").resolve(\"ingestion\").toFile());\n-        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps/mapping\"), hubProject.getProjectDir().resolve(\"steps\").resolve(\"mapping\").toFile());\n+        verifyFlows(hubProject);\n+        verifyIngestionSteps(hubProject, flowMap);\n+        verifyMappingSteps(hubProject, mappingMap, flowMap);\n     }\n \n-    private void verifyFiles(File expectedDir, File actualDir) {\n-        Arrays.stream(expectedDir.listFiles()).forEach(file ->{\n-            //Check if file is present in the key directory\n-            File migratedFile = new File(actualDir, file.getName());\n-            Assertions.assertTrue(migratedFile.exists());\n-            try {\n-                JSONAssert.assertEquals(FileUtils.readFileToString(file),FileUtils.readFileToString(migratedFile), true );\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n+    private void verifyMappingSteps(HubProject hubProject, Map<String, Mapping> mappingMap, Map<String, Flow> flowMap) throws IOException {\n+        Path mappingSteps = hubProject.getProjectDir().resolve(\"steps\").resolve(\"mapping\");\n+        Flow ingMapFlow = flowMap.get(\"ingestion_mapping-flow\");\n+        Flow ingMapMasterFlow = flowMap.get(\"ingestion_mapping_mastering-flow\");\n+\n+        Mapping mapping1 = mappingMap.get(\"OrderMappingJson\");\n+        Mapping mapping2 = mappingMap.get(\"xmlToXml-mapXmlToXml\");\n+\n+        JsonNode mapStep1 = mapper.readTree(mappingSteps.resolve(\"mapping-step-json.step.json\").toFile());\n+        JsonNode mapStep2 = mapper.readTree(mappingSteps.resolve(\"mapXmlToXml.step.json\").toFile());\n+\n+        verifyOptions(mapStep1, mapper.valueToTree(ingMapFlow.getStep(\"2\").getOptions()));\n+        verifyOptions(mapStep2, mapper.valueToTree(ingMapMasterFlow.getStep(\"2\").getOptions()));\n+\n+        Assertions.assertEquals(\"collection\", mapStep1.get(\"selectedSource\").asText());\n+        Assertions.assertEquals(\"collection\", mapStep2.get(\"selectedSource\").asText());\n+\n+        Assertions.assertNull(mapStep1.get(\"mapping\"));\n+        Assertions.assertNull(mapStep2.get(\"mapping\"));\n+\n+        Assertions.assertEquals(\"json\", mapStep1.get(\"targetFormat\").asText());\n+        Assertions.assertEquals(\"xml\", mapStep2.get(\"targetFormat\").asText());\n+\n+        Assertions.assertEquals(mapper.valueToTree(mapping1.getNamespaces()), mapStep1.get(\"namespaces\"));\n+        Assertions.assertEquals(mapper.valueToTree(mapping2.getNamespaces()), mapStep2.get(\"namespaces\"));\n+\n+        Assertions.assertEquals(mapper.valueToTree(mapping1.getProperties()), mapStep1.get(\"properties\"));\n+        Assertions.assertEquals(mapper.valueToTree(mapping2.getProperties()), mapStep2.get(\"properties\"));\n+    }\n+\n+    private void verifyIngestionSteps(HubProject hubProject, Map<String, Flow> flowMap) throws IOException {\n+        Path ingestionSteps = hubProject.getProjectDir().resolve(\"steps\").resolve(\"ingestion\");\n+        boolean duplicateStepName = ingestionSteps.resolve(\"ingestion_mapping-flow-ingest-step-json.step.json\").toFile().exists();\n+\n+        Flow ingMapFlow = flowMap.get(\"ingestion_mapping-flow\");\n+        Flow ingMapMasterFlow = flowMap.get(\"ingestion_mapping_mastering-flow\");\n+\n+        JsonNode ingStep1 = mapper.readTree(ingestionSteps.resolve(\"ingestion_mapping-flow-ingest-step-json.step.json\").toFile());\n+        JsonNode ingStep2 = mapper.readTree(ingestionSteps.resolve(\"ingest-step-json.step.json\").toFile());\n+        JsonNode ingStep3 = mapper.readTree(ingestionSteps.resolve(\"ingest-step-xml.step.json\").toFile());\n+\n+        //Properties change based on which duplicate step is created\n+        if(duplicateStepName){\n+            verifyOptions(ingStep1, mapper.valueToTree(ingMapFlow.getStep(\"1\").getOptions()));\n+            verifyOptions(ingStep2, mapper.valueToTree(ingMapMasterFlow.getStep(\"1\").getOptions()));\n+            Assertions.assertEquals(\"input\", ingStep1.get(\"inputFilePath\").asText());\n+            Assertions.assertEquals(\".*input*.,'/mapping-flow/json/'\", ingStep1.get(\"outputURIReplacement\").asText());\n+            Assertions.assertEquals(\"mastering-input\", ingStep2.get(\"inputFilePath\").asText());\n+            Assertions.assertEquals(\".*input*.,'/mastering-flow/json/'\", ingStep2.get(\"outputURIReplacement\").asText());\n+        }\n+        else{\n+            verifyOptions(ingStep1, mapper.valueToTree(ingMapMasterFlow.getStep(\"1\").getOptions()));\n+            verifyOptions(ingStep2, mapper.valueToTree(ingMapFlow.getStep(\"1\").getOptions()));\n+\n+            Assertions.assertEquals(\"input\", ingStep2.get(\"inputFilePath\").asText());\n+            Assertions.assertEquals(\".*input*.,'/mapping-flow/json/'\", ingStep2.get(\"outputURIReplacement\").asText());\n+            Assertions.assertEquals(\"mastering-input\", ingStep1.get(\"inputFilePath\").asText());\n+            Assertions.assertEquals(\".*input*.,'/mastering-flow/json/'\", ingStep1.get(\"outputURIReplacement\").asText());\n+        }\n+        verifyOptions(ingStep3, mapper.valueToTree(ingMapFlow.getStep(\"3\").getOptions()));\n+\n+        Assertions.assertEquals(\"xml\", ingStep3.get(\"sourceFormat\").asText());\n+        Assertions.assertEquals(\"xml\", ingStep3.get(\"targetFormat\").asText());\n+        Assertions.assertEquals(\"input\", ingStep3.get(\"inputFilePath\").asText());\n+        Assertions.assertEquals(\".*input*.,'/mapping-flow/xml/'\", ingStep3.get(\"outputURIReplacement\").asText());\n+\n+        Assertions.assertEquals(\"json\", ingStep1.get(\"sourceFormat\").asText());\n+        Assertions.assertEquals(\"json\", ingStep1.get(\"targetFormat\").asText());\n+        Assertions.assertEquals(\"json\", ingStep2.get(\"sourceFormat\").asText());\n+        Assertions.assertEquals(\"json\", ingStep2.get(\"targetFormat\").asText());\n+\n+    }\n+\n+    private void verifyOptions(JsonNode step, JsonNode options){\n+        Set fieldNotExpected ;\n+        if(\"mapping\".equalsIgnoreCase(step.get(\"stepDefinitionType\").asText())){\n+            fieldNotExpected = Set.of(\"outputFormat\", \"mapping\");\n+        }\n+        else{\n+            fieldNotExpected = Set.of(\"outputFormat\");\n+        }\n+\n+        options.fields().forEachRemaining(kv -> {\n+            if(!fieldNotExpected.contains(kv.getKey())){\n+                Assertions.assertNotNull(step.get(kv.getKey()));\n+                Assertions.assertEquals(options.get(kv.getKey()),step.get(kv.getKey()));\n             }\n         });\n     }\n+\n+    private void verifyFlows(HubProject hubProject) throws IOException {\n+        JsonNode ingMapFlow = mapper.readTree(hubProject.getFlowsDir().resolve(\"ingestion_mapping-flow.flow.json\").toFile());\n+        JsonNode ingMapMasterFlow = mapper.readTree(hubProject.getFlowsDir().resolve(\"ingestion_mapping_mastering-flow.flow.json\").toFile());\n+        JsonNode custFlow = mapper.readTree(hubProject.getFlowsDir().resolve(\"custom_only-flow.flow.json\").toFile());\n+        boolean duplicateStepName = hubProject.getProjectDir().resolve(\"steps\").resolve(\"ingestion\").resolve(\"ingestion_mapping-flow-ingest-step-json.step.json\").toFile().exists();\n+        if(duplicateStepName){\n+            Assert.assertEquals(\"ingestion_mapping-flow-ingest-step-json-ingestion\", getStepId(ingMapFlow,\"1\"));\n+            Assert.assertEquals(\"ingest-step-json-ingestion\", getStepId(ingMapMasterFlow,\"1\"));\n+        }\n+        else {\n+            Assert.assertEquals(\"ingestion_mapping_mastering-flow-ingest-step-json-ingestion\", getStepId(ingMapMasterFlow,\"1\"));\n+            Assert.assertEquals(\"ingest-step-json-ingestion\", getStepId(ingMapFlow,\"1\"));\n+        }\n+\n+        Assert.assertEquals(\"mapping-step-json-mapping\", getStepId(ingMapFlow,\"2\"));\n+        Assert.assertEquals(\"ingest-step-xml-ingestion\", getStepId(ingMapFlow,\"3\"));\n+        Assert.assertNull( getStepId(ingMapFlow,\"4\"));\n+\n+        Assert.assertEquals(\"mapXmlToXml-mapping\", getStepId(ingMapMasterFlow,\"2\"));\n+        Assert.assertNull( getStepId(ingMapMasterFlow,\"3\"));\n+        Assert.assertNull( getStepId(ingMapMasterFlow,\"4\"));\n+\n+        Assert.assertNull( getStepId(custFlow,\"1\"));\n+        Assert.assertNull( getStepId(custFlow,\"2\"));\n+    }\n+\n+    private String getStepId(JsonNode flowNode, String step){\n+        return flowNode.get(\"steps\").get(step).get(\"stepId\") != null ? flowNode.get(\"steps\").get(step).get(\"stepId\").asText() : null;\n+    }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwNDA0Mw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426304043", "bodyText": "I realized the story isn't clear here - the mapping artifacts should be moved, not copied. That is assuming that we don't need them anymore, which I think is true. I'll double check on 5.0.x \"default\" mappings.", "author": "rjrudin", "createdAt": "2020-05-17T20:56:01Z", "path": "marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.marklogic.hub.flow.impl;\n+\n+import com.marklogic.hub.AbstractHubCoreTest;\n+import com.marklogic.hub.HubConfig;\n+import com.marklogic.hub.HubProject;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.skyscreamer.jsonassert.JSONAssert;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+\n+class FlowMigratorTest extends AbstractHubCoreTest {\n+    @BeforeEach\n+    void setUp() {\n+        try {\n+            FileUtils.copyDirectory(getResourceFile(\"flow-migration-test/flows\"), getHubConfig().getFlowsDir().toFile());\n+            FileUtils.copyDirectory(getResourceFile(\"flow-migration-test/mappings\"), getHubConfig().getHubMappingsDir().toFile());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @AfterEach\n+    void tearDown() {\n+        deleteProjectDir();\n+    }\n+\n+    @Test\n+    void migrateFlows() {\n+        HubConfig hubConfig = getHubConfig();\n+        HubProject hubProject = hubConfig.getHubProject();\n+        FlowMigrator flowMigrator = new FlowMigrator(getHubConfig());\n+        flowMigrator.migrateFlows();\n+        Path migratedFlows = hubProject.getProjectDir().resolve(\"migrated-flows\");\n+\n+        Assertions.assertTrue(migratedFlows.toFile().exists());\n+        Assertions.assertTrue(migratedFlows.resolve(\"flows\").toFile().listFiles().length > 0);\n+        Assertions.assertTrue(migratedFlows.resolve(\"mappings\").toFile().listFiles().length > 0);\n+\n+        verifyFiles(getResourceFile(\"flow-migration-test/keys/flows\"), hubProject.getFlowsDir().toFile());\n+        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps/ingestion\"), hubProject.getProjectDir().resolve(\"steps\").resolve(\"ingestion\").toFile());\n+        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps/mapping\"), hubProject.getProjectDir().resolve(\"steps\").resolve(\"mapping\").toFile());", "originalCommit": "224d851480d0bf11d3e0c8d9478bda3d57cb99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4NjM2OQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426686369", "bodyText": "Since there will be no default-mapping steps and all mappings are migrated, ./mappings dir is removed.", "author": "srinathgit", "createdAt": "2020-05-18T14:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwNDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc1MjQ3MA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426752470", "bodyText": "@srinathgit when I tested this PR, ./mappings dir was not removed.", "author": "bsrikan", "createdAt": "2020-05-18T16:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwNDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc1OTg5OA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426759898", "bodyText": "It is removed in the latest commit", "author": "srinathgit", "createdAt": "2020-05-18T16:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwNDA0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4245e06774cfd086ffaa3100859abf1125940507", "chunk": "diff --git a/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java b/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java\nindex d17d6c7c2..44ef25cf4 100644\n--- a/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java\n+++ b/marklogic-data-hub/src/test/java/com/marklogic/hub/flow/impl/FlowMigratorTest.java\n\n@@ -1,63 +1,185 @@\n package com.marklogic.hub.flow.impl;\n \n-import com.marklogic.hub.AbstractHubCoreTest;\n-import com.marklogic.hub.HubConfig;\n-import com.marklogic.hub.HubProject;\n-import org.apache.commons.io.FileUtils;\n-import org.junit.jupiter.api.AfterEach;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.marklogic.hub.*;\n+import com.marklogic.hub.flow.Flow;\n+import com.marklogic.hub.impl.FlowManagerImpl;\n+import com.marklogic.hub.impl.MappingManagerImpl;\n+import com.marklogic.hub.mapping.Mapping;\n+import org.junit.Assert;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import org.skyscreamer.jsonassert.JSONAssert;\n \n-import java.io.File;\n import java.io.IOException;\n import java.nio.file.Path;\n-import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n \n class FlowMigratorTest extends AbstractHubCoreTest {\n+\n+    ObjectMapper mapper = new ObjectMapper();\n+\n     @BeforeEach\n     void setUp() {\n-        try {\n-            FileUtils.copyDirectory(getResourceFile(\"flow-migration-test/flows\"), getHubConfig().getFlowsDir().toFile());\n-            FileUtils.copyDirectory(getResourceFile(\"flow-migration-test/mappings\"), getHubConfig().getHubMappingsDir().toFile());\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    @AfterEach\n-    void tearDown() {\n-        deleteProjectDir();\n+        installProjectInFolder(\"flow-migration-test\");\n     }\n \n     @Test\n-    void migrateFlows() {\n+    void migrateFlows() throws IOException {\n+\n         HubConfig hubConfig = getHubConfig();\n         HubProject hubProject = hubConfig.getHubProject();\n-        FlowMigrator flowMigrator = new FlowMigrator(getHubConfig());\n+        MappingManager mappingManager = new MappingManagerImpl(hubConfig);\n+        FlowManager flowManager = new FlowManagerImpl(hubConfig, mappingManager);\n+        Map<String,Flow> flowMap = new HashMap<>();\n+        Map<String, Mapping> mappingMap = new HashMap<>();\n+        flowManager.getLocalFlows().forEach(flow ->flowMap.put(flow.getName(), flow));\n+        mappingManager.getMappings().forEach(mapping -> mappingMap.put(mapping.getName(), mapping));\n+\n+        FlowMigrator flowMigrator = new FlowMigrator(hubConfig);\n+\n+        //custom_only-flow's steps and hence the flow doesn't need migration\n+        Flow custFlow = flowManager.getLocalFlow(\"custom_only-flow\");\n+        Assertions.assertFalse(flowMigrator.flowRequiresMigration(flowManager.getLocalFlow(\"custom_only-flow\")));\n+        Assertions.assertFalse(flowMigrator.stepRequiresMigration(custFlow.getStep(\"1\")));\n+        Assertions.assertFalse(flowMigrator.stepRequiresMigration(custFlow.getStep(\"2\")));\n+\n+\n         flowMigrator.migrateFlows();\n         Path migratedFlows = hubProject.getProjectDir().resolve(\"migrated-flows\");\n \n         Assertions.assertTrue(migratedFlows.toFile().exists());\n+        Assertions.assertFalse(hubProject.getHubMappingsDir().toFile().exists());\n+\n         Assertions.assertTrue(migratedFlows.resolve(\"flows\").toFile().listFiles().length > 0);\n         Assertions.assertTrue(migratedFlows.resolve(\"mappings\").toFile().listFiles().length > 0);\n \n-        verifyFiles(getResourceFile(\"flow-migration-test/keys/flows\"), hubProject.getFlowsDir().toFile());\n-        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps/ingestion\"), hubProject.getProjectDir().resolve(\"steps\").resolve(\"ingestion\").toFile());\n-        verifyFiles(getResourceFile(\"flow-migration-test/keys/steps/mapping\"), hubProject.getProjectDir().resolve(\"steps\").resolve(\"mapping\").toFile());\n+        verifyFlows(hubProject);\n+        verifyIngestionSteps(hubProject, flowMap);\n+        verifyMappingSteps(hubProject, mappingMap, flowMap);\n     }\n \n-    private void verifyFiles(File expectedDir, File actualDir) {\n-        Arrays.stream(expectedDir.listFiles()).forEach(file ->{\n-            //Check if file is present in the key directory\n-            File migratedFile = new File(actualDir, file.getName());\n-            Assertions.assertTrue(migratedFile.exists());\n-            try {\n-                JSONAssert.assertEquals(FileUtils.readFileToString(file),FileUtils.readFileToString(migratedFile), true );\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n+    private void verifyMappingSteps(HubProject hubProject, Map<String, Mapping> mappingMap, Map<String, Flow> flowMap) throws IOException {\n+        Path mappingSteps = hubProject.getProjectDir().resolve(\"steps\").resolve(\"mapping\");\n+        Flow ingMapFlow = flowMap.get(\"ingestion_mapping-flow\");\n+        Flow ingMapMasterFlow = flowMap.get(\"ingestion_mapping_mastering-flow\");\n+\n+        Mapping mapping1 = mappingMap.get(\"OrderMappingJson\");\n+        Mapping mapping2 = mappingMap.get(\"xmlToXml-mapXmlToXml\");\n+\n+        JsonNode mapStep1 = mapper.readTree(mappingSteps.resolve(\"mapping-step-json.step.json\").toFile());\n+        JsonNode mapStep2 = mapper.readTree(mappingSteps.resolve(\"mapXmlToXml.step.json\").toFile());\n+\n+        verifyOptions(mapStep1, mapper.valueToTree(ingMapFlow.getStep(\"2\").getOptions()));\n+        verifyOptions(mapStep2, mapper.valueToTree(ingMapMasterFlow.getStep(\"2\").getOptions()));\n+\n+        Assertions.assertEquals(\"collection\", mapStep1.get(\"selectedSource\").asText());\n+        Assertions.assertEquals(\"collection\", mapStep2.get(\"selectedSource\").asText());\n+\n+        Assertions.assertNull(mapStep1.get(\"mapping\"));\n+        Assertions.assertNull(mapStep2.get(\"mapping\"));\n+\n+        Assertions.assertEquals(\"json\", mapStep1.get(\"targetFormat\").asText());\n+        Assertions.assertEquals(\"xml\", mapStep2.get(\"targetFormat\").asText());\n+\n+        Assertions.assertEquals(mapper.valueToTree(mapping1.getNamespaces()), mapStep1.get(\"namespaces\"));\n+        Assertions.assertEquals(mapper.valueToTree(mapping2.getNamespaces()), mapStep2.get(\"namespaces\"));\n+\n+        Assertions.assertEquals(mapper.valueToTree(mapping1.getProperties()), mapStep1.get(\"properties\"));\n+        Assertions.assertEquals(mapper.valueToTree(mapping2.getProperties()), mapStep2.get(\"properties\"));\n+    }\n+\n+    private void verifyIngestionSteps(HubProject hubProject, Map<String, Flow> flowMap) throws IOException {\n+        Path ingestionSteps = hubProject.getProjectDir().resolve(\"steps\").resolve(\"ingestion\");\n+        boolean duplicateStepName = ingestionSteps.resolve(\"ingestion_mapping-flow-ingest-step-json.step.json\").toFile().exists();\n+\n+        Flow ingMapFlow = flowMap.get(\"ingestion_mapping-flow\");\n+        Flow ingMapMasterFlow = flowMap.get(\"ingestion_mapping_mastering-flow\");\n+\n+        JsonNode ingStep1 = mapper.readTree(ingestionSteps.resolve(\"ingestion_mapping-flow-ingest-step-json.step.json\").toFile());\n+        JsonNode ingStep2 = mapper.readTree(ingestionSteps.resolve(\"ingest-step-json.step.json\").toFile());\n+        JsonNode ingStep3 = mapper.readTree(ingestionSteps.resolve(\"ingest-step-xml.step.json\").toFile());\n+\n+        //Properties change based on which duplicate step is created\n+        if(duplicateStepName){\n+            verifyOptions(ingStep1, mapper.valueToTree(ingMapFlow.getStep(\"1\").getOptions()));\n+            verifyOptions(ingStep2, mapper.valueToTree(ingMapMasterFlow.getStep(\"1\").getOptions()));\n+            Assertions.assertEquals(\"input\", ingStep1.get(\"inputFilePath\").asText());\n+            Assertions.assertEquals(\".*input*.,'/mapping-flow/json/'\", ingStep1.get(\"outputURIReplacement\").asText());\n+            Assertions.assertEquals(\"mastering-input\", ingStep2.get(\"inputFilePath\").asText());\n+            Assertions.assertEquals(\".*input*.,'/mastering-flow/json/'\", ingStep2.get(\"outputURIReplacement\").asText());\n+        }\n+        else{\n+            verifyOptions(ingStep1, mapper.valueToTree(ingMapMasterFlow.getStep(\"1\").getOptions()));\n+            verifyOptions(ingStep2, mapper.valueToTree(ingMapFlow.getStep(\"1\").getOptions()));\n+\n+            Assertions.assertEquals(\"input\", ingStep2.get(\"inputFilePath\").asText());\n+            Assertions.assertEquals(\".*input*.,'/mapping-flow/json/'\", ingStep2.get(\"outputURIReplacement\").asText());\n+            Assertions.assertEquals(\"mastering-input\", ingStep1.get(\"inputFilePath\").asText());\n+            Assertions.assertEquals(\".*input*.,'/mastering-flow/json/'\", ingStep1.get(\"outputURIReplacement\").asText());\n+        }\n+        verifyOptions(ingStep3, mapper.valueToTree(ingMapFlow.getStep(\"3\").getOptions()));\n+\n+        Assertions.assertEquals(\"xml\", ingStep3.get(\"sourceFormat\").asText());\n+        Assertions.assertEquals(\"xml\", ingStep3.get(\"targetFormat\").asText());\n+        Assertions.assertEquals(\"input\", ingStep3.get(\"inputFilePath\").asText());\n+        Assertions.assertEquals(\".*input*.,'/mapping-flow/xml/'\", ingStep3.get(\"outputURIReplacement\").asText());\n+\n+        Assertions.assertEquals(\"json\", ingStep1.get(\"sourceFormat\").asText());\n+        Assertions.assertEquals(\"json\", ingStep1.get(\"targetFormat\").asText());\n+        Assertions.assertEquals(\"json\", ingStep2.get(\"sourceFormat\").asText());\n+        Assertions.assertEquals(\"json\", ingStep2.get(\"targetFormat\").asText());\n+\n+    }\n+\n+    private void verifyOptions(JsonNode step, JsonNode options){\n+        Set fieldNotExpected ;\n+        if(\"mapping\".equalsIgnoreCase(step.get(\"stepDefinitionType\").asText())){\n+            fieldNotExpected = Set.of(\"outputFormat\", \"mapping\");\n+        }\n+        else{\n+            fieldNotExpected = Set.of(\"outputFormat\");\n+        }\n+\n+        options.fields().forEachRemaining(kv -> {\n+            if(!fieldNotExpected.contains(kv.getKey())){\n+                Assertions.assertNotNull(step.get(kv.getKey()));\n+                Assertions.assertEquals(options.get(kv.getKey()),step.get(kv.getKey()));\n             }\n         });\n     }\n+\n+    private void verifyFlows(HubProject hubProject) throws IOException {\n+        JsonNode ingMapFlow = mapper.readTree(hubProject.getFlowsDir().resolve(\"ingestion_mapping-flow.flow.json\").toFile());\n+        JsonNode ingMapMasterFlow = mapper.readTree(hubProject.getFlowsDir().resolve(\"ingestion_mapping_mastering-flow.flow.json\").toFile());\n+        JsonNode custFlow = mapper.readTree(hubProject.getFlowsDir().resolve(\"custom_only-flow.flow.json\").toFile());\n+        boolean duplicateStepName = hubProject.getProjectDir().resolve(\"steps\").resolve(\"ingestion\").resolve(\"ingestion_mapping-flow-ingest-step-json.step.json\").toFile().exists();\n+        if(duplicateStepName){\n+            Assert.assertEquals(\"ingestion_mapping-flow-ingest-step-json-ingestion\", getStepId(ingMapFlow,\"1\"));\n+            Assert.assertEquals(\"ingest-step-json-ingestion\", getStepId(ingMapMasterFlow,\"1\"));\n+        }\n+        else {\n+            Assert.assertEquals(\"ingestion_mapping_mastering-flow-ingest-step-json-ingestion\", getStepId(ingMapMasterFlow,\"1\"));\n+            Assert.assertEquals(\"ingest-step-json-ingestion\", getStepId(ingMapFlow,\"1\"));\n+        }\n+\n+        Assert.assertEquals(\"mapping-step-json-mapping\", getStepId(ingMapFlow,\"2\"));\n+        Assert.assertEquals(\"ingest-step-xml-ingestion\", getStepId(ingMapFlow,\"3\"));\n+        Assert.assertNull( getStepId(ingMapFlow,\"4\"));\n+\n+        Assert.assertEquals(\"mapXmlToXml-mapping\", getStepId(ingMapMasterFlow,\"2\"));\n+        Assert.assertNull( getStepId(ingMapMasterFlow,\"3\"));\n+        Assert.assertNull( getStepId(ingMapMasterFlow,\"4\"));\n+\n+        Assert.assertNull( getStepId(custFlow,\"1\"));\n+        Assert.assertNull( getStepId(custFlow,\"2\"));\n+    }\n+\n+    private String getStepId(JsonNode flowNode, String step){\n+        return flowNode.get(\"steps\").get(step).get(\"stepId\") != null ? flowNode.get(\"steps\").get(step).get(\"stepId\").asText() : null;\n+    }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxOTk2Mw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426419963", "bodyText": "Need a space before directory.", "author": "bsrikan", "createdAt": "2020-05-18T07:29:29Z", "path": "marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright (c) 2020 MarkLogic Corporation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.marklogic.hub.flow.impl;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.marklogic.hub.FlowManager;\n+import com.marklogic.hub.HubConfig;\n+import com.marklogic.hub.HubProject;\n+import com.marklogic.hub.MappingManager;\n+import com.marklogic.hub.error.DataHubProjectException;\n+import com.marklogic.hub.flow.Flow;\n+import com.marklogic.hub.impl.FlowManagerImpl;\n+import com.marklogic.hub.impl.MappingManagerImpl;\n+import com.marklogic.hub.mapping.Mapping;\n+import com.marklogic.hub.step.StepDefinition;\n+import com.marklogic.hub.step.impl.Step;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Map;\n+\n+\n+/**\n+ * Class for migrating pre-5.3.0 flows to  5.3.0 and above versions\n+ */\n+\n+public class FlowMigrator {\n+\n+    private HubProject hubProject;\n+    private MappingManager mappingManager;\n+    private FlowManager flowManager;\n+    protected final Logger logger = LoggerFactory.getLogger(this.getClass());\n+    ObjectMapper mapper = new ObjectMapper();\n+\n+    public FlowMigrator(HubConfig hubConfig){\n+        hubProject = hubConfig.getHubProject();\n+        mappingManager = new MappingManagerImpl(hubConfig);\n+        flowManager = new FlowManagerImpl(hubConfig, mappingManager);\n+    }\n+\n+    public void migrateFlows(){\n+        //Backup flows and mappings\n+        Path migratedFlows = hubProject.getProjectDir().resolve(\"migrated-flows\");\n+        try {\n+            migratedFlows.toFile().mkdirs();\n+            FileUtils.copyDirectory(hubProject.getFlowsDir().toFile(), migratedFlows.resolve(\"flows\").toFile());\n+            FileUtils.copyDirectory(hubProject.getHubMappingsDir().toFile(), migratedFlows.resolve(\"mappings\").toFile());\n+            logger.info(\"The original flows and mappings are backed up in migrated-flows/flows and migrated-flows/mappings\"+\n+                \"directory respectively.\");", "originalCommit": "224d851480d0bf11d3e0c8d9478bda3d57cb99ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4245e06774cfd086ffaa3100859abf1125940507", "chunk": "diff --git a/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java b/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java\nindex 58a5365d1..1feea74b4 100644\n--- a/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java\n+++ b/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java\n\n@@ -41,6 +41,7 @@ import java.io.IOException;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.util.Map;\n+import java.util.Set;\n \n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMzQxMw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426433413", "bodyText": "After migration, not able to run the flow. Used the flows in e2e/qa-project to migrate and run. Get an error like so.:\nUnable to retrieve flow with name: PersonXMLFlow for all the flows.", "author": "bsrikan", "createdAt": "2020-05-18T07:54:38Z", "path": "marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright (c) 2020 MarkLogic Corporation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.marklogic.hub.flow.impl;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.marklogic.hub.FlowManager;\n+import com.marklogic.hub.HubConfig;\n+import com.marklogic.hub.HubProject;\n+import com.marklogic.hub.MappingManager;\n+import com.marklogic.hub.error.DataHubProjectException;\n+import com.marklogic.hub.flow.Flow;\n+import com.marklogic.hub.impl.FlowManagerImpl;\n+import com.marklogic.hub.impl.MappingManagerImpl;\n+import com.marklogic.hub.mapping.Mapping;\n+import com.marklogic.hub.step.StepDefinition;\n+import com.marklogic.hub.step.impl.Step;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Map;\n+\n+\n+/**\n+ * Class for migrating pre-5.3.0 flows to  5.3.0 and above versions\n+ */\n+\n+public class FlowMigrator {\n+\n+    private HubProject hubProject;\n+    private MappingManager mappingManager;\n+    private FlowManager flowManager;\n+    protected final Logger logger = LoggerFactory.getLogger(this.getClass());\n+    ObjectMapper mapper = new ObjectMapper();\n+\n+    public FlowMigrator(HubConfig hubConfig){\n+        hubProject = hubConfig.getHubProject();\n+        mappingManager = new MappingManagerImpl(hubConfig);\n+        flowManager = new FlowManagerImpl(hubConfig, mappingManager);\n+    }\n+\n+    public void migrateFlows(){\n+        //Backup flows and mappings\n+        Path migratedFlows = hubProject.getProjectDir().resolve(\"migrated-flows\");\n+        try {\n+            migratedFlows.toFile().mkdirs();\n+            FileUtils.copyDirectory(hubProject.getFlowsDir().toFile(), migratedFlows.resolve(\"flows\").toFile());\n+            FileUtils.copyDirectory(hubProject.getHubMappingsDir().toFile(), migratedFlows.resolve(\"mappings\").toFile());\n+            logger.info(\"The original flows and mappings are backed up in migrated-flows/flows and migrated-flows/mappings\"+\n+                \"directory respectively.\");\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Couldn't migrate flows as backing up flows failed : \" + e.getMessage());\n+        }\n+\n+        Path stepsDir = hubProject.getProjectDir().resolve(\"steps\");\n+        Path ingestionDir = stepsDir.resolve(StepDefinition.StepDefinitionType.INGESTION.toString());\n+        Path mappingDir = stepsDir.resolve(StepDefinition.StepDefinitionType.MAPPING.toString());\n+\n+        try {\n+            ingestionDir.toFile().mkdirs();\n+            mappingDir.toFile().mkdirs();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Couldn't migrate flows as creation of step artifact directories  failed : \" + e.getMessage());\n+        }\n+\n+        ObjectWriter writer = mapper.writerWithDefaultPrettyPrinter();\n+        JsonNodeFactory nodeFactory = mapper.getNodeFactory();\n+\n+        flowManager.getLocalFlows().forEach(flow ->{\n+            Map<String, Step> steps = flow.getSteps();\n+            boolean flowRequiresMigration = steps.values().stream().anyMatch(step -> stepRequiresMigration(step));\n+            logger.info(flowRequiresMigration ? \"Migrating flow \" + flow.getName() :\n+                \"Flow \" + flow.getName() + \" contains no ingestion or mapping step. It doesn't require migration\");\n+            if(flowRequiresMigration){\n+                ObjectNode newFlow = nodeFactory.objectNode();\n+                newFlow.put(\"name\", flow.getName());\n+                ObjectNode newSteps = nodeFactory.objectNode();;\n+                for (Map.Entry<String, Step> entry : steps.entrySet()) {\n+                    Step step = entry.getValue();\n+                    if(stepRequiresMigration(step)){\n+                        newSteps.set(entry.getKey(),\n+                            nodeFactory.objectNode().put(\"stepId\",String.join(\"-\", step.getName(), step.getStepDefinitionType().toString())));\n+                        ObjectNode newStepArtifact = createStepArtifact(flow, step);\n+                        Path targetDir = step.getStepDefinitionType().equals(StepDefinition.StepDefinitionType.INGESTION) ? ingestionDir : mappingDir;\n+                        String stepFileName = new StringBuilder(step.getName()).append(\".step.json\").toString();\n+                        File stepFile = targetDir.resolve(stepFileName).toFile();\n+                        logger.info(\"Creating step artifact \"+ stepFile.toString());\n+                        if (stepFile.exists()) {\n+                            String msg = \"Step artifact \" + stepFile.toString() + \" already exists. The step artifact will be written to \";\n+                            //Update step artifact with new name\n+                            String stepName = new StringBuilder(flow.getName()).append(\"-\").append(step.getName()).toString();\n+                            newStepArtifact.put(\"name\", stepName);\n+                            //Update the filename\n+                            stepFileName = new StringBuilder(flow.getName()).append(\"-\").append(stepFileName).toString();\n+                            stepFile = targetDir.resolve(stepFileName).toFile();\n+\n+                            logger.info(msg + stepFile.toString()) ;\n+                        }\n+                        try{\n+                            writer.writeValue(stepFile, newStepArtifact);\n+                            logger.info(\"Step artifact \" + stepFile.toString() + \" successfully created.\");\n+                        }\n+                        catch(IOException e){\n+                            logger.error(\"Step artifact \" + stepFile.toString() + \" creation failed: \" + e.getMessage());\n+                        }\n+                    }\n+                    else {\n+                        logger.info(\"Step \" + step.getName() + \" is not an out of the box ingestion or mapping step. It will remain inline inside the flow artifact\");\n+                        newSteps.set(entry.getKey(), mapper.valueToTree(step));\n+                    }\n+                }\n+                newFlow.set(\"steps\",newSteps);\n+                File flowFile = Paths.get(hubProject.getFlowsDir().toString(), flow.getName() + FlowManager.FLOW_FILE_EXTENSION).toFile();\n+                try{\n+                    writer.writeValue(flowFile, newFlow);\n+                    logger.info(\"Flow \" + flowFile.toString() + \" successfully migrated.\");", "originalCommit": "224d851480d0bf11d3e0c8d9478bda3d57cb99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1MDMzNw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426450337", "bodyText": "The flows should be run after DHFPROD-4951 and DHFPROD-4952 are merged into develop though implementation of DHFPROD-4956 doesn't have dependency on them", "author": "srinathgit", "createdAt": "2020-05-18T08:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMzQxMw=="}], "type": "inlineReview", "revised_code": {"commit": "4245e06774cfd086ffaa3100859abf1125940507", "chunk": "diff --git a/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java b/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java\nindex 58a5365d1..1feea74b4 100644\n--- a/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java\n+++ b/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java\n\n@@ -41,6 +41,7 @@ import java.io.IOException;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.util.Map;\n+import java.util.Set;\n \n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNzAyMw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426437023", "bodyText": "ingestion step seems to be show up as \"Unknown\" in the the flow, since its expecting a loadData config", "author": "bsrikan", "createdAt": "2020-05-18T08:00:57Z", "path": "marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright (c) 2020 MarkLogic Corporation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.marklogic.hub.flow.impl;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.marklogic.hub.FlowManager;\n+import com.marklogic.hub.HubConfig;\n+import com.marklogic.hub.HubProject;\n+import com.marklogic.hub.MappingManager;\n+import com.marklogic.hub.error.DataHubProjectException;\n+import com.marklogic.hub.flow.Flow;\n+import com.marklogic.hub.impl.FlowManagerImpl;\n+import com.marklogic.hub.impl.MappingManagerImpl;\n+import com.marklogic.hub.mapping.Mapping;\n+import com.marklogic.hub.step.StepDefinition;\n+import com.marklogic.hub.step.impl.Step;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Map;\n+\n+\n+/**\n+ * Class for migrating pre-5.3.0 flows to  5.3.0 and above versions\n+ */\n+\n+public class FlowMigrator {\n+\n+    private HubProject hubProject;\n+    private MappingManager mappingManager;\n+    private FlowManager flowManager;\n+    protected final Logger logger = LoggerFactory.getLogger(this.getClass());\n+    ObjectMapper mapper = new ObjectMapper();\n+\n+    public FlowMigrator(HubConfig hubConfig){\n+        hubProject = hubConfig.getHubProject();\n+        mappingManager = new MappingManagerImpl(hubConfig);\n+        flowManager = new FlowManagerImpl(hubConfig, mappingManager);\n+    }\n+\n+    public void migrateFlows(){\n+        //Backup flows and mappings\n+        Path migratedFlows = hubProject.getProjectDir().resolve(\"migrated-flows\");\n+        try {\n+            migratedFlows.toFile().mkdirs();\n+            FileUtils.copyDirectory(hubProject.getFlowsDir().toFile(), migratedFlows.resolve(\"flows\").toFile());\n+            FileUtils.copyDirectory(hubProject.getHubMappingsDir().toFile(), migratedFlows.resolve(\"mappings\").toFile());\n+            logger.info(\"The original flows and mappings are backed up in migrated-flows/flows and migrated-flows/mappings\"+\n+                \"directory respectively.\");\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Couldn't migrate flows as backing up flows failed : \" + e.getMessage());\n+        }\n+\n+        Path stepsDir = hubProject.getProjectDir().resolve(\"steps\");\n+        Path ingestionDir = stepsDir.resolve(StepDefinition.StepDefinitionType.INGESTION.toString());\n+        Path mappingDir = stepsDir.resolve(StepDefinition.StepDefinitionType.MAPPING.toString());\n+\n+        try {\n+            ingestionDir.toFile().mkdirs();\n+            mappingDir.toFile().mkdirs();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Couldn't migrate flows as creation of step artifact directories  failed : \" + e.getMessage());\n+        }\n+\n+        ObjectWriter writer = mapper.writerWithDefaultPrettyPrinter();\n+        JsonNodeFactory nodeFactory = mapper.getNodeFactory();\n+\n+        flowManager.getLocalFlows().forEach(flow ->{\n+            Map<String, Step> steps = flow.getSteps();\n+            boolean flowRequiresMigration = steps.values().stream().anyMatch(step -> stepRequiresMigration(step));\n+            logger.info(flowRequiresMigration ? \"Migrating flow \" + flow.getName() :\n+                \"Flow \" + flow.getName() + \" contains no ingestion or mapping step. It doesn't require migration\");\n+            if(flowRequiresMigration){\n+                ObjectNode newFlow = nodeFactory.objectNode();\n+                newFlow.put(\"name\", flow.getName());\n+                ObjectNode newSteps = nodeFactory.objectNode();;\n+                for (Map.Entry<String, Step> entry : steps.entrySet()) {\n+                    Step step = entry.getValue();\n+                    if(stepRequiresMigration(step)){\n+                        newSteps.set(entry.getKey(),\n+                            nodeFactory.objectNode().put(\"stepId\",String.join(\"-\", step.getName(), step.getStepDefinitionType().toString())));\n+                        ObjectNode newStepArtifact = createStepArtifact(flow, step);\n+                        Path targetDir = step.getStepDefinitionType().equals(StepDefinition.StepDefinitionType.INGESTION) ? ingestionDir : mappingDir;\n+                        String stepFileName = new StringBuilder(step.getName()).append(\".step.json\").toString();\n+                        File stepFile = targetDir.resolve(stepFileName).toFile();\n+                        logger.info(\"Creating step artifact \"+ stepFile.toString());\n+                        if (stepFile.exists()) {\n+                            String msg = \"Step artifact \" + stepFile.toString() + \" already exists. The step artifact will be written to \";\n+                            //Update step artifact with new name\n+                            String stepName = new StringBuilder(flow.getName()).append(\"-\").append(step.getName()).toString();\n+                            newStepArtifact.put(\"name\", stepName);\n+                            //Update the filename\n+                            stepFileName = new StringBuilder(flow.getName()).append(\"-\").append(stepFileName).toString();\n+                            stepFile = targetDir.resolve(stepFileName).toFile();\n+\n+                            logger.info(msg + stepFile.toString()) ;\n+                        }\n+                        try{\n+                            writer.writeValue(stepFile, newStepArtifact);\n+                            logger.info(\"Step artifact \" + stepFile.toString() + \" successfully created.\");\n+                        }\n+                        catch(IOException e){\n+                            logger.error(\"Step artifact \" + stepFile.toString() + \" creation failed: \" + e.getMessage());\n+                        }\n+                    }\n+                    else {\n+                        logger.info(\"Step \" + step.getName() + \" is not an out of the box ingestion or mapping step. It will remain inline inside the flow artifact\");\n+                        newSteps.set(entry.getKey(), mapper.valueToTree(step));\n+                    }\n+                }\n+                newFlow.set(\"steps\",newSteps);\n+                File flowFile = Paths.get(hubProject.getFlowsDir().toString(), flow.getName() + FlowManager.FLOW_FILE_EXTENSION).toFile();\n+                try{\n+                    writer.writeValue(flowFile, newFlow);\n+                    logger.info(\"Flow \" + flowFile.toString() + \" successfully migrated.\");\n+                }\n+                catch(IOException e){\n+                    logger.error(\"Flow artifact \" + flowFile.toString() + \" creation failed: \" + e.getMessage());\n+                }\n+            }\n+        });\n+    }\n+\n+    // Only create step artifacts for ootb ingestion and mapping steps. Other steps(including custom ingestion and mapping)\n+    // will be inline\n+    private boolean stepRequiresMigration(Step step) {\n+        return (StepDefinition.StepDefinitionType.MAPPING.equals(step.getStepDefinitionType()) && \"entity-services-mapping\".equalsIgnoreCase(step.getStepDefinitionName())) ||\n+            (StepDefinition.StepDefinitionType.INGESTION.equals(step.getStepDefinitionType()) &&  \"default-ingestion\".equalsIgnoreCase(step.getStepDefinitionName()));", "originalCommit": "224d851480d0bf11d3e0c8d9478bda3d57cb99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1MDczOA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426450738", "bodyText": "This has to be verified after DHFPROD-4951 and DHFPROD-4952 are merged", "author": "srinathgit", "createdAt": "2020-05-18T08:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNzAyMw=="}], "type": "inlineReview", "revised_code": {"commit": "4245e06774cfd086ffaa3100859abf1125940507", "chunk": "diff --git a/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java b/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java\nindex 58a5365d1..1feea74b4 100644\n--- a/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java\n+++ b/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java\n\n@@ -41,6 +41,7 @@ import java.io.IOException;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.util.Map;\n+import java.util.Set;\n \n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0MTE0Mw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426441143", "bodyText": "endpoint http://localhost:8080/api/artifacts/mapping seems to return all the versions of a mapping. Shouldnt it return only the latest version. UI ends up showing all the versions which is not desired.", "author": "bsrikan", "createdAt": "2020-05-18T08:08:08Z", "path": "marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright (c) 2020 MarkLogic Corporation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.marklogic.hub.flow.impl;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.marklogic.hub.FlowManager;\n+import com.marklogic.hub.HubConfig;\n+import com.marklogic.hub.HubProject;\n+import com.marklogic.hub.MappingManager;\n+import com.marklogic.hub.error.DataHubProjectException;\n+import com.marklogic.hub.flow.Flow;\n+import com.marklogic.hub.impl.FlowManagerImpl;\n+import com.marklogic.hub.impl.MappingManagerImpl;\n+import com.marklogic.hub.mapping.Mapping;\n+import com.marklogic.hub.step.StepDefinition;\n+import com.marklogic.hub.step.impl.Step;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Map;\n+\n+\n+/**\n+ * Class for migrating pre-5.3.0 flows to  5.3.0 and above versions\n+ */\n+\n+public class FlowMigrator {\n+\n+    private HubProject hubProject;\n+    private MappingManager mappingManager;\n+    private FlowManager flowManager;\n+    protected final Logger logger = LoggerFactory.getLogger(this.getClass());\n+    ObjectMapper mapper = new ObjectMapper();\n+\n+    public FlowMigrator(HubConfig hubConfig){\n+        hubProject = hubConfig.getHubProject();\n+        mappingManager = new MappingManagerImpl(hubConfig);\n+        flowManager = new FlowManagerImpl(hubConfig, mappingManager);\n+    }\n+\n+    public void migrateFlows(){\n+        //Backup flows and mappings\n+        Path migratedFlows = hubProject.getProjectDir().resolve(\"migrated-flows\");\n+        try {\n+            migratedFlows.toFile().mkdirs();\n+            FileUtils.copyDirectory(hubProject.getFlowsDir().toFile(), migratedFlows.resolve(\"flows\").toFile());\n+            FileUtils.copyDirectory(hubProject.getHubMappingsDir().toFile(), migratedFlows.resolve(\"mappings\").toFile());\n+            logger.info(\"The original flows and mappings are backed up in migrated-flows/flows and migrated-flows/mappings\"+\n+                \"directory respectively.\");\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Couldn't migrate flows as backing up flows failed : \" + e.getMessage());\n+        }\n+\n+        Path stepsDir = hubProject.getProjectDir().resolve(\"steps\");\n+        Path ingestionDir = stepsDir.resolve(StepDefinition.StepDefinitionType.INGESTION.toString());\n+        Path mappingDir = stepsDir.resolve(StepDefinition.StepDefinitionType.MAPPING.toString());\n+\n+        try {\n+            ingestionDir.toFile().mkdirs();\n+            mappingDir.toFile().mkdirs();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Couldn't migrate flows as creation of step artifact directories  failed : \" + e.getMessage());\n+        }\n+\n+        ObjectWriter writer = mapper.writerWithDefaultPrettyPrinter();\n+        JsonNodeFactory nodeFactory = mapper.getNodeFactory();\n+\n+        flowManager.getLocalFlows().forEach(flow ->{\n+            Map<String, Step> steps = flow.getSteps();\n+            boolean flowRequiresMigration = steps.values().stream().anyMatch(step -> stepRequiresMigration(step));\n+            logger.info(flowRequiresMigration ? \"Migrating flow \" + flow.getName() :\n+                \"Flow \" + flow.getName() + \" contains no ingestion or mapping step. It doesn't require migration\");\n+            if(flowRequiresMigration){\n+                ObjectNode newFlow = nodeFactory.objectNode();\n+                newFlow.put(\"name\", flow.getName());\n+                ObjectNode newSteps = nodeFactory.objectNode();;\n+                for (Map.Entry<String, Step> entry : steps.entrySet()) {\n+                    Step step = entry.getValue();\n+                    if(stepRequiresMigration(step)){\n+                        newSteps.set(entry.getKey(),\n+                            nodeFactory.objectNode().put(\"stepId\",String.join(\"-\", step.getName(), step.getStepDefinitionType().toString())));\n+                        ObjectNode newStepArtifact = createStepArtifact(flow, step);\n+                        Path targetDir = step.getStepDefinitionType().equals(StepDefinition.StepDefinitionType.INGESTION) ? ingestionDir : mappingDir;\n+                        String stepFileName = new StringBuilder(step.getName()).append(\".step.json\").toString();\n+                        File stepFile = targetDir.resolve(stepFileName).toFile();\n+                        logger.info(\"Creating step artifact \"+ stepFile.toString());\n+                        if (stepFile.exists()) {\n+                            String msg = \"Step artifact \" + stepFile.toString() + \" already exists. The step artifact will be written to \";\n+                            //Update step artifact with new name\n+                            String stepName = new StringBuilder(flow.getName()).append(\"-\").append(step.getName()).toString();\n+                            newStepArtifact.put(\"name\", stepName);\n+                            //Update the filename\n+                            stepFileName = new StringBuilder(flow.getName()).append(\"-\").append(stepFileName).toString();\n+                            stepFile = targetDir.resolve(stepFileName).toFile();\n+\n+                            logger.info(msg + stepFile.toString()) ;\n+                        }\n+                        try{\n+                            writer.writeValue(stepFile, newStepArtifact);\n+                            logger.info(\"Step artifact \" + stepFile.toString() + \" successfully created.\");\n+                        }\n+                        catch(IOException e){\n+                            logger.error(\"Step artifact \" + stepFile.toString() + \" creation failed: \" + e.getMessage());\n+                        }\n+                    }\n+                    else {\n+                        logger.info(\"Step \" + step.getName() + \" is not an out of the box ingestion or mapping step. It will remain inline inside the flow artifact\");\n+                        newSteps.set(entry.getKey(), mapper.valueToTree(step));\n+                    }\n+                }\n+                newFlow.set(\"steps\",newSteps);\n+                File flowFile = Paths.get(hubProject.getFlowsDir().toString(), flow.getName() + FlowManager.FLOW_FILE_EXTENSION).toFile();\n+                try{\n+                    writer.writeValue(flowFile, newFlow);\n+                    logger.info(\"Flow \" + flowFile.toString() + \" successfully migrated.\");\n+                }\n+                catch(IOException e){\n+                    logger.error(\"Flow artifact \" + flowFile.toString() + \" creation failed: \" + e.getMessage());\n+                }\n+            }\n+        });\n+    }\n+\n+    // Only create step artifacts for ootb ingestion and mapping steps. Other steps(including custom ingestion and mapping)\n+    // will be inline\n+    private boolean stepRequiresMigration(Step step) {\n+        return (StepDefinition.StepDefinitionType.MAPPING.equals(step.getStepDefinitionType()) && \"entity-services-mapping\".equalsIgnoreCase(step.getStepDefinitionName())) ||", "originalCommit": "224d851480d0bf11d3e0c8d9478bda3d57cb99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0ODg5Nw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3963#discussion_r426448897", "bodyText": "It will only copy the mapping version that is specified in the flow. Also, \"mapping\" object will be removed from the mapping step in my next commit", "author": "srinathgit", "createdAt": "2020-05-18T08:21:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0MTE0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4245e06774cfd086ffaa3100859abf1125940507", "chunk": "diff --git a/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java b/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java\nindex 58a5365d1..1feea74b4 100644\n--- a/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java\n+++ b/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowMigrator.java\n\n@@ -41,6 +41,7 @@ import java.io.IOException;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.util.Map;\n+import java.util.Set;\n \n \n /**\n"}}, {"oid": "4245e06774cfd086ffaa3100859abf1125940507", "url": "https://github.com/marklogic/marklogic-data-hub/commit/4245e06774cfd086ffaa3100859abf1125940507", "message": "DHFPROD-4956:Migrate flows and mappings to flows and steps", "committedDate": "2020-05-18T10:39:24Z", "type": "commit"}, {"oid": "4245e06774cfd086ffaa3100859abf1125940507", "url": "https://github.com/marklogic/marklogic-data-hub/commit/4245e06774cfd086ffaa3100859abf1125940507", "message": "DHFPROD-4956:Migrate flows and mappings to flows and steps", "committedDate": "2020-05-18T10:39:24Z", "type": "forcePushed"}]}