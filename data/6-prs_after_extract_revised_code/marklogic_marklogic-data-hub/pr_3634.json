{"pr_number": 3634, "pr_title": "DHFPROD-4544: Make FlowRunner compatible with session based HubConfig", "pr_createdAt": "2020-03-02T21:57:49Z", "pr_url": "https://github.com/marklogic/marklogic-data-hub/pull/3634", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY3OTM5Mg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r386679392", "bodyText": "It does not relate to PR. But the condition does not seem correct.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if(!(threadPool != null && threadPool.isTerminating())) {\n          \n          \n            \n                                if (threadPool != null && !threadPool.isTerminating()) {", "author": "hao1st", "createdAt": "2020-03-02T22:06:00Z", "path": "marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowRunnerImpl.java", "diffHunk": "@@ -545,7 +551,7 @@ public void afterExecute(Runnable r, Throwable t) {\n                 //Run the next step\n                 else {\n                     if(!(threadPool != null && threadPool.isTerminating())) {", "originalCommit": "fb2cc361fc3fa65223d29002e307e58273373c29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAwNTEwNw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r387005107", "bodyText": "I think that's correct, because it avoids a null-pointer issue if the threadPool is null, since the next line tries to do something with the threadPool.", "author": "rjrudin", "createdAt": "2020-03-03T13:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY3OTM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA2ODY2MA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r387068660", "bodyText": "@rjrudin if threadpool is null, then the current condition is definitly true. It will produce NullPointerExeption! It is an old bug! If the threadpool is not null and it is not terminating, we want to continue execute next task. Old condition works because threadpool has very few chance to be null.", "author": "hao1st", "createdAt": "2020-03-03T14:47:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY3OTM5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "69be94623f3d3940057fbb4759ad1dc179e77057", "chunk": "diff --git a/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowRunnerImpl.java b/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowRunnerImpl.java\nindex 3cdd4ea8e..b4f401e88 100644\n--- a/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowRunnerImpl.java\n+++ b/marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowRunnerImpl.java\n\n@@ -550,7 +568,7 @@ public class FlowRunnerImpl implements FlowRunner{\n                 }\n                 //Run the next step\n                 else {\n-                    if(!(threadPool != null && threadPool.isTerminating())) {\n+                    if (threadPool != null && !threadPool.isTerminating()) {\n                         threadPool.execute(new FlowRunnerTask(stepRunnerFactory, runningFlow, runningJobId,((FlowRunnerTask)r).getStepQueue()));\n                     }\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4MzE4Mw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r386683183", "bodyText": "still @Autowired?", "author": "hao1st", "createdAt": "2020-03-02T22:13:58Z", "path": "marklogic-data-hub/src/main/java/com/marklogic/hub/impl/ScaffoldingImpl.java", "diffHunk": "@@ -43,7 +43,7 @@\n \n @Component\n public class ScaffoldingImpl implements Scaffolding {\n-    \n+\n     @Autowired", "originalCommit": "fb2cc361fc3fa65223d29002e307e58273373c29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY5NTM4Mw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r386695383", "bodyText": "I'd haven't verified that isn't autowired by other Data Hub code. It isn't autowired through any of the OneUI code paths.", "author": "ryanjdew", "createdAt": "2020-03-02T22:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4MzE4Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODA5Nw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r386708097", "bodyText": "My gut feeling is the StepRunnerFactory can be implemented as a singleton object.   StepRunnerFactory does not need to keep those states' reference when getStepRunner gets called. MarkLogicStepDefinitionProvider can be implemented as a singleton object. I am not sure why we have to pass stepRunnerFactory to the Runnable?", "author": "hao1st", "createdAt": "2020-03-02T23:13:07Z", "path": "marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowRunnerImpl.java", "diffHunk": "@@ -112,8 +113,9 @@ public FlowRunnerImpl(String host, String username, String password) {\n      */\n     public FlowRunnerImpl(HubConfig hubConfig) {\n         this.hubConfig = hubConfig;\n-        this.stepRunnerFactory = new StepRunnerFactory(this.hubConfig);\n-        this.stepRunnerFactory.setStepDefinitionProvider(new MarkLogicStepDefinitionProvider(this.hubConfig.newStagingClient(null)));\n+        this.flowManager = new FlowManagerImpl(hubConfig);\n+        this.stepRunnerFactory = new StepRunnerFactory(hubConfig);", "originalCommit": "fb2cc361fc3fa65223d29002e307e58273373c29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAwMzcwNA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r387003704", "bodyText": "The StepDefinitionProvider can't easily be a singleton because we have multiple implementations of it. As for FlowRunnerTask depending on StepRunnerFactory - it's likely that whole design can change, as I don't know that a FlowRunnerImpl is ever really used to run multiple flows at once. But I don't think it's worth changing anything about that right now.", "author": "rjrudin", "createdAt": "2020-03-03T13:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA3NjEwOA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r387076108", "bodyText": "@rjudin I do not think I need to do now. But I think I can refractor for sure. I even think that we should be able to run multiple flows concurrently with a better threadpool (i/o operations) management in backend.", "author": "hao1st", "createdAt": "2020-03-03T14:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA4MzI2Nw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r387083267", "bodyText": "Currently we don't have any requirement for running multiple flows though the same FlowRunnerImpl instance, so let's not tackle this until such a requirement comes up. When it does, I'd rather see a FlowRunnerImpl with far less state in it, such that we can spin up a new instance easily to run a new flow.", "author": "rjrudin", "createdAt": "2020-03-03T15:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA4NzA3Nw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r387087077", "bodyText": "yes, I thought that maybe we did not have use cases to do that in the past. But I do not know the reason.", "author": "hao1st", "createdAt": "2020-03-03T15:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODA5Nw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "cc54bd88b9b14c52cd89c0e3fe71cd370186a16d", "url": "https://github.com/marklogic/marklogic-data-hub/commit/cc54bd88b9b14c52cd89c0e3fe71cd370186a16d", "message": "DHFPROD-4544: Make FlowRunner compatible with session based HubConfig", "committedDate": "2020-03-03T00:58:43Z", "type": "commit"}, {"oid": "cc54bd88b9b14c52cd89c0e3fe71cd370186a16d", "url": "https://github.com/marklogic/marklogic-data-hub/commit/cc54bd88b9b14c52cd89c0e3fe71cd370186a16d", "message": "DHFPROD-4544: Make FlowRunner compatible with session based HubConfig", "committedDate": "2020-03-03T00:58:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAwNTYwMg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r387005602", "bodyText": "If we're not autowiring this anymore, I think the Component annotation should be removed.", "author": "rjrudin", "createdAt": "2020-03-03T13:06:03Z", "path": "marklogic-data-hub/src/main/java/com/marklogic/hub/impl/MappingManagerImpl.java", "diffHunk": "@@ -47,18 +46,20 @@\n @Component", "originalCommit": "cc54bd88b9b14c52cd89c0e3fe71cd370186a16d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e1e5db6183ea386d31eda0c15ee814a95aec276b", "chunk": "diff --git a/marklogic-data-hub/src/main/java/com/marklogic/hub/impl/MappingManagerImpl.java b/marklogic-data-hub/src/main/java/com/marklogic/hub/impl/MappingManagerImpl.java\nindex 92076b60a..31952905d 100644\n--- a/marklogic-data-hub/src/main/java/com/marklogic/hub/impl/MappingManagerImpl.java\n+++ b/marklogic-data-hub/src/main/java/com/marklogic/hub/impl/MappingManagerImpl.java\n\n@@ -46,8 +46,9 @@ import java.util.List;\n @Component\n public class MappingManagerImpl extends LoggingObject implements MappingManager {\n \n+    @Autowired\n     protected HubConfig hubConfig;\n-    protected HubProject hubProject;\n+    @Autowired\n     private Scaffolding scaffolding;\n     private EntityManager entityManager;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAwNjk4OA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r387006988", "bodyText": "You can get rid of this line of code now that StepRunnerFactory is doing this part itself in its constructor.", "author": "rjrudin", "createdAt": "2020-03-03T13:08:52Z", "path": "marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowRunnerImpl.java", "diffHunk": "@@ -118,8 +119,9 @@ public FlowRunnerImpl(String host, String username, String password) {\n      */\n     public FlowRunnerImpl(HubConfig hubConfig) {\n         this.hubConfig = hubConfig;\n-        this.stepRunnerFactory = new StepRunnerFactory(this.hubConfig);\n-        this.stepRunnerFactory.setStepDefinitionProvider(new MarkLogicStepDefinitionProvider(this.hubConfig.newStagingClient(null)));\n+        this.flowManager = new FlowManagerImpl(hubConfig);\n+        this.stepRunnerFactory = new StepRunnerFactory(hubConfig);\n+        this.stepRunnerFactory.setStepDefinitionProvider(new MarkLogicStepDefinitionProvider(hubConfig.newStagingClient(null)));", "originalCommit": "cc54bd88b9b14c52cd89c0e3fe71cd370186a16d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAwODY3OQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r387008679", "bodyText": "I think this introduces a race condition between two threads hitting this controller. Both threads could hit line 167 at the same time, and then lastFlowManagerService would be equal to whichever thread finished 167 last, and both threads would use the same one.\nIs \"lastFlowManagerService\" only needed for unit testing purposes? If so, the way to get a reference to it is to subclass FlowController in your test and override this method to do the same thing - i.e. hang onto a reference of the FlowManagerService that is constructed.", "author": "rjrudin", "createdAt": "2020-03-03T13:12:16Z", "path": "one-ui/src/main/java/com/marklogic/hub/curation/controllers/FlowController.java", "diffHunk": "@@ -163,4 +163,13 @@ protected ArtifactService getArtifactService() {\n         return ArtifactService.on(dataServicesClient);\n     }\n \n+    private FlowManagerService getFlowManagerService() {\n+        lastFlowManagerService = new FlowManagerService(this.hubConfig.getHubConfigImpl());", "originalCommit": "cc54bd88b9b14c52cd89c0e3fe71cd370186a16d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8bce169b83628d80d509db3bd4bbe4df38035d3", "chunk": "diff --git a/one-ui/src/main/java/com/marklogic/hub/curation/controllers/FlowController.java b/one-ui/src/main/java/com/marklogic/hub/curation/controllers/FlowController.java\nindex 80fce5a2a..eefe26b60 100644\n--- a/one-ui/src/main/java/com/marklogic/hub/curation/controllers/FlowController.java\n+++ b/one-ui/src/main/java/com/marklogic/hub/curation/controllers/FlowController.java\n\n@@ -140,22 +198,39 @@ public class FlowController {\n     public ResponseEntity<?> removeLinkToArtifact(@PathVariable String flowName, @PathVariable String stepId, @PathVariable String artifactType, @PathVariable String artifactName, @PathVariable String artifactVersion) {\n         JsonNode newFlow = getArtifactService().removeLinkToStepOptions(flowName, stepId, artifactType, artifactName, artifactVersion);\n         // only updating local, since the artifact service updated the flow in MarkLogic\n-        getFlowManagerService().updateFlow(newFlow.toString(), true);\n+        updateFlow(newFlow.toString(), true);\n         return new ResponseEntity<>(newFlow, HttpStatus.OK);\n     }\n \n     @RequestMapping(value = \"/{flowName}/run\", method = RequestMethod.POST)\n     @ResponseBody\n-    public ResponseEntity<?> runFlow(@PathVariable String flowName, @RequestBody(required = false) List<String> steps) {\n-        RunFlowResponse flow = getFlowManagerService().runFlow(flowName, steps);\n-        return new ResponseEntity<>(flow, HttpStatus.OK);\n+    public RunFlowResponse runFlow(@PathVariable String flowName, @RequestBody(required = false) List<String> steps) {\n+        FlowManager flowManager = getFlowManager();\n+        FlowRunnerImpl flowRunner = getFlowRunner();\n+        if (steps == null || steps.size() == 0) {\n+            return flowRunner.runFlow(flowName);\n+        }\n+        else {\n+            Flow flow = flowManager.getFlow(flowName);\n+            List<String> restrictedSteps = new ArrayList<>();\n+            steps.forEach((step) -> restrictedSteps.add(this.getStepKeyInStepMap(flow, step)));\n+            return flowRunner.runFlow(flowName, restrictedSteps);\n+        }\n     }\n \n     @RequestMapping(value = \"/{flowName}/stop\", method = RequestMethod.POST)\n     @ResponseBody\n     public ResponseEntity<?> stopFlow(@PathVariable String flowName) {\n-        Flow flow = getFlowManagerService().stop(flowName);\n-        return new ResponseEntity<>(flow, HttpStatus.OK);\n+        FlowRunnerImpl flowRunner = getFlowRunner();\n+        List<String> jobIds = flowRunner.getQueuedJobIdsFromFlow(flowName);\n+        Iterator<String> itr = jobIds.iterator();\n+        if (!itr.hasNext()) {\n+            throw new BadRequestException(\"Flow not running.\");\n+        }\n+        while (itr.hasNext()) {\n+            flowRunner.stopJob(itr.next());\n+        }\n+        return getFlow(flowName);\n     }\n \n     protected ArtifactService getArtifactService() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAxMDYwOQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3634#discussion_r387010609", "bodyText": "FlowManagerService isn't accomplishing anything in terms of reuse - FlowController is its only client (just like in QS). Its name doesn't fit with our naming conventions either. How about just shoving all of it into FlowController, and then you can just do the trick I mentioned above for getting a reference to lastFlowRunner?", "author": "rjrudin", "createdAt": "2020-03-03T13:16:05Z", "path": "one-ui/src/main/java/com/marklogic/hub/curation/services/FlowManagerService.java", "diffHunk": "@@ -365,4 +370,13 @@ public Flow stop(String flowName) {\n         return getFlow(flowName);\n     }\n \n+    protected FlowRunnerImpl getFlowRunner() {\n+        lastFlowRunner = new FlowRunnerImpl(this.hubConfig);\n+        return lastFlowRunner;\n+    }\n+\n+    // TODO public so the FlowControllerTest can see it\n+    public FlowRunnerImpl getLastFlowRunner() {", "originalCommit": "cc54bd88b9b14c52cd89c0e3fe71cd370186a16d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8bce169b83628d80d509db3bd4bbe4df38035d3", "chunk": "diff --git a/one-ui/src/main/java/com/marklogic/hub/curation/services/FlowManagerService.java b/one-ui/src/main/java/com/marklogic/hub/curation/services/FlowManagerService.java\ndeleted file mode 100644\nindex 117515179..000000000\n--- a/one-ui/src/main/java/com/marklogic/hub/curation/services/FlowManagerService.java\n+++ /dev/null\n\n@@ -1,382 +0,0 @@\n-package com.marklogic.hub.curation.services;\n-\n-import com.fasterxml.jackson.databind.JsonNode;\n-import com.marklogic.hub.FlowManager;\n-import com.marklogic.hub.HubConfig;\n-import com.marklogic.hub.StepDefinitionManager;\n-import com.marklogic.hub.error.DataHubProjectException;\n-import com.marklogic.hub.flow.Flow;\n-import com.marklogic.hub.flow.RunFlowResponse;\n-import com.marklogic.hub.flow.impl.FlowImpl;\n-import com.marklogic.hub.flow.impl.FlowRunnerImpl;\n-import com.marklogic.hub.impl.FlowManagerImpl;\n-import com.marklogic.hub.impl.ScaffoldingImpl;\n-import com.marklogic.hub.impl.StepDefinitionManagerImpl;\n-import com.marklogic.hub.oneui.exceptions.DataHubException;\n-import com.marklogic.hub.oneui.models.StepModel;\n-import com.marklogic.hub.scaffold.Scaffolding;\n-import com.marklogic.hub.step.StepDefinition;\n-import com.marklogic.hub.step.impl.Step;\n-import com.marklogic.hub.util.json.JSONObject;\n-import com.marklogic.hub.util.json.JSONUtils;\n-import org.apache.commons.io.IOUtils;\n-import org.apache.commons.lang3.EnumUtils;\n-import org.apache.commons.lang3.StringUtils;\n-\n-import javax.ws.rs.BadRequestException;\n-import javax.ws.rs.NotFoundException;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-\n-public class FlowManagerService {\n-\n-    private HubConfig hubConfig;\n-    private FlowManager flowManager;\n-    private StepDefinitionManager stepDefinitionManager;\n-    private Scaffolding scaffolding;\n-    private FlowRunnerImpl lastFlowRunner = null;\n-\n-    public FlowManagerService(HubConfig hubConfig) {\n-        this.hubConfig = hubConfig;\n-        this.flowManager = new FlowManagerImpl(this.hubConfig);\n-        this.stepDefinitionManager = new StepDefinitionManagerImpl(this.hubConfig);\n-        this.scaffolding = new ScaffoldingImpl(this.hubConfig);\n-    }\n-\n-    public Flow updateFlow(String flowJson) {\n-        return updateFlow(flowJson, false);\n-    }\n-\n-    public Flow updateFlow(String flowJson, boolean onlyUpdateLocal) {\n-        //for PUT updating\n-        JSONObject jsonObject = processPayload(flowJson);\n-\n-        String flowName = jsonObject.getString(\"name\");\n-        Flow flow;\n-        flow = flowManager.getFlow(flowName);\n-        if (flow == null) {\n-            throw new DataHubException(\"Either the flow \"+ flowName +\" doesn't exist or an attempt to change flow name \" +\n-                \"is made which is prohibited \");\n-        }\n-        flow.deserialize(jsonObject.jsonNode());\n-        if (onlyUpdateLocal) {\n-            flowManager.saveLocalFlow(flow);\n-        } else {\n-            flowManager.saveFlow(flow);\n-        }\n-        return flow;\n-    }\n-\n-    public Flow createFlow(String flowJson) {\n-        JSONObject jsonObject = processPayload(flowJson);\n-\n-        String flowName = jsonObject.getString(\"name\");\n-        Flow flow;\n-\n-        if (flowManager.isFlowExisted(flowName)) {\n-            throw new DataHubException(\"A Flow with \" + flowName + \" already exists.\");\n-        }\n-        flow = new FlowImpl();\n-        flow.setName(flowName);\n-\n-        flow.deserialize(jsonObject.jsonNode());\n-        flowManager.saveFlow(flow);\n-        return flow;\n-    }\n-\n-    private JSONObject processPayload(String flowJson) {\n-        JSONObject jsonObject;\n-        try {\n-            jsonObject = new JSONObject(flowJson);\n-\n-            JSONUtils.trimText(jsonObject, \"separator\");\n-        }\n-        catch (IOException e) {\n-            throw new DataHubException(\"Unable to parse flow json string : \" + e.getMessage());\n-        }\n-\n-        if (!jsonObject.isExist(\"name\") || StringUtils.isEmpty(jsonObject.getString(\"name\"))) {\n-            throw new BadRequestException(\"Flow Name not provided. Flow Name is required.\");\n-        }\n-        return jsonObject;\n-    }\n-\n-    public Flow getFlow(String flowName) {\n-        Flow flow = flowManager.getFlow(flowName);\n-        if (flow == null) {\n-            throw new NotFoundException(flowName + \" not found!\");\n-        }\n-        return flow;\n-    }\n-\n-    public void deleteFlow(String flowName) {\n-        flowManager.deleteFlow(flowName);\n-    }\n-\n-    public List<Flow> getFlows() {\n-        return flowManager.getFlows();\n-    }\n-\n-    public List<StepModel> getSteps(String flowName) {\n-        Flow flow = flowManager.getFlow(flowName);\n-        Map<String, Step> stepMap = flow.getSteps();\n-\n-        List<StepModel> stepModelList = new ArrayList<>();\n-        for (String key : stepMap.keySet()) {\n-            Step step = stepMap.get(key);\n-            StepModel stepModel = transformStepToWebModel(step);\n-            stepModelList.add(stepModel);\n-        }\n-\n-        return stepModelList;\n-    }\n-\n-    public StepModel getStep(String flowName, String stepId) {\n-        Flow flow = flowManager.getFlow(flowName);\n-        if (flow == null) {\n-            throw new NotFoundException(flowName + \" not found.\");\n-        }\n-\n-        Step step = flow.getStep(getStepKeyInStepMap(flow, stepId));\n-        if (step == null) {\n-            throw new NotFoundException(stepId + \" not found.\");\n-        }\n-\n-        return transformStepToWebModel(step);\n-    }\n-\n-    public StepModel createStep(String flowName, Integer stepOrder, String stepId, String stringStep) {\n-        StepModel stepModel;\n-        JsonNode stepJson;\n-        Flow flow = flowManager.getFlow(flowName);\n-        Step existingStep = flow.getStep(getStepKeyInStepMap(flow, stepId));\n-\n-        if (existingStep == null && !StringUtils.isEmpty(stepId)) {\n-            throw new NotFoundException(\"Step \" + stepId + \" Not Found\");\n-        }\n-\n-        try {\n-            stepJson = JSONObject.readInput(stringStep);\n-\n-            JSONUtils.trimText(stepJson, \"separator\");\n-\n-            stepModel = StepModel.fromJson(stepJson);\n-        }\n-        catch (IOException e) {\n-            throw new BadRequestException(\"Error parsing JSON\");\n-        }\n-\n-        if (stepModel == null) {\n-            throw new BadRequestException();\n-        }\n-\n-        Step step = StepModel.transformToCoreStepModel(stepModel, stepJson);\n-\n-        if (step.getStepDefinitionType() == null) {\n-            throw new BadRequestException(\"Invalid Step Definition Type\");\n-        }\n-\n-        if (step.getStepDefinitionName() == null) {\n-            throw new BadRequestException(\"Invalid Step Definition Name\");\n-        }\n-\n-        if (stepId != null) {\n-            if (!stepId.equals(step.getName() + \"-\" + step.getStepDefinitionType())) {\n-                throw new BadRequestException(\"Changing step name or step type not supported.\");\n-            }\n-        }\n-        if(!EnumUtils.isValidEnumIgnoreCase(StepDefinition.StepDefinitionType.class, step.getStepDefinitionType().toString())) {\n-            throw new BadRequestException(\"Invalid Step Type\");\n-        }\n-\n-        step = upsertStepDefinition(stepModel, step);\n-\n-        Map<String, Step> currSteps = flow.getSteps();\n-        if (stepId != null) {\n-            String key = getStepKeyInStepMap(flow, stepId);\n-            if (StringUtils.isNotEmpty(key)) {\n-                currSteps.put(key, step);\n-            }\n-            flow.setSteps(currSteps);\n-        }\n-        else {\n-            if (stepOrder == null || stepOrder > currSteps.size()) {\n-                currSteps.put(String.valueOf(currSteps.size() + 1), step);\n-            }\n-            else {\n-                Map<String, Step> newSteps = new LinkedHashMap<>();\n-                final Integer[] count = {1};\n-                Step finalStep = step;\n-                currSteps.values().forEach(s -> {\n-                    if (count[0].equals(stepOrder)) {\n-                        newSteps.put(String.valueOf(count[0]++), finalStep);\n-                    }\n-                    newSteps.put(String.valueOf(count[0]), s);\n-                    ++count[0];\n-                });\n-                flow.setSteps(newSteps);\n-            }\n-        }\n-\n-        if (existingStep != null && existingStep.isEqual(step)) {\n-            return transformStepToWebModel(existingStep);\n-        }\n-\n-        flowManager.saveFlow(flow);\n-        return transformStepToWebModel(step);\n-    }\n-\n-    private Step mergeDefaultStepDefinitionIntoStep(StepModel stepModel, Step step) {\n-        String stepType = step.getStepDefinitionType().toString().toLowerCase();\n-        StepDefinition defaultStepDefinition = getDefaultStepDefinitionFromResources(\"hub-internal-artifacts/step-definitions/\" + stepType + \"/marklogic/\"+ step.getStepDefinitionName() +\".step.json\", step.getStepDefinitionType());\n-        Step defaultStep = defaultStepDefinition.transformToStep(step.getName(), defaultStepDefinition, new Step());\n-        return StepModel.mergeFields(stepModel, defaultStep, step);\n-    }\n-\n-    private Step upsertStepDefinition(StepModel stepModel, Step step) {\n-        if (stepDefinitionManager.getStepDefinition(step.getStepDefinitionName(), step.getStepDefinitionType()) != null) {\n-            String stepType = step.getStepDefinitionType().toString().toLowerCase();\n-            if(step.getStepDefinitionName().equalsIgnoreCase(\"default-\" + stepType) || \"entity-services-mapping\".equalsIgnoreCase(step.getStepDefinitionName())) {\n-                step = mergeDefaultStepDefinitionIntoStep(stepModel, step);\n-            }\n-            else {\n-                StepDefinition oldStepDefinition = stepDefinitionManager.getStepDefinition(step.getStepDefinitionName(), step.getStepDefinitionType());\n-                StepDefinition stepDefinition = transformFromStep(oldStepDefinition, step, stepModel);\n-                stepDefinitionManager.saveStepDefinition(stepDefinition);\n-            }\n-        }\n-        else {\n-            String stepDefName = step.getStepDefinitionName();\n-            StepDefinition.StepDefinitionType stepDefType = step.getStepDefinitionType();\n-            String modulePath = \"/custom-modules/\" + stepDefType.toString().toLowerCase() + \"/\" + stepDefName + \"/main.sjs\";\n-\n-            StepDefinition stepDefinition = StepDefinition.create(stepDefName, stepDefType);\n-            stepDefinition = transformFromStep(stepDefinition, step, stepModel);\n-\n-            scaffolding.createCustomModule(stepDefName, stepDefType.toString());\n-            stepDefinition.setModulePath(modulePath);\n-            stepDefinitionManager.saveStepDefinition(stepDefinition);\n-        }\n-        return step;\n-    }\n-\n-    public void deleteStep(String flowName, String stepId) {\n-        Flow flow = flowManager.getFlow(flowName);\n-        String key = getStepKeyInStepMap(flow, stepId);\n-\n-        if (StringUtils.isEmpty(key)) {\n-            throw new BadRequestException(\"Invalid Step Id\");\n-        }\n-\n-        try {\n-            flowManager.deleteStep(flow, key);\n-        }\n-        catch (DataHubProjectException e) {\n-            throw new NotFoundException(e.getMessage());\n-        }\n-    }\n-\n-    /*\n-    The core and web models for steps are different, webModel has 'modulePath' which provides the uri of the main.sjs\n-    whereas it is not present in the core step model. Hence the following 2 transform methods additionally are meant to\n-    set modulePaths in 'StepModel' and 'StepDefinition' .\n-     */\n-    private StepModel transformStepToWebModel(Step step) {\n-        StepModel stepModel = StepModel.transformToWebStepModel(step);\n-        StepDefinition stepDef = stepDefinitionManager.getStepDefinition(step.getStepDefinitionName(), step.getStepDefinitionType());\n-        stepModel.setModulePath(stepDef.getModulePath());\n-        return stepModel;\n-    }\n-\n-    private StepDefinition transformFromStep(StepDefinition stepDefinition, Step step, StepModel stepModel) {\n-        StepDefinition newStepDefinition = stepDefinition.transformFromStep(stepDefinition, step);\n-        newStepDefinition.setModulePath(stepModel.getModulePath());\n-        return newStepDefinition;\n-    }\n-\n-    private String getStepKeyInStepMap(Flow flow, String stepId) {\n-        if (flow == null || StringUtils.isEmpty(stepId)) {\n-            return null;\n-        }\n-\n-        // Split on the last occurrence of \"-\"\n-        String[] stepStr = stepId.split(\"-(?!.*-)\");\n-\n-        if (stepStr.length == 2) {\n-            String name = stepStr[0];\n-            String type = stepStr[1];\n-            String[] key = new String[1];\n-\n-            flow.getSteps().forEach((k, v) -> {\n-                if (name.equals(v.getName()) && type.equalsIgnoreCase(v.getStepDefinitionType().toString())) {\n-                    key[0] = k;\n-                }\n-            });\n-            return key[0];\n-        }\n-        return null;\n-    }\n-\n-    private StepDefinition getDefaultStepDefinitionFromResources(String resourcePath, StepDefinition.StepDefinitionType stepDefinitionType) {\n-        try (InputStream in = FlowManagerService.class.getClassLoader().getResourceAsStream(resourcePath)) {\n-            JSONObject jsonObject = new JSONObject(IOUtils.toString(in));\n-            StepDefinition defaultStep = StepDefinition.create(stepDefinitionType.toString(), stepDefinitionType);\n-            defaultStep.deserialize(jsonObject.jsonNode());\n-            return defaultStep;\n-        }\n-        catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-\n-    /**\n-     * This is synchronized because Coverity is reporting that flowManagerService is being modified without proper\n-     * synchronization when it's invoked by FlowController.\n-     *\n-     * @param flowName\n-     * @param steps\n-     * @return\n-     */\n-    public synchronized RunFlowResponse runFlow(String flowName, List<String> steps) {\n-        FlowRunnerImpl flowRunner = getFlowRunner();\n-        if (steps == null || steps.size() == 0) {\n-            return flowRunner.runFlow(flowName);\n-        }\n-        else {\n-            Flow flow = flowManager.getFlow(flowName);\n-            List<String> restrictedSteps = new ArrayList<>();\n-            steps.forEach((step) -> restrictedSteps.add(this.getStepKeyInStepMap(flow, step)));\n-            return flowRunner.runFlow(flowName, restrictedSteps);\n-        }\n-    }\n-\n-    public Flow stop(String flowName) {\n-        FlowRunnerImpl flowRunner = getFlowRunner();\n-        List<String> jobIds = flowRunner.getQueuedJobIdsFromFlow(flowName);\n-        Iterator<String> itr = jobIds.iterator();\n-        if (!itr.hasNext()) {\n-            throw new BadRequestException(\"Flow not running.\");\n-        }\n-        while (itr.hasNext()) {\n-            flowRunner.stopJob(itr.next());\n-        }\n-        return getFlow(flowName);\n-    }\n-\n-    protected FlowRunnerImpl getFlowRunner() {\n-        lastFlowRunner = new FlowRunnerImpl(this.hubConfig);\n-        return lastFlowRunner;\n-    }\n-\n-    // TODO public so the FlowControllerTest can see it\n-    public FlowRunnerImpl getLastFlowRunner() {\n-        return lastFlowRunner;\n-    }\n-}\n"}}, {"oid": "e1e5db6183ea386d31eda0c15ee814a95aec276b", "url": "https://github.com/marklogic/marklogic-data-hub/commit/e1e5db6183ea386d31eda0c15ee814a95aec276b", "message": "DHFPROD-3922: Legacy FlowRunner still needs some of the Autowire annotations", "committedDate": "2020-03-03T19:43:28Z", "type": "commit"}, {"oid": "c8bce169b83628d80d509db3bd4bbe4df38035d3", "url": "https://github.com/marklogic/marklogic-data-hub/commit/c8bce169b83628d80d509db3bd4bbe4df38035d3", "message": "DHFPROD-3922: Implement refactoring that removes FlowManagerService", "committedDate": "2020-03-03T20:49:07Z", "type": "commit"}, {"oid": "69be94623f3d3940057fbb4759ad1dc179e77057", "url": "https://github.com/marklogic/marklogic-data-hub/commit/69be94623f3d3940057fbb4759ad1dc179e77057", "message": "Update marklogic-data-hub/src/main/java/com/marklogic/hub/flow/impl/FlowRunnerImpl.java\n\nCo-Authored-By: Hao Liu <hao.liu@marklogic.com>", "committedDate": "2020-03-03T23:25:31Z", "type": "commit"}]}