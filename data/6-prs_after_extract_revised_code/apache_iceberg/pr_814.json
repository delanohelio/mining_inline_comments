{"pr_number": 814, "pr_title": "Update RemoveSnapshots to protect cherry-picked data.", "pr_createdAt": "2020-02-20T09:55:03Z", "pr_url": "https://github.com/apache/iceberg/pull/814", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0MjEzNQ==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382142135", "bodyText": "Instead of updating a static variable that we need to clean up between test cases, how about using the delete callback? I think that's going to be a better way to test.", "author": "rdblue", "createdAt": "2020-02-20T17:17:55Z", "path": "core/src/test/java/org/apache/iceberg/TestTables.java", "diffHunk": "@@ -218,9 +222,7 @@ public OutputFile newOutputFile(String path) {\n \n     @Override\n     public void deleteFile(String path) {\n-      if (!new File(path).delete()) {\n-        throw new RuntimeIOException(\"Failed to delete file: \" + path);\n-      }\n+      DELETED_FILE_PATHS.add(path);", "originalCommit": "4c6cd676461069265ac2665781a08f34dd631b98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE3OTcwMA==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382179700", "bodyText": "+1", "author": "rominparekh", "createdAt": "2020-02-20T18:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0MjEzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "9f207d9af21cb7ef1a2e890ce1a88768b4ceb59b", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestTables.java b/core/src/test/java/org/apache/iceberg/TestTables.java\nindex 642fc8c2f..4d94e02ba 100644\n--- a/core/src/test/java/org/apache/iceberg/TestTables.java\n+++ b/core/src/test/java/org/apache/iceberg/TestTables.java\n\n@@ -222,7 +242,11 @@ public class TestTables {\n \n     @Override\n     public void deleteFile(String path) {\n-      DELETED_FILE_PATHS.add(path);\n+      if (deleteFileCallback.isPresent()) {\n+        deleteFileCallback.get().accept(path);\n+      } else if (!new File(path).delete()) {\n+        throw new RuntimeIOException(\"Failed to delete file: \" + path);\n+      }\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0MjgxMQ==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382142811", "bodyText": "Can you move this to a separate PR? I don't think we need to update RemoveSnapshots and deprecate a method at the same time.", "author": "rdblue", "createdAt": "2020-02-20T17:19:06Z", "path": "api/src/main/java/org/apache/iceberg/ExpireSnapshots.java", "diffHunk": "@@ -40,11 +40,13 @@\n public interface ExpireSnapshots extends PendingUpdate<List<Snapshot>> {\n \n   /**\n-   * Expires a specific {@link Snapshot} identified by id.\n+   * Expires a specific {@link Snapshot} identified by id. This API isn't compatible with\n+   * cherry-pick functionality (issue #744), and hence marked Deprecated.\n    *\n    * @param snapshotId long id of the snapshot to expire\n    * @return this for method chaining\n    */\n+  @Deprecated", "originalCommit": "4c6cd676461069265ac2665781a08f34dd631b98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE3OTQ3Mg==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382179472", "bodyText": "Also can we possibly provide a message to use an alternate API for deprecation. Something like -\n@Deprecate(\"Use `expireOlderThan()` method instead\")", "author": "rominparekh", "createdAt": "2020-02-20T18:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0MjgxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "9f207d9af21cb7ef1a2e890ce1a88768b4ceb59b", "chunk": "diff --git a/api/src/main/java/org/apache/iceberg/ExpireSnapshots.java b/api/src/main/java/org/apache/iceberg/ExpireSnapshots.java\nindex 8811390be..9f0a72058 100644\n--- a/api/src/main/java/org/apache/iceberg/ExpireSnapshots.java\n+++ b/api/src/main/java/org/apache/iceberg/ExpireSnapshots.java\n\n@@ -40,13 +40,11 @@ import java.util.function.Consumer;\n public interface ExpireSnapshots extends PendingUpdate<List<Snapshot>> {\n \n   /**\n-   * Expires a specific {@link Snapshot} identified by id. This API isn't compatible with\n-   * cherry-pick functionality (issue #744), and hence marked Deprecated.\n+   * Expires a specific {@link Snapshot} identified by id.\n    *\n    * @param snapshotId long id of the snapshot to expire\n    * @return this for method chaining\n    */\n-  @Deprecated\n   ExpireSnapshots expireSnapshotId(long snapshotId);\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0NDA3Ng==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382144076", "bodyText": "Quick note: this case needs a follow-up because we could expire A and B, then later expire C (not in the current table state) and not be able to detect that we should not delete its files. Expiring B means that we need to also expire C.", "author": "rdblue", "createdAt": "2020-02-20T17:21:21Z", "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -208,12 +226,40 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n       }\n     }\n \n+    // find manifests to clean up that were only referenced by snapshots that have expired\n     Set<String> manifestListsToDelete = Sets.newHashSet();\n     Set<String> manifestsToDelete = Sets.newHashSet();\n     Set<ManifestFile> manifestsToRevert = Sets.newHashSet();\n     for (Snapshot snapshot : base.snapshots()) {\n       long snapshotId = snapshot.snapshotId();\n       if (!validIds.contains(snapshotId)) {\n+        // determine whether the changes in this snapshot are in the current table state\n+        if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n+          // this snapshot was cherry-picked into the current table state, so skip cleaning it up. its changes will\n+          // expire when the picked snapshot expires.\n+          // A -- C (source=B)\n+          //  `- B <-- this commit\n+          continue;\n+        }\n+\n+        long sourceSnapshotId = PropertyUtil.propertyAsLong(\n+            snapshot.summary(), SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP, -1);\n+        if (ancestorIds.contains(sourceSnapshotId)) {\n+          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n+          // changes because it would revert data file additions that are in the current table.\n+          // A -- B\n+          //  `- C (source=B) <-- this commit", "originalCommit": "4c6cd676461069265ac2665781a08f34dd631b98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzODg0MQ==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382338841", "bodyText": "NOTE: I think we can handle this case, i.e. when picking a snapshot for expiration, we should also pick its source snapshot, but considering the gotchas, I would recommend to keep the API simple with expireOlderThan. Also our use case is to use expireOlderThan API for now.\nI will log a ticket for this.", "author": "mehtaashish23", "createdAt": "2020-02-21T00:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0NDA3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "289c824d783c7622b9556c2fcfed5663e6237a5d", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java b/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\nindex 222fd1f25..f806c82b6 100644\n--- a/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\n+++ b/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\n\n@@ -237,7 +237,7 @@ class RemoveSnapshots implements ExpireSnapshots {\n         if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n           // this snapshot was cherry-picked into the current table state, so skip cleaning it up. its changes will\n           // expire when the picked snapshot expires.\n-          // A -- C (source=B)\n+          // A -- C -- D (source=B)\n           //  `- B <-- this commit\n           continue;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0OTQwMQ==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382149401", "bodyText": "I think these tests should be in the suite for snapshot expiration, not the suite for WAP. Can you move them?", "author": "rdblue", "createdAt": "2020-02-20T17:31:09Z", "path": "core/src/test/java/org/apache/iceberg/TestWapWorkflow.java", "diffHunk": "@@ -684,4 +685,87 @@ public void testNonWapCherrypick() {\n           table.manageSnapshots().cherrypick(firstSnapshotId).commit();\n         });\n   }\n+\n+  @Test\n+  public void testWithExpiringWapThenCherrypick() {", "originalCommit": "4c6cd676461069265ac2665781a08f34dd631b98", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9f207d9af21cb7ef1a2e890ce1a88768b4ceb59b", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestWapWorkflow.java b/core/src/test/java/org/apache/iceberg/TestWapWorkflow.java\nindex fd8de395b..f11363d04 100644\n--- a/core/src/test/java/org/apache/iceberg/TestWapWorkflow.java\n+++ b/core/src/test/java/org/apache/iceberg/TestWapWorkflow.java\n\n@@ -685,87 +684,4 @@ public class TestWapWorkflow extends TableTestBase {\n           table.manageSnapshots().cherrypick(firstSnapshotId).commit();\n         });\n   }\n-\n-  @Test\n-  public void testWithExpiringWapThenCherrypick() {\n-    table.newAppend()\n-            .appendFile(FILE_A)\n-            .commit();\n-    // first WAP commit\n-    table.newAppend()\n-            .appendFile(FILE_B)\n-            .set(SnapshotSummary.STAGED_WAP_ID_PROP, \"123456789\")\n-            .stageOnly()\n-            .commit();\n-    table.refresh();\n-\n-    // pick the snapshot that's staged but not committed\n-    Snapshot wap1Snapshot = null;\n-    for (Snapshot s : table.snapshots()) {\n-      if (\"123456789\".equalsIgnoreCase(s.summary()\n-              .getOrDefault(SnapshotSummary.STAGED_WAP_ID_PROP, null))) {\n-        wap1Snapshot = s;\n-        break;\n-      }\n-    }\n-    Assert.assertNotNull(wap1Snapshot);\n-\n-    // table has new commit so that cherrypick can come into affect.\n-    table.newAppend()\n-            .appendFile(FILE_C)\n-            .commit();\n-    table.refresh();\n-\n-    // cherry-pick first snapshot\n-    table.manageSnapshots().cherrypick(wap1Snapshot.snapshotId()).commit();\n-    table.refresh();\n-    Snapshot wap1CherryPickSnapshot = table.currentSnapshot();\n-    Assert.assertEquals(\"123456789\", wap1CherryPickSnapshot.summary().getOrDefault(SnapshotSummary.PUBLISHED_WAP_ID_PROP,\n-            null));\n-    Assert.assertEquals(wap1CherryPickSnapshot.summary().getOrDefault(SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP,\n-            null), String.valueOf(wap1Snapshot.snapshotId()));\n-\n-\n-    table.expireSnapshots().expireOlderThan(wap1Snapshot.timestampMillis() + 1).commit();\n-    table.expireSnapshots().expireOlderThan(wap1CherryPickSnapshot.timestampMillis() + 1).commit();\n-\n-    //Make sure no files are deleted for the wap and cherrypick\n-    Lists.newArrayList(wap1Snapshot, wap1CherryPickSnapshot).forEach(i -> {\n-      i.addedFiles().forEach(item -> {\n-        Assert.assertFalse(TestTables.DELETED_FILE_PATHS.contains(item.path().toString()));\n-      });\n-    });\n-  }\n-\n-  @Test\n-  public void testWithExpiringDanglingWap() {\n-    table.newAppend()\n-            .appendFile(FILE_A)\n-            .commit();\n-    table.refresh();\n-\n-    // WAP commit\n-    table.newAppend()\n-            .appendFile(FILE_D)\n-            .set(\"wap.id\", \"987654321\")\n-            .stageOnly()\n-            .commit();\n-    table.refresh();\n-\n-    Snapshot wapSnapshot = null;\n-    for (Snapshot s : table.snapshots()) {\n-      if (\"987654321\".equalsIgnoreCase(s.summary()\n-              .getOrDefault(SnapshotSummary.STAGED_WAP_ID_PROP, null))) {\n-        wapSnapshot = s;\n-        break;\n-      }\n-    }\n-    Assert.assertNotNull(wapSnapshot);\n-    table.expireSnapshots().expireOlderThan(wapSnapshot.timestampMillis() + 1).commit();\n-\n-    wapSnapshot.addedFiles().forEach(item -> {\n-      Assert.assertTrue(TestTables.DELETED_FILE_PATHS.contains(item.path().toString()));\n-    });\n-  }\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1MDIzOQ==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382150239", "bodyText": "The tests shouldn't use WAP properties at all. Correctness depends on where commits were picked and should ignore the WAP ID. The reason is that two commits with the same WAP id don't contain the same files. They are logically the same data, not physically the same files. The only equivalence that matters is when a snapshot itself has been picked because the files are physically the same.", "author": "rdblue", "createdAt": "2020-02-20T17:32:49Z", "path": "core/src/test/java/org/apache/iceberg/TestWapWorkflow.java", "diffHunk": "@@ -684,4 +685,87 @@ public void testNonWapCherrypick() {\n           table.manageSnapshots().cherrypick(firstSnapshotId).commit();\n         });\n   }\n+\n+  @Test\n+  public void testWithExpiringWapThenCherrypick() {\n+    table.newAppend()\n+            .appendFile(FILE_A)\n+            .commit();\n+    // first WAP commit\n+    table.newAppend()\n+            .appendFile(FILE_B)\n+            .set(SnapshotSummary.STAGED_WAP_ID_PROP, \"123456789\")", "originalCommit": "4c6cd676461069265ac2665781a08f34dd631b98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MDgzOA==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382180838", "bodyText": "@mehtaashish23 - Can you add a UT for each scenario we are trying to handle? It might help debug in case we see rogue behavior. Thanks.", "author": "rominparekh", "createdAt": "2020-02-20T18:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1MDIzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "9f207d9af21cb7ef1a2e890ce1a88768b4ceb59b", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestWapWorkflow.java b/core/src/test/java/org/apache/iceberg/TestWapWorkflow.java\nindex fd8de395b..f11363d04 100644\n--- a/core/src/test/java/org/apache/iceberg/TestWapWorkflow.java\n+++ b/core/src/test/java/org/apache/iceberg/TestWapWorkflow.java\n\n@@ -685,87 +684,4 @@ public class TestWapWorkflow extends TableTestBase {\n           table.manageSnapshots().cherrypick(firstSnapshotId).commit();\n         });\n   }\n-\n-  @Test\n-  public void testWithExpiringWapThenCherrypick() {\n-    table.newAppend()\n-            .appendFile(FILE_A)\n-            .commit();\n-    // first WAP commit\n-    table.newAppend()\n-            .appendFile(FILE_B)\n-            .set(SnapshotSummary.STAGED_WAP_ID_PROP, \"123456789\")\n-            .stageOnly()\n-            .commit();\n-    table.refresh();\n-\n-    // pick the snapshot that's staged but not committed\n-    Snapshot wap1Snapshot = null;\n-    for (Snapshot s : table.snapshots()) {\n-      if (\"123456789\".equalsIgnoreCase(s.summary()\n-              .getOrDefault(SnapshotSummary.STAGED_WAP_ID_PROP, null))) {\n-        wap1Snapshot = s;\n-        break;\n-      }\n-    }\n-    Assert.assertNotNull(wap1Snapshot);\n-\n-    // table has new commit so that cherrypick can come into affect.\n-    table.newAppend()\n-            .appendFile(FILE_C)\n-            .commit();\n-    table.refresh();\n-\n-    // cherry-pick first snapshot\n-    table.manageSnapshots().cherrypick(wap1Snapshot.snapshotId()).commit();\n-    table.refresh();\n-    Snapshot wap1CherryPickSnapshot = table.currentSnapshot();\n-    Assert.assertEquals(\"123456789\", wap1CherryPickSnapshot.summary().getOrDefault(SnapshotSummary.PUBLISHED_WAP_ID_PROP,\n-            null));\n-    Assert.assertEquals(wap1CherryPickSnapshot.summary().getOrDefault(SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP,\n-            null), String.valueOf(wap1Snapshot.snapshotId()));\n-\n-\n-    table.expireSnapshots().expireOlderThan(wap1Snapshot.timestampMillis() + 1).commit();\n-    table.expireSnapshots().expireOlderThan(wap1CherryPickSnapshot.timestampMillis() + 1).commit();\n-\n-    //Make sure no files are deleted for the wap and cherrypick\n-    Lists.newArrayList(wap1Snapshot, wap1CherryPickSnapshot).forEach(i -> {\n-      i.addedFiles().forEach(item -> {\n-        Assert.assertFalse(TestTables.DELETED_FILE_PATHS.contains(item.path().toString()));\n-      });\n-    });\n-  }\n-\n-  @Test\n-  public void testWithExpiringDanglingWap() {\n-    table.newAppend()\n-            .appendFile(FILE_A)\n-            .commit();\n-    table.refresh();\n-\n-    // WAP commit\n-    table.newAppend()\n-            .appendFile(FILE_D)\n-            .set(\"wap.id\", \"987654321\")\n-            .stageOnly()\n-            .commit();\n-    table.refresh();\n-\n-    Snapshot wapSnapshot = null;\n-    for (Snapshot s : table.snapshots()) {\n-      if (\"987654321\".equalsIgnoreCase(s.summary()\n-              .getOrDefault(SnapshotSummary.STAGED_WAP_ID_PROP, null))) {\n-        wapSnapshot = s;\n-        break;\n-      }\n-    }\n-    Assert.assertNotNull(wapSnapshot);\n-    table.expireSnapshots().expireOlderThan(wapSnapshot.timestampMillis() + 1).commit();\n-\n-    wapSnapshot.addedFiles().forEach(item -> {\n-      Assert.assertTrue(TestTables.DELETED_FILE_PATHS.contains(item.path().toString()));\n-    });\n-  }\n-\n }\n"}}, {"oid": "9f207d9af21cb7ef1a2e890ce1a88768b4ceb59b", "url": "https://github.com/apache/iceberg/commit/9f207d9af21cb7ef1a2e890ce1a88768b4ceb59b", "message": "Issue-744: Support for ExpireSnapshot functionality on top of cherrypick\n\nPR Feedback", "committedDate": "2020-02-21T00:49:57Z", "type": "forcePushed"}, {"oid": "c721c090db4f2761fdcbd7b4ee82bab8c998ab26", "url": "https://github.com/apache/iceberg/commit/c721c090db4f2761fdcbd7b4ee82bab8c998ab26", "message": "Issue-744: Support for ExpireSnapshot functionality on top of cherrypick\n\nPR Feedback", "committedDate": "2020-02-21T00:50:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMDY0Mg==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382710642", "bodyText": "This class doesn't need to change at all because you can use ExpireSnapshots.deleteWith and pass a callback. In each test case, you'd do this to get the list of deletes:\n  List<String> deletedFiles = Lists.newArrayList();\n  table.expireSnapshots()\n      .deleteWith(deletedFiles::add)\n      .expireOlderThan(t)\n      .commit();", "author": "rdblue", "createdAt": "2020-02-21T17:30:09Z", "path": "core/src/test/java/org/apache/iceberg/TableTestBase.java", "diffHunk": "@@ -109,8 +113,8 @@ public void cleanupTables() {\n         !name.startsWith(\"snap\") && Files.getFileExtension(name).equalsIgnoreCase(\"avro\")));\n   }\n \n-  private TestTables.TestTable create(Schema schema, PartitionSpec spec) {\n-    return TestTables.create(tableDir, \"test\", schema, spec);\n+  private TestTables.TestTable create(Schema schema, PartitionSpec spec, Boolean accumulateDeletedFiles) {\n+    return TestTables.create(tableDir, \"test\", schema, spec, accumulateDeletedFiles);", "originalCommit": "7b69fdca2d4b97196b933c5677e6b11c0f93a2d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgxNjM5Mg==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382816392", "bodyText": "ohh really. Thanks, nice API!", "author": "mehtaashish23", "createdAt": "2020-02-21T21:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMDY0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TableTestBase.java b/core/src/test/java/org/apache/iceberg/TableTestBase.java\nindex 73609231f..012d177d9 100644\n--- a/core/src/test/java/org/apache/iceberg/TableTestBase.java\n+++ b/core/src/test/java/org/apache/iceberg/TableTestBase.java\n\n@@ -113,8 +109,8 @@ public class TableTestBase {\n         !name.startsWith(\"snap\") && Files.getFileExtension(name).equalsIgnoreCase(\"avro\")));\n   }\n \n-  private TestTables.TestTable create(Schema schema, PartitionSpec spec, Boolean accumulateDeletedFiles) {\n-    return TestTables.create(tableDir, \"test\", schema, spec, accumulateDeletedFiles);\n+  private TestTables.TestTable create(Schema schema, PartitionSpec spec) {\n+    return TestTables.create(tableDir, \"test\", schema, spec);\n   }\n \n   TestTables.TestTable load() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMTAwMw==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382711003", "bodyText": "This shouldn't use the name wap, since this is independent of the WAP pattern.", "author": "rdblue", "createdAt": "2020-02-21T17:30:54Z", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +393,55 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+  @Test\n+  public void testWithExpiringWapThenCherrypick() {\n+    // first WAP commit\n+    table.newAppend()\n+            .appendFile(FILE_B)\n+            .stageOnly()\n+            .commit();\n+\n+    TableMetadata base = readMetadata();\n+    // pick the snapshot that's staged but not committed\n+    Snapshot wap1Snapshot = base.snapshots().get(0);", "originalCommit": "7b69fdca2d4b97196b933c5677e6b11c0f93a2d8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\nindex e5eafd9f7..3ab8707d0 100644\n--- a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n+++ b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n\n@@ -393,55 +388,163 @@ public class TestRemoveSnapshots extends TableTestBase {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n   @Test\n-  public void testWithExpiringWapThenCherrypick() {\n-    // first WAP commit\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n     table.newAppend()\n-            .appendFile(FILE_B)\n-            .stageOnly()\n-            .commit();\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n \n     TableMetadata base = readMetadata();\n-    // pick the snapshot that's staged but not committed\n-    Snapshot wap1Snapshot = base.snapshots().get(0);\n-    Assert.assertNotNull(wap1Snapshot);\n-    // new commit on table so that cherrypick can come into affect.\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n     table.newAppend()\n-            .appendFile(FILE_C)\n-            .commit();\n+        .appendFile(FILE_C)\n+        .commit();\n \n-    table.manageSnapshots().cherrypick(wap1Snapshot.snapshotId()).commit();\n+    List<String> deletedFiles = new ArrayList<>();\n \n-    //Expire wap commit.\n-    table.expireSnapshots().expireOlderThan(table.currentSnapshot().timestampMillis() + 1).commit();\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n \n-    //Expire all snapshots including cherrypick\n-    table.expireSnapshots().expireOlderThan(table.currentSnapshot().timestampMillis() + 1).commit();\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {\n+      Assert.assertTrue(deletedFiles.contains(item.path().toString()));\n+    });\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B\n+   *   `- C (B) <--this commit\n+   */\n+  @Test\n+  public void testWithCherryPickTableSnapshot() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+    // pick the snapshot 'B`\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // Move the table back to `A`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotA.snapshotId())\n+        .commit();\n+\n+    // Generate A -> `C (B)`\n+    table.manageSnapshots()\n+        .cherrypick(snapshotB.snapshotId())\n+        .commit();\n+    Snapshot snapshotC = readMetadata().currentSnapshot();\n+\n+    // Move the table back to `B`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotB.snapshotId())\n+        .commit();\n+    List<String> deletedFiles = new ArrayList<>();\n \n-    //Make sure no files are deleted for the wap and cherrypick\n-    Lists.newArrayList(wap1Snapshot).forEach(i -> {\n+    // Expire `C`\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireSnapshotId(snapshotC.snapshotId())\n+        .commit();\n+\n+    // Make sure no dataFiles are deleted for the B and C snapshot\n+    Lists.newArrayList(snapshotB, snapshotC).forEach(i -> {\n       i.addedFiles().forEach(item -> {\n-        Assert.assertFalse(table.getDeletedDataFiles().contains(item.path().toString()));\n+        Assert.assertFalse(deletedFiles.contains(item.path().toString()));\n       });\n     });\n   }\n \n+  /**\n+   * Test on table below, and expiring\n+   *  1) Expire `B`\n+   *  2) All commit\n+   * Table: A - C - D (B)\n+   *          ` B (staged)\n+   */\n   @Test\n-  public void testWithExpiringDanglingWap() {\n-    // WAP commit\n+  public void testWithExpiringStagedThenCherrypick() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n     table.newAppend()\n-            .appendFile(FILE_D)\n-            .stageOnly()\n-            .commit();\n-    table.refresh();\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    // pick the snapshot that's staged but not committed\n     TableMetadata base = readMetadata();\n-    Snapshot wapSnapshot = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit to let cherry-pick take effect\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    // `D (B)` cherry-pick commit\n+    table.manageSnapshots()\n+        .cherrypick(snapshotB.snapshotId())\n+        .commit();\n+\n+    base = readMetadata();\n+    Snapshot snapshotD = base.snapshots().get(3);\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire `B` commit.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireSnapshotId(snapshotB.snapshotId())\n+        .commit();\n+\n+    // Make sure no dataFiles are deleted for the staged snapshot\n+    Lists.newArrayList(snapshotB).forEach(i -> {\n+      i.addedFiles().forEach(item -> {\n+        Assert.assertFalse(deletedFiles.contains(item.path().toString()));\n+      });\n+    });\n \n-    //Expire dangling wap snapshot.\n-    table.expireSnapshots().expireOlderThan(wapSnapshot.timestampMillis() + 1).commit();\n+    // Expire all snapshots including cherry-pick\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(table.currentSnapshot().timestampMillis() + 1)\n+        .commit();\n \n-    wapSnapshot.addedFiles().forEach(item -> {\n-      Assert.assertTrue(table.getDeletedDataFiles().contains(item.path().toString()));\n+    // Make sure no dataFiles are deleted for the staged and cherry-pick\n+    Lists.newArrayList(snapshotB, snapshotD).forEach(i -> {\n+      i.addedFiles().forEach(item -> {\n+        Assert.assertFalse(deletedFiles.contains(item.path().toString()));\n+      });\n     });\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMTE3MQ==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382711171", "bodyText": "Continuing indentation should be 4 spaces from the start of the previous line, not 8.", "author": "rdblue", "createdAt": "2020-02-21T17:31:18Z", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +393,55 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+  @Test\n+  public void testWithExpiringWapThenCherrypick() {\n+    // first WAP commit\n+    table.newAppend()\n+            .appendFile(FILE_B)", "originalCommit": "7b69fdca2d4b97196b933c5677e6b11c0f93a2d8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\nindex e5eafd9f7..3ab8707d0 100644\n--- a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n+++ b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n\n@@ -393,55 +388,163 @@ public class TestRemoveSnapshots extends TableTestBase {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n   @Test\n-  public void testWithExpiringWapThenCherrypick() {\n-    // first WAP commit\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n     table.newAppend()\n-            .appendFile(FILE_B)\n-            .stageOnly()\n-            .commit();\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n \n     TableMetadata base = readMetadata();\n-    // pick the snapshot that's staged but not committed\n-    Snapshot wap1Snapshot = base.snapshots().get(0);\n-    Assert.assertNotNull(wap1Snapshot);\n-    // new commit on table so that cherrypick can come into affect.\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n     table.newAppend()\n-            .appendFile(FILE_C)\n-            .commit();\n+        .appendFile(FILE_C)\n+        .commit();\n \n-    table.manageSnapshots().cherrypick(wap1Snapshot.snapshotId()).commit();\n+    List<String> deletedFiles = new ArrayList<>();\n \n-    //Expire wap commit.\n-    table.expireSnapshots().expireOlderThan(table.currentSnapshot().timestampMillis() + 1).commit();\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n \n-    //Expire all snapshots including cherrypick\n-    table.expireSnapshots().expireOlderThan(table.currentSnapshot().timestampMillis() + 1).commit();\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {\n+      Assert.assertTrue(deletedFiles.contains(item.path().toString()));\n+    });\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B\n+   *   `- C (B) <--this commit\n+   */\n+  @Test\n+  public void testWithCherryPickTableSnapshot() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+    // pick the snapshot 'B`\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // Move the table back to `A`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotA.snapshotId())\n+        .commit();\n+\n+    // Generate A -> `C (B)`\n+    table.manageSnapshots()\n+        .cherrypick(snapshotB.snapshotId())\n+        .commit();\n+    Snapshot snapshotC = readMetadata().currentSnapshot();\n+\n+    // Move the table back to `B`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotB.snapshotId())\n+        .commit();\n+    List<String> deletedFiles = new ArrayList<>();\n \n-    //Make sure no files are deleted for the wap and cherrypick\n-    Lists.newArrayList(wap1Snapshot).forEach(i -> {\n+    // Expire `C`\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireSnapshotId(snapshotC.snapshotId())\n+        .commit();\n+\n+    // Make sure no dataFiles are deleted for the B and C snapshot\n+    Lists.newArrayList(snapshotB, snapshotC).forEach(i -> {\n       i.addedFiles().forEach(item -> {\n-        Assert.assertFalse(table.getDeletedDataFiles().contains(item.path().toString()));\n+        Assert.assertFalse(deletedFiles.contains(item.path().toString()));\n       });\n     });\n   }\n \n+  /**\n+   * Test on table below, and expiring\n+   *  1) Expire `B`\n+   *  2) All commit\n+   * Table: A - C - D (B)\n+   *          ` B (staged)\n+   */\n   @Test\n-  public void testWithExpiringDanglingWap() {\n-    // WAP commit\n+  public void testWithExpiringStagedThenCherrypick() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n     table.newAppend()\n-            .appendFile(FILE_D)\n-            .stageOnly()\n-            .commit();\n-    table.refresh();\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    // pick the snapshot that's staged but not committed\n     TableMetadata base = readMetadata();\n-    Snapshot wapSnapshot = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit to let cherry-pick take effect\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    // `D (B)` cherry-pick commit\n+    table.manageSnapshots()\n+        .cherrypick(snapshotB.snapshotId())\n+        .commit();\n+\n+    base = readMetadata();\n+    Snapshot snapshotD = base.snapshots().get(3);\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire `B` commit.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireSnapshotId(snapshotB.snapshotId())\n+        .commit();\n+\n+    // Make sure no dataFiles are deleted for the staged snapshot\n+    Lists.newArrayList(snapshotB).forEach(i -> {\n+      i.addedFiles().forEach(item -> {\n+        Assert.assertFalse(deletedFiles.contains(item.path().toString()));\n+      });\n+    });\n \n-    //Expire dangling wap snapshot.\n-    table.expireSnapshots().expireOlderThan(wapSnapshot.timestampMillis() + 1).commit();\n+    // Expire all snapshots including cherry-pick\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(table.currentSnapshot().timestampMillis() + 1)\n+        .commit();\n \n-    wapSnapshot.addedFiles().forEach(item -> {\n-      Assert.assertTrue(table.getDeletedDataFiles().contains(item.path().toString()));\n+    // Make sure no dataFiles are deleted for the staged and cherry-pick\n+    Lists.newArrayList(snapshotB, snapshotD).forEach(i -> {\n+      i.addedFiles().forEach(item -> {\n+        Assert.assertFalse(deletedFiles.contains(item.path().toString()));\n+      });\n     });\n   }\n }\n"}}, {"oid": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b", "url": "https://github.com/apache/iceberg/commit/8be7fcf76ecd1546f699e2d5b4f4562452f08c5b", "message": "Issue-744: Support for ExpireSnapshot functionality on top of cherrypick\n\nUTs", "committedDate": "2020-02-21T21:51:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyNDQxOA==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r382824418", "bodyText": "Having D (cherry pick of B) isn't possible, if B is already an ancestor, encountered this while writing UTs.", "author": "mehtaashish23", "createdAt": "2020-02-21T21:55:57Z", "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -208,12 +226,40 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n       }\n     }\n \n+    // find manifests to clean up that were only referenced by snapshots that have expired\n     Set<String> manifestListsToDelete = Sets.newHashSet();\n     Set<String> manifestsToDelete = Sets.newHashSet();\n     Set<ManifestFile> manifestsToRevert = Sets.newHashSet();\n     for (Snapshot snapshot : base.snapshots()) {\n       long snapshotId = snapshot.snapshotId();\n       if (!validIds.contains(snapshotId)) {\n+        // determine whether the changes in this snapshot are in the current table state\n+        if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n+          // this snapshot was cherry-picked into the current table state, so skip cleaning it up. its changes will\n+          // expire when the picked snapshot expires.\n+          // A -- C (source=B)\n+          //  `- B <-- this commit\n+          continue;\n+        }\n+\n+        long sourceSnapshotId = PropertyUtil.propertyAsLong(\n+            snapshot.summary(), SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP, -1);\n+        if (ancestorIds.contains(sourceSnapshotId)) {\n+          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n+          // changes because it would revert data file additions that are in the current table.\n+          // A -- B\n+          //  `- C (source=B) <-- this commit\n+          continue;\n+        }\n+\n+        if (pickedAncestorSnapshotIds.contains(sourceSnapshotId)) {\n+          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n+          // changes because it would revert data file additions that are in the current table.\n+          // A -- C -- E (source=B)\n+          //  `- B `- D (source=B) <-- this commit", "originalCommit": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY3ODc1NQ==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386678755", "bodyText": "The case that would cause this is:\n\nA is committed\nB is staged\nC is committed\nB is picked to create D\nThe table is rolled back to C\nB is picked to create E\n\nThe main thing is the rollback, which can cause alternate branches with the same commit picked. I would expect in practice to have other commits (like one between C and D that is removed by the rollback) but we don't need those to test this case.", "author": "rdblue", "createdAt": "2020-03-02T22:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyNDQxOA=="}], "type": "inlineReview", "revised_code": {"commit": "289c824d783c7622b9556c2fcfed5663e6237a5d", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java b/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\nindex 222fd1f25..f806c82b6 100644\n--- a/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\n+++ b/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\n\n@@ -237,7 +237,7 @@ class RemoveSnapshots implements ExpireSnapshots {\n         if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n           // this snapshot was cherry-picked into the current table state, so skip cleaning it up. its changes will\n           // expire when the picked snapshot expires.\n-          // A -- C (source=B)\n+          // A -- C -- D (source=B)\n           //  `- B <-- this commit\n           continue;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY3OTgzOQ==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386679839", "bodyText": "The label \"this commit\" makes sense in context for RemoveSnapshots because it is iterating through snapshots/commits. It makes less sense here. Instead, I would use \"current\" and note which commits are expiring (e.g., \"expiring A and B\").", "author": "rdblue", "createdAt": "2020-03-02T22:06:54Z", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {\n+      Assert.assertTrue(deletedFiles.contains(item.path().toString()));\n+    });\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B\n+   *   `- C (B) <--this commit", "originalCommit": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4MTk0OQ==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386681949", "bodyText": "I think it would also be easier to understand if this explicitly labeled the source with (source=B) instead of just (B).", "author": "rdblue", "createdAt": "2020-03-02T22:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY3OTgzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "289c824d783c7622b9556c2fcfed5663e6237a5d", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\nindex 3ab8707d0..ed6b2509a 100644\n--- a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n+++ b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n\n@@ -408,6 +409,7 @@ public class TestRemoveSnapshots extends TableTestBase {\n         .commit();\n \n     TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n     Snapshot snapshotB = base.snapshots().get(1);\n \n     // `C` commit\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4MDM2OQ==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386680369", "bodyText": "Can you change this to an overwrite and also delete FILE_A? We should also test that deleted files are not physically deleted.", "author": "rdblue", "createdAt": "2020-03-02T22:08:07Z", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()", "originalCommit": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "289c824d783c7622b9556c2fcfed5663e6237a5d", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\nindex 3ab8707d0..ed6b2509a 100644\n--- a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n+++ b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n\n@@ -408,6 +409,7 @@ public class TestRemoveSnapshots extends TableTestBase {\n         .commit();\n \n     TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n     Snapshot snapshotB = base.snapshots().get(1);\n \n     // `C` commit\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4MTM4Ng==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386681386", "bodyText": "I think it would be more clear to use a Set<String> and validate using assertEquals. That way it verifies no additional files were deleted.\nSet<String> expectedDeletes = snapshotB.addedFiles().stream()\n    .map(added -> added.path().toString())\n    .collect(Collectors.toSet());\nAssert.assertEquals(\"Should delete only files added in snapshot B\", expectedDeletes, deletedFiles);", "author": "rdblue", "createdAt": "2020-03-02T22:10:14Z", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {", "originalCommit": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxMTAwMg==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r389311002", "bodyText": "+1, it would be good to add exact files, after considering following.\n\nApart from dataFile, we do delete manifests as well for dangling snapshots\nThe order in which the files are deleted, shouldn't matter, so I have handling that as well.\n\nI think, we should have couple of test to check manifest deletes in case of normal remove snapshots API. Let me know, I can log a ticket explicitly for that, if you agree.", "author": "mehtaashish23", "createdAt": "2020-03-07T20:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4MTM4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "289c824d783c7622b9556c2fcfed5663e6237a5d", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\nindex 3ab8707d0..ed6b2509a 100644\n--- a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n+++ b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n\n@@ -408,6 +409,7 @@ public class TestRemoveSnapshots extends TableTestBase {\n         .commit();\n \n     TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n     Snapshot snapshotB = base.snapshots().get(1);\n \n     // `C` commit\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4MzM2Nw==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386683367", "bodyText": "Nit: should have a newline before this comment.", "author": "rdblue", "createdAt": "2020-03-02T22:14:25Z", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {\n+      Assert.assertTrue(deletedFiles.contains(item.path().toString()));\n+    });\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B\n+   *   `- C (B) <--this commit\n+   */\n+  @Test\n+  public void testWithCherryPickTableSnapshot() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+    // pick the snapshot 'B`", "originalCommit": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "289c824d783c7622b9556c2fcfed5663e6237a5d", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\nindex 3ab8707d0..ed6b2509a 100644\n--- a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n+++ b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n\n@@ -408,6 +409,7 @@ public class TestRemoveSnapshots extends TableTestBase {\n         .commit();\n \n     TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n     Snapshot snapshotB = base.snapshots().get(1);\n \n     // `C` commit\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4NDU1NA==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386684554", "bodyText": "You can simplify this and avoid using expireSnapshotId by using expireOlderThan a future time (like you do in the next test). Snapshot B won't expire because it is the current snapshot.", "author": "rdblue", "createdAt": "2020-03-02T22:17:06Z", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {\n+      Assert.assertTrue(deletedFiles.contains(item.path().toString()));\n+    });\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B\n+   *   `- C (B) <--this commit\n+   */\n+  @Test\n+  public void testWithCherryPickTableSnapshot() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+    // pick the snapshot 'B`\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // Move the table back to `A`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotA.snapshotId())\n+        .commit();\n+\n+    // Generate A -> `C (B)`\n+    table.manageSnapshots()\n+        .cherrypick(snapshotB.snapshotId())\n+        .commit();\n+    Snapshot snapshotC = readMetadata().currentSnapshot();\n+\n+    // Move the table back to `B`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotB.snapshotId())\n+        .commit();\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire `C`\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireSnapshotId(snapshotC.snapshotId())", "originalCommit": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "289c824d783c7622b9556c2fcfed5663e6237a5d", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\nindex 3ab8707d0..ed6b2509a 100644\n--- a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n+++ b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n\n@@ -408,6 +409,7 @@ public class TestRemoveSnapshots extends TableTestBase {\n         .commit();\n \n     TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n     Snapshot snapshotB = base.snapshots().get(1);\n \n     // `C` commit\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4NjI0MQ==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r386686241", "bodyText": "It wasn't clear at first why this was needed, but it is to avoid using a fast-forward commit instead of a cherry-pick. Can you update the comment in RemoveSnapshots since the case there isn't possible?", "author": "rdblue", "createdAt": "2020-03-02T22:20:40Z", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +388,163 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(item -> {\n+      Assert.assertTrue(deletedFiles.contains(item.path().toString()));\n+    });\n+  }\n+\n+  /**\n+   * Expire cherry-pick the commit as shown below, when `B` is in table's current state\n+   *  Table:\n+   *  A - B\n+   *   `- C (B) <--this commit\n+   */\n+  @Test\n+  public void testWithCherryPickTableSnapshot() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .commit();\n+    // pick the snapshot 'B`\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // Move the table back to `A`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotA.snapshotId())\n+        .commit();\n+\n+    // Generate A -> `C (B)`\n+    table.manageSnapshots()\n+        .cherrypick(snapshotB.snapshotId())\n+        .commit();\n+    Snapshot snapshotC = readMetadata().currentSnapshot();\n+\n+    // Move the table back to `B`\n+    table.manageSnapshots()\n+        .setCurrentSnapshot(snapshotB.snapshotId())\n+        .commit();\n+    List<String> deletedFiles = new ArrayList<>();\n+\n+    // Expire `C`\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireSnapshotId(snapshotC.snapshotId())\n+        .commit();\n+\n+    // Make sure no dataFiles are deleted for the B and C snapshot\n+    Lists.newArrayList(snapshotB, snapshotC).forEach(i -> {\n+      i.addedFiles().forEach(item -> {\n+        Assert.assertFalse(deletedFiles.contains(item.path().toString()));\n+      });\n+    });\n+  }\n+\n+  /**\n+   * Test on table below, and expiring\n+   *  1) Expire `B`\n+   *  2) All commit\n+   * Table: A - C - D (B)\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringStagedThenCherrypick() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    // pick the snapshot that's staged but not committed\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit to let cherry-pick take effect", "originalCommit": "8be7fcf76ecd1546f699e2d5b4f4562452f08c5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjQ1Mg==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r389316452", "bodyText": "Yeah, I have also changed another UT, which was not taking care of fast forward.", "author": "mehtaashish23", "createdAt": "2020-03-07T22:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4NjI0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "289c824d783c7622b9556c2fcfed5663e6237a5d", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\nindex 3ab8707d0..ed6b2509a 100644\n--- a/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n+++ b/core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java\n\n@@ -408,6 +409,7 @@ public class TestRemoveSnapshots extends TableTestBase {\n         .commit();\n \n     TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n     Snapshot snapshotB = base.snapshots().get(1);\n \n     // `C` commit\n"}}, {"oid": "289c824d783c7622b9556c2fcfed5663e6237a5d", "url": "https://github.com/apache/iceberg/commit/289c824d783c7622b9556c2fcfed5663e6237a5d", "message": "Issue-744: Support for ExpireSnapshot functionality on top of cherrypick\n\nUTs", "committedDate": "2020-03-07T22:19:33Z", "type": "forcePushed"}, {"oid": "624f9365de251df29879480d0f6df92fc482bc39", "url": "https://github.com/apache/iceberg/commit/624f9365de251df29879480d0f6df92fc482bc39", "message": "Issue-744: Support for ExpireSnapshot functionality on top of cherrypick\n\nUTs", "committedDate": "2020-03-09T01:50:58Z", "type": "forcePushed"}, {"oid": "473c1592e167cd7235315047801ddbb71e6a773e", "url": "https://github.com/apache/iceberg/commit/473c1592e167cd7235315047801ddbb71e6a773e", "message": "Update RemoveSnapshots to protect cherry-picked data.", "committedDate": "2020-03-09T02:14:43Z", "type": "commit"}, {"oid": "6a3b3db2728f32dad6db5ef8f9c701a1f7793af7", "url": "https://github.com/apache/iceberg/commit/6a3b3db2728f32dad6db5ef8f9c701a1f7793af7", "message": "Issue-744: Support for ExpireSnapshot functionality on top of cherrypick\n\nUTs", "committedDate": "2020-03-09T02:18:10Z", "type": "commit"}, {"oid": "6a3b3db2728f32dad6db5ef8f9c701a1f7793af7", "url": "https://github.com/apache/iceberg/commit/6a3b3db2728f32dad6db5ef8f9c701a1f7793af7", "message": "Issue-744: Support for ExpireSnapshot functionality on top of cherrypick\n\nUTs", "committedDate": "2020-03-09T02:18:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTAzNw==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r390011037", "bodyText": "Why does this remove files from the set instead of using assertEqual?", "author": "rdblue", "createdAt": "2020-03-09T23:12:31Z", "path": "core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java", "diffHunk": "@@ -387,4 +389,190 @@ public void dataFilesCleanup() throws IOException {\n     Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n     Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n   }\n+\n+  /**\n+   * Test on table below, and expiring the staged commit `B` using `expireOlderThan` API.\n+   * Table: A - C\n+   *          ` B (staged)\n+   */\n+  @Test\n+  public void testWithExpiringDanglingStageCommit() {\n+    // `A` commit\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // `B` staged commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    TableMetadata base = readMetadata();\n+    Snapshot snapshotA = base.snapshots().get(0);\n+    Snapshot snapshotB = base.snapshots().get(1);\n+\n+    // `C` commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    Set<String> deletedFiles = new HashSet<>();\n+\n+    // Expire all commits including dangling staged snapshot.\n+    table.expireSnapshots()\n+        .deleteWith(deletedFiles::add)\n+        .expireOlderThan(snapshotB.timestampMillis() + 1)\n+        .commit();\n+\n+    Set<String> expectedDeletes = new HashSet<>();\n+    expectedDeletes.add(snapshotA.manifestListLocation());\n+\n+    // Files should be deleted of dangling staged snapshot\n+    snapshotB.addedFiles().forEach(i -> {\n+      expectedDeletes.add(i.path().toString());\n+    });\n+\n+    // ManifestList should be deleted too\n+    expectedDeletes.add(snapshotB.manifestListLocation());\n+    snapshotB.manifests().forEach(file -> {\n+      //Only the manifest of B should be deleted.\n+      if (file.snapshotId() == snapshotB.snapshotId()) {\n+        expectedDeletes.add(file.path());\n+      }\n+    });\n+    Assert.assertSame(\"Files deleted count should be expected\", expectedDeletes.size(), deletedFiles.size());\n+    //Take the diff\n+    expectedDeletes.removeAll(deletedFiles);", "originalCommit": "6a3b3db2728f32dad6db5ef8f9c701a1f7793af7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0Mjk2Ng==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r390042966", "bodyText": "The order was coming to be different, and I didn't wanted to rely on order.", "author": "mehtaashish23", "createdAt": "2020-03-10T01:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTAzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ3NzY1Mw==", "url": "https://github.com/apache/iceberg/pull/814#discussion_r390477653", "bodyText": "Comparing two sets would not rely on order.", "author": "rdblue", "createdAt": "2020-03-10T17:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTAzNw=="}], "type": "inlineReview", "revised_code": null}]}