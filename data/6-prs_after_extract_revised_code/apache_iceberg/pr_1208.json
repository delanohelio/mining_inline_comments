{"pr_number": 1208, "pr_title": "ORC: Add name mapping support", "pr_createdAt": "2020-07-15T17:31:41Z", "pr_url": "https://github.com/apache/iceberg/pull/1208", "timeline": [{"oid": "106795db2ddfbb0ed82154e219fd5315da66e245", "url": "https://github.com/apache/iceberg/commit/106795db2ddfbb0ed82154e219fd5315da66e245", "message": "Minor changes", "committedDate": "2020-07-15T19:47:01Z", "type": "forcePushed"}, {"oid": "f340ce0f22a22594b543a1d0bfd8a411f2e0ef68", "url": "https://github.com/apache/iceberg/commit/f340ce0f22a22594b543a1d0bfd8a411f2e0ef68", "message": "ORC: Implement name mapping strategy", "committedDate": "2020-07-22T17:26:38Z", "type": "commit"}, {"oid": "4796b2b1c9bdefc5344966be76f4503e9a263706", "url": "https://github.com/apache/iceberg/commit/4796b2b1c9bdefc5344966be76f4503e9a263706", "message": "Add tests for ORC name mapping", "committedDate": "2020-07-22T17:26:46Z", "type": "commit"}, {"oid": "4e49814bdf457ec357f33014eedb25cb4a1dac7d", "url": "https://github.com/apache/iceberg/commit/4e49814bdf457ec357f33014eedb25cb4a1dac7d", "message": "Reuse field name tracking in OrcSchemaVisitor", "committedDate": "2020-07-22T17:26:47Z", "type": "commit"}, {"oid": "2b365e8b4a88e82705f543f72d04a8f9dc7df4b4", "url": "https://github.com/apache/iceberg/commit/2b365e8b4a88e82705f543f72d04a8f9dc7df4b4", "message": "Minor changes", "committedDate": "2020-07-22T17:26:48Z", "type": "commit"}, {"oid": "2b365e8b4a88e82705f543f72d04a8f9dc7df4b4", "url": "https://github.com/apache/iceberg/commit/2b365e8b4a88e82705f543f72d04a8f9dc7df4b4", "message": "Minor changes", "committedDate": "2020-07-22T17:26:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE5MzA1Nw==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r459193057", "bodyText": "If we are not comparing the attributes here, is there any value to adding this assert? Seems like name mapping's effect (assigning ids) is not actually being tested in this case.", "author": "shardulm94", "createdAt": "2020-07-23T03:11:48Z", "path": "orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java", "diffHunk": "@@ -269,4 +278,68 @@ public void testSkipNonIcebergColumns() {\n     );\n     assertEquals(\"Schemas must match.\", expectedSchema2.asStruct(), icebergSchema2.asStruct());\n   }\n+\n+  @Test\n+  public void testHasIds() {\n+    Schema schema = new Schema(\n+        optional(1, \"data\", Types.StructType.of(\n+            optional(10, \"entries\", Types.MapType.ofOptional(11, 12, Types.StringType.get(), Types.DateType.get()))\n+        )),\n+        optional(2, \"intCol\", Types.IntegerType.get()),\n+        optional(3, \"longCol\", Types.LongType.get()),\n+        optional(4, \"listCol\", Types.ListType.ofOptional(40, Types.DoubleType.get()))\n+    );\n+\n+    TypeDescription orcSchema = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(schema));\n+    assertFalse(\"Should not have Ids\", ORCSchemaUtil.hasIds(orcSchema));\n+\n+    TypeDescription map2Col = TypeDescription.createMap(TypeDescription.createString(), TypeDescription.createBinary());\n+    map2Col.setAttribute(ICEBERG_ID_ATTRIBUTE, \"4\");\n+    orcSchema.addField(\"map2Col\", map2Col);\n+    assertTrue(\"Should have Ids after adding one type with Id\", ORCSchemaUtil.hasIds(orcSchema));\n+  }\n+\n+  @Test\n+  public void tetsAssignIdsByNameMapping() {\n+    Types.StructType structType = Types.StructType.of(\n+        required(0, \"id\", Types.LongType.get()),\n+        optional(1, \"list_of_maps\",\n+            Types.ListType.ofOptional(2, Types.MapType.ofOptional(3, 4,\n+                Types.StringType.get(),\n+                SUPPORTED_PRIMITIVES))),\n+        optional(5, \"map_of_lists\",\n+            Types.MapType.ofOptional(6, 7,\n+                Types.StringType.get(),\n+                Types.ListType.ofOptional(8, SUPPORTED_PRIMITIVES))),\n+        required(9, \"list_of_lists\",\n+            Types.ListType.ofOptional(10, Types.ListType.ofOptional(11, SUPPORTED_PRIMITIVES))),\n+        required(12, \"map_of_maps\",\n+            Types.MapType.ofOptional(13, 14,\n+                Types.StringType.get(),\n+                Types.MapType.ofOptional(15, 16,\n+                    Types.StringType.get(),\n+                    SUPPORTED_PRIMITIVES))),\n+        required(17, \"list_of_struct_of_nested_types\", Types.ListType.ofOptional(19, Types.StructType.of(\n+            Types.NestedField.required(20, \"m1\", Types.MapType.ofOptional(21, 22,\n+                Types.StringType.get(),\n+                SUPPORTED_PRIMITIVES)),\n+            Types.NestedField.optional(23, \"l1\", Types.ListType.ofRequired(24, SUPPORTED_PRIMITIVES)),\n+            Types.NestedField.required(25, \"l2\", Types.ListType.ofRequired(26, SUPPORTED_PRIMITIVES)),\n+            Types.NestedField.optional(27, \"m2\", Types.MapType.ofOptional(28, 29,\n+                Types.StringType.get(),\n+                SUPPORTED_PRIMITIVES))\n+        )))\n+    );\n+\n+    Schema schema = new Schema(TypeUtil.assignFreshIds(structType, new AtomicInteger(0)::incrementAndGet)\n+        .asStructType().fields());\n+\n+    NameMapping nameMapping = MappingUtil.create(schema);\n+    TypeDescription typeDescriptionWithIds = ORCSchemaUtil.convert(schema);\n+    TypeDescription typeDescriptionWithIdsFromNameMapping = ORCSchemaUtil\n+        .applyNameMapping(ORCSchemaUtil.removeIds(typeDescriptionWithIds), nameMapping);\n+\n+    assertTrue(\"TypeDescription schemas should be equal, not comparing Attributes\",\n+        typeDescriptionWithIds.equals(typeDescriptionWithIdsFromNameMapping, false /* checkAttributes */));", "originalCommit": "2b365e8b4a88e82705f543f72d04a8f9dc7df4b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwNTQ5NA==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r459805494", "bodyText": "I've added a check for the IDs as well.", "author": "edgarRd", "createdAt": "2020-07-24T00:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE5MzA1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c0c4eb569de8e340803ae01a6e3367e8d1e37145", "chunk": "diff --git a/orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java b/orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java\nindex 1817f6b89..8407f6f17 100644\n--- a/orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java\n+++ b/orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java\n\n@@ -339,7 +342,43 @@ public class TestORCSchemaUtil {\n     TypeDescription typeDescriptionWithIdsFromNameMapping = ORCSchemaUtil\n         .applyNameMapping(ORCSchemaUtil.removeIds(typeDescriptionWithIds), nameMapping);\n \n-    assertTrue(\"TypeDescription schemas should be equal, not comparing Attributes\",\n-        typeDescriptionWithIds.equals(typeDescriptionWithIdsFromNameMapping, false /* checkAttributes */));\n+    assertTrue(\"TypeDescription schemas should be equal, including IDs\",\n+        equalsWithIds(typeDescriptionWithIds, typeDescriptionWithIdsFromNameMapping));\n+  }\n+\n+  private static boolean equalsWithIds(TypeDescription first, TypeDescription second) {\n+    if (second == first) {\n+      return true;\n+    }\n+\n+    if (!first.equals(second, false)) {\n+      return false;\n+    }\n+\n+    // check the ID attribute on non-root TypeDescriptions\n+    if (first.getId() > 0 && second.getId() > 0) {\n+      if (first.getAttributeValue(ICEBERG_ID_ATTRIBUTE) == null ||\n+          second.getAttributeValue(ICEBERG_ID_ATTRIBUTE) == null) {\n+        return false;\n+      }\n+\n+      if (!first.getAttributeValue(ICEBERG_ID_ATTRIBUTE).equals(second.getAttributeValue(ICEBERG_ID_ATTRIBUTE))) {\n+        return false;\n+      }\n+    }\n+\n+    // check the children\n+    List<TypeDescription> firstChildren = Optional.ofNullable(first.getChildren()).orElse(Collections.emptyList());\n+    List<TypeDescription> secondChildren = Optional.ofNullable(second.getChildren()).orElse(Collections.emptyList());\n+    if (firstChildren.size() != secondChildren.size()) {\n+      return false;\n+    }\n+    for (int i = 0; i < firstChildren.size(); ++i) {\n+      if (!equalsWithIds(firstChildren.get(i), secondChildren.get(i))) {\n+        return false;\n+      }\n+    }\n+\n+    return true;\n   }\n }\n"}}, {"oid": "c0c4eb569de8e340803ae01a6e3367e8d1e37145", "url": "https://github.com/apache/iceberg/commit/c0c4eb569de8e340803ae01a6e3367e8d1e37145", "message": "Check mapped IDs in test", "committedDate": "2020-07-24T00:54:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1NjA5NA==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460356094", "bodyText": "Should we also check if the file schema does not have ids before initializing nameMapping?", "author": "rdsr", "createdAt": "2020-07-25T03:02:43Z", "path": "orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java", "diffHunk": "@@ -51,14 +54,16 @@\n   private final boolean caseSensitive;\n   private final Function<TypeDescription, OrcBatchReader<?>> batchReaderFunction;\n   private final int recordsPerBatch;\n+  private final NameMapping nameMapping;\n \n   OrcIterable(InputFile file, Configuration config, Schema schema,\n-              Long start, Long length,\n+              NameMapping nameMapping, Long start, Long length,\n               Function<TypeDescription, OrcRowReader<?>> readerFunction, boolean caseSensitive, Expression filter,\n               Function<TypeDescription, OrcBatchReader<?>> batchReaderFunction, int recordsPerBatch) {\n     this.schema = schema;\n     this.readerFunction = readerFunction;\n     this.file = file;\n+    this.nameMapping = Optional.ofNullable(nameMapping).orElse(MappingUtil.create(schema));", "originalCommit": "c0c4eb569de8e340803ae01a6e3367e8d1e37145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMwNTg2OQ==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461305869", "bodyText": "Done.", "author": "edgarRd", "createdAt": "2020-07-28T04:10:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1NjA5NA=="}], "type": "inlineReview", "revised_code": {"commit": "75fc9fdafee3ed34e99000344b719da3691ff5cb", "chunk": "diff --git a/orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java b/orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java\nindex f50c8ca86..df10d48e5 100644\n--- a/orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java\n+++ b/orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java\n\n@@ -54,7 +54,7 @@ class OrcIterable<T> extends CloseableGroup implements CloseableIterable<T> {\n   private final boolean caseSensitive;\n   private final Function<TypeDescription, OrcBatchReader<?>> batchReaderFunction;\n   private final int recordsPerBatch;\n-  private final NameMapping nameMapping;\n+  private NameMapping nameMapping;\n \n   OrcIterable(InputFile file, Configuration config, Schema schema,\n               NameMapping nameMapping, Long start, Long length,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MDcxNQ==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460360715", "bodyText": "shouldn't a 'type' be pruned if a mappedField is missing or null?", "author": "rdsr", "createdAt": "2020-07-25T03:58:20Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ApplyNameMapping.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.mapping.MappedField;\n+import org.apache.iceberg.mapping.NameMapping;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.orc.TypeDescription;\n+\n+class ApplyNameMapping extends OrcSchemaVisitor<TypeDescription> {\n+  private final NameMapping nameMapping;\n+\n+  ApplyNameMapping(NameMapping nameMapping) {\n+    this.nameMapping = nameMapping;\n+  }\n+\n+  @Override\n+  public String elementName() {\n+    return \"element\";\n+  }\n+\n+  @Override\n+  public String keyName() {\n+    return \"key\";\n+  }\n+\n+  @Override\n+  public String valueName() {\n+    return \"value\";\n+  }\n+\n+  TypeDescription setId(TypeDescription type, MappedField mappedField) {\n+    if (mappedField != null) {", "originalCommit": "c0c4eb569de8e340803ae01a6e3367e8d1e37145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM3NTk2Ng==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460375966", "bodyText": "I think this works as we are using the Iceberg read schema for building the projection.", "author": "rdsr", "createdAt": "2020-07-25T07:15:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MDcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwMTQ4Nw==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461001487", "bodyText": "That logic was implemented in #1140", "author": "edgarRd", "createdAt": "2020-07-27T16:06:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MDcxNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MDkyNQ==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460360925", "bodyText": "Why do we need to call clone here?", "author": "rdsr", "createdAt": "2020-07-25T04:00:44Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ApplyNameMapping.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.mapping.MappedField;\n+import org.apache.iceberg.mapping.NameMapping;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.orc.TypeDescription;\n+\n+class ApplyNameMapping extends OrcSchemaVisitor<TypeDescription> {\n+  private final NameMapping nameMapping;\n+\n+  ApplyNameMapping(NameMapping nameMapping) {\n+    this.nameMapping = nameMapping;\n+  }\n+\n+  @Override\n+  public String elementName() {\n+    return \"element\";\n+  }\n+\n+  @Override\n+  public String keyName() {\n+    return \"key\";\n+  }\n+\n+  @Override\n+  public String valueName() {\n+    return \"value\";\n+  }\n+\n+  TypeDescription setId(TypeDescription type, MappedField mappedField) {\n+    if (mappedField != null) {\n+      type.setAttribute(ORCSchemaUtil.ICEBERG_ID_ATTRIBUTE, mappedField.id().toString());\n+    }\n+    return type;\n+  }\n+\n+  @Override\n+  public TypeDescription record(TypeDescription record, List<String> names, List<TypeDescription> fields) {\n+    Preconditions.checkArgument(names.size() == fields.size(), \"All fields must have names\");\n+    MappedField field = nameMapping.find(currentPath());\n+    TypeDescription structType = TypeDescription.createStruct();\n+\n+    for (int i = 0; i < fields.size(); i++) {\n+      String fieldName = names.get(i);\n+      TypeDescription fieldType = fields.get(i);\n+      if (fieldType != null) {\n+        structType.addField(fieldName, fieldType);\n+      }\n+    }\n+    return setId(structType, field);\n+  }\n+\n+  @Override\n+  public TypeDescription list(TypeDescription array, TypeDescription element) {\n+    Preconditions.checkArgument(element != null, \"List type must have element type\");\n+\n+    MappedField field = nameMapping.find(currentPath());\n+    TypeDescription listType = TypeDescription.createList(element);\n+    return setId(listType, field);\n+  }\n+\n+  @Override\n+  public TypeDescription map(TypeDescription map, TypeDescription key, TypeDescription value) {\n+    Preconditions.checkArgument(key != null && value != null, \"Map type must have both key and value types\");\n+\n+    MappedField field = nameMapping.find(currentPath());\n+    TypeDescription mapType = TypeDescription.createMap(key, value);\n+    return setId(mapType, field);\n+  }\n+\n+  @Override\n+  public TypeDescription primitive(TypeDescription primitive) {\n+    MappedField field = nameMapping.find(currentPath());\n+    return setId(primitive.clone(), field);", "originalCommit": "c0c4eb569de8e340803ae01a6e3367e8d1e37145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwMjcwNw==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461002707", "bodyText": "The ApplyNameMapping returns new TypeDescription objects when mapped instead of the same references as input. For consistency, on primitives we clone the object to create a new one. This is consistent with the other format implementations of ApplyNameMapping creating a new tree as output.", "author": "edgarRd", "createdAt": "2020-07-27T16:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MDkyNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MTEyNg==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460361126", "bodyText": "Why underscores?", "author": "rdsr", "createdAt": "2020-07-25T04:03:45Z", "path": "orc/src/main/java/org/apache/iceberg/orc/OrcSchemaVisitor.java", "diffHunk": "@@ -83,9 +112,53 @@\n     return visitor.record(record, names, visitFields(fields, names, visitor));\n   }\n \n-  public void beforeField(String name, TypeDescription type) {}\n+  public String elementName() {\n+    return \"_elem\";", "originalCommit": "c0c4eb569de8e340803ae01a6e3367e8d1e37145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwNTE5Mw==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461005193", "bodyText": "These are the ORC names for list elements. Same for Map as _key and _value.", "author": "edgarRd", "createdAt": "2020-07-27T16:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MTEyNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MTU0MQ==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460361541", "bodyText": "Why don't we only remove the ID attribute?", "author": "rdsr", "createdAt": "2020-07-25T04:08:27Z", "path": "orc/src/main/java/org/apache/iceberg/orc/RemoveIds.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.orc.TypeDescription;\n+\n+class RemoveIds extends OrcSchemaVisitor<TypeDescription> {\n+\n+  @Override\n+  public TypeDescription record(TypeDescription record, List<String> names, List<TypeDescription> fields) {\n+    Preconditions.checkArgument(names.size() == fields.size(), \"All fields must have names.\");\n+    TypeDescription struct = TypeDescription.createStruct();\n+\n+    for (int i = 0; i < fields.size(); i++) {\n+      struct.addField(names.get(i), fields.get(i));\n+    }\n+    return struct;\n+  }\n+\n+  @Override\n+  public TypeDescription list(TypeDescription array, TypeDescription element) {\n+    return TypeDescription.createList(element);\n+  }\n+\n+  @Override\n+  public TypeDescription map(TypeDescription map, TypeDescription key, TypeDescription value) {\n+    return TypeDescription.createMap(key, value);\n+  }\n+\n+  @Override\n+  public TypeDescription primitive(TypeDescription primitive) {\n+    return removeIcebergAttributes(primitive.clone());\n+  }\n+\n+  private static TypeDescription removeIcebergAttributes(TypeDescription orcType) {\n+    orcType.removeAttribute(ORCSchemaUtil.ICEBERG_ID_ATTRIBUTE);", "originalCommit": "c0c4eb569de8e340803ae01a6e3367e8d1e37145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwNjc0Nw==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461006747", "bodyText": "We could, for completeness I removed the other Iceberg attributes but definitely not needed.", "author": "edgarRd", "createdAt": "2020-07-27T16:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MTU0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "b74abd8cdb25a94c3033404b324e95575216b493", "chunk": "diff --git a/orc/src/main/java/org/apache/iceberg/orc/RemoveIds.java b/orc/src/main/java/org/apache/iceberg/orc/RemoveIds.java\nindex 22d377107..bfa56deb5 100644\n--- a/orc/src/main/java/org/apache/iceberg/orc/RemoveIds.java\n+++ b/orc/src/main/java/org/apache/iceberg/orc/RemoveIds.java\n\n@@ -53,10 +53,6 @@ class RemoveIds extends OrcSchemaVisitor<TypeDescription> {\n \n   private static TypeDescription removeIcebergAttributes(TypeDescription orcType) {\n     orcType.removeAttribute(ORCSchemaUtil.ICEBERG_ID_ATTRIBUTE);\n-    orcType.removeAttribute(ORCSchemaUtil.ICEBERG_REQUIRED_ATTRIBUTE);\n-    orcType.removeAttribute(ORCSchemaUtil.ICEBERG_BINARY_TYPE_ATTRIBUTE);\n-    orcType.removeAttribute(ORCSchemaUtil.ICEBERG_LONG_TYPE_ATTRIBUTE);\n-    orcType.removeAttribute(ORCSchemaUtil.ICEBERG_FIELD_LENGTH);\n     return orcType;\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MjUwMg==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460362502", "bodyText": "IIRC, nameMapping may not have all the fields which maybe present in the file schema. I think we need a way to prune columns which does not have an associated mapping defined. I can't say whether buildOrcProjection is handling that case or not.", "author": "rdsr", "createdAt": "2020-07-25T04:19:00Z", "path": "orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java", "diffHunk": "@@ -73,7 +78,15 @@\n   public CloseableIterator<T> iterator() {\n     Reader orcFileReader = ORC.newFileReader(file, config);\n     addCloseable(orcFileReader);\n-    TypeDescription readOrcSchema = ORCSchemaUtil.buildOrcProjection(schema, orcFileReader.getSchema());\n+\n+    TypeDescription fileSchema = orcFileReader.getSchema();\n+    final TypeDescription readOrcSchema;\n+    if (ORCSchemaUtil.hasIds(fileSchema)) {\n+      readOrcSchema = ORCSchemaUtil.buildOrcProjection(schema, fileSchema);\n+    } else {\n+      TypeDescription typeWithIds = ORCSchemaUtil.applyNameMapping(fileSchema, nameMapping);", "originalCommit": "c0c4eb569de8e340803ae01a6e3367e8d1e37145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM3NjEyNA==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460376124", "bodyText": "Seems like buildOrcProjection is handling it by traversing iceberg read schema to build the read projection", "author": "rdsr", "createdAt": "2020-07-25T07:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwMTE1MA==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461001150", "bodyText": "Yes, buildOrcProjection has the logic to skip columns without IDs, that was implemented in #1140.", "author": "edgarRd", "createdAt": "2020-07-27T16:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2MjUwMg=="}], "type": "inlineReview", "revised_code": {"commit": "75fc9fdafee3ed34e99000344b719da3691ff5cb", "chunk": "diff --git a/orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java b/orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java\nindex f50c8ca86..df10d48e5 100644\n--- a/orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java\n+++ b/orc/src/main/java/org/apache/iceberg/orc/OrcIterable.java\n\n@@ -84,6 +84,9 @@ class OrcIterable<T> extends CloseableGroup implements CloseableIterable<T> {\n     if (ORCSchemaUtil.hasIds(fileSchema)) {\n       readOrcSchema = ORCSchemaUtil.buildOrcProjection(schema, fileSchema);\n     } else {\n+      if (nameMapping == null) {\n+        nameMapping = MappingUtil.create(schema);\n+      }\n       TypeDescription typeWithIds = ORCSchemaUtil.applyNameMapping(fileSchema, nameMapping);\n       readOrcSchema = ORCSchemaUtil.buildOrcProjection(schema, typeWithIds);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2NDY5Mg==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r460364692", "bodyText": "can we have a test case for where complex fields are also pruned? For instance if all fields of a struct are pruned, the struct is pruned. Similarly for maps and lists?", "author": "rdsr", "createdAt": "2020-07-25T04:46:59Z", "path": "orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java", "diffHunk": "@@ -262,4 +264,65 @@ public void testEvolvedSchema() {\n     actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n     Assert.assertEquals(expected.toString(), actual.toString());\n   }\n+\n+  @Test\n+  public void testOriginalSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(2, \"long\", Types.LongType.get())\n+    );\n+\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(originalSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(originalSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = and(equal(\"int\", 1), equal(\"long\", 1));\n+    Expression boundFilter = Binder.bind(originalSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`int`\", Type.LONG, 1L)\n+        .equals(\"`long`\", Type.LONG, 1L)\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testModifiedSchemaNameMapping() {", "originalCommit": "c0c4eb569de8e340803ae01a6e3367e8d1e37145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwODk1MQ==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461008951", "bodyText": "I think that test is https://github.com/apache/iceberg/pull/1140/files#diff-27a14477d32c8e2921027e1353a76753R216 and does not seem related to test the name mapping as that'd test buldOrcProjection. I can definitely add those cases you mention on that test.", "author": "edgarRd", "createdAt": "2020-07-27T16:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2NDY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMwNTgxNw==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r461305817", "bodyText": "I've added a couple tests to address this.", "author": "edgarRd", "createdAt": "2020-07-28T04:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM2NDY5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ff01d48b9db2237b8f5822ee33a56a3f76a689a5", "chunk": "diff --git a/orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java b/orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java\nindex 9f9039f35..bc63a26f1 100644\n--- a/orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java\n+++ b/orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java\n\n@@ -290,7 +290,7 @@ public class TestExpressionToSearchArgument {\n   }\n \n   @Test\n-  public void testModifiedSchemaNameMapping() {\n+  public void testModifiedSimpleSchemaNameMapping() {\n     Schema originalSchema = new Schema(\n         required(1, \"int\", Types.IntegerType.get()),\n         optional(2, \"long_to_be_dropped\", Types.LongType.get())\n"}}, {"oid": "75fc9fdafee3ed34e99000344b719da3691ff5cb", "url": "https://github.com/apache/iceberg/commit/75fc9fdafee3ed34e99000344b719da3691ff5cb", "message": "Compute name mapping if no ids are found", "committedDate": "2020-07-27T23:24:38Z", "type": "commit"}, {"oid": "ff01d48b9db2237b8f5822ee33a56a3f76a689a5", "url": "https://github.com/apache/iceberg/commit/ff01d48b9db2237b8f5822ee33a56a3f76a689a5", "message": "Add more tests\n\n- Projection on complex types: maps, lists, structs", "committedDate": "2020-07-28T03:45:13Z", "type": "commit"}, {"oid": "b74abd8cdb25a94c3033404b324e95575216b493", "url": "https://github.com/apache/iceberg/commit/b74abd8cdb25a94c3033404b324e95575216b493", "message": "Remove Ids only", "committedDate": "2020-07-28T03:47:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY3MzMwMQ==", "url": "https://github.com/apache/iceberg/pull/1208#discussion_r467673301", "bodyText": "Nit: Typo struct.long", "author": "shardulm94", "createdAt": "2020-08-10T03:29:26Z", "path": "orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java", "diffHunk": "@@ -262,4 +264,132 @@ public void testEvolvedSchema() {\n     actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n     Assert.assertEquals(expected.toString(), actual.toString());\n   }\n+\n+  @Test\n+  public void testOriginalSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(2, \"long\", Types.LongType.get())\n+    );\n+\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(originalSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(originalSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = and(equal(\"int\", 1), equal(\"long\", 1));\n+    Expression boundFilter = Binder.bind(originalSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`int`\", Type.LONG, 1L)\n+        .equals(\"`long`\", Type.LONG, 1L)\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testModifiedSimpleSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(2, \"long_to_be_dropped\", Types.LongType.get())\n+    );\n+    Schema mappingSchema = new Schema(\n+        required(1, \"int\", Types.IntegerType.get()),\n+        optional(3, \"new_float_field\", Types.FloatType.get())\n+    );\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(mappingSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(mappingSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = equal(\"int\", 1);\n+    Expression boundFilter = Binder.bind(mappingSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`int`\", Type.LONG, 1L)\n+        .build();\n+\n+    SearchArgument actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+\n+    // for columns not in the file, buildOrcProjection will append field names with _r<ID>\n+    // this will be passed down to ORC, but ORC will handle such cases and return a TruthValue during evaluation\n+    expr = equal(\"new_float_field\", 1);\n+    boundFilter = Binder.bind(mappingSchema.asStruct(), expr, true);\n+    expected = SearchArgumentFactory.newBuilder()\n+        .equals(\"`new_float_field_r3`\", Type.FLOAT, 1.0)\n+        .build();\n+\n+    actual = ExpressionToSearchArgument.convert(boundFilter, readSchema);\n+    Assert.assertEquals(expected.toString(), actual.toString());\n+  }\n+\n+  @Test\n+  public void testModifiedComplexSchemaNameMapping() {\n+    Schema originalSchema = new Schema(\n+        optional(1, \"struct\", Types.StructType.of(\n+            required(2, \"long\", Types.LongType.get())\n+        )),\n+        optional(3, \"list\", Types.ListType.ofRequired(4, Types.LongType.get())),\n+        optional(5, \"map\", Types.MapType.ofRequired(6, 7, Types.LongType.get(), Types.LongType.get())),\n+        optional(8, \"listOfStruct\", Types.ListType.ofRequired(9, Types.StructType.of(\n+            required(10, \"long\", Types.LongType.get())))),\n+        optional(11, \"listOfPeople\", Types.ListType.ofRequired(12, Types.StructType.of(\n+            required(13, \"name\", Types.StringType.get()),\n+            required(14, \"birth_date\", Types.DateType.get()))))\n+    );\n+    Schema mappingSchema = new Schema(\n+        optional(1, \"struct\", Types.StructType.of(\n+            required(2, \"int\", Types.LongType.get())\n+        )),\n+        optional(3, \"list\", Types.ListType.ofRequired(4, Types.LongType.get())),\n+        optional(5, \"newMap\", Types.MapType.ofRequired(6, 7, Types.StringType.get(), Types.LongType.get())),\n+        optional(8, \"listOfStruct\", Types.ListType.ofRequired(9, Types.StructType.of(\n+            required(10, \"newLong\", Types.LongType.get())))),\n+        optional(11, \"listOfPeople\", Types.ListType.ofRequired(12, Types.StructType.of(\n+            required(13, \"name\", Types.StringType.get()),\n+            required(14, \"age\", Types.IntegerType.get()))))\n+    );\n+    TypeDescription orcSchemaWithoutIds = ORCSchemaUtil.removeIds(ORCSchemaUtil.convert(originalSchema));\n+    NameMapping nameMapping = MappingUtil.create(mappingSchema);\n+\n+    TypeDescription readSchema = ORCSchemaUtil.buildOrcProjection(mappingSchema,\n+        ORCSchemaUtil.applyNameMapping(orcSchemaWithoutIds, nameMapping));\n+\n+    Expression expr = and(\n+        and(\n+            equal(\"struct.int\", 1), and(\n+                lessThanOrEqual(\"list.element\", 5),\n+                equal(\"newMap.key\", \"country\")\n+            ),\n+            and(\n+                equal(\"listOfStruct.newLong\", 100L),\n+                notEqual(\"listOfPeople.name\", \"Bob\")\n+            )\n+\n+        ),\n+        lessThan(\"listOfPeople.age\", 30)\n+    );\n+    Expression boundFilter = Binder.bind(mappingSchema.asStruct(), expr, true);\n+    SearchArgument expected = SearchArgumentFactory.newBuilder()\n+        .startAnd()\n+        // Drops strict.long", "originalCommit": "b74abd8cdb25a94c3033404b324e95575216b493", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "91b6a0e051840d225bf5f90186f5bef88bf12095", "chunk": "diff --git a/orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java b/orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java\nindex bc63a26f1..b56b65aa2 100644\n--- a/orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java\n+++ b/orc/src/test/java/org/apache/iceberg/orc/TestExpressionToSearchArgument.java\n\n@@ -375,7 +375,7 @@ public class TestExpressionToSearchArgument {\n     Expression boundFilter = Binder.bind(mappingSchema.asStruct(), expr, true);\n     SearchArgument expected = SearchArgumentFactory.newBuilder()\n         .startAnd()\n-        // Drops strict.long\n+        // Drops struct.long\n         .equals(\"`struct`.`int_r2`\", Type.LONG, 1L)\n         .lessThanEquals(\"`list`.`_elem`\", Type.LONG, 5L)\n         // Drops map\n"}}, {"oid": "91b6a0e051840d225bf5f90186f5bef88bf12095", "url": "https://github.com/apache/iceberg/commit/91b6a0e051840d225bf5f90186f5bef88bf12095", "message": "Fix typo", "committedDate": "2020-08-12T22:59:05Z", "type": "commit"}]}