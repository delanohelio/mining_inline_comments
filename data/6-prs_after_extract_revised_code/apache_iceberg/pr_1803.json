{"pr_number": 1803, "pr_title": "Add NaN value count to content file", "pr_createdAt": "2020-11-21T03:06:48Z", "pr_url": "https://github.com/apache/iceberg/pull/1803", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA2MTEyOA==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r528061128", "bodyText": "If I change this record_count to something else it will result in NPE due to InclusiveMetrisEvaluator.eval  needing record count, however STATS_COLUMNS in manifest reader doesn't have it. I know the reader normally will only be used internally so we don't expect to run into this often, but wonder if we want to ensure record_count is always added when populating stats.", "author": "yyanyy", "createdAt": "2020-11-21T03:10:30Z", "path": "core/src/test/java/org/apache/iceberg/TestManifestReaderStats.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.types.Conversions;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)\n+public class TestManifestReaderStats extends TableTestBase {\n+  @Parameterized.Parameters(name = \"formatVersion = {0}\")\n+  public static Object[] parameters() {\n+    return new Object[] { 1, 2 };\n+  }\n+\n+  public TestManifestReaderStats(int formatVersion) {\n+    super(formatVersion);\n+  }\n+\n+  private static final Map<Integer, Long> VALUE_COUNT = ImmutableMap.of(3, 3L);\n+  private static final Map<Integer, Long> NULL_VALUE_COUNTS = ImmutableMap.of(3, 0L);\n+  private static final Map<Integer, Long> NAN_VALUE_COUNTS = ImmutableMap.of(3, 1L);\n+  private static final Map<Integer, ByteBuffer> LOWER_BOUNDS =\n+      ImmutableMap.of(3, Conversions.toByteBuffer(Types.IntegerType.get(), 2));\n+  private static final Map<Integer, ByteBuffer> UPPER_BOUNDS =\n+      ImmutableMap.of(3, Conversions.toByteBuffer(Types.IntegerType.get(), 4));\n+\n+  private static final Metrics METRICS = new Metrics(3L, null,\n+      VALUE_COUNT, NULL_VALUE_COUNTS, NAN_VALUE_COUNTS, LOWER_BOUNDS, UPPER_BOUNDS);\n+\n+  private static final DataFile FILE = DataFiles.builder(SPEC)\n+      .withPath(\"/path/to/data-a.parquet\")\n+      .withFileSizeInBytes(10)\n+      .withPartitionPath(\"data_bucket=0\") // easy way to set partition data for now\n+      .withRecordCount(3)\n+      .withMetrics(METRICS)\n+      .build();\n+\n+  @Test\n+  public void testReadIncludesFullStats() throws IOException {\n+    ManifestFile manifest = writeManifest(1000L, FILE);\n+    try (ManifestReader<DataFile> reader = ManifestFiles.read(manifest, FILE_IO)) {\n+      CloseableIterable<ManifestEntry<DataFile>> entries = reader.entries();\n+      ManifestEntry<DataFile> entry = entries.iterator().next();\n+      assertFullStats(entry.file());\n+    }\n+  }\n+\n+  @Test\n+  public void testReadWithFilterIncludesFullStats() throws IOException {\n+    ManifestFile manifest = writeManifest(1000L, FILE);\n+    try (ManifestReader<DataFile> reader = ManifestFiles.read(manifest, FILE_IO)\n+        .filterRows(Expressions.equal(\"id\", 3))) {\n+      CloseableIterable<ManifestEntry<DataFile>> entries = reader.entries();\n+      ManifestEntry<DataFile> entry = entries.iterator().next();\n+      assertFullStats(entry.file());\n+    }\n+  }\n+\n+  @Test\n+  public void testReadEntriesWithFilterAndSelectIncludesFullStats() throws IOException {\n+    ManifestFile manifest = writeManifest(1000L, FILE);\n+    try (ManifestReader<DataFile> reader = ManifestFiles.read(manifest, FILE_IO)\n+        .select(ImmutableSet.of(\"record_count\"))", "originalCommit": "d19cc51a5a2082777b9283208c4d030e9bcae5c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5MjA1Mg==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529092052", "bodyText": "Yes, I think we do. Maybe we should do that in a separate update, though.", "author": "rdblue", "createdAt": "2020-11-24T00:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA2MTEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk5MDUzMQ==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529990531", "bodyText": "Sounds good, I'll create a separate pr for that", "author": "yyanyy", "createdAt": "2020-11-24T23:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA2MTEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA3MzQ4Mw==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r530073483", "bodyText": "PR: #1820", "author": "yyanyy", "createdAt": "2020-11-25T02:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA2MTEyOA=="}], "type": "inlineReview", "revised_code": {"commit": "fe48ba74d9a73cd91ae76fb5ab9d2b183d9a663e", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestManifestReaderStats.java b/core/src/test/java/org/apache/iceberg/TestManifestReaderStats.java\nindex 4cb0260dc..8d5f8b630 100644\n--- a/core/src/test/java/org/apache/iceberg/TestManifestReaderStats.java\n+++ b/core/src/test/java/org/apache/iceberg/TestManifestReaderStats.java\n\n@@ -151,12 +151,7 @@ public class TestManifestReaderStats extends TableTestBase {\n     Assert.assertEquals(NULL_VALUE_COUNTS, dataFile.nullValueCounts());\n     Assert.assertEquals(LOWER_BOUNDS, dataFile.lowerBounds());\n     Assert.assertEquals(UPPER_BOUNDS, dataFile.upperBounds());\n-\n-    if (formatVersion == 1) {\n-      Assert.assertNull(dataFile.nanValueCounts());\n-    } else {\n-      Assert.assertEquals(NAN_VALUE_COUNTS, dataFile.nanValueCounts());\n-    }\n+    Assert.assertEquals(NAN_VALUE_COUNTS, dataFile.nanValueCounts());\n   }\n \n   private void assertStatsDropped(DataFile dataFile) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzMzUwMA==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r528433500", "bodyText": "nit: newline should start at the same place as last line", "author": "jackye1995", "createdAt": "2020-11-23T00:59:26Z", "path": "api/src/main/java/org/apache/iceberg/ContentFile.java", "diffHunk": "@@ -132,7 +137,8 @@\n    * Copies this file without file stats. Manifest readers can reuse file instances; use\n    * this method to copy data without stats when collecting files.\n    *\n-   * @return a copy of this data file, without lower bounds, upper bounds, value counts, or null value counts\n+   * @return a copy of this data file, without lower bounds, upper bounds, value counts,\n+   * null value counts, or nan value counts", "originalCommit": "d19cc51a5a2082777b9283208c4d030e9bcae5c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "505a67112d8f359c00ae61975b4c710930c2738e", "chunk": "diff --git a/api/src/main/java/org/apache/iceberg/ContentFile.java b/api/src/main/java/org/apache/iceberg/ContentFile.java\nindex d2ab9ea43..3190f7b08 100644\n--- a/api/src/main/java/org/apache/iceberg/ContentFile.java\n+++ b/api/src/main/java/org/apache/iceberg/ContentFile.java\n\n@@ -138,7 +138,7 @@ public interface ContentFile<F> {\n    * this method to copy data without stats when collecting files.\n    *\n    * @return a copy of this data file, without lower bounds, upper bounds, value counts,\n-   * null value counts, or nan value counts\n+   *         null value counts, or nan value counts\n    */\n   F copyWithoutStats();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzMzgyNw==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r528433827", "bodyText": "nit: can we keep the existing lines the same?", "author": "jackye1995", "createdAt": "2020-11-23T01:01:42Z", "path": "core/src/main/java/org/apache/iceberg/BaseFile.java", "diffHunk": "@@ -116,8 +117,8 @@ public PartitionData copy() {\n   }\n \n   BaseFile(int specId, FileContent content, String filePath, FileFormat format,\n-           PartitionData partition, long fileSizeInBytes, long recordCount,\n-           Map<Integer, Long> columnSizes, Map<Integer, Long> valueCounts, Map<Integer, Long> nullValueCounts,\n+           PartitionData partition, long fileSizeInBytes, long recordCount, Map<Integer, Long> columnSizes,", "originalCommit": "d19cc51a5a2082777b9283208c4d030e9bcae5c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "505a67112d8f359c00ae61975b4c710930c2738e", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/BaseFile.java b/core/src/main/java/org/apache/iceberg/BaseFile.java\nindex 5aa1c965f..53d688a84 100644\n--- a/core/src/main/java/org/apache/iceberg/BaseFile.java\n+++ b/core/src/main/java/org/apache/iceberg/BaseFile.java\n\n@@ -117,8 +117,9 @@ abstract class BaseFile<F>\n   }\n \n   BaseFile(int specId, FileContent content, String filePath, FileFormat format,\n-           PartitionData partition, long fileSizeInBytes, long recordCount, Map<Integer, Long> columnSizes,\n-           Map<Integer, Long> valueCounts, Map<Integer, Long> nullValueCounts, Map<Integer, Long> nanValueCounts,\n+           PartitionData partition, long fileSizeInBytes, long recordCount,\n+           Map<Integer, Long> columnSizes, Map<Integer, Long> valueCounts,\n+           Map<Integer, Long> nullValueCounts, Map<Integer, Long> nanValueCounts,\n            Map<Integer, ByteBuffer> lowerBounds, Map<Integer, ByteBuffer> upperBounds, List<Long> splitOffsets,\n            int[] equalityFieldIds, ByteBuffer keyMetadata) {\n     this.partitionSpecId = specId;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzNDI5OQ==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r528434299", "bodyText": "what is this change for?", "author": "jackye1995", "createdAt": "2020-11-23T01:05:11Z", "path": "core/src/main/java/org/apache/iceberg/V1Metadata.java", "diffHunk": "@@ -356,7 +356,7 @@ public Object get(int pos) {\n \n     @Override\n     public void put(int i, Object v) {\n-      throw new UnsupportedOperationException(\"Cannot read into IndexedDataFile\");\n+      throw new UnsupportedOperationException(\"Cannot write into IndexedDataFile\");", "originalCommit": "d19cc51a5a2082777b9283208c4d030e9bcae5c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyMzcwMw==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r528923703", "bodyText": "I think this read was a typo, unless I misunderstood this?", "author": "yyanyy", "createdAt": "2020-11-23T18:50:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzNDI5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5MDYyNw==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529090627", "bodyText": "This was correct before.\nThis class is only used to write v1 metadata files, not to read. So there is no need to implement the put method that is used when reading values from a file and putting them in the data file instance.", "author": "rdblue", "createdAt": "2020-11-24T00:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzNDI5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk5MDYzOA==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529990638", "bodyText": "Ah I see, it was \"read into\" to populate IndexedDataFile, makes sense. I'll revert this back.", "author": "yyanyy", "createdAt": "2020-11-24T23:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzNDI5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "fe48ba74d9a73cd91ae76fb5ab9d2b183d9a663e", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/V1Metadata.java b/core/src/main/java/org/apache/iceberg/V1Metadata.java\nindex 8e5f5fb02..4b035830d 100644\n--- a/core/src/main/java/org/apache/iceberg/V1Metadata.java\n+++ b/core/src/main/java/org/apache/iceberg/V1Metadata.java\n\n@@ -343,12 +344,14 @@ class V1Metadata {\n         case 8:\n           return wrapped.nullValueCounts();\n         case 9:\n-          return wrapped.lowerBounds();\n+          return wrapped.nanValueCounts();\n         case 10:\n-          return wrapped.upperBounds();\n+          return wrapped.lowerBounds();\n         case 11:\n-          return wrapped.keyMetadata();\n+          return wrapped.upperBounds();\n         case 12:\n+          return wrapped.keyMetadata();\n+        case 13:\n           return wrapped.splitOffsets();\n       }\n       throw new IllegalArgumentException(\"Unknown field ordinal: \" + pos);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzNDcyOA==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r528434728", "bodyText": "why are we modifying this line instead of adding a new line?", "author": "jackye1995", "createdAt": "2020-11-23T01:08:57Z", "path": "spark/src/test/java/org/apache/iceberg/TestDataFileSerialization.java", "diffHunk": "@@ -68,14 +69,16 @@\n \n   private static final Map<Integer, Long> VALUE_COUNTS = Maps.newHashMap();\n   private static final Map<Integer, Long> NULL_VALUE_COUNTS = Maps.newHashMap();\n+  private static final Map<Integer, Long> NAN_VALUE_COUNTS = Maps.newHashMap();\n   private static final Map<Integer, ByteBuffer> LOWER_BOUNDS = Maps.newHashMap();\n   private static final Map<Integer, ByteBuffer> UPPER_BOUNDS = Maps.newHashMap();\n \n   static {\n     VALUE_COUNTS.put(1, 5L);\n     VALUE_COUNTS.put(2, 3L);\n+    VALUE_COUNTS.put(4, 2L);\n     NULL_VALUE_COUNTS.put(1, 0L);\n-    NULL_VALUE_COUNTS.put(2, 2L);", "originalCommit": "d19cc51a5a2082777b9283208c4d030e9bcae5c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNDM2NA==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r528924364", "bodyText": "Oh good catch, I guess I thought I duplicated the line myself but seems like it was from the original code; I'll add it back", "author": "yyanyy", "createdAt": "2020-11-23T18:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzNDcyOA=="}], "type": "inlineReview", "revised_code": {"commit": "505a67112d8f359c00ae61975b4c710930c2738e", "chunk": "diff --git a/spark/src/test/java/org/apache/iceberg/TestDataFileSerialization.java b/spark/src/test/java/org/apache/iceberg/TestDataFileSerialization.java\nindex fa7dcb0a3..783a62099 100644\n--- a/spark/src/test/java/org/apache/iceberg/TestDataFileSerialization.java\n+++ b/spark/src/test/java/org/apache/iceberg/TestDataFileSerialization.java\n\n@@ -78,6 +78,7 @@ public class TestDataFileSerialization {\n     VALUE_COUNTS.put(2, 3L);\n     VALUE_COUNTS.put(4, 2L);\n     NULL_VALUE_COUNTS.put(1, 0L);\n+    NULL_VALUE_COUNTS.put(2, 2L);\n     NAN_VALUE_COUNTS.put(4, 1L);\n     LOWER_BOUNDS.put(1, longToBuffer(0L));\n     UPPER_BOUNDS.put(1, longToBuffer(4L));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4OTQxNg==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529089416", "bodyText": "Could you move this up by NULL_VALUE_COUNTS?", "author": "rdblue", "createdAt": "2020-11-24T00:45:01Z", "path": "api/src/main/java/org/apache/iceberg/DataFile.java", "diffHunk": "@@ -59,10 +60,13 @@\n       \"Splittable offsets\");\n   Types.NestedField EQUALITY_IDS = optional(135, \"equality_ids\", ListType.ofRequired(136, IntegerType.get()),\n       \"Equality comparison field IDs\");\n+  Types.NestedField NAN_VALUE_COUNTS = optional(137, \"nan_value_counts\", MapType.ofRequired(138, 139,\n+      IntegerType.get(), LongType.get()), \"Map of column id to number of NaN values in the column\");", "originalCommit": "c3298b41d9cd9d94701c7952d567091649d43764", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe48ba74d9a73cd91ae76fb5ab9d2b183d9a663e", "chunk": "diff --git a/api/src/main/java/org/apache/iceberg/DataFile.java b/api/src/main/java/org/apache/iceberg/DataFile.java\nindex 51195533f..a763f9565 100644\n--- a/api/src/main/java/org/apache/iceberg/DataFile.java\n+++ b/api/src/main/java/org/apache/iceberg/DataFile.java\n\n@@ -60,8 +61,6 @@ public interface DataFile extends ContentFile<DataFile> {\n       \"Splittable offsets\");\n   Types.NestedField EQUALITY_IDS = optional(135, \"equality_ids\", ListType.ofRequired(136, IntegerType.get()),\n       \"Equality comparison field IDs\");\n-  Types.NestedField NAN_VALUE_COUNTS = optional(137, \"nan_value_counts\", MapType.ofRequired(138, 139,\n-      IntegerType.get(), LongType.get()), \"Map of column id to number of NaN values in the column\");\n \n   int PARTITION_ID = 102;\n   String PARTITION_NAME = \"partition\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4OTY0NA==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529089644", "bodyText": "I think we should place this field just after null counts.", "author": "rdblue", "createdAt": "2020-11-24T00:45:37Z", "path": "api/src/main/java/org/apache/iceberg/DataFile.java", "diffHunk": "@@ -80,7 +84,8 @@ static StructType getType(StructType partitionType) {\n         UPPER_BOUNDS,\n         KEY_METADATA,\n         SPLIT_OFFSETS,\n-        EQUALITY_IDS\n+        EQUALITY_IDS,\n+        NAN_VALUE_COUNTS", "originalCommit": "c3298b41d9cd9d94701c7952d567091649d43764", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe48ba74d9a73cd91ae76fb5ab9d2b183d9a663e", "chunk": "diff --git a/api/src/main/java/org/apache/iceberg/DataFile.java b/api/src/main/java/org/apache/iceberg/DataFile.java\nindex 51195533f..a763f9565 100644\n--- a/api/src/main/java/org/apache/iceberg/DataFile.java\n+++ b/api/src/main/java/org/apache/iceberg/DataFile.java\n\n@@ -80,12 +79,12 @@ public interface DataFile extends ContentFile<DataFile> {\n         COLUMN_SIZES,\n         VALUE_COUNTS,\n         NULL_VALUE_COUNTS,\n+        NAN_VALUE_COUNTS,\n         LOWER_BOUNDS,\n         UPPER_BOUNDS,\n         KEY_METADATA,\n         SPLIT_OFFSETS,\n-        EQUALITY_IDS,\n-        NAN_VALUE_COUNTS\n+        EQUALITY_IDS\n     );\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4OTg1OQ==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529089859", "bodyText": "I think all of the implementations will provide this method, so there should be no need for the default, right?", "author": "rdblue", "createdAt": "2020-11-24T00:46:14Z", "path": "api/src/main/java/org/apache/iceberg/DataFile.java", "diffHunk": "@@ -96,4 +101,9 @@ default FileContent content() {\n   default List<Integer> equalityFieldIds() {\n     return null;\n   }\n+\n+  @Override\n+  default Map<Integer, Long> nanValueCounts() {\n+    return null;\n+  }", "originalCommit": "c3298b41d9cd9d94701c7952d567091649d43764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk5MTQyOQ==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529991429", "bodyText": "Originally since V1 doesn't have this so it was used there, but as we are going to support it, I'll remove it.", "author": "yyanyy", "createdAt": "2020-11-24T23:16:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4OTg1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "fe48ba74d9a73cd91ae76fb5ab9d2b183d9a663e", "chunk": "diff --git a/api/src/main/java/org/apache/iceberg/DataFile.java b/api/src/main/java/org/apache/iceberg/DataFile.java\nindex 51195533f..a763f9565 100644\n--- a/api/src/main/java/org/apache/iceberg/DataFile.java\n+++ b/api/src/main/java/org/apache/iceberg/DataFile.java\n\n@@ -101,9 +100,4 @@ public interface DataFile extends ContentFile<DataFile> {\n   default List<Integer> equalityFieldIds() {\n     return null;\n   }\n-\n-  @Override\n-  default Map<Integer, Long> nanValueCounts() {\n-    return null;\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5MDg1Mw==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529090853", "bodyText": "Similar to above, I think we should add NaN value counts just below null value counts. This will affect the ordinals in get so you'll have to update them.", "author": "rdblue", "createdAt": "2020-11-24T00:49:12Z", "path": "core/src/main/java/org/apache/iceberg/V2Metadata.java", "diffHunk": "@@ -254,7 +254,8 @@ static Schema wrapFileSchema(Types.StructType fileSchema) {\n         DataFile.UPPER_BOUNDS,\n         DataFile.KEY_METADATA,\n         DataFile.SPLIT_OFFSETS,\n-        DataFile.EQUALITY_IDS\n+        DataFile.EQUALITY_IDS,\n+        DataFile.NAN_VALUE_COUNTS", "originalCommit": "c3298b41d9cd9d94701c7952d567091649d43764", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe48ba74d9a73cd91ae76fb5ab9d2b183d9a663e", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/V2Metadata.java b/core/src/main/java/org/apache/iceberg/V2Metadata.java\nindex fee4bc360..a468632f4 100644\n--- a/core/src/main/java/org/apache/iceberg/V2Metadata.java\n+++ b/core/src/main/java/org/apache/iceberg/V2Metadata.java\n\n@@ -250,12 +250,12 @@ class V2Metadata {\n         DataFile.COLUMN_SIZES,\n         DataFile.VALUE_COUNTS,\n         DataFile.NULL_VALUE_COUNTS,\n+        DataFile.NAN_VALUE_COUNTS,\n         DataFile.LOWER_BOUNDS,\n         DataFile.UPPER_BOUNDS,\n         DataFile.KEY_METADATA,\n         DataFile.SPLIT_OFFSETS,\n-        DataFile.EQUALITY_IDS,\n-        DataFile.NAN_VALUE_COUNTS\n+        DataFile.EQUALITY_IDS\n     );\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5MTc2OA==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529091768", "bodyText": "This doesn't add NaN counts to v1 metadata, but there's no reason why we can't. Adding a new column to v1 metadata files is forward compatible and is allowed, so we can go ahead and add it here. That way, even v1 benefits.\nThe reason why this is a v2 feature is that we are creating additional requirements for writers: NaN must not be written as a lower or upper bound in Iceberg metadata. Writers that want to write NaN counts in v1 should be able to do so.", "author": "rdblue", "createdAt": "2020-11-24T00:51:55Z", "path": "core/src/main/java/org/apache/iceberg/V1Metadata.java", "diffHunk": "@@ -356,7 +356,7 @@ public Object get(int pos) {\n \n     @Override\n     public void put(int i, Object v) {\n-      throw new UnsupportedOperationException(\"Cannot read into IndexedDataFile\");\n+      throw new UnsupportedOperationException(\"Cannot write into IndexedDataFile\");", "originalCommit": "c3298b41d9cd9d94701c7952d567091649d43764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk5MjcyOQ==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529992729", "bodyText": "Sure! I wasn't sure if I wanted to add it v1 since v1 was an established version, and I don't know if introducing new attributes would be considered as breaking people's assumption on the file contract (e.g. if some people have their own version of manifest entry parser). But I guess the chance of this happening would probably be rare, and should be easy to fix.", "author": "yyanyy", "createdAt": "2020-11-24T23:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5MTc2OA=="}], "type": "inlineReview", "revised_code": {"commit": "fe48ba74d9a73cd91ae76fb5ab9d2b183d9a663e", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/V1Metadata.java b/core/src/main/java/org/apache/iceberg/V1Metadata.java\nindex 8e5f5fb02..4b035830d 100644\n--- a/core/src/main/java/org/apache/iceberg/V1Metadata.java\n+++ b/core/src/main/java/org/apache/iceberg/V1Metadata.java\n\n@@ -343,12 +344,14 @@ class V1Metadata {\n         case 8:\n           return wrapped.nullValueCounts();\n         case 9:\n-          return wrapped.lowerBounds();\n+          return wrapped.nanValueCounts();\n         case 10:\n-          return wrapped.upperBounds();\n+          return wrapped.lowerBounds();\n         case 11:\n-          return wrapped.keyMetadata();\n+          return wrapped.upperBounds();\n         case 12:\n+          return wrapped.keyMetadata();\n+        case 13:\n           return wrapped.splitOffsets();\n       }\n       throw new IllegalArgumentException(\"Unknown field ordinal: \" + pos);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5MjY4Ng==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529092686", "bodyText": "Typo: // NaN value counts", "author": "rdblue", "createdAt": "2020-11-24T00:54:41Z", "path": "core/src/test/java/org/apache/iceberg/TestManifestWriterVersions.java", "diffHunk": "@@ -60,9 +61,10 @@\n   private static final PartitionData PARTITION = DataFiles.data(SPEC, \"category=cheesy/timestamp_hour=10/id_bucket=3\");\n   private static final Metrics METRICS = new Metrics(\n       1587L,\n-      ImmutableMap.of(1, 15L, 2, 122L, 3, 4021L, 4, 9411L), // sizes\n-      ImmutableMap.of(1, 100L, 2, 100L, 3, 100L, 4, 100L),  // value counts\n-      ImmutableMap.of(1, 0L, 2, 0L, 3, 0L, 4, 0L),          // null value counts\n+      ImmutableMap.of(1, 15L, 2, 122L, 3, 4021L, 4, 9411L, 5, 15L), // sizes\n+      ImmutableMap.of(1, 100L, 2, 100L, 3, 100L, 4, 100L, 5, 100L),  // value counts\n+      ImmutableMap.of(1, 0L, 2, 0L, 3, 0L, 4, 0L, 5, 0L), // null value counts\n+      ImmutableMap.of(5, 10L), // null value counts", "originalCommit": "c3298b41d9cd9d94701c7952d567091649d43764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk5MjgzNw==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529992837", "bodyText": "Ah thanks for the catch!", "author": "yyanyy", "createdAt": "2020-11-24T23:18:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5MjY4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "fe48ba74d9a73cd91ae76fb5ab9d2b183d9a663e", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestManifestWriterVersions.java b/core/src/test/java/org/apache/iceberg/TestManifestWriterVersions.java\nindex 355193138..0fb1d46f6 100644\n--- a/core/src/test/java/org/apache/iceberg/TestManifestWriterVersions.java\n+++ b/core/src/test/java/org/apache/iceberg/TestManifestWriterVersions.java\n\n@@ -64,7 +64,7 @@ public class TestManifestWriterVersions {\n       ImmutableMap.of(1, 15L, 2, 122L, 3, 4021L, 4, 9411L, 5, 15L), // sizes\n       ImmutableMap.of(1, 100L, 2, 100L, 3, 100L, 4, 100L, 5, 100L),  // value counts\n       ImmutableMap.of(1, 0L, 2, 0L, 3, 0L, 4, 0L, 5, 0L), // null value counts\n-      ImmutableMap.of(5, 10L), // null value counts\n+      ImmutableMap.of(5, 10L), // nan value counts\n       ImmutableMap.of(1, Conversions.toByteBuffer(Types.IntegerType.get(), 1)),  // lower bounds\n       ImmutableMap.of(1, Conversions.toByteBuffer(Types.IntegerType.get(), 1))); // upper bounds\n   private static final List<Long> OFFSETS = ImmutableList.of(4L);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5Mjg3Mw==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529092873", "bodyText": "I think writing NaN counts in v1 will probably simplify the test updates here.", "author": "rdblue", "createdAt": "2020-11-24T00:55:14Z", "path": "core/src/test/java/org/apache/iceberg/TestManifestWriterVersions.java", "diffHunk": "@@ -203,6 +208,11 @@ void checkDataFile(ContentFile<?> dataFile, FileContent content) {\n     } else {\n       Assert.assertNull(dataFile.equalityFieldIds());\n     }\n+    if (hasNaNCount) {\n+      Assert.assertEquals(\"NaN\", METRICS.nanValueCounts(), dataFile.nanValueCounts());\n+    } else {\n+      Assert.assertNull(\"NaN\", dataFile.nanValueCounts());\n+    }", "originalCommit": "c3298b41d9cd9d94701c7952d567091649d43764", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe48ba74d9a73cd91ae76fb5ab9d2b183d9a663e", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestManifestWriterVersions.java b/core/src/test/java/org/apache/iceberg/TestManifestWriterVersions.java\nindex 355193138..0fb1d46f6 100644\n--- a/core/src/test/java/org/apache/iceberg/TestManifestWriterVersions.java\n+++ b/core/src/test/java/org/apache/iceberg/TestManifestWriterVersions.java\n\n@@ -201,6 +200,7 @@ public class TestManifestWriterVersions {\n     Assert.assertEquals(\"Column sizes\", METRICS.columnSizes(), dataFile.columnSizes());\n     Assert.assertEquals(\"Value counts\", METRICS.valueCounts(), dataFile.valueCounts());\n     Assert.assertEquals(\"Null value counts\", METRICS.nullValueCounts(), dataFile.nullValueCounts());\n+    Assert.assertEquals(\"NaN value counts\", METRICS.nanValueCounts(), dataFile.nanValueCounts());\n     Assert.assertEquals(\"Lower bounds\", METRICS.lowerBounds(), dataFile.lowerBounds());\n     Assert.assertEquals(\"Upper bounds\", METRICS.upperBounds(), dataFile.upperBounds());\n     if (dataFile.content() == FileContent.EQUALITY_DELETES) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5MzI5MQ==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529093291", "bodyText": "Why are NaN values getting into the lower and upper bounds?", "author": "rdblue", "createdAt": "2020-11-24T00:56:35Z", "path": "core/src/test/java/org/apache/iceberg/TestMetrics.java", "diffHunk": "@@ -272,6 +273,8 @@ public void testMetricsForNestedStructFields() throws IOException {\n     assertCounts(6, 1L, 0L, metrics);\n     assertBounds(6, BinaryType.get(),\n         ByteBuffer.wrap(\"A\".getBytes()), ByteBuffer.wrap(\"A\".getBytes()), metrics);\n+    assertCounts(7, 1L, 0L, 1L, metrics);\n+    assertBounds(7, DoubleType.get(), Double.NaN, Double.NaN, metrics);", "originalCommit": "c3298b41d9cd9d94701c7952d567091649d43764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk5MzE2Mg==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r529993162", "bodyText": "This was because I added NaN as the only value in this column during the creation of the record in buildNestedTestRecord, and currently this will result in upper and lower bound being both NaN (similar behavior as in this test. I added this extra column in order to test NaN handling in metrics modes, and change to this test was a side effect. Do you want me to remove the bound check in this test?", "author": "yyanyy", "createdAt": "2020-11-24T23:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5MzI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzNzQwNg==", "url": "https://github.com/apache/iceberg/pull/1803#discussion_r530037406", "bodyText": "So I guess this will continue to happen until we ignore NaN values and keep track of the lower and upper bounds ourselves for Parquet and ORC?\nThis is fine for now, but I would want this to be correct eventually.", "author": "rdblue", "createdAt": "2020-11-25T00:49:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5MzI5MQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "3f0d3aee242b91aaf27faf3341430920051768fe", "url": "https://github.com/apache/iceberg/commit/3f0d3aee242b91aaf27faf3341430920051768fe", "message": "Add NaN value count to content file", "committedDate": "2020-11-24T23:03:12Z", "type": "commit"}, {"oid": "505a67112d8f359c00ae61975b4c710930c2738e", "url": "https://github.com/apache/iceberg/commit/505a67112d8f359c00ae61975b4c710930c2738e", "message": "minor update", "committedDate": "2020-11-24T23:03:13Z", "type": "commit"}, {"oid": "fe48ba74d9a73cd91ae76fb5ab9d2b183d9a663e", "url": "https://github.com/apache/iceberg/commit/fe48ba74d9a73cd91ae76fb5ab9d2b183d9a663e", "message": "update attributes order, support nan in v1 metadata", "committedDate": "2020-11-24T23:13:39Z", "type": "forcePushed"}, {"oid": "4fc80679c7517184250e62510e1a04284ce5b80c", "url": "https://github.com/apache/iceberg/commit/4fc80679c7517184250e62510e1a04284ce5b80c", "message": "update attributes order, support nan in v1 metadata", "committedDate": "2020-11-24T23:37:27Z", "type": "commit"}, {"oid": "4fc80679c7517184250e62510e1a04284ce5b80c", "url": "https://github.com/apache/iceberg/commit/4fc80679c7517184250e62510e1a04284ce5b80c", "message": "update attributes order, support nan in v1 metadata", "committedDate": "2020-11-24T23:37:27Z", "type": "forcePushed"}]}