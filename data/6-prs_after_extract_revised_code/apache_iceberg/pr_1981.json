{"pr_number": 1981, "pr_title": "Fix date and timestamp transforms", "pr_createdAt": "2020-12-23T21:50:30Z", "pr_url": "https://github.com/apache/iceberg/pull/1981", "timeline": [{"oid": "c5fe954009145ba0bec495bdeefd881a3343afa5", "url": "https://github.com/apache/iceberg/commit/c5fe954009145ba0bec495bdeefd881a3343afa5", "message": "Fix timestamp and date transforms.", "committedDate": "2020-12-23T21:50:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI3MTE0Ng==", "url": "https://github.com/apache/iceberg/pull/1981#discussion_r548271146", "bodyText": "More tests need to be added here. I just wanted to get this up for review since I'm going to be out for a couple of days.", "author": "rdblue", "createdAt": "2020-12-23T21:52:41Z", "path": "api/src/test/java/org/apache/iceberg/transforms/TestTimestampsProjection.java", "diffHunk": "@@ -74,22 +74,22 @@ public void assertProjectionStrictValue(PartitionSpec spec, UnboundPredicate<?>\n                                           Expression.Operation expectedOp) {\n \n     Expression projection = Projections.strict(spec).project(filter);\n-    Assert.assertEquals(projection.op(), expectedOp);\n+    Assert.assertEquals(expectedOp, projection.op());\n   }\n \n   public void assertProjectionInclusiveValue(PartitionSpec spec, UnboundPredicate<?> filter,\n                                              Expression.Operation expectedOp) {\n \n     Expression projection = Projections.inclusive(spec).project(filter);\n-    Assert.assertEquals(projection.op(), expectedOp);\n+    Assert.assertEquals(expectedOp, projection.op());\n   }\n \n   public void assertProjectionInclusive(PartitionSpec spec, UnboundPredicate<?> filter,\n                                         Expression.Operation expectedOp, String expectedLiteral) {\n     Expression projection = Projections.inclusive(spec).project(filter);\n     UnboundPredicate<?> predicate = assertAndUnwrapUnbound(projection);\n \n-    Assert.assertEquals(predicate.op(), expectedOp);", "originalCommit": "c5fe954009145ba0bec495bdeefd881a3343afa5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "a0b88165344b50f90cd60359287f8c5f7e5dadbb", "url": "https://github.com/apache/iceberg/commit/a0b88165344b50f90cd60359287f8c5f7e5dadbb", "message": "Fix timestamp and date transforms.", "committedDate": "2020-12-23T21:53:53Z", "type": "commit"}, {"oid": "a0b88165344b50f90cd60359287f8c5f7e5dadbb", "url": "https://github.com/apache/iceberg/commit/a0b88165344b50f90cd60359287f8c5f7e5dadbb", "message": "Fix timestamp and date transforms.", "committedDate": "2020-12-23T21:53:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NTQ2MA==", "url": "https://github.com/apache/iceberg/pull/1981#discussion_r548345460", "bodyText": "I think the second argument in Instant.ofEpochSecond is nanosecond instead of microsecond? Although this doesn't change the outcome of this method since we don't accept nanosecond in the first place, and inputing microsecond for nanosecond field just makes the field smaller than it should be, which is already enough to address the case when Math.floorMod() == 0", "author": "yyanyy", "createdAt": "2020-12-24T01:46:05Z", "path": "api/src/main/java/org/apache/iceberg/transforms/Timestamps.java", "diffHunk": "@@ -52,12 +52,19 @@ public Integer apply(Long timestampMicros) {\n       return null;\n     }\n \n-    // discards fractional seconds, not needed for calculation\n-    OffsetDateTime timestamp = Instant\n-        .ofEpochSecond(timestampMicros / 1_000_000)\n-        .atOffset(ZoneOffset.UTC);\n-\n-    return (int) granularity.between(EPOCH, timestamp);\n+    if (timestampMicros >= 0) {\n+      OffsetDateTime timestamp = Instant\n+          .ofEpochSecond(Math.floorDiv(timestampMicros, 1_000_000), Math.floorMod(timestampMicros, 1_000_000))\n+          .atOffset(ZoneOffset.UTC);\n+      return (int) granularity.between(EPOCH, timestamp);\n+    } else {\n+      // add 1 micro to the value to account for the case where there is exactly 1 unit between the timestamp and epoch\n+      // because the result will always be decremented.\n+      OffsetDateTime timestamp = Instant\n+          .ofEpochSecond(Math.floorDiv(timestampMicros, 1_000_000), Math.floorMod(timestampMicros + 1, 1_000_000))", "originalCommit": "a0b88165344b50f90cd60359287f8c5f7e5dadbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyMjQ1NA==", "url": "https://github.com/apache/iceberg/pull/1981#discussion_r549822454", "bodyText": "Fixed.", "author": "rdblue", "createdAt": "2020-12-29T19:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NTQ2MA=="}], "type": "inlineReview", "revised_code": {"commit": "b4eb6e6dff84c35e02884e73d8de6bc34c9e6565", "chunk": "diff --git a/api/src/main/java/org/apache/iceberg/transforms/Timestamps.java b/api/src/main/java/org/apache/iceberg/transforms/Timestamps.java\nindex de4bfcf8c..75735f771 100644\n--- a/api/src/main/java/org/apache/iceberg/transforms/Timestamps.java\n+++ b/api/src/main/java/org/apache/iceberg/transforms/Timestamps.java\n\n@@ -54,14 +54,18 @@ enum Timestamps implements Transform<Long, Integer> {\n \n     if (timestampMicros >= 0) {\n       OffsetDateTime timestamp = Instant\n-          .ofEpochSecond(Math.floorDiv(timestampMicros, 1_000_000), Math.floorMod(timestampMicros, 1_000_000))\n+          .ofEpochSecond(\n+              Math.floorDiv(timestampMicros, 1_000_000),\n+              Math.floorMod(timestampMicros, 1_000_000) * 1000)\n           .atOffset(ZoneOffset.UTC);\n       return (int) granularity.between(EPOCH, timestamp);\n     } else {\n       // add 1 micro to the value to account for the case where there is exactly 1 unit between the timestamp and epoch\n       // because the result will always be decremented.\n       OffsetDateTime timestamp = Instant\n-          .ofEpochSecond(Math.floorDiv(timestampMicros, 1_000_000), Math.floorMod(timestampMicros + 1, 1_000_000))\n+          .ofEpochSecond(\n+              Math.floorDiv(timestampMicros, 1_000_000),\n+              Math.floorMod(timestampMicros + 1, 1_000_000) * 1000)\n           .atOffset(ZoneOffset.UTC);\n       return (int) granularity.between(EPOCH, timestamp) - 1;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NTczNw==", "url": "https://github.com/apache/iceberg/pull/1981#discussion_r548345737", "bodyText": "I think the mention of \"correct\" and \"incorrect\" in these comments might not be obvious to understand outside the context of this PR, as the reader has no prior knowledge of the issue we are fixing here from looking at the code base itself. Do we want to add some more explanation/link to the issue?", "author": "yyanyy", "createdAt": "2020-12-24T01:47:22Z", "path": "api/src/main/java/org/apache/iceberg/transforms/ProjectionUtil.java", "diffHunk": "@@ -254,4 +257,124 @@ private ProjectionUtil() {\n     return predicate(predicate.op(), fieldName,\n         Iterables.transform(predicate.asSetPredicate().literalSet(), transform::apply));\n   }\n+\n+  static UnboundPredicate<Integer> fixInclusiveTimeProjection(UnboundPredicate<Integer> projected) {\n+    if (projected == null) {\n+      return projected;\n+    }\n+\n+    // adjust the predicate for values that were 1 larger than the correct transformed value", "originalCommit": "a0b88165344b50f90cd60359287f8c5f7e5dadbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyNjU0NQ==", "url": "https://github.com/apache/iceberg/pull/1981#discussion_r549826545", "bodyText": "I added docs to explain what \"correct\" and \"incorrect\" mean.", "author": "rdblue", "createdAt": "2020-12-29T19:47:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NTczNw=="}], "type": "inlineReview", "revised_code": {"commit": "146ff9e1aebe19d40ca76a849d39fd3432919ae2", "chunk": "diff --git a/api/src/main/java/org/apache/iceberg/transforms/ProjectionUtil.java b/api/src/main/java/org/apache/iceberg/transforms/ProjectionUtil.java\nindex 789facc89..df2575ce7 100644\n--- a/api/src/main/java/org/apache/iceberg/transforms/ProjectionUtil.java\n+++ b/api/src/main/java/org/apache/iceberg/transforms/ProjectionUtil.java\n\n@@ -258,6 +258,15 @@ class ProjectionUtil {\n         Iterables.transform(predicate.asSetPredicate().literalSet(), transform::apply));\n   }\n \n+  /**\n+   * Fixes an inclusive projection to account for incorrectly transformed values.\n+   * <p>\n+   * A bug in 0.10.0 and earlier caused negative values to be incorrectly transformed by date and timestamp transforms\n+   * to 1 larger than the correct value. For example, day(1969-12-31 10:00:00) produced 0 instead of -1. To read data\n+   * written by versions with this bug, this method adjusts the inclusive projection. The current inclusive projection\n+   * is correct, so this modifies the \"correct\" projection when needed. For example, < day(1969-12-31 10:00:00) will\n+   * produce <= -1 (= 1969-12-31) and is adjusted to <= 0 (= 1969-01-01) because the incorrect transformed value was 0.\n+   */\n   static UnboundPredicate<Integer> fixInclusiveTimeProjection(UnboundPredicate<Integer> projected) {\n     if (projected == null) {\n       return projected;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NTkzOQ==", "url": "https://github.com/apache/iceberg/pull/1981#discussion_r548345939", "bodyText": "I think this is testing the same thing for NOT_IN in testNegativeMonthStrictLowerBound, do we want to change 1970-01-01 to an earlier time?", "author": "yyanyy", "createdAt": "2020-12-24T01:48:23Z", "path": "api/src/test/java/org/apache/iceberg/transforms/TestDatesProjection.java", "diffHunk": "@@ -142,6 +161,24 @@ public void testMonthStrictUpperBound() {\n     assertProjectionStrictValue(spec, in(\"date\", anotherDate, date), Expression.Operation.FALSE);\n   }\n \n+  @Test\n+  public void testNegativeMonthStrictUpperBound() {\n+    Integer date = (Integer) Literal.of(\"1969-12-31\").to(TYPE).value();\n+    PartitionSpec spec = PartitionSpec.builderFor(SCHEMA).month(\"date\").build();\n+\n+    assertProjectionStrictValue(spec, lessThan(\"date\", date), Expression.Operation.FALSE);\n+    assertProjectionStrictValue(spec, lessThanOrEqual(\"date\", date), Expression.Operation.FALSE);\n+    assertProjectionStrict(spec, greaterThan(\"date\", date), Expression.Operation.GT, \"1969-12\");\n+    assertProjectionStrict(spec, greaterThanOrEqual(\"date\", date), Expression.Operation.GT, \"1969-12\");\n+    assertProjectionStrict(spec, notEqual(\"date\", date), Expression.Operation.NOT_IN, \"[1969-12, 1970-01]\");\n+    assertProjectionStrictValue(spec, equal(\"date\", date), Expression.Operation.FALSE);\n+\n+    Integer anotherDate = (Integer) Literal.of(\"1970-01-01\").to(TYPE).value();\n+    assertProjectionStrict(spec, notIn(\"date\", date, anotherDate),\n+        Expression.Operation.NOT_IN, \"[1969-12, 1970-01]\");", "originalCommit": "a0b88165344b50f90cd60359287f8c5f7e5dadbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyMzc5MQ==", "url": "https://github.com/apache/iceberg/pull/1981#discussion_r549823791", "bodyText": "I updated the other test to use a lower bound that is not 1970-01-01 and also added tests specifically for epoch values. This still conflicted with the epoch test, so I changed it to use 1969-11-01.", "author": "rdblue", "createdAt": "2020-12-29T19:37:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NTkzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b4eb6e6dff84c35e02884e73d8de6bc34c9e6565", "chunk": "diff --git a/api/src/test/java/org/apache/iceberg/transforms/TestDatesProjection.java b/api/src/test/java/org/apache/iceberg/transforms/TestDatesProjection.java\nindex ede55dc08..15830d658 100644\n--- a/api/src/test/java/org/apache/iceberg/transforms/TestDatesProjection.java\n+++ b/api/src/test/java/org/apache/iceberg/transforms/TestDatesProjection.java\n\n@@ -173,9 +209,9 @@ public class TestDatesProjection {\n     assertProjectionStrict(spec, notEqual(\"date\", date), Expression.Operation.NOT_IN, \"[1969-12, 1970-01]\");\n     assertProjectionStrictValue(spec, equal(\"date\", date), Expression.Operation.FALSE);\n \n-    Integer anotherDate = (Integer) Literal.of(\"1970-01-01\").to(TYPE).value();\n+    Integer anotherDate = (Integer) Literal.of(\"1969-11-01\").to(TYPE).value();\n     assertProjectionStrict(spec, notIn(\"date\", date, anotherDate),\n-        Expression.Operation.NOT_IN, \"[1969-12, 1970-01]\");\n+        Expression.Operation.NOT_IN, \"[1969-11, 1969-12, 1970-01]\");\n     assertProjectionStrictValue(spec, in(\"date\", date, anotherDate), Expression.Operation.FALSE);\n   }\n \n"}}, {"oid": "caad9b5564e9f342a35273f56ab7cf1fce85bc6d", "url": "https://github.com/apache/iceberg/commit/caad9b5564e9f342a35273f56ab7cf1fce85bc6d", "message": "Fix checkstyle.", "committedDate": "2020-12-29T18:46:34Z", "type": "commit"}, {"oid": "b4eb6e6dff84c35e02884e73d8de6bc34c9e6565", "url": "https://github.com/apache/iceberg/commit/b4eb6e6dff84c35e02884e73d8de6bc34c9e6565", "message": "Add more tests.", "committedDate": "2020-12-29T19:37:57Z", "type": "commit"}, {"oid": "146ff9e1aebe19d40ca76a849d39fd3432919ae2", "url": "https://github.com/apache/iceberg/commit/146ff9e1aebe19d40ca76a849d39fd3432919ae2", "message": "Add docs for the projection fix methods.", "committedDate": "2020-12-29T19:51:45Z", "type": "commit"}, {"oid": "146ff9e1aebe19d40ca76a849d39fd3432919ae2", "url": "https://github.com/apache/iceberg/commit/146ff9e1aebe19d40ca76a849d39fd3432919ae2", "message": "Add docs for the projection fix methods.", "committedDate": "2020-12-29T19:51:45Z", "type": "forcePushed"}, {"oid": "816218928c7fbcddd39b24e5b9e6d675ab6521b0", "url": "https://github.com/apache/iceberg/commit/816218928c7fbcddd39b24e5b9e6d675ab6521b0", "message": "Fix strict GT and GT_EQ projections.", "committedDate": "2020-12-29T20:12:25Z", "type": "commit"}, {"oid": "98a9f9b577e62668accda6a109e75eea3d71dcdd", "url": "https://github.com/apache/iceberg/commit/98a9f9b577e62668accda6a109e75eea3d71dcdd", "message": "Fix LT and LT_EQ strict projection.", "committedDate": "2020-12-29T20:30:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNDA0Mw==", "url": "https://github.com/apache/iceberg/pull/1981#discussion_r552934043", "bodyText": "Seems the same logic (if (condition) {return...} return ...) appears multiple times, can it be included inside a method, e.g. just embed it in the method defined in ProjectionUtil?", "author": "jun-he", "createdAt": "2021-01-06T19:59:19Z", "path": "api/src/main/java/org/apache/iceberg/transforms/Dates.java", "diffHunk": "@@ -99,11 +107,24 @@ public boolean satisfiesOrderOf(Transform<?, ?> other) {\n \n     if (pred.isUnaryPredicate()) {\n       return Expressions.predicate(pred.op(), fieldName);\n+\n     } else if (pred.isLiteralPredicate()) {\n-      return ProjectionUtil.truncateInteger(fieldName, pred.asLiteralPredicate(), this);\n+      UnboundPredicate<Integer> projected = ProjectionUtil.truncateInteger(fieldName, pred.asLiteralPredicate(), this);\n+      if (this != DAY) {", "originalCommit": "98a9f9b577e62668accda6a109e75eea3d71dcdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjMwNDU2NQ==", "url": "https://github.com/apache/iceberg/pull/1981#discussion_r562304565", "bodyText": "There are only 4 instance of this, and they call 2 different fix methods. I don't think it would be worth adding 2 methods just to dedup 4 lines here.", "author": "rdblue", "createdAt": "2021-01-22T01:13:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNDA0Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNjM3OA==", "url": "https://github.com/apache/iceberg/pull/1981#discussion_r552936378", "bodyText": "nit: extract 1_000_000 and 1000 to be a constant with meaningful name or use predefined ones in java library.", "author": "jun-he", "createdAt": "2021-01-06T20:04:59Z", "path": "api/src/main/java/org/apache/iceberg/transforms/Timestamps.java", "diffHunk": "@@ -52,12 +52,23 @@ public Integer apply(Long timestampMicros) {\n       return null;\n     }\n \n-    // discards fractional seconds, not needed for calculation\n-    OffsetDateTime timestamp = Instant\n-        .ofEpochSecond(timestampMicros / 1_000_000)\n-        .atOffset(ZoneOffset.UTC);\n-\n-    return (int) granularity.between(EPOCH, timestamp);\n+    if (timestampMicros >= 0) {\n+      OffsetDateTime timestamp = Instant\n+          .ofEpochSecond(\n+              Math.floorDiv(timestampMicros, 1_000_000),\n+              Math.floorMod(timestampMicros, 1_000_000) * 1000)", "originalCommit": "98a9f9b577e62668accda6a109e75eea3d71dcdd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzOTkwMg==", "url": "https://github.com/apache/iceberg/pull/1981#discussion_r552939902", "bodyText": "why not just always return this new expression? We build up fixedSet no matter what?", "author": "RussellSpitzer", "createdAt": "2021-01-06T20:13:33Z", "path": "api/src/main/java/org/apache/iceberg/transforms/ProjectionUtil.java", "diffHunk": "@@ -254,4 +257,145 @@ private ProjectionUtil() {\n     return predicate(predicate.op(), fieldName,\n         Iterables.transform(predicate.asSetPredicate().literalSet(), transform::apply));\n   }\n+\n+  /**\n+   * Fixes an inclusive projection to account for incorrectly transformed values.\n+   * <p>\n+   * A bug in 0.10.0 and earlier caused negative values to be incorrectly transformed by date and timestamp transforms\n+   * to 1 larger than the correct value. For example, day(1969-12-31 10:00:00) produced 0 instead of -1. To read data\n+   * written by versions with this bug, this method adjusts the inclusive projection. The current inclusive projection\n+   * is correct, so this modifies the \"correct\" projection when needed. For example, < day(1969-12-31 10:00:00) will\n+   * produce <= -1 (= 1969-12-31) and is adjusted to <= 0 (= 1969-01-01) because the incorrect transformed value was 0.\n+   */\n+  static UnboundPredicate<Integer> fixInclusiveTimeProjection(UnboundPredicate<Integer> projected) {\n+    if (projected == null) {\n+      return projected;\n+    }\n+\n+    // adjust the predicate for values that were 1 larger than the correct transformed value\n+    switch (projected.op()) {\n+      case LT:\n+        if (projected.literal().value() < 0) {\n+          return Expressions.lessThan(projected.term(), projected.literal().value() + 1);\n+        }\n+\n+        return projected;\n+\n+      case LT_EQ:\n+        if (projected.literal().value() < 0) {\n+          return Expressions.lessThanOrEqual(projected.term(), projected.literal().value() + 1);\n+        }\n+\n+        return projected;\n+\n+      case GT:\n+      case GT_EQ:\n+        // incorrect projected values are already greater than the bound for GT, GT_EQ\n+        return projected;\n+\n+      case EQ:\n+        if (projected.literal().value() < 0) {\n+          // match either the incorrect value (projectedValue + 1) or the correct value (projectedValue)\n+          return Expressions.in(projected.term(), projected.literal().value(), projected.literal().value() + 1);\n+        }\n+\n+        return projected;\n+\n+      case IN:\n+        Set<Integer> fixedSet = Sets.newHashSet();\n+        boolean hasNegativeValue = false;\n+        for (Literal<Integer> lit : projected.literals()) {\n+          Integer value = lit.value();\n+          fixedSet.add(value);\n+          if (value < 0) {\n+            hasNegativeValue = true;\n+            fixedSet.add(value + 1);\n+          }\n+        }\n+\n+        if (hasNegativeValue) {\n+          return Expressions.in(projected.term(), fixedSet);", "originalCommit": "98a9f9b577e62668accda6a109e75eea3d71dcdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwODI1Ng==", "url": "https://github.com/apache/iceberg/pull/1981#discussion_r553008256", "bodyText": "If there is no negative value, then there is no need to fixup the expression and we can return the original. That avoids some object allocation?", "author": "rdblue", "createdAt": "2021-01-06T23:03:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzOTkwMg=="}], "type": "inlineReview", "revised_code": null}]}