{"pr_number": 1919, "pr_title": "Add UpdatePartitionSpec implementation", "pr_createdAt": "2020-12-12T01:57:32Z", "pr_url": "https://github.com/apache/iceberg/pull/1919", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ3NDM1Mg==", "url": "https://github.com/apache/iceberg/pull/1919#discussion_r541474352", "bodyText": "Needed to add fields using Transform, not a string.", "author": "rdblue", "createdAt": "2020-12-12T01:58:07Z", "path": "api/src/main/java/org/apache/iceberg/PartitionSpec.java", "diffHunk": "@@ -480,9 +481,13 @@ Builder add(int sourceId, String name, String transform) {\n \n     Builder add(int sourceId, int fieldId, String name, String transform) {\n       Types.NestedField column = schema.findField(sourceId);\n-      checkAndAddPartitionName(name, column.fieldId());\n       Preconditions.checkNotNull(column, \"Cannot find source column: %s\", sourceId);\n-      fields.add(new PartitionField(sourceId, fieldId, name, Transforms.fromString(column.type(), transform)));\n+      return add(sourceId, fieldId, name, Transforms.fromString(column.type(), transform));\n+    }\n+\n+    Builder add(int sourceId, int fieldId, String name, Transform<?, ?> transform) {", "originalCommit": "9d39ee11d4066100bb8d1cf9e5899dec2d37635d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ3NDM5OQ==", "url": "https://github.com/apache/iceberg/pull/1919#discussion_r541474399", "bodyText": "Needed to allow identity partitions that have been deleted.", "author": "rdblue", "createdAt": "2020-12-12T01:58:27Z", "path": "api/src/main/java/org/apache/iceberg/PartitionSpec.java", "diffHunk": "@@ -463,8 +464,8 @@ public Builder truncate(String sourceName, int width) {\n     }\n \n     public Builder alwaysNull(String sourceName, String targetName) {\n-      checkAndAddPartitionName(targetName);\n       Types.NestedField sourceColumn = findSourceColumn(sourceName);\n+      checkAndAddPartitionName(targetName, sourceColumn.fieldId()); // can duplicate a source column name", "originalCommit": "9d39ee11d4066100bb8d1cf9e5899dec2d37635d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ3NDQ1MQ==", "url": "https://github.com/apache/iceberg/pull/1919#discussion_r541474451", "bodyText": "Will add Javadoc for these methods after there is agreement on this API.", "author": "rdblue", "createdAt": "2020-12-12T01:58:45Z", "path": "api/src/main/java/org/apache/iceberg/UpdatePartitionSpec.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.apache.iceberg.expressions.Term;\n+\n+/**\n+ * API for partition spec evolution.\n+ * <p>\n+ * When committing, these changes will be applied to the current table metadata. Commit conflicts\n+ * will not be resolved and will result in a {@link CommitFailedException}.\n+ */\n+public interface UpdatePartitionSpec extends PendingUpdate<PartitionSpec> {\n+  UpdatePartitionSpec addField(String sourceName);", "originalCommit": "9d39ee11d4066100bb8d1cf9e5899dec2d37635d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b14153359eb8513b32df74fb68dbc002ae505145", "chunk": "diff --git a/api/src/main/java/org/apache/iceberg/UpdatePartitionSpec.java b/api/src/main/java/org/apache/iceberg/UpdatePartitionSpec.java\nindex 2a8452ce1..d15c272e1 100644\n--- a/api/src/main/java/org/apache/iceberg/UpdatePartitionSpec.java\n+++ b/api/src/main/java/org/apache/iceberg/UpdatePartitionSpec.java\n\n@@ -1,29 +1,20 @@\n /*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n  *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n  *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n  */\n \n package org.apache.iceberg;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ3NDU5OA==", "url": "https://github.com/apache/iceberg/pull/1919#discussion_r541474598", "bodyText": "Refactored this out of the method above to visit individual fields, for setting default partition names based on the transform.", "author": "rdblue", "createdAt": "2020-12-12T01:59:31Z", "path": "api/src/main/java/org/apache/iceberg/transforms/PartitionSpecVisitor.java", "diffHunk": "@@ -113,37 +113,43 @@ default T unknown(int fieldId, String sourceName, int sourceId, String transform\n    * @deprecated this will be removed in 0.11.0; use {@link #visit(PartitionSpec, PartitionSpecVisitor)} instead.\n    */\n   @Deprecated\n-  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n   static <R> List<R> visit(Schema schema, PartitionSpec spec, PartitionSpecVisitor<R> visitor) {\n     List<R> results = Lists.newArrayListWithExpectedSize(spec.fields().size());\n \n     for (PartitionField field : spec.fields()) {\n-      String sourceName = schema.findColumnName(field.sourceId());\n-      Transform<?, ?> transform = field.transform();\n-\n-      if (transform instanceof Identity) {\n-        results.add(visitor.identity(field.fieldId(), sourceName, field.sourceId()));\n-      } else if (transform instanceof Bucket) {\n-        int numBuckets = ((Bucket<?>) transform).numBuckets();\n-        results.add(visitor.bucket(field.fieldId(), sourceName, field.sourceId(), numBuckets));\n-      } else if (transform instanceof Truncate) {\n-        int width = ((Truncate<?>) transform).width();\n-        results.add(visitor.truncate(field.fieldId(), sourceName, field.sourceId(), width));\n-      } else if (transform == Dates.YEAR || transform == Timestamps.YEAR) {\n-        results.add(visitor.year(field.fieldId(), sourceName, field.sourceId()));\n-      } else if (transform == Dates.MONTH || transform == Timestamps.MONTH) {\n-        results.add(visitor.month(field.fieldId(), sourceName, field.sourceId()));\n-      } else if (transform == Dates.DAY || transform == Timestamps.DAY) {\n-        results.add(visitor.day(field.fieldId(), sourceName, field.sourceId()));\n-      } else if (transform == Timestamps.HOUR) {\n-        results.add(visitor.hour(field.fieldId(), sourceName, field.sourceId()));\n-      } else if (transform instanceof VoidTransform) {\n-        results.add(visitor.alwaysNull(field.fieldId(), sourceName, field.sourceId()));\n-      } else if (transform instanceof UnknownTransform) {\n-        results.add(visitor.unknown(field.fieldId(), sourceName, field.sourceId(), transform.toString()));\n-      }\n+      results.add(visit(schema, field, visitor));\n     }\n \n     return results;\n   }\n+\n+  static <R> R visit(Schema schema, PartitionField field, PartitionSpecVisitor<R> visitor) {", "originalCommit": "9d39ee11d4066100bb8d1cf9e5899dec2d37635d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b14153359eb8513b32df74fb68dbc002ae505145", "chunk": "diff --git a/api/src/main/java/org/apache/iceberg/transforms/PartitionSpecVisitor.java b/api/src/main/java/org/apache/iceberg/transforms/PartitionSpecVisitor.java\nindex 92b942d6c..1770a22a3 100644\n--- a/api/src/main/java/org/apache/iceberg/transforms/PartitionSpecVisitor.java\n+++ b/api/src/main/java/org/apache/iceberg/transforms/PartitionSpecVisitor.java\n\n@@ -123,6 +123,7 @@ public interface PartitionSpecVisitor<T> {\n     return results;\n   }\n \n+  @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n   static <R> R visit(Schema schema, PartitionField field, PartitionSpecVisitor<R> visitor) {\n     String sourceName = schema.findColumnName(field.sourceId());\n     Transform<?, ?> transform = field.transform();\n"}}, {"oid": "b14153359eb8513b32df74fb68dbc002ae505145", "url": "https://github.com/apache/iceberg/commit/b14153359eb8513b32df74fb68dbc002ae505145", "message": "Add UpdatePartitionSpec implementation.", "committedDate": "2020-12-12T02:01:21Z", "type": "forcePushed"}, {"oid": "d1bd036b01c1a84548664cddc4e3fa395b8e7c14", "url": "https://github.com/apache/iceberg/commit/d1bd036b01c1a84548664cddc4e3fa395b8e7c14", "message": "Add UpdatePartitionSpec implementation.", "committedDate": "2020-12-12T21:11:41Z", "type": "commit"}, {"oid": "d1bd036b01c1a84548664cddc4e3fa395b8e7c14", "url": "https://github.com/apache/iceberg/commit/d1bd036b01c1a84548664cddc4e3fa395b8e7c14", "message": "Add UpdatePartitionSpec implementation.", "committedDate": "2020-12-12T21:11:41Z", "type": "forcePushed"}, {"oid": "a0e9dcd6aa9655619ff8855b377393ac7943bb1a", "url": "https://github.com/apache/iceberg/commit/a0e9dcd6aa9655619ff8855b377393ac7943bb1a", "message": "Add tests and fix context messages.", "committedDate": "2020-12-12T21:21:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTgwMjIyMw==", "url": "https://github.com/apache/iceberg/pull/1919#discussion_r541802223", "bodyText": "Maybe add a test for .removeField(\"myField\").addField(\"myField\")? What's the expected outcome for that?", "author": "johnclara", "createdAt": "2020-12-12T23:33:10Z", "path": "core/src/test/java/org/apache/iceberg/TestUpdatePartitionSpecV1.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.expressions.Expressions.bucket;\n+import static org.apache.iceberg.expressions.Expressions.day;\n+import static org.apache.iceberg.expressions.Expressions.hour;\n+import static org.apache.iceberg.expressions.Expressions.month;\n+import static org.apache.iceberg.expressions.Expressions.ref;\n+import static org.apache.iceberg.expressions.Expressions.truncate;\n+import static org.apache.iceberg.expressions.Expressions.year;\n+\n+public class TestUpdatePartitionSpecV1 {", "originalCommit": "a0e9dcd6aa9655619ff8855b377393ac7943bb1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYzNjU2MQ==", "url": "https://github.com/apache/iceberg/pull/1919#discussion_r542636561", "bodyText": "The expected result of any combination should be the same as if the two were done as separate changes, except for cases that signal some problem. For example, renaming a field and deleting the original field shows that there are two conflicting changes, even though we could apply one and then fail the second.\nI agree that this should have a test for that case, as well as possibly some additional checks for consistency with rename.", "author": "rdblue", "createdAt": "2020-12-14T18:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTgwMjIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcxNzUzMw==", "url": "https://github.com/apache/iceberg/pull/1919#discussion_r542717533", "bodyText": "Cool, so would order matter?\nis .removeField(\"myField\").addField(\"myField\") different from .addField(\"myField\").removeField(\"myField\")?", "author": "johnclara", "createdAt": "2020-12-14T20:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTgwMjIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg0NDUwNA==", "url": "https://github.com/apache/iceberg/pull/1919#discussion_r542844504", "bodyText": "Yes. Imagine I have partition shard=bucket(id, 16) and ran .removeField(\"shard\").addField(\"shard\", bucket(id, 32)). That replaces a 16-bin bucket scheme with a 32-bin bucket scheme. The opposite would add a bucket partition and then remove it, which looks like a mistake. So the second one would be rejected, the first would be allowed.", "author": "rdblue", "createdAt": "2020-12-14T22:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTgwMjIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUxMjkwMQ==", "url": "https://github.com/apache/iceberg/pull/1919#discussion_r543512901", "bodyText": "I added quite a few more test cases for situations like this and improved error messages. Now, if you attempt to rename a field that was added you get an error that clearly says you can't rename an added field, instead of an error that says the field is unknown. Same thing for combinations of adds and deletes.\nI also added a check to not allow adding duplicate time columns, like days(\"ts\") and hours(\"ts\"). That's allowed if the partition already existed, but not when adding partition fields.", "author": "rdblue", "createdAt": "2020-12-15T16:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTgwMjIyMw=="}], "type": "inlineReview", "revised_code": {"commit": "1b1d1c8829b2dd53730b41aa12f0967fd24f854b", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/TestUpdatePartitionSpecV1.java b/core/src/test/java/org/apache/iceberg/TestUpdatePartitionSpecV1.java\ndeleted file mode 100644\nindex 5f5b14e36..000000000\n--- a/core/src/test/java/org/apache/iceberg/TestUpdatePartitionSpecV1.java\n+++ /dev/null\n\n@@ -1,444 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.iceberg;\n-\n-import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n-import org.apache.iceberg.transforms.Transforms;\n-import org.apache.iceberg.types.Types;\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n-import static org.apache.iceberg.expressions.Expressions.bucket;\n-import static org.apache.iceberg.expressions.Expressions.day;\n-import static org.apache.iceberg.expressions.Expressions.hour;\n-import static org.apache.iceberg.expressions.Expressions.month;\n-import static org.apache.iceberg.expressions.Expressions.ref;\n-import static org.apache.iceberg.expressions.Expressions.truncate;\n-import static org.apache.iceberg.expressions.Expressions.year;\n-\n-public class TestUpdatePartitionSpecV1 {\n-  private static final Schema SCHEMA = new Schema(\n-      Types.NestedField.required(1, \"id\", Types.LongType.get()),\n-      Types.NestedField.required(2, \"ts\", Types.TimestampType.withZone()),\n-      Types.NestedField.required(3, \"category\", Types.StringType.get()),\n-      Types.NestedField.optional(4, \"data\", Types.StringType.get())\n-  );\n-\n-  private static final int FORMAT_VERSION = 1;\n-  private static final PartitionSpec UNPARTITIONED = PartitionSpec.builderFor(SCHEMA).build();\n-  private static final PartitionSpec PARTITIONED = PartitionSpec.builderFor(SCHEMA)\n-      .identity(\"category\")\n-      .day(\"ts\")\n-      .bucket(\"id\", 16, \"shard\")\n-      .build();\n-\n-  @Test\n-  public void testAddIdentityByName() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, UNPARTITIONED)\n-        .addField(\"category\")\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .identity(\"category\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testAddIdentityByTerm() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, UNPARTITIONED)\n-        .addField(ref(\"category\"))\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .identity(\"category\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testAddYear() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, UNPARTITIONED)\n-        .addField(year(\"ts\"))\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .year(\"ts\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testAddMonth() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, UNPARTITIONED)\n-        .addField(month(\"ts\"))\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .month(\"ts\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testAddDay() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, UNPARTITIONED)\n-        .addField(day(\"ts\"))\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .day(\"ts\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testAddHour() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, UNPARTITIONED)\n-        .addField(hour(\"ts\"))\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .hour(\"ts\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testAddBucket() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, UNPARTITIONED)\n-        .addField(bucket(\"id\", 16))\n-        .apply();\n-\n-    // added fields have different default names to avoid conflicts\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .bucket(\"id\", 16, \"id_bucket_16\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testAddTruncate() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, UNPARTITIONED)\n-        .addField(truncate(\"data\", 4))\n-        .apply();\n-\n-    // added fields have different default names to avoid conflicts\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .truncate(\"data\", 4, \"data_trunc_4\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testAddNamedPartition() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, UNPARTITIONED)\n-        .addField(\"shard\", bucket(\"id\", 16))\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .bucket(\"id\", 16, \"shard\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testAddToExisting() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-        .addField(truncate(\"data\", 4))\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .identity(\"category\")\n-        .day(\"ts\")\n-        .bucket(\"id\", 16, \"shard\")\n-        .truncate(\"data\", 4, \"data_trunc_4\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testMultipleAdds() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, UNPARTITIONED)\n-        .addField(\"category\")\n-        .addField(day(\"ts\"))\n-        .addField(\"shard\", bucket(\"id\", 16))\n-        .addField(\"prefix\", truncate(\"data\", 4))\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .identity(\"category\")\n-        .day(\"ts\")\n-        .bucket(\"id\", 16, \"shard\")\n-        .truncate(\"data\", 4, \"prefix\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testAddHourToDay() {\n-    // multiple partitions for the same source with different time granularity is not allowed by the builder, but is\n-    // allowed when updating a spec so that existing columns in metadata continue to work.\n-    PartitionSpec byDay = new BaseUpdatePartitionSpec(FORMAT_VERSION, UNPARTITIONED)\n-        .addField(day(\"ts\"))\n-        .apply();\n-\n-    PartitionSpec byHour = new BaseUpdatePartitionSpec(FORMAT_VERSION, byDay)\n-        .addField(hour(\"ts\"))\n-        .apply();\n-\n-    Assert.assertEquals(\"Should have a day and an hour time field\",\n-        ImmutableList.of(\n-            new PartitionField(2, 1000, \"ts_day\", Transforms.day(Types.TimestampType.withZone())),\n-            new PartitionField(2, 1001, \"ts_hour\", Transforms.hour(Types.TimestampType.withZone()))),\n-        byHour.fields());\n-  }\n-\n-  @Test\n-  public void testAddMultipleBuckets() {\n-    PartitionSpec bucket16 = new BaseUpdatePartitionSpec(FORMAT_VERSION, UNPARTITIONED)\n-        .addField(bucket(\"id\", 16))\n-        .apply();\n-\n-    PartitionSpec bucket8 = new BaseUpdatePartitionSpec(FORMAT_VERSION, bucket16)\n-        .addField(bucket(\"id\", 8))\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .bucket(\"id\", 16, \"id_bucket_16\")\n-        .bucket(\"id\", 8, \"id_bucket_8\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should have a day and an hour time field\", expected, bucket8);\n-  }\n-\n-  @Test\n-  public void testRemoveIdentityByName() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-        .removeField(\"category\")\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .alwaysNull(\"category\", \"category\")\n-        .day(\"ts\")\n-        .bucket(\"id\", 16, \"shard\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testRemoveBucketByName() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-        .removeField(\"shard\")\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .identity(\"category\")\n-        .day(\"ts\")\n-        .alwaysNull(\"id\", \"shard\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testRemoveIdentityByEquivalent() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-        .removeField(ref(\"category\"))\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .alwaysNull(\"category\", \"category\")\n-        .day(\"ts\")\n-        .bucket(\"id\", 16, \"shard\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testRemoveDayByEquivalent() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-        .removeField(day(\"ts\"))\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .identity(\"category\")\n-        .alwaysNull(\"ts\", \"ts_day\")\n-        .bucket(\"id\", 16, \"shard\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testRemoveBucketByEquivalent() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-        .removeField(bucket(\"id\", 16))\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .identity(\"category\")\n-        .day(\"ts\")\n-        .alwaysNull(\"id\", \"shard\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testRename() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-        .renameField(\"shard\", \"id_bucket\") // rename back to default\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .identity(\"category\")\n-        .day(\"ts\")\n-        .bucket(\"id\", 16)\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testMultipleChanges() {\n-    PartitionSpec updated = new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-        .renameField(\"shard\", \"id_bucket\") // rename back to default\n-        .removeField(day(\"ts\"))\n-        .addField(\"prefix\", truncate(\"data\", 4))\n-        .apply();\n-\n-    PartitionSpec expected = PartitionSpec.builderFor(SCHEMA)\n-        .identity(\"category\")\n-        .alwaysNull(\"ts\", \"ts_day\")\n-        .bucket(\"id\", 16)\n-        .truncate(\"data\", 4, \"prefix\")\n-        .build();\n-\n-    Assert.assertEquals(\"Should match expected spec\", expected, updated);\n-  }\n-\n-  @Test\n-  public void testAddDuplicateByName() {\n-    AssertHelpers.assertThrows(\"Should fail adding a duplicate field\",\n-        IllegalArgumentException.class, \"Cannot add duplicate partition field\",\n-        () -> new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-            .addField(\"category\"));\n-  }\n-\n-  @Test\n-  public void testAddDuplicateByRef() {\n-    AssertHelpers.assertThrows(\"Should fail adding a duplicate field\",\n-        IllegalArgumentException.class, \"Cannot add duplicate partition field\",\n-        () -> new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-            .addField(ref(\"category\")));\n-  }\n-\n-  @Test\n-  public void testAddDuplicateTransform() {\n-    AssertHelpers.assertThrows(\"Should fail adding a duplicate field\",\n-        IllegalArgumentException.class, \"Cannot add duplicate partition field\",\n-        () -> new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-            .addField(bucket(\"id\", 16)));\n-  }\n-\n-  @Test\n-  public void testAddNamedDuplicate() {\n-    AssertHelpers.assertThrows(\"Should fail adding a duplicate field\",\n-        IllegalArgumentException.class, \"Cannot add duplicate partition field\",\n-        () -> new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-            .addField(\"b16\", bucket(\"id\", 16)));\n-  }\n-\n-  @Test\n-  public void testRemoveUnknownFieldByName() {\n-    AssertHelpers.assertThrows(\"Should fail trying to remove unknown field\",\n-        IllegalArgumentException.class, \"Cannot find partition field to remove\",\n-        () -> new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED).removeField(\"moon\")\n-    );\n-  }\n-\n-  @Test\n-  public void testRemoveUnknownFieldAfterAdd() {\n-    AssertHelpers.assertThrows(\"Should fail trying to remove unknown field\",\n-        IllegalArgumentException.class, \"Cannot find partition field to remove\",\n-        () -> new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-            .addField(\"data_trunc\", truncate(\"data\", 4))\n-            .removeField(\"data_trunc\")\n-    );\n-  }\n-\n-  @Test\n-  public void testRemoveUnknownFieldByEquivalent() {\n-    AssertHelpers.assertThrows(\"Should fail trying to remove unknown field\",\n-        IllegalArgumentException.class, \"Cannot find partition field to remove\",\n-        () -> new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED).removeField(hour(\"ts\")) // day(ts) exists\n-    );\n-  }\n-\n-  @Test\n-  public void testRenameUnknownField() {\n-    AssertHelpers.assertThrows(\"Should fail trying to rename an unknown field\",\n-        IllegalArgumentException.class, \"Cannot find partition field to rename\",\n-        () -> new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED).renameField(\"shake\", \"seal\")\n-    );\n-  }\n-\n-  @Test\n-  public void testRenameAfterAdd() {\n-    AssertHelpers.assertThrows(\"Should fail trying to rename an added field\",\n-        IllegalArgumentException.class, \"Cannot find partition field to rename\",\n-        () -> new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-            .addField(\"data_trunc\", truncate(\"data\", 4))\n-            .renameField(\"data_trunc\", \"prefix\")\n-    );\n-  }\n-\n-  @Test\n-  public void testDeleteAndRename() {\n-    AssertHelpers.assertThrows(\"Should fail trying to rename a deleted field\",\n-        IllegalArgumentException.class, \"Cannot rename and delete partition field\",\n-        () -> new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-            .renameField(\"shard\", \"id_bucket\")\n-            .removeField(bucket(\"id\", 16)));\n-  }\n-\n-  @Test\n-  public void testRenameAndDelete() {\n-    AssertHelpers.assertThrows(\"Should fail trying to delete a renamed field\",\n-        IllegalArgumentException.class, \"Cannot delete and rename partition field\",\n-        () -> new BaseUpdatePartitionSpec(FORMAT_VERSION, PARTITIONED)\n-            .removeField(bucket(\"id\", 16))\n-            .renameField(\"shard\", \"id_bucket\"));\n-  }\n-}\n"}}, {"oid": "1b1d1c8829b2dd53730b41aa12f0967fd24f854b", "url": "https://github.com/apache/iceberg/commit/1b1d1c8829b2dd53730b41aa12f0967fd24f854b", "message": "Combine v1 and v2 tests.", "committedDate": "2020-12-15T01:37:21Z", "type": "commit"}, {"oid": "cdf03c979d516ef736888f82569fea4697afa597", "url": "https://github.com/apache/iceberg/commit/cdf03c979d516ef736888f82569fea4697afa597", "message": "Add more test cases.", "committedDate": "2020-12-15T16:26:39Z", "type": "commit"}, {"oid": "ce56c319ce3403a6d4ae5f498257534d5ddc08ab", "url": "https://github.com/apache/iceberg/commit/ce56c319ce3403a6d4ae5f498257534d5ddc08ab", "message": "Catch duplicate time partitions and improve error messages.", "committedDate": "2020-12-15T16:45:23Z", "type": "commit"}]}