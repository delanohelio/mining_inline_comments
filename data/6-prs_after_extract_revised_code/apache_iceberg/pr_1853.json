{"pr_number": 1853, "pr_title": "Core: Add utility StructLikeMap.", "pr_createdAt": "2020-11-30T14:08:24Z", "pr_url": "https://github.com/apache/iceberg/pull/1853", "timeline": [{"oid": "a5c4e3a3fc53f0ec89480d6596fb263afd19b8f6", "url": "https://github.com/apache/iceberg/commit/a5c4e3a3fc53f0ec89480d6596fb263afd19b8f6", "message": "Core: Add utility StructLikeMap.", "committedDate": "2020-11-30T14:06:50Z", "type": "commit"}, {"oid": "b155f239669cc69843eea331a764d3221ced7eb6", "url": "https://github.com/apache/iceberg/commit/b155f239669cc69843eea331a764d3221ced7eb6", "message": "Minor fixes", "committedDate": "2020-11-30T15:27:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzNTYxMw==", "url": "https://github.com/apache/iceberg/pull/1853#discussion_r532935613", "bodyText": "is ThreadLocal serializable? Should StructLikeMap be?", "author": "johnclara", "createdAt": "2020-11-30T22:08:59Z", "path": "core/src/main/java/org/apache/iceberg/util/StructLikeMap.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.util;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.iceberg.StructLike;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.types.Types;\n+\n+public class StructLikeMap<T> extends AbstractMap<StructLike, T> implements Map<StructLike, T> {\n+\n+  public static <T> StructLikeMap<T> create(Types.StructType type) {\n+    return new StructLikeMap<>(type);\n+  }\n+\n+  private final Types.StructType type;\n+  private final Map<StructLikeWrapper, T> wrapperMap;\n+  private final ThreadLocal<StructLikeWrapper> wrappers;", "originalCommit": "b155f239669cc69843eea331a764d3221ced7eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNDA3Nw==", "url": "https://github.com/apache/iceberg/pull/1853#discussion_r533024077", "bodyText": "The StructLikeMap is used for locating inserted row's the file/position, pls see here.  We want to write the file/pos into positional files when encountering a delete which will delete the row that has been inserted in same txn.\nHere, the StructLikeMap don't have to be serializable. For flink,  we will use the RowDataTaskWriterFactory to construct the IcebergStreamWriter,  we will require the factory to be serializable , the TaskWriter don't have to. So finally the StructLikeMap  also don't have to be serializable.", "author": "openinx", "createdAt": "2020-12-01T02:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzNTYxMw=="}], "type": "inlineReview", "revised_code": {"commit": "3b8d48edbe592f4031c9fc2d29ab63dd21c18a3e", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/util/StructLikeMap.java b/core/src/main/java/org/apache/iceberg/util/StructLikeMap.java\nindex d11553705..a3114bafa 100644\n--- a/core/src/main/java/org/apache/iceberg/util/StructLikeMap.java\n+++ b/core/src/main/java/org/apache/iceberg/util/StructLikeMap.java\n\n@@ -60,7 +60,7 @@ public class StructLikeMap<T> extends AbstractMap<StructLike, T> implements Map<\n     if (key instanceof StructLike) {\n       StructLikeWrapper wrapper = wrappers.get();\n       boolean result = wrapperMap.containsKey(wrapper.set((StructLike) key));\n-      wrapper.set(null);\n+      wrapper.set(null); // don't hold a reference to the key.\n       return result;\n     }\n     return false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1NDYwMg==", "url": "https://github.com/apache/iceberg/pull/1853#discussion_r532954602", "bodyText": "Comment should be \"don't hold a reference to the key\".", "author": "rdblue", "createdAt": "2020-11-30T22:49:59Z", "path": "core/src/main/java/org/apache/iceberg/util/StructLikeMap.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.util;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.iceberg.StructLike;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.types.Types;\n+\n+public class StructLikeMap<T> extends AbstractMap<StructLike, T> implements Map<StructLike, T> {\n+\n+  public static <T> StructLikeMap<T> create(Types.StructType type) {\n+    return new StructLikeMap<>(type);\n+  }\n+\n+  private final Types.StructType type;\n+  private final Map<StructLikeWrapper, T> wrapperMap;\n+  private final ThreadLocal<StructLikeWrapper> wrappers;\n+\n+  private StructLikeMap(Types.StructType type) {\n+    this.type = type;\n+    this.wrapperMap = Maps.newHashMap();\n+    this.wrappers = ThreadLocal.withInitial(() -> StructLikeWrapper.forType(type));\n+  }\n+\n+  @Override\n+  public int size() {\n+    return wrapperMap.size();\n+  }\n+\n+  @Override\n+  public boolean isEmpty() {\n+    return wrapperMap.isEmpty();\n+  }\n+\n+  @Override\n+  public boolean containsKey(Object key) {\n+    if (key instanceof StructLike) {\n+      StructLikeWrapper wrapper = wrappers.get();\n+      boolean result = wrapperMap.containsKey(wrapper.set((StructLike) key));\n+      wrapper.set(null);\n+      return result;\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean containsValue(Object value) {\n+    return wrapperMap.containsValue(value);\n+  }\n+\n+  @Override\n+  public T get(Object key) {\n+    if (key instanceof StructLike) {\n+      StructLikeWrapper wrapper = wrappers.get();\n+      T value = wrapperMap.get(wrapper.set((StructLike) key));\n+      wrapper.set(null);\n+      return value;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public T put(StructLike key, T value) {\n+    return wrapperMap.put(StructLikeWrapper.forType(type).set(key), value);\n+  }\n+\n+  @Override\n+  public T remove(Object key) {\n+    if (key instanceof StructLike) {\n+      StructLikeWrapper wrapper = wrappers.get();\n+      T value = wrapperMap.remove(wrapper.set((StructLike) key));\n+      wrapper.set(null); // don't hold a reference to the value.", "originalCommit": "b155f239669cc69843eea331a764d3221ced7eb6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b8d48edbe592f4031c9fc2d29ab63dd21c18a3e", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/util/StructLikeMap.java b/core/src/main/java/org/apache/iceberg/util/StructLikeMap.java\nindex d11553705..a3114bafa 100644\n--- a/core/src/main/java/org/apache/iceberg/util/StructLikeMap.java\n+++ b/core/src/main/java/org/apache/iceberg/util/StructLikeMap.java\n\n@@ -60,7 +60,7 @@ public class StructLikeMap<T> extends AbstractMap<StructLike, T> implements Map<\n     if (key instanceof StructLike) {\n       StructLikeWrapper wrapper = wrappers.get();\n       boolean result = wrapperMap.containsKey(wrapper.set((StructLike) key));\n-      wrapper.set(null);\n+      wrapper.set(null); // don't hold a reference to the key.\n       return result;\n     }\n     return false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwMjIzNg==", "url": "https://github.com/apache/iceberg/pull/1853#discussion_r533002236", "bodyText": "This can be delegated to the implementation in AbstractMap, since put will automatically wrap the key.", "author": "rdblue", "createdAt": "2020-12-01T00:56:04Z", "path": "core/src/main/java/org/apache/iceberg/util/StructLikeMap.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.util;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.iceberg.StructLike;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.types.Types;\n+\n+public class StructLikeMap<T> extends AbstractMap<StructLike, T> implements Map<StructLike, T> {\n+\n+  public static <T> StructLikeMap<T> create(Types.StructType type) {\n+    return new StructLikeMap<>(type);\n+  }\n+\n+  private final Types.StructType type;\n+  private final Map<StructLikeWrapper, T> wrapperMap;\n+  private final ThreadLocal<StructLikeWrapper> wrappers;\n+\n+  private StructLikeMap(Types.StructType type) {\n+    this.type = type;\n+    this.wrapperMap = Maps.newHashMap();\n+    this.wrappers = ThreadLocal.withInitial(() -> StructLikeWrapper.forType(type));\n+  }\n+\n+  @Override\n+  public int size() {\n+    return wrapperMap.size();\n+  }\n+\n+  @Override\n+  public boolean isEmpty() {\n+    return wrapperMap.isEmpty();\n+  }\n+\n+  @Override\n+  public boolean containsKey(Object key) {\n+    if (key instanceof StructLike) {\n+      StructLikeWrapper wrapper = wrappers.get();\n+      boolean result = wrapperMap.containsKey(wrapper.set((StructLike) key));\n+      wrapper.set(null);\n+      return result;\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean containsValue(Object value) {\n+    return wrapperMap.containsValue(value);\n+  }\n+\n+  @Override\n+  public T get(Object key) {\n+    if (key instanceof StructLike) {\n+      StructLikeWrapper wrapper = wrappers.get();\n+      T value = wrapperMap.get(wrapper.set((StructLike) key));\n+      wrapper.set(null);\n+      return value;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public T put(StructLike key, T value) {\n+    return wrapperMap.put(StructLikeWrapper.forType(type).set(key), value);\n+  }\n+\n+  @Override\n+  public T remove(Object key) {\n+    if (key instanceof StructLike) {\n+      StructLikeWrapper wrapper = wrappers.get();\n+      T value = wrapperMap.remove(wrapper.set((StructLike) key));\n+      wrapper.set(null); // don't hold a reference to the value.\n+      return value;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public void putAll(Map<? extends StructLike, ? extends T> keyValues) {", "originalCommit": "b155f239669cc69843eea331a764d3221ced7eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNDgxOQ==", "url": "https://github.com/apache/iceberg/pull/1853#discussion_r533024819", "bodyText": "Make sense !", "author": "openinx", "createdAt": "2020-12-01T02:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwMjIzNg=="}], "type": "inlineReview", "revised_code": {"commit": "3b8d48edbe592f4031c9fc2d29ab63dd21c18a3e", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/util/StructLikeMap.java b/core/src/main/java/org/apache/iceberg/util/StructLikeMap.java\nindex d11553705..a3114bafa 100644\n--- a/core/src/main/java/org/apache/iceberg/util/StructLikeMap.java\n+++ b/core/src/main/java/org/apache/iceberg/util/StructLikeMap.java\n\n@@ -60,7 +60,7 @@ public class StructLikeMap<T> extends AbstractMap<StructLike, T> implements Map<\n     if (key instanceof StructLike) {\n       StructLikeWrapper wrapper = wrappers.get();\n       boolean result = wrapperMap.containsKey(wrapper.set((StructLike) key));\n-      wrapper.set(null);\n+      wrapper.set(null); // don't hold a reference to the key.\n       return result;\n     }\n     return false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwMjk0NA==", "url": "https://github.com/apache/iceberg/pull/1853#discussion_r533002944", "bodyText": "Could you break this method into multiple test cases?\nA single long method hides problems because it can only fail once, while a suite of test cases that each focuses on one thing can show more information from a test run.", "author": "rdblue", "createdAt": "2020-12-01T00:58:22Z", "path": "core/src/test/java/org/apache/iceberg/util/TestStructLikeMap.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.util;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.iceberg.StructLike;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestStructLikeMap {\n+\n+  @Test\n+  public void testSimpleData() {", "originalCommit": "b155f239669cc69843eea331a764d3221ced7eb6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b8d48edbe592f4031c9fc2d29ab63dd21c18a3e", "chunk": "diff --git a/core/src/test/java/org/apache/iceberg/util/TestStructLikeMap.java b/core/src/test/java/org/apache/iceberg/util/TestStructLikeMap.java\nindex a32e9fda8..7aba8ed7a 100644\n--- a/core/src/test/java/org/apache/iceberg/util/TestStructLikeMap.java\n+++ b/core/src/test/java/org/apache/iceberg/util/TestStructLikeMap.java\n\n@@ -33,21 +33,17 @@ import org.junit.Assert;\n import org.junit.Test;\n \n public class TestStructLikeMap {\n+  private static final Types.StructType STRUCT_TYPE = Types.StructType.of(\n+      Types.NestedField.required(1, \"id\", Types.IntegerType.get()),\n+      Types.NestedField.optional(2, \"data\", Types.LongType.get())\n+  );\n \n   @Test\n-  public void testSimpleData() {\n-    Types.StructType structType = Types.StructType.of(\n-        Types.NestedField.required(1, \"id\", Types.IntegerType.get()),\n-        Types.NestedField.optional(2, \"data\", Types.LongType.get())\n-    );\n-    Record gRecord = GenericRecord.create(structType);\n+  public void testSingleRecord() {\n+    Record gRecord = GenericRecord.create(STRUCT_TYPE);\n     Record record1 = gRecord.copy(ImmutableMap.of(\"id\", 1, \"data\", \"aaa\"));\n-    Record record2 = gRecord.copy(ImmutableMap.of(\"id\", 2, \"data\", \"bbb\"));\n-    Record record3 = gRecord.copy();\n-    record3.setField(\"id\", 3);\n-    record3.setField(\"data\", null);\n \n-    Map<StructLike, String> map = StructLikeMap.create(structType);\n+    Map<StructLike, String> map = StructLikeMap.create(STRUCT_TYPE);\n     Assert.assertEquals(0, map.size());\n \n     map.put(record1, \"1-aaa\");\n"}}, {"oid": "3b8d48edbe592f4031c9fc2d29ab63dd21c18a3e", "url": "https://github.com/apache/iceberg/commit/3b8d48edbe592f4031c9fc2d29ab63dd21c18a3e", "message": "Addressing the comments.", "committedDate": "2020-12-01T02:59:16Z", "type": "commit"}]}