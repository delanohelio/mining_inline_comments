{"pr_number": 928, "pr_title": "Add failure handling in cleanup while reading snapshot manifest-list files", "pr_createdAt": "2020-04-15T22:04:29Z", "pr_url": "https://github.com/apache/iceberg/pull/928", "timeline": [{"oid": "7d6e98cf8ada1decedd63cc95403d79d6538923b", "url": "https://github.com/apache/iceberg/commit/7d6e98cf8ada1decedd63cc95403d79d6538923b", "message": "Add failure handling in cleanup while reading snapshot manifest-list files", "committedDate": "2020-04-15T21:53:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4Nzc4NQ==", "url": "https://github.com/apache/iceberg/pull/928#discussion_r409187785", "bodyText": "Why no retry? Because this adds to a set, it could retry without negative consequences.", "author": "rdblue", "createdAt": "2020-04-15T23:14:31Z", "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -201,112 +201,121 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n     // find manifests to clean up that are still referenced by a valid snapshot, but written by an expired snapshot\n     Set<String> validManifests = Sets.newHashSet();\n     Set<ManifestFile> manifestsToScan = Sets.newHashSet();\n-    for (Snapshot snapshot : snapshots) {\n-      try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n-        for (ManifestFile manifest : manifests) {\n-          validManifests.add(manifest.path());\n-\n-          long snapshotId = manifest.snapshotId();\n-          // whether the manifest was created by a valid snapshot (true) or an expired snapshot (false)\n-          boolean fromValidSnapshots = validIds.contains(snapshotId);\n-          // whether the snapshot that created the manifest was an ancestor of the table state\n-          boolean isFromAncestor = ancestorIds.contains(snapshotId);\n-          // whether the changes in this snapshot have been picked into the current table state\n-          boolean isPicked = pickedAncestorSnapshotIds.contains(snapshotId);\n-          // if the snapshot that wrote this manifest is no longer valid (has expired), then delete its deleted files.\n-          // note that this is only for expired snapshots that are in the current table state\n-          if (!fromValidSnapshots && (isFromAncestor || isPicked) && manifest.hasDeletedFiles()) {\n-            manifestsToScan.add(manifest.copy());\n-          }\n-        }\n-\n-      } catch (IOException e) {\n-        throw new RuntimeIOException(e,\n-            \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n-      }\n-    }\n+    Tasks.foreach(snapshots).noRetry().suppressFailureWhenFinished()", "originalCommit": "7d6e98cf8ada1decedd63cc95403d79d6538923b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNjkzMQ==", "url": "https://github.com/apache/iceberg/pull/928#discussion_r409706931", "bodyText": "Added.   Is there a reason we don't retry when findingFilesToDelete, deleteMetadataFiles and deleteDataFiles, should we add retries there as well?", "author": "prodeezy", "createdAt": "2020-04-16T16:54:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4Nzc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcxNzczMg==", "url": "https://github.com/apache/iceberg/pull/928#discussion_r409717732", "bodyText": "I think we should retry in findFilesToDelete. The most important part to retry is locating the files that need to be deleted. Not reading a manifest list could lead to hundreds of orphaned files.\nI think the original rationale for not retrying when deleting a file was that we expect more failures there from files that have already been deleted. If a file is missing, then we shouldn't try to delete it 4 times... but other than in our environment where we use bucket policy in some places I'm not sure where that might happen. Also, the deletes for metadata files that have probably been read should be retried.\nSo I think it's reasonable to add a retry for the delete methods, too.", "author": "rdblue", "createdAt": "2020-04-16T17:12:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4Nzc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc0OTc1NQ==", "url": "https://github.com/apache/iceberg/pull/928#discussion_r409749755", "bodyText": "Added with a guard on deletes for NotFoundException.", "author": "prodeezy", "createdAt": "2020-04-16T18:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4Nzc4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d1d6581e09f3448c789238feb5aec1189f3bb206", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java b/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\nindex ad67c429f..cb41a61e0 100644\n--- a/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\n+++ b/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\n\n@@ -201,9 +201,10 @@ class RemoveSnapshots implements ExpireSnapshots {\n     // find manifests to clean up that are still referenced by a valid snapshot, but written by an expired snapshot\n     Set<String> validManifests = Sets.newHashSet();\n     Set<ManifestFile> manifestsToScan = Sets.newHashSet();\n-    Tasks.foreach(snapshots).noRetry().suppressFailureWhenFinished()\n-        .onFailure((snapshot, exc) -> LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\",\n-            snapshot.snapshotId(), snapshot.manifestListLocation(), exc))\n+    Tasks.foreach(snapshots).retry(3).suppressFailureWhenFinished()\n+        .onFailure((snapshot, exc) ->\n+            LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\", snapshot.snapshotId(),\n+                snapshot.manifestListLocation(), exc))\n         .run(\n             snapshot -> {\n               try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4ODA4Nw==", "url": "https://github.com/apache/iceberg/pull/928#discussion_r409188087", "bodyText": "This indentation seems a bit awkward to me because the arguments are indented so much less than the LOG.warn call. What about moving LOG.warn to the next line and indenting its arguments to make it obvious what the args are passed to?", "author": "rdblue", "createdAt": "2020-04-15T23:15:29Z", "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -201,112 +201,121 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n     // find manifests to clean up that are still referenced by a valid snapshot, but written by an expired snapshot\n     Set<String> validManifests = Sets.newHashSet();\n     Set<ManifestFile> manifestsToScan = Sets.newHashSet();\n-    for (Snapshot snapshot : snapshots) {\n-      try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n-        for (ManifestFile manifest : manifests) {\n-          validManifests.add(manifest.path());\n-\n-          long snapshotId = manifest.snapshotId();\n-          // whether the manifest was created by a valid snapshot (true) or an expired snapshot (false)\n-          boolean fromValidSnapshots = validIds.contains(snapshotId);\n-          // whether the snapshot that created the manifest was an ancestor of the table state\n-          boolean isFromAncestor = ancestorIds.contains(snapshotId);\n-          // whether the changes in this snapshot have been picked into the current table state\n-          boolean isPicked = pickedAncestorSnapshotIds.contains(snapshotId);\n-          // if the snapshot that wrote this manifest is no longer valid (has expired), then delete its deleted files.\n-          // note that this is only for expired snapshots that are in the current table state\n-          if (!fromValidSnapshots && (isFromAncestor || isPicked) && manifest.hasDeletedFiles()) {\n-            manifestsToScan.add(manifest.copy());\n-          }\n-        }\n-\n-      } catch (IOException e) {\n-        throw new RuntimeIOException(e,\n-            \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n-      }\n-    }\n+    Tasks.foreach(snapshots).noRetry().suppressFailureWhenFinished()\n+        .onFailure((snapshot, exc) -> LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\",", "originalCommit": "7d6e98cf8ada1decedd63cc95403d79d6538923b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNDkxMQ==", "url": "https://github.com/apache/iceberg/pull/928#discussion_r409704911", "bodyText": "Fixed.", "author": "prodeezy", "createdAt": "2020-04-16T16:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4ODA4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d1d6581e09f3448c789238feb5aec1189f3bb206", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java b/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\nindex ad67c429f..cb41a61e0 100644\n--- a/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\n+++ b/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\n\n@@ -201,9 +201,10 @@ class RemoveSnapshots implements ExpireSnapshots {\n     // find manifests to clean up that are still referenced by a valid snapshot, but written by an expired snapshot\n     Set<String> validManifests = Sets.newHashSet();\n     Set<ManifestFile> manifestsToScan = Sets.newHashSet();\n-    Tasks.foreach(snapshots).noRetry().suppressFailureWhenFinished()\n-        .onFailure((snapshot, exc) -> LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\",\n-            snapshot.snapshotId(), snapshot.manifestListLocation(), exc))\n+    Tasks.foreach(snapshots).retry(3).suppressFailureWhenFinished()\n+        .onFailure((snapshot, exc) ->\n+            LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\", snapshot.snapshotId(),\n+                snapshot.manifestListLocation(), exc))\n         .run(\n             snapshot -> {\n               try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4ODU4OA==", "url": "https://github.com/apache/iceberg/pull/928#discussion_r409188588", "bodyText": "Same here. Wouldn't it be better to retry?", "author": "rdblue", "createdAt": "2020-04-15T23:16:59Z", "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -201,112 +201,121 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n     // find manifests to clean up that are still referenced by a valid snapshot, but written by an expired snapshot\n     Set<String> validManifests = Sets.newHashSet();\n     Set<ManifestFile> manifestsToScan = Sets.newHashSet();\n-    for (Snapshot snapshot : snapshots) {\n-      try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n-        for (ManifestFile manifest : manifests) {\n-          validManifests.add(manifest.path());\n-\n-          long snapshotId = manifest.snapshotId();\n-          // whether the manifest was created by a valid snapshot (true) or an expired snapshot (false)\n-          boolean fromValidSnapshots = validIds.contains(snapshotId);\n-          // whether the snapshot that created the manifest was an ancestor of the table state\n-          boolean isFromAncestor = ancestorIds.contains(snapshotId);\n-          // whether the changes in this snapshot have been picked into the current table state\n-          boolean isPicked = pickedAncestorSnapshotIds.contains(snapshotId);\n-          // if the snapshot that wrote this manifest is no longer valid (has expired), then delete its deleted files.\n-          // note that this is only for expired snapshots that are in the current table state\n-          if (!fromValidSnapshots && (isFromAncestor || isPicked) && manifest.hasDeletedFiles()) {\n-            manifestsToScan.add(manifest.copy());\n-          }\n-        }\n-\n-      } catch (IOException e) {\n-        throw new RuntimeIOException(e,\n-            \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n-      }\n-    }\n+    Tasks.foreach(snapshots).noRetry().suppressFailureWhenFinished()\n+        .onFailure((snapshot, exc) -> LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\",\n+            snapshot.snapshotId(), snapshot.manifestListLocation(), exc))\n+        .run(\n+            snapshot -> {\n+              try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n+                for (ManifestFile manifest : manifests) {\n+                  validManifests.add(manifest.path());\n+\n+                  long snapshotId = manifest.snapshotId();\n+                  // whether the manifest was created by a valid snapshot (true) or an expired snapshot (false)\n+                  boolean fromValidSnapshots = validIds.contains(snapshotId);\n+                  // whether the snapshot that created the manifest was an ancestor of the table state\n+                  boolean isFromAncestor = ancestorIds.contains(snapshotId);\n+                  // whether the changes in this snapshot have been picked into the current table state\n+                  boolean isPicked = pickedAncestorSnapshotIds.contains(snapshotId);\n+                  // if the snapshot that wrote this manifest is no longer valid (has expired),\n+                  // then delete its deleted files. note that this is only for expired snapshots that are in the\n+                  // current table state\n+                  if (!fromValidSnapshots && (isFromAncestor || isPicked) && manifest.hasDeletedFiles()) {\n+                    manifestsToScan.add(manifest.copy());\n+                  }\n+                }\n+\n+              } catch (IOException e) {\n+                throw new RuntimeIOException(e,\n+                    \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n+              }\n+            });\n \n     // find manifests to clean up that were only referenced by snapshots that have expired\n     Set<String> manifestListsToDelete = Sets.newHashSet();\n     Set<String> manifestsToDelete = Sets.newHashSet();\n     Set<ManifestFile> manifestsToRevert = Sets.newHashSet();\n-    for (Snapshot snapshot : base.snapshots()) {\n-      long snapshotId = snapshot.snapshotId();\n-      if (!validIds.contains(snapshotId)) {\n-        // determine whether the changes in this snapshot are in the current table state\n-        if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n-          // this snapshot was cherry-picked into the current table state, so skip cleaning it up. its changes will\n-          // expire when the picked snapshot expires.\n-          // A -- C -- D (source=B)\n-          //  `- B <-- this commit\n-          continue;\n-        }\n-\n-        long sourceSnapshotId = PropertyUtil.propertyAsLong(\n-            snapshot.summary(), SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP, -1);\n-        if (ancestorIds.contains(sourceSnapshotId)) {\n-          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n-          // changes because it would revert data file additions that are in the current table.\n-          // A -- B -- C\n-          //  `- D (source=B) <-- this commit\n-          continue;\n-        }\n-\n-        if (pickedAncestorSnapshotIds.contains(sourceSnapshotId)) {\n-          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n-          // changes because it would revert data file additions that are in the current table.\n-          // A -- C -- E (source=B)\n-          //  `- B `- D (source=B) <-- this commit\n-          continue;\n-        }\n-\n-        // find any manifests that are no longer needed\n-        try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n-          for (ManifestFile manifest : manifests) {\n-            if (!validManifests.contains(manifest.path())) {\n-              manifestsToDelete.add(manifest.path());\n-\n-              boolean isFromAncestor = ancestorIds.contains(manifest.snapshotId());\n-              boolean isFromExpiringSnapshot = expiredIds.contains(manifest.snapshotId());\n-\n-              if (isFromAncestor && manifest.hasDeletedFiles()) {\n-                // Only delete data files that were deleted in by an expired snapshot if that\n-                // snapshot is an ancestor of the current table state. Otherwise, a snapshot that\n-                // deleted files and was rolled back will delete files that could be in the current\n-                // table state.\n-                manifestsToScan.add(manifest.copy());\n+    Tasks.foreach(base.snapshots()).noRetry().suppressFailureWhenFinished()", "originalCommit": "7d6e98cf8ada1decedd63cc95403d79d6538923b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNDk0NA==", "url": "https://github.com/apache/iceberg/pull/928#discussion_r409704944", "bodyText": "Done.", "author": "prodeezy", "createdAt": "2020-04-16T16:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4ODU4OA=="}], "type": "inlineReview", "revised_code": {"commit": "d1d6581e09f3448c789238feb5aec1189f3bb206", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java b/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\nindex ad67c429f..cb41a61e0 100644\n--- a/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\n+++ b/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\n\n@@ -201,9 +201,10 @@ class RemoveSnapshots implements ExpireSnapshots {\n     // find manifests to clean up that are still referenced by a valid snapshot, but written by an expired snapshot\n     Set<String> validManifests = Sets.newHashSet();\n     Set<ManifestFile> manifestsToScan = Sets.newHashSet();\n-    Tasks.foreach(snapshots).noRetry().suppressFailureWhenFinished()\n-        .onFailure((snapshot, exc) -> LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\",\n-            snapshot.snapshotId(), snapshot.manifestListLocation(), exc))\n+    Tasks.foreach(snapshots).retry(3).suppressFailureWhenFinished()\n+        .onFailure((snapshot, exc) ->\n+            LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\", snapshot.snapshotId(),\n+                snapshot.manifestListLocation(), exc))\n         .run(\n             snapshot -> {\n               try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4ODY1Mw==", "url": "https://github.com/apache/iceberg/pull/928#discussion_r409188653", "bodyText": "+1", "author": "rdblue", "createdAt": "2020-04-15T23:17:13Z", "path": "core/src/main/java/org/apache/iceberg/RemoveSnapshots.java", "diffHunk": "@@ -201,112 +201,121 @@ private void cleanExpiredFiles(List<Snapshot> snapshots, Set<Long> validIds, Set\n     // find manifests to clean up that are still referenced by a valid snapshot, but written by an expired snapshot\n     Set<String> validManifests = Sets.newHashSet();\n     Set<ManifestFile> manifestsToScan = Sets.newHashSet();\n-    for (Snapshot snapshot : snapshots) {\n-      try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n-        for (ManifestFile manifest : manifests) {\n-          validManifests.add(manifest.path());\n-\n-          long snapshotId = manifest.snapshotId();\n-          // whether the manifest was created by a valid snapshot (true) or an expired snapshot (false)\n-          boolean fromValidSnapshots = validIds.contains(snapshotId);\n-          // whether the snapshot that created the manifest was an ancestor of the table state\n-          boolean isFromAncestor = ancestorIds.contains(snapshotId);\n-          // whether the changes in this snapshot have been picked into the current table state\n-          boolean isPicked = pickedAncestorSnapshotIds.contains(snapshotId);\n-          // if the snapshot that wrote this manifest is no longer valid (has expired), then delete its deleted files.\n-          // note that this is only for expired snapshots that are in the current table state\n-          if (!fromValidSnapshots && (isFromAncestor || isPicked) && manifest.hasDeletedFiles()) {\n-            manifestsToScan.add(manifest.copy());\n-          }\n-        }\n-\n-      } catch (IOException e) {\n-        throw new RuntimeIOException(e,\n-            \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n-      }\n-    }\n+    Tasks.foreach(snapshots).noRetry().suppressFailureWhenFinished()\n+        .onFailure((snapshot, exc) -> LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\",\n+            snapshot.snapshotId(), snapshot.manifestListLocation(), exc))\n+        .run(\n+            snapshot -> {\n+              try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n+                for (ManifestFile manifest : manifests) {\n+                  validManifests.add(manifest.path());\n+\n+                  long snapshotId = manifest.snapshotId();\n+                  // whether the manifest was created by a valid snapshot (true) or an expired snapshot (false)\n+                  boolean fromValidSnapshots = validIds.contains(snapshotId);\n+                  // whether the snapshot that created the manifest was an ancestor of the table state\n+                  boolean isFromAncestor = ancestorIds.contains(snapshotId);\n+                  // whether the changes in this snapshot have been picked into the current table state\n+                  boolean isPicked = pickedAncestorSnapshotIds.contains(snapshotId);\n+                  // if the snapshot that wrote this manifest is no longer valid (has expired),\n+                  // then delete its deleted files. note that this is only for expired snapshots that are in the\n+                  // current table state\n+                  if (!fromValidSnapshots && (isFromAncestor || isPicked) && manifest.hasDeletedFiles()) {\n+                    manifestsToScan.add(manifest.copy());\n+                  }\n+                }\n+\n+              } catch (IOException e) {\n+                throw new RuntimeIOException(e,\n+                    \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n+              }\n+            });\n \n     // find manifests to clean up that were only referenced by snapshots that have expired\n     Set<String> manifestListsToDelete = Sets.newHashSet();\n     Set<String> manifestsToDelete = Sets.newHashSet();\n     Set<ManifestFile> manifestsToRevert = Sets.newHashSet();\n-    for (Snapshot snapshot : base.snapshots()) {\n-      long snapshotId = snapshot.snapshotId();\n-      if (!validIds.contains(snapshotId)) {\n-        // determine whether the changes in this snapshot are in the current table state\n-        if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n-          // this snapshot was cherry-picked into the current table state, so skip cleaning it up. its changes will\n-          // expire when the picked snapshot expires.\n-          // A -- C -- D (source=B)\n-          //  `- B <-- this commit\n-          continue;\n-        }\n-\n-        long sourceSnapshotId = PropertyUtil.propertyAsLong(\n-            snapshot.summary(), SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP, -1);\n-        if (ancestorIds.contains(sourceSnapshotId)) {\n-          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n-          // changes because it would revert data file additions that are in the current table.\n-          // A -- B -- C\n-          //  `- D (source=B) <-- this commit\n-          continue;\n-        }\n-\n-        if (pickedAncestorSnapshotIds.contains(sourceSnapshotId)) {\n-          // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n-          // changes because it would revert data file additions that are in the current table.\n-          // A -- C -- E (source=B)\n-          //  `- B `- D (source=B) <-- this commit\n-          continue;\n-        }\n-\n-        // find any manifests that are no longer needed\n-        try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n-          for (ManifestFile manifest : manifests) {\n-            if (!validManifests.contains(manifest.path())) {\n-              manifestsToDelete.add(manifest.path());\n-\n-              boolean isFromAncestor = ancestorIds.contains(manifest.snapshotId());\n-              boolean isFromExpiringSnapshot = expiredIds.contains(manifest.snapshotId());\n-\n-              if (isFromAncestor && manifest.hasDeletedFiles()) {\n-                // Only delete data files that were deleted in by an expired snapshot if that\n-                // snapshot is an ancestor of the current table state. Otherwise, a snapshot that\n-                // deleted files and was rolled back will delete files that could be in the current\n-                // table state.\n-                manifestsToScan.add(manifest.copy());\n+    Tasks.foreach(base.snapshots()).noRetry().suppressFailureWhenFinished()\n+        .onFailure((snapshot, exc) -> LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\",\n+            snapshot.snapshotId(), snapshot.manifestListLocation(), exc))\n+        .run(\n+            snapshot -> {\n+              long snapshotId = snapshot.snapshotId();\n+              if (!validIds.contains(snapshotId)) {\n+                // determine whether the changes in this snapshot are in the current table state\n+                if (pickedAncestorSnapshotIds.contains(snapshotId)) {\n+                  // this snapshot was cherry-picked into the current table state, so skip cleaning it up.\n+                  // its changes will expire when the picked snapshot expires.\n+                  // A -- C -- D (source=B)\n+                  //  `- B <-- this commit\n+                  return;\n+                }\n+\n+                long sourceSnapshotId = PropertyUtil.propertyAsLong(\n+                    snapshot.summary(), SnapshotSummary.SOURCE_SNAPSHOT_ID_PROP, -1);\n+                if (ancestorIds.contains(sourceSnapshotId)) {\n+                  // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n+                  // changes because it would revert data file additions that are in the current table.\n+                  // A -- B -- C\n+                  //  `- D (source=B) <-- this commit\n+                  return;\n+                }\n+\n+                if (pickedAncestorSnapshotIds.contains(sourceSnapshotId)) {\n+                  // this commit was cherry-picked from a commit that is in the current table state. do not clean up its\n+                  // changes because it would revert data file additions that are in the current table.\n+                  // A -- C -- E (source=B)\n+                  //  `- B `- D (source=B) <-- this commit\n+                  return;\n+                }\n+\n+                // find any manifests that are no longer needed\n+                try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n+                  for (ManifestFile manifest : manifests) {\n+                    if (!validManifests.contains(manifest.path())) {\n+                      manifestsToDelete.add(manifest.path());\n+\n+                      boolean isFromAncestor = ancestorIds.contains(manifest.snapshotId());\n+                      boolean isFromExpiringSnapshot = expiredIds.contains(manifest.snapshotId());\n+\n+                      if (isFromAncestor && manifest.hasDeletedFiles()) {\n+                        // Only delete data files that were deleted in by an expired snapshot if that\n+                        // snapshot is an ancestor of the current table state. Otherwise, a snapshot that\n+                        // deleted files and was rolled back will delete files that could be in the current\n+                        // table state.\n+                        manifestsToScan.add(manifest.copy());\n+                      }\n+\n+                      if (!isFromAncestor && isFromExpiringSnapshot && manifest.hasAddedFiles()) {\n+                        // Because the manifest was written by a snapshot that is not an ancestor of the\n+                        // current table state, the files added in this manifest can be removed. The extra\n+                        // check whether the manifest was written by a known snapshot that was expired in\n+                        // this commit ensures that the full ancestor list between when the snapshot was\n+                        // written and this expiration is known and there is no missing history. If history\n+                        // were missing, then the snapshot could be an ancestor of the table state but the\n+                        // ancestor ID set would not contain it and this would be unsafe.\n+                        manifestsToRevert.add(manifest.copy());\n+                      }\n+                    }\n+                  }\n+                } catch (IOException e) {\n+                  throw new RuntimeIOException(e,\n+                      \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n+                }\n+\n+                // add the manifest list to the delete set, if present\n+                if (snapshot.manifestListLocation() != null) {\n+                  manifestListsToDelete.add(snapshot.manifestListLocation());\n+                }\n               }\n-\n-              if (!isFromAncestor && isFromExpiringSnapshot && manifest.hasAddedFiles()) {\n-                // Because the manifest was written by a snapshot that is not an ancestor of the\n-                // current table state, the files added in this manifest can be removed. The extra\n-                // check whether the manifest was written by a known snapshot that was expired in\n-                // this commit ensures that the full ancestor list between when the snapshot was\n-                // written and this expiration is known and there is no missing history. If history\n-                // were missing, then the snapshot could be an ancestor of the table state but the\n-                // ancestor ID set would not contain it and this would be unsafe.\n-                manifestsToRevert.add(manifest.copy());\n-              }\n-            }\n-          }\n-        } catch (IOException e) {\n-          throw new RuntimeIOException(e,\n-              \"Failed to close manifest list: %s\", snapshot.manifestListLocation());\n-        }\n-\n-        // add the manifest list to the delete set, if present\n-        if (snapshot.manifestListLocation() != null) {\n-          manifestListsToDelete.add(snapshot.manifestListLocation());\n-        }\n-      }\n-    }\n-\n+            });\n     deleteDataFiles(manifestsToScan, manifestsToRevert, validIds);\n     deleteMetadataFiles(manifestsToDelete, manifestListsToDelete);\n   }\n \n   private void deleteMetadataFiles(Set<String> manifestsToDelete, Set<String> manifestListsToDelete) {\n     LOG.warn(\"Manifests to delete: {}\", Joiner.on(\", \").join(manifestsToDelete));\n+    LOG.warn(\"Manifests Lists to delete: {}\", Joiner.on(\", \").join(manifestListsToDelete));", "originalCommit": "7d6e98cf8ada1decedd63cc95403d79d6538923b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d1d6581e09f3448c789238feb5aec1189f3bb206", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java b/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\nindex ad67c429f..cb41a61e0 100644\n--- a/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\n+++ b/core/src/main/java/org/apache/iceberg/RemoveSnapshots.java\n\n@@ -201,9 +201,10 @@ class RemoveSnapshots implements ExpireSnapshots {\n     // find manifests to clean up that are still referenced by a valid snapshot, but written by an expired snapshot\n     Set<String> validManifests = Sets.newHashSet();\n     Set<ManifestFile> manifestsToScan = Sets.newHashSet();\n-    Tasks.foreach(snapshots).noRetry().suppressFailureWhenFinished()\n-        .onFailure((snapshot, exc) -> LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\",\n-            snapshot.snapshotId(), snapshot.manifestListLocation(), exc))\n+    Tasks.foreach(snapshots).retry(3).suppressFailureWhenFinished()\n+        .onFailure((snapshot, exc) ->\n+            LOG.warn(\"Failed on snapshot {} while reading manifest list: {}\", snapshot.snapshotId(),\n+                snapshot.manifestListLocation(), exc))\n         .run(\n             snapshot -> {\n               try (CloseableIterable<ManifestFile> manifests = readManifestFiles(snapshot)) {\n"}}, {"oid": "d1d6581e09f3448c789238feb5aec1189f3bb206", "url": "https://github.com/apache/iceberg/commit/d1d6581e09f3448c789238feb5aec1189f3bb206", "message": "Fixed Log indent and added retries when reading manifest-lists", "committedDate": "2020-04-16T16:48:53Z", "type": "commit"}, {"oid": "e24e5f2ce393b2af457cbcc57c466795beb8d6e5", "url": "https://github.com/apache/iceberg/commit/e24e5f2ce393b2af457cbcc57c466795beb8d6e5", "message": "Add retries when finding datafiles/manifests to delete, when deleting\ndatafiles/manifests. Do not retry delete if file wasn't found.", "committedDate": "2020-04-16T18:03:36Z", "type": "commit"}]}