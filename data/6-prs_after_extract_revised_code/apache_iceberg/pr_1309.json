{"pr_number": 1309, "pr_title": "Add set-based equality and position filters", "pr_createdAt": "2020-08-07T22:23:06Z", "pr_url": "https://github.com/apache/iceberg/pull/1309", "timeline": [{"oid": "57dcbd5a9794538bcf7a10722f217d024b9eb92c", "url": "https://github.com/apache/iceberg/commit/57dcbd5a9794538bcf7a10722f217d024b9eb92c", "message": "Add set-based position and equality filters.", "committedDate": "2020-08-07T22:23:41Z", "type": "forcePushed"}, {"oid": "58c57a7fbac5edbeb49fdfb8526de4a89e3ba43b", "url": "https://github.com/apache/iceberg/commit/58c57a7fbac5edbeb49fdfb8526de4a89e3ba43b", "message": "Add set-based position and equality filters.", "committedDate": "2020-08-10T22:51:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ2NDQ4Ng==", "url": "https://github.com/apache/iceberg/pull/1309#discussion_r468464486", "bodyText": "Can we have a static method toLongSet(We can optimize it to primitive long set in future) in CloseableIterable(Or some other places)?", "author": "JingsongLi", "createdAt": "2020-08-11T09:56:33Z", "path": "core/src/main/java/org/apache/iceberg/deletes/Deletes.java", "diffHunk": "@@ -50,9 +54,47 @@\n   private Deletes() {\n   }\n \n-  public static <T> CloseableIterable<T> positionFilter(CloseableIterable<T> rows, Function<T, Long> rowToPosition,\n-                                                        CloseableIterable<Long> posDeletes) {\n-    return new PositionDeleteFilter<>(rows, rowToPosition, posDeletes);\n+  public static <T> CloseableIterable<T> equalitySetFilter(CloseableIterable<T> rows,\n+                                                           Function<T, StructLike> rowToDeleteKey,\n+                                                           Types.StructType eqType,\n+                                                           CloseableIterable<StructLike> eqDeletes) {\n+    try (CloseableIterable<StructLike> deletes = eqDeletes) {\n+      CloseableIterator<StructLike> eqDeleteIterator = deletes.iterator();\n+      if (eqDeleteIterator.hasNext()) {\n+        StructLikeSet deleteSet = StructLikeSet.create(eqType);\n+        Iterators.addAll(deleteSet, eqDeleteIterator);\n+        EqualitySetDeleteFilter<T> equalityFilter = new EqualitySetDeleteFilter<>(rowToDeleteKey, deleteSet);\n+        return equalityFilter.filter(rows);\n+      } else {\n+        return rows;\n+      }\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(\"Failed to close equality delete source\", e);\n+    }\n+  }\n+\n+  public static <T> CloseableIterable<T> positionSetFilter(CloseableIterable<T> rows,\n+                                                           Function<T, Long> rowToPosition,\n+                                                           CloseableIterable<Long> posDeletes) {\n+    try (CloseableIterable<Long> deletes = posDeletes) {", "originalCommit": "58c57a7fbac5edbeb49fdfb8526de4a89e3ba43b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzMzMwNQ==", "url": "https://github.com/apache/iceberg/pull/1309#discussion_r468933305", "bodyText": "I added the set methods as you suggested, which should make this a bit cleaner. Thanks!", "author": "rdblue", "createdAt": "2020-08-12T00:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ2NDQ4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "7d6d624cd36f42b6fc84893c0db6d1eee3d49da6", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/deletes/Deletes.java b/core/src/main/java/org/apache/iceberg/deletes/Deletes.java\nindex cdcb1a535..2a181984b 100644\n--- a/core/src/main/java/org/apache/iceberg/deletes/Deletes.java\n+++ b/core/src/main/java/org/apache/iceberg/deletes/Deletes.java\n\n@@ -54,51 +54,63 @@ public class Deletes {\n   private Deletes() {\n   }\n \n-  public static <T> CloseableIterable<T> equalitySetFilter(CloseableIterable<T> rows,\n-                                                           Function<T, StructLike> rowToDeleteKey,\n-                                                           Types.StructType eqType,\n-                                                           CloseableIterable<StructLike> eqDeletes) {\n+  public static <T> CloseableIterable<T> filter(CloseableIterable<T> rows, Function<T, StructLike> rowToDeleteKey,\n+                                                StructLikeSet deleteSet) {\n+    if (deleteSet.isEmpty()) {\n+      return rows;\n+    }\n+\n+    EqualitySetDeleteFilter<T> equalityFilter = new EqualitySetDeleteFilter<>(rowToDeleteKey, deleteSet);\n+    return equalityFilter.filter(rows);\n+  }\n+\n+  public static <T> CloseableIterable<T> filter(CloseableIterable<T> rows, Function<T, Long> rowToPosition,\n+                                                Set<Long> deleteSet) {\n+    if (deleteSet.isEmpty()) {\n+      return rows;\n+    }\n+\n+    PositionSetDeleteFilter<T> filter = new PositionSetDeleteFilter<>(rowToPosition, deleteSet);\n+    return filter.filter(rows);\n+  }\n+\n+  public static StructLikeSet toEqualitySet(CloseableIterable<StructLike> eqDeletes, Types.StructType eqType) {\n     try (CloseableIterable<StructLike> deletes = eqDeletes) {\n-      CloseableIterator<StructLike> eqDeleteIterator = deletes.iterator();\n-      if (eqDeleteIterator.hasNext()) {\n-        StructLikeSet deleteSet = StructLikeSet.create(eqType);\n-        Iterators.addAll(deleteSet, eqDeleteIterator);\n-        EqualitySetDeleteFilter<T> equalityFilter = new EqualitySetDeleteFilter<>(rowToDeleteKey, deleteSet);\n-        return equalityFilter.filter(rows);\n-      } else {\n-        return rows;\n-      }\n+      StructLikeSet deleteSet = StructLikeSet.create(eqType);\n+      Iterables.addAll(deleteSet, deletes);\n+      return deleteSet;\n     } catch (IOException e) {\n       throw new UncheckedIOException(\"Failed to close equality delete source\", e);\n     }\n   }\n \n-  public static <T> CloseableIterable<T> positionSetFilter(CloseableIterable<T> rows,\n-                                                           Function<T, Long> rowToPosition,\n-                                                           CloseableIterable<Long> posDeletes) {\n+  public static Set<Long> toPositionSet(String dataLocation, CloseableIterable<StructLike> deleteFile) {\n+    return toPositionSet(dataLocation, ImmutableList.of(deleteFile));\n+  }\n+\n+  public static Set<Long> toPositionSet(String dataLocation, List<CloseableIterable<StructLike>> deleteFiles) {\n+    DataFileFilter locationFilter = new DataFileFilter(dataLocation);\n+    List<CloseableIterable<Long>> positions = Lists.transform(deleteFiles, deletes ->\n+        CloseableIterable.transform(locationFilter.filter(deletes), row -> (Long) POSITION_ACCESSOR.get(row)));\n+    return toPositionSet(CloseableIterable.concat(positions));\n+  }\n+\n+  public static Set<Long> toPositionSet(CloseableIterable<Long> posDeletes) {\n     try (CloseableIterable<Long> deletes = posDeletes) {\n-      CloseableIterator<Long> posDeleteIterator = deletes.iterator();\n-      if (posDeleteIterator.hasNext()) {\n-        Set<Long> deleteSet = Sets.newHashSet(posDeleteIterator);\n-        Iterators.addAll(deleteSet, posDeleteIterator);\n-        PositionSetDeleteFilter<T> filter = new PositionSetDeleteFilter<>(rowToPosition, deleteSet);\n-        return filter.filter(rows);\n-      } else {\n-        return rows;\n-      }\n+      return Sets.newHashSet(deletes);\n     } catch (IOException e) {\n       throw new UncheckedIOException(\"Failed to close position delete source\", e);\n     }\n   }\n \n-  public static <T> CloseableIterable<T> positionStreamFilter(CloseableIterable<T> rows,\n-                                                              Function<T, Long> rowToPosition,\n-                                                              CloseableIterable<Long> posDeletes) {\n+  public static <T> CloseableIterable<T> streamingFilter(CloseableIterable<T> rows,\n+                                                         Function<T, Long> rowToPosition,\n+                                                         CloseableIterable<Long> posDeletes) {\n     return new PositionStreamDeleteFilter<>(rows, rowToPosition, posDeletes);\n   }\n \n-  public static CloseableIterable<Long> deletePositions(String dataLocation, CloseableIterable<StructLike> posDeletes) {\n-    return deletePositions(dataLocation, ImmutableList.of(posDeletes));\n+  public static CloseableIterable<Long> deletePositions(String dataLocation, CloseableIterable<StructLike> deleteFile) {\n+    return deletePositions(dataLocation, ImmutableList.of(deleteFile));\n   }\n \n   public static CloseableIterable<Long> deletePositions(String dataLocation,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ2OTY1MQ==", "url": "https://github.com/apache/iceberg/pull/1309#discussion_r468469651", "bodyText": "Maybe this set can be reused? A set gets bigger and bigger in merging?\nSo can we have a method like addAll(CloseableIterable<StructLike>) in StructLikeSet?", "author": "JingsongLi", "createdAt": "2020-08-11T10:06:14Z", "path": "core/src/main/java/org/apache/iceberg/deletes/Deletes.java", "diffHunk": "@@ -50,9 +54,47 @@\n   private Deletes() {\n   }\n \n-  public static <T> CloseableIterable<T> positionFilter(CloseableIterable<T> rows, Function<T, Long> rowToPosition,\n-                                                        CloseableIterable<Long> posDeletes) {\n-    return new PositionDeleteFilter<>(rows, rowToPosition, posDeletes);\n+  public static <T> CloseableIterable<T> equalitySetFilter(CloseableIterable<T> rows,\n+                                                           Function<T, StructLike> rowToDeleteKey,\n+                                                           Types.StructType eqType,\n+                                                           CloseableIterable<StructLike> eqDeletes) {\n+    try (CloseableIterable<StructLike> deletes = eqDeletes) {\n+      CloseableIterator<StructLike> eqDeleteIterator = deletes.iterator();\n+      if (eqDeleteIterator.hasNext()) {\n+        StructLikeSet deleteSet = StructLikeSet.create(eqType);", "originalCommit": "58c57a7fbac5edbeb49fdfb8526de4a89e3ba43b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzMzQzMg==", "url": "https://github.com/apache/iceberg/pull/1309#discussion_r468933432", "bodyText": "I refactored this so that the filter method accepts a set. That will make them reusable.", "author": "rdblue", "createdAt": "2020-08-12T00:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ2OTY1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7d6d624cd36f42b6fc84893c0db6d1eee3d49da6", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/deletes/Deletes.java b/core/src/main/java/org/apache/iceberg/deletes/Deletes.java\nindex cdcb1a535..2a181984b 100644\n--- a/core/src/main/java/org/apache/iceberg/deletes/Deletes.java\n+++ b/core/src/main/java/org/apache/iceberg/deletes/Deletes.java\n\n@@ -54,51 +54,63 @@ public class Deletes {\n   private Deletes() {\n   }\n \n-  public static <T> CloseableIterable<T> equalitySetFilter(CloseableIterable<T> rows,\n-                                                           Function<T, StructLike> rowToDeleteKey,\n-                                                           Types.StructType eqType,\n-                                                           CloseableIterable<StructLike> eqDeletes) {\n+  public static <T> CloseableIterable<T> filter(CloseableIterable<T> rows, Function<T, StructLike> rowToDeleteKey,\n+                                                StructLikeSet deleteSet) {\n+    if (deleteSet.isEmpty()) {\n+      return rows;\n+    }\n+\n+    EqualitySetDeleteFilter<T> equalityFilter = new EqualitySetDeleteFilter<>(rowToDeleteKey, deleteSet);\n+    return equalityFilter.filter(rows);\n+  }\n+\n+  public static <T> CloseableIterable<T> filter(CloseableIterable<T> rows, Function<T, Long> rowToPosition,\n+                                                Set<Long> deleteSet) {\n+    if (deleteSet.isEmpty()) {\n+      return rows;\n+    }\n+\n+    PositionSetDeleteFilter<T> filter = new PositionSetDeleteFilter<>(rowToPosition, deleteSet);\n+    return filter.filter(rows);\n+  }\n+\n+  public static StructLikeSet toEqualitySet(CloseableIterable<StructLike> eqDeletes, Types.StructType eqType) {\n     try (CloseableIterable<StructLike> deletes = eqDeletes) {\n-      CloseableIterator<StructLike> eqDeleteIterator = deletes.iterator();\n-      if (eqDeleteIterator.hasNext()) {\n-        StructLikeSet deleteSet = StructLikeSet.create(eqType);\n-        Iterators.addAll(deleteSet, eqDeleteIterator);\n-        EqualitySetDeleteFilter<T> equalityFilter = new EqualitySetDeleteFilter<>(rowToDeleteKey, deleteSet);\n-        return equalityFilter.filter(rows);\n-      } else {\n-        return rows;\n-      }\n+      StructLikeSet deleteSet = StructLikeSet.create(eqType);\n+      Iterables.addAll(deleteSet, deletes);\n+      return deleteSet;\n     } catch (IOException e) {\n       throw new UncheckedIOException(\"Failed to close equality delete source\", e);\n     }\n   }\n \n-  public static <T> CloseableIterable<T> positionSetFilter(CloseableIterable<T> rows,\n-                                                           Function<T, Long> rowToPosition,\n-                                                           CloseableIterable<Long> posDeletes) {\n+  public static Set<Long> toPositionSet(String dataLocation, CloseableIterable<StructLike> deleteFile) {\n+    return toPositionSet(dataLocation, ImmutableList.of(deleteFile));\n+  }\n+\n+  public static Set<Long> toPositionSet(String dataLocation, List<CloseableIterable<StructLike>> deleteFiles) {\n+    DataFileFilter locationFilter = new DataFileFilter(dataLocation);\n+    List<CloseableIterable<Long>> positions = Lists.transform(deleteFiles, deletes ->\n+        CloseableIterable.transform(locationFilter.filter(deletes), row -> (Long) POSITION_ACCESSOR.get(row)));\n+    return toPositionSet(CloseableIterable.concat(positions));\n+  }\n+\n+  public static Set<Long> toPositionSet(CloseableIterable<Long> posDeletes) {\n     try (CloseableIterable<Long> deletes = posDeletes) {\n-      CloseableIterator<Long> posDeleteIterator = deletes.iterator();\n-      if (posDeleteIterator.hasNext()) {\n-        Set<Long> deleteSet = Sets.newHashSet(posDeleteIterator);\n-        Iterators.addAll(deleteSet, posDeleteIterator);\n-        PositionSetDeleteFilter<T> filter = new PositionSetDeleteFilter<>(rowToPosition, deleteSet);\n-        return filter.filter(rows);\n-      } else {\n-        return rows;\n-      }\n+      return Sets.newHashSet(deletes);\n     } catch (IOException e) {\n       throw new UncheckedIOException(\"Failed to close position delete source\", e);\n     }\n   }\n \n-  public static <T> CloseableIterable<T> positionStreamFilter(CloseableIterable<T> rows,\n-                                                              Function<T, Long> rowToPosition,\n-                                                              CloseableIterable<Long> posDeletes) {\n+  public static <T> CloseableIterable<T> streamingFilter(CloseableIterable<T> rows,\n+                                                         Function<T, Long> rowToPosition,\n+                                                         CloseableIterable<Long> posDeletes) {\n     return new PositionStreamDeleteFilter<>(rows, rowToPosition, posDeletes);\n   }\n \n-  public static CloseableIterable<Long> deletePositions(String dataLocation, CloseableIterable<StructLike> posDeletes) {\n-    return deletePositions(dataLocation, ImmutableList.of(posDeletes));\n+  public static CloseableIterable<Long> deletePositions(String dataLocation, CloseableIterable<StructLike> deleteFile) {\n+    return deletePositions(dataLocation, ImmutableList.of(deleteFile));\n   }\n \n   public static CloseableIterable<Long> deletePositions(String dataLocation,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4NDE0MA==", "url": "https://github.com/apache/iceberg/pull/1309#discussion_r468684140", "bodyText": "Good catch.", "author": "aokolnychyi", "createdAt": "2020-08-11T15:49:13Z", "path": "api/src/main/java/org/apache/iceberg/types/Comparators.java", "diffHunk": "@@ -104,7 +104,10 @@ private Comparators() {}\n \n     private StructLikeComparator(Types.StructType struct) {\n       this.comparators = struct.fields().stream()\n-          .map(field -> internal(field.type()))\n+          .map(field -> field.isOptional() ?", "originalCommit": "58c57a7fbac5edbeb49fdfb8526de4a89e3ba43b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3NzA2MQ==", "url": "https://github.com/apache/iceberg/pull/1309#discussion_r468777061", "bodyText": "I should add this to the list comparator as well.", "author": "rdblue", "createdAt": "2020-08-11T18:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4NDE0MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5MTQzNg==", "url": "https://github.com/apache/iceberg/pull/1309#discussion_r468691436", "bodyText": "I am not sure I get this part. Do we create StructLikeSet for every entry in eqDeletes?", "author": "aokolnychyi", "createdAt": "2020-08-11T16:00:07Z", "path": "core/src/main/java/org/apache/iceberg/deletes/Deletes.java", "diffHunk": "@@ -50,9 +54,47 @@\n   private Deletes() {\n   }\n \n-  public static <T> CloseableIterable<T> positionFilter(CloseableIterable<T> rows, Function<T, Long> rowToPosition,\n-                                                        CloseableIterable<Long> posDeletes) {\n-    return new PositionDeleteFilter<>(rows, rowToPosition, posDeletes);\n+  public static <T> CloseableIterable<T> equalitySetFilter(CloseableIterable<T> rows,\n+                                                           Function<T, StructLike> rowToDeleteKey,\n+                                                           Types.StructType eqType,\n+                                                           CloseableIterable<StructLike> eqDeletes) {\n+    try (CloseableIterable<StructLike> deletes = eqDeletes) {\n+      CloseableIterator<StructLike> eqDeleteIterator = deletes.iterator();\n+      if (eqDeleteIterator.hasNext()) {\n+        StructLikeSet deleteSet = StructLikeSet.create(eqType);\n+        Iterators.addAll(deleteSet, eqDeleteIterator);", "originalCommit": "58c57a7fbac5edbeb49fdfb8526de4a89e3ba43b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5NDg3OA==", "url": "https://github.com/apache/iceberg/pull/1309#discussion_r468694878", "bodyText": "No. The outer hasNext check is used to see whether we need to filter at all. If there are no equality deletes then we just return rows in the else case. This could happen if we filter the deletes using the scan predicates. If you're looking for a specific ID that is also used for a delete, then you only need to merge in the deletes with that ID.\nTo fill the delete set, we call Iterators.addAll that will add all of the remaining items from an iterator to a collection.", "author": "rdblue", "createdAt": "2020-08-11T16:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5MTQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5NjIzOA==", "url": "https://github.com/apache/iceberg/pull/1309#discussion_r468696238", "bodyText": "Got it now.", "author": "aokolnychyi", "createdAt": "2020-08-11T16:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5MTQzNg=="}], "type": "inlineReview", "revised_code": {"commit": "7d6d624cd36f42b6fc84893c0db6d1eee3d49da6", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/deletes/Deletes.java b/core/src/main/java/org/apache/iceberg/deletes/Deletes.java\nindex cdcb1a535..2a181984b 100644\n--- a/core/src/main/java/org/apache/iceberg/deletes/Deletes.java\n+++ b/core/src/main/java/org/apache/iceberg/deletes/Deletes.java\n\n@@ -54,51 +54,63 @@ public class Deletes {\n   private Deletes() {\n   }\n \n-  public static <T> CloseableIterable<T> equalitySetFilter(CloseableIterable<T> rows,\n-                                                           Function<T, StructLike> rowToDeleteKey,\n-                                                           Types.StructType eqType,\n-                                                           CloseableIterable<StructLike> eqDeletes) {\n+  public static <T> CloseableIterable<T> filter(CloseableIterable<T> rows, Function<T, StructLike> rowToDeleteKey,\n+                                                StructLikeSet deleteSet) {\n+    if (deleteSet.isEmpty()) {\n+      return rows;\n+    }\n+\n+    EqualitySetDeleteFilter<T> equalityFilter = new EqualitySetDeleteFilter<>(rowToDeleteKey, deleteSet);\n+    return equalityFilter.filter(rows);\n+  }\n+\n+  public static <T> CloseableIterable<T> filter(CloseableIterable<T> rows, Function<T, Long> rowToPosition,\n+                                                Set<Long> deleteSet) {\n+    if (deleteSet.isEmpty()) {\n+      return rows;\n+    }\n+\n+    PositionSetDeleteFilter<T> filter = new PositionSetDeleteFilter<>(rowToPosition, deleteSet);\n+    return filter.filter(rows);\n+  }\n+\n+  public static StructLikeSet toEqualitySet(CloseableIterable<StructLike> eqDeletes, Types.StructType eqType) {\n     try (CloseableIterable<StructLike> deletes = eqDeletes) {\n-      CloseableIterator<StructLike> eqDeleteIterator = deletes.iterator();\n-      if (eqDeleteIterator.hasNext()) {\n-        StructLikeSet deleteSet = StructLikeSet.create(eqType);\n-        Iterators.addAll(deleteSet, eqDeleteIterator);\n-        EqualitySetDeleteFilter<T> equalityFilter = new EqualitySetDeleteFilter<>(rowToDeleteKey, deleteSet);\n-        return equalityFilter.filter(rows);\n-      } else {\n-        return rows;\n-      }\n+      StructLikeSet deleteSet = StructLikeSet.create(eqType);\n+      Iterables.addAll(deleteSet, deletes);\n+      return deleteSet;\n     } catch (IOException e) {\n       throw new UncheckedIOException(\"Failed to close equality delete source\", e);\n     }\n   }\n \n-  public static <T> CloseableIterable<T> positionSetFilter(CloseableIterable<T> rows,\n-                                                           Function<T, Long> rowToPosition,\n-                                                           CloseableIterable<Long> posDeletes) {\n+  public static Set<Long> toPositionSet(String dataLocation, CloseableIterable<StructLike> deleteFile) {\n+    return toPositionSet(dataLocation, ImmutableList.of(deleteFile));\n+  }\n+\n+  public static Set<Long> toPositionSet(String dataLocation, List<CloseableIterable<StructLike>> deleteFiles) {\n+    DataFileFilter locationFilter = new DataFileFilter(dataLocation);\n+    List<CloseableIterable<Long>> positions = Lists.transform(deleteFiles, deletes ->\n+        CloseableIterable.transform(locationFilter.filter(deletes), row -> (Long) POSITION_ACCESSOR.get(row)));\n+    return toPositionSet(CloseableIterable.concat(positions));\n+  }\n+\n+  public static Set<Long> toPositionSet(CloseableIterable<Long> posDeletes) {\n     try (CloseableIterable<Long> deletes = posDeletes) {\n-      CloseableIterator<Long> posDeleteIterator = deletes.iterator();\n-      if (posDeleteIterator.hasNext()) {\n-        Set<Long> deleteSet = Sets.newHashSet(posDeleteIterator);\n-        Iterators.addAll(deleteSet, posDeleteIterator);\n-        PositionSetDeleteFilter<T> filter = new PositionSetDeleteFilter<>(rowToPosition, deleteSet);\n-        return filter.filter(rows);\n-      } else {\n-        return rows;\n-      }\n+      return Sets.newHashSet(deletes);\n     } catch (IOException e) {\n       throw new UncheckedIOException(\"Failed to close position delete source\", e);\n     }\n   }\n \n-  public static <T> CloseableIterable<T> positionStreamFilter(CloseableIterable<T> rows,\n-                                                              Function<T, Long> rowToPosition,\n-                                                              CloseableIterable<Long> posDeletes) {\n+  public static <T> CloseableIterable<T> streamingFilter(CloseableIterable<T> rows,\n+                                                         Function<T, Long> rowToPosition,\n+                                                         CloseableIterable<Long> posDeletes) {\n     return new PositionStreamDeleteFilter<>(rows, rowToPosition, posDeletes);\n   }\n \n-  public static CloseableIterable<Long> deletePositions(String dataLocation, CloseableIterable<StructLike> posDeletes) {\n-    return deletePositions(dataLocation, ImmutableList.of(posDeletes));\n+  public static CloseableIterable<Long> deletePositions(String dataLocation, CloseableIterable<StructLike> deleteFile) {\n+    return deletePositions(dataLocation, ImmutableList.of(deleteFile));\n   }\n \n   public static CloseableIterable<Long> deletePositions(String dataLocation,\n"}}, {"oid": "7d6d624cd36f42b6fc84893c0db6d1eee3d49da6", "url": "https://github.com/apache/iceberg/commit/7d6d624cd36f42b6fc84893c0db6d1eee3d49da6", "message": "Add set-based position and equality filters.", "committedDate": "2020-08-12T00:12:25Z", "type": "commit"}, {"oid": "7d6d624cd36f42b6fc84893c0db6d1eee3d49da6", "url": "https://github.com/apache/iceberg/commit/7d6d624cd36f42b6fc84893c0db6d1eee3d49da6", "message": "Add set-based position and equality filters.", "committedDate": "2020-08-12T00:12:25Z", "type": "forcePushed"}]}