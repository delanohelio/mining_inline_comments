{"pr_number": 1255, "pr_title": "Flink: Add Orc value reader, writer implementations", "pr_createdAt": "2020-07-27T13:17:10Z", "pr_url": "https://github.com/apache/iceberg/pull/1255", "timeline": [{"oid": "33cb24099332d577b066d8c7f657bf9ebc62cfb7", "url": "https://github.com/apache/iceberg/commit/33cb24099332d577b066d8c7f657bf9ebc62cfb7", "message": "Fix the broken unit tests.", "committedDate": "2020-07-30T02:00:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI4NjMyMw==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r462286323", "bodyText": "It seems the flinkType here was just used for exception msg at the end of primitive method right ?", "author": "simonsssu", "createdAt": "2020-07-29T13:12:01Z", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcSchemaVisitor.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.util.List;\n+import org.apache.flink.table.types.logical.ArrayType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.MapType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+abstract class FlinkOrcSchemaVisitor<T> {\n+\n+  static <T> T visit(LogicalType flinkType, Schema schema, FlinkOrcSchemaVisitor<T> visitor) {\n+    return visit(flinkType, schema.asStruct(), visitor);\n+  }\n+\n+  private static <T> T visit(LogicalType flinkType, Type iType, FlinkOrcSchemaVisitor<T> visitor) {", "originalCommit": "6708967a97cc268b36087bb7451eeded65234df8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU3NzQ1NA==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r465577454", "bodyText": "The logicalType  is mainly used for getting fields from list/map/struct.  you could see ListWriter, MapWriter, StructWriter.  we will generate a elementGetter  for ListWriter and use it to read the element of a list.", "author": "openinx", "createdAt": "2020-08-05T08:56:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI4NjMyMw=="}], "type": "inlineReview", "revised_code": {"commit": "56c6ec6cd5a11d4e37265385352b1bc34bc9d032", "chunk": "diff --git a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcSchemaVisitor.java b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkSchemaVisitor.java\nsimilarity index 85%\nrename from flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcSchemaVisitor.java\nrename to flink/src/main/java/org/apache/iceberg/flink/data/FlinkSchemaVisitor.java\nindex b8b77be53..363d2bde4 100644\n--- a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcSchemaVisitor.java\n+++ b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkSchemaVisitor.java\n\n@@ -25,17 +25,18 @@ import org.apache.flink.table.types.logical.LogicalType;\n import org.apache.flink.table.types.logical.MapType;\n import org.apache.flink.table.types.logical.RowType;\n import org.apache.iceberg.Schema;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n import org.apache.iceberg.types.Type;\n import org.apache.iceberg.types.Types;\n \n-abstract class FlinkOrcSchemaVisitor<T> {\n+abstract class FlinkSchemaVisitor<T> {\n \n-  static <T> T visit(LogicalType flinkType, Schema schema, FlinkOrcSchemaVisitor<T> visitor) {\n+  static <T> T visit(RowType flinkType, Schema schema, FlinkSchemaVisitor<T> visitor) {\n     return visit(flinkType, schema.asStruct(), visitor);\n   }\n \n-  private static <T> T visit(LogicalType flinkType, Type iType, FlinkOrcSchemaVisitor<T> visitor) {\n+  private static <T> T visit(LogicalType flinkType, Type iType, FlinkSchemaVisitor<T> visitor) {\n     switch (iType.typeId()) {\n       case STRUCT:\n         return visitRecord(flinkType, iType.asStructType(), visitor);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NzEyOQ==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r465467129", "bodyText": "Lets use proper types instead of wild cards here. For instance this will return OrcValueWriter<StringData>", "author": "rdsr", "createdAt": "2020-08-05T04:36:44Z", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriters.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.time.Instant;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.List;\n+import org.apache.flink.table.data.ArrayData;\n+import org.apache.flink.table.data.DecimalData;\n+import org.apache.flink.table.data.MapData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.StringData;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.iceberg.orc.OrcValueWriter;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.orc.storage.common.type.HiveDecimal;\n+import org.apache.orc.storage.ql.exec.vector.BytesColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.ColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.DecimalColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.ListColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.LongColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.MapColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.StructColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.TimestampColumnVector;\n+\n+class FlinkOrcWriters {\n+\n+  private FlinkOrcWriters() {\n+  }\n+\n+  static OrcValueWriter<?> strings() {", "originalCommit": "33cb24099332d577b066d8c7f657bf9ebc62cfb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU3ODY5MQ==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r465578691", "bodyText": "Agree, it's better to have an explicit parameter type.", "author": "openinx", "createdAt": "2020-08-05T08:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NzEyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "56c6ec6cd5a11d4e37265385352b1bc34bc9d032", "chunk": "diff --git a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriters.java b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriters.java\nindex 0578df492..a3919c988 100644\n--- a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriters.java\n+++ b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriters.java\n\n@@ -31,6 +31,7 @@ import org.apache.flink.table.data.StringData;\n import org.apache.flink.table.data.TimestampData;\n import org.apache.flink.table.types.logical.LogicalType;\n import org.apache.iceberg.orc.OrcValueWriter;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n import org.apache.orc.storage.common.type.HiveDecimal;\n import org.apache.orc.storage.ql.exec.vector.BytesColumnVector;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ4MTgxMg==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r465481812", "bodyText": "Seems like these are not really used. I wonder if that's a bug. As per the Iceberg spec, for decimals, scale cannot change but precision can widen. In that case, I presume we should be able to make use of the read iceberg schema's precision.  We don't have to address it here but I guess a ticket is warranted where we should see if schema evolution for decimals in ORC works correctly", "author": "rdsr", "createdAt": "2020-08-05T05:29:45Z", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcReaders.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.flink.table.data.ArrayData;\n+import org.apache.flink.table.data.DecimalData;\n+import org.apache.flink.table.data.GenericArrayData;\n+import org.apache.flink.table.data.GenericMapData;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.MapData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.StringData;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.iceberg.orc.OrcValueReader;\n+import org.apache.iceberg.orc.OrcValueReaders;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.types.Types;\n+import org.apache.orc.storage.ql.exec.vector.BytesColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.ColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.DecimalColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.ListColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.LongColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.MapColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.TimestampColumnVector;\n+import org.apache.orc.storage.serde2.io.HiveDecimalWritable;\n+\n+class FlinkOrcReaders {\n+  private FlinkOrcReaders() {\n+  }\n+\n+  static OrcValueReader<StringData> strings() {\n+    return StringReader.INSTANCE;\n+  }\n+\n+  static OrcValueReader<Integer> dates() {\n+    return DateReader.INSTANCE;\n+  }\n+\n+  static OrcValueReader<DecimalData> decimals(int precision, int scale) {\n+    if (precision <= 18) {\n+      return new Decimal18Reader(precision, scale);\n+    } else {\n+      return new Decimal38Reader(precision, scale);\n+    }\n+  }\n+\n+  static OrcValueReader<Integer> times() {\n+    return TimeReader.INSTANCE;\n+  }\n+\n+  static OrcValueReader<TimestampData> timestamps() {\n+    return TimestampReader.INSTANCE;\n+  }\n+\n+  static OrcValueReader<TimestampData> timestampTzs() {\n+    return TimestampTzReader.INSTANCE;\n+  }\n+\n+  static <T> OrcValueReader<ArrayData> array(OrcValueReader<T> elementReader) {\n+    return new ArrayReader<>(elementReader);\n+  }\n+\n+  public static <K, V> OrcValueReader<MapData> map(OrcValueReader<K> keyReader, OrcValueReader<V> valueReader) {\n+    return new MapReader<>(keyReader, valueReader);\n+  }\n+\n+  public static OrcValueReader<RowData> struct(List<OrcValueReader<?>> readers,\n+                                               Types.StructType struct,\n+                                               Map<Integer, ?> idToConstant) {\n+    return new StructReader(readers, struct, idToConstant);\n+  }\n+\n+  private static class StringReader implements OrcValueReader<StringData> {\n+    private static final StringReader INSTANCE = new StringReader();\n+\n+    @Override\n+    public StringData nonNullRead(ColumnVector vector, int row) {\n+      BytesColumnVector bytesVector = (BytesColumnVector) vector;\n+      return StringData.fromBytes(bytesVector.vector[row], bytesVector.start[row], bytesVector.length[row]);\n+    }\n+  }\n+\n+  private static class DateReader implements OrcValueReader<Integer> {\n+    private static final DateReader INSTANCE = new DateReader();\n+\n+    @Override\n+    public Integer nonNullRead(ColumnVector vector, int row) {\n+      return (int) ((LongColumnVector) vector).vector[row];\n+    }\n+  }\n+\n+  private static class Decimal18Reader implements OrcValueReader<DecimalData> {\n+    private final int precision;", "originalCommit": "33cb24099332d577b066d8c7f657bf9ebc62cfb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU3OTgyOQ==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r465579829", "bodyText": "Yeah, here we should use the precision and scale to read long from hive decimal.  it should be :\nreturn DecimalData.fromUnscaledLong(value.serialize64(scale), precision, scale);", "author": "openinx", "createdAt": "2020-08-05T09:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ4MTgxMg=="}], "type": "inlineReview", "revised_code": {"commit": "56c6ec6cd5a11d4e37265385352b1bc34bc9d032", "chunk": "diff --git a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcReaders.java b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcReaders.java\nindex e4d2a375e..a434bddfe 100644\n--- a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcReaders.java\n+++ b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcReaders.java\n\n@@ -63,8 +63,10 @@ class FlinkOrcReaders {\n   static OrcValueReader<DecimalData> decimals(int precision, int scale) {\n     if (precision <= 18) {\n       return new Decimal18Reader(precision, scale);\n-    } else {\n+    } else if (precision <= 38) {\n       return new Decimal38Reader(precision, scale);\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid precision: \" + precision);\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4Mzk0NQ==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r465883945", "bodyText": "I don't think this is related to ORC in any way. So maybe we can rename it to FlinkSchemaVisitor?", "author": "rdsr", "createdAt": "2020-08-05T17:20:51Z", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcSchemaVisitor.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.util.List;\n+import org.apache.flink.table.types.logical.ArrayType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.MapType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+abstract class FlinkOrcSchemaVisitor<T> {", "originalCommit": "3972bf4602db6d02538ea68e17cdb6181f603750", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjExNDM5Mw==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r466114393", "bodyText": "That's right, it's not bind to ORC.", "author": "openinx", "createdAt": "2020-08-06T02:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4Mzk0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "56c6ec6cd5a11d4e37265385352b1bc34bc9d032", "chunk": "diff --git a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcSchemaVisitor.java b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkSchemaVisitor.java\nsimilarity index 94%\nrename from flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcSchemaVisitor.java\nrename to flink/src/main/java/org/apache/iceberg/flink/data/FlinkSchemaVisitor.java\nindex d262d838c..363d2bde4 100644\n--- a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcSchemaVisitor.java\n+++ b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkSchemaVisitor.java\n\n@@ -30,13 +30,13 @@ import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n import org.apache.iceberg.types.Type;\n import org.apache.iceberg.types.Types;\n \n-abstract class FlinkOrcSchemaVisitor<T> {\n+abstract class FlinkSchemaVisitor<T> {\n \n-  static <T> T visit(RowType flinkType, Schema schema, FlinkOrcSchemaVisitor<T> visitor) {\n+  static <T> T visit(RowType flinkType, Schema schema, FlinkSchemaVisitor<T> visitor) {\n     return visit(flinkType, schema.asStruct(), visitor);\n   }\n \n-  private static <T> T visit(LogicalType flinkType, Type iType, FlinkOrcSchemaVisitor<T> visitor) {\n+  private static <T> T visit(LogicalType flinkType, Type iType, FlinkSchemaVisitor<T> visitor) {\n     switch (iType.typeId()) {\n       case STRUCT:\n         return visitRecord(flinkType, iType.asStructType(), visitor);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjExNTE4NQ==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r466115185", "bodyText": "for UUID type,  we flink should return GenericOrcWriters.bytes() instead of GenericOrcWriters.uuids(),  will fix this in next path.  The reader will also need to fix.", "author": "openinx", "createdAt": "2020-08-06T02:53:37Z", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriter.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.util.List;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.data.orc.GenericOrcWriters;\n+import org.apache.iceberg.orc.OrcRowWriter;\n+import org.apache.iceberg.orc.OrcValueWriter;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+import org.apache.orc.storage.ql.exec.vector.VectorizedRowBatch;\n+\n+public class FlinkOrcWriter implements OrcRowWriter<RowData> {\n+  private final FlinkOrcWriters.StructWriter writer;\n+  private final List<RowData.FieldGetter> fieldGetters;\n+\n+  private FlinkOrcWriter(RowType rowType, Schema iSchema) {\n+    this.writer = (FlinkOrcWriters.StructWriter) FlinkOrcSchemaVisitor.visit(rowType, iSchema, new WriteBuilder());\n+\n+    List<LogicalType> fieldTypes = rowType.getChildren();\n+    this.fieldGetters = Lists.newArrayListWithExpectedSize(fieldTypes.size());\n+    for (int i = 0; i < fieldTypes.size(); i++) {\n+      fieldGetters.add(RowData.createFieldGetter(fieldTypes.get(i), i));\n+    }\n+  }\n+\n+  public static OrcRowWriter<RowData> buildWriter(RowType rowType, Schema iSchema) {\n+    return new FlinkOrcWriter(rowType, iSchema);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"unchecked\")\n+  public void write(RowData row, VectorizedRowBatch output) {\n+    int rowId = output.size;\n+    output.size += 1;\n+\n+    List<OrcValueWriter<?>> writers = writer.writers();\n+    for (int c = 0; c < writers.size(); ++c) {\n+      OrcValueWriter child = writers.get(c);\n+      child.write(rowId, fieldGetters.get(c).getFieldOrNull(row), output.cols[c]);\n+    }\n+  }\n+\n+  private static class WriteBuilder extends FlinkOrcSchemaVisitor<OrcValueWriter<?>> {\n+    private WriteBuilder() {\n+    }\n+\n+    @Override\n+    public OrcValueWriter<RowData> record(Types.StructType iStruct,\n+                                          List<OrcValueWriter<?>> results,\n+                                          List<LogicalType> fieldType) {\n+      return FlinkOrcWriters.struct(results, fieldType);\n+    }\n+\n+    @Override\n+    public OrcValueWriter<?> map(Types.MapType iMap, OrcValueWriter<?> key, OrcValueWriter<?> value,\n+                                 LogicalType keyType, LogicalType valueType) {\n+      return FlinkOrcWriters.map(key, value, keyType, valueType);\n+    }\n+\n+    @Override\n+    public OrcValueWriter<?> list(Types.ListType iList, OrcValueWriter<?> element, LogicalType elementType) {\n+      return FlinkOrcWriters.list(element, elementType);\n+    }\n+\n+    @Override\n+    public OrcValueWriter<?> primitive(Type.PrimitiveType iPrimitive, LogicalType flinkPrimitive) {\n+      switch (iPrimitive.typeId()) {\n+        case BOOLEAN:\n+          return GenericOrcWriters.booleans();\n+        case INTEGER:\n+          return GenericOrcWriters.ints();\n+        case LONG:\n+          return GenericOrcWriters.longs();\n+        case FLOAT:\n+          return GenericOrcWriters.floats();\n+        case DOUBLE:\n+          return GenericOrcWriters.doubles();\n+        case DATE:\n+          return FlinkOrcWriters.dates();\n+        case TIME:\n+          return FlinkOrcWriters.times();\n+        case TIMESTAMP:\n+          Types.TimestampType timestampType = (Types.TimestampType) iPrimitive;\n+          if (timestampType.shouldAdjustToUTC()) {\n+            return FlinkOrcWriters.timestampTzs();\n+          } else {\n+            return FlinkOrcWriters.timestamps();\n+          }\n+        case STRING:\n+          return FlinkOrcWriters.strings();\n+        case UUID:\n+          return GenericOrcWriters.uuids();", "originalCommit": "3972bf4602db6d02538ea68e17cdb6181f603750", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "56c6ec6cd5a11d4e37265385352b1bc34bc9d032", "chunk": "diff --git a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriter.java b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriter.java\nindex 93e0d53cb..1dd691533 100644\n--- a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriter.java\n+++ b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriter.java\n\n@@ -37,7 +37,7 @@ public class FlinkOrcWriter implements OrcRowWriter<RowData> {\n   private final List<RowData.FieldGetter> fieldGetters;\n \n   private FlinkOrcWriter(RowType rowType, Schema iSchema) {\n-    this.writer = (FlinkOrcWriters.StructWriter) FlinkOrcSchemaVisitor.visit(rowType, iSchema, new WriteBuilder());\n+    this.writer = (FlinkOrcWriters.StructWriter) FlinkSchemaVisitor.visit(rowType, iSchema, new WriteBuilder());\n \n     List<LogicalType> fieldTypes = rowType.getChildren();\n     this.fieldGetters = Lists.newArrayListWithExpectedSize(fieldTypes.size());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQxMTEwMQ==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r470411101", "bodyText": "I think I understand why u needed to build a FlinkSchemaVisitor. Unlike Spark, it seems in Flink, there's no common super interface for internal datatypes [list, map, struct], like SpecializedGetters for Spark. So we had to know upfront what is the type to pass to struct, map and list writers, whereas in Spark we can simply pass the parent SpecializedGetters object and get the right data type from within in.", "author": "rdsr", "createdAt": "2020-08-14T05:01:34Z", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkSchemaVisitor.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.util.List;\n+import org.apache.flink.table.types.logical.ArrayType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.MapType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Type;\n+import org.apache.iceberg.types.Types;\n+\n+abstract class FlinkSchemaVisitor<T> {", "originalCommit": "d416ed5c4c319347b09615e899debe904fb236aa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0144a1f66143f5d23da322ec83a672b5108b377a", "chunk": "diff --git a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkSchemaVisitor.java b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkSchemaVisitor.java\ndeleted file mode 100644\nindex 363d2bde4..000000000\n--- a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkSchemaVisitor.java\n+++ /dev/null\n\n@@ -1,106 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.iceberg.flink.data;\n-\n-import java.util.List;\n-import org.apache.flink.table.types.logical.ArrayType;\n-import org.apache.flink.table.types.logical.LogicalType;\n-import org.apache.flink.table.types.logical.MapType;\n-import org.apache.flink.table.types.logical.RowType;\n-import org.apache.iceberg.Schema;\n-import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n-import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n-import org.apache.iceberg.types.Type;\n-import org.apache.iceberg.types.Types;\n-\n-abstract class FlinkSchemaVisitor<T> {\n-\n-  static <T> T visit(RowType flinkType, Schema schema, FlinkSchemaVisitor<T> visitor) {\n-    return visit(flinkType, schema.asStruct(), visitor);\n-  }\n-\n-  private static <T> T visit(LogicalType flinkType, Type iType, FlinkSchemaVisitor<T> visitor) {\n-    switch (iType.typeId()) {\n-      case STRUCT:\n-        return visitRecord(flinkType, iType.asStructType(), visitor);\n-\n-      case MAP:\n-        MapType mapType = (MapType) flinkType;\n-        Types.MapType iMapType = iType.asMapType();\n-\n-        T key = visit(mapType.getKeyType(), iMapType.keyType(), visitor);\n-        T value = visit(mapType.getValueType(), iMapType.valueType(), visitor);\n-\n-        return visitor.map(iMapType, key, value, mapType.getKeyType(), mapType.getValueType());\n-\n-      case LIST:\n-        ArrayType listType = (ArrayType) flinkType;\n-        Types.ListType iListType = iType.asListType();\n-\n-        T element = visit(listType.getElementType(), iListType.elementType(), visitor);\n-\n-        return visitor.list(iListType, element, listType.getElementType());\n-\n-      default:\n-        return visitor.primitive(iType.asPrimitiveType(), flinkType);\n-    }\n-  }\n-\n-  private static <T> T visitRecord(LogicalType flinkType, Types.StructType struct,\n-                                   FlinkSchemaVisitor<T> visitor) {\n-    Preconditions.checkArgument(flinkType instanceof RowType, \"%s is not a RowType.\", flinkType);\n-    RowType rowType = (RowType) flinkType;\n-\n-    int fieldSize = struct.fields().size();\n-    List<T> results = Lists.newArrayListWithExpectedSize(fieldSize);\n-    List<LogicalType> fieldTypes = Lists.newArrayListWithExpectedSize(fieldSize);\n-    List<Types.NestedField> nestedFields = struct.fields();\n-\n-    for (int i = 0; i < fieldSize; i++) {\n-      Types.NestedField iField = nestedFields.get(i);\n-      int fieldIndex = rowType.getFieldIndex(iField.name());\n-      Preconditions.checkArgument(fieldIndex >= 0,\n-          \"NestedField: %s is not found in flink RowType: %s\", iField, rowType);\n-\n-      LogicalType fieldFlinkType = rowType.getTypeAt(fieldIndex);\n-\n-      fieldTypes.add(fieldFlinkType);\n-      results.add(visit(fieldFlinkType, iField.type(), visitor));\n-    }\n-\n-    return visitor.record(struct, results, fieldTypes);\n-  }\n-\n-  public T record(Types.StructType iStruct, List<T> results, List<LogicalType> fieldTypes) {\n-    return null;\n-  }\n-\n-  public T list(Types.ListType iList, T element, LogicalType elementType) {\n-    return null;\n-  }\n-\n-  public T map(Types.MapType iMap, T key, T value, LogicalType keyType, LogicalType valueType) {\n-    return null;\n-  }\n-\n-  public T primitive(Type.PrimitiveType iPrimitive, LogicalType flinkPrimitive) {\n-    return null;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzODA3MQ==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r472538071", "bodyText": "Should the FixedWriter class also be renamed to BytesWriter?", "author": "rdblue", "createdAt": "2020-08-18T22:56:01Z", "path": "data/src/main/java/org/apache/iceberg/data/orc/GenericOrcWriters.java", "diffHunk": "@@ -87,7 +87,7 @@ private GenericOrcWriters() {\n     return UUIDWriter.INSTANCE;\n   }\n \n-  public static OrcValueWriter<byte[]> fixed() {\n+  public static OrcValueWriter<byte[]> bytes() {", "originalCommit": "d416ed5c4c319347b09615e899debe904fb236aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA0MzMzMA==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r473043330", "bodyText": "Sounds good.", "author": "openinx", "createdAt": "2020-08-19T13:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzODA3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "56c6ec6cd5a11d4e37265385352b1bc34bc9d032", "chunk": "diff --git a/data/src/main/java/org/apache/iceberg/data/orc/GenericOrcWriters.java b/data/src/main/java/org/apache/iceberg/data/orc/GenericOrcWriters.java\nindex 1989f9aa8..4e1953bcd 100644\n--- a/data/src/main/java/org/apache/iceberg/data/orc/GenericOrcWriters.java\n+++ b/data/src/main/java/org/apache/iceberg/data/orc/GenericOrcWriters.java\n\n@@ -88,7 +89,7 @@ public class GenericOrcWriters {\n   }\n \n   public static OrcValueWriter<byte[]> bytes() {\n-    return FixedWriter.INSTANCE;\n+    return BytesWriter.INSTANCE;\n   }\n \n   public static OrcValueWriter<LocalDate> dates() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzODM4NQ==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r472538385", "bodyText": "What about the TODO to check the scale matches the column's scale? As long as we're updating this, does it make sense to fix that, since we just had a decimal scale problem?", "author": "rdblue", "createdAt": "2020-08-18T22:57:00Z", "path": "data/src/main/java/org/apache/iceberg/data/orc/GenericOrcWriters.java", "diffHunk": "@@ -326,7 +326,7 @@ public void nonNullWrite(int rowId, LocalDateTime data, ColumnVector output) {\n     public void nonNullWrite(int rowId, BigDecimal data, ColumnVector output) {\n       // TODO: validate precision and scale from schema\n       ((DecimalColumnVector) output).vector[rowId]\n-          .setFromLongAndScale(data.unscaledValue().longValueExact(), scale);\n+          .setFromLongAndScale(data.unscaledValue().longValueExact(), data.scale());", "originalCommit": "d416ed5c4c319347b09615e899debe904fb236aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA1MDU4Mw==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r473050583", "bodyText": "Actually,  we don't need to change this now, because this merged patch has fixed it. 6f96b36#diff-b1b07b15f036000a3f2bed76fdd9f961R334", "author": "openinx", "createdAt": "2020-08-19T13:58:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzODM4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "56c6ec6cd5a11d4e37265385352b1bc34bc9d032", "chunk": "diff --git a/data/src/main/java/org/apache/iceberg/data/orc/GenericOrcWriters.java b/data/src/main/java/org/apache/iceberg/data/orc/GenericOrcWriters.java\nindex 1989f9aa8..4e1953bcd 100644\n--- a/data/src/main/java/org/apache/iceberg/data/orc/GenericOrcWriters.java\n+++ b/data/src/main/java/org/apache/iceberg/data/orc/GenericOrcWriters.java\n\n@@ -324,14 +331,24 @@ public class GenericOrcWriters {\n \n     @Override\n     public void nonNullWrite(int rowId, BigDecimal data, ColumnVector output) {\n-      // TODO: validate precision and scale from schema\n+      Preconditions.checkArgument(data.scale() == scale,\n+          \"Cannot write value as decimal(%s,%s), wrong scale: %s\", precision, scale, data);\n+      Preconditions.checkArgument(data.precision() <= precision,\n+          \"Cannot write value as decimal(%s,%s), invalid precision: %s\", precision, scale, data);\n+\n       ((DecimalColumnVector) output).vector[rowId]\n-          .setFromLongAndScale(data.unscaledValue().longValueExact(), data.scale());\n+          .setFromLongAndScale(data.unscaledValue().longValueExact(), scale);\n     }\n   }\n \n   private static class Decimal38Writer implements OrcValueWriter<BigDecimal> {\n-    private static final OrcValueWriter<BigDecimal> INSTANCE = new Decimal38Writer();\n+    private final int precision;\n+    private final int scale;\n+\n+    Decimal38Writer(int precision, int scale) {\n+      this.precision = precision;\n+      this.scale = scale;\n+    }\n \n     @Override\n     public Class<BigDecimal> getJavaClass() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzOTU2NQ==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r472539565", "bodyText": "Can this list be reused? Allocating a new ArrayList each time could lead to poor performance.", "author": "rdblue", "createdAt": "2020-08-18T23:00:41Z", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcReaders.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.flink.table.data.ArrayData;\n+import org.apache.flink.table.data.DecimalData;\n+import org.apache.flink.table.data.GenericArrayData;\n+import org.apache.flink.table.data.GenericMapData;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.MapData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.StringData;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.iceberg.orc.OrcValueReader;\n+import org.apache.iceberg.orc.OrcValueReaders;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.types.Types;\n+import org.apache.orc.storage.ql.exec.vector.BytesColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.ColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.DecimalColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.ListColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.LongColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.MapColumnVector;\n+import org.apache.orc.storage.ql.exec.vector.TimestampColumnVector;\n+import org.apache.orc.storage.serde2.io.HiveDecimalWritable;\n+\n+class FlinkOrcReaders {\n+  private FlinkOrcReaders() {\n+  }\n+\n+  static OrcValueReader<StringData> strings() {\n+    return StringReader.INSTANCE;\n+  }\n+\n+  static OrcValueReader<Integer> dates() {\n+    return DateReader.INSTANCE;\n+  }\n+\n+  static OrcValueReader<DecimalData> decimals(int precision, int scale) {\n+    if (precision <= 18) {\n+      return new Decimal18Reader(precision, scale);\n+    } else if (precision <= 38) {\n+      return new Decimal38Reader(precision, scale);\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid precision: \" + precision);\n+    }\n+  }\n+\n+  static OrcValueReader<Integer> times() {\n+    return TimeReader.INSTANCE;\n+  }\n+\n+  static OrcValueReader<TimestampData> timestamps() {\n+    return TimestampReader.INSTANCE;\n+  }\n+\n+  static OrcValueReader<TimestampData> timestampTzs() {\n+    return TimestampTzReader.INSTANCE;\n+  }\n+\n+  static <T> OrcValueReader<ArrayData> array(OrcValueReader<T> elementReader) {\n+    return new ArrayReader<>(elementReader);\n+  }\n+\n+  public static <K, V> OrcValueReader<MapData> map(OrcValueReader<K> keyReader, OrcValueReader<V> valueReader) {\n+    return new MapReader<>(keyReader, valueReader);\n+  }\n+\n+  public static OrcValueReader<RowData> struct(List<OrcValueReader<?>> readers,\n+                                               Types.StructType struct,\n+                                               Map<Integer, ?> idToConstant) {\n+    return new StructReader(readers, struct, idToConstant);\n+  }\n+\n+  private static class StringReader implements OrcValueReader<StringData> {\n+    private static final StringReader INSTANCE = new StringReader();\n+\n+    @Override\n+    public StringData nonNullRead(ColumnVector vector, int row) {\n+      BytesColumnVector bytesVector = (BytesColumnVector) vector;\n+      return StringData.fromBytes(bytesVector.vector[row], bytesVector.start[row], bytesVector.length[row]);\n+    }\n+  }\n+\n+  private static class DateReader implements OrcValueReader<Integer> {\n+    private static final DateReader INSTANCE = new DateReader();\n+\n+    @Override\n+    public Integer nonNullRead(ColumnVector vector, int row) {\n+      return (int) ((LongColumnVector) vector).vector[row];\n+    }\n+  }\n+\n+  private static class Decimal18Reader implements OrcValueReader<DecimalData> {\n+    private final int precision;\n+    private final int scale;\n+\n+    Decimal18Reader(int precision, int scale) {\n+      this.precision = precision;\n+      this.scale = scale;\n+    }\n+\n+    @Override\n+    public DecimalData nonNullRead(ColumnVector vector, int row) {\n+      HiveDecimalWritable value = ((DecimalColumnVector) vector).vector[row];\n+      return DecimalData.fromUnscaledLong(value.serialize64(scale), precision, scale);\n+    }\n+  }\n+\n+  private static class Decimal38Reader implements OrcValueReader<DecimalData> {\n+    private final int precision;\n+    private final int scale;\n+\n+    Decimal38Reader(int precision, int scale) {\n+      this.precision = precision;\n+      this.scale = scale;\n+    }\n+\n+    @Override\n+    public DecimalData nonNullRead(ColumnVector vector, int row) {\n+      BigDecimal value = ((DecimalColumnVector) vector).vector[row].getHiveDecimal().bigDecimalValue();\n+      return DecimalData.fromBigDecimal(value, precision, scale);\n+    }\n+  }\n+\n+  private static class TimeReader implements OrcValueReader<Integer> {\n+    private static final TimeReader INSTANCE = new TimeReader();\n+\n+    @Override\n+    public Integer nonNullRead(ColumnVector vector, int row) {\n+      long micros = ((LongColumnVector) vector).vector[row];\n+      // Flink only support time mills, just erase micros.\n+      return (int) (micros / 1000);\n+    }\n+  }\n+\n+  private static class TimestampReader implements OrcValueReader<TimestampData> {\n+    private static final TimestampReader INSTANCE = new TimestampReader();\n+\n+    @Override\n+    public TimestampData nonNullRead(ColumnVector vector, int row) {\n+      TimestampColumnVector tcv = (TimestampColumnVector) vector;\n+      LocalDateTime localDate = Instant.ofEpochSecond(Math.floorDiv(tcv.time[row], 1_000), tcv.nanos[row])\n+          .atOffset(ZoneOffset.UTC)\n+          .toLocalDateTime();\n+      return TimestampData.fromLocalDateTime(localDate);\n+    }\n+  }\n+\n+  private static class TimestampTzReader implements OrcValueReader<TimestampData> {\n+    private static final TimestampTzReader INSTANCE = new TimestampTzReader();\n+\n+    @Override\n+    public TimestampData nonNullRead(ColumnVector vector, int row) {\n+      TimestampColumnVector tcv = (TimestampColumnVector) vector;\n+      Instant instant = Instant.ofEpochSecond(Math.floorDiv(tcv.time[row], 1_000), tcv.nanos[row])\n+          .atOffset(ZoneOffset.UTC)\n+          .toInstant();\n+      return TimestampData.fromInstant(instant);\n+    }\n+  }\n+\n+  private static class ArrayReader<T> implements OrcValueReader<ArrayData> {\n+    private final OrcValueReader<T> elementReader;\n+\n+    private ArrayReader(OrcValueReader<T> elementReader) {\n+      this.elementReader = elementReader;\n+    }\n+\n+    @Override\n+    public ArrayData nonNullRead(ColumnVector vector, int row) {\n+      ListColumnVector listVector = (ListColumnVector) vector;\n+      int offset = (int) listVector.offsets[row];\n+      int length = (int) listVector.lengths[row];\n+      List<T> elements = Lists.newArrayListWithExpectedSize(length);", "originalCommit": "d416ed5c4c319347b09615e899debe904fb236aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NDkwNg==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r473064906", "bodyText": "One way to reuse the ArrayList is: make it as a ThreadLocal<List>, then  each thread will share the same List instance.  when reading ArrayData,  we get the ThreadLocal list and clear it (the array list's space won't shrink and only free the references to elements).  Then read values into the list.   One thing need to concern is the size of list:   if we read an ArrayData with many elements,  then the ThreadLocal list may expand to a huge list too,  that would waste much memory.  I did not get a good idea to handle such case,   I also see other orc readers are allocating the list, maybe we could handle this in a separate issue.", "author": "openinx", "createdAt": "2020-08-19T14:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzOTU2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0144a1f66143f5d23da322ec83a672b5108b377a", "chunk": "diff --git a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcReaders.java b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcReaders.java\nindex a434bddfe..aeb02443a 100644\n--- a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcReaders.java\n+++ b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcReaders.java\n\n@@ -36,6 +36,7 @@ import org.apache.flink.table.data.StringData;\n import org.apache.flink.table.data.TimestampData;\n import org.apache.iceberg.orc.OrcValueReader;\n import org.apache.iceberg.orc.OrcValueReaders;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n import org.apache.iceberg.types.Types;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1Mzc0OA==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r472553748", "bodyText": "It looks like this validates records read by the reader against records written by the reader and subsequently read by the reader. I think it should validate the reader and writer separately. I think it should have to parts:\n\nWrite using generics, read using Flink, and use assertEquals(schema, genericRow, flinkRow)\nWrite using generics, read with Flink, write with Flink, read with generics and use assertEquals(genericRow, endGenericRow).\n\nThat way, we're always comparing results against the generics that were originally generated. I think we already have the assertEquals code to do it.", "author": "rdblue", "createdAt": "2020-08-18T23:44:59Z", "path": "flink/src/test/java/org/apache/iceberg/flink/data/TestFlinkOrcReaderWriter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.iceberg.Files;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.data.DataTest;\n+import org.apache.iceberg.data.RandomGenericData;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.data.orc.GenericOrcWriter;\n+import org.apache.iceberg.flink.FlinkSchemaUtil;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.orc.ORC;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestFlinkOrcReaderWriter extends DataTest {\n+  private static final int NUM_RECORDS = 200;\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @Override\n+  protected void writeAndValidate(Schema schema) throws IOException {", "originalCommit": "d416ed5c4c319347b09615e899debe904fb236aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA4NTgwOQ==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r473085809", "bodyText": "You testing method is correct, but we don't have assertEquals(schema, genericRow, flinkRow) before Junjie's parquet readers & writers patch get in. So I changed to another way to verify the data:\n\ngenerate List<records> by random generater;\nconvert the records to RowData list;\nwriter records from step1 to orc file, and reading them into RowData list, and compare with RowData from step2;\nwrite RowData  from step2 into orc file, and reading them into records, and compare with Records from step1.", "author": "openinx", "createdAt": "2020-08-19T14:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1Mzc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2MTY5OA==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r473661698", "bodyText": "@openinx , Sorry to block you so long. Now it is merged. You might want to take a look.", "author": "chenjunjiedada", "createdAt": "2020-08-20T06:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1Mzc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY4Mjg1OQ==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r473682859", "bodyText": "Since your TestHelpers got merged,  then I don't have to write the AssertHelpers now,  could reuse your work.  Thanks for the work, I've updated the patch.", "author": "openinx", "createdAt": "2020-08-20T07:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1Mzc0OA=="}], "type": "inlineReview", "revised_code": {"commit": "56c6ec6cd5a11d4e37265385352b1bc34bc9d032", "chunk": "diff --git a/flink/src/test/java/org/apache/iceberg/flink/data/TestFlinkOrcReaderWriter.java b/flink/src/test/java/org/apache/iceberg/flink/data/TestFlinkOrcReaderWriter.java\nindex f8cdcd90a..1f8cf0a31 100644\n--- a/flink/src/test/java/org/apache/iceberg/flink/data/TestFlinkOrcReaderWriter.java\n+++ b/flink/src/test/java/org/apache/iceberg/flink/data/TestFlinkOrcReaderWriter.java\n\n@@ -30,7 +30,9 @@ import org.apache.iceberg.Schema;\n import org.apache.iceberg.data.DataTest;\n import org.apache.iceberg.data.RandomGenericData;\n import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.data.orc.GenericOrcReader;\n import org.apache.iceberg.data.orc.GenericOrcWriter;\n+import org.apache.iceberg.flink.AssertHelpers;\n import org.apache.iceberg.flink.FlinkSchemaUtil;\n import org.apache.iceberg.io.CloseableIterable;\n import org.apache.iceberg.io.FileAppender;\n"}}, {"oid": "56c6ec6cd5a11d4e37265385352b1bc34bc9d032", "url": "https://github.com/apache/iceberg/commit/56c6ec6cd5a11d4e37265385352b1bc34bc9d032", "message": "Addressing the comments", "committedDate": "2020-08-19T16:18:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5MTAzNw==", "url": "https://github.com/apache/iceberg/pull/1255#discussion_r473491037", "bodyText": "This fixed the broken unit tests in flink: 2ec4ce6#diff-6820fc22b4e5cbfa4a1c029bf5c8c789L255.\nwe may need to add similar UT in spark so that we could write the tinyint and smallint to spark correctly,  I will take a look.", "author": "openinx", "createdAt": "2020-08-20T00:58:04Z", "path": "flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriter.java", "diffHunk": "@@ -91,6 +91,12 @@ private WriteBuilder() {\n         case BOOLEAN:\n           return GenericOrcWriters.booleans();\n         case INTEGER:\n+          switch (flinkPrimitive.getTypeRoot()) {\n+            case TINYINT:\n+              return GenericOrcWriters.bytes();", "originalCommit": "2ec4ce6030230e90e8becf3b0a79dca88c4024e1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0144a1f66143f5d23da322ec83a672b5108b377a", "chunk": "diff --git a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriter.java b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriter.java\nindex 592307ded..74202e7eb 100644\n--- a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriter.java\n+++ b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkOrcWriter.java\n\n@@ -19,115 +19,5 @@\n \n package org.apache.iceberg.flink.data;\n \n-import java.util.List;\n-import org.apache.flink.table.data.RowData;\n-import org.apache.flink.table.types.logical.LogicalType;\n-import org.apache.flink.table.types.logical.RowType;\n-import org.apache.iceberg.Schema;\n-import org.apache.iceberg.data.orc.GenericOrcWriters;\n-import org.apache.iceberg.orc.OrcRowWriter;\n-import org.apache.iceberg.orc.OrcValueWriter;\n-import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n-import org.apache.iceberg.types.Type;\n-import org.apache.iceberg.types.Types;\n-import org.apache.orc.storage.ql.exec.vector.VectorizedRowBatch;\n-\n-public class FlinkOrcWriter implements OrcRowWriter<RowData> {\n-  private final FlinkOrcWriters.StructWriter writer;\n-  private final List<RowData.FieldGetter> fieldGetters;\n-\n-  private FlinkOrcWriter(RowType rowType, Schema iSchema) {\n-    this.writer = (FlinkOrcWriters.StructWriter) FlinkSchemaVisitor.visit(rowType, iSchema, new WriteBuilder());\n-\n-    List<LogicalType> fieldTypes = rowType.getChildren();\n-    this.fieldGetters = Lists.newArrayListWithExpectedSize(fieldTypes.size());\n-    for (int i = 0; i < fieldTypes.size(); i++) {\n-      fieldGetters.add(RowData.createFieldGetter(fieldTypes.get(i), i));\n-    }\n-  }\n-\n-  public static OrcRowWriter<RowData> buildWriter(RowType rowType, Schema iSchema) {\n-    return new FlinkOrcWriter(rowType, iSchema);\n-  }\n-\n-  @Override\n-  @SuppressWarnings(\"unchecked\")\n-  public void write(RowData row, VectorizedRowBatch output) {\n-    int rowId = output.size;\n-    output.size += 1;\n-\n-    List<OrcValueWriter<?>> writers = writer.writers();\n-    for (int c = 0; c < writers.size(); ++c) {\n-      OrcValueWriter child = writers.get(c);\n-      child.write(rowId, fieldGetters.get(c).getFieldOrNull(row), output.cols[c]);\n-    }\n-  }\n-\n-  private static class WriteBuilder extends FlinkSchemaVisitor<OrcValueWriter<?>> {\n-    private WriteBuilder() {\n-    }\n-\n-    @Override\n-    public OrcValueWriter<RowData> record(Types.StructType iStruct,\n-                                          List<OrcValueWriter<?>> results,\n-                                          List<LogicalType> fieldType) {\n-      return FlinkOrcWriters.struct(results, fieldType);\n-    }\n-\n-    @Override\n-    public OrcValueWriter<?> map(Types.MapType iMap, OrcValueWriter<?> key, OrcValueWriter<?> value,\n-                                 LogicalType keyType, LogicalType valueType) {\n-      return FlinkOrcWriters.map(key, value, keyType, valueType);\n-    }\n-\n-    @Override\n-    public OrcValueWriter<?> list(Types.ListType iList, OrcValueWriter<?> element, LogicalType elementType) {\n-      return FlinkOrcWriters.list(element, elementType);\n-    }\n-\n-    @Override\n-    public OrcValueWriter<?> primitive(Type.PrimitiveType iPrimitive, LogicalType flinkPrimitive) {\n-      switch (iPrimitive.typeId()) {\n-        case BOOLEAN:\n-          return GenericOrcWriters.booleans();\n-        case INTEGER:\n-          switch (flinkPrimitive.getTypeRoot()) {\n-            case TINYINT:\n-              return GenericOrcWriters.bytes();\n-            case SMALLINT:\n-              return GenericOrcWriters.shorts();\n-          }\n-          return GenericOrcWriters.ints();\n-        case LONG:\n-          return GenericOrcWriters.longs();\n-        case FLOAT:\n-          return GenericOrcWriters.floats();\n-        case DOUBLE:\n-          return GenericOrcWriters.doubles();\n-        case DATE:\n-          return FlinkOrcWriters.dates();\n-        case TIME:\n-          return FlinkOrcWriters.times();\n-        case TIMESTAMP:\n-          Types.TimestampType timestampType = (Types.TimestampType) iPrimitive;\n-          if (timestampType.shouldAdjustToUTC()) {\n-            return FlinkOrcWriters.timestampTzs();\n-          } else {\n-            return FlinkOrcWriters.timestamps();\n-          }\n-        case STRING:\n-          return FlinkOrcWriters.strings();\n-        case UUID:\n-        case FIXED:\n-        case BINARY:\n-          return GenericOrcWriters.byteArrays();\n-        case DECIMAL:\n-          Types.DecimalType decimalType = (Types.DecimalType) iPrimitive;\n-          return FlinkOrcWriters.decimals(decimalType.precision(), decimalType.scale());\n-        default:\n-          throw new IllegalArgumentException(String.format(\n-              \"Invalid iceberg type %s corresponding to Flink logical type %s\", iPrimitive, flinkPrimitive));\n-      }\n-    }\n-  }\n+public class FlinkOrcWriter {\n }\n"}}, {"oid": "0144a1f66143f5d23da322ec83a672b5108b377a", "url": "https://github.com/apache/iceberg/commit/0144a1f66143f5d23da322ec83a672b5108b377a", "message": "Flink: Add Orc value reader, writer implementations", "committedDate": "2020-08-20T06:56:40Z", "type": "commit"}, {"oid": "7e03783e698722497a2af7a1d839f1506c4a076c", "url": "https://github.com/apache/iceberg/commit/7e03783e698722497a2af7a1d839f1506c4a076c", "message": "Add flink orc writers.", "committedDate": "2020-08-20T06:56:40Z", "type": "commit"}, {"oid": "11f5a0812ab4e517b352da28b0a6ff56b6c1543a", "url": "https://github.com/apache/iceberg/commit/11f5a0812ab4e517b352da28b0a6ff56b6c1543a", "message": "Add unit tests.", "committedDate": "2020-08-20T06:56:40Z", "type": "commit"}, {"oid": "b77a71327f58803c9c0d2575a1d83facf18ffff1", "url": "https://github.com/apache/iceberg/commit/b77a71327f58803c9c0d2575a1d83facf18ffff1", "message": "Fix the broken unit tests.", "committedDate": "2020-08-20T06:56:40Z", "type": "commit"}, {"oid": "dbc4ccea1eee5611b24fd69f1bac7c4f5992051d", "url": "https://github.com/apache/iceberg/commit/dbc4ccea1eee5611b24fd69f1bac7c4f5992051d", "message": "Addressing comments", "committedDate": "2020-08-20T06:56:40Z", "type": "commit"}, {"oid": "9cf929eae7b216118fb0039ae43305ceb85585af", "url": "https://github.com/apache/iceberg/commit/9cf929eae7b216118fb0039ae43305ceb85585af", "message": "Addressing the comment and fixing the uuid type issues.", "committedDate": "2020-08-20T06:56:40Z", "type": "commit"}, {"oid": "7ffb1a9c9a5d56facfe4a4aa94e4c41337f8bdaa", "url": "https://github.com/apache/iceberg/commit/7ffb1a9c9a5d56facfe4a4aa94e4c41337f8bdaa", "message": "Addressing the comments", "committedDate": "2020-08-20T06:56:40Z", "type": "commit"}, {"oid": "75c2434120f0f6d4df1a2f371e57ee54fb0c4d48", "url": "https://github.com/apache/iceberg/commit/75c2434120f0f6d4df1a2f371e57ee54fb0c4d48", "message": "Fix the broken unit tests", "committedDate": "2020-08-20T06:56:40Z", "type": "commit"}, {"oid": "21dd824793238d5a9bc75a486372c5c10b9eb3ac", "url": "https://github.com/apache/iceberg/commit/21dd824793238d5a9bc75a486372c5c10b9eb3ac", "message": "Rebase to use the flink TestHelpers.", "committedDate": "2020-08-20T07:13:32Z", "type": "commit"}, {"oid": "21dd824793238d5a9bc75a486372c5c10b9eb3ac", "url": "https://github.com/apache/iceberg/commit/21dd824793238d5a9bc75a486372c5c10b9eb3ac", "message": "Rebase to use the flink TestHelpers.", "committedDate": "2020-08-20T07:13:32Z", "type": "forcePushed"}]}