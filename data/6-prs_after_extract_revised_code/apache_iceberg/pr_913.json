{"pr_number": 913, "pr_title": "Add v2 manifests", "pr_createdAt": "2020-04-11T00:44:33Z", "pr_url": "https://github.com/apache/iceberg/pull/913", "timeline": [{"oid": "8a544d820f0f00225223339a01603ce62adfafc8", "url": "https://github.com/apache/iceberg/commit/8a544d820f0f00225223339a01603ce62adfafc8", "message": "Add v2 manifest writer and ManifestEntry sequence number.", "committedDate": "2020-04-11T00:50:33Z", "type": "forcePushed"}, {"oid": "eaf78717b94097030098c790d7db74f231440408", "url": "https://github.com/apache/iceberg/commit/eaf78717b94097030098c790d7db74f231440408", "message": "Add v2 manifest writer and ManifestEntry sequence number.", "committedDate": "2020-04-11T16:21:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI5NzU5OQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407297599", "bodyText": "nit: missing the sequence number here ?", "author": "openinx", "createdAt": "2020-04-13T03:13:59Z", "path": "core/src/main/java/org/apache/iceberg/GenericManifestEntry.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.base.MoreObjects;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.avro.specific.SpecificData;\n+import org.apache.iceberg.avro.AvroSchemaUtil;\n+import org.apache.iceberg.types.Types;\n+\n+class GenericManifestEntry implements ManifestEntry, IndexedRecord, SpecificData.SchemaConstructable {\n+  private final org.apache.avro.Schema schema;\n+  private final V1Metadata.IndexedDataFile fileWrapper;\n+  private Status status = Status.EXISTING;\n+  private Long snapshotId = null;\n+  private Long sequenceNumber = null;\n+  private DataFile file = null;\n+\n+  GenericManifestEntry(org.apache.avro.Schema schema) {\n+    this.schema = schema;\n+    this.fileWrapper = null; // do not use the file wrapper to read\n+  }\n+\n+  GenericManifestEntry(Types.StructType partitionType) {\n+    this.schema = AvroSchemaUtil.convert(V1Metadata.entrySchema(partitionType), \"manifest_entry\");\n+    this.fileWrapper = new V1Metadata.IndexedDataFile(schema.getField(\"data_file\").schema());\n+  }\n+\n+  private GenericManifestEntry(GenericManifestEntry toCopy, boolean fullCopy) {\n+    this.schema = toCopy.schema;\n+    this.fileWrapper = new V1Metadata.IndexedDataFile(schema.getField(\"data_file\").schema());\n+    this.status = toCopy.status;\n+    this.snapshotId = toCopy.snapshotId;\n+    if (fullCopy) {\n+      this.file = toCopy.file().copy();\n+    } else {\n+      this.file = toCopy.file().copyWithoutStats();\n+    }\n+  }\n+\n+  ManifestEntry wrapExisting(Long newSnapshotId, Long newSequenceNumber, DataFile newFile) {\n+    this.status = Status.EXISTING;\n+    this.snapshotId = newSnapshotId;\n+    this.sequenceNumber = newSequenceNumber;\n+    this.file = newFile;\n+    return this;\n+  }\n+\n+  ManifestEntry wrapAppend(Long newSnapshotId, DataFile newFile) {\n+    this.status = Status.ADDED;\n+    this.snapshotId = newSnapshotId;\n+    this.sequenceNumber = null;\n+    this.file = newFile;\n+    return this;\n+  }\n+\n+  ManifestEntry wrapDelete(Long newSnapshotId, DataFile newFile) {\n+    this.status = Status.DELETED;\n+    this.snapshotId = newSnapshotId;\n+    this.sequenceNumber = null;\n+    this.file = newFile;\n+    return this;\n+  }\n+\n+  /**\n+   * @return the status of the file, whether EXISTING, ADDED, or DELETED\n+   */\n+  public Status status() {\n+    return status;\n+  }\n+\n+  /**\n+   * @return id of the snapshot in which the file was added to the table\n+   */\n+  public Long snapshotId() {\n+    return snapshotId;\n+  }\n+\n+  @Override\n+  public Long sequenceNumber() {\n+    return sequenceNumber;\n+  }\n+\n+  /**\n+   * @return a file\n+   */\n+  public DataFile file() {\n+    return file;\n+  }\n+\n+  public ManifestEntry copy() {\n+    return new GenericManifestEntry(this, true /* full copy */);\n+  }\n+\n+  public ManifestEntry copyWithoutStats() {\n+    return new GenericManifestEntry(this, false /* drop stats */);\n+  }\n+\n+  @Override\n+  public void setSnapshotId(long newSnapshotId) {\n+    this.snapshotId = newSnapshotId;\n+  }\n+\n+  @Override\n+  public void setSequenceNumber(long newSequenceNumber) {\n+    this.sequenceNumber = newSequenceNumber;\n+  }\n+\n+  @Override\n+  public void put(int i, Object v) {\n+    switch (i) {\n+      case 0:\n+        this.status = Status.values()[(Integer) v];\n+        return;\n+      case 1:\n+        this.snapshotId = (Long) v;\n+        return;\n+      case 2:\n+        this.sequenceNumber = (Long) v;\n+        return;\n+      case 3:\n+        this.file = (DataFile) v;\n+        return;\n+      default:\n+        // ignore the object, it must be from a newer version of the format\n+    }\n+  }\n+\n+  @Override\n+  public Object get(int i) {\n+    switch (i) {\n+      case 0:\n+        return status.id();\n+      case 1:\n+        return snapshotId;\n+      case 2:\n+        return sequenceNumber;\n+      case 3:\n+        if (fileWrapper == null || file instanceof GenericDataFile) {\n+          return file;\n+        } else {\n+          return fileWrapper.wrap(file);\n+        }\n+      default:\n+        throw new UnsupportedOperationException(\"Unknown field ordinal: \" + i);\n+    }\n+  }\n+\n+  @Override\n+  public org.apache.avro.Schema getSchema() {\n+    return schema;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"status\", status)\n+        .add(\"snapshot_id\", snapshotId)", "originalCommit": "eaf78717b94097030098c790d7db74f231440408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUzMTgzMg==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r408531832", "bodyText": "Added. Thanks!", "author": "rdblue", "createdAt": "2020-04-15T01:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI5NzU5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "1119159033cea2e6e79691a5f1389c327d926e6f", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/GenericManifestEntry.java b/core/src/main/java/org/apache/iceberg/GenericManifestEntry.java\ndeleted file mode 100644\nindex d1b1cc2a..00000000\n--- a/core/src/main/java/org/apache/iceberg/GenericManifestEntry.java\n+++ /dev/null\n\n@@ -1,179 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.iceberg;\n-\n-import com.google.common.base.MoreObjects;\n-import org.apache.avro.generic.IndexedRecord;\n-import org.apache.avro.specific.SpecificData;\n-import org.apache.iceberg.avro.AvroSchemaUtil;\n-import org.apache.iceberg.types.Types;\n-\n-class GenericManifestEntry implements ManifestEntry, IndexedRecord, SpecificData.SchemaConstructable {\n-  private final org.apache.avro.Schema schema;\n-  private final V1Metadata.IndexedDataFile fileWrapper;\n-  private Status status = Status.EXISTING;\n-  private Long snapshotId = null;\n-  private Long sequenceNumber = null;\n-  private DataFile file = null;\n-\n-  GenericManifestEntry(org.apache.avro.Schema schema) {\n-    this.schema = schema;\n-    this.fileWrapper = null; // do not use the file wrapper to read\n-  }\n-\n-  GenericManifestEntry(Types.StructType partitionType) {\n-    this.schema = AvroSchemaUtil.convert(V1Metadata.entrySchema(partitionType), \"manifest_entry\");\n-    this.fileWrapper = new V1Metadata.IndexedDataFile(schema.getField(\"data_file\").schema());\n-  }\n-\n-  private GenericManifestEntry(GenericManifestEntry toCopy, boolean fullCopy) {\n-    this.schema = toCopy.schema;\n-    this.fileWrapper = new V1Metadata.IndexedDataFile(schema.getField(\"data_file\").schema());\n-    this.status = toCopy.status;\n-    this.snapshotId = toCopy.snapshotId;\n-    if (fullCopy) {\n-      this.file = toCopy.file().copy();\n-    } else {\n-      this.file = toCopy.file().copyWithoutStats();\n-    }\n-  }\n-\n-  ManifestEntry wrapExisting(Long newSnapshotId, Long newSequenceNumber, DataFile newFile) {\n-    this.status = Status.EXISTING;\n-    this.snapshotId = newSnapshotId;\n-    this.sequenceNumber = newSequenceNumber;\n-    this.file = newFile;\n-    return this;\n-  }\n-\n-  ManifestEntry wrapAppend(Long newSnapshotId, DataFile newFile) {\n-    this.status = Status.ADDED;\n-    this.snapshotId = newSnapshotId;\n-    this.sequenceNumber = null;\n-    this.file = newFile;\n-    return this;\n-  }\n-\n-  ManifestEntry wrapDelete(Long newSnapshotId, DataFile newFile) {\n-    this.status = Status.DELETED;\n-    this.snapshotId = newSnapshotId;\n-    this.sequenceNumber = null;\n-    this.file = newFile;\n-    return this;\n-  }\n-\n-  /**\n-   * @return the status of the file, whether EXISTING, ADDED, or DELETED\n-   */\n-  public Status status() {\n-    return status;\n-  }\n-\n-  /**\n-   * @return id of the snapshot in which the file was added to the table\n-   */\n-  public Long snapshotId() {\n-    return snapshotId;\n-  }\n-\n-  @Override\n-  public Long sequenceNumber() {\n-    return sequenceNumber;\n-  }\n-\n-  /**\n-   * @return a file\n-   */\n-  public DataFile file() {\n-    return file;\n-  }\n-\n-  public ManifestEntry copy() {\n-    return new GenericManifestEntry(this, true /* full copy */);\n-  }\n-\n-  public ManifestEntry copyWithoutStats() {\n-    return new GenericManifestEntry(this, false /* drop stats */);\n-  }\n-\n-  @Override\n-  public void setSnapshotId(long newSnapshotId) {\n-    this.snapshotId = newSnapshotId;\n-  }\n-\n-  @Override\n-  public void setSequenceNumber(long newSequenceNumber) {\n-    this.sequenceNumber = newSequenceNumber;\n-  }\n-\n-  @Override\n-  public void put(int i, Object v) {\n-    switch (i) {\n-      case 0:\n-        this.status = Status.values()[(Integer) v];\n-        return;\n-      case 1:\n-        this.snapshotId = (Long) v;\n-        return;\n-      case 2:\n-        this.sequenceNumber = (Long) v;\n-        return;\n-      case 3:\n-        this.file = (DataFile) v;\n-        return;\n-      default:\n-        // ignore the object, it must be from a newer version of the format\n-    }\n-  }\n-\n-  @Override\n-  public Object get(int i) {\n-    switch (i) {\n-      case 0:\n-        return status.id();\n-      case 1:\n-        return snapshotId;\n-      case 2:\n-        return sequenceNumber;\n-      case 3:\n-        if (fileWrapper == null || file instanceof GenericDataFile) {\n-          return file;\n-        } else {\n-          return fileWrapper.wrap(file);\n-        }\n-      default:\n-        throw new UnsupportedOperationException(\"Unknown field ordinal: \" + i);\n-    }\n-  }\n-\n-  @Override\n-  public org.apache.avro.Schema getSchema() {\n-    return schema;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return MoreObjects.toStringHelper(this)\n-        .add(\"status\", status)\n-        .add(\"snapshot_id\", snapshotId)\n-        .add(\"file\", file)\n-        .toString();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI5ODE0NQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407298145", "bodyText": "The append/delete operations won't attach the sequence number to its entries ?", "author": "openinx", "createdAt": "2020-04-13T03:17:29Z", "path": "core/src/main/java/org/apache/iceberg/GenericManifestEntry.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.base.MoreObjects;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.avro.specific.SpecificData;\n+import org.apache.iceberg.avro.AvroSchemaUtil;\n+import org.apache.iceberg.types.Types;\n+\n+class GenericManifestEntry implements ManifestEntry, IndexedRecord, SpecificData.SchemaConstructable {\n+  private final org.apache.avro.Schema schema;\n+  private final V1Metadata.IndexedDataFile fileWrapper;\n+  private Status status = Status.EXISTING;\n+  private Long snapshotId = null;\n+  private Long sequenceNumber = null;\n+  private DataFile file = null;\n+\n+  GenericManifestEntry(org.apache.avro.Schema schema) {\n+    this.schema = schema;\n+    this.fileWrapper = null; // do not use the file wrapper to read\n+  }\n+\n+  GenericManifestEntry(Types.StructType partitionType) {\n+    this.schema = AvroSchemaUtil.convert(V1Metadata.entrySchema(partitionType), \"manifest_entry\");\n+    this.fileWrapper = new V1Metadata.IndexedDataFile(schema.getField(\"data_file\").schema());\n+  }\n+\n+  private GenericManifestEntry(GenericManifestEntry toCopy, boolean fullCopy) {\n+    this.schema = toCopy.schema;\n+    this.fileWrapper = new V1Metadata.IndexedDataFile(schema.getField(\"data_file\").schema());\n+    this.status = toCopy.status;\n+    this.snapshotId = toCopy.snapshotId;\n+    if (fullCopy) {\n+      this.file = toCopy.file().copy();\n+    } else {\n+      this.file = toCopy.file().copyWithoutStats();\n+    }\n+  }\n+\n+  ManifestEntry wrapExisting(Long newSnapshotId, Long newSequenceNumber, DataFile newFile) {\n+    this.status = Status.EXISTING;\n+    this.snapshotId = newSnapshotId;\n+    this.sequenceNumber = newSequenceNumber;\n+    this.file = newFile;\n+    return this;\n+  }\n+\n+  ManifestEntry wrapAppend(Long newSnapshotId, DataFile newFile) {\n+    this.status = Status.ADDED;\n+    this.snapshotId = newSnapshotId;\n+    this.sequenceNumber = null;", "originalCommit": "eaf78717b94097030098c790d7db74f231440408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NzEwOA==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407577108", "bodyText": "When a file is appended, it must have the sequence number of the snapshot where it is committed. The problem is that the sequence number isn't determined until the snapshot's commit is successful. Two committers may be racing to add a commit with the same sequence number.\nThat's why sequence numbers are assigned initially through inheritance. Every snapshot commit attempt writes a new root manifest list with a new sequence number based on the table metadata's last sequence number. If two writers are trying to commit different snapshots as sequence number 5, one will win and the other will retry with 6. To avoid rewriting the metadata tree below the manifest list, sequence numbers that might change are inherited instead of written into the initial files.", "author": "rdblue", "createdAt": "2020-04-13T16:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI5ODE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "1119159033cea2e6e79691a5f1389c327d926e6f", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/GenericManifestEntry.java b/core/src/main/java/org/apache/iceberg/GenericManifestEntry.java\ndeleted file mode 100644\nindex d1b1cc2a..00000000\n--- a/core/src/main/java/org/apache/iceberg/GenericManifestEntry.java\n+++ /dev/null\n\n@@ -1,179 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.iceberg;\n-\n-import com.google.common.base.MoreObjects;\n-import org.apache.avro.generic.IndexedRecord;\n-import org.apache.avro.specific.SpecificData;\n-import org.apache.iceberg.avro.AvroSchemaUtil;\n-import org.apache.iceberg.types.Types;\n-\n-class GenericManifestEntry implements ManifestEntry, IndexedRecord, SpecificData.SchemaConstructable {\n-  private final org.apache.avro.Schema schema;\n-  private final V1Metadata.IndexedDataFile fileWrapper;\n-  private Status status = Status.EXISTING;\n-  private Long snapshotId = null;\n-  private Long sequenceNumber = null;\n-  private DataFile file = null;\n-\n-  GenericManifestEntry(org.apache.avro.Schema schema) {\n-    this.schema = schema;\n-    this.fileWrapper = null; // do not use the file wrapper to read\n-  }\n-\n-  GenericManifestEntry(Types.StructType partitionType) {\n-    this.schema = AvroSchemaUtil.convert(V1Metadata.entrySchema(partitionType), \"manifest_entry\");\n-    this.fileWrapper = new V1Metadata.IndexedDataFile(schema.getField(\"data_file\").schema());\n-  }\n-\n-  private GenericManifestEntry(GenericManifestEntry toCopy, boolean fullCopy) {\n-    this.schema = toCopy.schema;\n-    this.fileWrapper = new V1Metadata.IndexedDataFile(schema.getField(\"data_file\").schema());\n-    this.status = toCopy.status;\n-    this.snapshotId = toCopy.snapshotId;\n-    if (fullCopy) {\n-      this.file = toCopy.file().copy();\n-    } else {\n-      this.file = toCopy.file().copyWithoutStats();\n-    }\n-  }\n-\n-  ManifestEntry wrapExisting(Long newSnapshotId, Long newSequenceNumber, DataFile newFile) {\n-    this.status = Status.EXISTING;\n-    this.snapshotId = newSnapshotId;\n-    this.sequenceNumber = newSequenceNumber;\n-    this.file = newFile;\n-    return this;\n-  }\n-\n-  ManifestEntry wrapAppend(Long newSnapshotId, DataFile newFile) {\n-    this.status = Status.ADDED;\n-    this.snapshotId = newSnapshotId;\n-    this.sequenceNumber = null;\n-    this.file = newFile;\n-    return this;\n-  }\n-\n-  ManifestEntry wrapDelete(Long newSnapshotId, DataFile newFile) {\n-    this.status = Status.DELETED;\n-    this.snapshotId = newSnapshotId;\n-    this.sequenceNumber = null;\n-    this.file = newFile;\n-    return this;\n-  }\n-\n-  /**\n-   * @return the status of the file, whether EXISTING, ADDED, or DELETED\n-   */\n-  public Status status() {\n-    return status;\n-  }\n-\n-  /**\n-   * @return id of the snapshot in which the file was added to the table\n-   */\n-  public Long snapshotId() {\n-    return snapshotId;\n-  }\n-\n-  @Override\n-  public Long sequenceNumber() {\n-    return sequenceNumber;\n-  }\n-\n-  /**\n-   * @return a file\n-   */\n-  public DataFile file() {\n-    return file;\n-  }\n-\n-  public ManifestEntry copy() {\n-    return new GenericManifestEntry(this, true /* full copy */);\n-  }\n-\n-  public ManifestEntry copyWithoutStats() {\n-    return new GenericManifestEntry(this, false /* drop stats */);\n-  }\n-\n-  @Override\n-  public void setSnapshotId(long newSnapshotId) {\n-    this.snapshotId = newSnapshotId;\n-  }\n-\n-  @Override\n-  public void setSequenceNumber(long newSequenceNumber) {\n-    this.sequenceNumber = newSequenceNumber;\n-  }\n-\n-  @Override\n-  public void put(int i, Object v) {\n-    switch (i) {\n-      case 0:\n-        this.status = Status.values()[(Integer) v];\n-        return;\n-      case 1:\n-        this.snapshotId = (Long) v;\n-        return;\n-      case 2:\n-        this.sequenceNumber = (Long) v;\n-        return;\n-      case 3:\n-        this.file = (DataFile) v;\n-        return;\n-      default:\n-        // ignore the object, it must be from a newer version of the format\n-    }\n-  }\n-\n-  @Override\n-  public Object get(int i) {\n-    switch (i) {\n-      case 0:\n-        return status.id();\n-      case 1:\n-        return snapshotId;\n-      case 2:\n-        return sequenceNumber;\n-      case 3:\n-        if (fileWrapper == null || file instanceof GenericDataFile) {\n-          return file;\n-        } else {\n-          return fileWrapper.wrap(file);\n-        }\n-      default:\n-        throw new UnsupportedOperationException(\"Unknown field ordinal: \" + i);\n-    }\n-  }\n-\n-  @Override\n-  public org.apache.avro.Schema getSchema() {\n-    return schema;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return MoreObjects.toStringHelper(this)\n-        .add(\"status\", status)\n-        .add(\"snapshot_id\", snapshotId)\n-        .add(\"file\", file)\n-        .toString();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI5OTExNQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407299115", "bodyText": "Here we're changing the position of snapshotId/addedFilesCount/ ... etc,   will it break the compatibility ?  I mean the new code couldn't read the old data manifest file ...", "author": "openinx", "createdAt": "2020-04-13T03:23:02Z", "path": "core/src/main/java/org/apache/iceberg/GenericManifestFile.java", "diffHunk": "@@ -257,21 +255,25 @@ public Object get(int i) {\n       case 2:\n         return specId;\n       case 3:\n-        return snapshotId;\n+        return sequenceNumber;", "originalCommit": "eaf78717b94097030098c790d7db74f231440408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NzgxNA==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407577814", "bodyText": "Changing the order won't break compatibility. The requirement here is that the order of fields in these classes must match the order of fields in the schema. That's why this commit freezes the v1 schema and an IndexedWriter for v1. That way, we can write exactly what we would have before for v1, but make changes for v2.", "author": "rdblue", "createdAt": "2020-04-13T16:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI5OTExNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0ODMxMQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407348311", "bodyText": "I'm not sure in which case we will encounter the snapshot == null, mind to explain the case ? Thanks.", "author": "openinx", "createdAt": "2020-04-13T07:00:44Z", "path": "core/src/main/java/org/apache/iceberg/InheritableMetadataFactory.java", "diffHunk": "@@ -30,22 +31,40 @@ static InheritableMetadata empty() {\n   }\n \n   static InheritableMetadata fromManifest(ManifestFile manifest) {\n-    return new BaseInheritableMetadata(manifest.snapshotId());\n+    if (manifest.snapshotId() != null) {\n+      return new BaseInheritableMetadata(manifest.snapshotId(), manifest.sequenceNumber());\n+    } else {\n+      return NOOP;", "originalCommit": "eaf78717b94097030098c790d7db74f231440408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MzM5Nw==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407583397", "bodyText": "Snapshot id is null when a manifest is appended to a table and the snapshot id hasn't been assigned yet.\nIf the manifest is committed to table metadata, then it will be set when writing and will always be present. That's why it is required in the v2 schema for manifest list files.\nSome appended manifests are rewritten before committing. When reading those to rewrite them, this path is used.\nI think I'm going to update how this works, but as a separate commit. The problem is that this allows reading a manifest without filling in the snapshot id. But the rewrite method where the reader that is configured this was is used has the snapshot id. So we should add the snapshot id to the ManifestFile and then read to avoid the special case.", "author": "rdblue", "createdAt": "2020-04-13T16:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0ODMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2OTUxNw==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r411569517", "bodyText": "A couple of questions here:\n\nNow added_snapshot_id is optional. Do we plan to make it required once we start assigning the snapshot in ManifestListWriter?\nWe cannot actually remove InheritableMetadata as there might be old manifests where added_snapshot_id is null, correct?", "author": "aokolnychyi", "createdAt": "2020-04-20T17:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0ODMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzOTI5MQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r411639291", "bodyText": "added_snapshot_id is optional because we used to store manifests as a list in the metadata.json file. V2 changes it to required because we always write a manifest-list with the inherited snapshot id and sequence number.\nMy comment about changing this wasn't about removing InheritableMetadata. It was about the path that rewrites the manifest and uses the no-op InheritableMetadata. I think that we can simplify this by making sure we set the snapshot ID on the ManifestFile before rewriting. That way any rewrite has the snapshot ID and we don't need a special case here.", "author": "rdblue", "createdAt": "2020-04-20T19:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0ODMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1MDE2Ng==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r411650166", "bodyText": "I asked about InheritableMetadata as I wondered myself whether we can remove that completely. Seems not.\nYeah, I like the idea of setting the snapshot id in ManifestFile before rewriting.", "author": "aokolnychyi", "createdAt": "2020-04-20T19:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0ODMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY5MDY4NQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r411690685", "bodyText": "I'll look into removing it entirely, although I don't mind it very much. As long as it is baked into the reader and unavoidable, it seems like a clean way to apply the inherited values.", "author": "rdblue", "createdAt": "2020-04-20T21:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0ODMxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "1119159033cea2e6e79691a5f1389c327d926e6f", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/InheritableMetadataFactory.java b/core/src/main/java/org/apache/iceberg/InheritableMetadataFactory.java\nindex 71e7a485..d05c20e8 100644\n--- a/core/src/main/java/org/apache/iceberg/InheritableMetadataFactory.java\n+++ b/core/src/main/java/org/apache/iceberg/InheritableMetadataFactory.java\n\n@@ -32,7 +32,7 @@ class InheritableMetadataFactory {\n \n   static InheritableMetadata fromManifest(ManifestFile manifest) {\n     if (manifest.snapshotId() != null) {\n-      return new BaseInheritableMetadata(manifest.snapshotId(), manifest.sequenceNumber());\n+      return new BaseInheritableMetadata(manifest.snapshotId());\n     } else {\n       return NOOP;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM1MzcxOQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407353719", "bodyText": "Why need to define this min sequence number ?  for manifest file filtering purpose in read path ?", "author": "openinx", "createdAt": "2020-04-13T07:18:54Z", "path": "api/src/main/java/org/apache/iceberg/ManifestFile.java", "diffHunk": "@@ -66,6 +77,16 @@ static Schema schema() {\n    */\n   int partitionSpecId();\n \n+  /**\n+   * @return the sequence number of the commit that added the manifest file\n+   */\n+  long sequenceNumber();\n+\n+  /**\n+   * @return the lowest sequence number of any data file in the manifest\n+   */\n+  long minSequenceNumber();", "originalCommit": "eaf78717b94097030098c790d7db74f231440408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4NTgzNQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407585835", "bodyText": "This is additional information for job planning and metadata maintenance.\nThis may change, but the initial idea is that if we have the min sequence number of a manifest, we can use that to filter other manifests for planning. For example, if I have a manifest with delete files that was written at sequence number 14, but only manifests with data files written at sequence number 16 and later, I can ignore the manifest with delete files.\nWe can do something similar when maintaining metadata. If we detect that a delete file is older than all data files then we can remove it.", "author": "rdblue", "createdAt": "2020-04-13T16:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM1MzcxOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk2MTk3MA==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407961970", "bodyText": "I don't see other places call this except a unit test. This may be misused, how about removing it?", "author": "chenjunjiedada", "createdAt": "2020-04-14T08:36:18Z", "path": "core/src/main/java/org/apache/iceberg/ManifestLists.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.iceberg.avro.Avro;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.InputFile;\n+import org.apache.iceberg.io.OutputFile;\n+\n+class ManifestLists {\n+  private ManifestLists() {\n+  }\n+\n+  static List<ManifestFile> read(InputFile manifestList) {\n+    try (CloseableIterable<ManifestFile> files = Avro.read(manifestList)\n+        .rename(\"manifest_file\", GenericManifestFile.class.getName())\n+        .rename(\"partitions\", GenericPartitionFieldSummary.class.getName())\n+        .rename(\"r508\", GenericPartitionFieldSummary.class.getName())\n+        .classLoader(GenericManifestFile.class.getClassLoader())\n+        .project(ManifestFile.schema())\n+        .reuseContainers(false)\n+        .build()) {\n+\n+      return Lists.newLinkedList(files);\n+\n+    } catch (IOException e) {\n+      throw new RuntimeIOException(e, \"Cannot read manifest list file: %s\", manifestList.location());\n+    }\n+  }\n+\n+  static ManifestListWriter write(int formatVersion, OutputFile manifestListFile,", "originalCommit": "eaf78717b94097030098c790d7db74f231440408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MjIwMQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r408272201", "bodyText": "Yeah, we probably will.", "author": "rdblue", "createdAt": "2020-04-14T16:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk2MTk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUzNDg3Nw==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r408534877", "bodyText": "Opened #921 to remove this.", "author": "rdblue", "createdAt": "2020-04-15T01:53:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk2MTk3MA=="}], "type": "inlineReview", "revised_code": {"commit": "9da51d5952873bbe3c5ef115b2fc3f40621c7ebd", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/ManifestLists.java b/core/src/main/java/org/apache/iceberg/ManifestLists.java\nindex 2bd00465..b1b5dc47 100644\n--- a/core/src/main/java/org/apache/iceberg/ManifestLists.java\n+++ b/core/src/main/java/org/apache/iceberg/ManifestLists.java\n\n@@ -69,5 +69,4 @@ class ManifestLists {\n     }\n     throw new UnsupportedOperationException(\"Cannot write manifest list for table version: \" + formatVersion);\n   }\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk2MjI5NQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407962295", "bodyText": "The document is duplicated with the one in ManifestWriter.write. We can remove this function definition and just call from there.", "author": "chenjunjiedada", "createdAt": "2020-04-14T08:36:47Z", "path": "core/src/main/java/org/apache/iceberg/ManifestFiles.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.Map;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.io.InputFile;\n+import org.apache.iceberg.io.OutputFile;\n+\n+public class ManifestFiles {\n+  private ManifestFiles() {\n+  }\n+\n+  /**\n+   * Returns a new {@link ManifestReader} for a {@link ManifestFile}.\n+   * <p>\n+   * <em>Note:</em> Callers should use {@link ManifestFiles#read(ManifestFile, FileIO, Map)} to ensure\n+   * the schema used by filters is the latest table schema. This should be used only when reading\n+   * a manifest without filters.\n+   *\n+   * @param manifest a ManifestFile\n+   * @param io a FileIO\n+   * @return a manifest reader\n+   */\n+  public static ManifestReader read(ManifestFile manifest, FileIO io) {\n+    return read(manifest, io, null);\n+  }\n+\n+  /**\n+   * Returns a new {@link ManifestReader} for a {@link ManifestFile}.\n+   *\n+   * @param manifest a {@link ManifestFile}\n+   * @param io a {@link FileIO}\n+   * @param specsById a Map from spec ID to partition spec\n+   * @return a {@link ManifestReader}\n+   */\n+  public static ManifestReader read(ManifestFile manifest, FileIO io, Map<Integer, PartitionSpec> specsById) {\n+    InputFile file = io.newInputFile(manifest.path());\n+    InheritableMetadata inheritableMetadata = InheritableMetadataFactory.fromManifest(manifest);\n+    return new ManifestReader(file, specsById, inheritableMetadata);\n+  }\n+\n+  /**\n+   * Create a new {@link ManifestWriter}.\n+   * <p>\n+   * Manifests created by this writer have all entry snapshot IDs set to null.\n+   * All entries will inherit the snapshot ID that will be assigned to the manifest on commit.\n+   *\n+   * @param spec {@link PartitionSpec} used to produce {@link DataFile} partition tuples\n+   * @param outputFile the destination file location\n+   * @return a manifest writer\n+   */\n+  public static ManifestWriter write(PartitionSpec spec, OutputFile outputFile) {", "originalCommit": "eaf78717b94097030098c790d7db74f231440408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MTEyMg==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r408271122", "bodyText": "The one in ManifestWriter was released in version 0.7 so we don't want to remove it from the public API without a period of deprecation. However, we do want to move the factory methods here.", "author": "rdblue", "createdAt": "2020-04-14T16:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk2MjI5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUzNDMxMQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r408534311", "bodyText": "I see, thanks for the explanation.", "author": "chenjunjiedada", "createdAt": "2020-04-15T01:51:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk2MjI5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "9da51d5952873bbe3c5ef115b2fc3f40621c7ebd", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/ManifestFiles.java b/core/src/main/java/org/apache/iceberg/ManifestFiles.java\nindex 017d8eb0..2b13acce 100644\n--- a/core/src/main/java/org/apache/iceberg/ManifestFiles.java\n+++ b/core/src/main/java/org/apache/iceberg/ManifestFiles.java\n\n@@ -20,7 +20,11 @@\n package org.apache.iceberg;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.Sets;\n+import java.io.IOException;\n import java.util.Map;\n+import java.util.Set;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n import org.apache.iceberg.io.FileIO;\n import org.apache.iceberg.io.InputFile;\n import org.apache.iceberg.io.OutputFile;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3MzczNQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407973735", "bodyText": "Does this mean that a manifest file with a new snapshot id must have a sequence number?  Maybe add a more detailed reason in the exception message for this.", "author": "chenjunjiedada", "createdAt": "2020-04-14T08:54:50Z", "path": "core/src/main/java/org/apache/iceberg/V2Metadata.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.List;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.iceberg.avro.AvroSchemaUtil;\n+import org.apache.iceberg.types.Types;\n+\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+class V2Metadata {\n+  private V2Metadata() {\n+  }\n+\n+  // fields for v2 write schema for required metadata\n+  static final Types.NestedField REQUIRED_SNAPSHOT_ID =\n+      required(503, \"added_snapshot_id\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_ADDED_FILES_COUNT =\n+      required(504, \"added_data_files_count\", Types.IntegerType.get());\n+  static final Types.NestedField REQUIRED_EXISTING_FILES_COUNT =\n+      required(505, \"existing_data_files_count\", Types.IntegerType.get());\n+  static final Types.NestedField REQUIRED_DELETED_FILES_COUNT =\n+      required(506, \"deleted_data_files_count\", Types.IntegerType.get());\n+  static final Types.NestedField REQUIRED_ADDED_ROWS_COUNT =\n+      required(512, \"added_rows_count\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_EXISTING_ROWS_COUNT =\n+      required(513, \"existing_rows_count\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_DELETED_ROWS_COUNT =\n+      required(514, \"deleted_rows_count\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_SEQUENCE_NUMBER =\n+      required(515, \"sequence_number\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_MIN_SEQUENCE_NUMBER =\n+      required(516, \"min_sequence_number\", Types.LongType.get());\n+\n+  static final Schema MANIFEST_LIST_SCHEMA = new Schema(\n+      ManifestFile.PATH, ManifestFile.LENGTH, ManifestFile.SPEC_ID,\n+      REQUIRED_SEQUENCE_NUMBER, REQUIRED_MIN_SEQUENCE_NUMBER, REQUIRED_SNAPSHOT_ID,\n+      REQUIRED_ADDED_FILES_COUNT, REQUIRED_EXISTING_FILES_COUNT, REQUIRED_DELETED_FILES_COUNT,\n+      REQUIRED_ADDED_ROWS_COUNT, REQUIRED_EXISTING_ROWS_COUNT, REQUIRED_DELETED_ROWS_COUNT,\n+      ManifestFile.PARTITION_SUMMARIES);\n+\n+\n+  /**\n+   * A wrapper class to write any ManifestFile implementation to Avro using the v2 write schema.\n+   *\n+   * This is used to maintain compatibility with v2 by writing manifest list files with the old schema, instead of\n+   * writing a sequence number into metadata files in v2 tables.\n+   */\n+  static class IndexedManifestFile implements ManifestFile, IndexedRecord {\n+    private static final org.apache.avro.Schema AVRO_SCHEMA =\n+        AvroSchemaUtil.convert(MANIFEST_LIST_SCHEMA, \"manifest_file\");\n+\n+    private final long snapshotId;\n+    private final long sequenceNumber;\n+    private ManifestFile wrapped = null;\n+\n+    IndexedManifestFile(long snapshotId, long sequenceNumber) {\n+      this.snapshotId = snapshotId;\n+      this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    public ManifestFile wrap(ManifestFile file) {\n+      this.wrapped = file;\n+      return this;\n+    }\n+\n+    @Override\n+    public org.apache.avro.Schema getSchema() {\n+      return AVRO_SCHEMA;\n+    }\n+\n+    @Override\n+    public void put(int i, Object v) {\n+      throw new UnsupportedOperationException(\"Cannot read using IndexedManifestFile\");\n+    }\n+\n+    @Override\n+    public Object get(int pos) {\n+      switch (pos) {\n+        case 0:\n+          return wrapped.path();\n+        case 1:\n+          return wrapped.length();\n+        case 2:\n+          return wrapped.partitionSpecId();\n+        case 3:\n+          if (wrapped.sequenceNumber() == ManifestWriter.UNASSIGNED_SEQ) {\n+            Preconditions.checkState(snapshotId == wrapped.snapshotId(),", "originalCommit": "eaf78717b94097030098c790d7db74f231440408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MzQzOQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r408273439", "bodyText": "This validates that only new manifests created by the current snapshot will have the sequence number added on write.", "author": "rdblue", "createdAt": "2020-04-14T16:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3MzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUzNDU0Ng==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r408534546", "bodyText": "I added a better comment here.", "author": "rdblue", "createdAt": "2020-04-15T01:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3MzczNQ=="}], "type": "inlineReview", "revised_code": {"commit": "1119159033cea2e6e79691a5f1389c327d926e6f", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/V2Metadata.java b/core/src/main/java/org/apache/iceberg/V2Metadata.java\nindex 261b58cd..600506d4 100644\n--- a/core/src/main/java/org/apache/iceberg/V2Metadata.java\n+++ b/core/src/main/java/org/apache/iceberg/V2Metadata.java\n\n@@ -19,7 +19,6 @@\n \n package org.apache.iceberg;\n \n-import com.google.common.base.Preconditions;\n import java.util.List;\n import org.apache.avro.generic.IndexedRecord;\n import org.apache.iceberg.avro.AvroSchemaUtil;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk4ODE5NQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r407988195", "bodyText": "I think this also needs some detail or document about why it happens.", "author": "chenjunjiedada", "createdAt": "2020-04-14T09:17:08Z", "path": "core/src/main/java/org/apache/iceberg/V2Metadata.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.List;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.iceberg.avro.AvroSchemaUtil;\n+import org.apache.iceberg.types.Types;\n+\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+class V2Metadata {\n+  private V2Metadata() {\n+  }\n+\n+  // fields for v2 write schema for required metadata\n+  static final Types.NestedField REQUIRED_SNAPSHOT_ID =\n+      required(503, \"added_snapshot_id\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_ADDED_FILES_COUNT =\n+      required(504, \"added_data_files_count\", Types.IntegerType.get());\n+  static final Types.NestedField REQUIRED_EXISTING_FILES_COUNT =\n+      required(505, \"existing_data_files_count\", Types.IntegerType.get());\n+  static final Types.NestedField REQUIRED_DELETED_FILES_COUNT =\n+      required(506, \"deleted_data_files_count\", Types.IntegerType.get());\n+  static final Types.NestedField REQUIRED_ADDED_ROWS_COUNT =\n+      required(512, \"added_rows_count\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_EXISTING_ROWS_COUNT =\n+      required(513, \"existing_rows_count\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_DELETED_ROWS_COUNT =\n+      required(514, \"deleted_rows_count\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_SEQUENCE_NUMBER =\n+      required(515, \"sequence_number\", Types.LongType.get());\n+  static final Types.NestedField REQUIRED_MIN_SEQUENCE_NUMBER =\n+      required(516, \"min_sequence_number\", Types.LongType.get());\n+\n+  static final Schema MANIFEST_LIST_SCHEMA = new Schema(\n+      ManifestFile.PATH, ManifestFile.LENGTH, ManifestFile.SPEC_ID,\n+      REQUIRED_SEQUENCE_NUMBER, REQUIRED_MIN_SEQUENCE_NUMBER, REQUIRED_SNAPSHOT_ID,\n+      REQUIRED_ADDED_FILES_COUNT, REQUIRED_EXISTING_FILES_COUNT, REQUIRED_DELETED_FILES_COUNT,\n+      REQUIRED_ADDED_ROWS_COUNT, REQUIRED_EXISTING_ROWS_COUNT, REQUIRED_DELETED_ROWS_COUNT,\n+      ManifestFile.PARTITION_SUMMARIES);\n+\n+\n+  /**\n+   * A wrapper class to write any ManifestFile implementation to Avro using the v2 write schema.\n+   *\n+   * This is used to maintain compatibility with v2 by writing manifest list files with the old schema, instead of\n+   * writing a sequence number into metadata files in v2 tables.\n+   */\n+  static class IndexedManifestFile implements ManifestFile, IndexedRecord {\n+    private static final org.apache.avro.Schema AVRO_SCHEMA =\n+        AvroSchemaUtil.convert(MANIFEST_LIST_SCHEMA, \"manifest_file\");\n+\n+    private final long snapshotId;\n+    private final long sequenceNumber;\n+    private ManifestFile wrapped = null;\n+\n+    IndexedManifestFile(long snapshotId, long sequenceNumber) {\n+      this.snapshotId = snapshotId;\n+      this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    public ManifestFile wrap(ManifestFile file) {\n+      this.wrapped = file;\n+      return this;\n+    }\n+\n+    @Override\n+    public org.apache.avro.Schema getSchema() {\n+      return AVRO_SCHEMA;\n+    }\n+\n+    @Override\n+    public void put(int i, Object v) {\n+      throw new UnsupportedOperationException(\"Cannot read using IndexedManifestFile\");\n+    }\n+\n+    @Override\n+    public Object get(int pos) {\n+      switch (pos) {\n+        case 0:\n+          return wrapped.path();\n+        case 1:\n+          return wrapped.length();\n+        case 2:\n+          return wrapped.partitionSpecId();\n+        case 3:\n+          if (wrapped.sequenceNumber() == ManifestWriter.UNASSIGNED_SEQ) {\n+            Preconditions.checkState(snapshotId == wrapped.snapshotId(),\n+                \"Found unassigned sequence number for a manifest from snapshot: %s\", wrapped.snapshotId());\n+            return sequenceNumber;\n+          } else {\n+            return wrapped.sequenceNumber();\n+          }\n+        case 4:\n+          return wrapped.minSequenceNumber();\n+        case 5:\n+          return wrapped.snapshotId();\n+        case 6:\n+          return wrapped.addedFilesCount();\n+        case 7:\n+          return wrapped.existingFilesCount();\n+        case 8:\n+          return wrapped.deletedFilesCount();\n+        case 9:\n+          return wrapped.addedRowsCount();\n+        case 10:\n+          return wrapped.existingRowsCount();\n+        case 11:\n+          return wrapped.deletedRowsCount();\n+        case 12:\n+          return wrapped.partitions();\n+        default:\n+          throw new UnsupportedOperationException(\"Unknown field ordinal: \" + pos);\n+      }\n+    }\n+\n+    @Override\n+    public String path() {\n+      return wrapped.path();\n+    }\n+\n+    @Override\n+    public long length() {\n+      return wrapped.length();\n+    }\n+\n+    @Override\n+    public int partitionSpecId() {\n+      return wrapped.partitionSpecId();\n+    }\n+\n+    @Override\n+    public long sequenceNumber() {\n+      return wrapped.sequenceNumber();\n+    }\n+\n+    @Override\n+    public long minSequenceNumber() {\n+      return wrapped.minSequenceNumber();\n+    }\n+\n+    @Override\n+    public Long snapshotId() {\n+      return wrapped.snapshotId();\n+    }\n+\n+    @Override\n+    public boolean hasAddedFiles() {\n+      return wrapped.hasAddedFiles();\n+    }\n+\n+    @Override\n+    public Integer addedFilesCount() {\n+      return wrapped.addedFilesCount();\n+    }\n+\n+    @Override\n+    public Long addedRowsCount() {\n+      return wrapped.addedRowsCount();\n+    }\n+\n+    @Override\n+    public boolean hasExistingFiles() {\n+      return wrapped.hasExistingFiles();\n+    }\n+\n+    @Override\n+    public Integer existingFilesCount() {\n+      return wrapped.existingFilesCount();\n+    }\n+\n+    @Override\n+    public Long existingRowsCount() {\n+      return wrapped.existingRowsCount();\n+    }\n+\n+    @Override\n+    public boolean hasDeletedFiles() {\n+      return wrapped.hasDeletedFiles();\n+    }\n+\n+    @Override\n+    public Integer deletedFilesCount() {\n+      return wrapped.deletedFilesCount();\n+    }\n+\n+    @Override\n+    public Long deletedRowsCount() {\n+      return wrapped.deletedRowsCount();\n+    }\n+\n+    @Override\n+    public List<PartitionFieldSummary> partitions() {\n+      return wrapped.partitions();\n+    }\n+\n+    @Override\n+    public ManifestFile copy() {\n+      return wrapped.copy();\n+    }\n+  }\n+\n+  static Schema entrySchema(Types.StructType partitionType) {\n+    return wrapFileSchema(DataFile.getType(partitionType));\n+  }\n+\n+  static Schema wrapFileSchema(Types.StructType fileSchema) {\n+    // this is used to build projection schemas\n+    return new Schema(\n+        ManifestEntry.STATUS, ManifestEntry.SNAPSHOT_ID,\n+        required(ManifestEntry.DATA_FILE_ID, \"data_file\", fileSchema));\n+  }\n+\n+  static class IndexedManifestEntry implements ManifestEntry, IndexedRecord {\n+    private final org.apache.avro.Schema avroSchema;\n+    private final long snapshotId;\n+    private final V1Metadata.IndexedDataFile fileWrapper;\n+    private ManifestEntry wrapped = null;\n+\n+    IndexedManifestEntry(long snapshotId, Types.StructType partitionType) {\n+      this.avroSchema = AvroSchemaUtil.convert(entrySchema(partitionType), \"manifest_entry\");\n+      this.snapshotId = snapshotId;\n+      // TODO: when v2 data files differ from v1, this should use a v2 wrapper\n+      this.fileWrapper = new V1Metadata.IndexedDataFile(avroSchema.getField(\"data_file\").schema());\n+    }\n+\n+    public IndexedManifestEntry wrap(ManifestEntry entry) {\n+      this.wrapped = entry;\n+      return this;\n+    }\n+\n+    @Override\n+    public org.apache.avro.Schema getSchema() {\n+      return avroSchema;\n+    }\n+\n+    @Override\n+    public void put(int i, Object v) {\n+      throw new UnsupportedOperationException(\"Cannot read using IndexedManifestEntry\");\n+    }\n+\n+    @Override\n+    public Object get(int i) {\n+      switch (i) {\n+        case 0:\n+          return wrapped.status().id();\n+        case 1:\n+          return wrapped.snapshotId();\n+        case 2:\n+          if (wrapped.sequenceNumber() == null) {\n+            Preconditions.checkState(wrapped.snapshotId() == null || snapshotId == wrapped.snapshotId(),", "originalCommit": "eaf78717b94097030098c790d7db74f231440408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUzNDU5NA==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r408534594", "bodyText": "I added a comment to explain here as well.", "author": "rdblue", "createdAt": "2020-04-15T01:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk4ODE5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "1119159033cea2e6e79691a5f1389c327d926e6f", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/V2Metadata.java b/core/src/main/java/org/apache/iceberg/V2Metadata.java\nindex 261b58cd..600506d4 100644\n--- a/core/src/main/java/org/apache/iceberg/V2Metadata.java\n+++ b/core/src/main/java/org/apache/iceberg/V2Metadata.java\n\n@@ -19,7 +19,6 @@\n \n package org.apache.iceberg;\n \n-import com.google.common.base.Preconditions;\n import java.util.List;\n import org.apache.avro.generic.IndexedRecord;\n import org.apache.iceberg.avro.AvroSchemaUtil;\n"}}, {"oid": "9da51d5952873bbe3c5ef115b2fc3f40621c7ebd", "url": "https://github.com/apache/iceberg/commit/9da51d5952873bbe3c5ef115b2fc3f40621c7ebd", "message": "Move copyManifest methods and add format version argument.", "committedDate": "2020-04-15T01:38:30Z", "type": "forcePushed"}, {"oid": "1119159033cea2e6e79691a5f1389c327d926e6f", "url": "https://github.com/apache/iceberg/commit/1119159033cea2e6e79691a5f1389c327d926e6f", "message": "Extract ManifestEntry interface and snapshot v1 manifest entries.", "committedDate": "2020-04-16T22:51:24Z", "type": "commit"}, {"oid": "ed23f65c7cc4adc582b2712beae71b6144bbfc20", "url": "https://github.com/apache/iceberg/commit/ed23f65c7cc4adc582b2712beae71b6144bbfc20", "message": "Move GenericManifestEntry to a separate file.", "committedDate": "2020-04-16T22:51:24Z", "type": "commit"}, {"oid": "2e53e316970e9bb6263e9612d2179e924bed94d5", "url": "https://github.com/apache/iceberg/commit/2e53e316970e9bb6263e9612d2179e924bed94d5", "message": "Add v2 manifest writer and ManifestEntry sequence number.", "committedDate": "2020-04-16T22:53:28Z", "type": "commit"}, {"oid": "da63373bcd06e2693d3c7072ec54e88d291329e2", "url": "https://github.com/apache/iceberg/commit/da63373bcd06e2693d3c7072ec54e88d291329e2", "message": "Add sequence number to GenericManfiestEntry#toString.", "committedDate": "2020-04-16T22:54:01Z", "type": "commit"}, {"oid": "285da49dc096565dff1dfc42d9d80d4d3a0175b6", "url": "https://github.com/apache/iceberg/commit/285da49dc096565dff1dfc42d9d80d4d3a0175b6", "message": "Add more comments to explain sequence numbers in v2 metadata.", "committedDate": "2020-04-16T22:54:01Z", "type": "commit"}, {"oid": "662eb6a48a519b127bc220c363dca5b241e50212", "url": "https://github.com/apache/iceberg/commit/662eb6a48a519b127bc220c363dca5b241e50212", "message": "Fix checkstyle errors.", "committedDate": "2020-04-16T22:54:01Z", "type": "commit"}, {"oid": "d4eb3b41cd019303d6ce760f44ae4696c2bea1ef", "url": "https://github.com/apache/iceberg/commit/d4eb3b41cd019303d6ce760f44ae4696c2bea1ef", "message": "Handle missing sequence numbers when calculating min.", "committedDate": "2020-04-16T22:54:01Z", "type": "commit"}, {"oid": "d4eb3b41cd019303d6ce760f44ae4696c2bea1ef", "url": "https://github.com/apache/iceberg/commit/d4eb3b41cd019303d6ce760f44ae4696c2bea1ef", "message": "Handle missing sequence numbers when calculating min.", "committedDate": "2020-04-16T22:54:01Z", "type": "forcePushed"}, {"oid": "53e311974102d5e1534534751698e225a8e412d9", "url": "https://github.com/apache/iceberg/commit/53e311974102d5e1534534751698e225a8e412d9", "message": "Add more comments, fill in min seq number, and other minor fixes.", "committedDate": "2020-04-16T23:17:01Z", "type": "commit"}, {"oid": "86cf1b80e33e30fff6795f12f73443439956dd64", "url": "https://github.com/apache/iceberg/commit/86cf1b80e33e30fff6795f12f73443439956dd64", "message": "Add v1 and v2 format test for manifest files.", "committedDate": "2020-04-17T01:15:31Z", "type": "forcePushed"}, {"oid": "5377393c197c4be30515dc8cd6738bceac131d65", "url": "https://github.com/apache/iceberg/commit/5377393c197c4be30515dc8cd6738bceac131d65", "message": "Add v1 and v2 format test for manifest files.", "committedDate": "2020-04-17T01:16:30Z", "type": "forcePushed"}, {"oid": "b61fb6a70f8d3dbdf7b15ccea96f759850f36df9", "url": "https://github.com/apache/iceberg/commit/b61fb6a70f8d3dbdf7b15ccea96f759850f36df9", "message": "Add v1 and v2 format test for manifest files.", "committedDate": "2020-04-17T01:20:11Z", "type": "commit"}, {"oid": "b61fb6a70f8d3dbdf7b15ccea96f759850f36df9", "url": "https://github.com/apache/iceberg/commit/b61fb6a70f8d3dbdf7b15ccea96f759850f36df9", "message": "Add v1 and v2 format test for manifest files.", "committedDate": "2020-04-17T01:20:11Z", "type": "forcePushed"}, {"oid": "af1d77f7cd3ccbca164e66472983d1b6f1be9ef3", "url": "https://github.com/apache/iceberg/commit/af1d77f7cd3ccbca164e66472983d1b6f1be9ef3", "message": "Add another v2 format test.", "committedDate": "2020-04-17T16:57:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzMDMzMw==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r411630333", "bodyText": "nit: I think we need to update the Javadoc.", "author": "aokolnychyi", "createdAt": "2020-04-20T19:22:17Z", "path": "core/src/main/java/org/apache/iceberg/ManifestWriter.java", "diffHunk": "@@ -116,12 +126,12 @@ void add(ManifestEntry entry) {\n    * @param existingFile a data file\n    * @param fileSnapshotId snapshot ID when the data file was added to the table\n    */\n-  public void existing(DataFile existingFile, long fileSnapshotId) {\n-    addEntry(reused.wrapExisting(fileSnapshotId, existingFile));\n+  public void existing(DataFile existingFile, long fileSnapshotId, long sequenceNumber) {", "originalCommit": "af1d77f7cd3ccbca164e66472983d1b6f1be9ef3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzMzYyOA==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r411633628", "bodyText": "Also, I am using this method in the rewrite manifests action. The entries metadata table will have sequenceNumber but its value will be 0, correct?", "author": "aokolnychyi", "createdAt": "2020-04-20T19:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzMDMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY0MTQyMQ==", "url": "https://github.com/apache/iceberg/pull/913#discussion_r411641421", "bodyText": "The new action should use the sequence number from the metadata table. That will be 0 for metadata written without sequence numbers, or the correct sequence number for v2 tables.", "author": "rdblue", "createdAt": "2020-04-20T19:41:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzMDMzMw=="}], "type": "inlineReview", "revised_code": {"commit": "4b7c8f193e133e50d8f2ca858e50bb5930421adb", "chunk": "diff --git a/core/src/main/java/org/apache/iceberg/ManifestWriter.java b/core/src/main/java/org/apache/iceberg/ManifestWriter.java\nindex ece7d510..97065bf1 100644\n--- a/core/src/main/java/org/apache/iceberg/ManifestWriter.java\n+++ b/core/src/main/java/org/apache/iceberg/ManifestWriter.java\n\n@@ -125,6 +125,7 @@ public abstract class ManifestWriter implements FileAppender<DataFile> {\n    *\n    * @param existingFile a data file\n    * @param fileSnapshotId snapshot ID when the data file was added to the table\n+   * @param sequenceNumber sequence number for the data file\n    */\n   public void existing(DataFile existingFile, long fileSnapshotId, long sequenceNumber) {\n     addEntry(reused.wrapExisting(fileSnapshotId, sequenceNumber, existingFile));\n"}}, {"oid": "4b7c8f193e133e50d8f2ca858e50bb5930421adb", "url": "https://github.com/apache/iceberg/commit/4b7c8f193e133e50d8f2ca858e50bb5930421adb", "message": "Update Javadoc.", "committedDate": "2020-04-20T19:43:34Z", "type": "commit"}]}