{"pr_number": 1140, "pr_title": "ORC: skip non-iceberg columns when converting schema to Iceberg", "pr_createdAt": "2020-06-26T18:37:00Z", "pr_url": "https://github.com/apache/iceberg/pull/1140", "timeline": [{"oid": "9104949e6bd7c62a3203550b2d003c4849fc2875", "url": "https://github.com/apache/iceberg/commit/9104949e6bd7c62a3203550b2d003c4849fc2875", "message": "Skip columns without iceberg ids on schema conversion", "committedDate": "2020-06-23T17:24:37Z", "type": "commit"}, {"oid": "2970838dbc70a2eec8ce454c435aacfa0ac4c82c", "url": "https://github.com/apache/iceberg/commit/2970838dbc70a2eec8ce454c435aacfa0ac4c82c", "message": "Fix NPE on null list in ORC type visitor", "committedDate": "2020-06-25T18:30:08Z", "type": "commit"}, {"oid": "e74640c29b1dae917059e2cb201715c4344abce5", "url": "https://github.com/apache/iceberg/commit/e74640c29b1dae917059e2cb201715c4344abce5", "message": "Fix #1055 Use visitor to convert ORC schema to Iceberg\n\nThis change also skips columns that do not have an Iceberg ID attribute.", "committedDate": "2020-06-25T22:07:27Z", "type": "commit"}, {"oid": "d66cb470ef45a25c2726bb1255fb3cf4bb981d2a", "url": "https://github.com/apache/iceberg/commit/d66cb470ef45a25c2726bb1255fb3cf4bb981d2a", "message": "Add test for skipping non-iceberg columns in ORC", "committedDate": "2020-06-26T18:33:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUzODQyNA==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r446538424", "bodyText": "I think the javadoc on this method needs revision?", "author": "rdsr", "createdAt": "2020-06-27T15:37:25Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -214,10 +212,13 @@ public static Schema convert(TypeDescription orcSchema) {\n         \"Error in ORC file, children fields and names do not match.\");\n \n     List<Types.NestedField> icebergFields = Lists.newArrayListWithExpectedSize(children.size());\n-    AtomicInteger lastColumnId = new AtomicInteger(getMaxIcebergId(orcSchema));", "originalCommit": "d66cb470ef45a25c2726bb1255fb3cf4bb981d2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE0NjQ0MQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r447146441", "bodyText": "Done.", "author": "edgarRd", "createdAt": "2020-06-29T17:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUzODQyNA=="}], "type": "inlineReview", "revised_code": {"commit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "chunk": "diff --git a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\nindex ee1210b99..9a1521cc5 100644\n--- a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n+++ b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n\n@@ -214,7 +215,7 @@ public final class ORCSchemaUtil {\n     List<Types.NestedField> icebergFields = Lists.newArrayListWithExpectedSize(children.size());\n     OrcToIcebergVisitor schemaConverter = new OrcToIcebergVisitor(icebergToOrcMapping(\"root\", orcSchema));\n     for (TypeDescription child : orcSchema.getChildren()) {\n-      OrcToIcebergVisitor.visit((Type) null, child, schemaConverter).ifPresent(icebergFields::add);\n+      OrcToIcebergVisitor.visit(child, schemaConverter).ifPresent(icebergFields::add);\n     }\n \n     if (icebergFields.size() == 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0MDE1MQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r446540151", "bodyText": "I wonder if this logic should be in the visitor impl, The visitor  superclass should only be concerned with traversal, IMO", "author": "rdsr", "createdAt": "2020-06-27T15:56:20Z", "path": "orc/src/main/java/org/apache/iceberg/orc/OrcSchemaWithTypeVisitor.java", "diffHunk": "@@ -63,12 +68,20 @@\n     List<TypeDescription> fields = record.getChildren();\n     List<String> names = record.getFieldNames();\n     List<T> results = Lists.newArrayListWithExpectedSize(fields.size());\n-    for (TypeDescription field : fields) {\n-      int fieldId = ORCSchemaUtil.fieldId(field);\n-      Types.NestedField iField = struct != null ? struct.field(fieldId) : null;\n+    List<String> includedNames = Lists.newArrayListWithExpectedSize(names.size());\n+    for (int i = 0; i < fields.size(); ++i) {\n+      TypeDescription field = fields.get(i);\n+      String name = names.get(i);\n+      Optional<Integer> fieldId = ORCSchemaUtil.icebergID(field);", "originalCommit": "d66cb470ef45a25c2726bb1255fb3cf4bb981d2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzMjEzNg==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r447132136", "bodyText": "I generally agree that the visitor should only be concerned with the traversal. However, in this case I think the requirement of having knowledge of the fieldId  was already embedded in this visitor due to traversing the Iceberg schema as well - which seems like it's assumed to be a full conversion of the TypeDescription, if a field was not found instead it would just fail the process.\nI think it'd be better to have a generic OrcSchemaVisitor without context on the Iceberg Schema.", "author": "edgarRd", "createdAt": "2020-06-29T17:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0MDE1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "chunk": "diff --git a/orc/src/main/java/org/apache/iceberg/orc/OrcSchemaWithTypeVisitor.java b/orc/src/main/java/org/apache/iceberg/orc/OrcSchemaWithTypeVisitor.java\nindex 98976f55c..53b0c9f2f 100644\n--- a/orc/src/main/java/org/apache/iceberg/orc/OrcSchemaWithTypeVisitor.java\n+++ b/orc/src/main/java/org/apache/iceberg/orc/OrcSchemaWithTypeVisitor.java\n\n@@ -68,20 +63,12 @@ public abstract class OrcSchemaWithTypeVisitor<T> {\n     List<TypeDescription> fields = record.getChildren();\n     List<String> names = record.getFieldNames();\n     List<T> results = Lists.newArrayListWithExpectedSize(fields.size());\n-    List<String> includedNames = Lists.newArrayListWithExpectedSize(names.size());\n-    for (int i = 0; i < fields.size(); ++i) {\n-      TypeDescription field = fields.get(i);\n-      String name = names.get(i);\n-      Optional<Integer> fieldId = ORCSchemaUtil.icebergID(field);\n-      if (!fieldId.isPresent()) {\n-        LOG.warn(\"Missing expected '{}' property - skipping field {}\", ORCSchemaUtil.ICEBERG_ID_ATTRIBUTE, name);\n-        continue;\n-      }\n-      Types.NestedField iField = struct != null ? struct.field(fieldId.get()) : null;\n+    for (TypeDescription field : fields) {\n+      int fieldId = ORCSchemaUtil.fieldId(field);\n+      Types.NestedField iField = struct != null ? struct.field(fieldId) : null;\n       results.add(visit(iField != null ? iField.type() : null, field, visitor));\n-      includedNames.add(name);\n     }\n-    return visitor.record(struct, record, includedNames, results);\n+    return visitor.record(struct, record, names, results);\n   }\n \n   public T record(Types.StructType iStruct, TypeDescription record, List<String> names, List<T> fields) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0MDM0Ng==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r446540346", "bodyText": "Would it make sense to define an OrcSchemaVisitor visitor, similar to org.apache.iceberg.avro.AvroSchemaVisitor.  Here we are not making use of the Iceberg type parameter at all and that could be a little confusing.", "author": "rdsr", "createdAt": "2020-06-27T15:59:03Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -403,114 +398,150 @@ private static boolean isRequired(TypeDescription orcType) {\n         Types.NestedField.optional(icebergID, name, type);\n   }\n \n-  private static Types.NestedField convertOrcToIceberg(TypeDescription orcType, String name,\n-                                                       TypeUtil.NextID nextID) {\n+  private static class OrcToIcebergVisitor extends OrcSchemaWithTypeVisitor<Optional<Types.NestedField>> {\n \n-    final int icebergID = icebergID(orcType).orElseGet(nextID::get);\n-    final boolean isRequired = isRequired(orcType);\n+    private final Map<Integer, OrcField> icebergToOrcMapping;\n \n-    switch (orcType.getCategory()) {\n-      case BOOLEAN:\n-        return getIcebergType(icebergID, name, Types.BooleanType.get(), isRequired);\n-      case BYTE:\n-      case SHORT:\n-      case INT:\n-        return getIcebergType(icebergID, name, Types.IntegerType.get(), isRequired);\n-      case LONG:\n-        String longAttributeValue = orcType.getAttributeValue(ICEBERG_LONG_TYPE_ATTRIBUTE);\n-        LongType longType = longAttributeValue == null ? LongType.LONG : LongType.valueOf(longAttributeValue);\n-        switch (longType) {\n-          case TIME:\n-            return getIcebergType(icebergID, name, Types.TimeType.get(), isRequired);\n-          case LONG:\n-            return getIcebergType(icebergID, name, Types.LongType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Long type found in ORC type attribute\");\n-        }\n-      case FLOAT:\n-        return getIcebergType(icebergID, name, Types.FloatType.get(), isRequired);\n-      case DOUBLE:\n-        return getIcebergType(icebergID, name, Types.DoubleType.get(), isRequired);\n-      case STRING:\n-      case CHAR:\n-      case VARCHAR:\n-        return getIcebergType(icebergID, name, Types.StringType.get(), isRequired);\n-      case BINARY:\n-        String binaryAttributeValue = orcType.getAttributeValue(ICEBERG_BINARY_TYPE_ATTRIBUTE);\n-        BinaryType binaryType = binaryAttributeValue == null ? BinaryType.BINARY :\n-            BinaryType.valueOf(binaryAttributeValue);\n-        switch (binaryType) {\n-          case UUID:\n-            return getIcebergType(icebergID, name, Types.UUIDType.get(), isRequired);\n-          case FIXED:\n-            int fixedLength = Integer.parseInt(orcType.getAttributeValue(ICEBERG_FIELD_LENGTH));\n-            return getIcebergType(icebergID, name, Types.FixedType.ofLength(fixedLength), isRequired);\n-          case BINARY:\n-            return getIcebergType(icebergID, name, Types.BinaryType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Binary type found in ORC type attribute\");\n-        }\n-      case DATE:\n-        return getIcebergType(icebergID, name, Types.DateType.get(), isRequired);\n-      case TIMESTAMP:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withoutZone(), isRequired);\n-      case TIMESTAMP_INSTANT:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withZone(), isRequired);\n-      case DECIMAL:\n-        return getIcebergType(icebergID, name,\n-            Types.DecimalType.of(orcType.getPrecision(), orcType.getScale()),\n-            isRequired);\n-      case STRUCT: {\n-        List<String> fieldNames = orcType.getFieldNames();\n-        List<TypeDescription> fieldTypes = orcType.getChildren();\n-        List<Types.NestedField> fields = new ArrayList<>(fieldNames.size());\n-        for (int c = 0; c < fieldNames.size(); ++c) {\n-          String childName = fieldNames.get(c);\n-          TypeDescription type = fieldTypes.get(c);\n-          Types.NestedField field = convertOrcToIceberg(type, childName, nextID);\n-          fields.add(field);\n-        }\n+    OrcToIcebergVisitor(Map<Integer, OrcField> icebergToOrcMapping) {\n+      this.icebergToOrcMapping = icebergToOrcMapping;\n+    }\n \n-        return getIcebergType(icebergID, name, Types.StructType.of(fields), isRequired);\n+    @Override\n+    public Optional<Types.NestedField> record(Types.StructType iStruct, TypeDescription record, List<String> names,\n+                                              List<Optional<Types.NestedField>> fields) {\n+      boolean isRequired = isRequired(record);\n+      Optional<Integer> icebergIdOpt = icebergID(record);\n+      if (!icebergIdOpt.isPresent() || fields.size() == 0) {\n+        return Optional.empty();\n       }\n-      case LIST: {\n-        TypeDescription elementType = orcType.getChildren().get(0);\n-        Types.NestedField element = convertOrcToIceberg(elementType, \"element\", nextID);\n-\n-        Types.ListType listTypeWithElem = isRequired(elementType) ?\n-            Types.ListType.ofRequired(element.fieldId(), element.type()) :\n-            Types.ListType.ofOptional(element.fieldId(), element.type());\n-        return isRequired ?\n-            Types.NestedField.required(icebergID, name, listTypeWithElem) :\n-            Types.NestedField.optional(icebergID, name, listTypeWithElem);\n-      }\n-      case MAP: {\n-        TypeDescription keyType = orcType.getChildren().get(0);\n-        Types.NestedField key = convertOrcToIceberg(keyType, \"key\", nextID);\n-        TypeDescription valueType = orcType.getChildren().get(1);\n-        Types.NestedField value = convertOrcToIceberg(valueType, \"value\", nextID);\n \n-        Types.MapType mapTypeWithKV = isRequired(valueType) ?\n-            Types.MapType.ofRequired(key.fieldId(), value.fieldId(), key.type(), value.type()) :\n-            Types.MapType.ofOptional(key.fieldId(), value.fieldId(), key.type(), value.type());\n+      Types.StructType structType = Types.StructType.of(\n+          fields.stream().filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList()));\n+      return Optional.of(getIcebergType(icebergIdOpt.get(), icebergToOrcMapping.get(icebergIdOpt.get()).name(),\n+          structType, isRequired));\n+    }\n \n-        return getIcebergType(icebergID, name, mapTypeWithKV, isRequired);\n+    @Override\n+    public Optional<Types.NestedField> list(Types.ListType iList, TypeDescription array,\n+                                            Optional<Types.NestedField> element) {\n+      boolean isRequired = isRequired(array);\n+      Optional<Integer> icebergIdOpt = icebergID(array);\n+\n+      if (!icebergIdOpt.isPresent() || !element.isPresent()) {\n+        return Optional.empty();\n       }\n-      default:\n-        // We don't have an answer for union types.\n-        throw new IllegalArgumentException(\"Can't handle \" + orcType);\n+\n+      Types.NestedField foundElement = element.get();\n+      Types.ListType listTypeWithElem = isRequired(array.getChildren().get(0)) ?\n+          Types.ListType.ofRequired(foundElement.fieldId(), foundElement.type()) :\n+          Types.ListType.ofOptional(foundElement.fieldId(), foundElement.type());\n+      return Optional.of(getIcebergType(icebergIdOpt.get(),\n+          icebergToOrcMapping.get(icebergIdOpt.get()).name(), listTypeWithElem, isRequired));\n     }\n-  }\n \n-  private static int getMaxIcebergId(TypeDescription originalOrcSchema) {\n-    int maxId = icebergID(originalOrcSchema).orElse(0);\n-    final List<TypeDescription> children = Optional.ofNullable(originalOrcSchema.getChildren())\n-        .orElse(Collections.emptyList());\n-    for (TypeDescription child : children) {\n-      maxId = Math.max(maxId, getMaxIcebergId(child));\n+    @Override\n+    public Optional<Types.NestedField> map(Types.MapType iMap, TypeDescription map, Optional<Types.NestedField> key,\n+                                           Optional<Types.NestedField> value) {\n+      boolean isRequired = isRequired(map);\n+      Optional<Integer> icebergIdOpt = icebergID(map);\n+\n+      if (!icebergIdOpt.isPresent() || !key.isPresent() || !value.isPresent()) {\n+        return Optional.empty();\n+      }\n+\n+      Types.NestedField foundKey = key.get();\n+      Types.NestedField foundValue = value.get();\n+      Types.MapType mapTypeWithKV = isRequired(map.getChildren().get(1)) ?\n+          Types.MapType.ofRequired(foundKey.fieldId(), foundValue.fieldId(), foundKey.type(), foundValue.type()) :\n+          Types.MapType.ofOptional(foundKey.fieldId(), foundValue.fieldId(), foundKey.type(), foundValue.type());\n+\n+      return Optional.of(getIcebergType(icebergIdOpt.get(), icebergToOrcMapping.get(icebergIdOpt.get()).name(),\n+          mapTypeWithKV, isRequired));\n     }\n \n-    return maxId;\n+    @Override\n+    public Optional<Types.NestedField> primitive(Type.PrimitiveType iPrimitive, TypeDescription primitive) {", "originalCommit": "d66cb470ef45a25c2726bb1255fb3cf4bb981d2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzMjM4OQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r447132389", "bodyText": "Yeah, I think I can add a OrcSchemaVisitor for this case.", "author": "edgarRd", "createdAt": "2020-06-29T17:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0MDM0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "chunk": "diff --git a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\nindex ee1210b99..9a1521cc5 100644\n--- a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n+++ b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n\n@@ -398,7 +405,7 @@ public final class ORCSchemaUtil {\n         Types.NestedField.optional(icebergID, name, type);\n   }\n \n-  private static class OrcToIcebergVisitor extends OrcSchemaWithTypeVisitor<Optional<Types.NestedField>> {\n+  private static class OrcToIcebergVisitor extends OrcSchemaVisitor<Optional<Types.NestedField>> {\n \n     private final Map<Integer, OrcField> icebergToOrcMapping;\n \n"}}, {"oid": "170551c045aee18d167f4cef0c71563ab5a21235", "url": "https://github.com/apache/iceberg/commit/170551c045aee18d167f4cef0c71563ab5a21235", "message": "Update javadoc", "committedDate": "2020-06-29T16:47:01Z", "type": "commit"}, {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80", "url": "https://github.com/apache/iceberg/commit/693a7faf2f754dd7c268901e4ff2d392df365c80", "message": "Add OrcSchemaVisitor", "committedDate": "2020-06-29T17:49:19Z", "type": "commit"}, {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80", "url": "https://github.com/apache/iceberg/commit/693a7faf2f754dd7c268901e4ff2d392df365c80", "message": "Add OrcSchemaVisitor", "committedDate": "2020-06-29T17:49:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMTc3MQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448021771", "bodyText": "Looks like this map is only used to get the ORC field name. Could it be an idToName map instead?", "author": "rdblue", "createdAt": "2020-06-30T22:49:51Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -403,114 +405,150 @@ private static boolean isRequired(TypeDescription orcType) {\n         Types.NestedField.optional(icebergID, name, type);\n   }\n \n-  private static Types.NestedField convertOrcToIceberg(TypeDescription orcType, String name,\n-                                                       TypeUtil.NextID nextID) {\n+  private static class OrcToIcebergVisitor extends OrcSchemaVisitor<Optional<Types.NestedField>> {\n \n-    final int icebergID = icebergID(orcType).orElseGet(nextID::get);\n-    final boolean isRequired = isRequired(orcType);\n+    private final Map<Integer, OrcField> icebergToOrcMapping;\n \n-    switch (orcType.getCategory()) {\n-      case BOOLEAN:\n-        return getIcebergType(icebergID, name, Types.BooleanType.get(), isRequired);\n-      case BYTE:\n-      case SHORT:\n-      case INT:\n-        return getIcebergType(icebergID, name, Types.IntegerType.get(), isRequired);\n-      case LONG:\n-        String longAttributeValue = orcType.getAttributeValue(ICEBERG_LONG_TYPE_ATTRIBUTE);\n-        LongType longType = longAttributeValue == null ? LongType.LONG : LongType.valueOf(longAttributeValue);\n-        switch (longType) {\n-          case TIME:\n-            return getIcebergType(icebergID, name, Types.TimeType.get(), isRequired);\n-          case LONG:\n-            return getIcebergType(icebergID, name, Types.LongType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Long type found in ORC type attribute\");\n-        }\n-      case FLOAT:\n-        return getIcebergType(icebergID, name, Types.FloatType.get(), isRequired);\n-      case DOUBLE:\n-        return getIcebergType(icebergID, name, Types.DoubleType.get(), isRequired);\n-      case STRING:\n-      case CHAR:\n-      case VARCHAR:\n-        return getIcebergType(icebergID, name, Types.StringType.get(), isRequired);\n-      case BINARY:\n-        String binaryAttributeValue = orcType.getAttributeValue(ICEBERG_BINARY_TYPE_ATTRIBUTE);\n-        BinaryType binaryType = binaryAttributeValue == null ? BinaryType.BINARY :\n-            BinaryType.valueOf(binaryAttributeValue);\n-        switch (binaryType) {\n-          case UUID:\n-            return getIcebergType(icebergID, name, Types.UUIDType.get(), isRequired);\n-          case FIXED:\n-            int fixedLength = Integer.parseInt(orcType.getAttributeValue(ICEBERG_FIELD_LENGTH));\n-            return getIcebergType(icebergID, name, Types.FixedType.ofLength(fixedLength), isRequired);\n-          case BINARY:\n-            return getIcebergType(icebergID, name, Types.BinaryType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Binary type found in ORC type attribute\");\n-        }\n-      case DATE:\n-        return getIcebergType(icebergID, name, Types.DateType.get(), isRequired);\n-      case TIMESTAMP:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withoutZone(), isRequired);\n-      case TIMESTAMP_INSTANT:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withZone(), isRequired);\n-      case DECIMAL:\n-        return getIcebergType(icebergID, name,\n-            Types.DecimalType.of(orcType.getPrecision(), orcType.getScale()),\n-            isRequired);\n-      case STRUCT: {\n-        List<String> fieldNames = orcType.getFieldNames();\n-        List<TypeDescription> fieldTypes = orcType.getChildren();\n-        List<Types.NestedField> fields = new ArrayList<>(fieldNames.size());\n-        for (int c = 0; c < fieldNames.size(); ++c) {\n-          String childName = fieldNames.get(c);\n-          TypeDescription type = fieldTypes.get(c);\n-          Types.NestedField field = convertOrcToIceberg(type, childName, nextID);\n-          fields.add(field);\n-        }\n+    OrcToIcebergVisitor(Map<Integer, OrcField> icebergToOrcMapping) {", "originalCommit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNjA5MQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448026091", "bodyText": "Also, if field names are passed into the record visitor method, why is this needed? The visitor could use a before/after field callback to track names:\nprivate LinkedList<String> fieldNames;\n\npublic beforeField(String name, TypeDescription type) {\n   fieldNames.push(name);\n}\n\npublic afterField(String name, TypeDescription type) {\n  fieldNames.pop();\n}\n\nprivate Strign currentFieldName() {\n  return fieldNames.peek();\n}", "author": "rdblue", "createdAt": "2020-06-30T23:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMTc3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "97c0fa447a8bd69eacd1e7883299973f07aa5351", "chunk": "diff --git a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\nindex 9a1521cc5..3714489fb 100644\n--- a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n+++ b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n\n@@ -390,19 +390,12 @@ public final class ORCSchemaUtil {\n     return Integer.parseInt(idStr);\n   }\n \n-  private static boolean isRequired(TypeDescription orcType) {\n+  private static boolean isOptional(TypeDescription orcType) {\n     String isRequiredStr = orcType.getAttributeValue(ICEBERG_REQUIRED_ATTRIBUTE);\n     if (isRequiredStr != null) {\n-      return Boolean.parseBoolean(isRequiredStr);\n+      return !Boolean.parseBoolean(isRequiredStr);\n     }\n-    return false;\n-  }\n-\n-  private static Types.NestedField getIcebergType(int icebergID, String name, Type type,\n-                                                  boolean isRequired) {\n-    return isRequired ?\n-        Types.NestedField.required(icebergID, name, type) :\n-        Types.NestedField.optional(icebergID, name, type);\n+    return true;\n   }\n \n   private static class OrcToIcebergVisitor extends OrcSchemaVisitor<Optional<Types.NestedField>> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMjQ5MQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448022491", "bodyText": "I don't think it is necessary to call getIcebergType (which returns a NestedField?).\nIceberg added Types.NestedField.of() that accepts a boolean isOptional so you don't have to call just required or optional. That could be used in place of getIcebergType.", "author": "rdblue", "createdAt": "2020-06-30T22:51:51Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -403,114 +405,150 @@ private static boolean isRequired(TypeDescription orcType) {\n         Types.NestedField.optional(icebergID, name, type);\n   }\n \n-  private static Types.NestedField convertOrcToIceberg(TypeDescription orcType, String name,\n-                                                       TypeUtil.NextID nextID) {\n+  private static class OrcToIcebergVisitor extends OrcSchemaVisitor<Optional<Types.NestedField>> {\n \n-    final int icebergID = icebergID(orcType).orElseGet(nextID::get);\n-    final boolean isRequired = isRequired(orcType);\n+    private final Map<Integer, OrcField> icebergToOrcMapping;\n \n-    switch (orcType.getCategory()) {\n-      case BOOLEAN:\n-        return getIcebergType(icebergID, name, Types.BooleanType.get(), isRequired);\n-      case BYTE:\n-      case SHORT:\n-      case INT:\n-        return getIcebergType(icebergID, name, Types.IntegerType.get(), isRequired);\n-      case LONG:\n-        String longAttributeValue = orcType.getAttributeValue(ICEBERG_LONG_TYPE_ATTRIBUTE);\n-        LongType longType = longAttributeValue == null ? LongType.LONG : LongType.valueOf(longAttributeValue);\n-        switch (longType) {\n-          case TIME:\n-            return getIcebergType(icebergID, name, Types.TimeType.get(), isRequired);\n-          case LONG:\n-            return getIcebergType(icebergID, name, Types.LongType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Long type found in ORC type attribute\");\n-        }\n-      case FLOAT:\n-        return getIcebergType(icebergID, name, Types.FloatType.get(), isRequired);\n-      case DOUBLE:\n-        return getIcebergType(icebergID, name, Types.DoubleType.get(), isRequired);\n-      case STRING:\n-      case CHAR:\n-      case VARCHAR:\n-        return getIcebergType(icebergID, name, Types.StringType.get(), isRequired);\n-      case BINARY:\n-        String binaryAttributeValue = orcType.getAttributeValue(ICEBERG_BINARY_TYPE_ATTRIBUTE);\n-        BinaryType binaryType = binaryAttributeValue == null ? BinaryType.BINARY :\n-            BinaryType.valueOf(binaryAttributeValue);\n-        switch (binaryType) {\n-          case UUID:\n-            return getIcebergType(icebergID, name, Types.UUIDType.get(), isRequired);\n-          case FIXED:\n-            int fixedLength = Integer.parseInt(orcType.getAttributeValue(ICEBERG_FIELD_LENGTH));\n-            return getIcebergType(icebergID, name, Types.FixedType.ofLength(fixedLength), isRequired);\n-          case BINARY:\n-            return getIcebergType(icebergID, name, Types.BinaryType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Binary type found in ORC type attribute\");\n-        }\n-      case DATE:\n-        return getIcebergType(icebergID, name, Types.DateType.get(), isRequired);\n-      case TIMESTAMP:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withoutZone(), isRequired);\n-      case TIMESTAMP_INSTANT:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withZone(), isRequired);\n-      case DECIMAL:\n-        return getIcebergType(icebergID, name,\n-            Types.DecimalType.of(orcType.getPrecision(), orcType.getScale()),\n-            isRequired);\n-      case STRUCT: {\n-        List<String> fieldNames = orcType.getFieldNames();\n-        List<TypeDescription> fieldTypes = orcType.getChildren();\n-        List<Types.NestedField> fields = new ArrayList<>(fieldNames.size());\n-        for (int c = 0; c < fieldNames.size(); ++c) {\n-          String childName = fieldNames.get(c);\n-          TypeDescription type = fieldTypes.get(c);\n-          Types.NestedField field = convertOrcToIceberg(type, childName, nextID);\n-          fields.add(field);\n-        }\n+    OrcToIcebergVisitor(Map<Integer, OrcField> icebergToOrcMapping) {\n+      this.icebergToOrcMapping = icebergToOrcMapping;\n+    }\n \n-        return getIcebergType(icebergID, name, Types.StructType.of(fields), isRequired);\n-      }\n-      case LIST: {\n-        TypeDescription elementType = orcType.getChildren().get(0);\n-        Types.NestedField element = convertOrcToIceberg(elementType, \"element\", nextID);\n-\n-        Types.ListType listTypeWithElem = isRequired(elementType) ?\n-            Types.ListType.ofRequired(element.fieldId(), element.type()) :\n-            Types.ListType.ofOptional(element.fieldId(), element.type());\n-        return isRequired ?\n-            Types.NestedField.required(icebergID, name, listTypeWithElem) :\n-            Types.NestedField.optional(icebergID, name, listTypeWithElem);\n+    @Override\n+    public Optional<Types.NestedField> record(TypeDescription record, List<String> names,\n+                                              List<Optional<Types.NestedField>> fields) {\n+      boolean isRequired = isRequired(record);\n+      Optional<Integer> icebergIdOpt = icebergID(record);\n+      if (!icebergIdOpt.isPresent() || fields.size() == 0) {\n+        return Optional.empty();\n       }\n-      case MAP: {\n-        TypeDescription keyType = orcType.getChildren().get(0);\n-        Types.NestedField key = convertOrcToIceberg(keyType, \"key\", nextID);\n-        TypeDescription valueType = orcType.getChildren().get(1);\n-        Types.NestedField value = convertOrcToIceberg(valueType, \"value\", nextID);\n \n-        Types.MapType mapTypeWithKV = isRequired(valueType) ?\n-            Types.MapType.ofRequired(key.fieldId(), value.fieldId(), key.type(), value.type()) :\n-            Types.MapType.ofOptional(key.fieldId(), value.fieldId(), key.type(), value.type());\n+      Types.StructType structType = Types.StructType.of(\n+          fields.stream().filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList()));\n+      return Optional.of(getIcebergType(icebergIdOpt.get(), icebergToOrcMapping.get(icebergIdOpt.get()).name(),\n+          structType, isRequired));\n+    }\n+\n+    @Override\n+    public Optional<Types.NestedField> list(TypeDescription array,\n+                                            Optional<Types.NestedField> element) {\n+      boolean isRequired = isRequired(array);\n+      Optional<Integer> icebergIdOpt = icebergID(array);\n \n-        return getIcebergType(icebergID, name, mapTypeWithKV, isRequired);\n+      if (!icebergIdOpt.isPresent() || !element.isPresent()) {\n+        return Optional.empty();\n       }\n-      default:\n-        // We don't have an answer for union types.\n-        throw new IllegalArgumentException(\"Can't handle \" + orcType);\n+\n+      Types.NestedField foundElement = element.get();\n+      Types.ListType listTypeWithElem = isRequired(array.getChildren().get(0)) ?\n+          Types.ListType.ofRequired(foundElement.fieldId(), foundElement.type()) :\n+          Types.ListType.ofOptional(foundElement.fieldId(), foundElement.type());\n+      return Optional.of(getIcebergType(icebergIdOpt.get(),", "originalCommit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97c0fa447a8bd69eacd1e7883299973f07aa5351", "chunk": "diff --git a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\nindex 9a1521cc5..3714489fb 100644\n--- a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n+++ b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n\n@@ -390,19 +390,12 @@ public final class ORCSchemaUtil {\n     return Integer.parseInt(idStr);\n   }\n \n-  private static boolean isRequired(TypeDescription orcType) {\n+  private static boolean isOptional(TypeDescription orcType) {\n     String isRequiredStr = orcType.getAttributeValue(ICEBERG_REQUIRED_ATTRIBUTE);\n     if (isRequiredStr != null) {\n-      return Boolean.parseBoolean(isRequiredStr);\n+      return !Boolean.parseBoolean(isRequiredStr);\n     }\n-    return false;\n-  }\n-\n-  private static Types.NestedField getIcebergType(int icebergID, String name, Type type,\n-                                                  boolean isRequired) {\n-    return isRequired ?\n-        Types.NestedField.required(icebergID, name, type) :\n-        Types.NestedField.optional(icebergID, name, type);\n+    return true;\n   }\n \n   private static class OrcToIcebergVisitor extends OrcSchemaVisitor<Optional<Types.NestedField>> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDE1Ng==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448024156", "bodyText": "Should this also check that any of the fields are defined?\nif (!icebergIdOpt.isPresent() || !fields.stream().anyMatch(Optional::isPresent)) {\n  return Optional.empty();\n}", "author": "rdblue", "createdAt": "2020-06-30T22:56:38Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -403,114 +405,150 @@ private static boolean isRequired(TypeDescription orcType) {\n         Types.NestedField.optional(icebergID, name, type);\n   }\n \n-  private static Types.NestedField convertOrcToIceberg(TypeDescription orcType, String name,\n-                                                       TypeUtil.NextID nextID) {\n+  private static class OrcToIcebergVisitor extends OrcSchemaVisitor<Optional<Types.NestedField>> {\n \n-    final int icebergID = icebergID(orcType).orElseGet(nextID::get);\n-    final boolean isRequired = isRequired(orcType);\n+    private final Map<Integer, OrcField> icebergToOrcMapping;\n \n-    switch (orcType.getCategory()) {\n-      case BOOLEAN:\n-        return getIcebergType(icebergID, name, Types.BooleanType.get(), isRequired);\n-      case BYTE:\n-      case SHORT:\n-      case INT:\n-        return getIcebergType(icebergID, name, Types.IntegerType.get(), isRequired);\n-      case LONG:\n-        String longAttributeValue = orcType.getAttributeValue(ICEBERG_LONG_TYPE_ATTRIBUTE);\n-        LongType longType = longAttributeValue == null ? LongType.LONG : LongType.valueOf(longAttributeValue);\n-        switch (longType) {\n-          case TIME:\n-            return getIcebergType(icebergID, name, Types.TimeType.get(), isRequired);\n-          case LONG:\n-            return getIcebergType(icebergID, name, Types.LongType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Long type found in ORC type attribute\");\n-        }\n-      case FLOAT:\n-        return getIcebergType(icebergID, name, Types.FloatType.get(), isRequired);\n-      case DOUBLE:\n-        return getIcebergType(icebergID, name, Types.DoubleType.get(), isRequired);\n-      case STRING:\n-      case CHAR:\n-      case VARCHAR:\n-        return getIcebergType(icebergID, name, Types.StringType.get(), isRequired);\n-      case BINARY:\n-        String binaryAttributeValue = orcType.getAttributeValue(ICEBERG_BINARY_TYPE_ATTRIBUTE);\n-        BinaryType binaryType = binaryAttributeValue == null ? BinaryType.BINARY :\n-            BinaryType.valueOf(binaryAttributeValue);\n-        switch (binaryType) {\n-          case UUID:\n-            return getIcebergType(icebergID, name, Types.UUIDType.get(), isRequired);\n-          case FIXED:\n-            int fixedLength = Integer.parseInt(orcType.getAttributeValue(ICEBERG_FIELD_LENGTH));\n-            return getIcebergType(icebergID, name, Types.FixedType.ofLength(fixedLength), isRequired);\n-          case BINARY:\n-            return getIcebergType(icebergID, name, Types.BinaryType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Binary type found in ORC type attribute\");\n-        }\n-      case DATE:\n-        return getIcebergType(icebergID, name, Types.DateType.get(), isRequired);\n-      case TIMESTAMP:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withoutZone(), isRequired);\n-      case TIMESTAMP_INSTANT:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withZone(), isRequired);\n-      case DECIMAL:\n-        return getIcebergType(icebergID, name,\n-            Types.DecimalType.of(orcType.getPrecision(), orcType.getScale()),\n-            isRequired);\n-      case STRUCT: {\n-        List<String> fieldNames = orcType.getFieldNames();\n-        List<TypeDescription> fieldTypes = orcType.getChildren();\n-        List<Types.NestedField> fields = new ArrayList<>(fieldNames.size());\n-        for (int c = 0; c < fieldNames.size(); ++c) {\n-          String childName = fieldNames.get(c);\n-          TypeDescription type = fieldTypes.get(c);\n-          Types.NestedField field = convertOrcToIceberg(type, childName, nextID);\n-          fields.add(field);\n-        }\n+    OrcToIcebergVisitor(Map<Integer, OrcField> icebergToOrcMapping) {\n+      this.icebergToOrcMapping = icebergToOrcMapping;\n+    }\n \n-        return getIcebergType(icebergID, name, Types.StructType.of(fields), isRequired);\n-      }\n-      case LIST: {\n-        TypeDescription elementType = orcType.getChildren().get(0);\n-        Types.NestedField element = convertOrcToIceberg(elementType, \"element\", nextID);\n-\n-        Types.ListType listTypeWithElem = isRequired(elementType) ?\n-            Types.ListType.ofRequired(element.fieldId(), element.type()) :\n-            Types.ListType.ofOptional(element.fieldId(), element.type());\n-        return isRequired ?\n-            Types.NestedField.required(icebergID, name, listTypeWithElem) :\n-            Types.NestedField.optional(icebergID, name, listTypeWithElem);\n+    @Override\n+    public Optional<Types.NestedField> record(TypeDescription record, List<String> names,\n+                                              List<Optional<Types.NestedField>> fields) {\n+      boolean isRequired = isRequired(record);\n+      Optional<Integer> icebergIdOpt = icebergID(record);\n+      if (!icebergIdOpt.isPresent() || fields.size() == 0) {", "originalCommit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97c0fa447a8bd69eacd1e7883299973f07aa5351", "chunk": "diff --git a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\nindex 9a1521cc5..3714489fb 100644\n--- a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n+++ b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n\n@@ -390,19 +390,12 @@ public final class ORCSchemaUtil {\n     return Integer.parseInt(idStr);\n   }\n \n-  private static boolean isRequired(TypeDescription orcType) {\n+  private static boolean isOptional(TypeDescription orcType) {\n     String isRequiredStr = orcType.getAttributeValue(ICEBERG_REQUIRED_ATTRIBUTE);\n     if (isRequiredStr != null) {\n-      return Boolean.parseBoolean(isRequiredStr);\n+      return !Boolean.parseBoolean(isRequiredStr);\n     }\n-    return false;\n-  }\n-\n-  private static Types.NestedField getIcebergType(int icebergID, String name, Type type,\n-                                                  boolean isRequired) {\n-    return isRequired ?\n-        Types.NestedField.required(icebergID, name, type) :\n-        Types.NestedField.optional(icebergID, name, type);\n+    return true;\n   }\n \n   private static class OrcToIcebergVisitor extends OrcSchemaVisitor<Optional<Types.NestedField>> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDI3NQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448024275", "bodyText": "Instead of looping over children here, why not just call the visitor on the root orcSchema? Then you could check whether the record was present. If not, throw the exception.", "author": "rdblue", "createdAt": "2020-06-30T22:57:01Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -214,10 +213,13 @@ public static Schema convert(TypeDescription orcSchema) {\n         \"Error in ORC file, children fields and names do not match.\");\n \n     List<Types.NestedField> icebergFields = Lists.newArrayListWithExpectedSize(children.size());\n-    AtomicInteger lastColumnId = new AtomicInteger(getMaxIcebergId(orcSchema));\n-    for (int i = 0; i < children.size(); i++) {\n-      icebergFields.add(convertOrcToIceberg(children.get(i), childrenNames.get(i),\n-          lastColumnId::incrementAndGet));\n+    OrcToIcebergVisitor schemaConverter = new OrcToIcebergVisitor(icebergToOrcMapping(\"root\", orcSchema));\n+    for (TypeDescription child : orcSchema.getChildren()) {\n+      OrcToIcebergVisitor.visit(child, schemaConverter).ifPresent(icebergFields::add);", "originalCommit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4NTYyNg==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448685626", "bodyText": "The root struct of ORC does not have an Iceberg ID, hence this looping. I've moved this to a visitSchema method in the visitor that reuses the code of visitRecord.", "author": "edgarRd", "createdAt": "2020-07-02T00:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDI3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "79ca745da71444298bd2121affac7e01fecebef9", "chunk": "diff --git a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\nindex 9a1521cc5..12f654671 100644\n--- a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n+++ b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n\n@@ -219,7 +219,7 @@ public final class ORCSchemaUtil {\n     }\n \n     if (icebergFields.size() == 0) {\n-      throw new IllegalArgumentException(\"ORC schema has no Iceberg mappings\");\n+      throw new IllegalArgumentException(\"ORC schema does not contain Iceberg IDs\");\n     }\n \n     return new Schema(icebergFields);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDQ2MA==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448024460", "bodyText": "I wouldn't refer to the ID annotations as mappings. How about \"ORC schema does not contain Iceberg IDs\"?", "author": "rdblue", "createdAt": "2020-06-30T22:57:35Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -214,10 +213,13 @@ public static Schema convert(TypeDescription orcSchema) {\n         \"Error in ORC file, children fields and names do not match.\");\n \n     List<Types.NestedField> icebergFields = Lists.newArrayListWithExpectedSize(children.size());\n-    AtomicInteger lastColumnId = new AtomicInteger(getMaxIcebergId(orcSchema));\n-    for (int i = 0; i < children.size(); i++) {\n-      icebergFields.add(convertOrcToIceberg(children.get(i), childrenNames.get(i),\n-          lastColumnId::incrementAndGet));\n+    OrcToIcebergVisitor schemaConverter = new OrcToIcebergVisitor(icebergToOrcMapping(\"root\", orcSchema));\n+    for (TypeDescription child : orcSchema.getChildren()) {\n+      OrcToIcebergVisitor.visit(child, schemaConverter).ifPresent(icebergFields::add);\n+    }\n+\n+    if (icebergFields.size() == 0) {\n+      throw new IllegalArgumentException(\"ORC schema has no Iceberg mappings\");", "originalCommit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79ca745da71444298bd2121affac7e01fecebef9", "chunk": "diff --git a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\nindex 9a1521cc5..12f654671 100644\n--- a/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n+++ b/orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java\n\n@@ -219,7 +219,7 @@ public final class ORCSchemaUtil {\n     }\n \n     if (icebergFields.size() == 0) {\n-      throw new IllegalArgumentException(\"ORC schema has no Iceberg mappings\");\n+      throw new IllegalArgumentException(\"ORC schema does not contain Iceberg IDs\");\n     }\n \n     return new Schema(icebergFields);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDgwNA==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448024804", "bodyText": "Nit: does this need to be on a separate line?", "author": "rdblue", "createdAt": "2020-06-30T22:58:40Z", "path": "orc/src/main/java/org/apache/iceberg/orc/OrcSchemaVisitor.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.orc.TypeDescription;\n+\n+/**\n+ * Generic visitor of an ORC Schema.\n+ */\n+public abstract class OrcSchemaVisitor<T> {\n+\n+  public static <T> T visit(TypeDescription schema, OrcSchemaVisitor<T> visitor) {\n+    switch (schema.getCategory()) {\n+      case STRUCT:\n+        return visitRecord(schema, visitor);\n+\n+      case UNION:\n+        throw new UnsupportedOperationException(\"Cannot handle \" + schema);\n+\n+      case LIST:\n+        return visitor.list(\n+            schema, visit(schema.getChildren().get(0), visitor));", "originalCommit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79ca745da71444298bd2121affac7e01fecebef9", "chunk": "diff --git a/orc/src/main/java/org/apache/iceberg/orc/OrcSchemaVisitor.java b/orc/src/main/java/org/apache/iceberg/orc/OrcSchemaVisitor.java\nindex 25f83ffd5..d39b2982d 100644\n--- a/orc/src/main/java/org/apache/iceberg/orc/OrcSchemaVisitor.java\n+++ b/orc/src/main/java/org/apache/iceberg/orc/OrcSchemaVisitor.java\n\n@@ -37,12 +37,10 @@ public abstract class OrcSchemaVisitor<T> {\n         throw new UnsupportedOperationException(\"Cannot handle \" + schema);\n \n       case LIST:\n-        return visitor.list(\n-            schema, visit(schema.getChildren().get(0), visitor));\n+        return visitor.list(schema, visit(schema.getChildren().get(0), visitor));\n \n       case MAP:\n-        return visitor.map(\n-            schema,\n+        return visitor.map(schema,\n             visit(schema.getChildren().get(0), visitor),\n             visit(schema.getChildren().get(1), visitor));\n \n"}}, {"oid": "97c0fa447a8bd69eacd1e7883299973f07aa5351", "url": "https://github.com/apache/iceberg/commit/97c0fa447a8bd69eacd1e7883299973f07aa5351", "message": "Use Types.NestedField.of", "committedDate": "2020-07-01T00:39:27Z", "type": "commit"}, {"oid": "79ca745da71444298bd2121affac7e01fecebef9", "url": "https://github.com/apache/iceberg/commit/79ca745da71444298bd2121affac7e01fecebef9", "message": "PR review", "committedDate": "2020-07-01T01:13:08Z", "type": "commit"}, {"oid": "cf39a31bcde820e21db1734ae8a80521a2ece37f", "url": "https://github.com/apache/iceberg/commit/cf39a31bcde820e21db1734ae8a80521a2ece37f", "message": "Create method to visit ORC schema in OrcSchemaVisitor", "committedDate": "2020-07-01T02:00:30Z", "type": "commit"}, {"oid": "9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "url": "https://github.com/apache/iceberg/commit/9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "message": "Track field names in OrcSchemaVisitor", "committedDate": "2020-07-02T00:42:56Z", "type": "commit"}, {"oid": "9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "url": "https://github.com/apache/iceberg/commit/9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "message": "Track field names in OrcSchemaVisitor", "committedDate": "2020-07-02T00:42:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5Mjg1MQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448692851", "bodyText": "I think this should create an Iceberg schema and assert the two are equal (structs implement equals, so you have to check assertEquals(expected.asStruct(), converted.asStruct()).", "author": "rdblue", "createdAt": "2020-07-02T01:05:59Z", "path": "orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java", "diffHunk": "@@ -209,4 +210,39 @@ public void testInvalidTypePromotions() {\n           ORCSchemaUtil.buildOrcProjection(evolveSchema, orcSchema);\n         });\n   }\n+\n+  @Test\n+  public void testSkipNonIcebergColumns() {\n+    TypeDescription schema = TypeDescription.createStruct();\n+    TypeDescription intCol = TypeDescription.createInt();\n+    intCol.setAttribute(ICEBERG_ID_ATTRIBUTE, \"1\");\n+    TypeDescription listCol = TypeDescription\n+        .createList(TypeDescription.createMap(TypeDescription.createString(), TypeDescription.createDate()));\n+    listCol.setAttribute(ICEBERG_ID_ATTRIBUTE, \"2\");\n+    schema.addField(\"intCol\", intCol);\n+    schema.addField(\"listCol\", listCol);\n+    TypeDescription stringKey = TypeDescription.createString();\n+    stringKey.setAttribute(ICEBERG_ID_ATTRIBUTE, \"3\");\n+    TypeDescription booleanVal = TypeDescription.createBoolean();\n+    booleanVal.setAttribute(ICEBERG_ID_ATTRIBUTE, \"4\");\n+    TypeDescription mapCol = TypeDescription.createMap(stringKey, booleanVal);\n+    mapCol.setAttribute(ICEBERG_ID_ATTRIBUTE, \"5\");\n+    schema.addField(\"mapCol\", mapCol);\n+\n+    Schema icebergSchema = ORCSchemaUtil.convert(schema);\n+    assertEquals(2, icebergSchema.asStruct().fields().size());", "originalCommit": "9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MjI4OQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r449172289", "bodyText": "Done. I've changed the test to compare structs.", "author": "edgarRd", "createdAt": "2020-07-02T17:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5Mjg1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "eef07c6bc787ad6b9e8f20af4835f887063115f6", "chunk": "diff --git a/orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java b/orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java\nindex 11cc94405..269919cf8 100644\n--- a/orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java\n+++ b/orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java\n\n@@ -216,6 +217,7 @@ public class TestORCSchemaUtil {\n     TypeDescription schema = TypeDescription.createStruct();\n     TypeDescription intCol = TypeDescription.createInt();\n     intCol.setAttribute(ICEBERG_ID_ATTRIBUTE, \"1\");\n+    intCol.setAttribute(ICEBERG_REQUIRED_ATTRIBUTE, \"true\");\n     TypeDescription listCol = TypeDescription\n         .createList(TypeDescription.createMap(TypeDescription.createString(), TypeDescription.createDate()));\n     listCol.setAttribute(ICEBERG_ID_ATTRIBUTE, \"2\");\n"}}, {"oid": "eef07c6bc787ad6b9e8f20af4835f887063115f6", "url": "https://github.com/apache/iceberg/commit/eef07c6bc787ad6b9e8f20af4835f887063115f6", "message": "Compare schemas in test case", "committedDate": "2020-07-02T17:42:59Z", "type": "commit"}, {"oid": "ce01fe593b820bd045598391368cc9d8a4787bf2", "url": "https://github.com/apache/iceberg/commit/ce01fe593b820bd045598391368cc9d8a4787bf2", "message": "Move OrcToIcebergVisitor to separate file", "committedDate": "2020-07-02T17:43:34Z", "type": "commit"}, {"oid": "ce01fe593b820bd045598391368cc9d8a4787bf2", "url": "https://github.com/apache/iceberg/commit/ce01fe593b820bd045598391368cc9d8a4787bf2", "message": "Move OrcToIcebergVisitor to separate file", "committedDate": "2020-07-02T17:43:34Z", "type": "forcePushed"}]}