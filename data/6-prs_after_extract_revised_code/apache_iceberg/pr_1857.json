{"pr_number": 1857, "pr_title": "rewrite equals filters", "pr_createdAt": "2020-12-02T00:36:28Z", "pr_url": "https://github.com/apache/iceberg/pull/1857", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3NTQxNw==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r536375417", "bodyText": "why is this not directly inside Expressions.equal, so we can avoid duplication between spark 2 and 3?", "author": "jackye1995", "createdAt": "2020-12-04T20:57:51Z", "path": "spark2/src/main/java/org/apache/iceberg/spark/SparkFilters.java", "diffHunk": "@@ -113,13 +115,13 @@ public static Expression convert(Filter filter) {\n             // comparison with null in normal equality is always null. this is probably a mistake.\n             Preconditions.checkNotNull(eq.value(),\n                 \"Expression is always false (eq is not null-safe): %s\", filter);\n-            return equal(eq.attribute(), convertLiteral(eq.value()));\n+            return handleEqual(eq.attribute(), eq.value());\n           } else {\n             EqualNullSafe eq = (EqualNullSafe) filter;\n             if (eq.value() == null) {\n               return isNull(eq.attribute());\n             } else {\n-              return equal(eq.attribute(), convertLiteral(eq.value()));\n+              return handleEqual(eq.attribute(), eq.value());", "originalCommit": "445ee6db3bec3086a4bccf99de18b8bc79f246b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQyOTIyMw==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r536429223", "bodyText": "I thought to reject NaN in any predicate and let SparkFilters to do rewrites was the conclusion we reached in this thread?", "author": "yyanyy", "createdAt": "2020-12-04T22:48:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3NTQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyNzY2Ng==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r536927666", "bodyText": "Yes, I agree. Rewriting filters should be done in translation to Iceberg so that we have simpler behavior and strong assumptions.", "author": "rdblue", "createdAt": "2020-12-06T01:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3NTQxNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3NzQ0NQ==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r536377445", "bodyText": "I think we should also try to test it for spark2, maybe update some tests in TestReadProjection?", "author": "jackye1995", "createdAt": "2020-12-04T21:01:55Z", "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java", "diffHunk": "@@ -49,8 +49,8 @@ public TestSelect(String catalogName, String implementation, Map<String, String>\n ", "originalCommit": "445ee6db3bec3086a4bccf99de18b8bc79f246b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMDI2Ng==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r536430266", "bodyText": "Yeah I actually also spent some time on this but wasn't able to find a good place to add in spark2, and later gave up thinking that the added logic was relatively simple anyway. To me TestReadProjection is more about testing projection which is not what we are doing. I guess I'll create a TestSelect in spark3 test suite and duplicate this class then.", "author": "yyanyy", "createdAt": "2020-12-04T22:51:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3NzQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk4NjM0Nw==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r537986347", "bodyText": "Added a TestSelect in spark2 by basically duplicating logic from the same class in spark3; although apart from basic sanity testing I'm not sure how helpful the tests are as some of the logic for examine pushed-down filters only exist in spark3...", "author": "yyanyy", "createdAt": "2020-12-08T02:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3NzQ0NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyNzc1NA==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r536927754", "bodyText": "This should be moved into the else block because literal should not allow creating a NaN literal.", "author": "rdblue", "createdAt": "2020-12-06T01:18:07Z", "path": "spark2/src/main/java/org/apache/iceberg/spark/SparkFilters.java", "diffHunk": "@@ -177,4 +179,13 @@ private static Object convertLiteral(Object value) {\n     }\n     return value;\n   }\n+\n+  private static Expression handleEqual(String attribute, Object value) {\n+    Object literal = convertLiteral(value);", "originalCommit": "445ee6db3bec3086a4bccf99de18b8bc79f246b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "730ce5b791ea775b04870189940e18014211fb59", "chunk": "diff --git a/spark2/src/main/java/org/apache/iceberg/spark/SparkFilters.java b/spark2/src/main/java/org/apache/iceberg/spark/SparkFilters.java\nindex 23589a50c..0703688b9 100644\n--- a/spark2/src/main/java/org/apache/iceberg/spark/SparkFilters.java\n+++ b/spark2/src/main/java/org/apache/iceberg/spark/SparkFilters.java\n\n@@ -181,11 +181,10 @@ public class SparkFilters {\n   }\n \n   private static Expression handleEqual(String attribute, Object value) {\n-    Object literal = convertLiteral(value);\n-    if (NaNUtil.isNaN(literal)) {\n+    if (NaNUtil.isNaN(value)) {\n       return isNaN(attribute);\n     } else {\n-      return equal(attribute, literal);\n+      return equal(attribute, convertLiteral(value));\n     }\n   }\n }\n"}}, {"oid": "730ce5b791ea775b04870189940e18014211fb59", "url": "https://github.com/apache/iceberg/commit/730ce5b791ea775b04870189940e18014211fb59", "message": "add spark2 test", "committedDate": "2020-12-08T02:29:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5OTQxMA==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r538899410", "bodyText": "Shouldn't this be is_nan(float) instead of = NaN?", "author": "rdblue", "createdAt": "2020-12-08T23:56:31Z", "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java", "diffHunk": "@@ -63,11 +63,25 @@ public void removeTables() {\n \n   @Test\n   public void testSelect() {\n-    List<Object[]> expected = ImmutableList.of(row(1L, \"a\"), row(2L, \"b\"), row(3L, \"c\"));\n+    List<Object[]> expected = ImmutableList.of(\n+        row(1L, \"a\", 1.0F), row(2L, \"b\", 2.0F), row(3L, \"c\", Float.NaN));\n \n     assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT * FROM %s\", tableName));\n   }\n \n+  @Test\n+  public void testSelectRewrite() {\n+    List<Object[]> expected = ImmutableList.of(row(3L, \"c\", Float.NaN));\n+\n+    assertEquals(\"Should return all expected rows\", expected,\n+        sql(\"SELECT * FROM %s where float = float('NaN')\", tableName));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\",\n+        \"(float IS NOT NULL AND float = NaN)\",", "originalCommit": "730ce5b791ea775b04870189940e18014211fb59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5MDc5OA==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r539690798", "bodyText": "This is because in DescribeExpressionVisitor  we translate is_nan to = NaN in here. Do you want me to change this to is_nan(float)?", "author": "yyanyy", "createdAt": "2020-12-09T22:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5OTQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODk1OQ==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r539768959", "bodyText": "Yes, I think so. The description shouldn't produce a predicate that we don't support!", "author": "rdblue", "createdAt": "2020-12-10T01:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5OTQxMA=="}], "type": "inlineReview", "revised_code": {"commit": "031582f21a4d91d91a497181ad96f92967d8cbcf", "chunk": "diff --git a/spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java b/spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java\nindex 1dce537ce..846e234cb 100644\n--- a/spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java\n+++ b/spark3/src/test/java/org/apache/iceberg/spark/sql/TestSelect.java\n\n@@ -78,7 +78,7 @@ public class TestSelect extends SparkCatalogTestBase {\n \n     Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n     Assert.assertEquals(\"Should push down expected filter\",\n-        \"(float IS NOT NULL AND float = NaN)\",\n+        \"(float IS NOT NULL AND is_nan(float))\",\n         Spark3Util.describe(lastScanEvent.filter()));\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMDI1NQ==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r538900255", "bodyText": "Shouldn't this validate more than just the number of scans?", "author": "rdblue", "createdAt": "2020-12-08T23:58:39Z", "path": "spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.events.Listeners;\n+import org.apache.iceberg.events.ScanEvent;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.base.Objects;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public class TestSelect {\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"id\", Types.IntegerType.get()),\n+      optional(2, \"data\", Types.StringType.get()),\n+      optional(3, \"doubleVal\", Types.DoubleType.get())\n+  );\n+\n+  private static SparkSession spark;\n+\n+  private static int scanEventCount = 0;\n+  private static ScanEvent lastScanEvent = null;\n+\n+  private Table table;\n+\n+  static {\n+    Listeners.register(event -> {\n+      scanEventCount += 1;\n+      lastScanEvent = event;\n+    }, ScanEvent.class);\n+  }\n+\n+  @BeforeClass\n+  public static void startSpark() {\n+    spark = SparkSession.builder()\n+        .master(\"local[2]\")\n+        .getOrCreate();\n+  }\n+\n+  @AfterClass\n+  public static void stopSpark() {\n+    SparkSession currentSpark = spark;\n+    spark = null;\n+    currentSpark.stop();\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private String tableLocation = null;\n+\n+  @Before\n+  public void init() throws Exception {\n+    File tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+\n+    table = TABLES.create(SCHEMA, tableLocation);\n+\n+    List<Record> rows = Lists.newArrayList(\n+        new Record(1, \"a\", 1.0),\n+        new Record(2, \"b\", 2.0),\n+        new Record(3, \"c\", Double.NaN)\n+    );\n+\n+    Dataset<Row> df = spark.createDataFrame(rows, Record.class);\n+\n+    df.select(\"id\", \"data\", \"doubleVal\").write()\n+        .format(\"iceberg\")\n+        .mode(\"append\")\n+        .save(tableLocation);\n+\n+    table.refresh();\n+\n+    Dataset<Row> results = spark.read()\n+        .format(\"iceberg\")\n+        .load(tableLocation);\n+    results.createOrReplaceTempView(\"table\");\n+\n+    scanEventCount = 0;\n+    lastScanEvent = null;\n+  }\n+\n+  @Test\n+  public void testSelect() {\n+    List<Record> expected = ImmutableList.of(\n+        new Record(1, \"a\", 1.0), new Record(2, \"b\", 2.0), new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"select * from table\"));\n+  }\n+\n+  @Test\n+  public void testSelectRewrite() {\n+    List<Record> expected = ImmutableList.of(new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected,\n+        sql(\"SELECT * FROM table where doubleVal = double('NaN')\"));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);", "originalCommit": "730ce5b791ea775b04870189940e18014211fb59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5MDg1NA==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r539690854", "bodyText": "Yes, sorry I forgot to revisit this after cleaning up other changes. Since in spark2 we don't have Spark3Util.describe() I wasn't sure to which level we want to assert the expression, so that we can still have test coverage without being too coupled with internal implementation. Let me know how you think the updated test is!", "author": "yyanyy", "createdAt": "2020-12-09T22:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMDI1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4NzI3NQ==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r540587275", "bodyText": "Looks good!", "author": "rdblue", "createdAt": "2020-12-10T23:53:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMDI1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "cc8dc2b38895b251e8e5394535f986d3ec92025f", "chunk": "diff --git a/spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java b/spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java\ndeleted file mode 100644\nindex 3a099463f..000000000\n--- a/spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java\n+++ /dev/null\n\n@@ -1,230 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.iceberg.spark.source;\n-\n-import java.io.File;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-import org.apache.hadoop.conf.Configuration;\n-import org.apache.iceberg.Schema;\n-import org.apache.iceberg.Table;\n-import org.apache.iceberg.events.Listeners;\n-import org.apache.iceberg.events.ScanEvent;\n-import org.apache.iceberg.expressions.Expressions;\n-import org.apache.iceberg.hadoop.HadoopTables;\n-import org.apache.iceberg.relocated.com.google.common.base.Objects;\n-import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n-import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n-import org.apache.iceberg.types.Types;\n-import org.apache.spark.sql.Dataset;\n-import org.apache.spark.sql.Row;\n-import org.apache.spark.sql.SparkSession;\n-import org.junit.AfterClass;\n-import org.junit.Assert;\n-import org.junit.Before;\n-import org.junit.BeforeClass;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.TemporaryFolder;\n-\n-import static org.apache.iceberg.types.Types.NestedField.optional;\n-\n-public class TestSelect {\n-  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n-  private static final Schema SCHEMA = new Schema(\n-      optional(1, \"id\", Types.IntegerType.get()),\n-      optional(2, \"data\", Types.StringType.get()),\n-      optional(3, \"doubleVal\", Types.DoubleType.get())\n-  );\n-\n-  private static SparkSession spark;\n-\n-  private static int scanEventCount = 0;\n-  private static ScanEvent lastScanEvent = null;\n-\n-  private Table table;\n-\n-  static {\n-    Listeners.register(event -> {\n-      scanEventCount += 1;\n-      lastScanEvent = event;\n-    }, ScanEvent.class);\n-  }\n-\n-  @BeforeClass\n-  public static void startSpark() {\n-    spark = SparkSession.builder()\n-        .master(\"local[2]\")\n-        .getOrCreate();\n-  }\n-\n-  @AfterClass\n-  public static void stopSpark() {\n-    SparkSession currentSpark = spark;\n-    spark = null;\n-    currentSpark.stop();\n-  }\n-\n-  @Rule\n-  public TemporaryFolder temp = new TemporaryFolder();\n-\n-  private String tableLocation = null;\n-\n-  @Before\n-  public void init() throws Exception {\n-    File tableDir = temp.newFolder();\n-    this.tableLocation = tableDir.toURI().toString();\n-\n-    table = TABLES.create(SCHEMA, tableLocation);\n-\n-    List<Record> rows = Lists.newArrayList(\n-        new Record(1, \"a\", 1.0),\n-        new Record(2, \"b\", 2.0),\n-        new Record(3, \"c\", Double.NaN)\n-    );\n-\n-    Dataset<Row> df = spark.createDataFrame(rows, Record.class);\n-\n-    df.select(\"id\", \"data\", \"doubleVal\").write()\n-        .format(\"iceberg\")\n-        .mode(\"append\")\n-        .save(tableLocation);\n-\n-    table.refresh();\n-\n-    Dataset<Row> results = spark.read()\n-        .format(\"iceberg\")\n-        .load(tableLocation);\n-    results.createOrReplaceTempView(\"table\");\n-\n-    scanEventCount = 0;\n-    lastScanEvent = null;\n-  }\n-\n-  @Test\n-  public void testSelect() {\n-    List<Record> expected = ImmutableList.of(\n-        new Record(1, \"a\", 1.0), new Record(2, \"b\", 2.0), new Record(3, \"c\", Double.NaN));\n-\n-    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"select * from table\"));\n-  }\n-\n-  @Test\n-  public void testSelectRewrite() {\n-    List<Record> expected = ImmutableList.of(new Record(3, \"c\", Double.NaN));\n-\n-    Assert.assertEquals(\"Should return all expected rows\", expected,\n-        sql(\"SELECT * FROM table where doubleVal = double('NaN')\"));\n-    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n-  }\n-\n-  @Test\n-  public void testProjection() {\n-    List<Record> expected = ImmutableList.of(\n-        new Record(1, null, null), new Record(2, null, null), new Record(3, null, null));\n-\n-    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT id FROM table\"));\n-\n-    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n-    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n-    Assert.assertEquals(\"Should project only the id column\",\n-        table.schema().select(\"id\").asStruct(),\n-        lastScanEvent.projection().asStruct());\n-  }\n-\n-  @Test\n-  public void testExpressionPushdown() {\n-    List<Record> expected = ImmutableList.of(new Record(null, \"b\", null));\n-\n-    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT data FROM table WHERE id = 2\"));\n-\n-    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n-    Assert.assertEquals(\"Should project only id and data columns\",\n-        table.schema().select(\"id\", \"data\").asStruct(),\n-        lastScanEvent.projection().asStruct());\n-  }\n-\n-  private List<Record> sql(String str) {\n-    List<Row> rows = spark.sql(str).collectAsList();\n-    return rows.stream()\n-        .map(row -> {\n-          if (row.length() == 1) {\n-            if (row.get(0) instanceof String) {\n-              return new Record(null, val(row, 0), null);\n-            } else {\n-              return new Record(val(row, 0), null, null);\n-            }\n-          } else {\n-            return new Record(\n-                val(row, 0),\n-                val(row, 1),\n-                val(row, 2));\n-          }\n-        })\n-        .collect(Collectors.toList());\n-  }\n-\n-  private <T> T val(Row row, int index) {\n-    return row.length() <= index || row.isNullAt(index) ? null : (T) row.get(index);\n-  }\n-\n-  public static class Record {\n-    private Integer id;\n-    private String data;\n-    private Double doubleVal;\n-\n-    Record(Integer id, String data, Double doubleVal) {\n-      this.id = id;\n-      this.data = data;\n-      this.doubleVal = doubleVal;\n-    }\n-\n-    public Integer getId() {\n-      return id;\n-    }\n-\n-    public String getData() {\n-      return data;\n-    }\n-\n-    public Double getDoubleVal() {\n-      return doubleVal;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      Record record = (Record) o;\n-      return Objects.equal(id, record.id) && Objects.equal(data, record.data) &&\n-          Objects.equal(doubleVal, record.doubleVal);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return Objects.hashCode(id, data, doubleVal);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMTg0Ng==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r538901846", "bodyText": "This seems brittle because it uses types to place the results.\nOther tests use StructProjection and StructLikeSet for similar validations. The incoming row is wrapped to be a StructLike and added to a StructLikeSet based on the expected schema. Then another StructLikeSet is created with the expected rows, which are projected using StructProjection and the expected schema. That is a cleaner way to do this, I think.", "author": "rdblue", "createdAt": "2020-12-09T00:02:41Z", "path": "spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.source;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.events.Listeners;\n+import org.apache.iceberg.events.ScanEvent;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.relocated.com.google.common.base.Objects;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.types.Types;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import static org.apache.iceberg.types.Types.NestedField.optional;\n+\n+public class TestSelect {\n+  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n+  private static final Schema SCHEMA = new Schema(\n+      optional(1, \"id\", Types.IntegerType.get()),\n+      optional(2, \"data\", Types.StringType.get()),\n+      optional(3, \"doubleVal\", Types.DoubleType.get())\n+  );\n+\n+  private static SparkSession spark;\n+\n+  private static int scanEventCount = 0;\n+  private static ScanEvent lastScanEvent = null;\n+\n+  private Table table;\n+\n+  static {\n+    Listeners.register(event -> {\n+      scanEventCount += 1;\n+      lastScanEvent = event;\n+    }, ScanEvent.class);\n+  }\n+\n+  @BeforeClass\n+  public static void startSpark() {\n+    spark = SparkSession.builder()\n+        .master(\"local[2]\")\n+        .getOrCreate();\n+  }\n+\n+  @AfterClass\n+  public static void stopSpark() {\n+    SparkSession currentSpark = spark;\n+    spark = null;\n+    currentSpark.stop();\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private String tableLocation = null;\n+\n+  @Before\n+  public void init() throws Exception {\n+    File tableDir = temp.newFolder();\n+    this.tableLocation = tableDir.toURI().toString();\n+\n+    table = TABLES.create(SCHEMA, tableLocation);\n+\n+    List<Record> rows = Lists.newArrayList(\n+        new Record(1, \"a\", 1.0),\n+        new Record(2, \"b\", 2.0),\n+        new Record(3, \"c\", Double.NaN)\n+    );\n+\n+    Dataset<Row> df = spark.createDataFrame(rows, Record.class);\n+\n+    df.select(\"id\", \"data\", \"doubleVal\").write()\n+        .format(\"iceberg\")\n+        .mode(\"append\")\n+        .save(tableLocation);\n+\n+    table.refresh();\n+\n+    Dataset<Row> results = spark.read()\n+        .format(\"iceberg\")\n+        .load(tableLocation);\n+    results.createOrReplaceTempView(\"table\");\n+\n+    scanEventCount = 0;\n+    lastScanEvent = null;\n+  }\n+\n+  @Test\n+  public void testSelect() {\n+    List<Record> expected = ImmutableList.of(\n+        new Record(1, \"a\", 1.0), new Record(2, \"b\", 2.0), new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"select * from table\"));\n+  }\n+\n+  @Test\n+  public void testSelectRewrite() {\n+    List<Record> expected = ImmutableList.of(new Record(3, \"c\", Double.NaN));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected,\n+        sql(\"SELECT * FROM table where doubleVal = double('NaN')\"));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+  }\n+\n+  @Test\n+  public void testProjection() {\n+    List<Record> expected = ImmutableList.of(\n+        new Record(1, null, null), new Record(2, null, null), new Record(3, null, null));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT id FROM table\"));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+    Assert.assertEquals(\"Should project only the id column\",\n+        table.schema().select(\"id\").asStruct(),\n+        lastScanEvent.projection().asStruct());\n+  }\n+\n+  @Test\n+  public void testExpressionPushdown() {\n+    List<Record> expected = ImmutableList.of(new Record(null, \"b\", null));\n+\n+    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT data FROM table WHERE id = 2\"));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should project only id and data columns\",\n+        table.schema().select(\"id\", \"data\").asStruct(),\n+        lastScanEvent.projection().asStruct());\n+  }\n+\n+  private List<Record> sql(String str) {\n+    List<Row> rows = spark.sql(str).collectAsList();", "originalCommit": "730ce5b791ea775b04870189940e18014211fb59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMjI3Ng==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r538902276", "bodyText": "Looks like this uses a Java bean record class, so you could also rely on Spark to convert to your record class, and then use a special comparison function to only compare expected columns.", "author": "rdblue", "createdAt": "2020-12-09T00:03:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMTg0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5MTEwNQ==", "url": "https://github.com/apache/iceberg/pull/1857#discussion_r539691105", "bodyText": "Sounds good, I wanted to scope this Record class to only be used for this class' use cases but this is definitely not clean. I changed this to use Spark for converting to Java bean, but encountered a similar issue as described in this post that when projecting a subset of columns, conversion doesn't work due to missing expected columns. Since in this class I'm just projecting one column with primitive type, I convert data frame into their specific classes instead. Please let me know if you know better ways of doing this!", "author": "yyanyy", "createdAt": "2020-12-09T22:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwMTg0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "cc8dc2b38895b251e8e5394535f986d3ec92025f", "chunk": "diff --git a/spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java b/spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java\ndeleted file mode 100644\nindex 3a099463f..000000000\n--- a/spark2/src/test/java/org/apache/iceberg/spark/source/TestSelect.java\n+++ /dev/null\n\n@@ -1,230 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.iceberg.spark.source;\n-\n-import java.io.File;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-import org.apache.hadoop.conf.Configuration;\n-import org.apache.iceberg.Schema;\n-import org.apache.iceberg.Table;\n-import org.apache.iceberg.events.Listeners;\n-import org.apache.iceberg.events.ScanEvent;\n-import org.apache.iceberg.expressions.Expressions;\n-import org.apache.iceberg.hadoop.HadoopTables;\n-import org.apache.iceberg.relocated.com.google.common.base.Objects;\n-import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n-import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n-import org.apache.iceberg.types.Types;\n-import org.apache.spark.sql.Dataset;\n-import org.apache.spark.sql.Row;\n-import org.apache.spark.sql.SparkSession;\n-import org.junit.AfterClass;\n-import org.junit.Assert;\n-import org.junit.Before;\n-import org.junit.BeforeClass;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.TemporaryFolder;\n-\n-import static org.apache.iceberg.types.Types.NestedField.optional;\n-\n-public class TestSelect {\n-  private static final HadoopTables TABLES = new HadoopTables(new Configuration());\n-  private static final Schema SCHEMA = new Schema(\n-      optional(1, \"id\", Types.IntegerType.get()),\n-      optional(2, \"data\", Types.StringType.get()),\n-      optional(3, \"doubleVal\", Types.DoubleType.get())\n-  );\n-\n-  private static SparkSession spark;\n-\n-  private static int scanEventCount = 0;\n-  private static ScanEvent lastScanEvent = null;\n-\n-  private Table table;\n-\n-  static {\n-    Listeners.register(event -> {\n-      scanEventCount += 1;\n-      lastScanEvent = event;\n-    }, ScanEvent.class);\n-  }\n-\n-  @BeforeClass\n-  public static void startSpark() {\n-    spark = SparkSession.builder()\n-        .master(\"local[2]\")\n-        .getOrCreate();\n-  }\n-\n-  @AfterClass\n-  public static void stopSpark() {\n-    SparkSession currentSpark = spark;\n-    spark = null;\n-    currentSpark.stop();\n-  }\n-\n-  @Rule\n-  public TemporaryFolder temp = new TemporaryFolder();\n-\n-  private String tableLocation = null;\n-\n-  @Before\n-  public void init() throws Exception {\n-    File tableDir = temp.newFolder();\n-    this.tableLocation = tableDir.toURI().toString();\n-\n-    table = TABLES.create(SCHEMA, tableLocation);\n-\n-    List<Record> rows = Lists.newArrayList(\n-        new Record(1, \"a\", 1.0),\n-        new Record(2, \"b\", 2.0),\n-        new Record(3, \"c\", Double.NaN)\n-    );\n-\n-    Dataset<Row> df = spark.createDataFrame(rows, Record.class);\n-\n-    df.select(\"id\", \"data\", \"doubleVal\").write()\n-        .format(\"iceberg\")\n-        .mode(\"append\")\n-        .save(tableLocation);\n-\n-    table.refresh();\n-\n-    Dataset<Row> results = spark.read()\n-        .format(\"iceberg\")\n-        .load(tableLocation);\n-    results.createOrReplaceTempView(\"table\");\n-\n-    scanEventCount = 0;\n-    lastScanEvent = null;\n-  }\n-\n-  @Test\n-  public void testSelect() {\n-    List<Record> expected = ImmutableList.of(\n-        new Record(1, \"a\", 1.0), new Record(2, \"b\", 2.0), new Record(3, \"c\", Double.NaN));\n-\n-    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"select * from table\"));\n-  }\n-\n-  @Test\n-  public void testSelectRewrite() {\n-    List<Record> expected = ImmutableList.of(new Record(3, \"c\", Double.NaN));\n-\n-    Assert.assertEquals(\"Should return all expected rows\", expected,\n-        sql(\"SELECT * FROM table where doubleVal = double('NaN')\"));\n-    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n-  }\n-\n-  @Test\n-  public void testProjection() {\n-    List<Record> expected = ImmutableList.of(\n-        new Record(1, null, null), new Record(2, null, null), new Record(3, null, null));\n-\n-    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT id FROM table\"));\n-\n-    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n-    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n-    Assert.assertEquals(\"Should project only the id column\",\n-        table.schema().select(\"id\").asStruct(),\n-        lastScanEvent.projection().asStruct());\n-  }\n-\n-  @Test\n-  public void testExpressionPushdown() {\n-    List<Record> expected = ImmutableList.of(new Record(null, \"b\", null));\n-\n-    Assert.assertEquals(\"Should return all expected rows\", expected, sql(\"SELECT data FROM table WHERE id = 2\"));\n-\n-    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n-    Assert.assertEquals(\"Should project only id and data columns\",\n-        table.schema().select(\"id\", \"data\").asStruct(),\n-        lastScanEvent.projection().asStruct());\n-  }\n-\n-  private List<Record> sql(String str) {\n-    List<Row> rows = spark.sql(str).collectAsList();\n-    return rows.stream()\n-        .map(row -> {\n-          if (row.length() == 1) {\n-            if (row.get(0) instanceof String) {\n-              return new Record(null, val(row, 0), null);\n-            } else {\n-              return new Record(val(row, 0), null, null);\n-            }\n-          } else {\n-            return new Record(\n-                val(row, 0),\n-                val(row, 1),\n-                val(row, 2));\n-          }\n-        })\n-        .collect(Collectors.toList());\n-  }\n-\n-  private <T> T val(Row row, int index) {\n-    return row.length() <= index || row.isNullAt(index) ? null : (T) row.get(index);\n-  }\n-\n-  public static class Record {\n-    private Integer id;\n-    private String data;\n-    private Double doubleVal;\n-\n-    Record(Integer id, String data, Double doubleVal) {\n-      this.id = id;\n-      this.data = data;\n-      this.doubleVal = doubleVal;\n-    }\n-\n-    public Integer getId() {\n-      return id;\n-    }\n-\n-    public String getData() {\n-      return data;\n-    }\n-\n-    public Double getDoubleVal() {\n-      return doubleVal;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-      if (this == o) {\n-        return true;\n-      }\n-      if (o == null || getClass() != o.getClass()) {\n-        return false;\n-      }\n-\n-      Record record = (Record) o;\n-      return Objects.equal(id, record.id) && Objects.equal(data, record.data) &&\n-          Objects.equal(doubleVal, record.doubleVal);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return Objects.hashCode(id, data, doubleVal);\n-    }\n-  }\n-}\n"}}, {"oid": "cc8dc2b38895b251e8e5394535f986d3ec92025f", "url": "https://github.com/apache/iceberg/commit/cc8dc2b38895b251e8e5394535f986d3ec92025f", "message": "rewrite equals filters", "committedDate": "2020-12-09T22:17:27Z", "type": "commit"}, {"oid": "e8942159baa2d3dc747d25314b7b970fd07afc18", "url": "https://github.com/apache/iceberg/commit/e8942159baa2d3dc747d25314b7b970fd07afc18", "message": "add spark2 test", "committedDate": "2020-12-09T22:17:27Z", "type": "commit"}, {"oid": "ecb3839c039f21427ee5b8b191e84af0b1d2d848", "url": "https://github.com/apache/iceberg/commit/ecb3839c039f21427ee5b8b191e84af0b1d2d848", "message": "update spark2 test", "committedDate": "2020-12-09T22:18:39Z", "type": "commit"}, {"oid": "ecb3839c039f21427ee5b8b191e84af0b1d2d848", "url": "https://github.com/apache/iceberg/commit/ecb3839c039f21427ee5b8b191e84af0b1d2d848", "message": "update spark2 test", "committedDate": "2020-12-09T22:18:39Z", "type": "forcePushed"}, {"oid": "031582f21a4d91d91a497181ad96f92967d8cbcf", "url": "https://github.com/apache/iceberg/commit/031582f21a4d91d91a497181ad96f92967d8cbcf", "message": "change is_nan() representation in describe()", "committedDate": "2020-12-10T02:27:01Z", "type": "commit"}]}