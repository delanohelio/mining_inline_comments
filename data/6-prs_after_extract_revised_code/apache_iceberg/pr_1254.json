{"pr_number": 1254, "pr_title": "Parquet: Add row position reader", "pr_createdAt": "2020-07-27T12:32:13Z", "pr_url": "https://github.com/apache/iceberg/pull/1254", "timeline": [{"oid": "8bb39c32955484b470b0827907ae7495d42c2dc6", "url": "https://github.com/apache/iceberg/commit/8bb39c32955484b470b0827907ae7495d42c2dc6", "message": "Parquet: Add row position reader", "committedDate": "2020-07-27T12:30:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0NzgwNQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461047805", "bodyText": "Is removing the metadata fields from the projection schema required? We do this in the ORC implementation to avoid unnecessarily creating a Column Vector, and the ORC ReadBuilder take this into account while building the readers. What puzzles me is that this logic is not in the actual read path for Parquet and is only in the test read path.", "author": "shardulm94", "createdAt": "2020-07-27T17:21:25Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.apache.arrow.vector.NullCheckingForGet;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.Files;\n+import org.apache.iceberg.MetadataColumns;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.parquet.ParquetSchemaUtil;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.iceberg.spark.data.vectorized.VectorizedSparkParquetReaders;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.parquet.ParquetReadOptions;\n+import org.apache.parquet.hadoop.ParquetFileReader;\n+import org.apache.parquet.hadoop.ParquetFileWriter;\n+import org.apache.parquet.hadoop.metadata.BlockMetaData;\n+import org.apache.parquet.hadoop.util.HadoopInputFile;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.catalyst.expressions.GenericInternalRow;\n+import org.apache.spark.sql.types.StructType;\n+import org.apache.spark.unsafe.types.UTF8String;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+@RunWith(Parameterized.class)\n+public class TestSparkParquetReadMetadataColumns {\n+  private static final Schema DATA_SCHEMA = new Schema(\n+      required(100, \"id\", Types.LongType.get()),\n+      required(101, \"data\", Types.StringType.get())\n+  );\n+\n+  private static final Schema PROJECTION_SCHEMA = new Schema(\n+      required(100, \"id\", Types.LongType.get()),\n+      required(101, \"data\", Types.StringType.get()),\n+      MetadataColumns.ROW_POSITION\n+  );\n+\n+  private static final int NUM_ROWS = 1000;\n+  private static final List<InternalRow> DATA_ROWS;\n+  private static final List<InternalRow> EXPECTED_ROWS;\n+  private static final int NUM_ROW_GROUPS = 10;\n+  private static final int ROWS_PER_SPLIT = NUM_ROWS / NUM_ROW_GROUPS;\n+\n+  static {\n+    DATA_ROWS = Lists.newArrayListWithCapacity(NUM_ROWS);\n+    for (long i = 0; i < NUM_ROWS; i++) {\n+      InternalRow row = new GenericInternalRow(DATA_SCHEMA.columns().size());\n+      row.update(0, i);\n+      row.update(1, UTF8String.fromString(\"str\" + i));\n+      DATA_ROWS.add(row);\n+    }\n+\n+    EXPECTED_ROWS = Lists.newArrayListWithCapacity(NUM_ROWS);\n+    for (long i = 0; i < NUM_ROWS; i++) {\n+      InternalRow row = new GenericInternalRow(PROJECTION_SCHEMA.columns().size());\n+      row.update(0, i);\n+      row.update(1, UTF8String.fromString(\"str\" + i));\n+      row.update(2, i);\n+      EXPECTED_ROWS.add(row);\n+    }\n+  }\n+\n+  @Parameterized.Parameters\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+        new Object[] { false },\n+        //new Object[] { true }\n+    };\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private boolean vectorized;\n+  private File testFile;\n+\n+  public TestSparkParquetReadMetadataColumns(boolean vectorized) {\n+    this.vectorized = vectorized;\n+  }\n+\n+  @Before\n+  public void writeFile() throws IOException {\n+    List<Path> fileSplits = new ArrayList<>();\n+    StructType struct = SparkSchemaUtil.convert(DATA_SCHEMA);\n+    Configuration conf = new Configuration();\n+\n+    testFile = temp.newFile();\n+    Assert.assertTrue(\"Delete should succeed\", testFile.delete());\n+    ParquetFileWriter parquetFileWriter = new ParquetFileWriter(\n+        conf,\n+        ParquetSchemaUtil.convert(DATA_SCHEMA, \"testSchema\"),\n+        new Path(testFile.getAbsolutePath())\n+    );\n+\n+    parquetFileWriter.start();\n+    for (int i = 0; i < NUM_ROW_GROUPS; i += 1) {\n+      File split = temp.newFile();\n+      Assert.assertTrue(\"Delete should succeed\", split.delete());\n+      fileSplits.add(new Path(split.getAbsolutePath()));\n+      try (FileAppender<InternalRow> writer = Parquet.write(Files.localOutput(split))\n+          .createWriterFunc(msgType -> SparkParquetWriters.buildWriter(struct, msgType))\n+          .schema(DATA_SCHEMA)\n+          .overwrite()\n+          .build()) {\n+        writer.addAll(DATA_ROWS.subList(i * ROWS_PER_SPLIT, (i + 1) * ROWS_PER_SPLIT));\n+      }\n+      parquetFileWriter.appendFile(HadoopInputFile.fromPath(new Path(split.getAbsolutePath()), conf));\n+    }\n+    parquetFileWriter\n+        .end(ParquetFileWriter.mergeMetadataFiles(fileSplits, conf).getFileMetaData().getKeyValueMetaData());\n+  }\n+\n+  @Test\n+  public void testReadRowNumbers() throws IOException {\n+    readAndValidate(null, null, null, EXPECTED_ROWS);\n+  }\n+\n+  @Test\n+  public void testReadRowNumbersWithFilter() throws IOException {\n+    // current iceberg support row group filter.\n+    for (int i = 0; i < NUM_ROW_GROUPS; i += 1) {\n+      readAndValidate(Expressions.greaterThanOrEqual(\"id\", i * ROWS_PER_SPLIT), null, null,\n+          EXPECTED_ROWS.subList(i * ROWS_PER_SPLIT, 1000));\n+    }\n+  }\n+\n+  @Test\n+  public void testReadRowNumbersWithSplits() throws IOException {\n+    ParquetFileReader fileReader = new ParquetFileReader(\n+        HadoopInputFile.fromPath(new Path(testFile.getAbsolutePath()), new Configuration()),\n+        ParquetReadOptions.builder().build());\n+    List<BlockMetaData> rowGroups = fileReader.getRowGroups();\n+    for (int i = 0; i < NUM_ROW_GROUPS; i += 1) {\n+      readAndValidate(null,\n+          rowGroups.get(i).getColumns().get(1).getStartingPos(),\n+          rowGroups.get(i).getCompressedSize(),\n+          EXPECTED_ROWS.subList(i * ROWS_PER_SPLIT, (i + 1) * ROWS_PER_SPLIT));\n+    }\n+  }\n+\n+  private void readAndValidate(Expression filter, Long splitStart, Long splitLength, List<InternalRow> expected)\n+      throws IOException {\n+    Schema projectionWithoutMetadataFields = TypeUtil.selectNot(PROJECTION_SCHEMA, MetadataColumns.metadataFieldIds());", "originalCommit": "8bb39c32955484b470b0827907ae7495d42c2dc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMyMTEzNw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461321137", "bodyText": "Hmm, this is a copy-paste error. let me remove this at first. At least, I don't use any related logic right now.", "author": "chenjunjiedada", "createdAt": "2020-07-28T05:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0NzgwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "9b131c34fb7162cf329c64471a27517d598458b1", "chunk": "diff --git a/spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java b/spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java\nindex 6098781a7..c7378782a 100644\n--- a/spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java\n+++ b/spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java\n\n@@ -39,7 +39,6 @@ import org.apache.iceberg.parquet.ParquetSchemaUtil;\n import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n import org.apache.iceberg.spark.SparkSchemaUtil;\n import org.apache.iceberg.spark.data.vectorized.VectorizedSparkParquetReaders;\n-import org.apache.iceberg.types.TypeUtil;\n import org.apache.iceberg.types.Types;\n import org.apache.parquet.ParquetReadOptions;\n import org.apache.parquet.hadoop.ParquetFileReader;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA3MTkxOA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461071918", "bodyText": "If I change this to row.update(0, 2 * i); and the same for EXPECTED_ROWS, testReadRowNumbersWithSplits() seems to fail. Can you check if the split generation logic in the test case is correct?", "author": "shardulm94", "createdAt": "2020-07-27T18:03:09Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.apache.arrow.vector.NullCheckingForGet;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.Files;\n+import org.apache.iceberg.MetadataColumns;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.parquet.ParquetSchemaUtil;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.iceberg.spark.data.vectorized.VectorizedSparkParquetReaders;\n+import org.apache.iceberg.types.TypeUtil;\n+import org.apache.iceberg.types.Types;\n+import org.apache.parquet.ParquetReadOptions;\n+import org.apache.parquet.hadoop.ParquetFileReader;\n+import org.apache.parquet.hadoop.ParquetFileWriter;\n+import org.apache.parquet.hadoop.metadata.BlockMetaData;\n+import org.apache.parquet.hadoop.util.HadoopInputFile;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.catalyst.expressions.GenericInternalRow;\n+import org.apache.spark.sql.types.StructType;\n+import org.apache.spark.unsafe.types.UTF8String;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+@RunWith(Parameterized.class)\n+public class TestSparkParquetReadMetadataColumns {\n+  private static final Schema DATA_SCHEMA = new Schema(\n+      required(100, \"id\", Types.LongType.get()),\n+      required(101, \"data\", Types.StringType.get())\n+  );\n+\n+  private static final Schema PROJECTION_SCHEMA = new Schema(\n+      required(100, \"id\", Types.LongType.get()),\n+      required(101, \"data\", Types.StringType.get()),\n+      MetadataColumns.ROW_POSITION\n+  );\n+\n+  private static final int NUM_ROWS = 1000;\n+  private static final List<InternalRow> DATA_ROWS;\n+  private static final List<InternalRow> EXPECTED_ROWS;\n+  private static final int NUM_ROW_GROUPS = 10;\n+  private static final int ROWS_PER_SPLIT = NUM_ROWS / NUM_ROW_GROUPS;\n+\n+  static {\n+    DATA_ROWS = Lists.newArrayListWithCapacity(NUM_ROWS);\n+    for (long i = 0; i < NUM_ROWS; i++) {\n+      InternalRow row = new GenericInternalRow(DATA_SCHEMA.columns().size());\n+      row.update(0, i);", "originalCommit": "8bb39c32955484b470b0827907ae7495d42c2dc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMyMTcwNA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461321704", "bodyText": "Nice catch! The split start should use the first column's starting pos other than the second one. I updated the UT to cover both row.update(0, i) and row.update(0, 2*i).", "author": "chenjunjiedada", "createdAt": "2020-07-28T05:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA3MTkxOA=="}], "type": "inlineReview", "revised_code": {"commit": "9b131c34fb7162cf329c64471a27517d598458b1", "chunk": "diff --git a/spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java b/spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java\nindex 6098781a7..c7378782a 100644\n--- a/spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java\n+++ b/spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java\n\n@@ -39,7 +39,6 @@ import org.apache.iceberg.parquet.ParquetSchemaUtil;\n import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n import org.apache.iceberg.spark.SparkSchemaUtil;\n import org.apache.iceberg.spark.data.vectorized.VectorizedSparkParquetReaders;\n-import org.apache.iceberg.types.TypeUtil;\n import org.apache.iceberg.types.Types;\n import org.apache.parquet.ParquetReadOptions;\n import org.apache.parquet.hadoop.ParquetFileReader;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE1MDE3Nw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461150177", "bodyText": "Nit: Should be rowGroupRowOffsetInFile to maintain consistent camel casing in the variable name.", "author": "shardulm94", "createdAt": "2020-07-27T20:28:53Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java", "diffHunk": "@@ -137,6 +137,41 @@ public void setPageSource(PageReadStore pageStore) {\n     }\n   }\n \n+  static class PositionReader implements ParquetValueReader<Long> {\n+    private long rowOffsetInCurrentRowGroup = -1;\n+    private long rowGroupRowOffsetInfile;", "originalCommit": "8bb39c32955484b470b0827907ae7495d42c2dc6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b131c34fb7162cf329c64471a27517d598458b1", "chunk": "diff --git a/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java b/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java\nindex 5eb4c919c..3dd41c6cd 100644\n--- a/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java\n+++ b/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java\n\n@@ -139,12 +139,12 @@ public class ParquetValueReaders {\n \n   static class PositionReader implements ParquetValueReader<Long> {\n     private long rowOffsetInCurrentRowGroup = -1;\n-    private long rowGroupRowOffsetInfile;\n+    private long rowGroupRowOffsetInFile;\n \n     @Override\n     public Long read(Long reuse) {\n       rowOffsetInCurrentRowGroup = rowOffsetInCurrentRowGroup + 1;\n-      return rowGroupRowOffsetInfile + rowOffsetInCurrentRowGroup;\n+      return rowGroupRowOffsetInFile + rowOffsetInCurrentRowGroup;\n     }\n \n     @Override\n"}}, {"oid": "9b131c34fb7162cf329c64471a27517d598458b1", "url": "https://github.com/apache/iceberg/commit/9b131c34fb7162cf329c64471a27517d598458b1", "message": "address comments", "committedDate": "2020-07-28T05:19:55Z", "type": "commit"}, {"oid": "9b131c34fb7162cf329c64471a27517d598458b1", "url": "https://github.com/apache/iceberg/commit/9b131c34fb7162cf329c64471a27517d598458b1", "message": "address comments", "committedDate": "2020-07-28T05:19:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MDk0MQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461890941", "bodyText": "Why not add the position to the page source? Then the two operations are tied together: the row offset is the start offset for the new pages.", "author": "rdblue", "createdAt": "2020-07-28T21:29:24Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReader.java", "diffHunk": "@@ -30,4 +30,6 @@\n   List<TripleIterator<?>> columns();\n \n   void setPageSource(PageReadStore pageStore);\n+\n+  default void setRowOffsetForRowGroup(long position) {}", "originalCommit": "9b131c34fb7162cf329c64471a27517d598458b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNjkwNw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462006907", "bodyText": "I can change to that. Just one thing that do we mind to change the function signature in the public API?", "author": "chenjunjiedada", "createdAt": "2020-07-29T02:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MDk0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "76293446f71ae911f858a67cba210caca7549a9b", "chunk": "diff --git a/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReader.java b/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReader.java\nindex 9f399657c..a556849d3 100644\n--- a/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReader.java\n+++ b/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReader.java\n\n@@ -29,7 +29,5 @@ public interface ParquetValueReader<T> {\n \n   List<TripleIterator<?>> columns();\n \n-  void setPageSource(PageReadStore pageStore);\n-\n-  default void setRowOffsetForRowGroup(long position) {}\n+  void setPageSource(PageReadStore pageStore, long rowPosition);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MTkwMQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461891901", "bodyText": "Can you move this to the top of the file with the other factory methods?", "author": "rdblue", "createdAt": "2020-07-28T21:31:25Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java", "diffHunk": "@@ -137,6 +137,41 @@ public void setPageSource(PageReadStore pageStore) {\n     }\n   }\n \n+  static class PositionReader implements ParquetValueReader<Long> {\n+    private long rowOffsetInCurrentRowGroup = -1;\n+    private long rowGroupRowOffsetInFile;\n+\n+    @Override\n+    public Long read(Long reuse) {\n+      rowOffsetInCurrentRowGroup = rowOffsetInCurrentRowGroup + 1;\n+      return rowGroupRowOffsetInFile + rowOffsetInCurrentRowGroup;\n+    }\n+\n+    @Override\n+    public TripleIterator<?> column() {\n+      return NullReader.NULL_COLUMN;\n+    }\n+\n+    @Override\n+    public List<TripleIterator<?>> columns() {\n+      return NullReader.COLUMNS;\n+    }\n+\n+    @Override\n+    public void setPageSource(PageReadStore pageStore) {\n+    }\n+\n+    @Override\n+    public void setRowOffsetForRowGroup(long rowGroupStartPos) {\n+      this.rowGroupRowOffsetInFile = rowGroupStartPos;\n+      this.rowOffsetInCurrentRowGroup = -1;\n+    }\n+  }\n+\n+  public static ParquetValueReader<Long> position() {\n+    return new PositionReader();\n+  }", "originalCommit": "9b131c34fb7162cf329c64471a27517d598458b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNDM4OA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462014388", "bodyText": "Done.", "author": "chenjunjiedada", "createdAt": "2020-07-29T03:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MTkwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "76293446f71ae911f858a67cba210caca7549a9b", "chunk": "diff --git a/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java b/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java\nindex 3dd41c6cd..a9a6bc96f 100644\n--- a/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java\n+++ b/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java\n\n@@ -133,18 +137,18 @@ public class ParquetValueReaders {\n     }\n \n     @Override\n-    public void setPageSource(PageReadStore pageStore) {\n+    public void setPageSource(PageReadStore pageStore, long rowPosition) {\n     }\n   }\n \n   static class PositionReader implements ParquetValueReader<Long> {\n-    private long rowOffsetInCurrentRowGroup = -1;\n-    private long rowGroupRowOffsetInFile;\n+    private long rowOffset = -1;\n+    private long rowGroupStart;\n \n     @Override\n     public Long read(Long reuse) {\n-      rowOffsetInCurrentRowGroup = rowOffsetInCurrentRowGroup + 1;\n-      return rowGroupRowOffsetInFile + rowOffsetInCurrentRowGroup;\n+      rowOffset = rowOffset + 1;\n+      return rowGroupStart + rowOffset;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MjQ5Mw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461892493", "bodyText": "How about naming this startPositions?", "author": "rdblue", "createdAt": "2020-07-28T21:32:44Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "diffHunk": "@@ -157,6 +164,23 @@ ParquetFileReader reader() {\n     return shouldSkip;\n   }\n \n+  private Map<Long, Long> generateRowGroupsStartRowPos() {\n+    ParquetFileReader fileReader = newReader(this.file, ParquetReadOptions.builder().build());\n+    Map<Long, Long> offsetToStartRowPosMap = new HashMap<>();\n+    long curRowCount = 0;\n+    for (int i = 0; i < fileReader.getRowGroups().size(); i += 1) {\n+      BlockMetaData meta = fileReader.getRowGroups().get(i);\n+      offsetToStartRowPosMap.put(meta.getStartingPos(), curRowCount);\n+      curRowCount += meta.getRowCount();\n+    }\n+\n+    return offsetToStartRowPosMap;\n+  }\n+\n+  long[] getRowGroupsStartRowPos() {", "originalCommit": "9b131c34fb7162cf329c64471a27517d598458b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5NTMzMg==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461995332", "bodyText": "startPositions may confuse with rowGroup.startingPosition, how about startRowPosititions?", "author": "chenjunjiedada", "createdAt": "2020-07-29T02:08:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MjQ5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "76293446f71ae911f858a67cba210caca7549a9b", "chunk": "diff --git a/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java b/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java\nindex 0eaa87d0c..23d7a1ebb 100644\n--- a/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java\n+++ b/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java\n\n@@ -177,7 +177,7 @@ class ReadConf<T> {\n     return offsetToStartRowPosMap;\n   }\n \n-  long[] getRowGroupsStartRowPos() {\n+  long[] startRowPositions() {\n     return rowGroupsStartRowPos;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzY0Mg==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461893642", "bodyText": "Why does this separately read the Parquet file to create a map that is used to initialize an array, when the starting position could be set for the array in the existing loop? I don't think this method is needed.", "author": "rdblue", "createdAt": "2020-07-28T21:35:09Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "diffHunk": "@@ -157,6 +164,23 @@ ParquetFileReader reader() {\n     return shouldSkip;\n   }\n \n+  private Map<Long, Long> generateRowGroupsStartRowPos() {", "originalCommit": "9b131c34fb7162cf329c64471a27517d598458b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5MjE2OQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461992169", "bodyText": "The existing loop of row groups is based on the row groups that had been filtered with options.  So we need to read the Parquet file without any filter to get each starting row position of row group.", "author": "chenjunjiedada", "createdAt": "2020-07-29T01:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1OTE5Mg==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462659192", "bodyText": "You're right. Good catch!\nCan you add some comments to explain why this is needed for later?", "author": "rdblue", "createdAt": "2020-07-30T00:09:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxMzAxMQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462713011", "bodyText": "Done.", "author": "chenjunjiedada", "createdAt": "2020-07-30T03:29:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzY0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "76293446f71ae911f858a67cba210caca7549a9b", "chunk": "diff --git a/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java b/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java\nindex 0eaa87d0c..23d7a1ebb 100644\n--- a/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java\n+++ b/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java\n\n@@ -177,7 +177,7 @@ class ReadConf<T> {\n     return offsetToStartRowPosMap;\n   }\n \n-  long[] getRowGroupsStartRowPos() {\n+  long[] startRowPositions() {\n     return rowGroupsStartRowPos;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5NTU1Mw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461895553", "bodyText": "In general, try to be specific with names, but avoid unnecessary context. In this case, these names can be simpler: rowGroupStart and rowOffset would work fine. Extra context like InFile and InCurrent aren't adding clarity.", "author": "rdblue", "createdAt": "2020-07-28T21:39:34Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java", "diffHunk": "@@ -137,6 +137,41 @@ public void setPageSource(PageReadStore pageStore) {\n     }\n   }\n \n+  static class PositionReader implements ParquetValueReader<Long> {\n+    private long rowOffsetInCurrentRowGroup = -1;\n+    private long rowGroupRowOffsetInFile;", "originalCommit": "9b131c34fb7162cf329c64471a27517d598458b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNDM1MQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462014351", "bodyText": "Done.", "author": "chenjunjiedada", "createdAt": "2020-07-29T03:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5NTU1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "76293446f71ae911f858a67cba210caca7549a9b", "chunk": "diff --git a/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java b/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java\nindex 3dd41c6cd..a9a6bc96f 100644\n--- a/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java\n+++ b/parquet/src/main/java/org/apache/iceberg/parquet/ParquetValueReaders.java\n\n@@ -133,18 +137,18 @@ public class ParquetValueReaders {\n     }\n \n     @Override\n-    public void setPageSource(PageReadStore pageStore) {\n+    public void setPageSource(PageReadStore pageStore, long rowPosition) {\n     }\n   }\n \n   static class PositionReader implements ParquetValueReader<Long> {\n-    private long rowOffsetInCurrentRowGroup = -1;\n-    private long rowGroupRowOffsetInFile;\n+    private long rowOffset = -1;\n+    private long rowGroupStart;\n \n     @Override\n     public Long read(Long reuse) {\n-      rowOffsetInCurrentRowGroup = rowOffsetInCurrentRowGroup + 1;\n-      return rowGroupRowOffsetInFile + rowOffsetInCurrentRowGroup;\n+      rowOffset = rowOffset + 1;\n+      return rowGroupStart + rowOffset;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwMDA0NA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r461900044", "bodyText": "Why not use try-with-resources instead of a finally block?", "author": "rdblue", "createdAt": "2020-07-28T21:45:23Z", "path": "spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.apache.arrow.vector.NullCheckingForGet;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.iceberg.Files;\n+import org.apache.iceberg.MetadataColumns;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.parquet.ParquetSchemaUtil;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.spark.SparkSchemaUtil;\n+import org.apache.iceberg.spark.data.vectorized.VectorizedSparkParquetReaders;\n+import org.apache.iceberg.types.Types;\n+import org.apache.parquet.ParquetReadOptions;\n+import org.apache.parquet.hadoop.ParquetFileReader;\n+import org.apache.parquet.hadoop.ParquetFileWriter;\n+import org.apache.parquet.hadoop.metadata.BlockMetaData;\n+import org.apache.parquet.hadoop.util.HadoopInputFile;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.catalyst.expressions.GenericInternalRow;\n+import org.apache.spark.sql.types.StructType;\n+import org.apache.spark.unsafe.types.UTF8String;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+@RunWith(Parameterized.class)\n+public class TestSparkParquetReadMetadataColumns {\n+  private static final Schema DATA_SCHEMA = new Schema(\n+      required(100, \"id\", Types.LongType.get()),\n+      required(101, \"data\", Types.StringType.get())\n+  );\n+\n+  private static final Schema PROJECTION_SCHEMA = new Schema(\n+      required(100, \"id\", Types.LongType.get()),\n+      required(101, \"data\", Types.StringType.get()),\n+      MetadataColumns.ROW_POSITION\n+  );\n+\n+  private static final int NUM_ROWS = 1000;\n+  private static final List<InternalRow> DATA_ROWS;\n+  private static final List<InternalRow> EXPECTED_ROWS;\n+  private static final int NUM_ROW_GROUPS = 10;\n+  private static final int ROWS_PER_SPLIT = NUM_ROWS / NUM_ROW_GROUPS;\n+\n+  static {\n+    DATA_ROWS = Lists.newArrayListWithCapacity(NUM_ROWS);\n+    for (long i = 0; i < NUM_ROWS; i += 1) {\n+      InternalRow row = new GenericInternalRow(DATA_SCHEMA.columns().size());\n+      if (i >= 500) {\n+        row.update(0, 2 * i);\n+      } else {\n+        row.update(0, i);\n+      }\n+      row.update(1, UTF8String.fromString(\"str\" + i));\n+      DATA_ROWS.add(row);\n+    }\n+\n+    EXPECTED_ROWS = Lists.newArrayListWithCapacity(NUM_ROWS);\n+    for (long i = 0; i < NUM_ROWS; i += 1) {\n+      InternalRow row = new GenericInternalRow(PROJECTION_SCHEMA.columns().size());\n+      if (i >= 500) {\n+        row.update(0, 2 * i);\n+      } else {\n+        row.update(0, i);\n+      }\n+      row.update(1, UTF8String.fromString(\"str\" + i));\n+      row.update(2, i);\n+      EXPECTED_ROWS.add(row);\n+    }\n+  }\n+\n+  @Parameterized.Parameters\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+        new Object[] { false },\n+        //new Object[] { true }\n+    };\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private boolean vectorized;\n+  private File testFile;\n+\n+  public TestSparkParquetReadMetadataColumns(boolean vectorized) {\n+    this.vectorized = vectorized;\n+  }\n+\n+  @Before\n+  public void writeFile() throws IOException {\n+    List<Path> fileSplits = new ArrayList<>();\n+    StructType struct = SparkSchemaUtil.convert(DATA_SCHEMA);\n+    Configuration conf = new Configuration();\n+\n+    testFile = temp.newFile();\n+    Assert.assertTrue(\"Delete should succeed\", testFile.delete());\n+    ParquetFileWriter parquetFileWriter = new ParquetFileWriter(\n+        conf,\n+        ParquetSchemaUtil.convert(DATA_SCHEMA, \"testSchema\"),\n+        new Path(testFile.getAbsolutePath())\n+    );\n+\n+    parquetFileWriter.start();\n+    for (int i = 0; i < NUM_ROW_GROUPS; i += 1) {\n+      File split = temp.newFile();\n+      Assert.assertTrue(\"Delete should succeed\", split.delete());\n+      fileSplits.add(new Path(split.getAbsolutePath()));\n+      try (FileAppender<InternalRow> writer = Parquet.write(Files.localOutput(split))\n+          .createWriterFunc(msgType -> SparkParquetWriters.buildWriter(struct, msgType))\n+          .schema(DATA_SCHEMA)\n+          .overwrite()\n+          .build()) {\n+        writer.addAll(DATA_ROWS.subList(i * ROWS_PER_SPLIT, (i + 1) * ROWS_PER_SPLIT));\n+      }\n+      parquetFileWriter.appendFile(HadoopInputFile.fromPath(new Path(split.getAbsolutePath()), conf));\n+    }\n+    parquetFileWriter\n+        .end(ParquetFileWriter.mergeMetadataFiles(fileSplits, conf).getFileMetaData().getKeyValueMetaData());\n+  }\n+\n+  @Test\n+  public void testReadRowNumbers() throws IOException {\n+    readAndValidate(null, null, null, EXPECTED_ROWS);\n+  }\n+\n+  @Test\n+  public void testReadRowNumbersWithFilter() throws IOException {\n+    // current iceberg supports row group filter.\n+    for (int i = 1; i < 5; i += 1) {\n+      readAndValidate(\n+          Expressions.and(Expressions.lessThan(\"id\", 500),\n+              Expressions.greaterThanOrEqual(\"id\", i * ROWS_PER_SPLIT)),\n+          null,\n+          null,\n+          EXPECTED_ROWS.subList(i * ROWS_PER_SPLIT, 500));\n+    }\n+  }\n+\n+  @Test\n+  public void testReadRowNumbersWithSplits() throws IOException {\n+    ParquetFileReader fileReader = new ParquetFileReader(\n+        HadoopInputFile.fromPath(new Path(testFile.getAbsolutePath()), new Configuration()),\n+        ParquetReadOptions.builder().build());\n+    List<BlockMetaData> rowGroups = fileReader.getRowGroups();\n+    for (int i = 0; i < NUM_ROW_GROUPS; i += 1) {\n+      readAndValidate(null,\n+          rowGroups.get(i).getColumns().get(0).getStartingPos(),\n+          rowGroups.get(i).getCompressedSize(),\n+          EXPECTED_ROWS.subList(i * ROWS_PER_SPLIT, (i + 1) * ROWS_PER_SPLIT));\n+    }\n+  }\n+\n+  private void readAndValidate(Expression filter, Long splitStart, Long splitLength, List<InternalRow> expected)\n+      throws IOException {\n+    CloseableIterable<InternalRow> reader = null;\n+    try {\n+      Parquet.ReadBuilder builder = Parquet.read(Files.localInput(testFile))\n+          .project(PROJECTION_SCHEMA);\n+\n+      if (vectorized) {\n+        builder.createBatchedReaderFunc(fileSchema -> VectorizedSparkParquetReaders.buildReader(PROJECTION_SCHEMA,\n+            fileSchema, NullCheckingForGet.NULL_CHECKING_ENABLED));\n+      } else {\n+        builder = builder.createReaderFunc(msgType -> SparkParquetReaders.buildReader(PROJECTION_SCHEMA, msgType));\n+      }\n+\n+      if (filter != null) {\n+        builder = builder.filter(filter);\n+      }\n+\n+      if (splitStart != null && splitLength != null) {\n+        builder = builder.split(splitStart, splitLength);\n+      }\n+\n+      reader = builder.build();\n+\n+      final Iterator<InternalRow> actualRows = reader.iterator();\n+\n+      for (InternalRow internalRow : expected) {\n+        Assert.assertTrue(\"Should have expected number of rows\", actualRows.hasNext());\n+        TestHelpers.assertEquals(PROJECTION_SCHEMA, internalRow, actualRows.next());\n+      }\n+      Assert.assertFalse(\"Should not have extra rows\", actualRows.hasNext());\n+    } finally {\n+      if (reader != null) {\n+        reader.close();", "originalCommit": "9b131c34fb7162cf329c64471a27517d598458b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNDMyNw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462014327", "bodyText": "Done.", "author": "chenjunjiedada", "createdAt": "2020-07-29T03:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwMDA0NA=="}], "type": "inlineReview", "revised_code": {"commit": "76293446f71ae911f858a67cba210caca7549a9b", "chunk": "diff --git a/spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java b/spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java\nindex c7378782a..6382f34ff 100644\n--- a/spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java\n+++ b/spark/src/test/java/org/apache/iceberg/spark/data/TestSparkParquetReadMetadataColumns.java\n\n@@ -189,39 +189,32 @@ public class TestSparkParquetReadMetadataColumns {\n \n   private void readAndValidate(Expression filter, Long splitStart, Long splitLength, List<InternalRow> expected)\n       throws IOException {\n-    CloseableIterable<InternalRow> reader = null;\n-    try {\n-      Parquet.ReadBuilder builder = Parquet.read(Files.localInput(testFile))\n-          .project(PROJECTION_SCHEMA);\n-\n-      if (vectorized) {\n-        builder.createBatchedReaderFunc(fileSchema -> VectorizedSparkParquetReaders.buildReader(PROJECTION_SCHEMA,\n-            fileSchema, NullCheckingForGet.NULL_CHECKING_ENABLED));\n-      } else {\n-        builder = builder.createReaderFunc(msgType -> SparkParquetReaders.buildReader(PROJECTION_SCHEMA, msgType));\n-      }\n+    Parquet.ReadBuilder builder = Parquet.read(Files.localInput(testFile)).project(PROJECTION_SCHEMA);\n \n-      if (filter != null) {\n-        builder = builder.filter(filter);\n-      }\n+    if (vectorized) {\n+      builder.createBatchedReaderFunc(fileSchema -> VectorizedSparkParquetReaders.buildReader(PROJECTION_SCHEMA,\n+          fileSchema, NullCheckingForGet.NULL_CHECKING_ENABLED));\n+    } else {\n+      builder = builder.createReaderFunc(msgType -> SparkParquetReaders.buildReader(PROJECTION_SCHEMA, msgType));\n+    }\n \n-      if (splitStart != null && splitLength != null) {\n-        builder = builder.split(splitStart, splitLength);\n-      }\n+    if (filter != null) {\n+      builder = builder.filter(filter);\n+    }\n \n-      reader = builder.build();\n+    if (splitStart != null && splitLength != null) {\n+      builder = builder.split(splitStart, splitLength);\n+    }\n \n+    try (CloseableIterable<InternalRow> reader = builder.build()) {\n       final Iterator<InternalRow> actualRows = reader.iterator();\n \n       for (InternalRow internalRow : expected) {\n         Assert.assertTrue(\"Should have expected number of rows\", actualRows.hasNext());\n         TestHelpers.assertEquals(PROJECTION_SCHEMA, internalRow, actualRows.next());\n       }\n+\n       Assert.assertFalse(\"Should not have extra rows\", actualRows.hasNext());\n-    } finally {\n-      if (reader != null) {\n-        reader.close();\n-      }\n     }\n   }\n }\n"}}, {"oid": "76293446f71ae911f858a67cba210caca7549a9b", "url": "https://github.com/apache/iceberg/commit/76293446f71ae911f858a67cba210caca7549a9b", "message": "address comments", "committedDate": "2020-07-29T11:20:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MjAxMA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462662010", "bodyText": "Can we use the same name for the variable?", "author": "rdblue", "createdAt": "2020-07-30T00:19:26Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "diffHunk": "@@ -157,6 +164,23 @@ ParquetFileReader reader() {\n     return shouldSkip;\n   }\n \n+  private Map<Long, Long> generateRowGroupsStartRowPos() {\n+    ParquetFileReader fileReader = newReader(this.file, ParquetReadOptions.builder().build());\n+    Map<Long, Long> offsetToStartRowPosMap = new HashMap<>();\n+    long curRowCount = 0;\n+    for (int i = 0; i < fileReader.getRowGroups().size(); i += 1) {\n+      BlockMetaData meta = fileReader.getRowGroups().get(i);\n+      offsetToStartRowPosMap.put(meta.getStartingPos(), curRowCount);\n+      curRowCount += meta.getRowCount();\n+    }\n+\n+    return offsetToStartRowPosMap;\n+  }\n+\n+  long[] startRowPositions() {\n+    return rowGroupsStartRowPos;", "originalCommit": "76293446f71ae911f858a67cba210caca7549a9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxMzA2OA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462713068", "bodyText": "NP, Done.", "author": "chenjunjiedada", "createdAt": "2020-07-30T03:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MjAxMA=="}], "type": "inlineReview", "revised_code": {"commit": "07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "chunk": "diff --git a/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java b/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java\nindex 23d7a1ebb..96286dbca 100644\n--- a/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java\n+++ b/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java\n\n@@ -164,21 +165,21 @@ class ReadConf<T> {\n     return shouldSkip;\n   }\n \n-  private Map<Long, Long> generateRowGroupsStartRowPos() {\n+  private Map<Long, Long> generateOffsetToStartPos() {\n     ParquetFileReader fileReader = newReader(this.file, ParquetReadOptions.builder().build());\n-    Map<Long, Long> offsetToStartRowPosMap = new HashMap<>();\n+    Map<Long, Long> offsetToStartPos = new HashMap<>();\n     long curRowCount = 0;\n     for (int i = 0; i < fileReader.getRowGroups().size(); i += 1) {\n       BlockMetaData meta = fileReader.getRowGroups().get(i);\n-      offsetToStartRowPosMap.put(meta.getStartingPos(), curRowCount);\n+      offsetToStartPos.put(meta.getStartingPos(), curRowCount);\n       curRowCount += meta.getRowCount();\n     }\n \n-    return offsetToStartRowPosMap;\n+    return offsetToStartPos;\n   }\n \n   long[] startRowPositions() {\n-    return rowGroupsStartRowPos;\n+    return startRowPositions;\n   }\n \n   long totalValues() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MjIzNQ==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462662235", "bodyText": "How about naming this offsetToStartPos and similarly updating the method name? There's no need to include a type in the variable name, usually.", "author": "rdblue", "createdAt": "2020-07-30T00:20:21Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "diffHunk": "@@ -85,6 +87,9 @@\n     this.rowGroups = reader.getRowGroups();\n     this.shouldSkip = new boolean[rowGroups.size()];\n \n+    Map<Long, Long> offsetToStartRowPosMap = generateRowGroupsStartRowPos();", "originalCommit": "76293446f71ae911f858a67cba210caca7549a9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxMzExMA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462713110", "bodyText": "OK, done.", "author": "chenjunjiedada", "createdAt": "2020-07-30T03:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MjIzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "chunk": "diff --git a/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java b/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java\nindex 23d7a1ebb..96286dbca 100644\n--- a/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java\n+++ b/parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java\n\n@@ -87,8 +87,9 @@ class ReadConf<T> {\n     this.rowGroups = reader.getRowGroups();\n     this.shouldSkip = new boolean[rowGroups.size()];\n \n-    Map<Long, Long> offsetToStartRowPosMap = generateRowGroupsStartRowPos();\n-    this.rowGroupsStartRowPos = new long[rowGroups.size()];\n+    // Fetch all row groups starting positions to compute the row offsets of the filtered row groups\n+    Map<Long, Long> offsetToStartPos = generateOffsetToStartPos();\n+    this.startRowPositions = new long[rowGroups.size()];\n \n     ParquetMetricsRowGroupFilter statsFilter = null;\n     ParquetDictionaryRowGroupFilter dictFilter = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2NDM0Mw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462664343", "bodyText": "Instead of adding this, can you update setPageSource like the other interface that changed?", "author": "rdblue", "createdAt": "2020-07-30T00:27:56Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/BaseColumnIterator.java", "diffHunk": "@@ -72,4 +73,7 @@ public boolean hasNext() {\n     return triplesRead < triplesCount;\n   }\n \n+  public void setRowPosition(long rowPosition) {", "originalCommit": "76293446f71ae911f858a67cba210caca7549a9b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "chunk": "diff --git a/parquet/src/main/java/org/apache/iceberg/parquet/BaseColumnIterator.java b/parquet/src/main/java/org/apache/iceberg/parquet/BaseColumnIterator.java\nindex d62fa6280..3edc20ff5 100644\n--- a/parquet/src/main/java/org/apache/iceberg/parquet/BaseColumnIterator.java\n+++ b/parquet/src/main/java/org/apache/iceberg/parquet/BaseColumnIterator.java\n\n@@ -73,7 +72,4 @@ public abstract class BaseColumnIterator {\n     return triplesRead < triplesCount;\n   }\n \n-  public void setRowPosition(long rowPosition) {\n-    this.rowPosition = rowPosition;\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2NDQzMw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462664433", "bodyText": "Is this needed? I don't see any uses.", "author": "rdblue", "createdAt": "2020-07-30T00:28:19Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/BaseColumnIterator.java", "diffHunk": "@@ -34,6 +34,7 @@\n   protected long triplesRead = 0L;\n   protected long advanceNextPageCount = 0L;\n   protected Dictionary dictionary;\n+  protected long rowPosition;", "originalCommit": "76293446f71ae911f858a67cba210caca7549a9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxNTQ3Mg==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r462715472", "bodyText": "Right, this and setRowPosition are no longer needed.", "author": "chenjunjiedada", "createdAt": "2020-07-30T03:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2NDQzMw=="}], "type": "inlineReview", "revised_code": {"commit": "07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "chunk": "diff --git a/parquet/src/main/java/org/apache/iceberg/parquet/BaseColumnIterator.java b/parquet/src/main/java/org/apache/iceberg/parquet/BaseColumnIterator.java\nindex d62fa6280..3edc20ff5 100644\n--- a/parquet/src/main/java/org/apache/iceberg/parquet/BaseColumnIterator.java\n+++ b/parquet/src/main/java/org/apache/iceberg/parquet/BaseColumnIterator.java\n\n@@ -34,7 +34,6 @@ public abstract class BaseColumnIterator {\n   protected long triplesRead = 0L;\n   protected long advanceNextPageCount = 0L;\n   protected Dictionary dictionary;\n-  protected long rowPosition;\n \n   protected BaseColumnIterator(ColumnDescriptor descriptor) {\n     this.desc = descriptor;\n"}}, {"oid": "07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "url": "https://github.com/apache/iceberg/commit/07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "message": "fix naming and remove useless variable", "committedDate": "2020-07-30T11:31:59Z", "type": "forcePushed"}, {"oid": "07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "url": "https://github.com/apache/iceberg/commit/07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "message": "fix naming and remove useless variable", "committedDate": "2020-07-30T11:31:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NTAxNA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r463355014", "bodyText": "It just occurred to me (after merging this) that we may want to make this lazy, like we do in Avro. That way if the row positions are never used, we don't incur the cost of reading the footer another time.", "author": "rdblue", "createdAt": "2020-07-31T01:15:08Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/ReadConf.java", "diffHunk": "@@ -85,6 +87,10 @@\n     this.rowGroups = reader.getRowGroups();\n     this.shouldSkip = new boolean[rowGroups.size()];\n \n+    // Fetch all row groups starting positions to compute the row offsets of the filtered row groups\n+    Map<Long, Long> offsetToStartPos = generateOffsetToStartPos();", "originalCommit": "07bb9fbde5d04901c656dbffc64f7956c7bb04c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1Nzk1OA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r463357958", "bodyText": "I used to think to apply Caffeine cache this. Let me think about this again and also check what Avro does. I will update this in follow up vectorization code path.", "author": "chenjunjiedada", "createdAt": "2020-07-31T01:26:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NTAxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNjg4Nw==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r491236887", "bodyText": "@chenjunjiedada  yes we should make this lazy , do you have issue to track improvements to existing logic?", "author": "sudssf", "createdAt": "2020-09-18T23:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NTAxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MzkyMA==", "url": "https://github.com/apache/iceberg/pull/1254#discussion_r491243920", "bodyText": "@sudssf , Yes, I have a PR: #1356. It reads the file when the required schema contains position column.\n    if (expectedSchema.findField(MetadataColumns.ROW_POSITION.fieldId()) != null) {\n      // Only read footer when needed\n      offsetToStartPos = generateOffsetToStartPos();\n    }", "author": "chenjunjiedada", "createdAt": "2020-09-19T00:28:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NTAxNA=="}], "type": "inlineReview", "revised_code": null}]}