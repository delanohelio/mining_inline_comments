{"pr_number": 1108, "pr_title": "Evolve BrokerCapacityConfigResolver interface to be aware whether capacity estimation is allowed or not in broker capacity resolution.", "pr_createdAt": "2020-02-18T19:44:16Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1108", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODQ1OA==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382308458", "bodyText": "If allowBrokerCapacityEstimation is false, then wouldn't node shuffling be redundant?", "author": "efeg", "createdAt": "2020-02-20T23:04:46Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java", "diffHunk": "@@ -517,7 +523,8 @@ public ClusterModel clusterModel(long from,\n         clusterModel.createRack(rack);\n         BrokerCapacityInfo brokerCapacity;\n         try {\n-          brokerCapacity = _brokerCapacityConfigResolver.capacityForBroker(rack, node.host(), node.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n+          brokerCapacity = _brokerCapacityConfigResolver.capacityForBroker(rack, node.host(), node.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS,", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\nindex 5c45e565..2db720cb 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\n\n@@ -516,7 +520,9 @@ public class LoadMonitor {\n       // not have the chance to get the capacity for the other nodes.\n       // Shuffling the node order helps, as the problematic node is unlikely to always be the first node in the list.\n       List<Node> shuffledNodes = new ArrayList<>(cluster.nodes());\n-      Collections.shuffle(shuffledNodes);\n+      if (allowCapacityEstimation) {\n+        Collections.shuffle(shuffledNodes);\n+      }\n       for (Node node : shuffledNodes) {\n         // If the rack is not specified, we use the host info as rack info.\n         String rack = getRackHandleNull(node);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNTk1Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382325956", "bodyText": "Nit: Long line. I will update the checkstyle to make our check more strict -- e.g. from 160 to a more reasonable value.", "author": "efeg", "createdAt": "2020-02-20T23:54:53Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java", "diffHunk": "@@ -255,14 +255,15 @@ public BrokerStats cachedBrokerLoadStats(boolean allowCapacityEstimation) {\n   /**\n    * Get the cluster model cutting off at the current timestamp.\n    * @param requirements the model completeness requirements.\n+   * @param allowBrokerCapacityEstimation Whether allow broker capacity resolver to estimate broker capacity.\n    * @param operationProgress the progress of the job to report.\n    * @return The cluster workload model.\n    * @throws NotEnoughValidWindowsException If there is not enough sample to generate cluster model.\n    * @throws TimeoutException If broker capacity resolver is unable to resolve broker capacity.\n    */\n-  public ClusterModel clusterModel(ModelCompletenessRequirements requirements, OperationProgress operationProgress)\n+  public ClusterModel clusterModel(ModelCompletenessRequirements requirements, Boolean allowBrokerCapacityEstimation, OperationProgress operationProgress)", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java\nindex 96898694..e523aeab 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java\n\n@@ -255,15 +257,18 @@ public class KafkaCruiseControl {\n   /**\n    * Get the cluster model cutting off at the current timestamp.\n    * @param requirements the model completeness requirements.\n-   * @param allowBrokerCapacityEstimation Whether allow broker capacity resolver to estimate broker capacity.\n+   * @param allowCapacityEstimation whether allow capacity estimation in cluster model if the underlying live broker capacity is unavailable.\n    * @param operationProgress the progress of the job to report.\n    * @return The cluster workload model.\n    * @throws NotEnoughValidWindowsException If there is not enough sample to generate cluster model.\n    * @throws TimeoutException If broker capacity resolver is unable to resolve broker capacity.\n+   * @throws BrokerCapacityResolvingException If broker capacity resolver fails to resolve broker capacity.\n    */\n-  public ClusterModel clusterModel(ModelCompletenessRequirements requirements, Boolean allowBrokerCapacityEstimation, OperationProgress operationProgress)\n-      throws NotEnoughValidWindowsException, TimeoutException {\n-    return _loadMonitor.clusterModel(timeMs(), requirements, allowBrokerCapacityEstimation, operationProgress);\n+  public ClusterModel clusterModel(ModelCompletenessRequirements requirements,\n+                                   boolean allowCapacityEstimation,\n+                                   OperationProgress operationProgress)\n+      throws NotEnoughValidWindowsException, TimeoutException, BrokerCapacityResolvingException {\n+    return _loadMonitor.clusterModel(timeMs(), requirements, allowCapacityEstimation, operationProgress);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyODUyNw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382328527", "bodyText": "Why do we prefer a Boolean for allowBrokerCapacityEstimation rather than a boolean -- i.e. is null parameter value allowed here?", "author": "efeg", "createdAt": "2020-02-21T00:03:21Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java", "diffHunk": "@@ -255,14 +255,15 @@ public BrokerStats cachedBrokerLoadStats(boolean allowCapacityEstimation) {\n   /**\n    * Get the cluster model cutting off at the current timestamp.\n    * @param requirements the model completeness requirements.\n+   * @param allowBrokerCapacityEstimation Whether allow broker capacity resolver to estimate broker capacity.\n    * @param operationProgress the progress of the job to report.\n    * @return The cluster workload model.\n    * @throws NotEnoughValidWindowsException If there is not enough sample to generate cluster model.\n    * @throws TimeoutException If broker capacity resolver is unable to resolve broker capacity.\n    */\n-  public ClusterModel clusterModel(ModelCompletenessRequirements requirements, OperationProgress operationProgress)\n+  public ClusterModel clusterModel(ModelCompletenessRequirements requirements, Boolean allowBrokerCapacityEstimation, OperationProgress operationProgress)", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java\nindex 96898694..e523aeab 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java\n\n@@ -255,15 +257,18 @@ public class KafkaCruiseControl {\n   /**\n    * Get the cluster model cutting off at the current timestamp.\n    * @param requirements the model completeness requirements.\n-   * @param allowBrokerCapacityEstimation Whether allow broker capacity resolver to estimate broker capacity.\n+   * @param allowCapacityEstimation whether allow capacity estimation in cluster model if the underlying live broker capacity is unavailable.\n    * @param operationProgress the progress of the job to report.\n    * @return The cluster workload model.\n    * @throws NotEnoughValidWindowsException If there is not enough sample to generate cluster model.\n    * @throws TimeoutException If broker capacity resolver is unable to resolve broker capacity.\n+   * @throws BrokerCapacityResolvingException If broker capacity resolver fails to resolve broker capacity.\n    */\n-  public ClusterModel clusterModel(ModelCompletenessRequirements requirements, Boolean allowBrokerCapacityEstimation, OperationProgress operationProgress)\n-      throws NotEnoughValidWindowsException, TimeoutException {\n-    return _loadMonitor.clusterModel(timeMs(), requirements, allowBrokerCapacityEstimation, operationProgress);\n+  public ClusterModel clusterModel(ModelCompletenessRequirements requirements,\n+                                   boolean allowCapacityEstimation,\n+                                   OperationProgress operationProgress)\n+      throws NotEnoughValidWindowsException, TimeoutException, BrokerCapacityResolvingException {\n+    return _loadMonitor.clusterModel(timeMs(), requirements, allowCapacityEstimation, operationProgress);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyOTU3Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382329573", "bodyText": "Can we ensure that the JavaDoc indicates the expected return value if allowCapacityEstimation is false and the resolver fails to resolve the capacity?\n\nIf in this case the call throws an exception, I am not sure if TimeoutException would be the right one. Should it instead return an exception that extends from KafkaCruiseControlException -- e.g. CapacityResolutionException?\nAlternatively, (and maybe more preferably) the call can return a special BrokerCapacityInfo that indicates unresolvable broker capacity. The calling logic then identify this response, and use it in case it is acceptable to do so -- e.g. for dead broker capacity.", "author": "efeg", "createdAt": "2020-02-21T00:07:00Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java", "diffHunk": "@@ -30,8 +30,11 @@\n    * @param host The host of the broker\n    * @param brokerId The id of the broker\n    * @param timeoutMs The timeout in millisecond.\n+   * @param allowCapacityEstimation Whether allow resolver to estimate broker capacity if resolver is unable to get", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1OTU5Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382759592", "bodyText": "Discuss offline, we will create a new BrokerCapacityResolvingException type to represent capacity resolving failure.", "author": "kidkun", "createdAt": "2020-02-21T19:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyOTU3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java\nindex c298260b..284f8097 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java\n\n@@ -17,13 +17,6 @@ import java.util.concurrent.TimeoutException;\n public interface BrokerCapacityConfigResolver extends CruiseControlConfigurable, AutoCloseable {\n   /**\n    * Get the capacity of a broker based on rack, host and broker id.\n-   * The response must contain all the resources defined in {@link Resource}. The units for each resource are:\n-   * DISK - MegaBytes\n-   * CPU - Percentage (0 - 100)\n-   * Network Inbound - KB/s\n-   * Network Outbounds - KB/s\n-   *\n-   * The response also contains the number of CPU cores and may contain disk capacities by logDirs (i.e. for JBOD).\n    * May estimate the capacity of a broker, if it is not directly available.\n    *\n    * @param rack The rack of the broker\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMDQ1Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382330452", "bodyText": "The JavaDoc seems to describe the internals of BrokerCapacityInfo -- can we move the relevant information to the JavaDoc of BrokerCapacityInfo and refer to it from this JavaDoc via a link?", "author": "efeg", "createdAt": "2020-02-21T00:10:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java", "diffHunk": "@@ -30,8 +30,11 @@\n    * @param host The host of the broker\n    * @param brokerId The id of the broker\n    * @param timeoutMs The timeout in millisecond.\n+   * @param allowCapacityEstimation Whether allow resolver to estimate broker capacity if resolver is unable to get\n+   *                                capacity information of the broker.", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java\nindex c298260b..284f8097 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java\n\n@@ -17,13 +17,6 @@ import java.util.concurrent.TimeoutException;\n public interface BrokerCapacityConfigResolver extends CruiseControlConfigurable, AutoCloseable {\n   /**\n    * Get the capacity of a broker based on rack, host and broker id.\n-   * The response must contain all the resources defined in {@link Resource}. The units for each resource are:\n-   * DISK - MegaBytes\n-   * CPU - Percentage (0 - 100)\n-   * Network Inbound - KB/s\n-   * Network Outbounds - KB/s\n-   *\n-   * The response also contains the number of CPU cores and may contain disk capacities by logDirs (i.e. for JBOD).\n    * May estimate the capacity of a broker, if it is not directly available.\n    *\n    * @param rack The rack of the broker\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMjEzNA==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382332134", "bodyText": "[Applies globally] Can we use consistent (1) name and (2) JavaDoc description for this parameter across the code base -- i.e.\nname: allowBrokerCapacityEstimation -> allowCapacityEstimation?\ndoc: Allow capacity estimation in cluster model if the underlying live broker capacity is unavailable.", "author": "efeg", "createdAt": "2020-02-21T00:16:08Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java", "diffHunk": "@@ -255,14 +255,15 @@ public BrokerStats cachedBrokerLoadStats(boolean allowCapacityEstimation) {\n   /**\n    * Get the cluster model cutting off at the current timestamp.\n    * @param requirements the model completeness requirements.\n+   * @param allowBrokerCapacityEstimation Whether allow broker capacity resolver to estimate broker capacity.", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java\nindex 96898694..e523aeab 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java\n\n@@ -255,15 +257,18 @@ public class KafkaCruiseControl {\n   /**\n    * Get the cluster model cutting off at the current timestamp.\n    * @param requirements the model completeness requirements.\n-   * @param allowBrokerCapacityEstimation Whether allow broker capacity resolver to estimate broker capacity.\n+   * @param allowCapacityEstimation whether allow capacity estimation in cluster model if the underlying live broker capacity is unavailable.\n    * @param operationProgress the progress of the job to report.\n    * @return The cluster workload model.\n    * @throws NotEnoughValidWindowsException If there is not enough sample to generate cluster model.\n    * @throws TimeoutException If broker capacity resolver is unable to resolve broker capacity.\n+   * @throws BrokerCapacityResolvingException If broker capacity resolver fails to resolve broker capacity.\n    */\n-  public ClusterModel clusterModel(ModelCompletenessRequirements requirements, Boolean allowBrokerCapacityEstimation, OperationProgress operationProgress)\n-      throws NotEnoughValidWindowsException, TimeoutException {\n-    return _loadMonitor.clusterModel(timeMs(), requirements, allowBrokerCapacityEstimation, operationProgress);\n+  public ClusterModel clusterModel(ModelCompletenessRequirements requirements,\n+                                   boolean allowCapacityEstimation,\n+                                   OperationProgress operationProgress)\n+      throws NotEnoughValidWindowsException, TimeoutException, BrokerCapacityResolvingException {\n+    return _loadMonitor.clusterModel(timeMs(), requirements, allowCapacityEstimation, operationProgress);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNTY0Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382335643", "bodyText": "Can we avoid passing a local variable to a method of this class?", "author": "efeg", "createdAt": "2020-02-21T00:29:01Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java", "diffHunk": "@@ -151,28 +152,35 @@\n   private static final String NUM_CORES_CONFIG = \"num.cores\";\n   public static final double DEFAULT_CPU_CAPACITY_WITH_CORES = 100.0;\n   private static Map<Integer, BrokerCapacityInfo> _capacitiesForBrokers;\n+  private String _configFile;\n \n   @Override\n   public void configure(Map<String, ?> configs) {\n-    String configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n+    _configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n     try {\n-      loadCapacities(configFile);\n+      loadCapacities(_configFile);", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\nindex a54761d3..e121acb9 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\n\n@@ -156,9 +156,10 @@ public class BrokerCapacityConfigFileResolver implements BrokerCapacityConfigRes\n \n   @Override\n   public void configure(Map<String, ?> configs) {\n-    _configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n+    String configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n+    _configFile = configFile;\n     try {\n-      loadCapacities(_configFile);\n+      loadCapacities(configFile);\n     } catch (FileNotFoundException e) {\n       throw new IllegalArgumentException(e);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNjI0Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382336243", "bodyText": "Either allow capacity estimation -> in this case, shouldn't the users also ensure that the broker has a default capacity as defined via broker id -1?", "author": "efeg", "createdAt": "2020-02-21T00:31:13Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java", "diffHunk": "@@ -151,28 +152,35 @@\n   private static final String NUM_CORES_CONFIG = \"num.cores\";\n   public static final double DEFAULT_CPU_CAPACITY_WITH_CORES = 100.0;\n   private static Map<Integer, BrokerCapacityInfo> _capacitiesForBrokers;\n+  private String _configFile;\n \n   @Override\n   public void configure(Map<String, ?> configs) {\n-    String configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n+    _configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n     try {\n-      loadCapacities(configFile);\n+      loadCapacities(_configFile);\n     } catch (FileNotFoundException e) {\n       throw new IllegalArgumentException(e);\n     }\n   }\n \n   @Override\n-  public BrokerCapacityInfo capacityForBroker(String rack, String host, int brokerId, long timeoutMs) {\n+  public BrokerCapacityInfo capacityForBroker(String rack, String host, int brokerId, long timeoutMs, boolean allowCapacityEstimation)\n+      throws TimeoutException {\n     if (brokerId >= 0) {\n       BrokerCapacityInfo capacity = _capacitiesForBrokers.get(brokerId);\n       if (capacity != null) {\n         return capacity;\n       } else {\n-        String info = String.format(\"Missing broker id(%d) in capacity config file.\", brokerId);\n-        return new BrokerCapacityInfo(_capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).capacity(), info,\n-                                      _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).diskCapacityByLogDir(),\n-                                      _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).numCpuCores());\n+        if (allowCapacityEstimation) {\n+          String info = String.format(\"Missing broker id(%d) in capacity config file.\", brokerId);\n+          return new BrokerCapacityInfo(_capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).capacity(), info,\n+                                        _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).diskCapacityByLogDir(),\n+                                        _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).numCpuCores());\n+        } else {\n+          throw new TimeoutException(String.format(\"Unable to resolve capacity of broker %d. Either allow capacity estimation \"", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\nindex a54761d3..e121acb9 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\n\n@@ -156,9 +156,10 @@ public class BrokerCapacityConfigFileResolver implements BrokerCapacityConfigRes\n \n   @Override\n   public void configure(Map<String, ?> configs) {\n-    _configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n+    String configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n+    _configFile = configFile;\n     try {\n-      loadCapacities(_configFile);\n+      loadCapacities(configFile);\n     } catch (FileNotFoundException e) {\n       throw new IllegalArgumentException(e);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1NTIzOA==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382355238", "bodyText": "Shouldn't this logic be handled in this layer?  -- i.e. why don't we pass allowBrokerCapacityEstimation rather than aliveBrokers.contains(replica.id()) && allowBrokerCapacityEstimation?\n(please see the previous comment on potentially returning a special broker capacity response for unresolveable broker capacity).", "author": "efeg", "createdAt": "2020-02-21T01:41:17Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -463,7 +465,9 @@ static void populatePartitionLoad(Cluster cluster,\n         String rack = getRackHandleNull(replica);\n         BrokerCapacityInfo brokerCapacity;\n         try {\n-          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n+          // Do not allow capacity estimation for dead brokers.\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS,\n+                                                                          aliveBrokers.contains(replica.id()) && allowBrokerCapacityEstimation);", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\nindex 340be538..e99f62f6 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n\n@@ -467,8 +469,8 @@ public class MonitorUtils {\n         try {\n           // Do not allow capacity estimation for dead brokers.\n           brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS,\n-                                                                          aliveBrokers.contains(replica.id()) && allowBrokerCapacityEstimation);\n-        } catch (TimeoutException tme) {\n+                                                                          aliveBrokers.contains(replica.id()) && allowCapacityEstimation);\n+        } catch (TimeoutException | BrokerCapacityResolvingException e) {\n           // Capacity resolver may not be able to return the capacity information of dead brokers.\n           if (!aliveBrokers.contains(replica.id())) {\n             brokerCapacity = new BrokerCapacityInfo(EMPTY_BROKER_CAPACITY);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1NjE3Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382356177", "bodyText": "Not sure if TimeoutException is correct/sufficient exception here in case the capacity cannot be resolved due to not allowing CPU capacity estimation.", "author": "efeg", "createdAt": "2020-02-21T01:45:19Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java", "diffHunk": "@@ -82,9 +82,9 @@ private void updateCachedNumCoresByBroker(Cluster cluster) {\n         }\n         try {\n           BrokerCapacityInfo capacity =\n-              _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid, BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n-          // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n-          return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+              _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid, BROKER_CAPACITY_FETCH_TIMEOUT_MS,\n+                                                              _allowCpuCapacityEstimation);\n+          return capacity.numCpuCores();", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java\nindex 3854c0ee..866141a4 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java\n\n@@ -84,9 +85,9 @@ public class CruiseControlMetricsProcessor {\n           BrokerCapacityInfo capacity =\n               _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid, BROKER_CAPACITY_FETCH_TIMEOUT_MS,\n                                                               _allowCpuCapacityEstimation);\n-          return capacity.numCpuCores();\n-        } catch (TimeoutException tme) {\n-          LOG.warn(\"Unable to get number of CPU cores for broker {}.\", node.id(), tme);\n+          return capacity == null ? null : capacity.numCpuCores();\n+        } catch (TimeoutException | BrokerCapacityResolvingException e) {\n+          LOG.warn(\"Unable to get number of CPU cores for broker {}.\", node.id(), e);\n           return null;\n         }\n       });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1NzM4OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382357389", "bodyText": "Can we add the relevant test cases to ensure correct functionality when allow capacity estimation is false and the capacity cannot be resolved for (1) dead brokers and (2) alive brokers?", "author": "efeg", "createdAt": "2020-02-21T01:49:26Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolverTest.java", "diffHunk": "@@ -35,52 +35,52 @@ private static BrokerCapacityConfigResolver getBrokerCapacityConfigResolver(Stri\n   public void testParseConfigFile() throws TimeoutException {\n     BrokerCapacityConfigResolver configResolver = getBrokerCapacityConfigResolver(\"testCapacityConfig.json\", this.getClass());\n \n-    assertEquals(200000.0, configResolver.capacityForBroker(\"\", \"\", 0, BROKER_CAPACITY_FETCH_TIMEOUT_MS)\n+    assertEquals(200000.0, configResolver.capacityForBroker(\"\", \"\", 0, BROKER_CAPACITY_FETCH_TIMEOUT_MS, false)", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolverTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolverTest.java\nindex 77ac8a23..c316d405 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolverTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolverTest.java\n\n@@ -31,8 +32,8 @@ public class BrokerCapacityConfigFileResolverTest {\n     return configResolver;\n   }\n \n-  @Test\n-  public void testParseConfigFile() throws TimeoutException {\n+  @Test(expected = BrokerCapacityResolvingException.class)\n+  public void testParseConfigFile() throws TimeoutException, BrokerCapacityResolvingException {\n     BrokerCapacityConfigResolver configResolver = getBrokerCapacityConfigResolver(\"testCapacityConfig.json\", this.getClass());\n \n     assertEquals(200000.0, configResolver.capacityForBroker(\"\", \"\", 0, BROKER_CAPACITY_FETCH_TIMEOUT_MS, false)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1Nzg1Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382357856", "bodyText": "Can we verify (via test cases) that the anomaly detectors behave as expected if capacity estimation is disabled (i.e. the default behavior) and capacity resolver cannot resolve capacity of (1) dead brokers, (2) alive brokers, and (3) a mix of dead/alive brokers.", "author": "efeg", "createdAt": "2020-02-21T01:51:19Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetectorTest.java", "diffHunk": "@@ -293,7 +293,7 @@ private void testFixAnomaly(AnomalyType anomalyType)\n       EasyMock.expect(mockAnomalyNotifier.onGoalViolation(EasyMock.isA(GoalViolations.class))).andReturn(AnomalyNotificationResult.fix());\n     } else if (anomalyType == KafkaAnomalyType.DISK_FAILURE) {\n       ClusterModel singleBrokerWithBadDisk = singleBrokerWithBadDisk();\n-      EasyMock.expect(mockKafkaCruiseControl.clusterModel(EasyMock.anyObject(), EasyMock.anyObject())).andReturn(singleBrokerWithBadDisk);\n+      EasyMock.expect(mockKafkaCruiseControl.clusterModel(EasyMock.anyObject(), EasyMock.anyObject(), EasyMock.anyObject())).andReturn(singleBrokerWithBadDisk);", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgwNTkyOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382805929", "bodyText": "I feel these scenario is specific to LoadMonitor, I prefer to add check in LoadMonitorTest, this test should focus on how detector react to different anomalies.", "author": "kidkun", "createdAt": "2020-02-21T21:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1Nzg1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3b3fe9b180220c58c210f3735e1fe73161c6cfc6", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetectorTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetectorTest.java\nindex 6efb7131..b10586ab 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetectorTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetectorTest.java\n\n@@ -288,7 +312,7 @@ public class AnomalyDetectorTest {\n                                               EasyMock.eq(null),\n                                               EasyMock.eq(false),\n                                               EasyMock.anyString(),\n-                                              EasyMock.anyString());\n+                                              EasyMock.anyObject());\n \n       EasyMock.expect(mockAnomalyNotifier.onGoalViolation(EasyMock.isA(GoalViolations.class))).andReturn(AnomalyNotificationResult.fix());\n     } else if (anomalyType == KafkaAnomalyType.DISK_FAILURE) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1ODI1MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382358251", "bodyText": "Should we add test cases for allow capacity is false for load monitor?", "author": "efeg", "createdAt": "2020-02-21T01:52:54Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitorTest.java", "diffHunk": "@@ -250,6 +250,7 @@ public void testBasicClusterModel() throws NotEnoughValidWindowsException, Timeo\n \n     ClusterModel clusterModel = loadMonitor.clusterModel(-1, Long.MAX_VALUE,\n                                                          new ModelCompletenessRequirements(2, 1.0, false),\n+                                                         true,", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitorTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitorTest.java\nindex 79af684c..11288845 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitorTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitorTest.java\n\n@@ -250,7 +264,7 @@ public class LoadMonitorTest {\n \n     ClusterModel clusterModel = loadMonitor.clusterModel(-1, Long.MAX_VALUE,\n                                                          new ModelCompletenessRequirements(2, 1.0, false),\n-                                                         true,\n+                                                         allowCapacityEstimation,\n                                                          new OperationProgress());\n     assertEquals(6.5, clusterModel.partition(T0P0).leader().load().expectedUtilizationFor(Resource.CPU), 0.0);\n     assertEquals(13, clusterModel.partition(T0P0).leader().load().expectedUtilizationFor(Resource.NW_IN), 0.0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1OTE0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382359142", "bodyText": "Getting a TimeoutException here seems a little non-intuitive -- should we adopt one of the approaches in the previous discussion?", "author": "efeg", "createdAt": "2020-02-21T01:56:31Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessorTest.java", "diffHunk": "@@ -129,8 +130,8 @@ public void testWithCpuCapacityEstimation() throws TimeoutException {\n     // All estimated.\n     BrokerCapacityConfigResolver brokerCapacityConfigResolverAllEstimated = EasyMock.mock(BrokerCapacityConfigResolver.class);\n     EasyMock.expect(brokerCapacityConfigResolverAllEstimated.capacityForBroker(EasyMock.anyString(), EasyMock.anyString(),\n-                                                                               EasyMock.anyInt(), EasyMock.anyLong()))\n-            .andReturn(new BrokerCapacityInfo(EMPTY_BROKER_CAPACITY, \"All estimated\", Collections.emptyMap(), MOCK_NUM_CPU_CORES)).anyTimes();\n+                                                                               EasyMock.anyInt(), EasyMock.anyLong(), EasyMock.eq(false)))\n+            .andThrow(new TimeoutException(\"Unable to resolve capacity.\")).anyTimes();", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessorTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessorTest.java\nindex 32058b1f..495ecb5b 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessorTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessorTest.java\n\n@@ -125,13 +126,13 @@ public class CruiseControlMetricsProcessorTest {\n   }\n \n   @Test\n-  public void testWithCpuCapacityEstimation() throws TimeoutException {\n+  public void testWithCpuCapacityEstimation() throws TimeoutException, BrokerCapacityResolvingException {\n     Set<CruiseControlMetric> metrics = getCruiseControlMetrics();\n     // All estimated.\n     BrokerCapacityConfigResolver brokerCapacityConfigResolverAllEstimated = EasyMock.mock(BrokerCapacityConfigResolver.class);\n     EasyMock.expect(brokerCapacityConfigResolverAllEstimated.capacityForBroker(EasyMock.anyString(), EasyMock.anyString(),\n                                                                                EasyMock.anyInt(), EasyMock.anyLong(), EasyMock.eq(false)))\n-            .andThrow(new TimeoutException(\"Unable to resolve capacity.\")).anyTimes();\n+            .andThrow(new BrokerCapacityResolvingException(\"Unable to resolve capacity.\")).anyTimes();\n     EasyMock.replay(brokerCapacityConfigResolverAllEstimated);\n \n     CruiseControlMetricsProcessor processor = new CruiseControlMetricsProcessor(brokerCapacityConfigResolverAllEstimated, false);\n"}}, {"oid": "3b3fe9b180220c58c210f3735e1fe73161c6cfc6", "url": "https://github.com/linkedin/cruise-control/commit/3b3fe9b180220c58c210f3735e1fe73161c6cfc6", "message": "Improve broker capacity estimation.", "committedDate": "2020-02-21T23:36:09Z", "type": "commit"}, {"oid": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "url": "https://github.com/linkedin/cruise-control/commit/edea6da765dc7e1c227086175da9ff1cf1dbd14f", "message": "Address the feedback.", "committedDate": "2020-02-21T23:36:09Z", "type": "commit"}, {"oid": "751e4f26076b5a8edd8f0ca9a538230d1f01feb5", "url": "https://github.com/linkedin/cruise-control/commit/751e4f26076b5a8edd8f0ca9a538230d1f01feb5", "message": "Fix build failure.", "committedDate": "2020-02-21T23:36:09Z", "type": "commit"}, {"oid": "751e4f26076b5a8edd8f0ca9a538230d1f01feb5", "url": "https://github.com/linkedin/cruise-control/commit/751e4f26076b5a8edd8f0ca9a538230d1f01feb5", "message": "Fix build failure.", "committedDate": "2020-02-21T23:36:09Z", "type": "forcePushed"}, {"oid": "34ce3f6af2f599682715c2e89a0b21c6b5ce0e88", "url": "https://github.com/linkedin/cruise-control/commit/34ce3f6af2f599682715c2e89a0b21c6b5ce0e88", "message": "Fix build failue.", "committedDate": "2020-02-21T23:41:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3OTcxMw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383579713", "bodyText": "(Applies globally to the similar usages in JavaDoc) TimeoutException is underdefined.", "author": "efeg", "createdAt": "2020-02-24T23:41:42Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java", "diffHunk": "@@ -256,15 +257,18 @@ public BrokerStats cachedBrokerLoadStats(boolean allowCapacityEstimation) {\n   /**\n    * Get the cluster model cutting off at the current timestamp.\n    * @param requirements the model completeness requirements.\n-   * @param allowBrokerCapacityEstimation Whether allow broker capacity resolver to estimate broker capacity.\n+   * @param allowCapacityEstimation whether allow capacity estimation in cluster model if the underlying live broker capacity is unavailable.\n    * @param operationProgress the progress of the job to report.\n    * @return The cluster workload model.\n    * @throws NotEnoughValidWindowsException If there is not enough sample to generate cluster model.\n    * @throws TimeoutException If broker capacity resolver is unable to resolve broker capacity.\n+   * @throws BrokerCapacityResolvingException If broker capacity resolver fails to resolve broker capacity.", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "561185e8db4da8d44b1958202495249c5ed11c96", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java\nindex e523aeab..a6b57685 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java\n\n@@ -261,13 +261,13 @@ public class KafkaCruiseControl {\n    * @param operationProgress the progress of the job to report.\n    * @return The cluster workload model.\n    * @throws NotEnoughValidWindowsException If there is not enough sample to generate cluster model.\n-   * @throws TimeoutException If broker capacity resolver is unable to resolve broker capacity.\n-   * @throws BrokerCapacityResolvingException If broker capacity resolver fails to resolve broker capacity.\n+   * @throws TimeoutException If broker capacity resolver is unable to resolve broker capacity in time.\n+   * @throws BrokerCapacityResolutionException If broker capacity resolver fails to resolve broker capacity.\n    */\n   public ClusterModel clusterModel(ModelCompletenessRequirements requirements,\n                                    boolean allowCapacityEstimation,\n                                    OperationProgress operationProgress)\n-      throws NotEnoughValidWindowsException, TimeoutException, BrokerCapacityResolvingException {\n+      throws NotEnoughValidWindowsException, TimeoutException, BrokerCapacityResolutionException {\n     return _loadMonitor.clusterModel(timeMs(), requirements, allowCapacityEstimation, operationProgress);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MTk2NA==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383591964", "bodyText": "Nit: %d.Either -> %d. Either", "author": "efeg", "createdAt": "2020-02-25T00:21:00Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java", "diffHunk": "@@ -178,8 +179,9 @@ public BrokerCapacityInfo capacityForBroker(String rack, String host, int broker\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).diskCapacityByLogDir(),\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).numCpuCores());\n         } else {\n-          throw new TimeoutException(String.format(\"Unable to resolve capacity of broker %d. Either allow capacity estimation \"\n-                                                   + \"or add broker's capacity information in file %s.\", brokerId, _configFile));\n+          throw new BrokerCapacityResolvingException(String.format(\"Unable to resolve capacity of broker %d.Either (1) adding the \"", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "561185e8db4da8d44b1958202495249c5ed11c96", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\nindex e121acb9..98afafce 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\n\n@@ -179,8 +178,8 @@ public class BrokerCapacityConfigFileResolver implements BrokerCapacityConfigRes\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).diskCapacityByLogDir(),\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).numCpuCores());\n         } else {\n-          throw new BrokerCapacityResolvingException(String.format(\"Unable to resolve capacity of broker %d.Either (1) adding the \"\n-              + \"default broker capacity (via adding capacity for broker %d and allowing capacity estimation or (2) add missing \"\n+          throw new BrokerCapacityResolutionException(String.format(\"Unable to resolve capacity of broker %d. Either (1) adding the \"\n+              + \"default broker capacity (via adding capacity for broker %d and allowing capacity estimation) or (2) adding missing \"\n               + \"broker's capacity in file %s.\", brokerId, DEFAULT_CAPACITY_BROKER_ID, _configFile));\n         }\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjE4OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383592189", "bodyText": "Missing closing parenthesis.", "author": "efeg", "createdAt": "2020-02-25T00:21:39Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java", "diffHunk": "@@ -178,8 +179,9 @@ public BrokerCapacityInfo capacityForBroker(String rack, String host, int broker\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).diskCapacityByLogDir(),\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).numCpuCores());\n         } else {\n-          throw new TimeoutException(String.format(\"Unable to resolve capacity of broker %d. Either allow capacity estimation \"\n-                                                   + \"or add broker's capacity information in file %s.\", brokerId, _configFile));\n+          throw new BrokerCapacityResolvingException(String.format(\"Unable to resolve capacity of broker %d.Either (1) adding the \"\n+              + \"default broker capacity (via adding capacity for broker %d and allowing capacity estimation or (2) add missing \"", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "561185e8db4da8d44b1958202495249c5ed11c96", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\nindex e121acb9..98afafce 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\n\n@@ -179,8 +178,8 @@ public class BrokerCapacityConfigFileResolver implements BrokerCapacityConfigRes\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).diskCapacityByLogDir(),\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).numCpuCores());\n         } else {\n-          throw new BrokerCapacityResolvingException(String.format(\"Unable to resolve capacity of broker %d.Either (1) adding the \"\n-              + \"default broker capacity (via adding capacity for broker %d and allowing capacity estimation or (2) add missing \"\n+          throw new BrokerCapacityResolutionException(String.format(\"Unable to resolve capacity of broker %d. Either (1) adding the \"\n+              + \"default broker capacity (via adding capacity for broker %d and allowing capacity estimation) or (2) adding missing \"\n               + \"broker's capacity in file %s.\", brokerId, DEFAULT_CAPACITY_BROKER_ID, _configFile));\n         }\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjY5Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383592696", "bodyText": "Inconsistent use of add and adding\nshould we reformat it as -> Either add (1) XXX, or (2) YYY.", "author": "efeg", "createdAt": "2020-02-25T00:23:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java", "diffHunk": "@@ -178,8 +179,9 @@ public BrokerCapacityInfo capacityForBroker(String rack, String host, int broker\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).diskCapacityByLogDir(),\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).numCpuCores());\n         } else {\n-          throw new TimeoutException(String.format(\"Unable to resolve capacity of broker %d. Either allow capacity estimation \"\n-                                                   + \"or add broker's capacity information in file %s.\", brokerId, _configFile));\n+          throw new BrokerCapacityResolvingException(String.format(\"Unable to resolve capacity of broker %d.Either (1) adding the \"", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "561185e8db4da8d44b1958202495249c5ed11c96", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\nindex e121acb9..98afafce 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\n\n@@ -179,8 +178,8 @@ public class BrokerCapacityConfigFileResolver implements BrokerCapacityConfigRes\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).diskCapacityByLogDir(),\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).numCpuCores());\n         } else {\n-          throw new BrokerCapacityResolvingException(String.format(\"Unable to resolve capacity of broker %d.Either (1) adding the \"\n-              + \"default broker capacity (via adding capacity for broker %d and allowing capacity estimation or (2) add missing \"\n+          throw new BrokerCapacityResolutionException(String.format(\"Unable to resolve capacity of broker %d. Either (1) adding the \"\n+              + \"default broker capacity (via adding capacity for broker %d and allowing capacity estimation) or (2) adding missing \"\n               + \"broker's capacity in file %s.\", brokerId, DEFAULT_CAPACITY_BROKER_ID, _configFile));\n         }\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5Mjg1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383592850", "bodyText": "Nit: -> An instance", "author": "efeg", "createdAt": "2020-02-25T00:23:52Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java", "diffHunk": "@@ -32,9 +25,10 @@\n    * @param timeoutMs The timeout in millisecond.\n    * @param allowCapacityEstimation Whether allow resolver to estimate broker capacity if resolver is unable to get\n    *                                capacity information of the broker.\n-   * @return The capacity of each resource for the broker\n+   * @return A instance of {@link BrokerCapacityInfo}.", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "561185e8db4da8d44b1958202495249c5ed11c96", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java\nindex 284f8097..6e9a6d8f 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java\n\n@@ -25,10 +25,10 @@ public interface BrokerCapacityConfigResolver extends CruiseControlConfigurable,\n    * @param timeoutMs The timeout in millisecond.\n    * @param allowCapacityEstimation Whether allow resolver to estimate broker capacity if resolver is unable to get\n    *                                capacity information of the broker.\n-   * @return A instance of {@link BrokerCapacityInfo}.\n+   * @return An instance of {@link BrokerCapacityInfo}.\n    * @throws TimeoutException if resolver is unable to resolve broker capacity in time.\n-   * @throws BrokerCapacityResolvingException if resolver fails to resolve broker capacity.\n+   * @throws BrokerCapacityResolutionException if resolver fails to resolve broker capacity.\n    */\n   BrokerCapacityInfo capacityForBroker(String rack, String host, int brokerId, long timeoutMs, boolean allowCapacityEstimation)\n-      throws TimeoutException, BrokerCapacityResolvingException;\n+      throws TimeoutException, BrokerCapacityResolutionException;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MzAwMw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383593003", "bodyText": "Nit: encapsulate -> encapsulating", "author": "efeg", "createdAt": "2020-02-25T00:24:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java", "diffHunk": "@@ -10,6 +10,17 @@\n import java.util.stream.Collectors;\n \n \n+/**\n+ * A class encapsulate the capacity information of a broker, which includes all the resources defined in {@link Resource}.", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "561185e8db4da8d44b1958202495249c5ed11c96", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java\nindex dce94e58..cb31c9e9 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java\n\n@@ -11,7 +11,7 @@ import java.util.stream.Collectors;\n \n \n /**\n- * A class encapsulate the capacity information of a broker, which includes all the resources defined in {@link Resource}.\n+ * A class encapsulating the capacity information of a broker, which includes all the resources defined in {@link Resource}.\n  *\n  * The units for each resource are:\n  * DISK - MegaBytes\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MzM5Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383593393", "bodyText": "Nit: BrokerCapacityResolvingException -> CapacityResolutionException or BrokerCapacityResolutionException", "author": "efeg", "createdAt": "2020-02-25T00:25:48Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/exception/BrokerCapacityResolvingException.java", "diffHunk": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.exception;\n+\n+/**\n+ * The exception indicating something went wrong during the broker capacity resolving.\n+ */\n+public class BrokerCapacityResolvingException extends KafkaCruiseControlException {", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "561185e8db4da8d44b1958202495249c5ed11c96", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/exception/BrokerCapacityResolvingException.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/exception/BrokerCapacityResolutionException.java\nsimilarity index 61%\nrename from cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/exception/BrokerCapacityResolvingException.java\nrename to cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/exception/BrokerCapacityResolutionException.java\nindex 06ce9391..651496df 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/exception/BrokerCapacityResolvingException.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/exception/BrokerCapacityResolutionException.java\n\n@@ -7,13 +7,13 @@ package com.linkedin.kafka.cruisecontrol.exception;\n /**\n  * The exception indicating something went wrong during the broker capacity resolving.\n  */\n-public class BrokerCapacityResolvingException extends KafkaCruiseControlException {\n+public class BrokerCapacityResolutionException extends KafkaCruiseControlException {\n \n-  public BrokerCapacityResolvingException(String message, Throwable cause) {\n+  public BrokerCapacityResolutionException(String message, Throwable cause) {\n     super(message, cause);\n   }\n \n-  public BrokerCapacityResolvingException(String message) {\n+  public BrokerCapacityResolutionException(String message) {\n     super(message);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5NDAwMA==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383594000", "bodyText": "Do we even need to create a new ArrayList in case allowCapacityEstimation is false?", "author": "efeg", "createdAt": "2020-02-25T00:27:42Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java", "diffHunk": "@@ -506,32 +510,34 @@ public ClusterModel clusterModel(long from,\n     final Timer.Context ctx = _clusterModelCreationTimer.time();\n     try {\n       // Create the racks and brokers.\n-      // Shuffle nodes before getting their capacity from the capacity resolver.\n-      // This enables a capacity resolver to estimate the capacity of the nodes, for which the capacity retrieval has\n-      // failed.\n+      // If broker capacity is allowed to estimate broker capacity, shuffle nodes before getting their capacity from the\n+      // capacity resolver. This is good for the capacity resolver to estimate the capacity of the nodes, for which the\n+      // capacity retrieval has failed.\n       // The use case for this estimation is that if the capacity of one of the nodes is not available (e.g. due to some\n       // 3rd party service issue), the capacity resolver may want to use the capacity of a peer node as the capacity for\n       // that node.\n       // To this end, Cruise Control handles the case that the first node is problematic so the capacity resolver does\n       // not have the chance to get the capacity for the other nodes.\n       // Shuffling the node order helps, as the problematic node is unlikely to always be the first node in the list.\n       List<Node> shuffledNodes = new ArrayList<>(cluster.nodes());", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "561185e8db4da8d44b1958202495249c5ed11c96", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\nindex 2db720cb..cc935f7f 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\n\n@@ -519,7 +519,7 @@ public class LoadMonitor {\n       // To this end, Cruise Control handles the case that the first node is problematic so the capacity resolver does\n       // not have the chance to get the capacity for the other nodes.\n       // Shuffling the node order helps, as the problematic node is unlikely to always be the first node in the list.\n-      List<Node> shuffledNodes = new ArrayList<>(cluster.nodes());\n+      List<Node> shuffledNodes = allowCapacityEstimation ? new ArrayList<>(cluster.nodes()) : cluster.nodes();\n       if (allowCapacityEstimation) {\n         Collections.shuffle(shuffledNodes);\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5NjEwNw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383596107", "bodyText": "Sorry if my previous comment was not clear -- let me rephrase my question:\n\nWhy are we passing a parameter to loadCapacities function? This is a local private function and we already have the value assigned to _configFile. Is it possible to modify loadCapacities to have no parameter and use _configFile in its implementation?", "author": "efeg", "createdAt": "2020-02-25T00:34:54Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java", "diffHunk": "@@ -156,17 +156,18 @@\n \n   @Override\n   public void configure(Map<String, ?> configs) {\n-    _configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n+    String configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n+    _configFile = configFile;\n     try {\n-      loadCapacities(_configFile);\n+      loadCapacities(configFile);", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "561185e8db4da8d44b1958202495249c5ed11c96", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\nindex e121acb9..98afafce 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java\n\n@@ -156,10 +156,9 @@ public class BrokerCapacityConfigFileResolver implements BrokerCapacityConfigRes\n \n   @Override\n   public void configure(Map<String, ?> configs) {\n-    String configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n-    _configFile = configFile;\n+    _configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n     try {\n-      loadCapacities(configFile);\n+      loadCapacities();\n     } catch (FileNotFoundException e) {\n       throw new IllegalArgumentException(e);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5NzIyNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383597225", "bodyText": "Nit: an BrokerCapacityResolvingException -> a BrokerCapacityResolvingException", "author": "efeg", "createdAt": "2020-02-25T00:38:53Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolverTest.java", "diffHunk": "@@ -48,10 +49,13 @@ public void testParseConfigFile() throws TimeoutException {\n \n     assertTrue(configResolver.capacityForBroker(\"\", \"\", 2, BROKER_CAPACITY_FETCH_TIMEOUT_MS, true).isEstimated());\n     assertTrue(configResolver.capacityForBroker(\"\", \"\", 2, BROKER_CAPACITY_FETCH_TIMEOUT_MS, true).estimationInfo().length() > 0);\n+\n+    // If resolver is unable to get broker capacity and not allowed to estimate, an BrokerCapacityResolvingException will be thrown.", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "561185e8db4da8d44b1958202495249c5ed11c96", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolverTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolverTest.java\nindex c316d405..1b6a42f9 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolverTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolverTest.java\n\n@@ -50,12 +50,12 @@ public class BrokerCapacityConfigFileResolverTest {\n     assertTrue(configResolver.capacityForBroker(\"\", \"\", 2, BROKER_CAPACITY_FETCH_TIMEOUT_MS, true).isEstimated());\n     assertTrue(configResolver.capacityForBroker(\"\", \"\", 2, BROKER_CAPACITY_FETCH_TIMEOUT_MS, true).estimationInfo().length() > 0);\n \n-    // If resolver is unable to get broker capacity and not allowed to estimate, an BrokerCapacityResolvingException will be thrown.\n+    // If resolver is unable to get broker capacity and not allowed to estimate, a BrokerCapacityResolutionException will be thrown.\n     configResolver.capacityForBroker(\"\", \"\", 2, BROKER_CAPACITY_FETCH_TIMEOUT_MS, false);\n   }\n \n   @Test\n-  public void testParseConfigJBODFile() throws TimeoutException, BrokerCapacityResolvingException {\n+  public void testParseConfigJBODFile() throws TimeoutException, BrokerCapacityResolutionException {\n     BrokerCapacityConfigResolver configResolver = getBrokerCapacityConfigResolver(\"testCapacityConfigJBOD.json\", this.getClass());\n \n     assertEquals(2000000.0, configResolver.capacityForBroker(\"\", \"\", 0, BROKER_CAPACITY_FETCH_TIMEOUT_MS, false)\n"}}, {"oid": "561185e8db4da8d44b1958202495249c5ed11c96", "url": "https://github.com/linkedin/cruise-control/commit/561185e8db4da8d44b1958202495249c5ed11c96", "message": "Address the feedback.", "committedDate": "2020-02-26T01:04:45Z", "type": "commit"}]}