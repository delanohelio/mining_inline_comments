{"pr_number": 1302, "pr_title": "Support stop ongoing executions with rollback", "pr_createdAt": "2020-08-05T04:06:50Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1302", "timeline": [{"oid": "6b7157f8b4b5f77394d4577c3f3c68d623edfe45", "url": "https://github.com/linkedin/cruise-control/commit/6b7157f8b4b5f77394d4577c3f3c68d623edfe45", "message": "Support stop ongoing executions with rollback", "committedDate": "2020-08-05T04:01:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2Mzg3NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1302#discussion_r465463875", "bodyText": "Prior to this patch, we act on STOP_EXECUTION  in other conditions but we handle that in this condition now. Is it intentional?", "author": "hzxa21", "createdAt": "2020-08-05T04:24:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -1333,16 +1334,21 @@ private int moveLeadershipInBatch() throws InterruptedException, ExecutionExcept\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Tasks in execution: {}\", inExecutionTasks());\n         }\n-        List<ExecutionTask> deadOrAbortingInterBrokerReplicaActions = new ArrayList<>();\n+        List<ExecutionTask> deadInterBrokerReplicaTasks = new ArrayList<>();\n+        List<ExecutionTask> stoppedInterBrokerReplicaTasks = new ArrayList<>();\n         List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n         boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n         for (ExecutionTask task : inExecutionTasks()) {\n           TopicPartition tp = task.proposal().topicPartition();\n-          if (_stopSignal.get() == FORCE_STOP_EXECUTION) {\n-            LOG.debug(\"Task {} is marked as dead to force execution to stop.\", task);\n+          if (_stopSignal.get() != NO_STOP_EXECUTION) {", "originalCommit": "6b7157f8b4b5f77394d4577c3f3c68d623edfe45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAxMzcwNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1302#discussion_r466013705", "bodyText": "Prior to this PR, only FORCE_STOP_EXECUTION (i.e. a force-stop execution request) had a special handling in this loop. Whereas, STOP_EXECUTION did not have any handling -- i.e. all tasks in execution were treated like any other in-progress tasks, and were being tracked until the completion (In pre Kafka 2.4.* versions, the role of STOP_EXECUTION was just avoid submitting a new batch of execution and wait for the completion of the ongoing batch).\nHowever, the current logic in the initial version of this patch was incomplete. More specifically, we should handle the rollback for gracefully stopped inter-broker replica reassignments. And also we should avoid running a rollback for force-stopped executions -- i.e. they are already handled without rollback.\nI updated the handling logic along with comments to explain the reasoning. Thanks for pointing this out!", "author": "efeg", "createdAt": "2020-08-05T21:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2Mzg3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2fc916bfe1fb6cef962f540b14bcabfee8a3ee63", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java\nindex 4d6f0d29..de021412 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java\n\n@@ -1335,19 +1335,26 @@ public class Executor {\n           LOG.debug(\"Tasks in execution: {}\", inExecutionTasks());\n         }\n         List<ExecutionTask> deadInterBrokerReplicaTasks = new ArrayList<>();\n-        List<ExecutionTask> stoppedInterBrokerReplicaTasks = new ArrayList<>();\n+        List<ExecutionTask> gracefullyStoppedInterBrokerReplicaTasks = new ArrayList<>();\n         List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n         boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n         for (ExecutionTask task : inExecutionTasks()) {\n           TopicPartition tp = task.proposal().topicPartition();\n-          if (_stopSignal.get() != NO_STOP_EXECUTION) {\n-            LOG.debug(\"Task {} is marked as dead to stop the execution.\", task);\n+          if (_stopSignal.get() == FORCE_STOP_EXECUTION\n+              || (_stopSignal.get() == STOP_EXECUTION && task.type() == INTER_BROKER_REPLICA_ACTION)) {\n+            // If the execution is (1) force-stopped or (2) gracefully-stopped during an ongoing inter-broker replica reassignment,\n+            // then the executor will not just silently wait for the completion if the current in-progress tasks. For the former\n+            // case, the executor will mark all in progress tasks as dead, cleanup the relevant reassignment zNodes, and then bounce\n+            // the controller (see ExecutionUtils#deleteZNodesToStopExecution). For the latter case, the executor will mark in\n+            // progress tasks as dead, and rollback the ongoing reassignment of gracefully stopped inter-broker replica reassignment.\n+            LOG.debug(\"Task {} is marked as dead to {}.\", task,\n+                      _stopSignal.get() == FORCE_STOP_EXECUTION ? \"force-stop the execution with a controller bounce\"\n+                                                                : \"gracefully-stop the execution with a rollback\");\n             finishedTasks.add(task);\n             stoppedTaskIds.add(task.executionId());\n             _executionTaskManager.markTaskDead(task);\n-            // Only add the dead tasks to execute if it is an inter-broker replica action.\n-            if (task.type() == INTER_BROKER_REPLICA_ACTION) {\n-              stoppedInterBrokerReplicaTasks.add(task);\n+            if (_stopSignal.get() == STOP_EXECUTION) {\n+              gracefullyStoppedInterBrokerReplicaTasks.add(task);\n             }\n           } else if (cluster.partition(tp) == null) {\n             // Handle topic deletion during the execution.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2OTU3Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1302#discussion_r465469577", "bodyText": "I am confused about the naming at the very beginning since the comment says \"Cancel/rollback ... tasks\" but we call submitReplicaReassignmentTasks here. When I look at the implementation  I realized that the task will be cancelled if it is in a DEAD state. Are the tasks in deadInterBrokerReplicaTasks and stoppedInterBrokerReplicaTasks all guaranteed to be in DEAD state?\nMaybe add more documentations here to make it clearer?", "author": "hzxa21", "createdAt": "2020-08-05T04:46:07Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -1358,42 +1364,76 @@ private int moveLeadershipInBatch() throws InterruptedException, ExecutionExcept\n             if (shouldReportSlowTasks) {\n               task.maybeReportExecutionTooSlow(_time.milliseconds(), slowTasksToReport);\n             }\n-            if (maybeMarkTaskAsDeadOrAborting(cluster, logDirInfoByTask, task, result)) {\n-              deadOrAbortingTaskIds.add(task.executionId());\n-              // Only add the dead or aborted tasks to execute if it is an inter-broker replica action.\n+            if (maybeMarkTaskAsDead(cluster, logDirInfoByTask, task, result)) {\n+              deadTaskIds.add(task.executionId());\n+              // Only add the dead tasks to execute if it is an inter-broker replica action.\n               if (task.type() == INTER_BROKER_REPLICA_ACTION) {\n-                deadOrAbortingInterBrokerReplicaActions.add(task);\n-              }\n-              // A dead or aborted task is considered as finished.\n-              if (task.state() == DEAD || task.state() == ABORTED) {\n-                finishedTasks.add(task);\n+                deadInterBrokerReplicaTasks.add(task);\n               }\n+              finishedTasks.add(task);\n             }\n           }\n         }\n         sendSlowExecutionAlert(slowTasksToReport);\n-        handleDeadOrAbortingReplicaActions(deadOrAbortingInterBrokerReplicaActions);\n+        handleDeadInterBrokerReplicaTasks(deadInterBrokerReplicaTasks, stoppedInterBrokerReplicaTasks);\n         updateOngoingExecutionState();\n       } while (!inExecutionTasks().isEmpty() && finishedTasks.isEmpty());\n \n       LOG.info(\"Finished tasks: {}.{}{}{}\", finishedTasks,\n-               forceStoppedTaskIds.isEmpty() ? \"\" : String.format(\". [Force-stopped: %s]\", forceStoppedTaskIds),\n+               stoppedTaskIds.isEmpty() ? \"\" : String.format(\". [Stopped: %s]\", stoppedTaskIds),\n                deletedTaskIds.isEmpty() ? \"\" : String.format(\". [Deleted: %s]\", deletedTaskIds),\n-               deadOrAbortingTaskIds.isEmpty() ? \"\" : String.format(\". [Dead/aborting: %s]\", deadOrAbortingTaskIds));\n+               deadTaskIds.isEmpty() ? \"\" : String.format(\". [Dead: %s]\", deadTaskIds));\n \n       return finishedTasks;\n     }\n \n-    private void handleDeadOrAbortingReplicaActions(List<ExecutionTask> deadOrAbortingInterBrokerReplicaActions)\n+    /**\n+     * Attempts to cancel/rollback the ongoing reassignment of dead/stopped inter-broker replica actions and stops the\n+     * execution if not already requested so by the user.\n+     *\n+     * If all dead tasks are due to stopped inter-broker replica tasks, it waits until the rollback is completed.\n+     * Otherwise, it will not wait for the actual rollback to complete to avoid being blocked on a potentially stuck\n+     * reassignment operation due to dead brokers in the cluster. If by the time the next execution is attempted, the\n+     * rollback is still in progress on Kafka server-side, the executor will detect the ongoing server-side execution\n+     * and will not start a new execution (see {@link #sanityCheckOngoingMovement}).\n+     *\n+     * @param deadInterBrokerReplicaTasks Inter-broker replica tasks that are marked as dead due to dead destination brokers.\n+     * @param stoppedInterBrokerReplicaTasks Inter-broker replica tasks that are marked as dead due to being stopped by user.\n+     */\n+    private void handleDeadInterBrokerReplicaTasks(List<ExecutionTask> deadInterBrokerReplicaTasks,\n+                                                   List<ExecutionTask> stoppedInterBrokerReplicaTasks)\n         throws InterruptedException, ExecutionException, TimeoutException {\n-      if (!deadOrAbortingInterBrokerReplicaActions.isEmpty()) {\n-        ExecutionUtils.submitReplicaReassignmentTasks(_adminClient, deadOrAbortingInterBrokerReplicaActions);\n+      List<ExecutionTask> tasksToCancel = new ArrayList<>(deadInterBrokerReplicaTasks);\n+      tasksToCancel.addAll(stoppedInterBrokerReplicaTasks);\n+\n+      if (!tasksToCancel.isEmpty()) {\n+        // Cancel/rollback reassignment of dead inter-broker replica tasks.\n+        ExecutionUtils.submitReplicaReassignmentTasks(_adminClient, tasksToCancel);", "originalCommit": "6b7157f8b4b5f77394d4577c3f3c68d623edfe45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAxMzY5Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1302#discussion_r466013693", "bodyText": "I added a sanity check along with expected to be ... phrase in the existing param in the JavaDoc.", "author": "efeg", "createdAt": "2020-08-05T21:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2OTU3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2fc916bfe1fb6cef962f540b14bcabfee8a3ee63", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java\nindex 4d6f0d29..de021412 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java\n\n@@ -1375,12 +1382,13 @@ public class Executor {\n           }\n         }\n         sendSlowExecutionAlert(slowTasksToReport);\n-        handleDeadInterBrokerReplicaTasks(deadInterBrokerReplicaTasks, stoppedInterBrokerReplicaTasks);\n+        handleDeadInterBrokerReplicaTasks(deadInterBrokerReplicaTasks, gracefullyStoppedInterBrokerReplicaTasks);\n         updateOngoingExecutionState();\n       } while (!inExecutionTasks().isEmpty() && finishedTasks.isEmpty());\n \n       LOG.info(\"Finished tasks: {}.{}{}{}\", finishedTasks,\n-               stoppedTaskIds.isEmpty() ? \"\" : String.format(\". [Stopped: %s]\", stoppedTaskIds),\n+               stoppedTaskIds.isEmpty() ? \"\" : String.format(\". [%sStopped: %s]\", _stopSignal.get() == FORCE_STOP_EXECUTION\n+                                                                                  ? \"Force-\" : \"\", stoppedTaskIds),\n                deletedTaskIds.isEmpty() ? \"\" : String.format(\". [Deleted: %s]\", deletedTaskIds),\n                deadTaskIds.isEmpty() ? \"\" : String.format(\". [Dead: %s]\", deadTaskIds));\n \n"}}, {"oid": "2fc916bfe1fb6cef962f540b14bcabfee8a3ee63", "url": "https://github.com/linkedin/cruise-control/commit/2fc916bfe1fb6cef962f540b14bcabfee8a3ee63", "message": "Address the feedback", "committedDate": "2020-08-05T21:35:00Z", "type": "forcePushed"}, {"oid": "e722d751e05faf6676aeb1f4fdd5ae3fc251be21", "url": "https://github.com/linkedin/cruise-control/commit/e722d751e05faf6676aeb1f4fdd5ae3fc251be21", "message": "Address the feedback", "committedDate": "2020-08-05T21:36:48Z", "type": "commit"}, {"oid": "e722d751e05faf6676aeb1f4fdd5ae3fc251be21", "url": "https://github.com/linkedin/cruise-control/commit/e722d751e05faf6676aeb1f4fdd5ae3fc251be21", "message": "Address the feedback", "committedDate": "2020-08-05T21:36:48Z", "type": "forcePushed"}]}