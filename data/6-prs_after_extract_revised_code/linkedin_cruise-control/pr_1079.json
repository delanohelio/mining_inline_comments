{"pr_number": 1079, "pr_title": "Add support to detect and self-heal inconsistent topic replication factor", "pr_createdAt": "2020-01-27T23:36:24Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1079", "timeline": [{"oid": "48f8f0f90e56869bc5bed19d04983bea8aba7f24", "url": "https://github.com/linkedin/cruise-control/commit/48f8f0f90e56869bc5bed19d04983bea8aba7f24", "message": "Add support to detect and self-heal inconsistent topic replication factor.", "committedDate": "2020-02-04T00:07:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyMTY1NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374421655", "bodyText": "Nit: Can we put these *AnomalyDetectionIntervalMs to a map per anomaly type?", "author": "efeg", "createdAt": "2020-02-04T00:44:23Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java", "diffHunk": "@@ -60,10 +60,12 @@\n   private final BrokerFailureDetector _brokerFailureDetector;\n   private final MetricAnomalyDetector _metricAnomalyDetector;\n   private final DiskFailureDetector _diskFailureDetector;\n+  private final TopicAnomalyDetector _topicAnomalyDetector;\n   private final ScheduledExecutorService _detectorScheduler;\n   private final long _goalViolationDetectionIntervalMs;\n   private final long _diskFailureDetectionIntervalMs;\n   private final long _metricAnomalyDetectionIntervalMs;\n+  private final long _topicAnomalyDetectionIntervalMs;", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java\nindex 53c8c82d..3d9775f6 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java\n\n@@ -62,10 +64,7 @@ public class AnomalyDetector {\n   private final DiskFailureDetector _diskFailureDetector;\n   private final TopicAnomalyDetector _topicAnomalyDetector;\n   private final ScheduledExecutorService _detectorScheduler;\n-  private final long _goalViolationDetectionIntervalMs;\n-  private final long _diskFailureDetectionIntervalMs;\n-  private final long _metricAnomalyDetectionIntervalMs;\n-  private final long _topicAnomalyDetectionIntervalMs;\n+  private final Map<KafkaAnomalyType, Long> _anomalyDetectionIntervalMsByType;\n   private final long _brokerFailureDetectionBackoffMs;\n   private final PriorityBlockingQueue<Anomaly> _anomalies;\n   private volatile boolean _shutdown;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNjI0NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374426245", "bodyText": "Can we be more verbose on what a topic anomaly means?", "author": "efeg", "createdAt": "2020-02-04T01:02:13Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomaly.java", "diffHunk": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.detector.AnomalyType;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType.TOPIC_ANOMALY;\n+\n+/**\n+ * The interface for a topic anomaly.", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomaly.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomaly.java\nindex e2f1aed9..9d9d972b 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomaly.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomaly.java\n\n@@ -10,6 +10,8 @@ import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyTyp\n \n /**\n  * The interface for a topic anomaly.\n+ * Topic anomaly refers to one or more topics are under an undesired state which may jeopardize data completeness or\n+ * cluster balanceness (e.g. topic having small replication factor or gigantic replicas).\n  */\n public abstract class TopicAnomaly extends KafkaAnomaly {\n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNzc0OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374427749", "bodyText": "The logic of this function seems to be commonly used by the other anomaly detectors. Is it possible to combine their common logic in a parameterized util function?", "author": "efeg", "createdAt": "2020-02-04T01:08:30Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyDetector.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.detector.Anomaly;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.MAX_METADATA_WAIT_MS;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.shouldSkipAnomalyDetection;\n+\n+/**\n+ * This class will be scheduled to periodically check if {@link TopicAnomalyFinder} identifies a topic anomaly.\n+ * An alert will be triggered if one of the desired topic property is not met.\n+ */\n+public class TopicAnomalyDetector implements Runnable {\n+  private static final Logger LOG = LoggerFactory.getLogger(TopicAnomalyDetector.class);\n+  private final Queue<Anomaly> _anomalies;\n+  private final KafkaCruiseControl _kafkaCruiseControl;\n+  private final List<TopicAnomalyFinder> _topicAnomalyFinders;\n+\n+  TopicAnomalyDetector(Queue<Anomaly> anomalies,\n+                       KafkaCruiseControl kafkaCruiseControl) {\n+    _anomalies = anomalies;\n+    _kafkaCruiseControl = kafkaCruiseControl;\n+    Map<String, Object> configWithCruiseControlObject = Collections.singletonMap(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG,\n+                                                                                 kafkaCruiseControl);\n+    _topicAnomalyFinders = kafkaCruiseControl.config().getConfiguredInstances(AnomalyDetectorConfig.TOPIC_ANOMALY_FINDER_CLASSES_CONFIG,\n+                                                                              TopicAnomalyFinder.class,\n+                                                                              configWithCruiseControlObject);\n+  }\n+\n+  /**\n+   * Skip topic anomaly detection if any of the following is true:\n+   * <ul>\n+   *  <li>There is offline replicas in the cluster, which means there is dead brokers/disks. In this case\n+   * {@link BrokerFailureDetector} or {@link DiskFailureDetector} should take care of the anomaly.</li>\n+   *  <li>{@link AnomalyDetectorUtils#shouldSkipAnomalyDetection(KafkaCruiseControl)} returns true.\n+   * </ul>\n+   *\n+   * @return True to skip topic anomaly detection based on the current state, false otherwise.\n+   */\n+  private boolean shouldSkipMetricAnomalyDetection() {", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyDetector.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyDetector.java\nindex 820a4196..24e1690a 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyDetector.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyDetector.java\n\n@@ -11,12 +11,10 @@ import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Queue;\n-import java.util.Set;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n-import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.MAX_METADATA_WAIT_MS;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.shouldSkipAnomalyDetection;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyODgxOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374428819", "bodyText": "Why is this a list -- i.e. what is the implied ordering of anomalies? If the ordering does not matter, can we avoid using a list?", "author": "efeg", "createdAt": "2020-02-04T01:12:40Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n+import java.util.List;\n+import org.apache.yetus.audience.InterfaceStability;\n+\n+\n+/**\n+ * The finder which checks topics against certain desired topic property to identify topic anomaly.\n+ */\n+@InterfaceStability.Evolving\n+public interface  TopicAnomalyFinder extends CruiseControlConfigurable {\n+\n+  /**\n+   * Get a list of topic anomalies for topics which are misconfigured or violate some desired property.\n+   * @return List of topic anomalies.\n+   */\n+  List<TopicAnomaly> topicAnomalies();", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java\nindex 6913293c..5ec0fbce 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java\n\n@@ -5,7 +5,7 @@\n package com.linkedin.kafka.cruisecontrol.detector;\n \n import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n-import java.util.List;\n+import java.util.Set;\n import org.apache.yetus.audience.InterfaceStability;\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMDQwMw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374430403", "bodyText": "Can we add explanation of the configs to the JavaDoc?", "author": "efeg", "createdAt": "2020-02-04T01:19:01Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\nindex 38686266..34c921cb 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n\n@@ -9,25 +9,32 @@ import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.apache.kafka.common.Cluster;\n import org.apache.kafka.common.PartitionInfo;\n \n-import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n-import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n \n \n /**\n  * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n+ *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n+ * </ul>\n  */\n public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n   public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n-  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n   public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n   public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n   public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMTM0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374431342", "bodyText": "Should this be a static function in some utils class with a corresponding unit test?", "author": "efeg", "createdAt": "2020-02-04T01:22:51Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType;\n+import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.UpdateTopicConfigurationRunnable;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.regex.Pattern;\n+\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getSelfHealingGoalNames;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.extractKafkaCruiseControlObjectFromConfig;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType.TOPIC_ANOMALY;\n+\n+\n+/**\n+ * Topics which contain at least one partition with replication factor not equal to the config value of\n+ * {@link com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder#SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}\n+ */\n+public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n+  protected Short _targetReplicationFactor;\n+  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected UpdateTopicConfigurationRunnable _updateTopicConfigurationRunnable;\n+\n+  @Override\n+  public boolean fix() throws Exception {\n+    _optimizationResult = _updateTopicConfigurationRunnable.getResult();\n+    boolean hasProposalsToFix = hasProposalsToFix();\n+    // Ensure that only the relevant response is cached to avoid memory pressure.\n+    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n+    return hasProposalsToFix;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    super.configure(configs);\n+    KafkaCruiseControl kafkaCruiseControl = extractKafkaCruiseControlObjectFromConfig(configs, KafkaAnomalyType.TOPIC_ANOMALY);\n+    KafkaCruiseControlConfig config = kafkaCruiseControl.config();\n+    _topicsWithBadReplicationFactor = (Set<String>) configs.get(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG);\n+    if (_topicsWithBadReplicationFactor == null || _topicsWithBadReplicationFactor.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\", TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG));\n+    }\n+    _targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    if (_targetReplicationFactor == null) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\",\n+                                                       SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG));\n+    }\n+    boolean allowCapacityEstimation = config.getBoolean(ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG);\n+    boolean excludeRecentlyDemotedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG);\n+    boolean excludeRecentlyRemovedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG);\n+    _updateTopicConfigurationRunnable = new UpdateTopicConfigurationRunnable(kafkaCruiseControl,\n+                                                                             Collections.singletonMap(_targetReplicationFactor,\n+                                                                                                      buildTopicRegex(_topicsWithBadReplicationFactor)),\n+                                                                             getSelfHealingGoalNames(config),\n+                                                                             allowCapacityEstimation,\n+                                                                             excludeRecentlyDemotedBrokers,\n+                                                                             excludeRecentlyRemovedBrokers,\n+                                                                             _anomalyId.toString(),\n+                                                                             String.format(\"Self healing for %s: %s\", TOPIC_ANOMALY, this));\n+\n+  }\n+\n+  private Pattern buildTopicRegex(Set<String> topics) {", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java\nindex 4508f968..ad3e5406 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java\n\n@@ -11,13 +11,12 @@ import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.UpdateTop\n import java.util.Collections;\n import java.util.Map;\n import java.util.Set;\n-import java.util.StringJoiner;\n-import java.util.regex.Pattern;\n \n import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getSelfHealingGoalNames;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.buildTopicRegex;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.extractKafkaCruiseControlObjectFromConfig;\n import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMzExNw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374433117", "bodyText": "I am curious why we need these parentheses? Aren't they redundant?", "author": "efeg", "createdAt": "2020-02-04T01:30:52Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType;\n+import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.UpdateTopicConfigurationRunnable;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.regex.Pattern;\n+\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getSelfHealingGoalNames;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.extractKafkaCruiseControlObjectFromConfig;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType.TOPIC_ANOMALY;\n+\n+\n+/**\n+ * Topics which contain at least one partition with replication factor not equal to the config value of\n+ * {@link com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder#SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}\n+ */\n+public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n+  protected Short _targetReplicationFactor;\n+  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected UpdateTopicConfigurationRunnable _updateTopicConfigurationRunnable;\n+\n+  @Override\n+  public boolean fix() throws Exception {\n+    _optimizationResult = _updateTopicConfigurationRunnable.getResult();\n+    boolean hasProposalsToFix = hasProposalsToFix();\n+    // Ensure that only the relevant response is cached to avoid memory pressure.\n+    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n+    return hasProposalsToFix;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    super.configure(configs);\n+    KafkaCruiseControl kafkaCruiseControl = extractKafkaCruiseControlObjectFromConfig(configs, KafkaAnomalyType.TOPIC_ANOMALY);\n+    KafkaCruiseControlConfig config = kafkaCruiseControl.config();\n+    _topicsWithBadReplicationFactor = (Set<String>) configs.get(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG);\n+    if (_topicsWithBadReplicationFactor == null || _topicsWithBadReplicationFactor.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\", TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG));\n+    }\n+    _targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    if (_targetReplicationFactor == null) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\",\n+                                                       SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG));\n+    }\n+    boolean allowCapacityEstimation = config.getBoolean(ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG);\n+    boolean excludeRecentlyDemotedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG);\n+    boolean excludeRecentlyRemovedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG);\n+    _updateTopicConfigurationRunnable = new UpdateTopicConfigurationRunnable(kafkaCruiseControl,\n+                                                                             Collections.singletonMap(_targetReplicationFactor,\n+                                                                                                      buildTopicRegex(_topicsWithBadReplicationFactor)),\n+                                                                             getSelfHealingGoalNames(config),\n+                                                                             allowCapacityEstimation,\n+                                                                             excludeRecentlyDemotedBrokers,\n+                                                                             excludeRecentlyRemovedBrokers,\n+                                                                             _anomalyId.toString(),\n+                                                                             String.format(\"Self healing for %s: %s\", TOPIC_ANOMALY, this));\n+\n+  }\n+\n+  private Pattern buildTopicRegex(Set<String> topics) {\n+    StringJoiner sj = new StringJoiner(\"|\");\n+    topics.forEach(sj::add);\n+    return Pattern.compile(\"(\" + sj.toString() + \")\");", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc0MTUwMg==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r376741502", "bodyText": "I think the syntax of regex is that \"(a|b|c)\" will match a or b or c.", "author": "kidkun", "createdAt": "2020-02-08T23:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMzExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MTQ0MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379191441", "bodyText": "The corresponding unit test seems to pass without parentheses, as well. Capturing group seems redundant.", "author": "efeg", "createdAt": "2020-02-14T00:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMzExNw=="}], "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java\nindex 4508f968..ad3e5406 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java\n\n@@ -11,13 +11,12 @@ import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.UpdateTop\n import java.util.Collections;\n import java.util.Map;\n import java.util.Set;\n-import java.util.StringJoiner;\n-import java.util.regex.Pattern;\n \n import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getSelfHealingGoalNames;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.buildTopicRegex;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.extractKafkaCruiseControlObjectFromConfig;\n import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMzUyMw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374433523", "bodyText": "The meaning of the following sentence is not clear: Detected follow topics...", "author": "efeg", "createdAt": "2020-02-04T01:32:45Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType;\n+import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.UpdateTopicConfigurationRunnable;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.regex.Pattern;\n+\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getSelfHealingGoalNames;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.extractKafkaCruiseControlObjectFromConfig;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType.TOPIC_ANOMALY;\n+\n+\n+/**\n+ * Topics which contain at least one partition with replication factor not equal to the config value of\n+ * {@link com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder#SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}\n+ */\n+public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n+  protected Short _targetReplicationFactor;\n+  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected UpdateTopicConfigurationRunnable _updateTopicConfigurationRunnable;\n+\n+  @Override\n+  public boolean fix() throws Exception {\n+    _optimizationResult = _updateTopicConfigurationRunnable.getResult();\n+    boolean hasProposalsToFix = hasProposalsToFix();\n+    // Ensure that only the relevant response is cached to avoid memory pressure.\n+    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n+    return hasProposalsToFix;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    super.configure(configs);\n+    KafkaCruiseControl kafkaCruiseControl = extractKafkaCruiseControlObjectFromConfig(configs, KafkaAnomalyType.TOPIC_ANOMALY);\n+    KafkaCruiseControlConfig config = kafkaCruiseControl.config();\n+    _topicsWithBadReplicationFactor = (Set<String>) configs.get(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG);\n+    if (_topicsWithBadReplicationFactor == null || _topicsWithBadReplicationFactor.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\", TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG));\n+    }\n+    _targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    if (_targetReplicationFactor == null) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\",\n+                                                       SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG));\n+    }\n+    boolean allowCapacityEstimation = config.getBoolean(ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG);\n+    boolean excludeRecentlyDemotedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG);\n+    boolean excludeRecentlyRemovedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG);\n+    _updateTopicConfigurationRunnable = new UpdateTopicConfigurationRunnable(kafkaCruiseControl,\n+                                                                             Collections.singletonMap(_targetReplicationFactor,\n+                                                                                                      buildTopicRegex(_topicsWithBadReplicationFactor)),\n+                                                                             getSelfHealingGoalNames(config),\n+                                                                             allowCapacityEstimation,\n+                                                                             excludeRecentlyDemotedBrokers,\n+                                                                             excludeRecentlyRemovedBrokers,\n+                                                                             _anomalyId.toString(),\n+                                                                             String.format(\"Self healing for %s: %s\", TOPIC_ANOMALY, this));\n+\n+  }\n+\n+  private Pattern buildTopicRegex(Set<String> topics) {\n+    StringJoiner sj = new StringJoiner(\"|\");\n+    topics.forEach(sj::add);\n+    return Pattern.compile(\"(\" + sj.toString() + \")\");\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"{Detected follow topics have at least one partition with replication factor other than \")", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java\nindex 4508f968..ad3e5406 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java\n\n@@ -11,13 +11,12 @@ import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.UpdateTop\n import java.util.Collections;\n import java.util.Map;\n import java.util.Set;\n-import java.util.StringJoiner;\n-import java.util.regex.Pattern;\n \n import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getSelfHealingGoalNames;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.buildTopicRegex;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.extractKafkaCruiseControlObjectFromConfig;\n import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNDMwNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374434305", "bodyText": "Can we avoid wildcard import?", "author": "efeg", "createdAt": "2020-02-04T01:36:01Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\nindex 38686266..34c921cb 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n\n@@ -9,25 +9,32 @@ import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.apache.kafka.common.Cluster;\n import org.apache.kafka.common.PartitionInfo;\n \n-import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n-import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n \n \n /**\n  * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n+ *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n+ * </ul>\n  */\n public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n   public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n-  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n   public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n   public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n   public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNTU3NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374435575", "bodyText": "This is a potentially disruptive config -- i.e. if the user forgets setting the value for the target self healing replication factor and enable self healing for all anomaly types, it may cause unintended changes in RF in clusters, where the intended RF != 3.\nTo avoid this scenario, should we make this a required config? -- i.e. we can have a sanity check that fails if the user does not provide a value for this config when this pluggable anomaly finder is used upon configuration time.", "author": "efeg", "createdAt": "2020-02-04T01:41:29Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc0MTc3OA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r376741778", "bodyText": "Good point!", "author": "kidkun", "createdAt": "2020-02-08T23:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNTU3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\nindex 38686266..34c921cb 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n\n@@ -9,25 +9,32 @@ import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.apache.kafka.common.Cluster;\n import org.apache.kafka.common.PartitionInfo;\n \n-import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n-import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n \n \n /**\n  * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n+ *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n+ * </ul>\n  */\n public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n   public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n-  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n   public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n   public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n   public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNjI1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374436250", "bodyText": "Can we define what each parameter corresponds to? c and t are not descriptive for a public util function.", "author": "efeg", "createdAt": "2020-02-04T01:44:27Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfigUtils.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.config;\n+\n+import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n+import java.util.Map;\n+\n+\n+public class KafkaCruiseControlConfigUtils {\n+\n+  private KafkaCruiseControlConfigUtils() {\n+\n+  }\n+\n+  /**\n+   * @return Configured instance.\n+   */\n+  public static <T> T getConfiguredInstance(Class<?> c, Class<T> t, Map<String, Object> configs) {", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfigUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfigUtils.java\nindex 13392019..463649ae 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfigUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfigUtils.java\n\n@@ -15,7 +15,13 @@ public class KafkaCruiseControlConfigUtils {\n   }\n \n   /**\n-   * @return Configured instance.\n+   * Get a configured instance of the given concrete class. If the object implements {@link CruiseControlConfigurable},\n+   * configure it using the configuration.\n+   *\n+   * @param c The concrete class of the returned instance\n+   * @param t The interface of the returned instance\n+   * @param configs Configuration to used to config the returned instance.\n+   * @return A configured instance of the class c\n    */\n   public static <T> T getConfiguredInstance(Class<?> c, Class<T> t, Map<String, Object> configs) {\n     Object instance;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNzQ4MA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374437480", "bodyText": "Shouldn't the second param be TopicAnomaly.class?", "author": "efeg", "createdAt": "2020-02-04T01:49:37Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public List<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singletonList(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                           _targetReplicationFactor));\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicReplicationFactorAnomaly.class, configs);", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\nindex 38686266..34c921cb 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n\n@@ -9,25 +9,32 @@ import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.apache.kafka.common.Cluster;\n import org.apache.kafka.common.PartitionInfo;\n \n-import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n-import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n \n \n /**\n  * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n+ *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n+ * </ul>\n  */\n public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n   public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n-  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n   public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n   public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n   public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODEwMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374438101", "bodyText": "I am curious why we prefer this method over KafkaCruiseControlConfig#getConfiguredInstance?", "author": "efeg", "createdAt": "2020-02-04T01:52:37Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public List<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singletonList(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                           _targetReplicationFactor));\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicReplicationFactorAnomaly.class, configs);", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc0MjUxNw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r376742517", "bodyText": "The issue with  KafkaCruiseControlConfig#getConfiguredInstance is that using this method you can only create object of one type of TopicAnomaly.\nImagine we are trying to that method, we will define a TOPIC_ANOMALY_CLASS_CONFIG config in AnomalyDetectorConfig , and lets's say we set the value of this config to be TopicReplicationFactorAnomaly.class.\nTopicReplicationFactorAnomalyFinder will work just fine.\nThen we are trying to add another TopicAnomalyFinder, TopicPartitionSizeAnomalyFinder and it is supposed to generate TopicPartitionSizeAnomaly, this finder is unable to generate anomaly object using KafkaCruiseControlConfig#getConfiguredInstance.", "author": "kidkun", "createdAt": "2020-02-09T00:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc0MjU4Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r376742586", "bodyText": "I think MeticAnomaly also has the same issue.", "author": "kidkun", "createdAt": "2020-02-09T00:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5OTU1MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379199551", "bodyText": "Shouldn't the *AnomalyFinder of a particular Anomaly Detector always generate the same type of anomalies?\n-- i.e. Shouldn't the generated anomaly type have an API to support any anomaly finders? If the anomaly type is missing certain functionalities, I think we should evolve its API. Note that in case of metric anomalies, we have SlowBrokers extending KafkaMetricAnomaly. Hence, the metric anomaly detector always returns an instance of KafkaMetricAnomaly as expected.", "author": "efeg", "createdAt": "2020-02-14T00:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODEwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\nindex 38686266..34c921cb 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n\n@@ -9,25 +9,32 @@ import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.apache.kafka.common.Cluster;\n import org.apache.kafka.common.PartitionInfo;\n \n-import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n-import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n \n \n /**\n  * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n+ *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n+ * </ul>\n  */\n public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n   public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n-  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n   public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n   public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n   public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODI5MA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374438290", "bodyText": "anomaly detector -> anomaly finder?", "author": "efeg", "createdAt": "2020-02-04T01:53:31Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public List<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singletonList(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                           _targetReplicationFactor));\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicReplicationFactorAnomaly.class, configs);\n+  }\n+\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    _kafkaCruiseControl = (KafkaCruiseControl) configs.get(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    if (_kafkaCruiseControl == null) {\n+      throw new IllegalArgumentException(\"Topic replication factor anomaly detector is missing \" + KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\nindex 38686266..34c921cb 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n\n@@ -9,25 +9,32 @@ import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.apache.kafka.common.Cluster;\n import org.apache.kafka.common.PartitionInfo;\n \n-import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n-import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n \n \n /**\n  * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n+ *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n+ * </ul>\n  */\n public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n   public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n-  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n   public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n   public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n   public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODg5Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374438897", "bodyText": "If we make this configurable, should we have a sanity check to make sure that this is an instance of TopicAnomaly for early failure?", "author": "efeg", "createdAt": "2020-02-04T01:56:20Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public List<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singletonList(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                           _targetReplicationFactor));\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicReplicationFactorAnomaly.class, configs);\n+  }\n+\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    _kafkaCruiseControl = (KafkaCruiseControl) configs.get(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    if (_kafkaCruiseControl == null) {\n+      throw new IllegalArgumentException(\"Topic replication factor anomaly detector is missing \" + KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    }\n+    Short targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    _targetReplicationFactor = targetReplicationFactor == null ? DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR\n+                                                               : _targetReplicationFactor;\n+    String topicExcludedFromCheck = (String) configs.get(TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK);\n+    _topicExcludedFromCheck = Pattern.compile(topicExcludedFromCheck == null ? DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK\n+                                                                             : topicExcludedFromCheck);\n+    String topicReplicationTopicAnomalyClass = (String) configs.get(TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG);\n+    if (topicReplicationTopicAnomalyClass == null) {\n+      _topicReplicationTopicAnomalyClass = DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS;", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\nindex 38686266..34c921cb 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n\n@@ -9,25 +9,32 @@ import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.apache.kafka.common.Cluster;\n import org.apache.kafka.common.PartitionInfo;\n \n-import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n-import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n \n \n /**\n  * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n+ *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n+ * </ul>\n  */\n public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n   public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n-  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n   public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n   public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n   public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MjEwMg==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374442102", "bodyText": "If all parameters are local, can we avoid passing them to the method of the same class (e.g. see RemoveBrokersRunnable#removeBrokers())?", "author": "efeg", "createdAt": "2020-02-04T02:11:05Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java", "diffHunk": "@@ -48,38 +57,107 @@\n  */\n public class UpdateTopicConfigurationRunnable extends OperationRunnable {\n   private static final Logger LOG = LoggerFactory.getLogger(UpdateTopicConfigurationRunnable.class);\n-  protected final TopicReplicationFactorChangeParameters _topicReplicationFactorChangeParameters;\n   protected final String _uuid;\n+  protected Map<Short, Pattern> _topicPatternByReplicationFactor;\n+  protected List<String> _goals;\n+  protected boolean _skipRackAwarenessCheck;\n+  protected ModelCompletenessRequirements _requirements;\n+  protected boolean _allowCapacityEstimation;\n+  protected Integer _concurrentInterBrokerPartitionMovements;\n+  protected Integer _concurrentLeaderMovements;\n+  protected Long _executionProgressCheckIntervalMs;\n+  protected boolean _skipHardGoalCheck;\n+  protected ReplicaMovementStrategy _replicaMovementStrategy;\n+  protected Long _replicationThrottle;\n+  protected boolean _excludeRecentlyDemotedBrokers;\n+  protected boolean _excludeRecentlyRemovedBrokers;\n+  protected boolean _dryRun;\n+  protected String _reason;\n+  protected boolean _stopOngoingExecution;\n+  protected boolean _isTriggeredByUserRequest;\n \n   public UpdateTopicConfigurationRunnable(KafkaCruiseControl kafkaCruiseControl,\n                                           OperationFuture future,\n                                           String uuid,\n                                           TopicConfigurationParameters parameters) {\n     super(kafkaCruiseControl, future);\n-    _topicReplicationFactorChangeParameters = parameters.topicReplicationFactorChangeParameters();\n+    TopicReplicationFactorChangeParameters topicReplicationFactorChangeParameters = parameters.topicReplicationFactorChangeParameters();\n+    if (topicReplicationFactorChangeParameters != null) {\n+      _topicPatternByReplicationFactor = topicReplicationFactorChangeParameters.topicPatternByReplicationFactor();\n+      _goals = topicReplicationFactorChangeParameters.goals();\n+      _skipRackAwarenessCheck = topicReplicationFactorChangeParameters.skipRackAwarenessCheck();\n+      _requirements = topicReplicationFactorChangeParameters.modelCompletenessRequirements();\n+      _allowCapacityEstimation = topicReplicationFactorChangeParameters.allowCapacityEstimation();\n+      _concurrentInterBrokerPartitionMovements = topicReplicationFactorChangeParameters.concurrentInterBrokerPartitionMovements();\n+      _concurrentLeaderMovements = topicReplicationFactorChangeParameters.concurrentLeaderMovements();\n+      _executionProgressCheckIntervalMs = topicReplicationFactorChangeParameters.executionProgressCheckIntervalMs();\n+      _skipHardGoalCheck = topicReplicationFactorChangeParameters.skipHardGoalCheck();\n+      _replicaMovementStrategy = topicReplicationFactorChangeParameters.replicaMovementStrategy();\n+      _replicationThrottle = topicReplicationFactorChangeParameters.replicationThrottle();\n+      _excludeRecentlyDemotedBrokers = topicReplicationFactorChangeParameters.excludeRecentlyDemotedBrokers();\n+      _excludeRecentlyRemovedBrokers = topicReplicationFactorChangeParameters.excludeRecentlyRemovedBrokers();\n+      _dryRun = topicReplicationFactorChangeParameters.dryRun();\n+      _reason = topicReplicationFactorChangeParameters.reason();\n+      _stopOngoingExecution = topicReplicationFactorChangeParameters.stopOngoingExecution();\n+      }\n     _uuid = uuid;\n+    _isTriggeredByUserRequest = true;\n   }\n \n+  /**\n+   * Constructor to be used for creating a runnable for self-healing.\n+   */\n+  public UpdateTopicConfigurationRunnable(KafkaCruiseControl kafkaCruiseControl,\n+                                          Map<Short, Pattern> topicPatternByReplicationFactor,\n+                                          List<String> selfHealingGoals,\n+                                          boolean allowCapacityEstimation,\n+                                          boolean excludeRecentlyDemotedBrokers,\n+                                          boolean excludeRecentlyRemovedBrokers,\n+                                          String anomalyId,\n+                                          String reason) {\n+    super(kafkaCruiseControl, new OperationFuture(\"Topic replication factor anomaly self-healing.\"));\n+    _topicPatternByReplicationFactor = topicPatternByReplicationFactor;\n+    _goals = selfHealingGoals;\n+    _skipRackAwarenessCheck = SELF_HEALING_SKIP_RACK_AWARENESS_CHECK;\n+    _requirements = SELF_HEALING_MODEL_COMPLETENESS_REQUIREMENTS;\n+    _allowCapacityEstimation = allowCapacityEstimation;\n+    _concurrentInterBrokerPartitionMovements = SELF_HEALING_CONCURRENT_MOVEMENTS;\n+    _concurrentLeaderMovements = SELF_HEALING_CONCURRENT_MOVEMENTS;\n+    _executionProgressCheckIntervalMs = SELF_HEALING_EXECUTION_PROGRESS_CHECK_INTERVAL_MS;\n+    _skipHardGoalCheck = SELF_HEALING_SKIP_HARD_GOAL_CHECK;\n+    _replicaMovementStrategy = SELF_HEALING_REPLICA_MOVEMENT_STRATEGY;\n+    _replicationThrottle = kafkaCruiseControl.config().getLong(ExecutorConfig.DEFAULT_REPLICATION_THROTTLE_CONFIG);\n+    _excludeRecentlyDemotedBrokers = excludeRecentlyDemotedBrokers;\n+    _excludeRecentlyRemovedBrokers = excludeRecentlyRemovedBrokers;\n+    _dryRun = SELF_HEALING_DRYRUN;\n+    _reason = reason;\n+    _stopOngoingExecution = SELF_HEALING_STOP_ONGOING_EXECUTION;\n+    _uuid = anomalyId;\n+    _isTriggeredByUserRequest = false;\n+  }\n+\n+\n   @Override\n-  protected OptimizationResult getResult() throws Exception {\n-    if (_topicReplicationFactorChangeParameters != null) {\n+  public OptimizationResult getResult() throws Exception {\n+    if (_topicPatternByReplicationFactor != null) {\n       return new OptimizationResult(\n-          updateTopicReplicationFactor(_topicReplicationFactorChangeParameters.topicPatternByReplicationFactor(),\n-                                       _topicReplicationFactorChangeParameters.goals(),\n-                                       _topicReplicationFactorChangeParameters.skipRackAwarenessCheck(),\n-                                       _topicReplicationFactorChangeParameters.modelCompletenessRequirements(),\n-                                       _topicReplicationFactorChangeParameters.allowCapacityEstimation(),\n-                                       _topicReplicationFactorChangeParameters.concurrentInterBrokerPartitionMovements(),\n-                                       _topicReplicationFactorChangeParameters.concurrentLeaderMovements(),\n-                                       _topicReplicationFactorChangeParameters.executionProgressCheckIntervalMs(),\n-                                       _topicReplicationFactorChangeParameters.skipHardGoalCheck(),\n-                                       _topicReplicationFactorChangeParameters.replicaMovementStrategy(),\n-                                       _topicReplicationFactorChangeParameters.replicationThrottle(),\n-                                       _topicReplicationFactorChangeParameters.excludeRecentlyDemotedBrokers(),\n-                                       _topicReplicationFactorChangeParameters.excludeRecentlyRemovedBrokers(),\n-                                       _topicReplicationFactorChangeParameters.dryRun(),\n-                                       _topicReplicationFactorChangeParameters.reason(),\n-                                       _topicReplicationFactorChangeParameters.stopOngoingExecution()),\n+          updateTopicReplicationFactor(_topicPatternByReplicationFactor,", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java\nindex a752a03b..23df02f7 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java\n\n@@ -140,25 +140,7 @@ public class UpdateTopicConfigurationRunnable extends OperationRunnable {\n   @Override\n   public OptimizationResult getResult() throws Exception {\n     if (_topicPatternByReplicationFactor != null) {\n-      return new OptimizationResult(\n-          updateTopicReplicationFactor(_topicPatternByReplicationFactor,\n-                                       _goals,\n-                                       _skipRackAwarenessCheck,\n-                                       _requirements,\n-                                       _allowCapacityEstimation,\n-                                       _concurrentInterBrokerPartitionMovements,\n-                                       _concurrentLeaderMovements,\n-                                       _executionProgressCheckIntervalMs,\n-                                       _skipHardGoalCheck,\n-                                       _replicaMovementStrategy,\n-                                       _replicationThrottle,\n-                                       _excludeRecentlyDemotedBrokers,\n-                                       _excludeRecentlyRemovedBrokers,\n-                                       _dryRun,\n-                                       _reason,\n-                                       _stopOngoingExecution,\n-                                       _isTriggeredByUserRequest),\n-          _kafkaCruiseControl.config());\n+      return new OptimizationResult(updateTopicReplicationFactor(), _kafkaCruiseControl.config());\n     }\n     // Never reaches here.\n     throw new IllegalArgumentException(\"Nothing executable found in request.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MjI1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374442250", "bodyText": "Null check on a random local variable of this runnable is a little confusing. Can we make it more clear?", "author": "efeg", "createdAt": "2020-02-04T02:11:56Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java", "diffHunk": "@@ -48,38 +57,107 @@\n  */\n public class UpdateTopicConfigurationRunnable extends OperationRunnable {\n   private static final Logger LOG = LoggerFactory.getLogger(UpdateTopicConfigurationRunnable.class);\n-  protected final TopicReplicationFactorChangeParameters _topicReplicationFactorChangeParameters;\n   protected final String _uuid;\n+  protected Map<Short, Pattern> _topicPatternByReplicationFactor;\n+  protected List<String> _goals;\n+  protected boolean _skipRackAwarenessCheck;\n+  protected ModelCompletenessRequirements _requirements;\n+  protected boolean _allowCapacityEstimation;\n+  protected Integer _concurrentInterBrokerPartitionMovements;\n+  protected Integer _concurrentLeaderMovements;\n+  protected Long _executionProgressCheckIntervalMs;\n+  protected boolean _skipHardGoalCheck;\n+  protected ReplicaMovementStrategy _replicaMovementStrategy;\n+  protected Long _replicationThrottle;\n+  protected boolean _excludeRecentlyDemotedBrokers;\n+  protected boolean _excludeRecentlyRemovedBrokers;\n+  protected boolean _dryRun;\n+  protected String _reason;\n+  protected boolean _stopOngoingExecution;\n+  protected boolean _isTriggeredByUserRequest;\n \n   public UpdateTopicConfigurationRunnable(KafkaCruiseControl kafkaCruiseControl,\n                                           OperationFuture future,\n                                           String uuid,\n                                           TopicConfigurationParameters parameters) {\n     super(kafkaCruiseControl, future);\n-    _topicReplicationFactorChangeParameters = parameters.topicReplicationFactorChangeParameters();\n+    TopicReplicationFactorChangeParameters topicReplicationFactorChangeParameters = parameters.topicReplicationFactorChangeParameters();\n+    if (topicReplicationFactorChangeParameters != null) {\n+      _topicPatternByReplicationFactor = topicReplicationFactorChangeParameters.topicPatternByReplicationFactor();\n+      _goals = topicReplicationFactorChangeParameters.goals();\n+      _skipRackAwarenessCheck = topicReplicationFactorChangeParameters.skipRackAwarenessCheck();\n+      _requirements = topicReplicationFactorChangeParameters.modelCompletenessRequirements();\n+      _allowCapacityEstimation = topicReplicationFactorChangeParameters.allowCapacityEstimation();\n+      _concurrentInterBrokerPartitionMovements = topicReplicationFactorChangeParameters.concurrentInterBrokerPartitionMovements();\n+      _concurrentLeaderMovements = topicReplicationFactorChangeParameters.concurrentLeaderMovements();\n+      _executionProgressCheckIntervalMs = topicReplicationFactorChangeParameters.executionProgressCheckIntervalMs();\n+      _skipHardGoalCheck = topicReplicationFactorChangeParameters.skipHardGoalCheck();\n+      _replicaMovementStrategy = topicReplicationFactorChangeParameters.replicaMovementStrategy();\n+      _replicationThrottle = topicReplicationFactorChangeParameters.replicationThrottle();\n+      _excludeRecentlyDemotedBrokers = topicReplicationFactorChangeParameters.excludeRecentlyDemotedBrokers();\n+      _excludeRecentlyRemovedBrokers = topicReplicationFactorChangeParameters.excludeRecentlyRemovedBrokers();\n+      _dryRun = topicReplicationFactorChangeParameters.dryRun();\n+      _reason = topicReplicationFactorChangeParameters.reason();\n+      _stopOngoingExecution = topicReplicationFactorChangeParameters.stopOngoingExecution();\n+      }\n     _uuid = uuid;\n+    _isTriggeredByUserRequest = true;\n   }\n \n+  /**\n+   * Constructor to be used for creating a runnable for self-healing.\n+   */\n+  public UpdateTopicConfigurationRunnable(KafkaCruiseControl kafkaCruiseControl,\n+                                          Map<Short, Pattern> topicPatternByReplicationFactor,\n+                                          List<String> selfHealingGoals,\n+                                          boolean allowCapacityEstimation,\n+                                          boolean excludeRecentlyDemotedBrokers,\n+                                          boolean excludeRecentlyRemovedBrokers,\n+                                          String anomalyId,\n+                                          String reason) {\n+    super(kafkaCruiseControl, new OperationFuture(\"Topic replication factor anomaly self-healing.\"));\n+    _topicPatternByReplicationFactor = topicPatternByReplicationFactor;\n+    _goals = selfHealingGoals;\n+    _skipRackAwarenessCheck = SELF_HEALING_SKIP_RACK_AWARENESS_CHECK;\n+    _requirements = SELF_HEALING_MODEL_COMPLETENESS_REQUIREMENTS;\n+    _allowCapacityEstimation = allowCapacityEstimation;\n+    _concurrentInterBrokerPartitionMovements = SELF_HEALING_CONCURRENT_MOVEMENTS;\n+    _concurrentLeaderMovements = SELF_HEALING_CONCURRENT_MOVEMENTS;\n+    _executionProgressCheckIntervalMs = SELF_HEALING_EXECUTION_PROGRESS_CHECK_INTERVAL_MS;\n+    _skipHardGoalCheck = SELF_HEALING_SKIP_HARD_GOAL_CHECK;\n+    _replicaMovementStrategy = SELF_HEALING_REPLICA_MOVEMENT_STRATEGY;\n+    _replicationThrottle = kafkaCruiseControl.config().getLong(ExecutorConfig.DEFAULT_REPLICATION_THROTTLE_CONFIG);\n+    _excludeRecentlyDemotedBrokers = excludeRecentlyDemotedBrokers;\n+    _excludeRecentlyRemovedBrokers = excludeRecentlyRemovedBrokers;\n+    _dryRun = SELF_HEALING_DRYRUN;\n+    _reason = reason;\n+    _stopOngoingExecution = SELF_HEALING_STOP_ONGOING_EXECUTION;\n+    _uuid = anomalyId;\n+    _isTriggeredByUserRequest = false;\n+  }\n+\n+\n   @Override\n-  protected OptimizationResult getResult() throws Exception {\n-    if (_topicReplicationFactorChangeParameters != null) {\n+  public OptimizationResult getResult() throws Exception {\n+    if (_topicPatternByReplicationFactor != null) {", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc0NDg0Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r376744846", "bodyText": "I feel this is needed because we plan to add more functionality to this Runnable.  It is supposed to be part of all the topic configuration change code path. Currently we only have topic RF change, so it looks a little bizarre. Once we support more topic configuration change type, it will make more sense.", "author": "kidkun", "createdAt": "2020-02-09T00:25:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MjI1MA=="}], "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java\nindex a752a03b..23df02f7 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java\n\n@@ -140,25 +140,7 @@ public class UpdateTopicConfigurationRunnable extends OperationRunnable {\n   @Override\n   public OptimizationResult getResult() throws Exception {\n     if (_topicPatternByReplicationFactor != null) {\n-      return new OptimizationResult(\n-          updateTopicReplicationFactor(_topicPatternByReplicationFactor,\n-                                       _goals,\n-                                       _skipRackAwarenessCheck,\n-                                       _requirements,\n-                                       _allowCapacityEstimation,\n-                                       _concurrentInterBrokerPartitionMovements,\n-                                       _concurrentLeaderMovements,\n-                                       _executionProgressCheckIntervalMs,\n-                                       _skipHardGoalCheck,\n-                                       _replicaMovementStrategy,\n-                                       _replicationThrottle,\n-                                       _excludeRecentlyDemotedBrokers,\n-                                       _excludeRecentlyRemovedBrokers,\n-                                       _dryRun,\n-                                       _reason,\n-                                       _stopOngoingExecution,\n-                                       _isTriggeredByUserRequest),\n-          _kafkaCruiseControl.config());\n+      return new OptimizationResult(updateTopicReplicationFactor(), _kafkaCruiseControl.config());\n     }\n     // Never reaches here.\n     throw new IllegalArgumentException(\"Nothing executable found in request.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0Mzc5Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374443797", "bodyText": "Nit: Can we name the CLUSTER_ID to a more specific value?", "author": "efeg", "createdAt": "2020-02-04T02:19:09Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java", "diffHunk": "@@ -24,6 +29,7 @@\n   public static final String T1 = \"T1\";\n   public static final String T2 = \"T2\";\n   public static final Map<Integer, Integer> RACK_BY_BROKER;\n+  public static final String CLUSTER_ID = \"TEST\";", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java\nindex 3b16eefb..6638bc7a 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java\n\n@@ -29,7 +29,8 @@ public class DeterministicCluster {\n   public static final String T1 = \"T1\";\n   public static final String T2 = \"T2\";\n   public static final Map<Integer, Integer> RACK_BY_BROKER;\n-  public static final String CLUSTER_ID = \"TEST\";\n+  public static final String CLUSTER_ID = \"DETERMINISTIC_CLUSTER\";\n+  public static final int PORT = 0;\n   static {\n     Map<Integer, Integer> racksByBrokerIds = new HashMap<>();\n     racksByBrokerIds.put(0, 0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NDIzMA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374444230", "bodyText": "Nit: Can we avoid hard-coding port number?", "author": "efeg", "createdAt": "2020-02-04T02:21:08Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java", "diffHunk": "@@ -503,4 +509,31 @@ public static ClusterModel getHomogeneousCluster(Map<Integer, Integer> rackByBro\n         (key, value) -> cluster.createBroker(value.toString(), Integer.toString(key), key, commonBrokerCapacityInfo, diskCapacityByLogDir != null));\n     return cluster;\n   }\n+\n+  /**\n+   * Generate the cluster metadata from given cluster model.\n+   * @param clusterModel The cluster model.\n+   * @return The cluster metadata.\n+   */\n+  public static Cluster generateClusterFromClusterModel(ClusterModel clusterModel) {\n+    Map<Integer, Node> nodes = new HashMap<>();\n+    clusterModel.brokers().forEach(b -> nodes.put(b.id(), new Node(b.id(), b.host().toString(), 0, b.rack().id())));", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java\nindex 3b16eefb..6638bc7a 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java\n\n@@ -517,7 +518,7 @@ public class DeterministicCluster {\n    */\n   public static Cluster generateClusterFromClusterModel(ClusterModel clusterModel) {\n     Map<Integer, Node> nodes = new HashMap<>();\n-    clusterModel.brokers().forEach(b -> nodes.put(b.id(), new Node(b.id(), b.host().toString(), 0, b.rack().id())));\n+    clusterModel.brokers().forEach(b -> nodes.put(b.id(), new Node(b.id(), b.host().name(), PORT, b.rack().id())));\n     List<PartitionInfo> partitions = new ArrayList<>();\n     for (List<Partition> pList : clusterModel.getPartitionsByTopic().values()) {\n       for (Partition p : pList) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NTAwNg==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374445006", "bodyText": "Rather than b.host().toString(), maybe it is more preferable to use host().name()?\nFor historical reasons, toString() method is returning XML format -- which is something we should change in this or another patch.", "author": "efeg", "createdAt": "2020-02-04T02:24:31Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java", "diffHunk": "@@ -503,4 +509,31 @@ public static ClusterModel getHomogeneousCluster(Map<Integer, Integer> rackByBro\n         (key, value) -> cluster.createBroker(value.toString(), Integer.toString(key), key, commonBrokerCapacityInfo, diskCapacityByLogDir != null));\n     return cluster;\n   }\n+\n+  /**\n+   * Generate the cluster metadata from given cluster model.\n+   * @param clusterModel The cluster model.\n+   * @return The cluster metadata.\n+   */\n+  public static Cluster generateClusterFromClusterModel(ClusterModel clusterModel) {\n+    Map<Integer, Node> nodes = new HashMap<>();\n+    clusterModel.brokers().forEach(b -> nodes.put(b.id(), new Node(b.id(), b.host().toString(), 0, b.rack().id())));", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java\nindex 3b16eefb..6638bc7a 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java\n\n@@ -517,7 +518,7 @@ public class DeterministicCluster {\n    */\n   public static Cluster generateClusterFromClusterModel(ClusterModel clusterModel) {\n     Map<Integer, Node> nodes = new HashMap<>();\n-    clusterModel.brokers().forEach(b -> nodes.put(b.id(), new Node(b.id(), b.host().toString(), 0, b.rack().id())));\n+    clusterModel.brokers().forEach(b -> nodes.put(b.id(), new Node(b.id(), b.host().name(), PORT, b.rack().id())));\n     List<PartitionInfo> partitions = new ArrayList<>();\n     for (List<Partition> pList : clusterModel.getPartitionsByTopic().values()) {\n       for (Partition p : pList) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NTk4OA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374445988", "bodyText": "Nit (not introduced in this patch): Noticed a typo in static private final long MOCK_ANOMALY_DETECTER_SHUTDOWN_MS = 5000L;", "author": "efeg", "createdAt": "2020-02-04T02:29:02Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetectorTest.java", "diffHunk": "@@ -41,6 +41,9 @@\n import org.junit.Test;\n \n import static com.linkedin.kafka.cruisecontrol.common.DeterministicCluster.smallClusterModel;\n+import static com.linkedin.kafka.cruisecontrol.common.DeterministicCluster.unbalanced;", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NjU4OA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374446588", "bodyText": "This function seems to be quite verbose -- can we move some of the logic to functions to make what it is testing more clear?", "author": "efeg", "createdAt": "2020-02-04T02:31:57Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetectorTest.java", "diffHunk": "@@ -255,7 +278,8 @@ private void testFixAnomaly(AnomalyType anomalyType)\n     EasyMock.expect(mockKafkaCruiseControl.getLoadMonitorTaskRunnerState())\n             .andReturn(LoadMonitorTaskRunner.LoadMonitorTaskRunnerState.RUNNING).times(1, 4);\n \n-    startPeriodicDetectors(mockDetectorScheduler, mockGoalViolationDetector, mockMetricAnomalyDetector, mockDiskFailureDetector, executorService);\n+    startPeriodicDetectors(mockDetectorScheduler, mockGoalViolationDetector, mockMetricAnomalyDetector, mockDiskFailureDetector,", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc0NTA2Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r376745066", "bodyText": "It would be hard since most of the code is to create mock objects, if we move these code to another method, the return value(we need to return a lot of mock object) will be hard in Java.", "author": "kidkun", "createdAt": "2020-02-09T00:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NjU4OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NzEzMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374447131", "bodyText": "Can we add some notes (e.g. to JavaDoc or inline) on what we are testing?", "author": "efeg", "createdAt": "2020-02-04T02:34:31Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java", "diffHunk": "@@ -197,6 +203,15 @@ public void testSelfHealingDisabled() {\n     assertEquals(AnomalyNotificationResult.Action.IGNORE, result.action());\n     assertTrue(anomalyNotifier._alertCalled.get(KafkaAnomalyType.DISK_FAILURE));\n     assertFalse(anomalyNotifier._autoFixTriggered.get(KafkaAnomalyType.DISK_FAILURE));\n+\n+    // (5) Topic Anomaly", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java\nindex 5a46b387..6a0f64ea 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java\n\n@@ -195,7 +195,7 @@ public class SelfHealingNotifierTest {\n     assertTrue(anomalyNotifier._alertCalled.get(KafkaAnomalyType.METRIC_ANOMALY));\n     assertFalse(anomalyNotifier._autoFixTriggered.get(KafkaAnomalyType.METRIC_ANOMALY));\n \n-    // (4) Disk Failure\n+    // (4) Test disk failure anomaly can be detected by notifier.\n     anomalyNotifier.resetAlert(KafkaAnomalyType.DISK_FAILURE);\n     result = anomalyNotifier.onDiskFailure(kafkaCruiseControlConfig.getConfiguredInstance(AnomalyDetectorConfig.DISK_FAILURES_CLASS_CONFIG,\n                                                                                           DiskFailures.class,\n"}}, {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "url": "https://github.com/linkedin/cruise-control/commit/c694052ddc5f7c393429b187991b2b5b0a70e7f7", "message": "Fix build failure.", "committedDate": "2020-02-10T06:31:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4ODMxNg==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379188316", "bodyText": "Nit: Can these static variables also be final?", "author": "efeg", "createdAt": "2020-02-14T00:07:01Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyUtilsTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.junit.Test;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.buildTopicRegex;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+\n+/**\n+ * Unit test class for anomaly utilization methods.\n+ */\n+public class AnomalyUtilsTest {\n+    private static String TOPIC1 = \"abc\";", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef939f4f523ff7e90f2669da3be46fdc847f260", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyUtilsTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyUtilsTest.java\ndeleted file mode 100644\nindex d3ddff37..00000000\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyUtilsTest.java\n+++ /dev/null\n\n@@ -1,36 +0,0 @@\n-/*\n- * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n- */\n-\n-package com.linkedin.kafka.cruisecontrol.detector;\n-\n-import java.util.HashSet;\n-import java.util.Set;\n-import java.util.regex.Pattern;\n-import org.junit.Test;\n-\n-import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.buildTopicRegex;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n-\n-\n-/**\n- * Unit test class for anomaly utilization methods.\n- */\n-public class AnomalyUtilsTest {\n-    private static String TOPIC1 = \"abc\";\n-    private static String TOPIC2 = \"def\";\n-    private static String TOPIC3 = \"ghi\";\n-\n-    @Test\n-    public void testBuildTopicRegex() {\n-        Set<String> topicsToMatch = new HashSet<>(2);\n-        topicsToMatch.add(TOPIC1);\n-        topicsToMatch.add(TOPIC2);\n-        Pattern pattern = buildTopicRegex(topicsToMatch);\n-\n-        assertTrue(pattern.matcher(TOPIC1).matches());\n-        assertTrue(pattern.matcher(TOPIC2).matches());\n-        assertFalse(pattern.matcher(TOPIC3).matches());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MTQ3OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379191479", "bodyText": "The corresponding unit test seems to pass without parentheses, as well. Capturing group seems redundant.", "author": "efeg", "createdAt": "2020-02-14T00:18:19Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyUtilsTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.junit.Test;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.buildTopicRegex;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+\n+/**\n+ * Unit test class for anomaly utilization methods.\n+ */\n+public class AnomalyUtilsTest {\n+    private static String TOPIC1 = \"abc\";\n+    private static String TOPIC2 = \"def\";\n+    private static String TOPIC3 = \"ghi\";\n+\n+    @Test\n+    public void testBuildTopicRegex() {", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef939f4f523ff7e90f2669da3be46fdc847f260", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyUtilsTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyUtilsTest.java\ndeleted file mode 100644\nindex d3ddff37..00000000\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyUtilsTest.java\n+++ /dev/null\n\n@@ -1,36 +0,0 @@\n-/*\n- * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n- */\n-\n-package com.linkedin.kafka.cruisecontrol.detector;\n-\n-import java.util.HashSet;\n-import java.util.Set;\n-import java.util.regex.Pattern;\n-import org.junit.Test;\n-\n-import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.buildTopicRegex;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n-\n-\n-/**\n- * Unit test class for anomaly utilization methods.\n- */\n-public class AnomalyUtilsTest {\n-    private static String TOPIC1 = \"abc\";\n-    private static String TOPIC2 = \"def\";\n-    private static String TOPIC3 = \"ghi\";\n-\n-    @Test\n-    public void testBuildTopicRegex() {\n-        Set<String> topicsToMatch = new HashSet<>(2);\n-        topicsToMatch.add(TOPIC1);\n-        topicsToMatch.add(TOPIC2);\n-        Pattern pattern = buildTopicRegex(topicsToMatch);\n-\n-        assertTrue(pattern.matcher(TOPIC1).matches());\n-        assertTrue(pattern.matcher(TOPIC2).matches());\n-        assertFalse(pattern.matcher(TOPIC3).matches());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MjkxNA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379192914", "bodyText": "Nit: Can we make it KafkaAnomalyType.cachedValues().size() + 1 and add a comment to clarify why we have a + 1?", "author": "efeg", "createdAt": "2020-02-14T00:24:07Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java", "diffHunk": "@@ -48,7 +50,7 @@\n   static final String METRIC_REGISTRY_NAME = \"AnomalyDetector\";\n   private static final int INIT_JITTER_BOUND = 10000;\n   private static final long SCHEDULER_SHUTDOWN_TIMEOUT_MS = 5000L;\n-  private static final int NUM_ANOMALY_DETECTION_THREADS = 5;\n+  private static final int NUM_ANOMALY_DETECTION_THREADS = 6;", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee8771f3ab11ffe5671e0753b5f1af7f65506632", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java\nindex 3d9775f6..402536a4 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java\n\n@@ -50,7 +50,9 @@ public class AnomalyDetector {\n   static final String METRIC_REGISTRY_NAME = \"AnomalyDetector\";\n   private static final int INIT_JITTER_BOUND = 10000;\n   private static final long SCHEDULER_SHUTDOWN_TIMEOUT_MS = 5000L;\n-  private static final int NUM_ANOMALY_DETECTION_THREADS = 6;\n+  // For each anomaly type, one thread is needed to run corresponding anomaly detector.\n+  // One more thread is needed to run anomaly handler task.\n+  private static final int NUM_ANOMALY_DETECTION_THREADS = KafkaAnomalyType.cachedValues().size() + 1;\n   private static final int ANOMALY_QUEUE_INITIAL_CAPACITY = 10;\n   private static final Logger LOG = LoggerFactory.getLogger(AnomalyDetector.class);\n   private static final Logger OPERATION_LOG = LoggerFactory.getLogger(OPERATION_LOGGER);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5NDk4OA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379194988", "bodyText": "Nit: Would it be more clear to say violation of user-defined topic properties rather than certain desired topic property?", "author": "efeg", "createdAt": "2020-02-14T00:31:55Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n+import java.util.Set;\n+import org.apache.yetus.audience.InterfaceStability;\n+\n+\n+/**\n+ * The finder which checks topics against certain desired topic property to identify topic anomaly.", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef939f4f523ff7e90f2669da3be46fdc847f260", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java\nindex 5ec0fbce..6913293c 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java\n\n@@ -5,7 +5,7 @@\n package com.linkedin.kafka.cruisecontrol.detector;\n \n import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n-import java.util.Set;\n+import java.util.List;\n import org.apache.yetus.audience.InterfaceStability;\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwMTk3NA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379201974", "bodyText": "Can we make all variables final?", "author": "efeg", "createdAt": "2020-02-14T00:58:09Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java", "diffHunk": "@@ -48,39 +57,90 @@\n  */\n public class UpdateTopicConfigurationRunnable extends OperationRunnable {\n   private static final Logger LOG = LoggerFactory.getLogger(UpdateTopicConfigurationRunnable.class);\n-  protected final TopicReplicationFactorChangeParameters _topicReplicationFactorChangeParameters;\n   protected final String _uuid;\n+  protected Map<Short, Pattern> _topicPatternByReplicationFactor;", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTc1NzI4MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379757281", "bodyText": "we can not make them final because in one constructor we may not initialize them.", "author": "kidkun", "createdAt": "2020-02-15T06:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwMTk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5OTQ0NA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r380999444", "bodyText": "Would it be possible to initialize them to null in the constructor otherwise?", "author": "efeg", "createdAt": "2020-02-18T23:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwMTk3NA=="}], "type": "inlineReview", "revised_code": {"commit": "0ef939f4f523ff7e90f2669da3be46fdc847f260", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java\nindex 23df02f7..08531fd9 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java\n\n@@ -140,7 +140,25 @@ public class UpdateTopicConfigurationRunnable extends OperationRunnable {\n   @Override\n   public OptimizationResult getResult() throws Exception {\n     if (_topicPatternByReplicationFactor != null) {\n-      return new OptimizationResult(updateTopicReplicationFactor(), _kafkaCruiseControl.config());\n+      return new OptimizationResult(\n+          updateTopicReplicationFactor(_topicPatternByReplicationFactor,\n+                                       _goals,\n+                                       _skipRackAwarenessCheck,\n+                                       _requirements,\n+                                       _allowCapacityEstimation,\n+                                       _concurrentInterBrokerPartitionMovements,\n+                                       _concurrentLeaderMovements,\n+                                       _executionProgressCheckIntervalMs,\n+                                       _skipHardGoalCheck,\n+                                       _replicaMovementStrategy,\n+                                       _replicationThrottle,\n+                                       _excludeRecentlyDemotedBrokers,\n+                                       _excludeRecentlyRemovedBrokers,\n+                                       _dryRun,\n+                                       _reason,\n+                                       _stopOngoingExecution,\n+                                       _isTriggeredByUserRequest),\n+          _kafkaCruiseControl.config());\n     }\n     // Never reaches here.\n     throw new IllegalArgumentException(\"Nothing executable found in request.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwMzQyMA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379203420", "bodyText": "Nit: Let's avoid hardcoding test constants.", "author": "efeg", "createdAt": "2020-02-14T01:03:11Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java", "diffHunk": "@@ -162,6 +166,8 @@ public void testSelfHealingDisabled() {\n                                  Collections.singletonMap(brokerWithMetricAnomaly, anomalyDetectionTime));\n     parameterConfigOverrides.put(FAILED_DISKS_OBJECT_CONFIG,\n                                  Collections.singletonMap(1, Collections.singletonMap(\"logdir1\", failureTime1)));\n+    parameterConfigOverrides.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, (short) 3);\n+    parameterConfigOverrides.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, Collections.singleton(\"topic1\"));", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee8771f3ab11ffe5671e0753b5f1af7f65506632", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java\nindex 6a0f64ea..ed6960fa 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java\n\n@@ -165,9 +168,9 @@ public class SelfHealingNotifierTest {\n     parameterConfigOverrides.put(METRIC_ANOMALY_BROKER_ENTITIES_OBJECT_CONFIG,\n                                  Collections.singletonMap(brokerWithMetricAnomaly, anomalyDetectionTime));\n     parameterConfigOverrides.put(FAILED_DISKS_OBJECT_CONFIG,\n-                                 Collections.singletonMap(1, Collections.singletonMap(\"logdir1\", failureTime1)));\n-    parameterConfigOverrides.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, (short) 3);\n-    parameterConfigOverrides.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, Collections.singleton(\"topic1\"));\n+                                 Collections.singletonMap(1, Collections.singletonMap(BAD_LOGDIR, failureTime1)));\n+    parameterConfigOverrides.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, SELF_HEALING_TARGET_REPLICATION_FACTOR);\n+    parameterConfigOverrides.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, Collections.singleton(BAD_TOPIC));\n     AnomalyNotificationResult result = anomalyNotifier.onBrokerFailure(\n         kafkaCruiseControlConfig.getConfiguredInstance(AnomalyDetectorConfig.BROKER_FAILURES_CLASS_CONFIG,\n                                                        BrokerFailures.class,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwNDc1NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379204755", "bodyText": "Nit: bad indentation", "author": "efeg", "createdAt": "2020-02-14T01:07:39Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n+ *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n+ * </ul>\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public Set<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                       _targetReplicationFactor));\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef939f4f523ff7e90f2669da3be46fdc847f260", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\nindex 34c921cb..38686266 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n\n@@ -9,32 +9,25 @@ import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.apache.kafka.common.Cluster;\n import org.apache.kafka.common.PartitionInfo;\n \n-import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n-import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n \n \n /**\n  * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n- * Required configurations for this class.\n- * <ul>\n- *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n- *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n- *   The value is treated as a regular expression, default value is set to\n- *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n- *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n- *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n- * </ul>\n  */\n public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n   public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n   public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n   public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n   public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwNjUxNg==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379206516", "bodyText": "(Not introduced in this patch) We are missing similar sanity checks for pluggable SlowBrokerFinder for AnomalyDetectorConfig.METRIC_ANOMALY_CLASS_CONFIG .", "author": "efeg", "createdAt": "2020-02-14T01:14:23Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n+ *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n+ * </ul>\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public Set<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                       _targetReplicationFactor));\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicAnomaly.class, configs);\n+  }\n+\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    _kafkaCruiseControl = (KafkaCruiseControl) configs.get(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    if (_kafkaCruiseControl == null) {\n+      throw new IllegalArgumentException(\"Topic replication factor anomaly finder is missing \" + KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    }\n+    Short targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    if (targetReplicationFactor == null) {\n+      throw new IllegalArgumentException(\"Topic replication factor anomaly finder is missing \" + SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    }\n+    _targetReplicationFactor = targetReplicationFactor;\n+    String topicExcludedFromCheck = (String) configs.get(TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK);\n+    _topicExcludedFromCheck = Pattern.compile(topicExcludedFromCheck == null ? DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK\n+                                                                             : topicExcludedFromCheck);\n+    String topicReplicationTopicAnomalyClass = (String) configs.get(TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG);\n+    if (topicReplicationTopicAnomalyClass == null) {\n+      _topicReplicationTopicAnomalyClass = DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS;\n+    } else {\n+      _topicReplicationTopicAnomalyClass = (Class<?>) ConfigDef.parseType(TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG,\n+                                                                          topicReplicationTopicAnomalyClass,\n+                                                                          CLASS);\n+      if (_topicReplicationTopicAnomalyClass == null || !TopicAnomaly.class.isAssignableFrom(_topicReplicationTopicAnomalyClass)) {", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTc2MDE1Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379760156", "bodyText": "Discussed this offline, I would like to fix this in a follow-up patch to fix a bigger metric anomaly issue.", "author": "kidkun", "createdAt": "2020-02-15T06:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwNjUxNg=="}], "type": "inlineReview", "revised_code": {"commit": "0ef939f4f523ff7e90f2669da3be46fdc847f260", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\nindex 34c921cb..38686266 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java\n\n@@ -9,32 +9,25 @@ import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.apache.kafka.common.Cluster;\n import org.apache.kafka.common.PartitionInfo;\n \n-import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n-import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n \n \n /**\n  * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n- * Required configurations for this class.\n- * <ul>\n- *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n- *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n- *   The value is treated as a regular expression, default value is set to\n- *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n- *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n- *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n- * </ul>\n  */\n public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n   public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n   public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n   public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n   public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzMjc5Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382232793", "bodyText": "Nit: Can we move the default to a static variable?", "author": "efeg", "createdAt": "2020-02-20T20:13:16Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java", "diffHunk": "@@ -269,6 +286,16 @@ public static ConfigDef define(ConfigDef configDef) {\n                             ConfigDef.Type.BOOLEAN,\n                             DEFAULT_ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG,\n                             ConfigDef.Importance.LOW,\n-                            ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_DOC);\n+                            ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_DOC)\n+                    .define(TOPIC_ANOMALY_FINDER_CLASSES_CONFIG,\n+                            ConfigDef.Type.LIST,\n+                            DEFAULT_TOPIC_ANOMALY_FINDER_CLASS,\n+                            ConfigDef.Importance.MEDIUM,\n+                            TOPIC_ANOMALY_FINDER_CLASSES_DOC)\n+                    .define(TOPIC_ANOMALY_DETECTION_INTERVAL_MS_CONFIG,\n+                            ConfigDef.Type.LONG,\n+                            null,", "originalCommit": "7c600aa16a95127bb01db28f130c479a913ea9ce", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef939f4f523ff7e90f2669da3be46fdc847f260", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java\nindex 8e0b7de1..888faf9c 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java\n\n@@ -259,27 +265,27 @@ public class AnomalyDetectorConfig {\n                             FAILED_BROKERS_ZK_PATH_DOC)\n                     .define(ANOMALY_DETECTION_INTERVAL_MS_CONFIG,\n                             ConfigDef.Type.LONG,\n-                            300000L,\n+                            DEFAULT_ANOMALY_DETECTION_INTERVAL_MS,\n                             ConfigDef.Importance.LOW,\n                             ANOMALY_DETECTION_INTERVAL_MS_DOC)\n                     .define(GOAL_VIOLATION_DETECTION_INTERVAL_MS_CONFIG,\n                             ConfigDef.Type.LONG,\n-                            null,\n+                            DEFAULT_GOAL_VIOLATION_DETECTION_INTERVAL_MS,\n                             ConfigDef.Importance.LOW,\n                             GOAL_VIOLATION_DETECTION_INTERVAL_MS_DOC)\n                     .define(METRIC_ANOMALY_DETECTION_INTERVAL_MS_CONFIG,\n                             ConfigDef.Type.LONG,\n-                            null,\n+                            DEFAULT_METRIC_ANOMALY_DETECTION_INTERVAL_MS,\n                             ConfigDef.Importance.LOW,\n                             METRIC_ANOMALY_DETECTION_INTERVAL_MS_DOC)\n                     .define(DISK_FAILURE_DETECTION_INTERVAL_MS_CONFIG,\n                             ConfigDef.Type.LONG,\n-                            null,\n+                            DEFAULT_DISK_FAILURE_DETECTION_INTERVAL_MS,\n                             ConfigDef.Importance.LOW,\n                             DISK_FAILURE_DETECTION_INTERVAL_MS_DOC)\n                     .define(BROKER_FAILURE_DETECTION_BACKOFF_MS_CONFIG,\n                             ConfigDef.Type.LONG,\n-                            300000L,\n+                            DEFAULT_BROKER_FAILURE_DETECTION_BACKOFF_MS,\n                             ConfigDef.Importance.LOW,\n                             BROKER_FAILURE_DETECTION_BACKOFF_MS_DOC)\n                     .define(ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzNTkxNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382235915", "bodyText": "If we make this the default topic anomaly finder, even if the user does not want to use the topic anomaly finder, s/he will receive an IllegalXXX exception upon configuration time due to missing default replication factor. Should we:\n\nMake the NoopTopic Anomaly Finder as the default here, and\nAdd a documentation under the wiki on what needs to be done to use TopicReplicationFactorAnomalyFinder?\nAlso add documentation on configurations section of wiki to add the new configs?", "author": "efeg", "createdAt": "2020-02-20T20:20:03Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java", "diffHunk": "@@ -172,6 +173,22 @@ private AnomalyDetectorConfig() {\n   public static final String ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_DOC = \"The flag to indicate whether anomaly \"\n       + \"detection threads allow capacity estimation in the generated cluster model they use.\";\n \n+  /**\n+   * <code>topic.anomaly.detection.interval.ms</code>\n+   */\n+  public static final String TOPIC_ANOMALY_DETECTION_INTERVAL_MS_CONFIG = \"topic.anomaly.detection.interval.ms\";\n+  public static final String TOPIC_ANOMALY_DETECTION_INTERVAL_MS_DOC = \"The interval in millisecond that topic anomaly \"\n+      + \"detector will run to detect topic anomalies. If this interval time is not specified, topic anomaly detector \"\n+      + \"will run with interval specified in \" + ANOMALY_DETECTION_INTERVAL_MS_CONFIG + \".\";\n+\n+  /**\n+   * <code>topic.anomaly.finder.class</code>\n+   */\n+  public static final String TOPIC_ANOMALY_FINDER_CLASSES_CONFIG = \"topic.anomaly.finder.class\";\n+  public static final String DEFAULT_TOPIC_ANOMALY_FINDER_CLASS = TopicReplicationFactorAnomalyFinder.class.getName();", "originalCommit": "7c600aa16a95127bb01db28f130c479a913ea9ce", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97033a2e74eb2fea158a67d3e114cb41173ace0e", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java\nindex 8e0b7de1..61f84bc8 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java\n\n@@ -177,6 +183,7 @@ public class AnomalyDetectorConfig {\n    * <code>topic.anomaly.detection.interval.ms</code>\n    */\n   public static final String TOPIC_ANOMALY_DETECTION_INTERVAL_MS_CONFIG = \"topic.anomaly.detection.interval.ms\";\n+  public static final Long DEFAULT_TOPIC_ANOMALY_DETECTION_INTERVAL_MS = null;\n   public static final String TOPIC_ANOMALY_DETECTION_INTERVAL_MS_DOC = \"The interval in millisecond that topic anomaly \"\n       + \"detector will run to detect topic anomalies. If this interval time is not specified, topic anomaly detector \"\n       + \"will run with interval specified in \" + ANOMALY_DETECTION_INTERVAL_MS_CONFIG + \".\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzNjQ3Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382236477", "bodyText": "Is this import intentional? Shouldn't we use org.apache.kafka.common.annotation.InterfaceStability;?", "author": "efeg", "createdAt": "2020-02-20T20:21:16Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n+import java.util.Set;\n+import org.apache.yetus.audience.InterfaceStability;", "originalCommit": "7c600aa16a95127bb01db28f130c479a913ea9ce", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef939f4f523ff7e90f2669da3be46fdc847f260", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java\nindex e19a435a..6913293c 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java\n\n@@ -5,20 +5,19 @@\n package com.linkedin.kafka.cruisecontrol.detector;\n \n import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n-import java.util.Set;\n+import java.util.List;\n import org.apache.yetus.audience.InterfaceStability;\n \n \n /**\n- * The finder which checks violation of user-defined topic properties.\n+ * The finder which checks topics against certain desired topic property to identify topic anomaly.\n  */\n @InterfaceStability.Evolving\n public interface  TopicAnomalyFinder extends CruiseControlConfigurable {\n \n   /**\n-   * Get a collection of topic anomalies for topics which are misconfigured or violate user-defined topic properties.\n-   *\n-   * @return Set of topic anomalies.\n+   * Get a list of topic anomalies for topics which are misconfigured or violate some desired property.\n+   * @return List of topic anomalies.\n    */\n-  Set<TopicAnomaly> topicAnomalies();\n+  List<TopicAnomaly> topicAnomalies();\n }\n"}}, {"oid": "0ef939f4f523ff7e90f2669da3be46fdc847f260", "url": "https://github.com/linkedin/cruise-control/commit/0ef939f4f523ff7e90f2669da3be46fdc847f260", "message": "Add support to detect and self-heal inconsistent topic replication factor.", "committedDate": "2020-02-20T22:45:44Z", "type": "commit"}, {"oid": "ac1c3b1ed8ec53ba2662ce503dde083e92dea69f", "url": "https://github.com/linkedin/cruise-control/commit/ac1c3b1ed8ec53ba2662ce503dde083e92dea69f", "message": "Fix build failure.", "committedDate": "2020-02-20T22:45:44Z", "type": "commit"}, {"oid": "7f73b230eccfcbff9ca89991cb9ad0a09e88e6aa", "url": "https://github.com/linkedin/cruise-control/commit/7f73b230eccfcbff9ca89991cb9ad0a09e88e6aa", "message": "Remove access.log", "committedDate": "2020-02-20T22:45:44Z", "type": "commit"}, {"oid": "a31b96c336a80462028dbfa40a891d1c3d9e90db", "url": "https://github.com/linkedin/cruise-control/commit/a31b96c336a80462028dbfa40a891d1c3d9e90db", "message": "Address the feedback.", "committedDate": "2020-02-20T22:46:35Z", "type": "commit"}, {"oid": "529138d2635fbe86947ce6b2556eff615b31bd50", "url": "https://github.com/linkedin/cruise-control/commit/529138d2635fbe86947ce6b2556eff615b31bd50", "message": "Fix build failure.", "committedDate": "2020-02-20T22:46:35Z", "type": "commit"}, {"oid": "ee8771f3ab11ffe5671e0753b5f1af7f65506632", "url": "https://github.com/linkedin/cruise-control/commit/ee8771f3ab11ffe5671e0753b5f1af7f65506632", "message": "Address the feedback.", "committedDate": "2020-02-20T22:46:35Z", "type": "commit"}, {"oid": "3cbfa344156a644b0d80e28f01deb2cc6279e18b", "url": "https://github.com/linkedin/cruise-control/commit/3cbfa344156a644b0d80e28f01deb2cc6279e18b", "message": "remove access log.", "committedDate": "2020-02-20T22:46:35Z", "type": "commit"}, {"oid": "97033a2e74eb2fea158a67d3e114cb41173ace0e", "url": "https://github.com/linkedin/cruise-control/commit/97033a2e74eb2fea158a67d3e114cb41173ace0e", "message": "Address the feedback.", "committedDate": "2020-02-20T22:52:54Z", "type": "commit"}, {"oid": "97033a2e74eb2fea158a67d3e114cb41173ace0e", "url": "https://github.com/linkedin/cruise-control/commit/97033a2e74eb2fea158a67d3e114cb41173ace0e", "message": "Address the feedback.", "committedDate": "2020-02-20T22:52:54Z", "type": "forcePushed"}, {"oid": "05cfe1c9757e0c3f4b40144e79c08c357d381f80", "url": "https://github.com/linkedin/cruise-control/commit/05cfe1c9757e0c3f4b40144e79c08c357d381f80", "message": "Fix build failure and udpate wiki.", "committedDate": "2020-02-20T23:17:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2MjcwNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382362705", "bodyText": "Can we use NoopTopicAnomalyFinder.class.getName() and use in topic anomaly unit test?", "author": "efeg", "createdAt": "2020-02-21T02:11:43Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControlUnitTestUtils.java", "diffHunk": "@@ -60,6 +60,7 @@ public static Properties getKafkaCruiseControlProperties() {\n                       Boolean.toString(AnomalyDetectorConfig.DEFAULT_SELF_HEALING_EXCLUDE_RECENT_BROKERS_CONFIG));\n     props.setProperty(AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG,\n                       Boolean.toString(AnomalyDetectorConfig.DEFAULT_SELF_HEALING_EXCLUDE_RECENT_BROKERS_CONFIG));\n+    props.setProperty(AnomalyDetectorConfig.TOPIC_ANOMALY_FINDER_CLASSES_CONFIG, \"\");", "originalCommit": "05cfe1c9757e0c3f4b40144e79c08c357d381f80", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dffd7ff392b8df6e393798d89f2384f435ea2b8f", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControlUnitTestUtils.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControlUnitTestUtils.java\nindex 31df863c..61921fc7 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControlUnitTestUtils.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControlUnitTestUtils.java\n\n@@ -60,7 +61,7 @@ public class KafkaCruiseControlUnitTestUtils {\n                       Boolean.toString(AnomalyDetectorConfig.DEFAULT_SELF_HEALING_EXCLUDE_RECENT_BROKERS_CONFIG));\n     props.setProperty(AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG,\n                       Boolean.toString(AnomalyDetectorConfig.DEFAULT_SELF_HEALING_EXCLUDE_RECENT_BROKERS_CONFIG));\n-    props.setProperty(AnomalyDetectorConfig.TOPIC_ANOMALY_FINDER_CLASSES_CONFIG, \"\");\n+    props.setProperty(AnomalyDetectorConfig.TOPIC_ANOMALY_FINDER_CLASSES_CONFIG, NoopTopicAnomalyFinder.class.getName());\n     props.setProperty(AnomalyDetectorConfig.SELF_HEALING_GOALS_CONFIG, \"\");\n     props.setProperty(\n         AnalyzerConfig.DEFAULT_GOALS_CONFIG,\n"}}, {"oid": "dffd7ff392b8df6e393798d89f2384f435ea2b8f", "url": "https://github.com/linkedin/cruise-control/commit/dffd7ff392b8df6e393798d89f2384f435ea2b8f", "message": "Address the feedback.", "committedDate": "2020-02-21T18:18:26Z", "type": "commit"}]}