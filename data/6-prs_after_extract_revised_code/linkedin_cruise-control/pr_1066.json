{"pr_number": 1066, "pr_title": "Tolerate broker capacity resolver unable to retrieve capacity information of dead broker.", "pr_createdAt": "2020-01-11T00:52:09Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1066", "timeline": [{"oid": "b5366b4e8a79ed6a609b7f22f843d80790a64288", "url": "https://github.com/linkedin/cruise-control/commit/b5366b4e8a79ed6a609b7f22f843d80790a64288", "message": "Tolerate broker capacity resolver unable to get capacity information of dead broker.", "committedDate": "2020-01-11T00:49:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ5NzU0MA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r365497540", "bodyText": "MonitorUtils#deadBrokersWithReplicas(Cluster) excludes dead brokers with 0 replicas. Shouldn't we include all dead brokers?", "author": "efeg", "createdAt": "2020-01-11T04:00:12Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java", "diffHunk": "@@ -523,10 +523,11 @@ public ClusterModel clusterModel(long from,\n       }\n \n       // Populate snapshots for the cluster model.\n+      Set<Integer> deadBrokers = MonitorUtils.deadBrokersWithReplicas(cluster);", "originalCommit": "b5366b4e8a79ed6a609b7f22f843d80790a64288", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62bc3142105765f4dc5871b25b44c734167c53f5", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\nindex 8a6884ff..fe5aa4a5 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\n\n@@ -523,11 +524,10 @@ public class LoadMonitor {\n       }\n \n       // Populate snapshots for the cluster model.\n-      Set<Integer> deadBrokers = MonitorUtils.deadBrokersWithReplicas(cluster);\n       for (Map.Entry<PartitionEntity, ValuesAndExtrapolations> entry : partitionValuesAndExtrapolations.entrySet()) {\n         TopicPartition tp = entry.getKey().tp();\n         ValuesAndExtrapolations leaderLoad = entry.getValue();\n-        populatePartitionLoad(cluster, clusterModel, tp, leaderLoad, replicaPlacementInfo, _brokerCapacityConfigResolver, deadBrokers);\n+        populatePartitionLoad(cluster, clusterModel, tp, leaderLoad, replicaPlacementInfo, _brokerCapacityConfigResolver);\n         step.incrementPopulatedNumPartitions();\n       }\n       // Set the state of bad brokers in clusterModel based on the Kafka cluster state.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ5ODA1Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r365498053", "bodyText": "Passing an empty map to BrokerCapacityInfo means that the broker has no resources -- I suspect that this will cause issues in the interpreting logic, which expects a value for each resource type (e.g. populating partition load on such brokers -- also see Broker#_brokerCapacity).\n\nCan we add a sanity check in BrokerCapacityInfo constructors to ensure that any capacity sent to this broker has exactly all resource types in the keyset of map?\nCan we add a unit test to verify our expected behavior and a cluster model can be generated properly under the tested scenario?", "author": "efeg", "createdAt": "2020-01-11T04:11:15Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -436,24 +437,33 @@ static void setBadBrokerState(ClusterModel clusterModel, Cluster cluster) {\n    * @param valuesAndExtrapolations The values and extrapolations of the leader replica.\n    * @param replicaPlacementInfo The distribution of replicas over broker logdirs if available, {@code null} otherwise.\n    * @param brokerCapacityConfigResolver The resolver for retrieving broker capacities.\n+   * @param deadBrokers Set of dead brokers in the cluster.\n    */\n   static void populatePartitionLoad(Cluster cluster,\n                                     ClusterModel clusterModel,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver,\n+                                    Set<Integer> deadBrokers) {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n       boolean needToAdjustCpuUsage = true;\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n-        // Note that we assume the capacity resolver can still return the broker capacity even if the broker\n-        // is dead. We need this to get the host resource capacity.\n-        BrokerCapacityInfo brokerCapacity =\n-            brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        BrokerCapacityInfo brokerCapacity;\n+        try {\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        } catch (Exception e) {\n+          //Capacity resolver may not be able to return the capacity information of dead brokers.\n+          if (deadBrokers.contains(replica.id())) {\n+            brokerCapacity = new BrokerCapacityInfo(Collections.emptyMap());", "originalCommit": "b5366b4e8a79ed6a609b7f22f843d80790a64288", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62bc3142105765f4dc5871b25b44c734167c53f5", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\nindex 3c213cf5..19fd91e3 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n\n@@ -437,16 +444,15 @@ public class MonitorUtils {\n    * @param valuesAndExtrapolations The values and extrapolations of the leader replica.\n    * @param replicaPlacementInfo The distribution of replicas over broker logdirs if available, {@code null} otherwise.\n    * @param brokerCapacityConfigResolver The resolver for retrieving broker capacities.\n-   * @param deadBrokers Set of dead brokers in the cluster.\n    */\n   static void populatePartitionLoad(Cluster cluster,\n                                     ClusterModel clusterModel,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver,\n-                                    Set<Integer> deadBrokers) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n+    Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n       boolean needToAdjustCpuUsage = true;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ5ODExMg==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r365498112", "bodyText": "Instead of catching all exceptions, should we catch a TimeoutException and in the logic that implements capacityForBroker, ensure that a timeout exception is thrown in the desired scenario?", "author": "efeg", "createdAt": "2020-01-11T04:13:15Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -436,24 +437,33 @@ static void setBadBrokerState(ClusterModel clusterModel, Cluster cluster) {\n    * @param valuesAndExtrapolations The values and extrapolations of the leader replica.\n    * @param replicaPlacementInfo The distribution of replicas over broker logdirs if available, {@code null} otherwise.\n    * @param brokerCapacityConfigResolver The resolver for retrieving broker capacities.\n+   * @param deadBrokers Set of dead brokers in the cluster.\n    */\n   static void populatePartitionLoad(Cluster cluster,\n                                     ClusterModel clusterModel,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver,\n+                                    Set<Integer> deadBrokers) {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n       boolean needToAdjustCpuUsage = true;\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n-        // Note that we assume the capacity resolver can still return the broker capacity even if the broker\n-        // is dead. We need this to get the host resource capacity.\n-        BrokerCapacityInfo brokerCapacity =\n-            brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        BrokerCapacityInfo brokerCapacity;\n+        try {\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        } catch (Exception e) {", "originalCommit": "b5366b4e8a79ed6a609b7f22f843d80790a64288", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62bc3142105765f4dc5871b25b44c734167c53f5", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\nindex 3c213cf5..19fd91e3 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n\n@@ -437,16 +444,15 @@ public class MonitorUtils {\n    * @param valuesAndExtrapolations The values and extrapolations of the leader replica.\n    * @param replicaPlacementInfo The distribution of replicas over broker logdirs if available, {@code null} otherwise.\n    * @param brokerCapacityConfigResolver The resolver for retrieving broker capacities.\n-   * @param deadBrokers Set of dead brokers in the cluster.\n    */\n   static void populatePartitionLoad(Cluster cluster,\n                                     ClusterModel clusterModel,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver,\n-                                    Set<Integer> deadBrokers) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n+    Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n       boolean needToAdjustCpuUsage = true;\n"}}, {"oid": "62bc3142105765f4dc5871b25b44c734167c53f5", "url": "https://github.com/linkedin/cruise-control/commit/62bc3142105765f4dc5871b25b44c734167c53f5", "message": "Address the feedback.", "committedDate": "2020-01-16T01:12:39Z", "type": "commit"}, {"oid": "d1e36497e6ed98941d299f5da634814f604fe2da", "url": "https://github.com/linkedin/cruise-control/commit/d1e36497e6ed98941d299f5da634814f604fe2da", "message": "Fix build failure.", "committedDate": "2020-01-17T19:54:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwMzA2NA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369303064", "bodyText": "When would this exception be thrown? Who configures the timeout here? Can we clarify this in JavaDoc?\nShould we modify this interface to pass a timeout -- e.g. a Duration argument similar to the way consumer poll() timeouts work?", "author": "efeg", "createdAt": "2020-01-21T23:41:53Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java", "diffHunk": "@@ -29,6 +30,7 @@\n    * @param host The host of the broker\n    * @param brokerId the id of the broker\n    * @return The capacity of each resource for the broker\n+   * @throws TimeoutException if resolver is unable to resolve broker capacity.", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21d6ecd81492c704fd80ecc2246ad36630c9b456", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java\nindex 657d9a67..d0d9a95e 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java\n\n@@ -28,9 +28,10 @@ public interface BrokerCapacityConfigResolver extends CruiseControlConfigurable,\n    *\n    * @param rack The rack of the broker\n    * @param host The host of the broker\n-   * @param brokerId the id of the broker\n+   * @param brokerId The id of the broker\n+   * @param timeoutMs The timeout in millisecond.\n    * @return The capacity of each resource for the broker\n-   * @throws TimeoutException if resolver is unable to resolve broker capacity.\n+   * @throws TimeoutException if resolver is unable to resolve broker capacity in time.\n    */\n-  BrokerCapacityInfo capacityForBroker(String rack, String host, int brokerId) throws TimeoutException;\n+  BrokerCapacityInfo capacityForBroker(String rack, String host, int brokerId, long timeoutMs) throws TimeoutException;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwNDA3OA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369304078", "bodyText": "Looks like this sanity check can be moved to a static function -- can we also add a unit test for this sanity check? Also can we add a comment to explain why the missing CPU resource is ok? Shouldn't the cpu resource capacity be defined regardless of num cores are defined or not?", "author": "efeg", "createdAt": "2020-01-21T23:45:28Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java", "diffHunk": "@@ -29,6 +31,16 @@ public BrokerCapacityInfo(Map<Resource, Double> capacity,\n                             String estimationInfo,\n                             Map<String, Double> diskCapacityByLogDir,\n                             short numCpuCores) {\n+    Set<Resource> providedResource = capacity.keySet();\n+    Set<Resource> missingResource = new HashSet<>();\n+    for (Resource resource : Resource.cachedValues()) {\n+      if (!providedResource.contains(resource) && resource != Resource.CPU) {\n+        missingResource.add(resource);\n+      }\n+    }\n+    if (!missingResource.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Provided capacity information missing value for resource %s.\", missingResource));\n+    }", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21d6ecd81492c704fd80ecc2246ad36630c9b456", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java\nindex 8b01a1e1..069db67d 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java\n\n@@ -31,16 +31,7 @@ public class BrokerCapacityInfo {\n                             String estimationInfo,\n                             Map<String, Double> diskCapacityByLogDir,\n                             short numCpuCores) {\n-    Set<Resource> providedResource = capacity.keySet();\n-    Set<Resource> missingResource = new HashSet<>();\n-    for (Resource resource : Resource.cachedValues()) {\n-      if (!providedResource.contains(resource) && resource != Resource.CPU) {\n-        missingResource.add(resource);\n-      }\n-    }\n-    if (!missingResource.isEmpty()) {\n-      throw new IllegalArgumentException(String.format(\"Provided capacity information missing value for resource %s.\", missingResource));\n-    }\n+    sanityCheckCapcity(capacity);\n     _capacity = capacity;\n     _estimationInfo = estimationInfo == null ? DEFAULT_ESTIMATION_INFO : estimationInfo;\n     _diskCapacityByLogDir = diskCapacityByLogDir;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTE1Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369309153", "bodyText": "If we intend to propagate TimeoutException all the way to higher layers, can we update the JavaDoc as we did for NotEnoughValidWindowsException for consistency? Alternatively, would it be cleaner to return null if the cluster model creation has failed due to not being able to resolve the cluster capacity, and handle the null cluster capacity response?", "author": "efeg", "createdAt": "2020-01-22T00:03:05Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java", "diffHunk": "@@ -473,7 +474,7 @@ public ClusterModel clusterModel(long from,\n                                    ModelCompletenessRequirements requirements,\n                                    boolean populateReplicaPlacementInfo,\n                                    OperationProgress operationProgress)\n-      throws NotEnoughValidWindowsException {\n+      throws NotEnoughValidWindowsException, TimeoutException {", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc0MTA2MA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369741060", "bodyText": "I prefer the first approach. Because if the cluster model is unable to generate, there is nothing CC should do other than notify the user about the error.", "author": "kidkun", "createdAt": "2020-01-22T18:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTE1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "21d6ecd81492c704fd80ecc2246ad36630c9b456", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\nindex fe5aa4a5..859ada03 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\n\n@@ -468,6 +471,7 @@ public class LoadMonitor {\n    * @param operationProgress the progress of the job to report.\n    * @return A cluster model with the available snapshots whose timestamp is in the given window.\n    * @throws NotEnoughValidWindowsException If there is not enough sample to generate cluster model.\n+   * @throws TimeoutException If broker capacity resolver is unable to resolve broker capacity.\n    */\n   public ClusterModel clusterModel(long from,\n                                    long to,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTI3OA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369309278", "bodyText": "Nit: Missing space before Capacity.", "author": "efeg", "createdAt": "2020-01-22T00:03:33Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -442,18 +450,26 @@ static void populatePartitionLoad(Cluster cluster,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n+    Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n       boolean needToAdjustCpuUsage = true;\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n-        // Note that we assume the capacity resolver can still return the broker capacity even if the broker\n-        // is dead. We need this to get the host resource capacity.\n-        BrokerCapacityInfo brokerCapacity =\n-            brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        BrokerCapacityInfo brokerCapacity;\n+        try {\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        } catch (TimeoutException tme) {\n+          //Capacity resolver may not be able to return the capacity information of dead brokers.", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21d6ecd81492c704fd80ecc2246ad36630c9b456", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\nindex 19fd91e3..e56fd5f0 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n\n@@ -452,20 +453,22 @@ public class MonitorUtils {\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n                                     BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n-    Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n+      Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n       boolean needToAdjustCpuUsage = true;\n+      Set<Integer> deadBrokers = new HashSet<>();\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n         BrokerCapacityInfo brokerCapacity;\n         try {\n-          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n         } catch (TimeoutException tme) {\n-          //Capacity resolver may not be able to return the capacity information of dead brokers.\n+          // Capacity resolver may not be able to return the capacity information of dead brokers.\n           if (!aliveBrokers.contains(replica.id())) {\n             brokerCapacity = new BrokerCapacityInfo(EMPTY_BROKER_CAPACITY);\n+            deadBrokers.add(replica.id());\n           } else {\n             throw tme;\n           }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTQ0NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369309445", "bodyText": "Should we (bulk) log this empty broker capacity assignment?", "author": "efeg", "createdAt": "2020-01-22T00:04:12Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -442,18 +450,26 @@ static void populatePartitionLoad(Cluster cluster,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n+    Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n       boolean needToAdjustCpuUsage = true;\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n-        // Note that we assume the capacity resolver can still return the broker capacity even if the broker\n-        // is dead. We need this to get the host resource capacity.\n-        BrokerCapacityInfo brokerCapacity =\n-            brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        BrokerCapacityInfo brokerCapacity;\n+        try {\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        } catch (TimeoutException tme) {\n+          //Capacity resolver may not be able to return the capacity information of dead brokers.\n+          if (!aliveBrokers.contains(replica.id())) {\n+            brokerCapacity = new BrokerCapacityInfo(EMPTY_BROKER_CAPACITY);", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21d6ecd81492c704fd80ecc2246ad36630c9b456", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\nindex 19fd91e3..e56fd5f0 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n\n@@ -452,20 +453,22 @@ public class MonitorUtils {\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n                                     BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n-    Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n+      Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n       boolean needToAdjustCpuUsage = true;\n+      Set<Integer> deadBrokers = new HashSet<>();\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n         BrokerCapacityInfo brokerCapacity;\n         try {\n-          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n         } catch (TimeoutException tme) {\n-          //Capacity resolver may not be able to return the capacity information of dead brokers.\n+          // Capacity resolver may not be able to return the capacity information of dead brokers.\n           if (!aliveBrokers.contains(replica.id())) {\n             brokerCapacity = new BrokerCapacityInfo(EMPTY_BROKER_CAPACITY);\n+            deadBrokers.add(replica.id());\n           } else {\n             throw tme;\n           }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTgxMg==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369309812", "bodyText": "Should we move this inside if (partitionInfo != null)?", "author": "efeg", "createdAt": "2020-01-22T00:05:35Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -442,18 +450,26 @@ static void populatePartitionLoad(Cluster cluster,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n+    Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21d6ecd81492c704fd80ecc2246ad36630c9b456", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\nindex 19fd91e3..e56fd5f0 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n\n@@ -452,20 +453,22 @@ public class MonitorUtils {\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n                                     BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n-    Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n+      Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n       boolean needToAdjustCpuUsage = true;\n+      Set<Integer> deadBrokers = new HashSet<>();\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n         BrokerCapacityInfo brokerCapacity;\n         try {\n-          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n         } catch (TimeoutException tme) {\n-          //Capacity resolver may not be able to return the capacity information of dead brokers.\n+          // Capacity resolver may not be able to return the capacity information of dead brokers.\n           if (!aliveBrokers.contains(replica.id())) {\n             brokerCapacity = new BrokerCapacityInfo(EMPTY_BROKER_CAPACITY);\n+            deadBrokers.add(replica.id());\n           } else {\n             throw tme;\n           }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxMTM5Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369311393", "bodyText": "Nit: core number -> number of CPU cores", "author": "efeg", "createdAt": "2020-01-22T00:11:21Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java", "diffHunk": "@@ -76,9 +77,14 @@ private void updateCachedNumCoresByBroker(Cluster cluster) {\n           LOG.warn(\"Received metrics from unrecognized broker {}.\", bid);\n           return null;\n         }\n-        BrokerCapacityInfo capacity = _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid);\n-        // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n-        return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+        try {\n+          BrokerCapacityInfo capacity = _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid);\n+          // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n+          return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+        } catch (TimeoutException tme) {\n+          LOG.warn(\"Unable to get core number of broker {}.\", node.id());", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21d6ecd81492c704fd80ecc2246ad36630c9b456", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java\nindex f8da5a17..0d46f30f 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java\n\n@@ -78,11 +81,12 @@ public class CruiseControlMetricsProcessor {\n           return null;\n         }\n         try {\n-          BrokerCapacityInfo capacity = _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid);\n+          BrokerCapacityInfo capacity =\n+              _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid, BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n           // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n           return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n         } catch (TimeoutException tme) {\n-          LOG.warn(\"Unable to get core number of broker {}.\", node.id());\n+          LOG.warn(\"Unable to get number of CPU cores for broker {}.\", node.id());\n           return null;\n         }\n       });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxMTcyNw==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369311727", "bodyText": "Can we update the JavaDoc to indicate cases that a null response is expected? Can we add a unit test to verify the return of expected null response?", "author": "efeg", "createdAt": "2020-01-22T00:12:41Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java", "diffHunk": "@@ -76,9 +77,14 @@ private void updateCachedNumCoresByBroker(Cluster cluster) {\n           LOG.warn(\"Received metrics from unrecognized broker {}.\", bid);\n           return null;\n         }\n-        BrokerCapacityInfo capacity = _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid);\n-        // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n-        return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+        try {\n+          BrokerCapacityInfo capacity = _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid);\n+          // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n+          return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+        } catch (TimeoutException tme) {\n+          LOG.warn(\"Unable to get core number of broker {}.\", node.id());\n+          return null;", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21d6ecd81492c704fd80ecc2246ad36630c9b456", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java\nindex f8da5a17..0d46f30f 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java\n\n@@ -78,11 +81,12 @@ public class CruiseControlMetricsProcessor {\n           return null;\n         }\n         try {\n-          BrokerCapacityInfo capacity = _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid);\n+          BrokerCapacityInfo capacity =\n+              _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid, BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n           // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n           return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n         } catch (TimeoutException tme) {\n-          LOG.warn(\"Unable to get core number of broker {}.\", node.id());\n+          LOG.warn(\"Unable to get number of CPU cores for broker {}.\", node.id());\n           return null;\n         }\n       });\n"}}, {"oid": "21d6ecd81492c704fd80ecc2246ad36630c9b456", "url": "https://github.com/linkedin/cruise-control/commit/21d6ecd81492c704fd80ecc2246ad36630c9b456", "message": "Address the feedback.", "committedDate": "2020-01-22T20:58:53Z", "type": "commit"}, {"oid": "ff3c4326c194a2bb879d164471c835098cb148ef", "url": "https://github.com/linkedin/cruise-control/commit/ff3c4326c194a2bb879d164471c835098cb148ef", "message": "remove access.log", "committedDate": "2020-01-22T20:59:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI0Mjc0Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r373242747", "bodyText": "Typo: sanityCheckCapcity -> sanityCheckCapacity", "author": "efeg", "createdAt": "2020-01-30T23:08:23Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java", "diffHunk": "@@ -130,4 +133,17 @@ public String estimationInfo() {\n   public short numCpuCores() {\n     return _numCpuCores;\n   }\n+\n+  /**\n+   * Sanity check to ensure the provided capacity information contains all the resource type.\n+   * @param capacity The provided capacity map.\n+   */\n+  static void sanityCheckCapcity(Map<Resource, Double> capacity) {", "originalCommit": "ff3c4326c194a2bb879d164471c835098cb148ef", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b10af1c5f044415a4e45cbee2b20131217862467", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java\nindex 069db67d..3e0708cc 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java\n\n@@ -138,7 +138,7 @@ public class BrokerCapacityInfo {\n    * Sanity check to ensure the provided capacity information contains all the resource type.\n    * @param capacity The provided capacity map.\n    */\n-  static void sanityCheckCapcity(Map<Resource, Double> capacity) {\n+  static void sanityCheckCapacity(Map<Resource, Double> capacity) {\n     Set<Resource> providedResource = capacity.keySet();\n     Set<Resource> missingResource = Resource.cachedValues().stream().filter(r -> !providedResource.contains(r))\n                                             .collect(Collectors.toSet());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI0NjA4Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r373246086", "bodyText": "How do we handle the case, where a broker has become unavailable (e.g. dead) after the cluster information is received from _metadataClient.refreshMetadata()?", "author": "efeg", "createdAt": "2020-01-30T23:19:21Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java", "diffHunk": "@@ -510,7 +515,7 @@ public ClusterModel clusterModel(long from,\n         // If the rack is not specified, we use the host info as rack info.\n         String rack = getRackHandleNull(node);\n         clusterModel.createRack(rack);\n-        BrokerCapacityInfo brokerCapacity = _brokerCapacityConfigResolver.capacityForBroker(rack, node.host(), node.id());\n+        BrokerCapacityInfo brokerCapacity = _brokerCapacityConfigResolver.capacityForBroker(rack, node.host(), node.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS);", "originalCommit": "ff3c4326c194a2bb879d164471c835098cb148ef", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b10af1c5f044415a4e45cbee2b20131217862467", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\nindex 859ada03..4da657ad 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java\n\n@@ -515,9 +515,17 @@ public class LoadMonitor {\n         // If the rack is not specified, we use the host info as rack info.\n         String rack = getRackHandleNull(node);\n         clusterModel.createRack(rack);\n-        BrokerCapacityInfo brokerCapacity = _brokerCapacityConfigResolver.capacityForBroker(rack, node.host(), node.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n-        LOG.debug(\"Get capacity info for broker {}: total capacity {}, capacity by logdir {}.\",\n-                  node.id(), brokerCapacity.capacity().get(Resource.DISK), brokerCapacity.diskCapacityByLogDir());\n+        BrokerCapacityInfo brokerCapacity;\n+        try {\n+          brokerCapacity = _brokerCapacityConfigResolver.capacityForBroker(rack, node.host(), node.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n+          LOG.debug(\"Get capacity info for broker {}: total capacity {}, capacity by logdir {}.\", node.id(),\n+                    brokerCapacity.capacity().get(Resource.DISK), brokerCapacity.diskCapacityByLogDir());\n+        } catch (TimeoutException tme) {\n+          String errorMessage = String.format(\"Unable to retrieve capacity for broker %d. This may be caused by churn in \"\n+                                              + \"the cluster, please retry.\", node.id());\n+          LOG.warn(errorMessage, tme);\n+          throw new TimeoutException(errorMessage);\n+        }\n         clusterModel.createBroker(rack, node.host(), node.id(), brokerCapacity, populateReplicaPlacementInfo);\n       }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI0ODQ5NA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r373248494", "bodyText": "Can we add a log here to indicate why this exception has been thrown and what the user can do to mitigate the issue -- i.e. (1) potentially due to high churn in the cluster (2) retry?", "author": "efeg", "createdAt": "2020-01-30T23:27:44Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -442,18 +451,28 @@ static void populatePartitionLoad(Cluster cluster,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n+      Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n       boolean needToAdjustCpuUsage = true;\n+      Set<Integer> deadBrokers = new HashSet<>();\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n-        // Note that we assume the capacity resolver can still return the broker capacity even if the broker\n-        // is dead. We need this to get the host resource capacity.\n-        BrokerCapacityInfo brokerCapacity =\n-            brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        BrokerCapacityInfo brokerCapacity;\n+        try {\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n+        } catch (TimeoutException tme) {\n+          // Capacity resolver may not be able to return the capacity information of dead brokers.\n+          if (!aliveBrokers.contains(replica.id())) {\n+            brokerCapacity = new BrokerCapacityInfo(EMPTY_BROKER_CAPACITY);\n+            deadBrokers.add(replica.id());\n+          } else {\n+            throw tme;", "originalCommit": "ff3c4326c194a2bb879d164471c835098cb148ef", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b10af1c5f044415a4e45cbee2b20131217862467", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\nindex e56fd5f0..5ad87003 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n\n@@ -457,7 +457,7 @@ public class MonitorUtils {\n     if (partitionInfo != null) {\n       Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n       boolean needToAdjustCpuUsage = true;\n-      Set<Integer> deadBrokers = new HashSet<>();\n+      Set<Integer> deadBrokersWithUnknownCapacity = new HashSet<>();\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI2NjAyNg==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r373266026", "bodyText": "Can we rename this to deadBrokersWithUnknownCapacity? -- i.e. it is possible that a broker can be dead, but its capacity can still be resolved depending on whether the capacity resolving service can provide the capacity or not.", "author": "efeg", "createdAt": "2020-01-31T00:33:25Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -442,18 +451,28 @@ static void populatePartitionLoad(Cluster cluster,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n+      Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n       boolean needToAdjustCpuUsage = true;\n+      Set<Integer> deadBrokers = new HashSet<>();", "originalCommit": "ff3c4326c194a2bb879d164471c835098cb148ef", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b10af1c5f044415a4e45cbee2b20131217862467", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\nindex e56fd5f0..5ad87003 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n\n@@ -457,7 +457,7 @@ public class MonitorUtils {\n     if (partitionInfo != null) {\n       Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n       boolean needToAdjustCpuUsage = true;\n-      Set<Integer> deadBrokers = new HashSet<>();\n+      Set<Integer> deadBrokersWithUnknownCapacity = new HashSet<>();\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI2NjM4Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r373266387", "bodyText": "Can we update the message to make it clear that these are not necessarily all the dead brokers, but only the dead brokers, whose capacity cannot be obtained from the capacity resolver?", "author": "efeg", "createdAt": "2020-01-31T00:34:44Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -479,6 +498,9 @@ static void populatePartitionLoad(Cluster cluster,\n                                     valuesAndExtrapolations.windows());\n         needToAdjustCpuUsage = false;\n       }\n+      if (!deadBrokers.isEmpty()) {\n+        LOG.info(\"Assign empty capacity to dead brokers {} in cluster model.\", deadBrokers);", "originalCommit": "ff3c4326c194a2bb879d164471c835098cb148ef", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b10af1c5f044415a4e45cbee2b20131217862467", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\nindex e56fd5f0..5ad87003 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java\n\n@@ -498,8 +501,9 @@ public class MonitorUtils {\n                                     valuesAndExtrapolations.windows());\n         needToAdjustCpuUsage = false;\n       }\n-      if (!deadBrokers.isEmpty()) {\n-        LOG.info(\"Assign empty capacity to dead brokers {} in cluster model.\", deadBrokers);\n+      if (!deadBrokersWithUnknownCapacity.isEmpty()) {\n+        LOG.info(\"Assign empty capacity to brokers {} because they are dead and capacity resolver is unable to fetch their capacity.\",\n+                 deadBrokersWithUnknownCapacity);\n       }\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI2NzIzNA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r373267234", "bodyText": "Should we add , tme to the log?", "author": "efeg", "createdAt": "2020-01-31T00:38:02Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java", "diffHunk": "@@ -76,9 +80,15 @@ private void updateCachedNumCoresByBroker(Cluster cluster) {\n           LOG.warn(\"Received metrics from unrecognized broker {}.\", bid);\n           return null;\n         }\n-        BrokerCapacityInfo capacity = _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid);\n-        // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n-        return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+        try {\n+          BrokerCapacityInfo capacity =\n+              _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid, BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n+          // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n+          return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+        } catch (TimeoutException tme) {\n+          LOG.warn(\"Unable to get number of CPU cores for broker {}.\", node.id());", "originalCommit": "ff3c4326c194a2bb879d164471c835098cb148ef", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b10af1c5f044415a4e45cbee2b20131217862467", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java\nindex 0d46f30f..032a7a83 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java\n\n@@ -86,7 +86,7 @@ public class CruiseControlMetricsProcessor {\n           // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n           return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n         } catch (TimeoutException tme) {\n-          LOG.warn(\"Unable to get number of CPU cores for broker {}.\", node.id());\n+          LOG.warn(\"Unable to get number of CPU cores for broker {}.\", node.id(), tme);\n           return null;\n         }\n       });\n"}}, {"oid": "b10af1c5f044415a4e45cbee2b20131217862467", "url": "https://github.com/linkedin/cruise-control/commit/b10af1c5f044415a4e45cbee2b20131217862467", "message": "Address the feedback.", "committedDate": "2020-01-31T01:51:16Z", "type": "commit"}]}