{"pr_number": 1401, "pr_title": "Honor webserver.api.urlprefix config", "pr_createdAt": "2020-11-24T05:03:06Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1401", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwMTUxMA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530001510", "bodyText": "Can we avoid wildcard imports?", "author": "efeg", "createdAt": "2020-11-24T23:27:05Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/SessionManager.java", "diffHunk": "@@ -30,6 +30,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServletUtils.*;", "originalCommit": "22bba336d1fed726f402e881ae976de1b5dbcacc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26edfc01890b825a2dfef1fa38aa32f4697d1b41", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/SessionManager.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/SessionManager.java\ndeleted file mode 100644\nindex 21a8860a..00000000\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/SessionManager.java\n+++ /dev/null\n\n@@ -1,315 +0,0 @@\n-/*\n- * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n- */\n-\n-package com.linkedin.kafka.cruisecontrol.servlet;\n-\n-import com.codahale.metrics.Gauge;\n-import com.codahale.metrics.Meter;\n-import com.codahale.metrics.MetricRegistry;\n-import com.codahale.metrics.Timer;\n-import com.linkedin.cruisecontrol.servlet.EndPoint;\n-import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.OperationFuture;\n-import com.linkedin.kafka.cruisecontrol.common.KafkaCruiseControlThreadFactory;\n-import com.linkedin.kafka.cruisecontrol.servlet.parameters.ParameterUtils;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.function.Supplier;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpSession;\n-import org.apache.kafka.common.utils.Time;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServletUtils.*;\n-\n-\n-/**\n- * A class that helps track the http sessions and their corresponding operations.\n- *\n- * When an {@link HttpServletRequest} executes a long operation. The servlet will submit an asynchronous operation and\n- * return the progress of that operation instead of blocking waiting for the operation to finish. In that case, the\n- * {@link HttpSession} of that HttpServletRequest will be recorded by the servlet. Next time when the same client\n- * issue the same request again, it will resume the operation requested last time.\n- *\n- * If an HttpSession is recorded for a request with a request URL, it is required that the same request URL should be\n- * issued again from the same session until the asynchronous operation is finished. Otherwise an exception will\n- * be returned.\n- */\n-public class SessionManager {\n-  private static final Logger LOG = LoggerFactory.getLogger(SessionManager.class);\n-  private final int _capacity;\n-  private final long _sessionExpiryMs;\n-  private final Map<HttpSession, SessionInfo> _inProgressSessions;\n-  private final Time _time;\n-  private final ScheduledExecutorService _sessionCleaner =\n-      Executors.newSingleThreadScheduledExecutor(new KafkaCruiseControlThreadFactory(\"SessionCleaner\",\n-                                                                                     true,\n-                                                                                     null));\n-  private final Timer _sessionLifetimeTimer;\n-  private final Meter _sessionCreationFailureMeter;\n-  private final Map<EndPoint, Timer> _successfulRequestExecutionTimer;\n-\n-  /**\n-   * Construct the session manager.\n-   * @param capacity the maximum of sessions allowed to exist at the same time.\n-   * @param sessionExpiryMs the maximum time to wait before expire an inactive session.\n-   * @param time the time object for unit test.\n-   * @param dropwizardMetricRegistry the metric registry to record metrics.\n-   */\n-  SessionManager(int capacity,\n-                 long sessionExpiryMs,\n-                 Time time,\n-                 MetricRegistry dropwizardMetricRegistry,\n-                 Map<EndPoint, Timer> successfulRequestExecutionTimer) {\n-    _capacity = capacity;\n-    _sessionExpiryMs = sessionExpiryMs;\n-    _time = time;\n-    _inProgressSessions = new HashMap<>();\n-    _sessionCleaner.scheduleAtFixedRate(new ExpiredSessionCleaner(), 0, 5, TimeUnit.SECONDS);\n-    _successfulRequestExecutionTimer = successfulRequestExecutionTimer;\n-    // Metrics registration\n-    _sessionLifetimeTimer = dropwizardMetricRegistry.timer(MetricRegistry.name(\"SessionManager\", \"session-lifetime-timer\"));\n-    _sessionCreationFailureMeter = dropwizardMetricRegistry.meter(MetricRegistry.name(\"SessionManager\", \"session-creation-failure-rate\"));\n-    dropwizardMetricRegistry.register(MetricRegistry.name(\"SessionManager\", \"num-active-sessions\"),\n-                                      (Gauge<Integer>) _inProgressSessions::size);\n-\n-  }\n-\n-  /**\n-   * Close the session manager.\n-   */\n-  public void close() {\n-    _sessionCleaner.shutdownNow();\n-  }\n-\n-  /**\n-   * @return Total number of active sessions.\n-   */\n-  synchronized int numSessions() {\n-    return _inProgressSessions.size();\n-  }\n-\n-  /**\n-   * Create the session for the request if needed.\n-   *\n-   * @param request the HttpServletRequest to create session for.\n-   * @param operation the async operation that returns an {@link OperationFuture}\n-   * @param step the index of the step whose future needs to be added or get.\n-   *\n-   * @return The {@link OperationFuture} for the provided async operation.\n-   */\n-  synchronized OperationFuture getAndCreateSessionIfNotExist(HttpServletRequest request,\n-                                                             Supplier<OperationFuture> operation,\n-                                                             int step) {\n-    HttpSession session = request.getSession();\n-    SessionInfo info = _inProgressSessions.get(session);\n-    String requestString = toRequestString(request);\n-    // Session exists.\n-    if (info != null) {\n-      LOG.info(\"Found existing session {}\", session);\n-      info.ensureSameRequest(requestString, request.getParameterMap());\n-      // If there is next future return it.\n-      if (step < info.numFutures()) {\n-        return info.future(step);\n-      } else if (step == info.numFutures()) {\n-        LOG.info(\"Adding new future to existing session {}.\", session);\n-        // if there is no next future, add the future to the next list.\n-        OperationFuture future = operation.get();\n-        info.addFuture(future);\n-        return future;\n-      } else {\n-        throw new IllegalArgumentException(String.format(\"There are %d steps in the session. Cannot add step %d.\",\n-                                                         info.numFutures(), step));\n-      }\n-    } else {\n-      if (step > 0) {\n-        throw new IllegalArgumentException(String.format(\"There are no step in the session. Cannot add step %d.\", step));\n-      }\n-      // The session does not exist, add it.\n-      if (_inProgressSessions.size() >= _capacity) {\n-        _sessionCreationFailureMeter.mark();\n-        throw new RuntimeException(\"There are already \" + _inProgressSessions.size() + \" active sessions, which \"\n-                                   + \"has reached the servlet capacity.\");\n-      }\n-      LOG.info(\"Created session for {}\", session);\n-      info = new SessionInfo(requestString, request.getParameterMap(), ParameterUtils.endPoint(request, REQUEST_URI));\n-      OperationFuture future = operation.get();\n-      info.addFuture(future);\n-      _inProgressSessions.put(session, info);\n-      return future;\n-    }\n-  }\n-\n-  /**\n-   * Get the {@link OperationFuture} for the request.\n-   * @param request the request to get the operation future.\n-   * @param <T> the returned future type.\n-   * @return The operation future for the request if it exists, otherwise {@code null} is returned.\n-   */\n-  @SuppressWarnings(\"unchecked\")\n-  synchronized <T> T getFuture(HttpServletRequest request) {\n-    SessionInfo info = _inProgressSessions.get(request.getSession());\n-    if (info == null) {\n-      return null;\n-    } else if (!info.requestUrl().equals(toRequestString(request))) {\n-      throw new IllegalStateException(\"The session has an ongoing operation \" + info.requestUrl() + \" while it \"\n-                                      + \"is trying another operation of \" + toRequestString(request));\n-    }\n-    return (T) info.lastFuture();\n-  }\n-\n-  /**\n-   * Close the session for the given request.\n-   * @param request the request to close its session.\n-   * @param hasError whether the session is closed due to an error or not.\n-   */\n-  synchronized void closeSession(HttpServletRequest request, boolean hasError) {\n-    // Response associated with this request has already been flushed; hence, do not attempt to create a new session.\n-    HttpSession session = request.getSession(false);\n-    if (session == null) {\n-      return;\n-    }\n-    SessionInfo info = _inProgressSessions.remove(session);\n-    if (info != null && info.lastFuture().isDone()) {\n-      LOG.info(\"Closing session {}\", session);\n-      session.invalidate();\n-      _sessionLifetimeTimer.update(System.nanoTime() - info.requestStartTimeNs(), TimeUnit.NANOSECONDS);\n-      if (!hasError && info.executionTime() > 0) {\n-        _successfulRequestExecutionTimer.get(info.endPoint()).update(info.executionTime(), TimeUnit.NANOSECONDS);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Expire the sessions that have been inactive for more than configured expiration time.\n-   */\n-  synchronized void expireOldSessions() {\n-    long now = _time.milliseconds();\n-    Iterator<Map.Entry<HttpSession, SessionInfo>> iter = _inProgressSessions.entrySet().iterator();\n-    while (iter.hasNext()) {\n-      Map.Entry<HttpSession, SessionInfo> entry = iter.next();\n-      HttpSession session = entry.getKey();\n-      SessionInfo info = entry.getValue();\n-      if (LOG.isTraceEnabled()) {\n-        LOG.trace(\"Session {} was last accessed at {}, age is {} ms\", session, session.getLastAccessedTime(),\n-                  now - session.getLastAccessedTime());\n-      }\n-      if (now >= session.getLastAccessedTime() + _sessionExpiryMs) {\n-        LOG.info(\"Expiring session {}.\", session);\n-        iter.remove();\n-        session.invalidate();\n-        _sessionLifetimeTimer.update(System.nanoTime() - info.requestStartTimeNs(), TimeUnit.NANOSECONDS);\n-        if (info.lastFuture().isDone() && info.executionTime() > 0) {\n-          _successfulRequestExecutionTimer.get(info.endPoint()).update(info.executionTime(), TimeUnit.NANOSECONDS);\n-        } else {\n-          info.lastFuture().cancel(true);\n-        }\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Container class to host the future and the request url for verification.\n-   */\n-  private static class SessionInfo {\n-    private final String _requestUrl;\n-    private final Map<String, String[]> _requestParameters;\n-    private final List<OperationFuture> _operationFuture;\n-    private final long _requestStartTimeNs;\n-    private final EndPoint _endPoint;\n-\n-    private SessionInfo(String requestUrl, Map<String, String[]> requestParameters, EndPoint endPoint) {\n-      _operationFuture = new ArrayList<>();\n-      _requestUrl = requestUrl;\n-      _requestParameters = requestParameters;\n-      _requestStartTimeNs = System.nanoTime();\n-      _endPoint = endPoint;\n-    }\n-\n-    private int numFutures() {\n-      return _operationFuture.size();\n-    }\n-\n-    private void addFuture(OperationFuture future) {\n-      _operationFuture.add(future);\n-    }\n-\n-    private OperationFuture future(int index) {\n-      return _operationFuture.get(index);\n-    }\n-\n-    private OperationFuture lastFuture() {\n-      return _operationFuture.get(_operationFuture.size() - 1);\n-    }\n-\n-    private String requestUrl() {\n-      return _requestUrl;\n-    }\n-\n-    private long requestStartTimeNs() {\n-      return _requestStartTimeNs;\n-    }\n-\n-    private long executionTime() {\n-      return lastFuture().finishTimeNs() == -1 ? -1 : lastFuture().finishTimeNs() - _requestStartTimeNs;\n-    }\n-\n-    private EndPoint endPoint() {\n-      return _endPoint;\n-    }\n-\n-    private boolean paramEquals(Map<String, String[]> parameters) {\n-      boolean isSameParameters = _requestParameters.keySet().equals(parameters.keySet());\n-      if (isSameParameters) {\n-        for (Map.Entry<String, String[]> entry : _requestParameters.entrySet()) {\n-          Set<String> param1 = new HashSet<>(Arrays.asList(entry.getValue()));\n-          Set<String> param2 = new HashSet<>(Arrays.asList(parameters.get(entry.getKey())));\n-          if (!param1.equals(param2)) {\n-            return false;\n-          }\n-        }\n-      }\n-      return isSameParameters;\n-    }\n-\n-    private void ensureSameRequest(String requestUrl, Map<String, String[]> parameters) {\n-      if (!_requestUrl.equals(requestUrl) || !paramEquals(parameters)) {\n-        throw new IllegalStateException(String.format(\n-            \"The session has an ongoing operation [URL: %s, Parameters: %s] \"\n-            + \"while it is trying another operation of [URL: %s, Parameters: %s].\",\n-            _requestUrl, _requestParameters, requestUrl, parameters));\n-      }\n-    }\n-  }\n-\n-  private static String toRequestString(HttpServletRequest request) {\n-    return String.format(\"%s(%s %s)\",\n-                         request.getClass().getSimpleName(),\n-                         request.getMethod(),\n-                         request.getRequestURI());\n-  }\n-\n-  /**\n-   * A runnable class to expire the old sessions.\n-   */\n-  private class ExpiredSessionCleaner implements Runnable {\n-    @Override\n-    public void run() {\n-      try {\n-        expireOldSessions();\n-      } catch (Throwable t) {\n-        LOG.warn(\"Received exception when trying to expire sessions.\", t);\n-      }\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwMTc4NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530001785", "bodyText": "If this PR honors configurable request URI, can we drop this hardcoded value?\n\n  \n    \n      cruise-control/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java\n    \n    \n        Lines 38 to 39\n      in\n      5ed774e\n    \n    \n    \n    \n\n        \n          \n           // FIXME: Read this from a configuration \n        \n\n        \n          \n           public static final String REQUEST_URI = \"/KAFKACRUISECONTROL/\";", "author": "efeg", "createdAt": "2020-11-24T23:27:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java", "diffHunk": "@@ -193,7 +193,7 @@ static String urlEncode(String s) throws UnsupportedEncodingException {\n    */\n   static CruiseControlEndPoint getValidEndpoint(HttpServletRequest request, HttpServletResponse response, KafkaCruiseControlConfig config)\n       throws IOException {\n-    CruiseControlEndPoint endPoint = endPoint(request);\n+    CruiseControlEndPoint endPoint = endPoint(request, config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG));\n     if (endPoint == null) {\n       String method = request.getMethod();\n       String errorMessage = String.format(\"Unrecognized endpoint in request '%s'%nSupported %s endpoints: %s\",", "originalCommit": "22bba336d1fed726f402e881ae976de1b5dbcacc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA4MTA1OA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530081058", "bodyText": "Yes. I agree that we can drop this value and (indirectly) use the default web server API URL prefix value DEFAULT_WEBSERVER_API_URLPREFIX", "author": "Lincong", "createdAt": "2020-11-25T03:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwMTc4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java\nindex 0b9c6b71..4b667fc3 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java\n\n@@ -193,7 +193,8 @@ public class KafkaCruiseControlServletUtils {\n    */\n   static CruiseControlEndPoint getValidEndpoint(HttpServletRequest request, HttpServletResponse response, KafkaCruiseControlConfig config)\n       throws IOException {\n-    CruiseControlEndPoint endPoint = endPoint(request, config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG));\n+    String apiUrlPrefix = config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG);\n+    CruiseControlEndPoint endPoint = endPoint(request, apiUrlPrefix);\n     if (endPoint == null) {\n       String method = request.getMethod();\n       String errorMessage = String.format(\"Unrecognized endpoint in request '%s'%nSupported %s endpoints: %s\",\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwOTM1OA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530009358", "bodyText": "According to the Java Servlet specification, the config WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG must end with /* suffix.\n\nThe following comment seems incomplete:\n\n\n  \n    \n      cruise-control/config/cruisecontrol.properties\n    \n    \n        Lines 325 to 327\n      in\n      5ed774e\n    \n    \n    \n    \n\n        \n          \n           # REST API default prefix \n        \n\n        \n          \n           # (dont forget the ending *) \n        \n\n        \n          \n           webserver.api.urlprefix=/kafkacruisecontrol/* \n        \n    \n  \n\n\nCan we update it to say:\n# REST API default prefix (dont forget the ending /*)\n\n\nWe don't have any sanity check to enforce this suffix upon configuration time. Can we add a sanity check for WEBSERVER_API_URLPREFIX_CONFIG under KafkaCruiseControlConfig?", "author": "efeg", "createdAt": "2020-11-24T23:35:22Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java", "diffHunk": "@@ -193,7 +193,7 @@ static String urlEncode(String s) throws UnsupportedEncodingException {\n    */\n   static CruiseControlEndPoint getValidEndpoint(HttpServletRequest request, HttpServletResponse response, KafkaCruiseControlConfig config)\n       throws IOException {\n-    CruiseControlEndPoint endPoint = endPoint(request);\n+    CruiseControlEndPoint endPoint = endPoint(request, config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG));\n     if (endPoint == null) {\n       String method = request.getMethod();\n       String errorMessage = String.format(\"Unrecognized endpoint in request '%s'%nSupported %s endpoints: %s\",", "originalCommit": "22bba336d1fed726f402e881ae976de1b5dbcacc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java\nindex 0b9c6b71..4b667fc3 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java\n\n@@ -193,7 +193,8 @@ public class KafkaCruiseControlServletUtils {\n    */\n   static CruiseControlEndPoint getValidEndpoint(HttpServletRequest request, HttpServletResponse response, KafkaCruiseControlConfig config)\n       throws IOException {\n-    CruiseControlEndPoint endPoint = endPoint(request, config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG));\n+    String apiUrlPrefix = config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG);\n+    CruiseControlEndPoint endPoint = endPoint(request, apiUrlPrefix);\n     if (endPoint == null) {\n       String method = request.getMethod();\n       String errorMessage = String.format(\"Unrecognized endpoint in request '%s'%nSupported %s endpoints: %s\",\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxMjM4Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530012386", "bodyText": "apiUrlPrefix must end with /* -- i.e. failure of this condition must result in a configuration time failure.\nHence, this if check is redundant.", "author": "efeg", "createdAt": "2020-11-24T23:38:35Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java", "diffHunk": "@@ -177,7 +177,11 @@ public static CruiseControlEndPoint endPoint(HttpServletRequest request) {\n         throw new UserRequestException(\"Unsupported request method: \" + request.getMethod() + \".\");\n     }\n \n-    String path = request.getRequestURI().toUpperCase().replace(REQUEST_URI, \"\");\n+    if (apiUrlPrefix.endsWith(\"/*\")) {", "originalCommit": "22bba336d1fed726f402e881ae976de1b5dbcacc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26edfc01890b825a2dfef1fa38aa32f4697d1b41", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java\nindex e7f0806a..6ce58a62 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java\n\n@@ -177,10 +181,8 @@ public class ParameterUtils {\n         throw new UserRequestException(\"Unsupported request method: \" + request.getMethod() + \".\");\n     }\n \n-    if (apiUrlPrefix.endsWith(\"/*\")) {\n-      // Ignore the last character '*'\n-      apiUrlPrefix = apiUrlPrefix.substring(0, apiUrlPrefix.length() - 1);\n-    }\n+    // Ignore the last character '*' since the API URL prefix must end with \"/*\",\n+    apiUrlPrefix = apiUrlPrefix.substring(0, apiUrlPrefix.length() - 1);\n     String path = request.getRequestURI().toUpperCase().replace(apiUrlPrefix.toUpperCase(), \"\");\n     for (CruiseControlEndPoint endPoint : supportedEndpoints) {\n       if (endPoint.toString().equalsIgnoreCase(path)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjI3NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530016275", "bodyText": "Do we have to do this pruning and upper case conversion for apiUrlPrefix for every single request that hits a CC endpoint?\napiUrlPrefix is already known at configuration time -- i.e. it won't change throughout the lifetime of this CC instance. So can't we initialize this static util class with the well-formatted REQUEST_URI (which is constructed by pruning and upper case conversion of WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG once) and use that here as before?", "author": "efeg", "createdAt": "2020-11-24T23:44:49Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java", "diffHunk": "@@ -177,7 +177,11 @@ public static CruiseControlEndPoint endPoint(HttpServletRequest request) {\n         throw new UserRequestException(\"Unsupported request method: \" + request.getMethod() + \".\");\n     }\n \n-    String path = request.getRequestURI().toUpperCase().replace(REQUEST_URI, \"\");\n+    if (apiUrlPrefix.endsWith(\"/*\")) {\n+      // Ignore the last character '*'\n+      apiUrlPrefix = apiUrlPrefix.substring(0, apiUrlPrefix.length() - 1);\n+    }\n+    String path = request.getRequestURI().toUpperCase().replace(apiUrlPrefix.toUpperCase(), \"\");", "originalCommit": "22bba336d1fed726f402e881ae976de1b5dbcacc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA5NjMxNw==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530096317", "bodyText": "It's not a good practice to use a static class to \"cache\" any value. A static method should be 100% stateless. So I strongly prefer to just stick with the current implementation with the blow change:\n    if (!apiUrlPrefix.endsWith(\"/*\")) {\n      throw new IllegalArgumentException(\"API URL prefix should end with \\\"/*\\\". Got: \" + apiUrlPrefix));\n    }\n\nIn this approach, we need to do this pruning and upper case conversion for every single request. It's not a big deal. If we really want to save this \"overhead\". We will need to think of some way that does not use the static method/class. However, that might over-complicate the whole thing. So, I prefer to stick with this approach.", "author": "Lincong", "createdAt": "2020-11-25T04:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzQ1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530613450", "bodyText": "Discussed offline and we decided to stick with the current implementation for now. In the future, we can consider using Dagger 2", "author": "Lincong", "createdAt": "2020-11-25T19:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjI3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "26edfc01890b825a2dfef1fa38aa32f4697d1b41", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java\nindex e7f0806a..6ce58a62 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java\n\n@@ -177,10 +181,8 @@ public class ParameterUtils {\n         throw new UserRequestException(\"Unsupported request method: \" + request.getMethod() + \".\");\n     }\n \n-    if (apiUrlPrefix.endsWith(\"/*\")) {\n-      // Ignore the last character '*'\n-      apiUrlPrefix = apiUrlPrefix.substring(0, apiUrlPrefix.length() - 1);\n-    }\n+    // Ignore the last character '*' since the API URL prefix must end with \"/*\",\n+    apiUrlPrefix = apiUrlPrefix.substring(0, apiUrlPrefix.length() - 1);\n     String path = request.getRequestURI().toUpperCase().replace(apiUrlPrefix.toUpperCase(), \"\");\n     for (CruiseControlEndPoint endPoint : supportedEndpoints) {\n       if (endPoint.toString().equalsIgnoreCase(path)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjk1OA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530016958", "bodyText": "Passing config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG) to endpoint seems redundant (please see my comment on ParameterUtils#endPoint )", "author": "efeg", "createdAt": "2020-11-24T23:46:44Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java", "diffHunk": "@@ -193,7 +193,7 @@ static String urlEncode(String s) throws UnsupportedEncodingException {\n    */\n   static CruiseControlEndPoint getValidEndpoint(HttpServletRequest request, HttpServletResponse response, KafkaCruiseControlConfig config)\n       throws IOException {\n-    CruiseControlEndPoint endPoint = endPoint(request);\n+    CruiseControlEndPoint endPoint = endPoint(request, config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG));", "originalCommit": "22bba336d1fed726f402e881ae976de1b5dbcacc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA5NjQwNA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530096404", "bodyText": "Replied to the previous comment", "author": "Lincong", "createdAt": "2020-11-25T04:11:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjk1OA=="}], "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java\nindex 0b9c6b71..4b667fc3 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java\n\n@@ -193,7 +193,8 @@ public class KafkaCruiseControlServletUtils {\n    */\n   static CruiseControlEndPoint getValidEndpoint(HttpServletRequest request, HttpServletResponse response, KafkaCruiseControlConfig config)\n       throws IOException {\n-    CruiseControlEndPoint endPoint = endPoint(request, config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG));\n+    String apiUrlPrefix = config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG);\n+    CruiseControlEndPoint endPoint = endPoint(request, apiUrlPrefix);\n     if (endPoint == null) {\n       String method = request.getMethod();\n       String errorMessage = String.format(\"Unrecognized endpoint in request '%s'%nSupported %s endpoints: %s\",\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxODUzNg==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530018536", "bodyText": "REQUEST_URI is a malformed _apiUrlPrefix -- i.e. it does not end with * -- hence, it shall not be used interchangeably here.\nWith the proposed change in ParameterUtils (please see earlier comment), we can drop these changes.", "author": "efeg", "createdAt": "2020-11-24T23:51:29Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/UserTaskManager.java", "diffHunk": "@@ -136,6 +138,7 @@ protected boolean removeEldestEntry(Map.Entry<UUID, UserTaskInfo> eldest) {\n     }\n     _sessionExpiryMs = sessionExpiryMs;\n     _maxActiveUserTasks = maxActiveUserTasks;\n+    _apiUrlPrefix = KafkaCruiseControlServletUtils.REQUEST_URI;", "originalCommit": "22bba336d1fed726f402e881ae976de1b5dbcacc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA5Njc4Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530096782", "bodyText": "I changed it to:\n_apiUrlPrefix = config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG);", "author": "Lincong", "createdAt": "2020-11-25T04:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxODUzNg=="}], "type": "inlineReview", "revised_code": {"commit": "26edfc01890b825a2dfef1fa38aa32f4697d1b41", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/UserTaskManager.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/UserTaskManager.java\nindex 876e8047..49ddd5e6 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/UserTaskManager.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/UserTaskManager.java\n\n@@ -138,7 +138,7 @@ public class UserTaskManager implements Closeable {\n     }\n     _sessionExpiryMs = sessionExpiryMs;\n     _maxActiveUserTasks = maxActiveUserTasks;\n-    _apiUrlPrefix = KafkaCruiseControlServletUtils.REQUEST_URI;\n+    _apiUrlPrefix = WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX;\n     _time = time;\n     _uuidGenerator = uuidGenerator;\n     _userTaskScannerExecutor.scheduleAtFixedRate(new UserTaskScanner(),\n"}}, {"oid": "26edfc01890b825a2dfef1fa38aa32f4697d1b41", "url": "https://github.com/linkedin/cruise-control/commit/26edfc01890b825a2dfef1fa38aa32f4697d1b41", "message": "Fix some issues", "committedDate": "2020-11-25T04:17:29Z", "type": "forcePushed"}, {"oid": "14ade8d35919d7b5a86c03aff54c4ce4533332a2", "url": "https://github.com/linkedin/cruise-control/commit/14ade8d35919d7b5a86c03aff54c4ce4533332a2", "message": "Fix some issues", "committedDate": "2020-11-26T00:09:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwODMwMg==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530708302", "bodyText": "Nit: We are using the expectedUrlPrefixEnd to check both webserverApiUrlPrefix and webserverUiUrlPrefix. Should we name it to something that applies to both? -- e.g. expectedSuffix", "author": "efeg", "createdAt": "2020-11-26T00:34:28Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java", "diffHunk": "@@ -464,6 +464,25 @@ void sanityCheckSecurity() { // visible for testing\n     }\n   }\n \n+  /**\n+   * Sanity check to ensure that webserver URL prefix is set up correctly. This means the following:\n+   *  <code>webserver.api.urlprefix</code> and <code>webserver.ui.urlprefix</code> must end with \"/*\"\n+   */\n+  void sanityCheckWebServerUrlPrefix() { // visible for testing\n+    String expectedUrlPrefixEnd = \"/*\";", "originalCommit": "14ade8d35919d7b5a86c03aff54c4ce4533332a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NTk2Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530755963", "bodyText": "Good idea", "author": "Lincong", "createdAt": "2020-11-26T03:39:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwODMwMg=="}], "type": "inlineReview", "revised_code": {"commit": "8ae006f1d8ee2583a7dc0fa116dba5036fcdb411", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\nindex 134a7de6..c3fec777 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\n\n@@ -469,17 +469,17 @@ public class KafkaCruiseControlConfig extends AbstractConfig {\n    *  <code>webserver.api.urlprefix</code> and <code>webserver.ui.urlprefix</code> must end with \"/*\"\n    */\n   void sanityCheckWebServerUrlPrefix() { // visible for testing\n-    String expectedUrlPrefixEnd = \"/*\";\n+    String expectedSuffix = \"/*\";\n     String webserverApiUrlPrefix = getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG);\n-    if (!webserverApiUrlPrefix.endsWith(expectedUrlPrefixEnd)) {\n+    if (!webserverApiUrlPrefix.endsWith(expectedSuffix)) {\n       throw new ConfigException(String.format(\"Expect value to the config %s ends with %s. Got: %s\",\n-          WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG, expectedUrlPrefixEnd, webserverApiUrlPrefix));\n+          WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG, expectedSuffix, webserverApiUrlPrefix));\n     }\n \n     String webserverUiUrlPrefix = getString(WebServerConfig.WEBSERVER_UI_URLPREFIX_CONFIG);\n-    if (!webserverUiUrlPrefix.endsWith(expectedUrlPrefixEnd)) {\n+    if (!webserverUiUrlPrefix.endsWith(expectedSuffix)) {\n       throw new ConfigException(String.format(\"Expect value to the config %s ends with %s. Got: %s\",\n-          WebServerConfig.WEBSERVER_UI_URLPREFIX_CONFIG, expectedUrlPrefixEnd, webserverUiUrlPrefix));\n+          WebServerConfig.WEBSERVER_UI_URLPREFIX_CONFIG, expectedSuffix, webserverUiUrlPrefix));\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwOTEzMA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530709130", "bodyText": "Looks like we use this function only in tests. Should we move it to a relevant test utility class?", "author": "efeg", "createdAt": "2020-11-26T00:37:23Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java", "diffHunk": "@@ -283,4 +281,10 @@ static void ensureHeaderNotPresent(HttpServletRequest request, String headerName\n   public static String httpServletRequestToString(HttpServletRequest request) {\n     return String.format(\"%s %s\", request.getMethod(), request.getRequestURI());\n   }\n+\n+  public static String getDefaultWebServerApiUrlPrefix() {\n+    // Strip off the '*' from the end of the default web server API URL prefix\n+    return WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX\n+        .substring(0, WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX.length() - 1);\n+  }", "originalCommit": "14ade8d35919d7b5a86c03aff54c4ce4533332a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NjQ2MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530756461", "bodyText": "After adding back the SessionManager class, it will use this method. So, I will leave it here for now and move it to some util test class when we remove SessionManager", "author": "Lincong", "createdAt": "2020-11-26T03:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwOTEzMA=="}], "type": "inlineReview", "revised_code": {"commit": "8ae006f1d8ee2583a7dc0fa116dba5036fcdb411", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java\nindex c06d9d74..4cc642be 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletUtils.java\n\n@@ -281,10 +281,4 @@ public class KafkaCruiseControlServletUtils {\n   public static String httpServletRequestToString(HttpServletRequest request) {\n     return String.format(\"%s %s\", request.getMethod(), request.getRequestURI());\n   }\n-\n-  public static String getDefaultWebServerApiUrlPrefix() {\n-    // Strip off the '*' from the end of the default web server API URL prefix\n-    return WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX\n-        .substring(0, WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX.length() - 1);\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMTc5NA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530711794", "bodyText": "Can we avoid wildcard import?", "author": "efeg", "createdAt": "2020-11-26T00:48:19Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.config;\n+\n+import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n+import org.apache.kafka.common.config.ConfigException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import static org.easymock.EasyMock.*;", "originalCommit": "14ade8d35919d7b5a86c03aff54c4ce4533332a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8ae006f1d8ee2583a7dc0fa116dba5036fcdb411", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java\nindex 70947a02..c5f0b74d 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java\n\n@@ -6,22 +6,22 @@ package com.linkedin.kafka.cruisecontrol.config;\n \n import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n import org.apache.kafka.common.config.ConfigException;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n+import static org.junit.Assert.assertThrows;\n \n-import static org.easymock.EasyMock.*;\n+import static org.easymock.EasyMock.partialMockBuilder;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.easymock.EasyMock.reset;\n \n \n-public class WebserverUrlPrefixConfigTest {\n-\n-  @Rule\n-  public ExpectedException _expectedException = ExpectedException.none();\n+public class WebserverUrlPrefixConfigTest extends AbstractConfigTest {\n \n   @Test\n   public void testWebserverUrlPrefixConfigsCorrectSetup() {\n     KafkaCruiseControlConfig config = partialMockBuilder(KafkaCruiseControlConfig.class)\n-        .addMockedMethod(\"getString\")\n+        .addMockedMethod(GET_STRING_METHOD_NAME)\n         .createNiceMock();\n \n     expect(config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG)).andReturn(\"a/b/c/d/*\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMjE0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530712142", "bodyText": "Let's not use the deprecated API any more. We can instead use Assert.assertThrows to check for expected exceptions.", "author": "efeg", "createdAt": "2020-11-26T00:49:48Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.config;\n+\n+import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n+import org.apache.kafka.common.config.ConfigException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import static org.easymock.EasyMock.*;\n+\n+\n+public class WebserverUrlPrefixConfigTest {\n+\n+  @Rule\n+  public ExpectedException _expectedException = ExpectedException.none();", "originalCommit": "14ade8d35919d7b5a86c03aff54c4ce4533332a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8ae006f1d8ee2583a7dc0fa116dba5036fcdb411", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java\nindex 70947a02..c5f0b74d 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java\n\n@@ -6,22 +6,22 @@ package com.linkedin.kafka.cruisecontrol.config;\n \n import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n import org.apache.kafka.common.config.ConfigException;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n+import static org.junit.Assert.assertThrows;\n \n-import static org.easymock.EasyMock.*;\n+import static org.easymock.EasyMock.partialMockBuilder;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.easymock.EasyMock.reset;\n \n \n-public class WebserverUrlPrefixConfigTest {\n-\n-  @Rule\n-  public ExpectedException _expectedException = ExpectedException.none();\n+public class WebserverUrlPrefixConfigTest extends AbstractConfigTest {\n \n   @Test\n   public void testWebserverUrlPrefixConfigsCorrectSetup() {\n     KafkaCruiseControlConfig config = partialMockBuilder(KafkaCruiseControlConfig.class)\n-        .addMockedMethod(\"getString\")\n+        .addMockedMethod(GET_STRING_METHOD_NAME)\n         .createNiceMock();\n \n     expect(config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG)).andReturn(\"a/b/c/d/*\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMjYxNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530712615", "bodyText": "Can we move all occurrences of the hardcoded \"getString\" to a static final variable?", "author": "efeg", "createdAt": "2020-11-26T00:51:36Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.config;\n+\n+import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n+import org.apache.kafka.common.config.ConfigException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import static org.easymock.EasyMock.*;\n+\n+\n+public class WebserverUrlPrefixConfigTest {\n+\n+  @Rule\n+  public ExpectedException _expectedException = ExpectedException.none();\n+\n+  @Test\n+  public void testWebserverUrlPrefixConfigsCorrectSetup() {\n+    KafkaCruiseControlConfig config = partialMockBuilder(KafkaCruiseControlConfig.class)\n+        .addMockedMethod(\"getString\")", "originalCommit": "14ade8d35919d7b5a86c03aff54c4ce4533332a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1OTMyMA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530759320", "bodyText": "Fixed", "author": "Lincong", "createdAt": "2020-11-26T03:54:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMjYxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "8ae006f1d8ee2583a7dc0fa116dba5036fcdb411", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java\nindex 70947a02..c5f0b74d 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java\n\n@@ -6,22 +6,22 @@ package com.linkedin.kafka.cruisecontrol.config;\n \n import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n import org.apache.kafka.common.config.ConfigException;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n+import static org.junit.Assert.assertThrows;\n \n-import static org.easymock.EasyMock.*;\n+import static org.easymock.EasyMock.partialMockBuilder;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.easymock.EasyMock.reset;\n \n \n-public class WebserverUrlPrefixConfigTest {\n-\n-  @Rule\n-  public ExpectedException _expectedException = ExpectedException.none();\n+public class WebserverUrlPrefixConfigTest extends AbstractConfigTest {\n \n   @Test\n   public void testWebserverUrlPrefixConfigsCorrectSetup() {\n     KafkaCruiseControlConfig config = partialMockBuilder(KafkaCruiseControlConfig.class)\n-        .addMockedMethod(\"getString\")\n+        .addMockedMethod(GET_STRING_METHOD_NAME)\n         .createNiceMock();\n \n     expect(config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG)).andReturn(\"a/b/c/d/*\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMzU1Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530713557", "bodyText": "Since we already have testWebserverUrlPrefixConfigsCorrectSetup can we drop this test?", "author": "efeg", "createdAt": "2020-11-26T00:54:23Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.config;\n+\n+import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n+import org.apache.kafka.common.config.ConfigException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import static org.easymock.EasyMock.*;\n+\n+\n+public class WebserverUrlPrefixConfigTest {\n+\n+  @Rule\n+  public ExpectedException _expectedException = ExpectedException.none();\n+\n+  @Test\n+  public void testWebserverUrlPrefixConfigsCorrectSetup() {\n+    KafkaCruiseControlConfig config = partialMockBuilder(KafkaCruiseControlConfig.class)\n+        .addMockedMethod(\"getString\")\n+        .createNiceMock();\n+\n+    expect(config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG)).andReturn(\"a/b/c/d/*\");\n+    expect(config.getString(WebServerConfig.WEBSERVER_UI_URLPREFIX_CONFIG)).andReturn(\"a/b/c/*\");\n+    replay(config);\n+    config.sanityCheckWebServerUrlPrefix();\n+    verify(config);\n+  }\n+\n+  @Test\n+  public void testWebserverUrlPrefixConfigCorrectSetupOnDefault() {", "originalCommit": "14ade8d35919d7b5a86c03aff54c4ce4533332a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc2MzMyNw==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530763327", "bodyText": "I think the value of this test is to ensure that if those default values ever change to something that is not valid, this test will catch it and the testWebserverUrlPrefixConfigsCorrectSetup serves a different purpose", "author": "Lincong", "createdAt": "2020-11-26T04:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMzU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc2OTY3NA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r532769674", "bodyText": "Don't we have sanity checks in KafkaCruiseControlConfig.java to ensure validity of config values in production regardless of whether they are the default ones or overridden by users?", "author": "efeg", "createdAt": "2020-11-30T17:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMzU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg5NjkyMA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r532896920", "bodyText": "Yes, the sanity checks will catch invalid web server URL prefix. However, invalid URL prefix can only be caught during runtime whereas this test fails the build process if the default webserver URL is invalid.", "author": "Lincong", "createdAt": "2020-11-30T20:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMzU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYxODkxNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533618915", "bodyText": "The existing unit tests already verify (as they should) the behavior of the tested unit with all possible good and bad inputs. The default value is just one such input, whose behavior is known -- because we already tested what such an input would generate. We know that if a future programmer changes the default value, CC will fail to start and provide a meaningful message to help resolve the configuration issue, because it is tested.\nI am against adding individual tests specifically for the default values as it eventually leads to bloating, making a build take longer at CircleCI with no additional testing coverage.", "author": "efeg", "createdAt": "2020-12-01T18:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMzU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg1OTEzNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533859135", "bodyText": "Makes sense. I'll remove it", "author": "Lincong", "createdAt": "2020-12-02T02:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMzU1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8ae006f1d8ee2583a7dc0fa116dba5036fcdb411", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java\nindex 70947a02..c5f0b74d 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/WebserverUrlPrefixConfigTest.java\n\n@@ -6,22 +6,22 @@ package com.linkedin.kafka.cruisecontrol.config;\n \n import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n import org.apache.kafka.common.config.ConfigException;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n+import static org.junit.Assert.assertThrows;\n \n-import static org.easymock.EasyMock.*;\n+import static org.easymock.EasyMock.partialMockBuilder;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.easymock.EasyMock.reset;\n \n \n-public class WebserverUrlPrefixConfigTest {\n-\n-  @Rule\n-  public ExpectedException _expectedException = ExpectedException.none();\n+public class WebserverUrlPrefixConfigTest extends AbstractConfigTest {\n \n   @Test\n   public void testWebserverUrlPrefixConfigsCorrectSetup() {\n     KafkaCruiseControlConfig config = partialMockBuilder(KafkaCruiseControlConfig.class)\n-        .addMockedMethod(\"getString\")\n+        .addMockedMethod(GET_STRING_METHOD_NAME)\n         .createNiceMock();\n \n     expect(config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG)).andReturn(\"a/b/c/d/*\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMzY0NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530713645", "bodyText": "Can we avoid using wildcard import?", "author": "efeg", "createdAt": "2020-11-26T00:54:40Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java", "diffHunk": "@@ -34,8 +35,7 @@\n import static com.linkedin.kafka.cruisecontrol.servlet.CruiseControlEndPoint.REBALANCE;\n import static com.linkedin.kafka.cruisecontrol.servlet.CruiseControlEndPoint.REMOVE_BROKER;\n import static com.linkedin.kafka.cruisecontrol.servlet.CruiseControlEndPoint.USER_TASKS;\n-import static com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServletUtils.GET_METHOD;\n-import static com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServletUtils.POST_METHOD;\n+import static com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServletUtils.*;", "originalCommit": "14ade8d35919d7b5a86c03aff54c4ce4533332a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8ae006f1d8ee2583a7dc0fa116dba5036fcdb411", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java\nindex 5205501a..12da2078 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java\n\n@@ -35,7 +35,8 @@ import static com.linkedin.kafka.cruisecontrol.servlet.CruiseControlEndPoint.PRO\n import static com.linkedin.kafka.cruisecontrol.servlet.CruiseControlEndPoint.REBALANCE;\n import static com.linkedin.kafka.cruisecontrol.servlet.CruiseControlEndPoint.REMOVE_BROKER;\n import static com.linkedin.kafka.cruisecontrol.servlet.CruiseControlEndPoint.USER_TASKS;\n-import static com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServletUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServletUtils.GET_METHOD;\n+import static com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServletUtils.POST_METHOD;\n \n \n public class KafkaCruiseControlServletEndpointTest {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMzg3Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530713872", "bodyText": "Can we avoid wildcard import?", "author": "efeg", "createdAt": "2020-11-26T00:55:20Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java", "diffHunk": "@@ -14,6 +16,8 @@\n import org.junit.Assert;\n import org.junit.Test;\n \n+import static com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServletUtils.*;", "originalCommit": "14ade8d35919d7b5a86c03aff54c4ce4533332a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8ae006f1d8ee2583a7dc0fa116dba5036fcdb411", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\nindex 11ff19ab..40b46f22 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\n\n@@ -16,7 +16,8 @@ import org.easymock.EasyMock;\n import org.junit.Assert;\n import org.junit.Test;\n \n-import static com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServletUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServletUtils.GET_METHOD;\n+import static com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServletUtils.POST_METHOD;\n \n \n public class ParameterUtilsTest {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxNDg1Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530714857", "bodyText": "Is apiUrlPrefix expected to be the same as apiUrlPrefixParam w/o an * at the end? If so, can we drop apiUrlPrefix from the parameters of this function and infer its value from apiUrlPrefixParam?", "author": "efeg", "createdAt": "2020-11-26T00:59:08Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java", "diffHunk": "@@ -136,4 +140,40 @@ public void testParseExecutionProgressCheckIntervalMsWithValue() {\n     EasyMock.verify(mockRequest);\n     Assert.assertEquals(Long.valueOf(EXECUTION_PROGRESS_CHECK_INTERVAL_STRING), executionProgressCheckIntervalMs);\n   }\n+\n+  @Test\n+  public void testGetEndpoint() {\n+    verifyGetEndpoint(\"/a/\", \"/a/*\");\n+    verifyGetEndpoint(\"/kafkacruisecontrol/\", WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX);\n+  }\n+\n+  /**\n+   * Verifies that {@link ParameterUtils#endPoint} can parse out all endpoints\n+   *\n+   * @param apiUrlPrefix API URL prefix used to concatenate with \"/endpoint_name\" to mock the URL in a request\n+   * @param apiUrlPrefixParam API URL prefix parameter passed to the {@link ParameterUtils#endPoint}\n+   */\n+  private void verifyGetEndpoint(String apiUrlPrefix, String apiUrlPrefixParam) {", "originalCommit": "14ade8d35919d7b5a86c03aff54c4ce4533332a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc2MDkxMw==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r530760913", "bodyText": "Yes, good idea", "author": "Lincong", "createdAt": "2020-11-26T04:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxNDg1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8ae006f1d8ee2583a7dc0fa116dba5036fcdb411", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\nindex 11ff19ab..40b46f22 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\n\n@@ -143,19 +144,18 @@ public class ParameterUtilsTest {\n \n   @Test\n   public void testGetEndpoint() {\n-    verifyGetEndpoint(\"/a/\", \"/a/*\");\n-    verifyGetEndpoint(\"/kafkacruisecontrol/\", WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX);\n+    verifyGetEndpoint(\"/a/*\");\n+    verifyGetEndpoint(WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX);\n   }\n \n   /**\n    * Verifies that {@link ParameterUtils#endPoint} can parse out all endpoints\n    *\n-   * @param apiUrlPrefix API URL prefix used to concatenate with \"/endpoint_name\" to mock the URL in a request\n    * @param apiUrlPrefixParam API URL prefix parameter passed to the {@link ParameterUtils#endPoint}\n    */\n-  private void verifyGetEndpoint(String apiUrlPrefix, String apiUrlPrefixParam) {\n+  private void verifyGetEndpoint(String apiUrlPrefixParam) {\n     HttpServletRequest mockRequest = EasyMock.mock(HttpServletRequest.class);\n-\n+    String apiUrlPrefix = apiUrlPrefixParam.substring(0, apiUrlPrefixParam.length() - 1);\n     for (CruiseControlEndPoint getEndPoint : CruiseControlEndPoint.getEndpoints()) {\n       String mockRequestUri = apiUrlPrefix + getEndPoint;\n       EasyMock.expect(mockRequest.getMethod()).andReturn(GET_METHOD).times(1);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMDQwMw==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533620403", "bodyText": "Looks like this change modifies and breaks the indentation formatting. Can we avoid such changes?\nImporting the project style file on IntelliJ may help: https://github.com/linkedin/cruise-control/blob/master/docs/code-style.xml", "author": "efeg", "createdAt": "2020-12-01T18:12:10Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/SessionManager.java", "diffHunk": "@@ -51,8 +52,8 @@\n   private final Time _time;\n   private final ScheduledExecutorService _sessionCleaner =\n       Executors.newSingleThreadScheduledExecutor(new KafkaCruiseControlThreadFactory(\"SessionCleaner\",\n-                                                                                     true,", "originalCommit": "540f22f46f69bde7bc97b77472aa484c68df4055", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg2Mjg5MA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533862890", "bodyText": "Will do. Thanks", "author": "Lincong", "createdAt": "2020-12-02T02:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMDQwMw=="}], "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/SessionManager.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/SessionManager.java\ndeleted file mode 100644\nindex 6907e2bf..00000000\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/SessionManager.java\n+++ /dev/null\n\n@@ -1,317 +0,0 @@\n-/*\n- * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n- */\n-\n-package com.linkedin.kafka.cruisecontrol.servlet;\n-\n-import com.codahale.metrics.Gauge;\n-import com.codahale.metrics.Meter;\n-import com.codahale.metrics.MetricRegistry;\n-import com.codahale.metrics.Timer;\n-import com.linkedin.cruisecontrol.servlet.EndPoint;\n-import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n-import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.OperationFuture;\n-import com.linkedin.kafka.cruisecontrol.common.KafkaCruiseControlThreadFactory;\n-import com.linkedin.kafka.cruisecontrol.servlet.parameters.ParameterUtils;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.function.Supplier;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpSession;\n-import org.apache.kafka.common.utils.Time;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-\n-/**\n- * A class that helps track the http sessions and their corresponding operations.\n- *\n- * When an {@link HttpServletRequest} executes a long operation. The servlet will submit an asynchronous operation and\n- * return the progress of that operation instead of blocking waiting for the operation to finish. In that case, the\n- * {@link HttpSession} of that HttpServletRequest will be recorded by the servlet. Next time when the same client\n- * issue the same request again, it will resume the operation requested last time.\n- *\n- * If an HttpSession is recorded for a request with a request URL, it is required that the same request URL should be\n- * issued again from the same session until the asynchronous operation is finished. Otherwise an exception will\n- * be returned.\n- */\n-public class SessionManager {\n-  private static final Logger LOG = LoggerFactory.getLogger(SessionManager.class);\n-  private final int _capacity;\n-  private final long _sessionExpiryMs;\n-  private final Map<HttpSession, SessionInfo> _inProgressSessions;\n-  private final Time _time;\n-  private final ScheduledExecutorService _sessionCleaner =\n-      Executors.newSingleThreadScheduledExecutor(new KafkaCruiseControlThreadFactory(\"SessionCleaner\",\n-          true,\n-          null));\n-  private final Timer _sessionLifetimeTimer;\n-  private final Meter _sessionCreationFailureMeter;\n-  private final Map<EndPoint, Timer> _successfulRequestExecutionTimer;\n-\n-  /**\n-   * Construct the session manager.\n-   * @param capacity the maximum of sessions allowed to exist at the same time.\n-   * @param sessionExpiryMs the maximum time to wait before expire an inactive session.\n-   * @param time the time object for unit test.\n-   * @param dropwizardMetricRegistry the metric registry to record metrics.\n-   */\n-  SessionManager(int capacity,\n-      long sessionExpiryMs,\n-      Time time,\n-      MetricRegistry dropwizardMetricRegistry,\n-      Map<EndPoint, Timer> successfulRequestExecutionTimer) {\n-    _capacity = capacity;\n-    _sessionExpiryMs = sessionExpiryMs;\n-    _time = time;\n-    _inProgressSessions = new HashMap<>();\n-    _sessionCleaner.scheduleAtFixedRate(new ExpiredSessionCleaner(), 0, 5, TimeUnit.SECONDS);\n-    _successfulRequestExecutionTimer = successfulRequestExecutionTimer;\n-    // Metrics registration\n-    _sessionLifetimeTimer = dropwizardMetricRegistry.timer(MetricRegistry.name(\"SessionManager\", \"session-lifetime-timer\"));\n-    _sessionCreationFailureMeter = dropwizardMetricRegistry.meter(MetricRegistry.name(\"SessionManager\", \"session-creation-failure-rate\"));\n-    dropwizardMetricRegistry.register(MetricRegistry.name(\"SessionManager\", \"num-active-sessions\"),\n-        (Gauge<Integer>) _inProgressSessions::size);\n-\n-  }\n-\n-  /**\n-   * Close the session manager.\n-   */\n-  public void close() {\n-    _sessionCleaner.shutdownNow();\n-  }\n-\n-  /**\n-   * @return Total number of active sessions.\n-   */\n-  synchronized int numSessions() {\n-    return _inProgressSessions.size();\n-  }\n-\n-  /**\n-   * Create the session for the request if needed.\n-   *\n-   * @param request the HttpServletRequest to create session for.\n-   * @param operation the async operation that returns an {@link OperationFuture}\n-   * @param step the index of the step whose future needs to be added or get.\n-   *\n-   * @return The {@link OperationFuture} for the provided async operation.\n-   */\n-  synchronized OperationFuture getAndCreateSessionIfNotExist(HttpServletRequest request,\n-      Supplier<OperationFuture> operation,\n-      int step) {\n-    HttpSession session = request.getSession();\n-    SessionInfo info = _inProgressSessions.get(session);\n-    String requestString = toRequestString(request);\n-    // Session exists.\n-    if (info != null) {\n-      LOG.info(\"Found existing session {}\", session);\n-      info.ensureSameRequest(requestString, request.getParameterMap());\n-      // If there is next future return it.\n-      if (step < info.numFutures()) {\n-        return info.future(step);\n-      } else if (step == info.numFutures()) {\n-        LOG.info(\"Adding new future to existing session {}.\", session);\n-        // if there is no next future, add the future to the next list.\n-        OperationFuture future = operation.get();\n-        info.addFuture(future);\n-        return future;\n-      } else {\n-        throw new IllegalArgumentException(String.format(\"There are %d steps in the session. Cannot add step %d.\",\n-            info.numFutures(), step));\n-      }\n-    } else {\n-      if (step > 0) {\n-        throw new IllegalArgumentException(String.format(\"There are no step in the session. Cannot add step %d.\", step));\n-      }\n-      // The session does not exist, add it.\n-      if (_inProgressSessions.size() >= _capacity) {\n-        _sessionCreationFailureMeter.mark();\n-        throw new RuntimeException(\"There are already \" + _inProgressSessions.size() + \" active sessions, which \"\n-            + \"has reached the servlet capacity.\");\n-      }\n-      LOG.info(\"Created session for {}\", session);\n-      info = new SessionInfo(requestString,\n-                             request.getParameterMap(),\n-                             ParameterUtils.endPoint(request, WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX));\n-      OperationFuture future = operation.get();\n-      info.addFuture(future);\n-      _inProgressSessions.put(session, info);\n-      return future;\n-    }\n-  }\n-\n-  /**\n-   * Get the {@link OperationFuture} for the request.\n-   * @param request the request to get the operation future.\n-   * @param <T> the returned future type.\n-   * @return The operation future for the request if it exists, otherwise {@code null} is returned.\n-   */\n-  @SuppressWarnings(\"unchecked\")\n-  synchronized <T> T getFuture(HttpServletRequest request) {\n-    SessionInfo info = _inProgressSessions.get(request.getSession());\n-    if (info == null) {\n-      return null;\n-    } else if (!info.requestUrl().equals(toRequestString(request))) {\n-      throw new IllegalStateException(\"The session has an ongoing operation \" + info.requestUrl() + \" while it \"\n-          + \"is trying another operation of \" + toRequestString(request));\n-    }\n-    return (T) info.lastFuture();\n-  }\n-\n-  /**\n-   * Close the session for the given request.\n-   * @param request the request to close its session.\n-   * @param hasError whether the session is closed due to an error or not.\n-   */\n-  synchronized void closeSession(HttpServletRequest request, boolean hasError) {\n-    // Response associated with this request has already been flushed; hence, do not attempt to create a new session.\n-    HttpSession session = request.getSession(false);\n-    if (session == null) {\n-      return;\n-    }\n-    SessionInfo info = _inProgressSessions.remove(session);\n-    if (info != null && info.lastFuture().isDone()) {\n-      LOG.info(\"Closing session {}\", session);\n-      session.invalidate();\n-      _sessionLifetimeTimer.update(System.nanoTime() - info.requestStartTimeNs(), TimeUnit.NANOSECONDS);\n-      if (!hasError && info.executionTime() > 0) {\n-        _successfulRequestExecutionTimer.get(info.endPoint()).update(info.executionTime(), TimeUnit.NANOSECONDS);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Expire the sessions that have been inactive for more than configured expiration time.\n-   */\n-  synchronized void expireOldSessions() {\n-    long now = _time.milliseconds();\n-    Iterator<Map.Entry<HttpSession, SessionInfo>> iter = _inProgressSessions.entrySet().iterator();\n-    while (iter.hasNext()) {\n-      Map.Entry<HttpSession, SessionInfo> entry = iter.next();\n-      HttpSession session = entry.getKey();\n-      SessionInfo info = entry.getValue();\n-      if (LOG.isTraceEnabled()) {\n-        LOG.trace(\"Session {} was last accessed at {}, age is {} ms\", session, session.getLastAccessedTime(),\n-            now - session.getLastAccessedTime());\n-      }\n-      if (now >= session.getLastAccessedTime() + _sessionExpiryMs) {\n-        LOG.info(\"Expiring session {}.\", session);\n-        iter.remove();\n-        session.invalidate();\n-        _sessionLifetimeTimer.update(System.nanoTime() - info.requestStartTimeNs(), TimeUnit.NANOSECONDS);\n-        if (info.lastFuture().isDone() && info.executionTime() > 0) {\n-          _successfulRequestExecutionTimer.get(info.endPoint()).update(info.executionTime(), TimeUnit.NANOSECONDS);\n-        } else {\n-          info.lastFuture().cancel(true);\n-        }\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Container class to host the future and the request url for verification.\n-   */\n-  private static class SessionInfo {\n-    private final String _requestUrl;\n-    private final Map<String, String[]> _requestParameters;\n-    private final List<OperationFuture> _operationFuture;\n-    private final long _requestStartTimeNs;\n-    private final EndPoint _endPoint;\n-\n-    private SessionInfo(String requestUrl, Map<String, String[]> requestParameters, EndPoint endPoint) {\n-      _operationFuture = new ArrayList<>();\n-      _requestUrl = requestUrl;\n-      _requestParameters = requestParameters;\n-      _requestStartTimeNs = System.nanoTime();\n-      _endPoint = endPoint;\n-    }\n-\n-    private int numFutures() {\n-      return _operationFuture.size();\n-    }\n-\n-    private void addFuture(OperationFuture future) {\n-      _operationFuture.add(future);\n-    }\n-\n-    private OperationFuture future(int index) {\n-      return _operationFuture.get(index);\n-    }\n-\n-    private OperationFuture lastFuture() {\n-      return _operationFuture.get(_operationFuture.size() - 1);\n-    }\n-\n-    private String requestUrl() {\n-      return _requestUrl;\n-    }\n-\n-    private long requestStartTimeNs() {\n-      return _requestStartTimeNs;\n-    }\n-\n-    private long executionTime() {\n-      return lastFuture().finishTimeNs() == -1 ? -1 : lastFuture().finishTimeNs() - _requestStartTimeNs;\n-    }\n-\n-    private EndPoint endPoint() {\n-      return _endPoint;\n-    }\n-\n-    private boolean paramEquals(Map<String, String[]> parameters) {\n-      boolean isSameParameters = _requestParameters.keySet().equals(parameters.keySet());\n-      if (isSameParameters) {\n-        for (Map.Entry<String, String[]> entry : _requestParameters.entrySet()) {\n-          Set<String> param1 = new HashSet<>(Arrays.asList(entry.getValue()));\n-          Set<String> param2 = new HashSet<>(Arrays.asList(parameters.get(entry.getKey())));\n-          if (!param1.equals(param2)) {\n-            return false;\n-          }\n-        }\n-      }\n-      return isSameParameters;\n-    }\n-\n-    private void ensureSameRequest(String requestUrl, Map<String, String[]> parameters) {\n-      if (!_requestUrl.equals(requestUrl) || !paramEquals(parameters)) {\n-        throw new IllegalStateException(String.format(\n-            \"The session has an ongoing operation [URL: %s, Parameters: %s] \"\n-                + \"while it is trying another operation of [URL: %s, Parameters: %s].\",\n-            _requestUrl, _requestParameters, requestUrl, parameters));\n-      }\n-    }\n-  }\n-\n-  private static String toRequestString(HttpServletRequest request) {\n-    return String.format(\"%s(%s %s)\",\n-        request.getClass().getSimpleName(),\n-        request.getMethod(),\n-        request.getRequestURI());\n-  }\n-\n-  /**\n-   * A runnable class to expire the old sessions.\n-   */\n-  private class ExpiredSessionCleaner implements Runnable {\n-    @Override\n-    public void run() {\n-      try {\n-        expireOldSessions();\n-      } catch (Throwable t) {\n-        LOG.warn(\"Received exception when trying to expire sessions.\", t);\n-      }\n-    }\n-  }\n-}\n-\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMDg0MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533620841", "bodyText": "Bad indentation -- please see the earlier comment.", "author": "efeg", "createdAt": "2020-12-01T18:12:57Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/SessionManagerTest.java", "diffHunk": "@@ -36,8 +36,8 @@ public void testCreateAndCloseSession() {\n     SessionManager sessionManager = new SessionManager(1, 1000, context.time(), new MetricRegistry(), null);\n \n     sessionManager.getAndCreateSessionIfNotExist(context.request(0),\n-                                                 () -> new OperationFuture(\"testCreateSession\"),", "originalCommit": "540f22f46f69bde7bc97b77472aa484c68df4055", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/SessionManagerTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/SessionManagerTest.java\ndeleted file mode 100644\nindex 164d4916..00000000\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/SessionManagerTest.java\n+++ /dev/null\n\n@@ -1,173 +0,0 @@\n-/*\n- * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n- */\n-\n-package com.linkedin.kafka.cruisecontrol.servlet;\n-\n-import com.codahale.metrics.MetricRegistry;\n-import com.linkedin.kafka.cruisecontrol.servlet.response.PauseSamplingResult;\n-import com.linkedin.kafka.cruisecontrol.servlet.response.ResumeSamplingResult;\n-import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.OperationFuture;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.Future;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpSession;\n-import org.apache.kafka.common.utils.MockTime;\n-import org.apache.kafka.common.utils.Time;\n-import org.easymock.EasyMock;\n-import org.junit.Test;\n-\n-import static com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServletUtils.GET_METHOD;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-\n-public class SessionManagerTest {\n-\n-  @Test\n-  public void testCreateAndCloseSession() {\n-    TestContext context = prepareRequests(true, 1);\n-    SessionManager sessionManager = new SessionManager(1, 1000, context.time(), new MetricRegistry(), null);\n-\n-    sessionManager.getAndCreateSessionIfNotExist(context.request(0),\n-        () -> new OperationFuture(\"testCreateSession\"),\n-        0);\n-    assertEquals(1, sessionManager.numSessions());\n-\n-    sessionManager.closeSession(context.request(0), false);\n-    assertEquals(0, sessionManager.numSessions());\n-  }\n-\n-  @Test\n-  public void testSessionExpiration() {\n-    TestContext context = prepareRequests(true, 2);\n-    SessionManager sessionManager = new SessionManager(2, 1000, context.time(), new MetricRegistry(), null);\n-\n-    List<OperationFuture> futures = new ArrayList<>();\n-    for (int i = 0; i < 2; i++) {\n-      futures.add(sessionManager.getAndCreateSessionIfNotExist(context.request(i),\n-          () -> new OperationFuture(\"testSessionExpiration\"),\n-          0));\n-    }\n-    assertEquals(2, sessionManager.numSessions());\n-\n-    // Sleep to 1 ms before expiration.\n-    context.time().sleep(999);\n-    sessionManager.expireOldSessions();\n-    assertEquals(2, sessionManager.numSessions());\n-    for (Future future : futures)  {\n-      assertFalse(future.isDone());\n-      assertFalse(future.isCancelled());\n-    }\n-    // Sleep to the exact time to expire\n-    context.time().sleep(1);\n-    sessionManager.expireOldSessions();\n-    assertEquals(\"All the sessions should have been expired\", 0, sessionManager.numSessions());\n-    for (Future future : futures)  {\n-      assertTrue(future.isDone());\n-      assertTrue(future.isCancelled());\n-    }\n-  }\n-\n-  @Test\n-  public void testCreateSessionReachingCapacity() {\n-    TestContext context = prepareRequests(false, 2);\n-    SessionManager sessionManager = new SessionManager(1, 1000, context.time(), new MetricRegistry(), null);\n-\n-    sessionManager.getAndCreateSessionIfNotExist(context.request(0),\n-        () -> new OperationFuture(\"testCreateSession\"),\n-        0);\n-    assertEquals(1, sessionManager.numSessions());\n-    assertNull(sessionManager.getFuture(context.request(1)));\n-    // Adding same request again should have no impact\n-    sessionManager.getAndCreateSessionIfNotExist(context.request(0),\n-        () -> new OperationFuture(\"testCreateSession\"),\n-        1);\n-    assertEquals(1, sessionManager.numSessions());\n-\n-    try {\n-      sessionManager.getAndCreateSessionIfNotExist(context.request(1),\n-          () -> new OperationFuture(\"testCreateSession\"),\n-          0);\n-      fail(\"Should have thrown exception due to session capacity reached.\");\n-    } catch (RuntimeException e) {\n-      // let it go.\n-    }\n-  }\n-\n-  @Test\n-  public void testMultipleOperationRequest() {\n-    TestContext context = prepareRequests(false, 1);\n-    SessionManager sessionManager = new SessionManager(1, 1000, context.time(), new MetricRegistry(), null);\n-    HttpServletRequest request = context.request(0);\n-    OperationFuture future1 = new OperationFuture(\"future1\");\n-    OperationFuture future2 = new OperationFuture(\"future2\");\n-    for (int i = 0; i < 2; i++) {\n-      // Create the first future.\n-      OperationFuture firstFuture = sessionManager.getAndCreateSessionIfNotExist(request, () -> future1, 0);\n-      assertSame(firstFuture, future1);\n-      future1.complete(new PauseSamplingResult(null));\n-      // create the second future.\n-      OperationFuture secondFuture = sessionManager.getAndCreateSessionIfNotExist(request, () -> future2, 1);\n-      assertSame(secondFuture, future2);\n-      future2.complete(new ResumeSamplingResult(null));\n-    }\n-  }\n-\n-  @Test (expected = IllegalArgumentException.class)\n-  public void testSkipStep() {\n-    TestContext context = prepareRequests(false, 1);\n-    SessionManager sessionManager = new SessionManager(1, 1000, context.time(), new MetricRegistry(), null);\n-    HttpServletRequest request = context.request(0);\n-    sessionManager.getAndCreateSessionIfNotExist(request, () -> null, 1);\n-  }\n-\n-  private TestContext prepareRequests(boolean expectSessionInvalidation, int numRequests) {\n-    Time time = new MockTime();\n-    List<HttpServletRequest> requests = new ArrayList<>(numRequests);\n-    List<HttpSession> sessions = new ArrayList<>();\n-    for (int i = 0; i < numRequests; i++) {\n-      HttpServletRequest request = EasyMock.mock(HttpServletRequest.class);\n-      HttpSession session = EasyMock.mock(HttpSession.class);\n-      requests.add(request);\n-      sessions.add(session);\n-      EasyMock.expect(request.getSession()).andReturn(session).anyTimes();\n-      EasyMock.expect(request.getSession(false)).andReturn(session).anyTimes();\n-      EasyMock.expect(request.getMethod()).andReturn(GET_METHOD).anyTimes();\n-      EasyMock.expect(request.getRequestURI()).andReturn(\"/test\").anyTimes();\n-      EasyMock.expect(request.getParameterMap()).andReturn(Collections.emptyMap()).anyTimes();\n-      EasyMock.expect(session.getLastAccessedTime()).andReturn(time.milliseconds()).anyTimes();\n-      if (expectSessionInvalidation) {\n-        session.invalidate();\n-        EasyMock.expectLastCall().once();\n-      }\n-    }\n-    EasyMock.replay(requests.toArray());\n-    EasyMock.replay(sessions.toArray());\n-    return new TestContext(requests, time);\n-  }\n-\n-  private static class TestContext {\n-    private List<HttpServletRequest> _requests;\n-    private Time _time;\n-\n-    private TestContext(List<HttpServletRequest> requests, Time time) {\n-      _requests = requests;\n-      _time = time;\n-    }\n-\n-    private HttpServletRequest request(int index) {\n-      return _requests.get(index);\n-    }\n-\n-    private Time time() {\n-      return _time;\n-    }\n-  }\n-}\n\\ No newline at end of file\n"}}, {"oid": "8ae006f1d8ee2583a7dc0fa116dba5036fcdb411", "url": "https://github.com/linkedin/cruise-control/commit/8ae006f1d8ee2583a7dc0fa116dba5036fcdb411", "message": "Removed redundant unit test", "committedDate": "2020-12-02T02:55:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg2OTg0MA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533869840", "bodyText": "Was this added intentionally?", "author": "efeg", "createdAt": "2020-12-02T03:20:34Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServlet.java", "diffHunk": "@@ -74,6 +74,10 @@ public void destroy() {\n     }\n   }\n \n+  public String apiUrlPrefix() {\n+    return _config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG);\n+  }\n+", "originalCommit": "48038e7c7620b259769a99eb5ad0b09c343edd94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkwMzg5NA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533903894", "bodyText": "I was added for testing purposes. I'll remove it.", "author": "Lincong", "createdAt": "2020-12-02T05:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg2OTg0MA=="}], "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServlet.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServlet.java\nindex 94ebdcae..64830f08 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServlet.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServlet.java\n\n@@ -74,10 +74,6 @@ public class KafkaCruiseControlServlet extends HttpServlet {\n     }\n   }\n \n-  public String apiUrlPrefix() {\n-    return _config.getString(WebServerConfig.WEBSERVER_API_URLPREFIX_CONFIG);\n-  }\n-\n   public AsyncKafkaCruiseControl asyncKafkaCruiseControl() {\n     return _asyncKafkaCruiseControl;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg3Mjc5NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533872795", "bodyText": "I am not sure if extending an abstract class like this by SecurityAndSslConfigTest and WebserverUrlPrefixConfigTest is the best approach.\n\nSecurityAndSslConfigTest does not use GET_CLASS_METHOD_NAME anywhere, and\nWebserverUrlPrefixConfigTest does not use GET_BOOLEAN_METHOD_NAME and HASH_CODE_METHOD_NAME anywhere.\n\nInheritance should imply that everything in the abstract class applies to the classes that extend from it. If the goal here is to share common constants across classes, can we move these constants to a utility class within config package?", "author": "efeg", "createdAt": "2020-12-02T03:29:22Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/AbstractConfigTest.java", "diffHunk": "@@ -0,0 +1,15 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+package com.linkedin.kafka.cruisecontrol.config;\n+\n+abstract class AbstractConfigTest {", "originalCommit": "48038e7c7620b259769a99eb5ad0b09c343edd94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkwNjAwMg==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533906002", "bodyText": "Sure", "author": "Lincong", "createdAt": "2020-12-02T05:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg3Mjc5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/AbstractConfigTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/AbstractConfigTest.java\ndeleted file mode 100644\nindex 763b203d..00000000\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/AbstractConfigTest.java\n+++ /dev/null\n\n@@ -1,15 +0,0 @@\n-/*\n- * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n- */\n-package com.linkedin.kafka.cruisecontrol.config;\n-\n-abstract class AbstractConfigTest {\n-\n-  protected static final String GET_STRING_METHOD_NAME = \"getString\";\n-  protected static final String GET_BOOLEAN_METHOD_NAME = \"getBoolean\";\n-\n-  protected static final String HASH_CODE_METHOD_NAME = \"hashCode\";\n-  protected static final String GET_CLASS_METHOD_NAME = \"getClass\";\n-\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg3MzE0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533873142", "bodyText": "There are some missing cases below -- see:\n        .addMockedMethod(\"getBoolean\")\n        .addMockedMethod(\"getClass\")\n        .addMockedMethod(\"hashCode\")", "author": "efeg", "createdAt": "2020-12-02T03:30:27Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/SecurityAndSslConfigTest.java", "diffHunk": "@@ -16,17 +16,17 @@\n import static org.easymock.EasyMock.replay;\n import static org.easymock.EasyMock.verify;\n \n-public class SecurityAndSslConfigTest {\n+public class SecurityAndSslConfigTest extends AbstractConfigTest {\n \n   @Rule\n   public ExpectedException _expectedException = ExpectedException.none();\n \n   @Test\n   public void testSslConfigsSetUpThrowsExceptionOnNullKeystoreLocation() {\n     KafkaCruiseControlConfig config = partialMockBuilder(KafkaCruiseControlConfig.class)\n-        .addMockedMethod(\"getBoolean\")\n-        .addMockedMethod(\"getString\")\n-        .addMockedMethod(\"hashCode\")\n+        .addMockedMethod(GET_BOOLEAN_METHOD_NAME)", "originalCommit": "48038e7c7620b259769a99eb5ad0b09c343edd94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/SecurityAndSslConfigTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/SecurityAndSslConfigTest.java\nindex 8db166df..fcd20728 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/SecurityAndSslConfigTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/SecurityAndSslConfigTest.java\n\n@@ -16,7 +16,7 @@ import static org.easymock.EasyMock.partialMockBuilder;\n import static org.easymock.EasyMock.replay;\n import static org.easymock.EasyMock.verify;\n \n-public class SecurityAndSslConfigTest extends AbstractConfigTest {\n+public class SecurityAndSslConfigTest {\n \n   @Rule\n   public ExpectedException _expectedException = ExpectedException.none();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg3NDcwMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533874701", "bodyText": "Nit: It is common practice / convention to make utility classes final.", "author": "efeg", "createdAt": "2020-12-02T03:36:19Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletTestUtils.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+package com.linkedin.kafka.cruisecontrol.servlet;\n+\n+import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n+\n+\n+public class KafkaCruiseControlServletTestUtils {", "originalCommit": "48038e7c7620b259769a99eb5ad0b09c343edd94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkwMzIwMg==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533903202", "bodyText": "Thanks for letting me know", "author": "Lincong", "createdAt": "2020-12-02T05:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg3NDcwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletTestUtils.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletTestUtils.java\ndeleted file mode 100644\nindex c2aee6e2..00000000\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletTestUtils.java\n+++ /dev/null\n\n@@ -1,22 +0,0 @@\n-/*\n- * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n- */\n-package com.linkedin.kafka.cruisecontrol.servlet;\n-\n-import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n-\n-\n-public class KafkaCruiseControlServletTestUtils {\n-  private KafkaCruiseControlServletTestUtils() {\n-\n-  }\n-\n-  /**\n-   * Strip off the '*' from the end of the default web server API URL prefix\n-   * @return the default web server API URL prefix with no '*' at the end\n-   */\n-  public static String getDefaultWebServerApiUrlPrefix() {\n-    return WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX\n-        .substring(0, WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX.length() - 1);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg3NDg2MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533874861", "bodyText": "Nit: times(1) -> once()", "author": "efeg", "createdAt": "2020-12-02T03:36:55Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java", "diffHunk": "@@ -136,4 +141,39 @@ public void testParseExecutionProgressCheckIntervalMsWithValue() {\n     EasyMock.verify(mockRequest);\n     Assert.assertEquals(Long.valueOf(EXECUTION_PROGRESS_CHECK_INTERVAL_STRING), executionProgressCheckIntervalMs);\n   }\n+\n+  @Test\n+  public void testGetEndpoint() {\n+    verifyGetEndpoint(\"/a/*\");\n+    verifyGetEndpoint(WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX);\n+  }\n+\n+  /**\n+   * Verifies that {@link ParameterUtils#endPoint} can parse out all endpoints\n+   *\n+   * @param apiUrlPrefixParam API URL prefix parameter passed to the {@link ParameterUtils#endPoint}\n+   */\n+  private void verifyGetEndpoint(String apiUrlPrefixParam) {\n+    HttpServletRequest mockRequest = EasyMock.mock(HttpServletRequest.class);\n+    String apiUrlPrefix = apiUrlPrefixParam.substring(0, apiUrlPrefixParam.length() - 1);\n+    for (CruiseControlEndPoint getEndPoint : CruiseControlEndPoint.getEndpoints()) {\n+      String mockRequestUri = apiUrlPrefix + getEndPoint;\n+      EasyMock.expect(mockRequest.getMethod()).andReturn(GET_METHOD).times(1);\n+      EasyMock.expect(mockRequest.getRequestURI()).andReturn(mockRequestUri).times(1);\n+      EasyMock.replay(mockRequest);\n+      CruiseControlEndPoint endPoint = ParameterUtils.endPoint(mockRequest, apiUrlPrefixParam);\n+      Assert.assertEquals(getEndPoint, endPoint);\n+      EasyMock.reset(mockRequest);\n+    }\n+\n+    for (CruiseControlEndPoint postEndPoint : CruiseControlEndPoint.postEndpoints()) {\n+      String mockRequestUri = apiUrlPrefix + postEndPoint;\n+      EasyMock.expect(mockRequest.getMethod()).andReturn(POST_METHOD).times(1);\n+      EasyMock.expect(mockRequest.getRequestURI()).andReturn(mockRequestUri).times(1);", "originalCommit": "48038e7c7620b259769a99eb5ad0b09c343edd94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\nindex 40b46f22..9a7f3183 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\n\n@@ -141,39 +136,4 @@ public class ParameterUtilsTest {\n     EasyMock.verify(mockRequest);\n     Assert.assertEquals(Long.valueOf(EXECUTION_PROGRESS_CHECK_INTERVAL_STRING), executionProgressCheckIntervalMs);\n   }\n-\n-  @Test\n-  public void testGetEndpoint() {\n-    verifyGetEndpoint(\"/a/*\");\n-    verifyGetEndpoint(WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX);\n-  }\n-\n-  /**\n-   * Verifies that {@link ParameterUtils#endPoint} can parse out all endpoints\n-   *\n-   * @param apiUrlPrefixParam API URL prefix parameter passed to the {@link ParameterUtils#endPoint}\n-   */\n-  private void verifyGetEndpoint(String apiUrlPrefixParam) {\n-    HttpServletRequest mockRequest = EasyMock.mock(HttpServletRequest.class);\n-    String apiUrlPrefix = apiUrlPrefixParam.substring(0, apiUrlPrefixParam.length() - 1);\n-    for (CruiseControlEndPoint getEndPoint : CruiseControlEndPoint.getEndpoints()) {\n-      String mockRequestUri = apiUrlPrefix + getEndPoint;\n-      EasyMock.expect(mockRequest.getMethod()).andReturn(GET_METHOD).times(1);\n-      EasyMock.expect(mockRequest.getRequestURI()).andReturn(mockRequestUri).times(1);\n-      EasyMock.replay(mockRequest);\n-      CruiseControlEndPoint endPoint = ParameterUtils.endPoint(mockRequest, apiUrlPrefixParam);\n-      Assert.assertEquals(getEndPoint, endPoint);\n-      EasyMock.reset(mockRequest);\n-    }\n-\n-    for (CruiseControlEndPoint postEndPoint : CruiseControlEndPoint.postEndpoints()) {\n-      String mockRequestUri = apiUrlPrefix + postEndPoint;\n-      EasyMock.expect(mockRequest.getMethod()).andReturn(POST_METHOD).times(1);\n-      EasyMock.expect(mockRequest.getRequestURI()).andReturn(mockRequestUri).times(1);\n-      EasyMock.replay(mockRequest);\n-      CruiseControlEndPoint endPoint = ParameterUtils.endPoint(mockRequest, apiUrlPrefixParam);\n-      Assert.assertEquals(postEndPoint, endPoint);\n-      EasyMock.reset(mockRequest);\n-    }\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg3NTcxMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533875711", "bodyText": "I'd recommend dropping the test for the default -- i.e.\nverifyGetEndpoint(WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX);\n\nand moving the content of the private function verifyGetEndpoint inside this test function as it is not used anywhere else and contains all the logic of this test.", "author": "efeg", "createdAt": "2020-12-02T03:40:02Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java", "diffHunk": "@@ -136,4 +141,39 @@ public void testParseExecutionProgressCheckIntervalMsWithValue() {\n     EasyMock.verify(mockRequest);\n     Assert.assertEquals(Long.valueOf(EXECUTION_PROGRESS_CHECK_INTERVAL_STRING), executionProgressCheckIntervalMs);\n   }\n+\n+  @Test\n+  public void testGetEndpoint() {\n+    verifyGetEndpoint(\"/a/*\");\n+    verifyGetEndpoint(WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX);", "originalCommit": "48038e7c7620b259769a99eb5ad0b09c343edd94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkwMjg4OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533902889", "bodyText": "I have changed the implementation and the verifyGetEndpoint method is not used any more in test", "author": "Lincong", "createdAt": "2020-12-02T05:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg3NTcxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\nindex 40b46f22..9a7f3183 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\n\n@@ -141,39 +136,4 @@ public class ParameterUtilsTest {\n     EasyMock.verify(mockRequest);\n     Assert.assertEquals(Long.valueOf(EXECUTION_PROGRESS_CHECK_INTERVAL_STRING), executionProgressCheckIntervalMs);\n   }\n-\n-  @Test\n-  public void testGetEndpoint() {\n-    verifyGetEndpoint(\"/a/*\");\n-    verifyGetEndpoint(WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX);\n-  }\n-\n-  /**\n-   * Verifies that {@link ParameterUtils#endPoint} can parse out all endpoints\n-   *\n-   * @param apiUrlPrefixParam API URL prefix parameter passed to the {@link ParameterUtils#endPoint}\n-   */\n-  private void verifyGetEndpoint(String apiUrlPrefixParam) {\n-    HttpServletRequest mockRequest = EasyMock.mock(HttpServletRequest.class);\n-    String apiUrlPrefix = apiUrlPrefixParam.substring(0, apiUrlPrefixParam.length() - 1);\n-    for (CruiseControlEndPoint getEndPoint : CruiseControlEndPoint.getEndpoints()) {\n-      String mockRequestUri = apiUrlPrefix + getEndPoint;\n-      EasyMock.expect(mockRequest.getMethod()).andReturn(GET_METHOD).times(1);\n-      EasyMock.expect(mockRequest.getRequestURI()).andReturn(mockRequestUri).times(1);\n-      EasyMock.replay(mockRequest);\n-      CruiseControlEndPoint endPoint = ParameterUtils.endPoint(mockRequest, apiUrlPrefixParam);\n-      Assert.assertEquals(getEndPoint, endPoint);\n-      EasyMock.reset(mockRequest);\n-    }\n-\n-    for (CruiseControlEndPoint postEndPoint : CruiseControlEndPoint.postEndpoints()) {\n-      String mockRequestUri = apiUrlPrefix + postEndPoint;\n-      EasyMock.expect(mockRequest.getMethod()).andReturn(POST_METHOD).times(1);\n-      EasyMock.expect(mockRequest.getRequestURI()).andReturn(mockRequestUri).times(1);\n-      EasyMock.replay(mockRequest);\n-      CruiseControlEndPoint endPoint = ParameterUtils.endPoint(mockRequest, apiUrlPrefixParam);\n-      Assert.assertEquals(postEndPoint, endPoint);\n-      EasyMock.reset(mockRequest);\n-    }\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg3NjU5Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533876597", "bodyText": "Does reset call also verify the mock? -- i.e. if not do we need EasyMock.verify()? (similar use above)", "author": "efeg", "createdAt": "2020-12-02T03:43:15Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java", "diffHunk": "@@ -136,4 +141,39 @@ public void testParseExecutionProgressCheckIntervalMsWithValue() {\n     EasyMock.verify(mockRequest);\n     Assert.assertEquals(Long.valueOf(EXECUTION_PROGRESS_CHECK_INTERVAL_STRING), executionProgressCheckIntervalMs);\n   }\n+\n+  @Test\n+  public void testGetEndpoint() {\n+    verifyGetEndpoint(\"/a/*\");\n+    verifyGetEndpoint(WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX);\n+  }\n+\n+  /**\n+   * Verifies that {@link ParameterUtils#endPoint} can parse out all endpoints\n+   *\n+   * @param apiUrlPrefixParam API URL prefix parameter passed to the {@link ParameterUtils#endPoint}\n+   */\n+  private void verifyGetEndpoint(String apiUrlPrefixParam) {\n+    HttpServletRequest mockRequest = EasyMock.mock(HttpServletRequest.class);\n+    String apiUrlPrefix = apiUrlPrefixParam.substring(0, apiUrlPrefixParam.length() - 1);\n+    for (CruiseControlEndPoint getEndPoint : CruiseControlEndPoint.getEndpoints()) {\n+      String mockRequestUri = apiUrlPrefix + getEndPoint;\n+      EasyMock.expect(mockRequest.getMethod()).andReturn(GET_METHOD).times(1);\n+      EasyMock.expect(mockRequest.getRequestURI()).andReturn(mockRequestUri).times(1);\n+      EasyMock.replay(mockRequest);\n+      CruiseControlEndPoint endPoint = ParameterUtils.endPoint(mockRequest, apiUrlPrefixParam);\n+      Assert.assertEquals(getEndPoint, endPoint);\n+      EasyMock.reset(mockRequest);\n+    }\n+\n+    for (CruiseControlEndPoint postEndPoint : CruiseControlEndPoint.postEndpoints()) {\n+      String mockRequestUri = apiUrlPrefix + postEndPoint;\n+      EasyMock.expect(mockRequest.getMethod()).andReturn(POST_METHOD).times(1);\n+      EasyMock.expect(mockRequest.getRequestURI()).andReturn(mockRequestUri).times(1);\n+      EasyMock.replay(mockRequest);\n+      CruiseControlEndPoint endPoint = ParameterUtils.endPoint(mockRequest, apiUrlPrefixParam);\n+      Assert.assertEquals(postEndPoint, endPoint);\n+      EasyMock.reset(mockRequest);", "originalCommit": "48038e7c7620b259769a99eb5ad0b09c343edd94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkwMjk4MA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r533902980", "bodyText": "I will call verify before reset", "author": "Lincong", "createdAt": "2020-12-02T05:19:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg3NjU5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\nindex 40b46f22..9a7f3183 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtilsTest.java\n\n@@ -141,39 +136,4 @@ public class ParameterUtilsTest {\n     EasyMock.verify(mockRequest);\n     Assert.assertEquals(Long.valueOf(EXECUTION_PROGRESS_CHECK_INTERVAL_STRING), executionProgressCheckIntervalMs);\n   }\n-\n-  @Test\n-  public void testGetEndpoint() {\n-    verifyGetEndpoint(\"/a/*\");\n-    verifyGetEndpoint(WebServerConfig.DEFAULT_WEBSERVER_API_URLPREFIX);\n-  }\n-\n-  /**\n-   * Verifies that {@link ParameterUtils#endPoint} can parse out all endpoints\n-   *\n-   * @param apiUrlPrefixParam API URL prefix parameter passed to the {@link ParameterUtils#endPoint}\n-   */\n-  private void verifyGetEndpoint(String apiUrlPrefixParam) {\n-    HttpServletRequest mockRequest = EasyMock.mock(HttpServletRequest.class);\n-    String apiUrlPrefix = apiUrlPrefixParam.substring(0, apiUrlPrefixParam.length() - 1);\n-    for (CruiseControlEndPoint getEndPoint : CruiseControlEndPoint.getEndpoints()) {\n-      String mockRequestUri = apiUrlPrefix + getEndPoint;\n-      EasyMock.expect(mockRequest.getMethod()).andReturn(GET_METHOD).times(1);\n-      EasyMock.expect(mockRequest.getRequestURI()).andReturn(mockRequestUri).times(1);\n-      EasyMock.replay(mockRequest);\n-      CruiseControlEndPoint endPoint = ParameterUtils.endPoint(mockRequest, apiUrlPrefixParam);\n-      Assert.assertEquals(getEndPoint, endPoint);\n-      EasyMock.reset(mockRequest);\n-    }\n-\n-    for (CruiseControlEndPoint postEndPoint : CruiseControlEndPoint.postEndpoints()) {\n-      String mockRequestUri = apiUrlPrefix + postEndPoint;\n-      EasyMock.expect(mockRequest.getMethod()).andReturn(POST_METHOD).times(1);\n-      EasyMock.expect(mockRequest.getRequestURI()).andReturn(mockRequestUri).times(1);\n-      EasyMock.replay(mockRequest);\n-      CruiseControlEndPoint endPoint = ParameterUtils.endPoint(mockRequest, apiUrlPrefixParam);\n-      Assert.assertEquals(postEndPoint, endPoint);\n-      EasyMock.reset(mockRequest);\n-    }\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY0NjA0OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r534646049", "bodyText": "If the URL does not have any extra path information, request.getPathInfo() can return null. In this case, I believe this method should return null.", "author": "efeg", "createdAt": "2020-12-03T03:45:49Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java", "diffHunk": "@@ -177,7 +176,7 @@ public static CruiseControlEndPoint endPoint(HttpServletRequest request) {\n         throw new UserRequestException(\"Unsupported request method: \" + request.getMethod() + \".\");\n     }\n \n-    String path = request.getRequestURI().toUpperCase().replace(REQUEST_URI, \"\");\n+    String path = request.getPathInfo().substring(1); // Skip the first character '/'", "originalCommit": "5ede61bc8158263994bc7864f10e39dc4919b6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2OTcwMA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r534669700", "bodyText": "Good point!", "author": "Lincong", "createdAt": "2020-12-03T05:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY0NjA0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java\nindex 9b55c608..56880b7e 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java\n\n@@ -176,7 +177,7 @@ public class ParameterUtils {\n         throw new UserRequestException(\"Unsupported request method: \" + request.getMethod() + \".\");\n     }\n \n-    String path = request.getPathInfo().substring(1); // Skip the first character '/'\n+    String path = request.getRequestURI().toUpperCase().replace(apiUrlPrefix, \"\");\n     for (CruiseControlEndPoint endPoint : supportedEndpoints) {\n       if (endPoint.toString().equalsIgnoreCase(path)) {\n         return endPoint;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY0NjMwOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r534646309", "bodyText": "Can we drop the unused apiUrlPrefix?", "author": "efeg", "createdAt": "2020-12-03T03:46:36Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java", "diffHunk": "@@ -881,7 +880,7 @@ static int partitionBoundary(HttpServletRequest request, boolean isUpperBound) {\n     return Integer.parseInt(boundaries[isUpperBound ? 1 : 0]);\n   }\n \n-  static Set<Integer> brokerIds(HttpServletRequest request, boolean isOptional) throws UnsupportedEncodingException {\n+  static Set<Integer> brokerIds(HttpServletRequest request, String apiUrlPrefix, boolean isOptional) throws UnsupportedEncodingException {", "originalCommit": "5ede61bc8158263994bc7864f10e39dc4919b6be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java\nindex 9b55c608..56880b7e 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/parameters/ParameterUtils.java\n\n@@ -880,7 +881,7 @@ public class ParameterUtils {\n     return Integer.parseInt(boundaries[isUpperBound ? 1 : 0]);\n   }\n \n-  static Set<Integer> brokerIds(HttpServletRequest request, String apiUrlPrefix, boolean isOptional) throws UnsupportedEncodingException {\n+  static Set<Integer> brokerIds(HttpServletRequest request, boolean isOptional) throws UnsupportedEncodingException {\n     Set<Integer> brokerIds = parseParamToIntegerSet(request, BROKER_ID_PARAM);\n     if (!isOptional && brokerIds.isEmpty()) {\n       EndPoint endpoint = endPoint(request);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY0NzQ5OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r534647499", "bodyText": "Nit: Why do we break the line -- i.e. are there any code changes here?", "author": "efeg", "createdAt": "2020-12-03T03:50:17Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java", "diffHunk": "@@ -234,7 +234,8 @@ private static UserTasksParameters mockUserTasksParameters(HttpServletRequest an\n     EasyMock.expect(parameters.userTaskIds()).andReturn(ParameterUtils.userTaskIds(answerQueryRequest)).anyTimes();\n     EasyMock.expect(parameters.clientIds()).andReturn(ParameterUtils.clientIds(answerQueryRequest)).anyTimes();\n     EasyMock.expect(parameters.endPoints()).andReturn(ParameterUtils.endPoints(answerQueryRequest)).anyTimes();\n-    EasyMock.expect(parameters.endPoint()).andReturn(ParameterUtils.endPoint(answerQueryRequest)).anyTimes();\n+    EasyMock.expect(parameters.endPoint()).andReturn(ParameterUtils\n+        .endPoint(answerQueryRequest)).anyTimes();", "originalCommit": "5ede61bc8158263994bc7864f10e39dc4919b6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY3MTI5Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r534671296", "bodyText": "Right. No need to break the line here and no code change here", "author": "Lincong", "createdAt": "2020-12-03T05:06:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY0NzQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU4NDk0Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r535584947", "bodyText": "Nit: This line still has the line break even after this issue is marked as resolved.", "author": "efeg", "createdAt": "2020-12-03T20:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY0NzQ5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java\nindex 96a9b711..a2a544cb 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java\n\n@@ -234,8 +234,7 @@ public class KafkaCruiseControlServletEndpointTest {\n     EasyMock.expect(parameters.userTaskIds()).andReturn(ParameterUtils.userTaskIds(answerQueryRequest)).anyTimes();\n     EasyMock.expect(parameters.clientIds()).andReturn(ParameterUtils.clientIds(answerQueryRequest)).anyTimes();\n     EasyMock.expect(parameters.endPoints()).andReturn(ParameterUtils.endPoints(answerQueryRequest)).anyTimes();\n-    EasyMock.expect(parameters.endPoint()).andReturn(ParameterUtils\n-        .endPoint(answerQueryRequest)).anyTimes();\n+    EasyMock.expect(parameters.endPoint()).andReturn(ParameterUtils.endPoint(answerQueryRequest)).anyTimes();\n     EasyMock.expect(parameters.types()).andReturn(ParameterUtils.types(answerQueryRequest)).anyTimes();\n     EasyMock.expect(parameters.entries()).andReturn(ParameterUtils.entries(answerQueryRequest)).anyTimes();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1MTA0Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r534651043", "bodyText": "(Not introduced in this patch) Looks like this class has no EasyMock.verify(XXX) calls; hence, it is hard to verify if the expected calls are made as many as required. Should we add verify before appropriate EasyMock.reset() calls? -- e.g. for the first one in testUserTaskParameters\n    EasyMock.verify(answerQueryRequest1, parameters1, _mockUUIDGenerator, _mockHttpSession, _mockHttpServletResponse);", "author": "efeg", "createdAt": "2020-12-03T04:01:31Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java", "diffHunk": "@@ -260,8 +261,10 @@ private HttpServletRequest prepareRequest(HttpSession session, String userTaskId\n     EasyMock.expect(request.getSession()).andReturn(session).anyTimes();\n     EasyMock.expect(request.getSession(false)).andReturn(session).anyTimes();\n     EasyMock.expect(request.getMethod()).andReturn(method).anyTimes();\n-    EasyMock.expect(request.getRequestURI()).andReturn(KafkaCruiseControlServletUtils.REQUEST_URI + resource).anyTimes();\n+    EasyMock.expect(request.getRequestURI())\n+        .andReturn(KafkaCruiseControlServletTestUtils.getDefaultWebServerApiUrlPrefix() + resource).anyTimes();\n     EasyMock.expect(request.getParameterMap()).andReturn(params).anyTimes();\n+    EasyMock.expect(request.getPathInfo()).andReturn(\"/\" + resource).anyTimes();", "originalCommit": "5ede61bc8158263994bc7864f10e39dc4919b6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyOTc4Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r535429787", "bodyText": "I tried to add verify to KafkaCruiseControlServletEndpointTest.java and UserTaskManagerTest.java and I realized that the test cases need to be changed to pass the verify method and it requires some relatively non-trivial change or even re-write some of the unit tests.\nSo, I suggest not doing it in this PR since it's irrelevant and creating an issue for this task.", "author": "Lincong", "createdAt": "2020-12-03T17:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1MTA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU5OTg0OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r535599849", "bodyText": "Issue created: #1408", "author": "Lincong", "createdAt": "2020-12-03T20:53:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1MTA0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java\nindex 96a9b711..a2a544cb 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/KafkaCruiseControlServletEndpointTest.java\n\n@@ -261,10 +260,8 @@ public class KafkaCruiseControlServletEndpointTest {\n     EasyMock.expect(request.getSession()).andReturn(session).anyTimes();\n     EasyMock.expect(request.getSession(false)).andReturn(session).anyTimes();\n     EasyMock.expect(request.getMethod()).andReturn(method).anyTimes();\n-    EasyMock.expect(request.getRequestURI())\n-        .andReturn(KafkaCruiseControlServletTestUtils.getDefaultWebServerApiUrlPrefix() + resource).anyTimes();\n+    EasyMock.expect(request.getRequestURI()).andReturn(KafkaCruiseControlServletUtils.REQUEST_URI + resource).anyTimes();\n     EasyMock.expect(request.getParameterMap()).andReturn(params).anyTimes();\n-    EasyMock.expect(request.getPathInfo()).andReturn(\"/\" + resource).anyTimes();\n     EasyMock.expect(request.getHeader(UserTaskManager.USER_TASK_HEADER_NAME)).andReturn(userTaskId).anyTimes();\n     EasyMock.expect(request.getRemoteHost()).andReturn(\"test-host\").anyTimes();\n     for (String headerName : KafkaCruiseControlServletUtils.HEADERS_TO_TRY) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1MjMzOA==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r534652338", "bodyText": "(Not introduced in this PR) Can we add verify for mocks? (please see earlier similar comment)", "author": "efeg", "createdAt": "2020-12-03T04:05:46Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/UserTaskManagerTest.java", "diffHunk": "@@ -296,6 +296,7 @@ private HttpServletRequest prepareRequest(HttpSession session, String userTaskId\n     EasyMock.expect(request.getSession(false)).andReturn(session).anyTimes();\n     EasyMock.expect(request.getMethod()).andReturn(GET_METHOD).anyTimes();\n     EasyMock.expect(request.getRequestURI()).andReturn(resource).anyTimes();\n+    EasyMock.expect(request.getPathInfo()).andReturn(resource).anyTimes();", "originalCommit": "5ede61bc8158263994bc7864f10e39dc4919b6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyOTk3Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r535429977", "bodyText": "Same comment as above", "author": "Lincong", "createdAt": "2020-12-03T17:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1MjMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU4NjMzMw==", "url": "https://github.com/linkedin/cruise-control/pull/1401#discussion_r535586333", "bodyText": "Sure, we can address them in a separate PR -- can we create an issue about them?", "author": "efeg", "createdAt": "2020-12-03T20:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1MjMzOA=="}], "type": "inlineReview", "revised_code": {"commit": "8a939ff9936ced5cc256193ea5286c3adb307cab", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/UserTaskManagerTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/UserTaskManagerTest.java\nindex 600708ab..bb830cb4 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/UserTaskManagerTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/UserTaskManagerTest.java\n\n@@ -296,7 +296,6 @@ public class UserTaskManagerTest {\n     EasyMock.expect(request.getSession(false)).andReturn(session).anyTimes();\n     EasyMock.expect(request.getMethod()).andReturn(GET_METHOD).anyTimes();\n     EasyMock.expect(request.getRequestURI()).andReturn(resource).anyTimes();\n-    EasyMock.expect(request.getPathInfo()).andReturn(resource).anyTimes();\n     EasyMock.expect(request.getParameterMap()).andReturn(params).anyTimes();\n     EasyMock.expect(request.getHeader(UserTaskManager.USER_TASK_HEADER_NAME)).andReturn(userTaskId).anyTimes();\n     EasyMock.expect(request.getRemoteHost()).andReturn(\"test-host\").anyTimes();\n"}}, {"oid": "8a939ff9936ced5cc256193ea5286c3adb307cab", "url": "https://github.com/linkedin/cruise-control/commit/8a939ff9936ced5cc256193ea5286c3adb307cab", "message": "wip", "committedDate": "2020-12-03T04:57:45Z", "type": "commit"}, {"oid": "1a7b573d1c88b22d0b2c0e3d694b176fc7125b68", "url": "https://github.com/linkedin/cruise-control/commit/1a7b573d1c88b22d0b2c0e3d694b176fc7125b68", "message": "Make the endpoint parsing method parse endpoint using a given API URL prefix string", "committedDate": "2020-12-03T04:57:45Z", "type": "commit"}, {"oid": "311d635339dd9961dbf9adbf85f5293e74e32ba5", "url": "https://github.com/linkedin/cruise-control/commit/311d635339dd9961dbf9adbf85f5293e74e32ba5", "message": "Fix some issues", "committedDate": "2020-12-03T04:57:45Z", "type": "commit"}, {"oid": "97e76dc8641e43276240e80cb50d333fc2cd8755", "url": "https://github.com/linkedin/cruise-control/commit/97e76dc8641e43276240e80cb50d333fc2cd8755", "message": "Fix PR issues", "committedDate": "2020-12-03T04:57:45Z", "type": "commit"}, {"oid": "71034c98512391248b2eec29a2b3a5f42d18b692", "url": "https://github.com/linkedin/cruise-control/commit/71034c98512391248b2eec29a2b3a5f42d18b692", "message": "Add a getter on the CC servlet to expose API URL prefix", "committedDate": "2020-12-03T04:57:45Z", "type": "commit"}, {"oid": "5d47729774eb5540c6524768fb682ba131513b29", "url": "https://github.com/linkedin/cruise-control/commit/5d47729774eb5540c6524768fb682ba131513b29", "message": "Removed redundant unit test", "committedDate": "2020-12-03T04:57:45Z", "type": "commit"}, {"oid": "e814f6c1fc9d8d9ffcfe7a7b098ade6710d7707b", "url": "https://github.com/linkedin/cruise-control/commit/e814f6c1fc9d8d9ffcfe7a7b098ade6710d7707b", "message": "Remove session manager and its test", "committedDate": "2020-12-03T04:57:45Z", "type": "commit"}, {"oid": "056797f32248f364011e6f988391b81da391ffee", "url": "https://github.com/linkedin/cruise-control/commit/056797f32248f364011e6f988391b81da391ffee", "message": "Change the endpoint method so that it gets resource information from the request object", "committedDate": "2020-12-03T04:57:45Z", "type": "commit"}, {"oid": "2f37e15727064de1b5f4ed1925d7743c11a5b200", "url": "https://github.com/linkedin/cruise-control/commit/2f37e15727064de1b5f4ed1925d7743c11a5b200", "message": "Fix issues", "committedDate": "2020-12-03T04:57:45Z", "type": "commit"}, {"oid": "ee819293751b6263b7e7f394ac830fd2bbea7762", "url": "https://github.com/linkedin/cruise-control/commit/ee819293751b6263b7e7f394ac830fd2bbea7762", "message": "Fixed PR issues", "committedDate": "2020-12-03T17:19:41Z", "type": "commit"}, {"oid": "ee819293751b6263b7e7f394ac830fd2bbea7762", "url": "https://github.com/linkedin/cruise-control/commit/ee819293751b6263b7e7f394ac830fd2bbea7762", "message": "Fixed PR issues", "committedDate": "2020-12-03T17:19:41Z", "type": "forcePushed"}, {"oid": "864844ae83f500e4c2d2edd18b61650f4116447c", "url": "https://github.com/linkedin/cruise-control/commit/864844ae83f500e4c2d2edd18b61650f4116447c", "message": "Remove unnecessary line wrap", "committedDate": "2020-12-03T20:48:39Z", "type": "commit"}]}