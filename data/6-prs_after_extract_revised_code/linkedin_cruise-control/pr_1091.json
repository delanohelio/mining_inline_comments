{"pr_number": 1091, "pr_title": "JWT Authentication", "pr_createdAt": "2020-02-07T08:59:19Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1091", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwMjk2NA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r376402964", "bodyText": "nit: maybe it might be better to remove the space in BEARER variable and trim here: authorizationHeader.substring(BEARER.length()).trim()", "author": "in-park", "createdAt": "2020-02-07T13:58:35Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.security.ServerAuthException;\n+import org.eclipse.jetty.security.UserAuthentication;\n+import org.eclipse.jetty.security.authentication.LoginAuthenticator;\n+import org.eclipse.jetty.server.Authentication;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.function.Function;\n+\n+/**\n+ * <p>The {@link JwtAuthenticator} adds SSO capabilites to Cruise Control. The expected token is a Json Web Token (JWT).\n+ * This class should be used with {@link JwtLoginService} as the token check is carried out by that one. This class\n+ * handles redirects for unauthenticated requests and CORS preflight requests.</p>\n+ * <p>The workflow can be described with the following diagram:\n+ * <pre>\n+ *       Client -----1., 4.----> Cruise Control\n+ *        |  ^                        |\n+ *        |  |________2.______________|\n+ *        |\n+ *        |\n+ *        |------3.------------> Authentication\n+ *                                 provider\n+ * </pre>\n+ * <ol>\n+ * <li>The client makes an initial call to Cruise Control\n+ * <li>If the request doesn't have a JWT cookie by the specified cookie name, it will be redirected to the authentication\n+ *     service to obtain it. If the request is an OPTIONS request we presume it's a CORS preflight request so it'll skip\n+ *     the authentication (if the user is authenticated at this point we'll use the existing credentials).\n+ * <li>The client authenticates with the provider and obtains the SSO token.\n+ * <li>The client can present the JWT cookie to Cruise Control. Cruise Control will validate the cookie with the\n+ *    {@link JwtLoginService} by checking its signature, audience and expiration.\n+ * </ol>\n+ * </p>\n+ */\n+public class JwtAuthenticator extends LoginAuthenticator {\n+\n+  public static final String JWT_TOKEN_REQUEST_ATTRIBUTE = \"com.linkedin.kafka.cruisecontrol.JwtTokenAttribute\";\n+  static final Logger JWT_LOGGER = LoggerFactory.getLogger(\"kafka.cruisecontrol.jwt.logger\");\n+\n+  private static final String METHOD = \"JWT\";\n+  private static final String BEARER = \"Bearer \";\n+\n+  private final String _cookieName;\n+  private final Function<HttpServletRequest, String> _authenticationProviderUrlGenerator;\n+\n+  /**\n+   * Creates a new {@link JwtAuthenticator} instance with a custom authentication provider url and a cookie name that\n+   * will be populated by the authentication service with the JWT token.\n+   * @param authenticationProviderUrl is the HTTP(S) address of the authentication service. It will be used to create\n+   *                                  the redirection url. For instance <code>https://www.my-auth-service.com/websso?origin={redirectUrl}</code>\n+   *                                  will generate <code>https://www.my-auth-service.com/websso?origin=https://www.cruise-control.cc/state</code>\n+   *                                  which should redirect from <code>my-auth-service.com</code> to <code>cruise-control.cc/state</code>\n+   *                                  after obtaining the JWT token.\n+   * @param cookieName is the cookie name which will contain the cookie obtained from the authentication service.\n+   *                   <code>null</code> is an acceptable value when the token is always returned\n+   */\n+  public JwtAuthenticator(String authenticationProviderUrl, String cookieName) {\n+    _cookieName = cookieName;\n+    Function<String, Function<HttpServletRequest, String>> urlGen =\n+        url -> req -> url.replace(\"{redirectUrl}\", req.getRequestURL().toString() + getOriginalQueryString(req));\n+    _authenticationProviderUrlGenerator = urlGen.apply(authenticationProviderUrl);\n+  }\n+\n+  @Override\n+  public String getAuthMethod() {\n+    return METHOD;\n+  }\n+\n+  @Override\n+  public void prepareRequest(ServletRequest request) {\n+\n+  }\n+\n+  @Override\n+  public Authentication validateRequest(ServletRequest request, ServletResponse response, boolean mandatory) throws ServerAuthException {\n+    JWT_LOGGER.trace(\"Authentication request received for \" + request.toString());\n+    if (!(request instanceof HttpServletRequest) && !(response instanceof HttpServletResponse)) {\n+      return Authentication.UNAUTHENTICATED;\n+    }\n+\n+    String serializedJWT;\n+    HttpServletRequest req = (HttpServletRequest) request;\n+    // we'll skip the authentication for CORS preflight requests\n+    if (HttpMethod.OPTIONS.name().toLowerCase().equals(req.getMethod().toLowerCase())) {\n+      return Authentication.NOT_CHECKED;\n+    }\n+    serializedJWT = getJwtFromBearerAuthorization(req);\n+    if (serializedJWT == null) {\n+      serializedJWT = getJwtFromCookie(req);\n+    }\n+    if (serializedJWT == null) {\n+      String loginURL = _authenticationProviderUrlGenerator.apply(req);\n+      JWT_LOGGER.info(\"No JWT token found, sending redirect to \" + loginURL);\n+      try {\n+        ((HttpServletResponse) response).sendRedirect(loginURL);\n+        return Authentication.SEND_CONTINUE;\n+      } catch (IOException e) {\n+        JWT_LOGGER.error(\"Couldn't authenticate request\", e);\n+        throw new ServerAuthException(e);\n+      }\n+    } else {\n+      try {\n+        SignedJWT jwtToken = SignedJWT.parse(serializedJWT);\n+        String userName = jwtToken.getJWTClaimsSet().getSubject();\n+        request.setAttribute(JWT_TOKEN_REQUEST_ATTRIBUTE, serializedJWT);\n+        UserIdentity identity = login(userName, jwtToken, request);\n+        return new UserAuthentication(getAuthMethod(), identity);\n+      } catch (ParseException pe) {\n+        String loginURL = _authenticationProviderUrlGenerator.apply(req);\n+        JWT_LOGGER.warn(\"Unable to parse the JWT token, redirecting back to the login page\", pe);\n+        try {\n+          ((HttpServletResponse) response).sendRedirect(loginURL);\n+        } catch (IOException e) {\n+          throw new ServerAuthException(e);\n+        }\n+      }\n+    }\n+\n+    return Authentication.SEND_FAILURE;\n+  }\n+\n+  @Override\n+  public boolean secureResponse(ServletRequest request, ServletResponse response, boolean mandatory, Authentication.User validatedUser) {\n+    return true;\n+  }\n+\n+  String getJwtFromCookie(HttpServletRequest req) {\n+    String serializedJWT = null;\n+    Cookie[] cookies = req.getCookies();\n+    if (cookies != null) {\n+      for (Cookie cookie : cookies) {\n+        if (_cookieName != null && _cookieName.equals(cookie.getName())) {\n+          JWT_LOGGER.trace(_cookieName + \" cookie has been found and is being processed\");\n+          serializedJWT = cookie.getValue();\n+          break;\n+        }\n+      }\n+    }\n+    return serializedJWT;\n+  }\n+\n+  String getJwtFromBearerAuthorization(HttpServletRequest req) {\n+    String authorizationHeader = req.getHeader(HttpHeader.AUTHORIZATION.asString());\n+    if (authorizationHeader == null || !authorizationHeader.startsWith(BEARER)) {\n+      return null;\n+    } else {\n+      return authorizationHeader.substring(BEARER.length());", "originalCommit": "82ec99a3fb9e9e58f2c2d0c8fb3e049739cd7fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA1MDgxOA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377050818", "bodyText": "Makes sense, will update this.", "author": "viktorsomogyi", "createdAt": "2020-02-10T13:07:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwMjk2NA=="}], "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java\nindex 0075c8bf..666ec458 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java\n\n@@ -25,7 +25,7 @@ import java.text.ParseException;\n import java.util.function.Function;\n \n /**\n- * <p>The {@link JwtAuthenticator} adds SSO capabilites to Cruise Control. The expected token is a Json Web Token (JWT).\n+ * <p>The {@link JwtAuthenticator} adds SSO capabilities to Cruise Control. The expected token is a Json Web Token (JWT).\n  * This class should be used with {@link JwtLoginService} as the token check is carried out by that one. This class\n  * handles redirects for unauthenticated requests and CORS preflight requests.</p>\n  * <p>The workflow can be described with the following diagram:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMTMzOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r376411339", "bodyText": "I am wondering if something must be done here. Isn't this needed to prevent unneccesary renewals when the UserIdentity is still valid?", "author": "in-park", "createdAt": "2020-02-07T14:16:07Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSObject;\n+import com.nimbusds.jose.JWSVerifier;\n+import com.nimbusds.jose.crypto.RSASSAVerifier;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.security.DefaultIdentityService;\n+import org.eclipse.jetty.security.IdentityService;\n+import org.eclipse.jetty.security.LoginService;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.util.component.AbstractLifeCycle;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+\n+import javax.security.auth.Subject;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPublicKey;\n+import java.text.ParseException;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.linkedin.kafka.cruisecontrol.servlet.security.jwt.JwtAuthenticator.JWT_LOGGER;\n+\n+/**\n+ * <p>This class validates a JWT token. The token must be cryptographically encrypted an It uses an RSA public key for\n+ * validation that is expected to be stored in a PEM formatted file.</p>\n+ * <p>This class implements {@link AbstractLifeCycle} which means it is a managed bean, its lifecycle will be managed\n+ * by Jetty. It's {@link AuthorizationService} can also be an {@link AbstractLifeCycle} in which case it delegates to\n+ * this class, so opening and closing connections should be done by implementing the {@link AbstractLifeCycle} interface's\n+ * {@link #doStart()} and {@link #doStop()} methods respectively. For a simple example see\n+ * {@link UserStoreAuthorizationService}.</p>\n+ */\n+public class JwtLoginService extends AbstractLifeCycle implements LoginService {\n+\n+  private final AuthorizationService _authorizationService;\n+  private IdentityService _identityService = new DefaultIdentityService();\n+  private final RSAPublicKey _publicKey;\n+  private final List<String> _audiences;\n+\n+  public JwtLoginService(AuthorizationService authorizationService, String publicKeyLocation, List<String> audiences)\n+      throws IOException, CertificateException {\n+    this(authorizationService, readPublicKey(publicKeyLocation), audiences);\n+  }\n+\n+  public JwtLoginService(AuthorizationService authorizationService, RSAPublicKey publicKey, List<String> audiences) {\n+    _authorizationService = authorizationService;\n+    _publicKey = publicKey;\n+    _audiences = audiences;\n+  }\n+\n+  @Override\n+  protected void doStart() throws Exception {\n+    super.doStart();\n+    // The authorization service might want to start a connection or access a file\n+    if (_authorizationService instanceof LifeCycle) {\n+      ((LifeCycle) _authorizationService).start();\n+    }\n+  }\n+\n+  @Override\n+  protected void doStop() throws Exception {\n+    if (_authorizationService instanceof LifeCycle) {\n+      ((LifeCycle) _authorizationService).stop();\n+    }\n+    super.doStop();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public UserIdentity login(String username, Object credentials, ServletRequest request) {\n+    if (!(credentials instanceof SignedJWT)) {\n+      return null;\n+    }\n+    if (!(request instanceof HttpServletRequest)) {\n+      return null;\n+    }\n+\n+    SignedJWT jwtToken = (SignedJWT) credentials;\n+    boolean valid;\n+    try {\n+      valid = validateToken(jwtToken, username);\n+    } catch (ParseException e) {\n+      JWT_LOGGER.warn(String.format(\"%s: Couldn't parse a JWT token\", username), e);\n+      return null;\n+    }\n+    if (valid) {\n+      String serializedToken = (String) request.getAttribute(JwtAuthenticator.JWT_TOKEN_REQUEST_ATTRIBUTE);\n+      UserIdentity rolesDelegate = _authorizationService.getUserIdentity((HttpServletRequest) request, username);\n+      return getUserIdentity(jwtToken, serializedToken, username, rolesDelegate);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public boolean validate(UserIdentity user) {", "originalCommit": "82ec99a3fb9e9e58f2c2d0c8fb3e049739cd7fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA1MDAyMg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377050022", "bodyText": "Hmm, good question. On a second thought probably it would make sense to check the expiry (as audiences and signature doesn't change for an authenticated user). I'll update this.", "author": "viktorsomogyi", "createdAt": "2020-02-10T13:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMTMzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\nindex dd90322f..020db543 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\n\n@@ -9,6 +9,7 @@ import com.nimbusds.jose.JOSEException;\n import com.nimbusds.jose.JWSObject;\n import com.nimbusds.jose.JWSVerifier;\n import com.nimbusds.jose.crypto.RSASSAVerifier;\n+import com.nimbusds.jwt.JWTClaimsSet;\n import com.nimbusds.jwt.SignedJWT;\n import org.eclipse.jetty.security.DefaultIdentityService;\n import org.eclipse.jetty.security.IdentityService;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMzQ1Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r376413453", "bodyText": "Is it ok to leave this empty? I am wondering if the framework makes use of this method to invalidate tokens.", "author": "in-park", "createdAt": "2020-02-07T14:19:57Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSObject;\n+import com.nimbusds.jose.JWSVerifier;\n+import com.nimbusds.jose.crypto.RSASSAVerifier;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.security.DefaultIdentityService;\n+import org.eclipse.jetty.security.IdentityService;\n+import org.eclipse.jetty.security.LoginService;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.util.component.AbstractLifeCycle;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+\n+import javax.security.auth.Subject;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPublicKey;\n+import java.text.ParseException;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.linkedin.kafka.cruisecontrol.servlet.security.jwt.JwtAuthenticator.JWT_LOGGER;\n+\n+/**\n+ * <p>This class validates a JWT token. The token must be cryptographically encrypted an It uses an RSA public key for\n+ * validation that is expected to be stored in a PEM formatted file.</p>\n+ * <p>This class implements {@link AbstractLifeCycle} which means it is a managed bean, its lifecycle will be managed\n+ * by Jetty. It's {@link AuthorizationService} can also be an {@link AbstractLifeCycle} in which case it delegates to\n+ * this class, so opening and closing connections should be done by implementing the {@link AbstractLifeCycle} interface's\n+ * {@link #doStart()} and {@link #doStop()} methods respectively. For a simple example see\n+ * {@link UserStoreAuthorizationService}.</p>\n+ */\n+public class JwtLoginService extends AbstractLifeCycle implements LoginService {\n+\n+  private final AuthorizationService _authorizationService;\n+  private IdentityService _identityService = new DefaultIdentityService();\n+  private final RSAPublicKey _publicKey;\n+  private final List<String> _audiences;\n+\n+  public JwtLoginService(AuthorizationService authorizationService, String publicKeyLocation, List<String> audiences)\n+      throws IOException, CertificateException {\n+    this(authorizationService, readPublicKey(publicKeyLocation), audiences);\n+  }\n+\n+  public JwtLoginService(AuthorizationService authorizationService, RSAPublicKey publicKey, List<String> audiences) {\n+    _authorizationService = authorizationService;\n+    _publicKey = publicKey;\n+    _audiences = audiences;\n+  }\n+\n+  @Override\n+  protected void doStart() throws Exception {\n+    super.doStart();\n+    // The authorization service might want to start a connection or access a file\n+    if (_authorizationService instanceof LifeCycle) {\n+      ((LifeCycle) _authorizationService).start();\n+    }\n+  }\n+\n+  @Override\n+  protected void doStop() throws Exception {\n+    if (_authorizationService instanceof LifeCycle) {\n+      ((LifeCycle) _authorizationService).stop();\n+    }\n+    super.doStop();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public UserIdentity login(String username, Object credentials, ServletRequest request) {\n+    if (!(credentials instanceof SignedJWT)) {\n+      return null;\n+    }\n+    if (!(request instanceof HttpServletRequest)) {\n+      return null;\n+    }\n+\n+    SignedJWT jwtToken = (SignedJWT) credentials;\n+    boolean valid;\n+    try {\n+      valid = validateToken(jwtToken, username);\n+    } catch (ParseException e) {\n+      JWT_LOGGER.warn(String.format(\"%s: Couldn't parse a JWT token\", username), e);\n+      return null;\n+    }\n+    if (valid) {\n+      String serializedToken = (String) request.getAttribute(JwtAuthenticator.JWT_TOKEN_REQUEST_ATTRIBUTE);\n+      UserIdentity rolesDelegate = _authorizationService.getUserIdentity((HttpServletRequest) request, username);\n+      return getUserIdentity(jwtToken, serializedToken, username, rolesDelegate);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public boolean validate(UserIdentity user) {\n+    return false;\n+  }\n+\n+  @Override\n+  public IdentityService getIdentityService() {\n+    return _identityService;\n+  }\n+\n+  @Override\n+  public void setIdentityService(IdentityService service) {\n+    _identityService = service;\n+  }\n+\n+  @Override\n+  public void logout(UserIdentity user) {\n+", "originalCommit": "82ec99a3fb9e9e58f2c2d0c8fb3e049739cd7fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA0ODcxOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377048719", "bodyText": "This logout method I think is mostly used to implement the user initiated logout (when they click on the button) and is common with session based authentications. In this case this is a bit different because the token is issued by a third party so we need to call that to invalidate the token. Unfortunately Knox doesn't really provide a solid way for this. There is a proposal for this KIP-10 and some traces of this in their code but it doesn't seem to be a public and documented API so I didn't want to make a generic implementation based on that.", "author": "viktorsomogyi", "createdAt": "2020-02-10T13:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMzQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE3NTE3OA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377175178", "bodyText": "One more addition: reading up on it, JWTs can't be easily expired as they're stateless. On the provider side it's possible to set an expiration time for the cookie.\nA good article I found here: https://medium.com/devgorilla/how-to-log-out-when-using-jwt-a8c7823e8a6", "author": "viktorsomogyi", "createdAt": "2020-02-10T16:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMzQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NTg4Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377495882", "bodyText": "I see, cool :)", "author": "in-park", "createdAt": "2020-02-11T08:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMzQ1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\nindex dd90322f..020db543 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\n\n@@ -9,6 +9,7 @@ import com.nimbusds.jose.JOSEException;\n import com.nimbusds.jose.JWSObject;\n import com.nimbusds.jose.JWSVerifier;\n import com.nimbusds.jose.crypto.RSASSAVerifier;\n+import com.nimbusds.jwt.JWTClaimsSet;\n import com.nimbusds.jwt.SignedJWT;\n import org.eclipse.jetty.security.DefaultIdentityService;\n import org.eclipse.jetty.security.IdentityService;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQzMzY4Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r376433682", "bodyText": "nit:2020?", "author": "in-park", "createdAt": "2020-02-07T14:57:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2019 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.", "originalCommit": "82ec99a3fb9e9e58f2c2d0c8fb3e049739cd7fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java\nindex 445da118..a2db23b1 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2019 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n  */\n \n package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQzMzgwNg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r376433806", "bodyText": "nit:2020?", "author": "in-park", "createdAt": "2020-02-07T14:57:37Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserPrincipal.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright 2019 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.", "originalCommit": "82ec99a3fb9e9e58f2c2d0c8fb3e049739cd7fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserPrincipal.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserPrincipal.java\nindex 5ac177e6..1c5e36e8 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserPrincipal.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserPrincipal.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2019 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n  */\n \n package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MDA0NA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r376450044", "bodyText": "I am curious why BouncyCastle was used. Was there limitation in generating self-signed certificates with classes provided with JDK (for example CertAndKeyGen class)?", "author": "in-park", "createdAt": "2020-02-07T15:25:55Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtSecurityProviderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.CruiseControlIntegrationTestHarness;\n+import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n+import org.bouncycastle.asn1.x500.X500Name;\n+import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;\n+import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder;\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.security.HashLoginService;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.server.handler.AbstractHandler;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.math.BigInteger;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.cert.X509Certificate;\n+import java.util.Base64;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static com.linkedin.kafka.cruisecontrol.servlet.CruiseControlEndPoint.STATE;\n+import static org.junit.Assert.assertEquals;\n+\n+public class JwtSecurityProviderIntegrationTest extends CruiseControlIntegrationTestHarness {\n+\n+  private static final String CRUISE_CONTROL_STATE_ENDPOINT = \"kafkacruisecontrol/\" + STATE;\n+  private static final String TEST_USERNAME_KEY = \"username\";\n+  private static final String TEST_PASSWORD_KEY = \"password\";\n+  private static final String TEST_USERNAME = \"ccTestUser\";\n+  private static final String TEST_PASSWORD = \"TestPwd123\";\n+  private static final String ORIGIN = \"origin\";\n+  public static final String JWT_TOKEN_COOKIE_NAME = \"jwt_token\";\n+\n+  private final TokenGenerator.TokenAndKeys _tokenAndKeys;\n+  private final Server _tokenProviderServer;\n+  private final File _publicKeyFile;\n+\n+  class TestAuthenticatorHandler extends AbstractHandler {\n+\n+    HashLoginService _loginService;\n+\n+    TestAuthenticatorHandler() {\n+      _loginService = new HashLoginService();\n+      _loginService.setConfig(\n+          Objects.requireNonNull(this.getClass().getClassLoader().getResource(\"basic-auth.credentials\")).getPath());\n+    }\n+\n+    @Override\n+    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException {\n+      String username = request.getParameter(TEST_USERNAME_KEY);\n+      String password = request.getParameter(TEST_PASSWORD_KEY);\n+\n+      String cruiseControlUrl = request.getParameter(ORIGIN);\n+\n+      System.out.println(String.format(\"Handling login: %s %s %s\", username, password, cruiseControlUrl));\n+      UserIdentity identity = _loginService.login(username, password, request);\n+      if (identity != null) {\n+        response.addCookie(new Cookie(JWT_TOKEN_COOKIE_NAME, _tokenAndKeys.token()));\n+      } else {\n+        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n+      }\n+    }\n+\n+    @Override\n+    protected void doStart() throws Exception {\n+      super.doStart();\n+      _loginService.start();\n+    }\n+\n+    @Override\n+    protected void doStop() throws Exception {\n+      _loginService.stop();\n+      super.doStop();\n+    }\n+  }\n+\n+  public JwtSecurityProviderIntegrationTest() throws Exception {\n+    _tokenAndKeys = TokenGenerator.generateToken(TEST_USERNAME);\n+    _publicKeyFile = createCertificate(_tokenAndKeys);\n+    _tokenProviderServer = new Server(0);\n+    _tokenProviderServer.setHandler(new TestAuthenticatorHandler());\n+  }\n+\n+  /**\n+   * Starts the token provider and the Kafka environment before test\n+   * @throws Exception\n+   */\n+  @Before\n+  public void setup() throws Exception {\n+    _tokenProviderServer.start();\n+    super.start();\n+  }\n+\n+  /**\n+   * Stops the token provider and the Kafka environment after test\n+   * @throws Exception\n+   */\n+  @After\n+  public void teardown() throws Exception {\n+    super.stop();\n+    _tokenProviderServer.stop();\n+  }\n+\n+  @Override\n+  protected Map<String, Object> withConfigs() {\n+    Map<String, Object> securityConfigs = new HashMap<>();\n+    securityConfigs.put(WebServerConfig.WEBSERVER_SECURITY_ENABLE_CONFIG, true);\n+    securityConfigs.put(WebServerConfig.WEBSERVER_SECURITY_PROVIDER_CONFIG, JwtSecurityProvider.class);\n+    securityConfigs.put(WebServerConfig.JWT_AUTHENTICATION_PROVIDER_URL_CONFIG,\n+        _tokenProviderServer.getURI().toString() + \"?\" +\n+            TEST_USERNAME_KEY + \"=\" + TEST_USERNAME +\n+            \"&\" + TEST_PASSWORD_KEY + \"=\" + TEST_PASSWORD +\n+            \"&origin={redirectUrl}\");\n+    securityConfigs.put(WebServerConfig.WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG,\n+        Objects.requireNonNull(this.getClass().getClassLoader().getResource(\"jwt-auth.credentials\")).getPath());\n+    securityConfigs.put(WebServerConfig.JWT_COOKIE_NAME_CONFIG, JWT_TOKEN_COOKIE_NAME);\n+    securityConfigs.put(WebServerConfig.JWT_AUTH_CERTIFICATE_LOCATION_CONFIG, _publicKeyFile.getAbsolutePath());\n+\n+    return securityConfigs;\n+  }\n+\n+  @Test\n+  public void testSuccessfulLogin() throws Exception {\n+    HttpURLConnection stateEndpointConnection = (HttpURLConnection) new URI(_app.serverUrl())\n+        .resolve(CRUISE_CONTROL_STATE_ENDPOINT).toURL().openConnection();\n+    String cookie = stateEndpointConnection.getHeaderField(HttpHeader.SET_COOKIE.asString());\n+    stateEndpointConnection = (HttpURLConnection) new URI(_app.serverUrl())\n+        .resolve(CRUISE_CONTROL_STATE_ENDPOINT).toURL().openConnection();\n+    stateEndpointConnection.setRequestProperty(HttpHeader.COOKIE.asString(), cookie);\n+    assertEquals(HttpServletResponse.SC_OK, stateEndpointConnection.getResponseCode());\n+  }\n+\n+  private File createCertificate(TokenGenerator.TokenAndKeys tokenAndKeys) throws Exception {\n+    String subjectDN = \"C=US, ST=California, L=Santa Clara, O=LinkedIn, CN=localhost\";\n+    Provider bcProvider = new BouncyCastleProvider();", "originalCommit": "82ec99a3fb9e9e58f2c2d0c8fb3e049739cd7fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAzMTU2NA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377031564", "bodyText": "There aren't really good classes in plain Java to work with on this level (as far as I saw). CertAndKeyGen is unfortunately in a Sun package and therefore belongs to Oracle so I think we should avoid it as it isn't compatible with OpenJDK.\nAdditionally to this, BouncyCastle was already a dependency of the metrics reporter tests so I thought it's not a too big leap to use this here.", "author": "viktorsomogyi", "createdAt": "2020-02-10T12:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MDA0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NjEyNw==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377496127", "bodyText": "Ah ok, understood.", "author": "in-park", "createdAt": "2020-02-11T08:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MDA0NA=="}], "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtSecurityProviderIntegrationTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtSecurityProviderIntegrationTest.java\nindex 1661d837..d8d63307 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtSecurityProviderIntegrationTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtSecurityProviderIntegrationTest.java\n\n@@ -135,7 +135,7 @@ public class JwtSecurityProviderIntegrationTest extends CruiseControlIntegration\n         _tokenProviderServer.getURI().toString() + \"?\" +\n             TEST_USERNAME_KEY + \"=\" + TEST_USERNAME +\n             \"&\" + TEST_PASSWORD_KEY + \"=\" + TEST_PASSWORD +\n-            \"&origin={redirectUrl}\");\n+            \"&origin=\" + JwtAuthenticator.REDIRECT_URL);\n     securityConfigs.put(WebServerConfig.WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG,\n         Objects.requireNonNull(this.getClass().getClassLoader().getResource(\"jwt-auth.credentials\")).getPath());\n     securityConfigs.put(WebServerConfig.JWT_COOKIE_NAME_CONFIG, JWT_TOKEN_COOKIE_NAME);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwNjczOA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383606738", "bodyText": "Can we add missing public static final String DEFAULT_XXX for each config? -- please see the HEAD version of this file.", "author": "efeg", "createdAt": "2020-02-25T01:11:20Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/WebServerConfig.java", "diffHunk": "@@ -220,6 +220,38 @@ private WebServerConfig() {\n   public static final String WEBSERVER_SSL_PROTOCOL_CONFIG = \"webserver.ssl.protocol\";\n   private static final String WEBSERVER_SSL_PROTOCOL_DOC = \"Sets the SSL protocol to use. By default it's TLS.\";\n \n+  /**\n+   * <code>jwt.authentication.provider.url</code>\n+   */\n+  public static final String JWT_AUTHENTICATION_PROVIDER_URL_CONFIG = \"jwt.authentication.provider.url\";\n+  private static final String JWT_AUTHENTICATION_PROVIDER_URL_DOCS = \"This is an endpoint of the token issuer. \" +\n+      \"Requests without tokens will be redirected to this endpoint for authentication. The given url can contain \" +\n+      \"the {redirectUrl} string which is an instruction to the authentication service to redirect to the original \" +\n+      \"Cruise Control URL after a successful login. For instance www.my-auth.service.com/websso?origin={redirectUrl}.\";\n+\n+  /**\n+   * <code>jwt.cookie.name</code>\n+   */\n+  public static final String JWT_COOKIE_NAME_CONFIG = \"jwt.cookie.name\";\n+  private static final String JWT_COOKIE_NAME_DOCS = \"Cruise Control expects issued tokens to be forwarded in a cookie. \" +\n+      \"This config specifies which one will contain the token.\";\n+\n+  /**\n+   * <code>jwt.auth.certificate.location</code>\n+   */\n+  public static final String JWT_AUTH_CERTIFICATE_LOCATION_CONFIG = \"jwt.auth.certificate.location\";\n+  private static final String JWT_AUTH_CERTIFICATE_LOCATION_DOCS = \"A private key is used to sign the JWT token by the \" +\n+      \"authentication service and its public key pair is used to validate the signature in the token. This config points \" +\n+      \"to the location of the file containing that public key.\";\n+\n+  /**\n+   * <code>jwt.expected.audiences</code>\n+   */\n+  public static final String JWT_EXPECTED_AUDIENCES_CONFIG = \"jwt.expected.audiences\";\n+  private static final String JWT_EXPECTED_AUDIENCES_DOCS = \"A comma separated list of audiences that Cruise Control accepts. \" +\n+      \"Audience is a way for the issuer to indicate what entities the token is intended for. The default value is null, \" +\n+      \"which means all audiences are accepted.\";\n+", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/WebServerConfig.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/WebServerConfig.java\nindex b3819a4d..7eb6d2b7 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/WebServerConfig.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/WebServerConfig.java\n\n@@ -212,19 +216,22 @@ public class WebServerConfig {\n    * <code>webserver.ssl.key.password</code>\n    */\n   public static final String WEBSERVER_SSL_KEY_PASSWORD_CONFIG = \"webserver.ssl.key.password\";\n+  public static final String DEFAULT_WEBSERVER_SSL_KEY_PASSWORD = null;\n   private static final String WEBSERVER_SSL_KEY_PASSWORD_DOC = \"The password of the private key in the key store file.\";\n \n   /**\n    * <code>webserver.ssl.protocol</code>\n    */\n   public static final String WEBSERVER_SSL_PROTOCOL_CONFIG = \"webserver.ssl.protocol\";\n+  public static final String DEFAULT_WEBSERVER_SSL_PROTOCOL = \"TLS\";\n   private static final String WEBSERVER_SSL_PROTOCOL_DOC = \"Sets the SSL protocol to use. By default it's TLS.\";\n \n   /**\n    * <code>jwt.authentication.provider.url</code>\n    */\n   public static final String JWT_AUTHENTICATION_PROVIDER_URL_CONFIG = \"jwt.authentication.provider.url\";\n-  private static final String JWT_AUTHENTICATION_PROVIDER_URL_DOCS = \"This is an endpoint of the token issuer. \" +\n+  public static final String DEFAULT_JWT_AUTHENTICATION_PROVIDER_URL = null;\n+  private static final String JWT_AUTHENTICATION_PROVIDER_URL_DOC = \"This is an endpoint of the token issuer. \" +\n       \"Requests without tokens will be redirected to this endpoint for authentication. The given url can contain \" +\n       \"the {redirectUrl} string which is an instruction to the authentication service to redirect to the original \" +\n       \"Cruise Control URL after a successful login. For instance www.my-auth.service.com/websso?origin={redirectUrl}.\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwNzE0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383607142", "bodyText": "Nit: For consistency, can we change XXX_DOCS to XXX_DOC?", "author": "efeg", "createdAt": "2020-02-25T01:12:47Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/WebServerConfig.java", "diffHunk": "@@ -220,6 +220,38 @@ private WebServerConfig() {\n   public static final String WEBSERVER_SSL_PROTOCOL_CONFIG = \"webserver.ssl.protocol\";\n   private static final String WEBSERVER_SSL_PROTOCOL_DOC = \"Sets the SSL protocol to use. By default it's TLS.\";\n \n+  /**\n+   * <code>jwt.authentication.provider.url</code>\n+   */\n+  public static final String JWT_AUTHENTICATION_PROVIDER_URL_CONFIG = \"jwt.authentication.provider.url\";\n+  private static final String JWT_AUTHENTICATION_PROVIDER_URL_DOCS = \"This is an endpoint of the token issuer. \" +\n+      \"Requests without tokens will be redirected to this endpoint for authentication. The given url can contain \" +\n+      \"the {redirectUrl} string which is an instruction to the authentication service to redirect to the original \" +\n+      \"Cruise Control URL after a successful login. For instance www.my-auth.service.com/websso?origin={redirectUrl}.\";\n+\n+  /**\n+   * <code>jwt.cookie.name</code>\n+   */\n+  public static final String JWT_COOKIE_NAME_CONFIG = \"jwt.cookie.name\";\n+  private static final String JWT_COOKIE_NAME_DOCS = \"Cruise Control expects issued tokens to be forwarded in a cookie. \" +\n+      \"This config specifies which one will contain the token.\";\n+\n+  /**\n+   * <code>jwt.auth.certificate.location</code>\n+   */\n+  public static final String JWT_AUTH_CERTIFICATE_LOCATION_CONFIG = \"jwt.auth.certificate.location\";\n+  private static final String JWT_AUTH_CERTIFICATE_LOCATION_DOCS = \"A private key is used to sign the JWT token by the \" +\n+      \"authentication service and its public key pair is used to validate the signature in the token. This config points \" +\n+      \"to the location of the file containing that public key.\";\n+\n+  /**\n+   * <code>jwt.expected.audiences</code>\n+   */\n+  public static final String JWT_EXPECTED_AUDIENCES_CONFIG = \"jwt.expected.audiences\";\n+  private static final String JWT_EXPECTED_AUDIENCES_DOCS = \"A comma separated list of audiences that Cruise Control accepts. \" +", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/WebServerConfig.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/WebServerConfig.java\nindex b3819a4d..7eb6d2b7 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/WebServerConfig.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/WebServerConfig.java\n\n@@ -212,19 +216,22 @@ public class WebServerConfig {\n    * <code>webserver.ssl.key.password</code>\n    */\n   public static final String WEBSERVER_SSL_KEY_PASSWORD_CONFIG = \"webserver.ssl.key.password\";\n+  public static final String DEFAULT_WEBSERVER_SSL_KEY_PASSWORD = null;\n   private static final String WEBSERVER_SSL_KEY_PASSWORD_DOC = \"The password of the private key in the key store file.\";\n \n   /**\n    * <code>webserver.ssl.protocol</code>\n    */\n   public static final String WEBSERVER_SSL_PROTOCOL_CONFIG = \"webserver.ssl.protocol\";\n+  public static final String DEFAULT_WEBSERVER_SSL_PROTOCOL = \"TLS\";\n   private static final String WEBSERVER_SSL_PROTOCOL_DOC = \"Sets the SSL protocol to use. By default it's TLS.\";\n \n   /**\n    * <code>jwt.authentication.provider.url</code>\n    */\n   public static final String JWT_AUTHENTICATION_PROVIDER_URL_CONFIG = \"jwt.authentication.provider.url\";\n-  private static final String JWT_AUTHENTICATION_PROVIDER_URL_DOCS = \"This is an endpoint of the token issuer. \" +\n+  public static final String DEFAULT_JWT_AUTHENTICATION_PROVIDER_URL = null;\n+  private static final String JWT_AUTHENTICATION_PROVIDER_URL_DOC = \"This is an endpoint of the token issuer. \" +\n       \"Requests without tokens will be redirected to this endpoint for authentication. The given url can contain \" +\n       \"the {redirectUrl} string which is an instruction to the authentication service to redirect to the original \" +\n       \"Cruise Control URL after a successful login. For instance www.my-auth.service.com/websso?origin={redirectUrl}.\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMTE4NA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383621184", "bodyText": "It is not clear why (1) BasicSecurityProvider, (2) DefaultRoleSecurityProvider, or (3) JwtSecurityProvider have throws ServletException in their method signature.", "author": "efeg", "createdAt": "2020-02-25T02:07:21Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/BasicSecurityProvider.java", "diffHunk": "@@ -20,9 +22,9 @@\n   private String _userCredentialsFile;\n \n   @Override\n-  public void init(KafkaCruiseControlConfig config) {\n+  public void init(KafkaCruiseControlConfig config) throws ServletException {", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY0NDMwNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r385644305", "bodyText": "Fair thought, they shouldn't.", "author": "viktorsomogyi", "createdAt": "2020-02-28T11:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMTE4NA=="}], "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/BasicSecurityProvider.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/BasicSecurityProvider.java\nindex 970d8f5e..747457b4 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/BasicSecurityProvider.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/BasicSecurityProvider.java\n\n@@ -22,7 +20,7 @@ public class BasicSecurityProvider extends DefaultRoleSecurityProvider {\n   private String _userCredentialsFile;\n \n   @Override\n-  public void init(KafkaCruiseControlConfig config) throws ServletException {\n+  public void init(KafkaCruiseControlConfig config) {\n     super.init(config);\n     this._userCredentialsFile = config.getString(WebServerConfig.WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG);\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMTY2Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383621662", "bodyText": "Nit: low amount of users -> low number of users", "author": "efeg", "createdAt": "2020-02-25T02:09:20Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/UserStoreAuthorizationService.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security;\n+\n+import org.eclipse.jetty.security.PropertyUserStore;\n+import org.eclipse.jetty.security.UserStore;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.util.component.AbstractLifeCycle;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * Can be used for authorization scenarios where a file can be created in a secure location with a relatively\n+ * low amount of users. It follows the <code>username: password [,rolename ...]</code> format which corresponds to", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/UserStoreAuthorizationService.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/UserStoreAuthorizationService.java\nindex a012a871..440befd0 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/UserStoreAuthorizationService.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/UserStoreAuthorizationService.java\n\n@@ -14,7 +14,7 @@ import javax.servlet.http.HttpServletRequest;\n \n /**\n  * Can be used for authorization scenarios where a file can be created in a secure location with a relatively\n- * low amount of users. It follows the <code>username: password [,rolename ...]</code> format which corresponds to\n+ * low number of users. It follows the <code>username: password [,rolename ...]</code> format which corresponds to\n  * the format used with {@link org.eclipse.jetty.security.HashLoginService}.\n  */\n public class UserStoreAuthorizationService extends AbstractLifeCycle implements AuthorizationService {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMjI5OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383622299", "bodyText": "Typo: SSO capabilites -> SSO capabilities", "author": "efeg", "createdAt": "2020-02-25T02:12:08Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.security.ServerAuthException;\n+import org.eclipse.jetty.security.UserAuthentication;\n+import org.eclipse.jetty.security.authentication.LoginAuthenticator;\n+import org.eclipse.jetty.server.Authentication;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.function.Function;\n+\n+/**\n+ * <p>The {@link JwtAuthenticator} adds SSO capabilites to Cruise Control. The expected token is a Json Web Token (JWT).", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java\nindex 7b6f1c6f..666ec458 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java\n\n@@ -25,7 +25,7 @@ import java.text.ParseException;\n import java.util.function.Function;\n \n /**\n- * <p>The {@link JwtAuthenticator} adds SSO capabilites to Cruise Control. The expected token is a Json Web Token (JWT).\n+ * <p>The {@link JwtAuthenticator} adds SSO capabilities to Cruise Control. The expected token is a Json Web Token (JWT).\n  * This class should be used with {@link JwtLoginService} as the token check is carried out by that one. This class\n  * handles redirects for unauthenticated requests and CORS preflight requests.</p>\n  * <p>The workflow can be described with the following diagram:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMzQxNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383623415", "bodyText": "Nit: Can we move the hardcoded String (i.e. \"{redirectUrl}\") to a static variable?", "author": "efeg", "createdAt": "2020-02-25T02:16:33Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.security.ServerAuthException;\n+import org.eclipse.jetty.security.UserAuthentication;\n+import org.eclipse.jetty.security.authentication.LoginAuthenticator;\n+import org.eclipse.jetty.server.Authentication;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.function.Function;\n+\n+/**\n+ * <p>The {@link JwtAuthenticator} adds SSO capabilites to Cruise Control. The expected token is a Json Web Token (JWT).\n+ * This class should be used with {@link JwtLoginService} as the token check is carried out by that one. This class\n+ * handles redirects for unauthenticated requests and CORS preflight requests.</p>\n+ * <p>The workflow can be described with the following diagram:\n+ * <pre>\n+ *       Client -----1., 4.----> Cruise Control\n+ *        |  ^                        |\n+ *        |  |________2.______________|\n+ *        |\n+ *        |\n+ *        |------3.------------> Authentication\n+ *                                 provider\n+ * </pre>\n+ * <ol>\n+ * <li>The client makes an initial call to Cruise Control\n+ * <li>If the request doesn't have a JWT cookie by the specified cookie name, it will be redirected to the authentication\n+ *     service to obtain it. If the request is an OPTIONS request we presume it's a CORS preflight request so it'll skip\n+ *     the authentication (if the user is authenticated at this point we'll use the existing credentials).\n+ * <li>The client authenticates with the provider and obtains the SSO token.\n+ * <li>The client can present the JWT cookie to Cruise Control. Cruise Control will validate the cookie with the\n+ *    {@link JwtLoginService} by checking its signature, audience and expiration.\n+ * </ol>\n+ * </p>\n+ */\n+public class JwtAuthenticator extends LoginAuthenticator {\n+\n+  public static final String JWT_TOKEN_REQUEST_ATTRIBUTE = \"com.linkedin.kafka.cruisecontrol.JwtTokenAttribute\";\n+  static final Logger JWT_LOGGER = LoggerFactory.getLogger(\"kafka.cruisecontrol.jwt.logger\");\n+\n+  private static final String METHOD = \"JWT\";\n+  private static final String BEARER = \"Bearer\";\n+\n+  private final String _cookieName;\n+  private final Function<HttpServletRequest, String> _authenticationProviderUrlGenerator;\n+\n+  /**\n+   * Creates a new {@link JwtAuthenticator} instance with a custom authentication provider url and a cookie name that\n+   * will be populated by the authentication service with the JWT token.\n+   * @param authenticationProviderUrl is the HTTP(S) address of the authentication service. It will be used to create\n+   *                                  the redirection url. For instance <code>https://www.my-auth-service.com/websso?origin={redirectUrl}</code>\n+   *                                  will generate <code>https://www.my-auth-service.com/websso?origin=https://www.cruise-control.cc/state</code>\n+   *                                  which should redirect from <code>my-auth-service.com</code> to <code>cruise-control.cc/state</code>\n+   *                                  after obtaining the JWT token.\n+   * @param cookieName is the cookie name which will contain the cookie obtained from the authentication service.\n+   *                   <code>null</code> is an acceptable value when the token is always returned\n+   */\n+  public JwtAuthenticator(String authenticationProviderUrl, String cookieName) {\n+    _cookieName = cookieName;\n+    Function<String, Function<HttpServletRequest, String>> urlGen =\n+        url -> req -> url.replace(\"{redirectUrl}\", req.getRequestURL().toString() + getOriginalQueryString(req));", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java\nindex 7b6f1c6f..666ec458 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java\n\n@@ -25,7 +25,7 @@ import java.text.ParseException;\n import java.util.function.Function;\n \n /**\n- * <p>The {@link JwtAuthenticator} adds SSO capabilites to Cruise Control. The expected token is a Json Web Token (JWT).\n+ * <p>The {@link JwtAuthenticator} adds SSO capabilities to Cruise Control. The expected token is a Json Web Token (JWT).\n  * This class should be used with {@link JwtLoginService} as the token check is carried out by that one. This class\n  * handles redirects for unauthenticated requests and CORS preflight requests.</p>\n  * <p>The workflow can be described with the following diagram:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNDg2Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383624862", "bodyText": "encrypted an It uses  -> broken sentence.", "author": "efeg", "createdAt": "2020-02-25T02:22:33Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSObject;\n+import com.nimbusds.jose.JWSVerifier;\n+import com.nimbusds.jose.crypto.RSASSAVerifier;\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.security.DefaultIdentityService;\n+import org.eclipse.jetty.security.IdentityService;\n+import org.eclipse.jetty.security.LoginService;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.util.component.AbstractLifeCycle;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+\n+import javax.security.auth.Subject;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPublicKey;\n+import java.text.ParseException;\n+import java.time.Clock;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static com.linkedin.kafka.cruisecontrol.servlet.security.jwt.JwtAuthenticator.JWT_LOGGER;\n+\n+/**\n+ * <p>This class validates a JWT token. The token must be cryptographically encrypted an It uses an RSA public key for", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\nindex 5e2b6a3e..020db543 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\n\n@@ -41,7 +41,7 @@ import java.util.Set;\n import static com.linkedin.kafka.cruisecontrol.servlet.security.jwt.JwtAuthenticator.JWT_LOGGER;\n \n /**\n- * <p>This class validates a JWT token. The token must be cryptographically encrypted an It uses an RSA public key for\n+ * <p>This class validates a JWT token. The token must be cryptographically encrypted and it uses an RSA public key for\n  * validation that is expected to be stored in a PEM formatted file.</p>\n  * <p>This class implements {@link AbstractLifeCycle} which means it is a managed bean, its lifecycle will be managed\n  * by Jetty. It's {@link AuthorizationService} can also be an {@link AbstractLifeCycle} in which case it delegates to\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNTI2Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383625267", "bodyText": "Nit: For code style consistency, can we move this initialization to the constructor?", "author": "efeg", "createdAt": "2020-02-25T02:24:16Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSObject;\n+import com.nimbusds.jose.JWSVerifier;\n+import com.nimbusds.jose.crypto.RSASSAVerifier;\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.security.DefaultIdentityService;\n+import org.eclipse.jetty.security.IdentityService;\n+import org.eclipse.jetty.security.LoginService;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.util.component.AbstractLifeCycle;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+\n+import javax.security.auth.Subject;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPublicKey;\n+import java.text.ParseException;\n+import java.time.Clock;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static com.linkedin.kafka.cruisecontrol.servlet.security.jwt.JwtAuthenticator.JWT_LOGGER;\n+\n+/**\n+ * <p>This class validates a JWT token. The token must be cryptographically encrypted an It uses an RSA public key for\n+ * validation that is expected to be stored in a PEM formatted file.</p>\n+ * <p>This class implements {@link AbstractLifeCycle} which means it is a managed bean, its lifecycle will be managed\n+ * by Jetty. It's {@link AuthorizationService} can also be an {@link AbstractLifeCycle} in which case it delegates to\n+ * this class, so opening and closing connections should be done by implementing the {@link AbstractLifeCycle} interface's\n+ * {@link #doStart()} and {@link #doStop()} methods respectively. For a simple example see\n+ * {@link UserStoreAuthorizationService}.</p>\n+ * <p>The login service also validates expiration time of the token and it expects the token to contain the expiration\n+ * in Unix epoch time format in UTC.</p>\n+ */\n+public class JwtLoginService extends AbstractLifeCycle implements LoginService {\n+\n+  private final AuthorizationService _authorizationService;\n+  private IdentityService _identityService = new DefaultIdentityService();", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1NzY4Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r385657687", "bodyText": "Sure", "author": "viktorsomogyi", "createdAt": "2020-02-28T11:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNTI2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\nindex 5e2b6a3e..020db543 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\n\n@@ -41,7 +41,7 @@ import java.util.Set;\n import static com.linkedin.kafka.cruisecontrol.servlet.security.jwt.JwtAuthenticator.JWT_LOGGER;\n \n /**\n- * <p>This class validates a JWT token. The token must be cryptographically encrypted an It uses an RSA public key for\n+ * <p>This class validates a JWT token. The token must be cryptographically encrypted and it uses an RSA public key for\n  * validation that is expected to be stored in a PEM formatted file.</p>\n  * <p>This class implements {@link AbstractLifeCycle} which means it is a managed bean, its lifecycle will be managed\n  * by Jetty. It's {@link AuthorizationService} can also be an {@link AbstractLifeCycle} in which case it delegates to\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNjA0Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383626047", "bodyText": "Nit: Can we move the certificate type to a static variable?", "author": "efeg", "createdAt": "2020-02-25T02:27:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSObject;\n+import com.nimbusds.jose.JWSVerifier;\n+import com.nimbusds.jose.crypto.RSASSAVerifier;\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.security.DefaultIdentityService;\n+import org.eclipse.jetty.security.IdentityService;\n+import org.eclipse.jetty.security.LoginService;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.util.component.AbstractLifeCycle;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+\n+import javax.security.auth.Subject;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPublicKey;\n+import java.text.ParseException;\n+import java.time.Clock;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static com.linkedin.kafka.cruisecontrol.servlet.security.jwt.JwtAuthenticator.JWT_LOGGER;\n+\n+/**\n+ * <p>This class validates a JWT token. The token must be cryptographically encrypted an It uses an RSA public key for\n+ * validation that is expected to be stored in a PEM formatted file.</p>\n+ * <p>This class implements {@link AbstractLifeCycle} which means it is a managed bean, its lifecycle will be managed\n+ * by Jetty. It's {@link AuthorizationService} can also be an {@link AbstractLifeCycle} in which case it delegates to\n+ * this class, so opening and closing connections should be done by implementing the {@link AbstractLifeCycle} interface's\n+ * {@link #doStart()} and {@link #doStop()} methods respectively. For a simple example see\n+ * {@link UserStoreAuthorizationService}.</p>\n+ * <p>The login service also validates expiration time of the token and it expects the token to contain the expiration\n+ * in Unix epoch time format in UTC.</p>\n+ */\n+public class JwtLoginService extends AbstractLifeCycle implements LoginService {\n+\n+  private final AuthorizationService _authorizationService;\n+  private IdentityService _identityService = new DefaultIdentityService();\n+  private final RSAPublicKey _publicKey;\n+  private final List<String> _audiences;\n+  private Clock _clock;\n+\n+  public JwtLoginService(AuthorizationService authorizationService, String publicKeyLocation, List<String> audiences)\n+      throws IOException, CertificateException {\n+    this(authorizationService, readPublicKey(publicKeyLocation), audiences);\n+  }\n+\n+  public JwtLoginService(AuthorizationService authorizationService, RSAPublicKey publicKey, List<String> audiences) {\n+    this(authorizationService, publicKey, audiences, Clock.systemUTC());\n+  }\n+\n+  public JwtLoginService(AuthorizationService authorizationService, RSAPublicKey publicKey, List<String> audiences, Clock clock) {\n+    _authorizationService = authorizationService;\n+    _publicKey = publicKey;\n+    _audiences = audiences;\n+    _clock = clock;\n+  }\n+\n+  @Override\n+  protected void doStart() throws Exception {\n+    super.doStart();\n+    // The authorization service might want to start a connection or access a file\n+    if (_authorizationService instanceof LifeCycle) {\n+      ((LifeCycle) _authorizationService).start();\n+    }\n+  }\n+\n+  @Override\n+  protected void doStop() throws Exception {\n+    if (_authorizationService instanceof LifeCycle) {\n+      ((LifeCycle) _authorizationService).stop();\n+    }\n+    super.doStop();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public UserIdentity login(String username, Object credentials, ServletRequest request) {\n+    if (!(credentials instanceof SignedJWT)) {\n+      return null;\n+    }\n+    if (!(request instanceof HttpServletRequest)) {\n+      return null;\n+    }\n+\n+    SignedJWT jwtToken = (SignedJWT) credentials;\n+    JWTClaimsSet claimsSet;\n+    boolean valid;\n+    try {\n+      claimsSet = jwtToken.getJWTClaimsSet();\n+      valid = validateToken(jwtToken, claimsSet, username);\n+    } catch (ParseException e) {\n+      JWT_LOGGER.warn(String.format(\"%s: Couldn't parse a JWT token\", username), e);\n+      return null;\n+    }\n+    if (valid) {\n+      String serializedToken = (String) request.getAttribute(JwtAuthenticator.JWT_TOKEN_REQUEST_ATTRIBUTE);\n+      UserIdentity rolesDelegate = _authorizationService.getUserIdentity((HttpServletRequest) request, username);\n+      return getUserIdentity(jwtToken, claimsSet, serializedToken, username, rolesDelegate);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public boolean validate(UserIdentity user) {\n+    Set<JWTClaimsSet> claims = user.getSubject().getPrivateCredentials(JWTClaimsSet.class);\n+    return !claims.isEmpty() && claims.stream().allMatch(this::validateExpiration);\n+  }\n+\n+  @Override\n+  public IdentityService getIdentityService() {\n+    return _identityService;\n+  }\n+\n+  @Override\n+  public void setIdentityService(IdentityService service) {\n+    _identityService = service;\n+  }\n+\n+  @Override\n+  public void logout(UserIdentity user) {\n+\n+  }\n+\n+  // visible for testing\n+  void setClock(Clock newClock) {\n+    _clock = newClock;\n+  }\n+\n+  private boolean validateToken(SignedJWT jwtToken, JWTClaimsSet claimsSet, String username) {\n+    boolean sigValid = validateSignature(jwtToken);\n+    if (!sigValid) {\n+      JWT_LOGGER.warn(String.format(\"%s: Signature could not be verified\", username));\n+    }\n+    boolean audValid = validateAudiences(claimsSet);\n+    if (!audValid) {\n+      JWT_LOGGER.warn(String.format(\"%s: Audience validation failed\", username));\n+    }\n+    boolean expValid = validateExpiration(claimsSet);\n+    if (!expValid) {\n+      JWT_LOGGER.warn(String.format(\"%s: Expiration validation failed\", username));\n+    }\n+\n+    return sigValid && audValid && expValid;\n+  }\n+\n+  private boolean validateSignature(SignedJWT jwtToken) {\n+    if (JWSObject.State.SIGNED != jwtToken.getState() || jwtToken.getSignature() == null) {\n+      return false;\n+    }\n+    JWSVerifier verifier = new RSASSAVerifier(_publicKey);\n+    try {\n+      return jwtToken.verify(verifier);\n+    } catch (JOSEException e) {\n+      JWT_LOGGER.warn(\"Couldn't verify the signature of a token\", e);\n+      return false;\n+    }\n+  }\n+\n+  private boolean validateAudiences(JWTClaimsSet claimsSet) {\n+    if (_audiences == null) {\n+      return true;\n+    }\n+    List<String> tokenAudienceList = claimsSet.getAudience();\n+    for (String aud : tokenAudienceList) {\n+      if (_audiences.contains(aud)) {\n+        JWT_LOGGER.trace(\"JWT token audience has been successfully validated\");\n+        return true;\n+      }\n+    }\n+    JWT_LOGGER.trace(\"Couldn't find a valid audience\");\n+    return false;\n+  }\n+\n+  private boolean validateExpiration(JWTClaimsSet claimsSet) {\n+    Date expires = claimsSet.getExpirationTime();\n+    return expires == null || _clock.instant().isBefore(expires.toInstant());\n+  }\n+\n+  private static RSAPublicKey readPublicKey(String location) throws CertificateException, IOException {\n+    byte[] publicKeyBytes = Files.readAllBytes(Paths.get(location));\n+    CertificateFactory fact = CertificateFactory.getInstance(\"X.509\");", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\nindex 5e2b6a3e..020db543 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java\n\n@@ -41,7 +41,7 @@ import java.util.Set;\n import static com.linkedin.kafka.cruisecontrol.servlet.security.jwt.JwtAuthenticator.JWT_LOGGER;\n \n /**\n- * <p>This class validates a JWT token. The token must be cryptographically encrypted an It uses an RSA public key for\n+ * <p>This class validates a JWT token. The token must be cryptographically encrypted and it uses an RSA public key for\n  * validation that is expected to be stored in a PEM formatted file.</p>\n  * <p>This class implements {@link AbstractLifeCycle} which means it is a managed bean, its lifecycle will be managed\n  * by Jetty. It's {@link AuthorizationService} can also be an {@link AbstractLifeCycle} in which case it delegates to\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNzA0Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383627046", "bodyText": "Should we add any sanity checks regarding the value of these configs -- e.g. maybe under KafkaCruiseControlConfig#sanityCheckSecurity?", "author": "efeg", "createdAt": "2020-02-25T02:30:41Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtSecurityProvider.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n+import com.linkedin.kafka.cruisecontrol.servlet.security.DefaultRoleSecurityProvider;\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import org.eclipse.jetty.security.Authenticator;\n+import org.eclipse.jetty.security.LoginService;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+\n+import javax.servlet.ServletException;\n+import java.io.IOException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+\n+/**\n+ * A security provider implementation for JWT based authentication. It has to be configured with\n+ * <ul>\n+ *   <li>{@link WebServerConfig#JWT_AUTHENTICATION_PROVIDER_URL_CONFIG} that is the url of the token issuer,\n+ *   <li>{@link WebServerConfig#JWT_COOKIE_NAME_CONFIG} that is the name of the cookie that contains the issued token\n+ *   <li>{@link WebServerConfig#JWT_AUTH_CERTIFICATE_LOCATION_CONFIG} which is shared by the issuer to validate tokens\n+ *   <li>{@link WebServerConfig#JWT_EXPECTED_AUDIENCES_CONFIG} which is the expected audiences of the token (so a token\n+ *   will be rejected if it contains anything other than what is listed here)\n+ *   <li>{@link WebServerConfig#WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG} which contains the username-role associations\n+ *   without any passwords.\n+ * </ul>\n+ */\n+public class JwtSecurityProvider extends DefaultRoleSecurityProvider {\n+\n+  private String _authenticationProviderUrl;\n+  private String _cookieName;\n+  private String _publicKeyLocation;\n+  private String _privilegesFilePath;\n+  private List<String> _audiences;\n+\n+  @Override\n+  public void init(KafkaCruiseControlConfig config) throws ServletException {\n+    super.init(config);\n+    _authenticationProviderUrl = config.getString(WebServerConfig.JWT_AUTHENTICATION_PROVIDER_URL_CONFIG);\n+    _cookieName = config.getString(WebServerConfig.JWT_COOKIE_NAME_CONFIG);\n+    _publicKeyLocation = config.getString(WebServerConfig.JWT_AUTH_CERTIFICATE_LOCATION_CONFIG);\n+    _audiences = config.getList(WebServerConfig.JWT_EXPECTED_AUDIENCES_CONFIG);\n+    _privilegesFilePath = config.getString(WebServerConfig.WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG);", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtSecurityProvider.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtSecurityProvider.java\nindex 4f4a3267..23a337a2 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtSecurityProvider.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtSecurityProvider.java\n\n@@ -38,7 +38,7 @@ public class JwtSecurityProvider extends DefaultRoleSecurityProvider {\n   private List<String> _audiences;\n \n   @Override\n-  public void init(KafkaCruiseControlConfig config) throws ServletException {\n+  public void init(KafkaCruiseControlConfig config) {\n     super.init(config);\n     _authenticationProviderUrl = config.getString(WebServerConfig.JWT_AUTHENTICATION_PROVIDER_URL_CONFIG);\n     _cookieName = config.getString(WebServerConfig.JWT_COOKIE_NAME_CONFIG);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyODM5NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383628395", "bodyText": "Is null an acceptable value for authenticationProviderUrl? -- e.g. JwtSecurityProvider#authenticator() may set its value to null.", "author": "efeg", "createdAt": "2020-02-25T02:36:32Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.security.ServerAuthException;\n+import org.eclipse.jetty.security.UserAuthentication;\n+import org.eclipse.jetty.security.authentication.LoginAuthenticator;\n+import org.eclipse.jetty.server.Authentication;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.function.Function;\n+\n+/**\n+ * <p>The {@link JwtAuthenticator} adds SSO capabilites to Cruise Control. The expected token is a Json Web Token (JWT).\n+ * This class should be used with {@link JwtLoginService} as the token check is carried out by that one. This class\n+ * handles redirects for unauthenticated requests and CORS preflight requests.</p>\n+ * <p>The workflow can be described with the following diagram:\n+ * <pre>\n+ *       Client -----1., 4.----> Cruise Control\n+ *        |  ^                        |\n+ *        |  |________2.______________|\n+ *        |\n+ *        |\n+ *        |------3.------------> Authentication\n+ *                                 provider\n+ * </pre>\n+ * <ol>\n+ * <li>The client makes an initial call to Cruise Control\n+ * <li>If the request doesn't have a JWT cookie by the specified cookie name, it will be redirected to the authentication\n+ *     service to obtain it. If the request is an OPTIONS request we presume it's a CORS preflight request so it'll skip\n+ *     the authentication (if the user is authenticated at this point we'll use the existing credentials).\n+ * <li>The client authenticates with the provider and obtains the SSO token.\n+ * <li>The client can present the JWT cookie to Cruise Control. Cruise Control will validate the cookie with the\n+ *    {@link JwtLoginService} by checking its signature, audience and expiration.\n+ * </ol>\n+ * </p>\n+ */\n+public class JwtAuthenticator extends LoginAuthenticator {\n+\n+  public static final String JWT_TOKEN_REQUEST_ATTRIBUTE = \"com.linkedin.kafka.cruisecontrol.JwtTokenAttribute\";\n+  static final Logger JWT_LOGGER = LoggerFactory.getLogger(\"kafka.cruisecontrol.jwt.logger\");\n+\n+  private static final String METHOD = \"JWT\";\n+  private static final String BEARER = \"Bearer\";\n+\n+  private final String _cookieName;\n+  private final Function<HttpServletRequest, String> _authenticationProviderUrlGenerator;\n+\n+  /**\n+   * Creates a new {@link JwtAuthenticator} instance with a custom authentication provider url and a cookie name that\n+   * will be populated by the authentication service with the JWT token.\n+   * @param authenticationProviderUrl is the HTTP(S) address of the authentication service. It will be used to create\n+   *                                  the redirection url. For instance <code>https://www.my-auth-service.com/websso?origin={redirectUrl}</code>\n+   *                                  will generate <code>https://www.my-auth-service.com/websso?origin=https://www.cruise-control.cc/state</code>\n+   *                                  which should redirect from <code>my-auth-service.com</code> to <code>cruise-control.cc/state</code>\n+   *                                  after obtaining the JWT token.", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java\nindex 7b6f1c6f..666ec458 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java\n\n@@ -25,7 +25,7 @@ import java.text.ParseException;\n import java.util.function.Function;\n \n /**\n- * <p>The {@link JwtAuthenticator} adds SSO capabilites to Cruise Control. The expected token is a Json Web Token (JWT).\n+ * <p>The {@link JwtAuthenticator} adds SSO capabilities to Cruise Control. The expected token is a Json Web Token (JWT).\n  * This class should be used with {@link JwtLoginService} as the token check is carried out by that one. This class\n  * handles redirects for unauthenticated requests and CORS preflight requests.</p>\n  * <p>The workflow can be described with the following diagram:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyODcxMA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383628710", "bodyText": "Nit: Can we set these fields to final?", "author": "efeg", "createdAt": "2020-02-25T02:37:50Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import org.eclipse.jetty.server.UserIdentity;\n+\n+import javax.security.auth.Subject;\n+import java.security.Principal;\n+\n+public class JwtUserIdentity implements UserIdentity {\n+\n+  private Subject _subject;\n+  private Principal _principal;\n+  private UserIdentity _roleDelegate;", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java\nindex 321631eb..a2db23b1 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java\n\n@@ -11,9 +11,9 @@ import java.security.Principal;\n \n public class JwtUserIdentity implements UserIdentity {\n \n-  private Subject _subject;\n-  private Principal _principal;\n-  private UserIdentity _roleDelegate;\n+  private final Subject _subject;\n+  private final Principal _principal;\n+  private final UserIdentity _roleDelegate;\n \n   JwtUserIdentity(Subject subject, Principal principal, UserIdentity roleDelegate) {\n     _subject = subject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyOTQ2OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383629469", "bodyText": "Is there an implicit assumption that subject and roleDelegate cannot be null? -- e.g. JwtUserIdentity#getSubject() is accessed w/o a null check, which may potentially yield an NPE?", "author": "efeg", "createdAt": "2020-02-25T02:40:59Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import org.eclipse.jetty.server.UserIdentity;\n+\n+import javax.security.auth.Subject;\n+import java.security.Principal;\n+\n+public class JwtUserIdentity implements UserIdentity {\n+\n+  private Subject _subject;\n+  private Principal _principal;\n+  private UserIdentity _roleDelegate;\n+\n+  JwtUserIdentity(Subject subject, Principal principal, UserIdentity roleDelegate) {\n+    _subject = subject;\n+    _principal = principal;", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyNTE5NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r385725195", "bodyText": "Good catch. In fact it could happen that in JwtLoginService.login null is returned by the\nUserIdentity rolesDelegate = _authorizationService.getUserIdentity((HttpServletRequest) request, username);\ncall. In this case we should return with an unauthenticated identity and handle that case as an unsuccessful login. Otherwise if the login was successful then the subject and roleDelegate shouldn't be null.", "author": "viktorsomogyi", "createdAt": "2020-02-28T14:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyOTQ2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java\nindex 321631eb..a2db23b1 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java\n\n@@ -11,9 +11,9 @@ import java.security.Principal;\n \n public class JwtUserIdentity implements UserIdentity {\n \n-  private Subject _subject;\n-  private Principal _principal;\n-  private UserIdentity _roleDelegate;\n+  private final Subject _subject;\n+  private final Principal _principal;\n+  private final UserIdentity _roleDelegate;\n \n   JwtUserIdentity(Subject subject, Principal principal, UserIdentity roleDelegate) {\n     _subject = subject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyOTY1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383629650", "bodyText": "Nit: Can we set these fields to final?", "author": "efeg", "createdAt": "2020-02-25T02:41:41Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserPrincipal.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import java.security.Principal;\n+\n+public class JwtUserPrincipal implements Principal {\n+\n+  private String _username;\n+  private String _serializedToken;", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserPrincipal.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserPrincipal.java\nindex 0e149db0..1c5e36e8 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserPrincipal.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserPrincipal.java\n\n@@ -8,8 +8,8 @@ import java.security.Principal;\n \n public class JwtUserPrincipal implements Principal {\n \n-  private String _username;\n-  private String _serializedToken;\n+  private final String _username;\n+  private final String _serializedToken;\n \n   JwtUserPrincipal(String username, String serializedToken) {\n     _username = username;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzMDg0MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383630841", "bodyText": "(Applies to similar uses in JwtLoginServiceTest) Nit: Can we move hardcoded String, \"USER\", to a static variable?", "author": "efeg", "createdAt": "2020-02-25T02:46:39Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticatorTest.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.security.Authenticator;\n+import org.eclipse.jetty.security.DefaultIdentityService;\n+import org.eclipse.jetty.security.ServerAuthException;\n+import org.eclipse.jetty.security.UserAuthentication;\n+import org.eclipse.jetty.security.UserStore;\n+import org.eclipse.jetty.server.Authentication;\n+import org.eclipse.jetty.server.Request;\n+import org.junit.Test;\n+\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.expectLastCall;\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.niceMock;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+public class JwtAuthenticatorTest {\n+\n+  private static final String TEST_USER = \"testUser\";\n+  private static final String JWT_TOKEN = \"jwt_token\";\n+  private static final String EXPECTED_TOKEN = \"token\";\n+  private static final String RANDOM_COOKIE_NAME = \"random_cookie_name\";\n+  private static final String TOKEN_PROVIDER = \"http://mytokenprovider.com?origin={redirectUrl}\";\n+  private static final String CRUISE_CONTROL_ENDPOINT = \"http://cruisecontrol.mycompany.com/state\";\n+\n+  @Test\n+  public void testParseTokenFromAuthHeader() {\n+    JwtAuthenticator authenticator = new JwtAuthenticator(TOKEN_PROVIDER, JWT_TOKEN);\n+    HttpServletRequest request = mock(HttpServletRequest.class);\n+    expect(request.getHeader(HttpHeader.AUTHORIZATION.asString())).andReturn(\"Bearer \" + EXPECTED_TOKEN);\n+    replay(request);\n+    String actualToken = authenticator.getJwtFromBearerAuthorization(request);\n+    verify(request);\n+    assertEquals(EXPECTED_TOKEN, actualToken);\n+  }\n+\n+  @Test\n+  public void testParseTokenFromAuthHeaderNoBearer() {\n+    JwtAuthenticator authenticator = new JwtAuthenticator(TOKEN_PROVIDER, JWT_TOKEN);\n+    HttpServletRequest request = mock(HttpServletRequest.class);\n+    expect(request.getHeader(HttpHeader.AUTHORIZATION.asString())).andReturn(\"Basic \" + EXPECTED_TOKEN);\n+    replay(request);\n+    String actualToken = authenticator.getJwtFromBearerAuthorization(request);\n+    verify(request);\n+    assertNull(actualToken);\n+  }\n+\n+  @Test\n+  public void testParseTokenFromCookie() {\n+    JwtAuthenticator authenticator = new JwtAuthenticator(TOKEN_PROVIDER, JWT_TOKEN);\n+    HttpServletRequest request = mock(HttpServletRequest.class);\n+    expect(request.getCookies()).andReturn(new Cookie[] {new Cookie(JWT_TOKEN, EXPECTED_TOKEN)});\n+    replay(request);\n+    String actualToken = authenticator.getJwtFromCookie(request);\n+    verify(request);\n+    assertEquals(EXPECTED_TOKEN, actualToken);\n+  }\n+\n+  @Test\n+  public void testParseTokenFromCookieNoJwtCookie() {\n+    JwtAuthenticator authenticator = new JwtAuthenticator(TOKEN_PROVIDER, JWT_TOKEN);\n+    HttpServletRequest request = mock(HttpServletRequest.class);\n+    expect(request.getCookies()).andReturn(new Cookie[] {new Cookie(RANDOM_COOKIE_NAME, \"\")});\n+    replay(request);\n+    String actualToken = authenticator.getJwtFromCookie(request);\n+    verify(request);\n+    assertNull(actualToken);\n+  }\n+\n+  @Test\n+  public void testRedirect() throws IOException, ServerAuthException {\n+    JwtAuthenticator authenticator = new JwtAuthenticator(TOKEN_PROVIDER, JWT_TOKEN);\n+\n+    HttpServletRequest request = mock(HttpServletRequest.class);\n+    expect(request.getMethod()).andReturn(HttpMethod.GET.asString());\n+    expect(request.getQueryString()).andReturn(null);\n+    expect(request.getHeader(HttpHeader.AUTHORIZATION.asString())).andReturn(null);\n+    expect(request.getCookies()).andReturn(new Cookie[] {});\n+    expect(request.getRequestURL()).andReturn(new StringBuffer(CRUISE_CONTROL_ENDPOINT));\n+\n+    HttpServletResponse response = mock(HttpServletResponse.class);\n+    response.sendRedirect(TOKEN_PROVIDER.replace(\"{redirectUrl}\", CRUISE_CONTROL_ENDPOINT));\n+    expectLastCall().andVoid();\n+\n+    replay(request, response);\n+    Authentication actualAuthentication = authenticator.validateRequest(request, response, true);\n+    verify(request, response);\n+    assertEquals(Authentication.SEND_CONTINUE, actualAuthentication);\n+  }\n+\n+  @Test\n+  public void testSuccessfulLogin() throws Exception {\n+    UserStore testUserStore = new UserStore();\n+    testUserStore.addUser(TEST_USER, null, new String[] {\"USER\"});", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticatorTest.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticatorTest.java\nindex 50e7b340..79cfb183 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticatorTest.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticatorTest.java\n\n@@ -34,17 +34,20 @@ import static org.junit.Assert.assertTrue;\n public class JwtAuthenticatorTest {\n \n   private static final String TEST_USER = \"testUser\";\n+  private static final String TEST_USER_2 = \"testUser2\";\n   private static final String JWT_TOKEN = \"jwt_token\";\n   private static final String EXPECTED_TOKEN = \"token\";\n   private static final String RANDOM_COOKIE_NAME = \"random_cookie_name\";\n-  private static final String TOKEN_PROVIDER = \"http://mytokenprovider.com?origin={redirectUrl}\";\n+  private static final String TOKEN_PROVIDER = \"http://mytokenprovider.com?origin=\" + JwtAuthenticator.REDIRECT_URL;\n   private static final String CRUISE_CONTROL_ENDPOINT = \"http://cruisecontrol.mycompany.com/state\";\n+  private static final String USER_ROLE = \"USER\";\n+  private static final String BASIC_SCHEME = \"Basic\";\n \n   @Test\n   public void testParseTokenFromAuthHeader() {\n     JwtAuthenticator authenticator = new JwtAuthenticator(TOKEN_PROVIDER, JWT_TOKEN);\n     HttpServletRequest request = mock(HttpServletRequest.class);\n-    expect(request.getHeader(HttpHeader.AUTHORIZATION.asString())).andReturn(\"Bearer \" + EXPECTED_TOKEN);\n+    expect(request.getHeader(HttpHeader.AUTHORIZATION.asString())).andReturn(JwtAuthenticator.BEARER + \" \" + EXPECTED_TOKEN);\n     replay(request);\n     String actualToken = authenticator.getJwtFromBearerAuthorization(request);\n     verify(request);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzMTQ4Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383631483", "bodyText": "Nit: Can we set these fields to final?", "author": "efeg", "createdAt": "2020-02-25T02:49:16Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/TokenGenerator.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JOSEObjectType;\n+import com.nimbusds.jose.JWSAlgorithm;\n+import com.nimbusds.jose.JWSHeader;\n+import com.nimbusds.jose.crypto.RSASSASigner;\n+import com.nimbusds.jose.jwk.RSAKey;\n+import com.nimbusds.jose.jwk.gen.RSAKeyGenerator;\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.jwt.SignedJWT;\n+\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.interfaces.RSAPublicKey;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+\n+class TokenGenerator {\n+\n+  static class TokenAndKeys {\n+    private String _token;\n+    private RSAPrivateKey _privateKey;\n+    private RSAPublicKey _publicKey;\n+", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "chunk": "diff --git a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/TokenGenerator.java b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/TokenGenerator.java\nindex b013be09..b883ee32 100644\n--- a/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/TokenGenerator.java\n+++ b/cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/TokenGenerator.java\n\n@@ -23,9 +23,9 @@ import java.util.List;\n class TokenGenerator {\n \n   static class TokenAndKeys {\n-    private String _token;\n-    private RSAPrivateKey _privateKey;\n-    private RSAPublicKey _publicKey;\n+    private final String _token;\n+    private final RSAPrivateKey _privateKey;\n+    private final RSAPublicKey _publicKey;\n \n     private TokenAndKeys(String token, RSAPrivateKey privateKey, RSAPublicKey publicKey) {\n       _token = token;\n"}}, {"oid": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "url": "https://github.com/linkedin/cruise-control/commit/10faa73059ef21277dcb03f193ed69d6adfb0a98", "message": "Address review comments", "committedDate": "2020-03-02T10:20:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzMTc0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r386531742", "bodyText": "Nit: Missing dot at the end.", "author": "efeg", "createdAt": "2020-03-02T17:17:35Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java", "diffHunk": "@@ -320,15 +321,35 @@ void sanityCheckSecurity() { // visible for testing\n         throw new ConfigException(String.format(\"If webserver security is enabled, a valid security provider must be set \" +\n             \"that is an implementation of %s.\", SecurityProvider.class.getName()));\n       }\n-      String basicAuthCredentialsFile = getString(WebServerConfig.WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG);\n-      if (BasicSecurityProvider.class.isAssignableFrom(securityProvider) && (basicAuthCredentialsFile == null\n-          || !Files.exists(Paths.get(basicAuthCredentialsFile)))) {\n+      String authCredentialsFile = getString(WebServerConfig.WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG);\n+      if (BasicSecurityProvider.class == securityProvider && !fileExists(authCredentialsFile)) {\n         throw new ConfigException(String.format(\"If %s is used, an existing credentials file must be set.\",\n             BasicSecurityProvider.class.getName()));\n       }\n+      if (JwtSecurityProvider.class == securityProvider) {\n+        String providerUrl = getString(WebServerConfig.JWT_AUTHENTICATION_PROVIDER_URL_CONFIG);\n+        if (providerUrl == null || providerUrl.isEmpty()) {\n+          throw new ConfigException(String.format(\"When %s is used, %s must be set\",", "originalCommit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b854f08d491445a6a37dbd5c4da27c87bd7360cb", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\nindex 3eef93c8..42260b4f 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\n\n@@ -321,35 +320,15 @@ public class KafkaCruiseControlConfig extends AbstractConfig {\n         throw new ConfigException(String.format(\"If webserver security is enabled, a valid security provider must be set \" +\n             \"that is an implementation of %s.\", SecurityProvider.class.getName()));\n       }\n-      String authCredentialsFile = getString(WebServerConfig.WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG);\n-      if (BasicSecurityProvider.class == securityProvider && !fileExists(authCredentialsFile)) {\n+      String basicAuthCredentialsFile = getString(WebServerConfig.WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG);\n+      if (BasicSecurityProvider.class.isAssignableFrom(securityProvider) && (basicAuthCredentialsFile == null\n+          || !Files.exists(Paths.get(basicAuthCredentialsFile)))) {\n         throw new ConfigException(String.format(\"If %s is used, an existing credentials file must be set.\",\n             BasicSecurityProvider.class.getName()));\n       }\n-      if (JwtSecurityProvider.class == securityProvider) {\n-        String providerUrl = getString(WebServerConfig.JWT_AUTHENTICATION_PROVIDER_URL_CONFIG);\n-        if (providerUrl == null || providerUrl.isEmpty()) {\n-          throw new ConfigException(String.format(\"When %s is used, %s must be set\",\n-              JwtSecurityProvider.class.getName(), WebServerConfig.JWT_AUTHENTICATION_PROVIDER_URL_CONFIG));\n-        }\n-        String certificateFile = getString(WebServerConfig.JWT_AUTH_CERTIFICATE_LOCATION_CONFIG);\n-        if (!fileExists(certificateFile)) {\n-          throw new ConfigException(String.format(\"If %s is used, an existing certificate file must be set.\",\n-              JwtSecurityProvider.class.getName()));\n-        }\n-        String privilegesFile = getString(WebServerConfig.WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG);\n-        if (!fileExists(privilegesFile)) {\n-          throw new ConfigException(String.format(\"If %s is used, an existing certificate file must be set.\",\n-              JwtSecurityProvider.class.getName()));\n-        }\n-      }\n     }\n   }\n \n-  private boolean fileExists(String file) {\n-    return file != null && Files.exists(Paths.get(file));\n-  }\n-\n   public KafkaCruiseControlConfig(Map<?, ?> originals) {\n     this(originals, true);\n   }\n"}}, {"oid": "b854f08d491445a6a37dbd5c4da27c87bd7360cb", "url": "https://github.com/linkedin/cruise-control/commit/b854f08d491445a6a37dbd5c4da27c87bd7360cb", "message": "JWT Authentication", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "63a4d04e106f55c9c37243c977b15e16b2e0c2f9", "url": "https://github.com/linkedin/cruise-control/commit/63a4d04e106f55c9c37243c977b15e16b2e0c2f9", "message": "Update the user guide", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "1165cbb154993b308023420a1bf4784f49868b69", "url": "https://github.com/linkedin/cruise-control/commit/1165cbb154993b308023420a1bf4784f49868b69", "message": "Emphasize demo purposes in docs", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "965fd5c752b24aee6a0bf6b39af369b7466135ad", "url": "https://github.com/linkedin/cruise-control/commit/965fd5c752b24aee6a0bf6b39af369b7466135ad", "message": "Minor doc fix", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "51961d3fc02f30cbfb10398840cd7c5f264d2626", "url": "https://github.com/linkedin/cruise-control/commit/51961d3fc02f30cbfb10398840cd7c5f264d2626", "message": "Minor fixes", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "dbc907b3222aa2dc73ccd41d118cc4d2174e3224", "url": "https://github.com/linkedin/cruise-control/commit/dbc907b3222aa2dc73ccd41d118cc4d2174e3224", "message": "Trim the token instead of Bearer", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "fe1fdc24f63399a6284e5b94cf4a2c8ef03c744b", "url": "https://github.com/linkedin/cruise-control/commit/fe1fdc24f63399a6284e5b94cf4a2c8ef03c744b", "message": "Add token revalidation capability", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "d158f9f898fdbc9a6ae2e311013fdb22363ee4a0", "url": "https://github.com/linkedin/cruise-control/commit/d158f9f898fdbc9a6ae2e311013fdb22363ee4a0", "message": "Address review comments", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "8ac11ff190be9fcac9945606b7509af5f0163a2c", "url": "https://github.com/linkedin/cruise-control/commit/8ac11ff190be9fcac9945606b7509af5f0163a2c", "message": "Add dot", "committedDate": "2020-03-03T10:35:09Z", "type": "commit"}, {"oid": "8ac11ff190be9fcac9945606b7509af5f0163a2c", "url": "https://github.com/linkedin/cruise-control/commit/8ac11ff190be9fcac9945606b7509af5f0163a2c", "message": "Add dot", "committedDate": "2020-03-03T10:35:09Z", "type": "forcePushed"}, {"oid": "819cd3b0ea4ac61c8030b83bdd607eb9219e3cd5", "url": "https://github.com/linkedin/cruise-control/commit/819cd3b0ea4ac61c8030b83bdd607eb9219e3cd5", "message": "Set status to 401 explicitly on failed authentication", "committedDate": "2020-03-03T13:08:05Z", "type": "commit"}]}