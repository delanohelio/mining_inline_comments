{"pr_number": 1308, "pr_title": "Eliminate inefficiencies in execution process.", "pr_createdAt": "2020-08-08T02:20:56Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1308", "timeline": [{"oid": "b91e7fc8f24b67b6c82e39c9ae875b48d4d202f2", "url": "https://github.com/linkedin/cruise-control/commit/b91e7fc8f24b67b6c82e39c9ae875b48d4d202f2", "message": "Eliminate inefficiencies in execution process.", "committedDate": "2020-08-08T01:45:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NzA0OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1308#discussion_r468297049", "bodyText": "Is this comment correct? I thought CC no longer deletes the znode and moves controller in order to stop the execution.", "author": "hzxa21", "createdAt": "2020-08-11T02:54:16Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -1416,6 +1416,120 @@ private int moveLeadershipInBatch() throws InterruptedException, ExecutionExcept\n       return finishedTasks;\n     }\n \n+    private void handleProgressWithTopicDeletion(ExecutionTask task, List<ExecutionTask> finishedTasks, Set<Long> deletedTaskIds) {\n+      // Handle topic deletion during the execution.\n+      LOG.debug(\"Task {} is marked as finished because the topic has been deleted.\", task);\n+      finishedTasks.add(task);\n+      deletedTaskIds.add(task.executionId());\n+      _executionTaskManager.markTaskAborting(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    private void handleProgressWithCompletion(ExecutionTask task, List<ExecutionTask> finishedTasks) {\n+      // Check to see if the task is done.\n+      finishedTasks.add(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    /**\n+     * Periodically checks the metadata to see if leadership reassignment has finished or not.\n+     */\n+    private void waitForLeadershipTasksToFinish() {\n+      List<ExecutionTask> finishedTasks = new ArrayList<>();\n+      Set<Long> stoppedTaskIds = new HashSet<>();\n+      Set<Long> deletedTaskIds = new HashSet<>();\n+      Set<Long> deadTaskIds = new HashSet<>();\n+      do {\n+        // If there is no finished tasks, we need to check if anything is blocked.\n+        maybeReexecuteLeadershipTasks();\n+        Cluster cluster = getClusterForExecutionProgressCheck();\n+\n+        List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n+        boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n+        for (ExecutionTask task : inExecutionTasks()) {\n+          TopicPartition tp = task.proposal().topicPartition();\n+          if (_stopSignal.get() == FORCE_STOP_EXECUTION) {\n+            // If the execution is force-stopped, the executor will mark all in progress tasks as dead, cleanup the\n+            // relevant reassignment zNodes, and then bounce the controller (see ExecutionUtils#deleteZNodesToStopExecution).", "originalCommit": "b91e7fc8f24b67b6c82e39c9ae875b48d4d202f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgwMjYyMg==", "url": "https://github.com/linkedin/cruise-control/pull/1308#discussion_r468802622", "bodyText": "Yes, I believe it is correct.\nLeadership reassignments in Kafka use PreferredReplicaElection znode; hence, potentially stuck leadership movements may require a force-stop. Though in practice, a stuck / time-consuming leadership movement is not common.\nNote that KIP-455 was about a new API for inter-broker replica reassignment tasks. Thus, its impact is limited to changes in starting, stopping, and listing them.\nI cleaned up the force-stop logic to ensure that it only applies to leadership movements along with a deprecation message for replica reassignments  -- i.e. with KIP-455 inter-broker replica reassignments no longer need force stop and intra-broker replica reassignments were already not using zNodes.\nOne side-effect of this change would be the loss of ability to bounce controller upon force-stopping inter/intra broker replica reassignments, which would have helped in case the controller itself is stuck for some reason. We can address that in a future PR by moving intentional controller bounce functionality to admin endpoint of cruise control.", "author": "efeg", "createdAt": "2020-08-11T19:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NzA0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "706c29fb88b3f16f64ba126d3068f6f1064ee17d", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java\nindex 58e59392..29dfc68b 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java\n\n@@ -1408,8 +1410,7 @@ public class Executor {\n       } while (retry);\n \n       LOG.info(\"Finished tasks: {}.{}{}{}\", finishedTasks,\n-               stoppedTaskIds.isEmpty() ? \"\" : String.format(\". [%sStopped: %s]\", _stopSignal.get() == FORCE_STOP_EXECUTION\n-                                                                                  ? \"Force-\" : \"\", stoppedTaskIds),\n+               stoppedTaskIds.isEmpty() ? \"\" : String.format(\". [Stopped: %s]\", stoppedTaskIds),\n                deletedTaskIds.isEmpty() ? \"\" : String.format(\". [Deleted: %s]\", deletedTaskIds),\n                deadTaskIds.isEmpty() ? \"\" : String.format(\". [Dead: %s]\", deadTaskIds));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NzIwOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1308#discussion_r468297209", "bodyText": "Is this comment correct? I thought CC no longer deletes the znode and moves controller in order to stop the execution.", "author": "hzxa21", "createdAt": "2020-08-11T02:54:54Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -1416,6 +1416,120 @@ private int moveLeadershipInBatch() throws InterruptedException, ExecutionExcept\n       return finishedTasks;\n     }\n \n+    private void handleProgressWithTopicDeletion(ExecutionTask task, List<ExecutionTask> finishedTasks, Set<Long> deletedTaskIds) {\n+      // Handle topic deletion during the execution.\n+      LOG.debug(\"Task {} is marked as finished because the topic has been deleted.\", task);\n+      finishedTasks.add(task);\n+      deletedTaskIds.add(task.executionId());\n+      _executionTaskManager.markTaskAborting(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    private void handleProgressWithCompletion(ExecutionTask task, List<ExecutionTask> finishedTasks) {\n+      // Check to see if the task is done.\n+      finishedTasks.add(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    /**\n+     * Periodically checks the metadata to see if leadership reassignment has finished or not.\n+     */\n+    private void waitForLeadershipTasksToFinish() {\n+      List<ExecutionTask> finishedTasks = new ArrayList<>();\n+      Set<Long> stoppedTaskIds = new HashSet<>();\n+      Set<Long> deletedTaskIds = new HashSet<>();\n+      Set<Long> deadTaskIds = new HashSet<>();\n+      do {\n+        // If there is no finished tasks, we need to check if anything is blocked.\n+        maybeReexecuteLeadershipTasks();\n+        Cluster cluster = getClusterForExecutionProgressCheck();\n+\n+        List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n+        boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n+        for (ExecutionTask task : inExecutionTasks()) {\n+          TopicPartition tp = task.proposal().topicPartition();\n+          if (_stopSignal.get() == FORCE_STOP_EXECUTION) {\n+            // If the execution is force-stopped, the executor will mark all in progress tasks as dead, cleanup the\n+            // relevant reassignment zNodes, and then bounce the controller (see ExecutionUtils#deleteZNodesToStopExecution).\n+            LOG.debug(\"Task {} is marked as dead to force-stop the execution with a controller bounce.\", task);\n+            finishedTasks.add(task);\n+            stoppedTaskIds.add(task.executionId());\n+            _executionTaskManager.markTaskDead(task);\n+          } else if (cluster.partition(tp) == null) {\n+            handleProgressWithTopicDeletion(task, finishedTasks, deletedTaskIds);\n+          } else if (ExecutionUtils.isLeadershipMovementDone(cluster, task)) {\n+            handleProgressWithCompletion(task, finishedTasks);\n+          } else {\n+            if (shouldReportSlowTasks) {\n+              task.maybeReportExecutionTooSlow(_time.milliseconds(), slowTasksToReport);\n+            }\n+            if (maybeMarkTaskAsDead(cluster, null, task, null)) {\n+              deadTaskIds.add(task.executionId());\n+              finishedTasks.add(task);\n+            }\n+          }\n+        }\n+        sendSlowExecutionAlert(slowTasksToReport);\n+        updateOngoingExecutionState();\n+      } while (!inExecutionTasks().isEmpty() && finishedTasks.isEmpty());\n+\n+      LOG.info(\"Finished tasks: {}.{}{}{}\", finishedTasks,\n+               stoppedTaskIds.isEmpty() ? \"\" : String.format(\". [Force-Stopped: %s]\", stoppedTaskIds),\n+               deletedTaskIds.isEmpty() ? \"\" : String.format(\". [Deleted: %s]\", deletedTaskIds),\n+               deadTaskIds.isEmpty() ? \"\" : String.format(\". [Dead: %s]\", deadTaskIds));\n+    }\n+\n+    /**\n+     * Periodically checks the metadata to see if intra-broker replica reassignment has finished or not.\n+     */\n+    private void waitForIntraBrokerReplicaTasksToFinish() {\n+      List<ExecutionTask> finishedTasks = new ArrayList<>();\n+      Set<Long> stoppedTaskIds = new HashSet<>();\n+      Set<Long> deletedTaskIds = new HashSet<>();\n+      Set<Long> deadTaskIds = new HashSet<>();\n+      do {\n+        // If there is no finished tasks, we need to check if anything is blocked.\n+        maybeReexecuteIntraBrokerReplicaTasks();\n+        Cluster cluster = getClusterForExecutionProgressCheck();\n+        Map<ExecutionTask, ReplicaLogDirInfo> logDirInfoByTask = getLogdirInfoForExecutionTask(\n+            _executionTaskManager.inExecutionTasks(Collections.singleton(INTRA_BROKER_REPLICA_ACTION)),\n+            _adminClient, _config);\n+\n+        List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n+        boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n+        for (ExecutionTask task : inExecutionTasks()) {\n+          TopicPartition tp = task.proposal().topicPartition();\n+          if (_stopSignal.get() == FORCE_STOP_EXECUTION) {\n+            // If the execution is force-stopped, the executor will mark all in progress tasks as dead, cleanup the\n+            // relevant reassignment zNodes, and then bounce the controller (see ExecutionUtils#deleteZNodesToStopExecution).", "originalCommit": "b91e7fc8f24b67b6c82e39c9ae875b48d4d202f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgwMjYxMw==", "url": "https://github.com/linkedin/cruise-control/pull/1308#discussion_r468802613", "bodyText": "Please see the response to the other comment above.", "author": "efeg", "createdAt": "2020-08-11T19:05:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NzIwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "706c29fb88b3f16f64ba126d3068f6f1064ee17d", "chunk": "diff --git a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java\nindex 58e59392..29dfc68b 100644\n--- a/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java\n+++ b/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java\n\n@@ -1408,8 +1410,7 @@ public class Executor {\n       } while (retry);\n \n       LOG.info(\"Finished tasks: {}.{}{}{}\", finishedTasks,\n-               stoppedTaskIds.isEmpty() ? \"\" : String.format(\". [%sStopped: %s]\", _stopSignal.get() == FORCE_STOP_EXECUTION\n-                                                                                  ? \"Force-\" : \"\", stoppedTaskIds),\n+               stoppedTaskIds.isEmpty() ? \"\" : String.format(\". [Stopped: %s]\", stoppedTaskIds),\n                deletedTaskIds.isEmpty() ? \"\" : String.format(\". [Deleted: %s]\", deletedTaskIds),\n                deadTaskIds.isEmpty() ? \"\" : String.format(\". [Dead: %s]\", deadTaskIds));\n \n"}}, {"oid": "706c29fb88b3f16f64ba126d3068f6f1064ee17d", "url": "https://github.com/linkedin/cruise-control/commit/706c29fb88b3f16f64ba126d3068f6f1064ee17d", "message": "Address the feedback.", "committedDate": "2020-08-11T18:53:38Z", "type": "commit"}]}