{"pr_number": 1337, "pr_title": "Reactive gateways.", "pr_createdAt": "2020-02-05T08:28:49Z", "pr_url": "https://github.com/AxonFramework/AxonFramework/pull/1337", "timeline": [{"oid": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "url": "https://github.com/AxonFramework/AxonFramework/commit/e9529d16f2579e3bfd06692287b9b5bd704836ee", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-20T14:15:25Z", "type": "commit"}, {"oid": "1b1ea09fbd5c85fd9a6459d1b495185afef407c4", "url": "https://github.com/AxonFramework/AxonFramework/commit/1b1ea09fbd5c85fd9a6459d1b495185afef407c4", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-20T14:20:48Z", "type": "commit"}, {"oid": "8ff710175ca33182f5a5bad48c32834a3f21f422", "url": "https://github.com/AxonFramework/AxonFramework/commit/8ff710175ca33182f5a5bad48c32834a3f21f422", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-20T14:26:45Z", "type": "commit"}, {"oid": "ab0a931650e7642efc146e4088d9373aebc30c94", "url": "https://github.com/AxonFramework/AxonFramework/commit/ab0a931650e7642efc146e4088d9373aebc30c94", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-20T14:33:31Z", "type": "commit"}, {"oid": "3d7566d67f94507f1b1f65d87414b456509b331b", "url": "https://github.com/AxonFramework/AxonFramework/commit/3d7566d67f94507f1b1f65d87414b456509b331b", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-20T14:34:45Z", "type": "commit"}, {"oid": "dd624ab3d84bb0d317f7af75b9d19505fd302bfe", "url": "https://github.com/AxonFramework/AxonFramework/commit/dd624ab3d84bb0d317f7af75b9d19505fd302bfe", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-20T14:35:30Z", "type": "commit"}, {"oid": "a0ad8eb226c2f912a67415c91577814ac5907d16", "url": "https://github.com/AxonFramework/AxonFramework/commit/a0ad8eb226c2f912a67415c91577814ac5907d16", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-20T14:36:29Z", "type": "commit"}, {"oid": "a405b511d9d26bacc42f8d2c437a834b4f0fd5c4", "url": "https://github.com/AxonFramework/AxonFramework/commit/a405b511d9d26bacc42f8d2c437a834b4f0fd5c4", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-20T15:07:33Z", "type": "commit"}, {"oid": "1a306018939b35904b579aeaa3b541a3c09e456d", "url": "https://github.com/AxonFramework/AxonFramework/commit/1a306018939b35904b579aeaa3b541a3c09e456d", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n\nCo-authored-by: Stefan An\u0111elkovi\u0107 <6233783+sandjelkovic@users.noreply.github.com>", "committedDate": "2020-07-20T15:13:51Z", "type": "commit"}, {"oid": "5af6d40e0e6c54f5e8a7554c3f6956c4088219a4", "url": "https://github.com/AxonFramework/AxonFramework/commit/5af6d40e0e6c54f5e8a7554c3f6956c4088219a4", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Stefan An\u0111elkovi\u0107 <6233783+sandjelkovic@users.noreply.github.com>", "committedDate": "2020-07-20T15:14:09Z", "type": "commit"}, {"oid": "b1184583fc50ca0b0ae81bdefc41b0a3772aa8f4", "url": "https://github.com/AxonFramework/AxonFramework/commit/b1184583fc50ca0b0ae81bdefc41b0a3772aa8f4", "message": "Processed review remarks.", "committedDate": "2020-07-20T15:32:38Z", "type": "commit"}, {"oid": "0ad8abeb10df75f098d632f917dcb6715588e8aa", "url": "https://github.com/AxonFramework/AxonFramework/commit/0ad8abeb10df75f098d632f917dcb6715588e8aa", "message": "Merge branch 'master' into reactive-gateways", "committedDate": "2020-07-20T15:33:15Z", "type": "commit"}, {"oid": "65a12c975a900e96412a6b2f2c5fa222cbcb07a1", "url": "https://github.com/AxonFramework/AxonFramework/commit/65a12c975a900e96412a6b2f2c5fa222cbcb07a1", "message": "Use Function.identity instead of creating new mono.", "committedDate": "2020-07-21T09:39:19Z", "type": "commit"}, {"oid": "bc60a808690d5b1eb3d6d80581ed59892813643d", "url": "https://github.com/AxonFramework/AxonFramework/commit/bc60a808690d5b1eb3d6d80581ed59892813643d", "message": "Merge branch 'master' into reactive-gateways", "committedDate": "2020-07-27T09:57:05Z", "type": "commit"}, {"oid": "9d2da7ff7507791063c95d39681098c708145c94", "url": "https://github.com/AxonFramework/AxonFramework/commit/9d2da7ff7507791063c95d39681098c708145c94", "message": "Adjusted indentation and JavaDoc.", "committedDate": "2020-07-27T11:14:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4MjI0OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461382249", "bodyText": "Shouldn't these two be private final?", "author": "smcvb", "createdAt": "2020-07-28T07:42:48Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the\n+ * Project Reactor mechanisms. This callback allows the caller to synchronize calls when an asynchronous command bus is\n+ * being used.\n+ *\n+ * @author Stefan Dragisic\n+ * @since 4.4\n+ *\n+ * @see CommandCallback\n+ * @see org.axonframework.commandhandling.CommandBus\n+ */\n+\n+public class ReactorCallback<C, R> extends Mono<CommandResultMessage<? extends R>> implements CommandCallback<C, R> {\n+\n+    EmitterProcessor<CommandResultMessage<? extends R>> commandResultMessageEmitter = EmitterProcessor.create(1);", "originalCommit": "9d2da7ff7507791063c95d39681098c708145c94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d36c4a3a85516d49314330e0f894bb3b3ea39aa", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java b/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java\nindex 1633ee88d..46e1f487f 100644\n--- a/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java\n+++ b/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java\n\n@@ -35,11 +35,10 @@\n  * @see CommandCallback\n  * @see org.axonframework.commandhandling.CommandBus\n  */\n-\n public class ReactorCallback<C, R> extends Mono<CommandResultMessage<? extends R>> implements CommandCallback<C, R> {\n \n-    EmitterProcessor<CommandResultMessage<? extends R>> commandResultMessageEmitter = EmitterProcessor.create(1);\n-    FluxSink<CommandResultMessage<? extends R>> sink = commandResultMessageEmitter.sink();\n+    private final EmitterProcessor<CommandResultMessage<? extends R>> commandResultMessageEmitter = EmitterProcessor.create(1);\n+    private final FluxSink<CommandResultMessage<? extends R>> sink = commandResultMessageEmitter.sink();\n \n     @Override\n     public void onResult(CommandMessage<? extends C> commandMessage,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4MjM1NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461382354", "bodyText": "Unintended empty line here.", "author": "smcvb", "createdAt": "2020-07-28T07:43:01Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the\n+ * Project Reactor mechanisms. This callback allows the caller to synchronize calls when an asynchronous command bus is\n+ * being used.\n+ *\n+ * @author Stefan Dragisic\n+ * @since 4.4\n+ *\n+ * @see CommandCallback\n+ * @see org.axonframework.commandhandling.CommandBus\n+ */\n+", "originalCommit": "9d2da7ff7507791063c95d39681098c708145c94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d36c4a3a85516d49314330e0f894bb3b3ea39aa", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java b/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java\nindex 1633ee88d..46e1f487f 100644\n--- a/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java\n+++ b/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java\n\n@@ -35,11 +35,10 @@\n  * @see CommandCallback\n  * @see org.axonframework.commandhandling.CommandBus\n  */\n-\n public class ReactorCallback<C, R> extends Mono<CommandResultMessage<? extends R>> implements CommandCallback<C, R> {\n \n-    EmitterProcessor<CommandResultMessage<? extends R>> commandResultMessageEmitter = EmitterProcessor.create(1);\n-    FluxSink<CommandResultMessage<? extends R>> sink = commandResultMessageEmitter.sink();\n+    private final EmitterProcessor<CommandResultMessage<? extends R>> commandResultMessageEmitter = EmitterProcessor.create(1);\n+    private final FluxSink<CommandResultMessage<? extends R>> sink = commandResultMessageEmitter.sink();\n \n     @Override\n     public void onResult(CommandMessage<? extends C> commandMessage,\n"}}, {"oid": "7d36c4a3a85516d49314330e0f894bb3b3ea39aa", "url": "https://github.com/AxonFramework/AxonFramework/commit/7d36c4a3a85516d49314330e0f894bb3b3ea39aa", "message": "Cleaning the code.", "committedDate": "2020-07-28T13:18:17Z", "type": "commit"}, {"oid": "30ba00c255b5a867f13c792cd330dde0bb30cc9d", "url": "https://github.com/AxonFramework/AxonFramework/commit/30ba00c255b5a867f13c792cd330dde0bb30cc9d", "message": "Removed Reactor Gateways in favor of moving them to the reactor extension.", "committedDate": "2020-07-29T08:30:22Z", "type": "commit"}, {"oid": "e1a8cd318493dbd00e6f43bed14e57fe130f765d", "url": "https://github.com/AxonFramework/AxonFramework/commit/e1a8cd318493dbd00e6f43bed14e57fe130f765d", "message": "Merge branch 'master' into reactive-gateways", "committedDate": "2020-07-29T08:31:08Z", "type": "commit"}, {"oid": "5123436deb1d76db21ab0d14d251e7c0de6001ed", "url": "https://github.com/AxonFramework/AxonFramework/commit/5123436deb1d76db21ab0d14d251e7c0de6001ed", "message": "Removed unnecessary dependency.", "committedDate": "2020-07-29T08:47:07Z", "type": "commit"}, {"oid": "4aca9b0d41cac83c1df6992d5e9dd337ec52010b", "url": "https://github.com/AxonFramework/AxonFramework/commit/4aca9b0d41cac83c1df6992d5e9dd337ec52010b", "message": "Reactive gateways.", "committedDate": "2020-02-05T08:19:42Z", "type": "commit"}, {"oid": "d6548cde5c65c7e904684da54b903b93110f095f", "url": "https://github.com/AxonFramework/AxonFramework/commit/d6548cde5c65c7e904684da54b903b93110f095f", "message": "Removed unused logger in DefaultReactiveCommandGateway.", "committedDate": "2020-02-05T08:29:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyNzkwMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375327902", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "author": "corradom", "createdAt": "2020-02-05T15:32:01Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "originalCommit": "d6548cde5c65c7e904684da54b903b93110f095f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex b3562baaa..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,280 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                      Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                                      Class<I> initialResponseType,\n-                                                                      Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, ResponseType<I> initialResponseType,\n-                                                                      ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                                      ResponseType<I> initialResponseType,\n-                                                                      ResponseType<U> updateResponseType,\n-                                                                      SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                              ResponseType<I> initialResponseType,\n-                                                              ResponseType<U> updateResponseType,\n-                                                              SubscriptionQueryBackpressure backpressure,\n-                                                              int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyODM5OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375328399", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "author": "corradom", "createdAt": "2020-02-05T15:32:48Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "originalCommit": "d6548cde5c65c7e904684da54b903b93110f095f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex b3562baaa..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,280 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                      Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                                      Class<I> initialResponseType,\n-                                                                      Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, ResponseType<I> initialResponseType,\n-                                                                      ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                                      ResponseType<I> initialResponseType,\n-                                                                      ResponseType<U> updateResponseType,\n-                                                                      SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                              ResponseType<I> initialResponseType,\n-                                                              ResponseType<U> updateResponseType,\n-                                                              SubscriptionQueryBackpressure backpressure,\n-                                                              int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyOTEzNw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375329137", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "author": "corradom", "createdAt": "2020-02-05T15:33:59Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n+                                                                      Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "originalCommit": "d6548cde5c65c7e904684da54b903b93110f095f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex b3562baaa..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,280 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                      Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                                      Class<I> initialResponseType,\n-                                                                      Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, ResponseType<I> initialResponseType,\n-                                                                      ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                                      ResponseType<I> initialResponseType,\n-                                                                      ResponseType<U> updateResponseType,\n-                                                                      SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                              ResponseType<I> initialResponseType,\n-                                                              ResponseType<U> updateResponseType,\n-                                                              SubscriptionQueryBackpressure backpressure,\n-                                                              int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyOTI1Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375329252", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "author": "corradom", "createdAt": "2020-02-05T15:34:08Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n+                                                                      Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, ResponseType<I> initialResponseType,\n+                                                                      ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "originalCommit": "d6548cde5c65c7e904684da54b903b93110f095f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex b3562baaa..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,280 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                      Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                                      Class<I> initialResponseType,\n-                                                                      Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, ResponseType<I> initialResponseType,\n-                                                                      ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                                      ResponseType<I> initialResponseType,\n-                                                                      ResponseType<U> updateResponseType,\n-                                                                      SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                              ResponseType<I> initialResponseType,\n-                                                              ResponseType<U> updateResponseType,\n-                                                              SubscriptionQueryBackpressure backpressure,\n-                                                              int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyOTM3NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375329375", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "author": "corradom", "createdAt": "2020-02-05T15:34:21Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n+                                                                      Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, ResponseType<I> initialResponseType,\n+                                                                      ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n+                                                                      ResponseType<I> initialResponseType,\n+                                                                      ResponseType<U> updateResponseType,\n+                                                                      SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "originalCommit": "d6548cde5c65c7e904684da54b903b93110f095f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex b3562baaa..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,280 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                      Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                                      Class<I> initialResponseType,\n-                                                                      Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, ResponseType<I> initialResponseType,\n-                                                                      ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                                      ResponseType<I> initialResponseType,\n-                                                                      ResponseType<U> updateResponseType,\n-                                                                      SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n-                                                              ResponseType<I> initialResponseType,\n-                                                              ResponseType<U> updateResponseType,\n-                                                              SubscriptionQueryBackpressure backpressure,\n-                                                              int updateBufferSize);\n-}\n"}}, {"oid": "18b22249c9b7b982a95a7cd19c2394c866ca6173", "url": "https://github.com/AxonFramework/AxonFramework/commit/18b22249c9b7b982a95a7cd19c2394c866ca6173", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Corrado Musumeci <corradom@gmail.com>", "committedDate": "2020-02-05T16:26:00Z", "type": "commit"}, {"oid": "15b576656e62e5987075d3fc6a92aa0b3021199c", "url": "https://github.com/AxonFramework/AxonFramework/commit/15b576656e62e5987075d3fc6a92aa0b3021199c", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Corrado Musumeci <corradom@gmail.com>", "committedDate": "2020-02-05T16:26:14Z", "type": "commit"}, {"oid": "06d836a29c60eba807b0f9fdfb09fcba947f167a", "url": "https://github.com/AxonFramework/AxonFramework/commit/06d836a29c60eba807b0f9fdfb09fcba947f167a", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Corrado Musumeci <corradom@gmail.com>", "committedDate": "2020-02-05T16:26:27Z", "type": "commit"}, {"oid": "f160ccee6bc9c135ba1deb8c550ebbc19b98c0fc", "url": "https://github.com/AxonFramework/AxonFramework/commit/f160ccee6bc9c135ba1deb8c550ebbc19b98c0fc", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Corrado Musumeci <corradom@gmail.com>", "committedDate": "2020-02-05T16:26:37Z", "type": "commit"}, {"oid": "2a580c5b7ec6bb2cf8ba5eb17b32a52b3c3fb67f", "url": "https://github.com/AxonFramework/AxonFramework/commit/2a580c5b7ec6bb2cf8ba5eb17b32a52b3c3fb67f", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Corrado Musumeci <corradom@gmail.com>", "committedDate": "2020-02-05T16:26:49Z", "type": "commit"}, {"oid": "e168420e5f05562c09216b8b56e2d370415f9bc4", "url": "https://github.com/AxonFramework/AxonFramework/commit/e168420e5f05562c09216b8b56e2d370415f9bc4", "message": "Merge branch 'master' into reactive-gateways", "committedDate": "2020-02-18T12:47:39Z", "type": "commit"}, {"oid": "513e6bcd2db50b4252b12fb83870fd1d76d175ea", "url": "https://github.com/AxonFramework/AxonFramework/commit/513e6bcd2db50b4252b12fb83870fd1d76d175ea", "message": "Merge branch 'master' into reactive-gateways", "committedDate": "2020-02-19T09:42:45Z", "type": "commit"}, {"oid": "3b2e0cf173d4ecf02c70abee2d3e85955624eb03", "url": "https://github.com/AxonFramework/AxonFramework/commit/3b2e0cf173d4ecf02c70abee2d3e85955624eb03", "message": "Added ReactiveMessageDispatchInterceptor to the ReactiveCommandGateway.", "committedDate": "2020-02-25T10:22:52Z", "type": "commit"}, {"oid": "dc34c277cfacbc1364d67c5ed5b26105833b2169", "url": "https://github.com/AxonFramework/AxonFramework/commit/dc34c277cfacbc1364d67c5ed5b26105833b2169", "message": "Added ReactiveMessageDispatchInterceptor to the ReactiveQueryGateway.", "committedDate": "2020-02-26T15:01:44Z", "type": "commit"}, {"oid": "dd4db9d5244fd7c0614ed21b0aa4a7fd9ec97000", "url": "https://github.com/AxonFramework/AxonFramework/commit/dd4db9d5244fd7c0614ed21b0aa4a7fd9ec97000", "message": "Added builders to ReactiveCommandGateway and ReactiveQueryGateway.", "committedDate": "2020-02-26T15:55:00Z", "type": "commit"}, {"oid": "3253ff7e66e6230d258f3b680193b689d66774a0", "url": "https://github.com/AxonFramework/AxonFramework/commit/3253ff7e66e6230d258f3b680193b689d66774a0", "message": "Added RetryScheduler to ReactiveCommandGateway.", "committedDate": "2020-02-26T16:18:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1MDcyOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r385050728", "bodyText": "Is there a use case where a retryScheduler is needed and Mono's out of the box retry mechanism isn't enough? If so, documentation for each use case would be great.", "author": "sandjelkovic", "createdAt": "2020-02-27T10:50:32Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactiveCommandGateway implements ReactiveCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactiveMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactiveCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactiveCommandGateway} instance\n+     */\n+    protected DefaultReactiveCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactiveCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirements</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactiveCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Mono<Object> command) {\n+        return processInterceptors(command.map(GenericCommandMessage::asCommandMessage))\n+                .flatMap(commandMessage -> Mono.create(\n+                        sink -> {\n+                            CommandCallback<Object, R> commandCallback = (cm, result) -> {\n+                                try {\n+                                    if (result.isExceptional()) {\n+                                        sink.error(result.exceptionResult());\n+                                    } else {\n+                                        sink.success(result.getPayload());\n+                                    }\n+                                } catch (Exception e) {\n+                                    sink.error(e);\n+                                }\n+                            };\n+                            if (retryScheduler != null) {\n+                                commandCallback = new RetryingCallback<>(commandCallback, retryScheduler, commandBus);", "originalCommit": "3253ff7e66e6230d258f3b680193b689d66774a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE0MDg5OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r385140899", "bodyText": "Mono retry mechanism is great. Retry scheduler, in this case, is an optimization (we might discuss whether is necessary) to retry only command sending and not the whole loop with interceptors. Also, you might wanna reconsider Mono's retry since you'd retry interceptors which purpose might be to return Mono.error which indicates command dispatching should be cancelled.", "author": "m1l4n54v1c", "createdAt": "2020-02-27T13:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1MDcyOA=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java\ndeleted file mode 100644\nindex 2c7964cb3..000000000\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java\n+++ /dev/null\n\n@@ -1,207 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.commandhandling.gateway;\n-\n-import org.axonframework.commandhandling.CommandBus;\n-import org.axonframework.commandhandling.CommandCallback;\n-import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.commandhandling.GenericCommandMessage;\n-import org.axonframework.common.AxonConfigurationException;\n-import org.axonframework.common.Registration;\n-import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.List;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n-import static java.util.Arrays.asList;\n-import static org.axonframework.common.BuilderUtils.assertNonNull;\n-\n-/**\n- * Default implementation of {@link ReactiveCommandGateway}.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public class DefaultReactiveCommandGateway implements ReactiveCommandGateway {\n-\n-    private final CommandBus commandBus;\n-    private final RetryScheduler retryScheduler;\n-    private final List<ReactiveMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n-\n-    /**\n-     * Creates an instance of {@link DefaultReactiveCommandGateway} based on the fields contained in the {@link\n-     * Builder}.\n-     * <p>\n-     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n-     * it is.\n-     * </p>\n-     *\n-     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactiveCommandGateway} instance\n-     */\n-    protected DefaultReactiveCommandGateway(Builder builder) {\n-        builder.validate();\n-        this.commandBus = builder.commandBus;\n-        this.retryScheduler = builder.retryScheduler;\n-        this.dispatchInterceptors = builder.dispatchInterceptors;\n-    }\n-\n-    /**\n-     * Instantiate a Builder to be able to create a {@link DefaultReactiveCommandGateway}.\n-     * <p>\n-     * The {@code dispatchInterceptors} are defaulted to an empty list.\n-     * The {@link CommandBus} is a <b>hard requirements</b> and as such should be provided.\n-     * </p>\n-     *\n-     * @return a Builder to be able to create a {@link DefaultReactiveCommandGateway}\n-     */\n-    public static Builder builder() {\n-        return new Builder();\n-    }\n-\n-    @Override\n-    public <R> Mono<R> send(Mono<Object> command) {\n-        return processInterceptors(command.map(GenericCommandMessage::asCommandMessage))\n-                .flatMap(commandMessage -> Mono.create(\n-                        sink -> {\n-                            CommandCallback<Object, R> commandCallback = (cm, result) -> {\n-                                try {\n-                                    if (result.isExceptional()) {\n-                                        sink.error(result.exceptionResult());\n-                                    } else {\n-                                        sink.success(result.getPayload());\n-                                    }\n-                                } catch (Exception e) {\n-                                    sink.error(e);\n-                                }\n-                            };\n-                            if (retryScheduler != null) {\n-                                commandCallback = new RetryingCallback<>(commandCallback, retryScheduler, commandBus);\n-                            }\n-                            commandBus.dispatch(commandMessage, commandCallback);\n-                        }));\n-    }\n-\n-    /**\n-     * Registers a {@link ReactiveMessageDispatchInterceptor} within this reactive gateway.\n-     *\n-     * @param interceptor intercepts a command message\n-     * @return a registration which can be used to unregister this {@code interceptor}\n-     */\n-    public Registration registerCommandDispatchInterceptor(\n-            ReactiveMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n-        dispatchInterceptors.add(interceptor);\n-        return () -> dispatchInterceptors.remove(interceptor);\n-    }\n-\n-    private Mono<CommandMessage<?>> processInterceptors(Mono<CommandMessage<?>> commandMessage) {\n-        Mono<CommandMessage<?>> message = commandMessage;\n-        for (ReactiveMessageDispatchInterceptor<CommandMessage<?>> dispatchInterceptor : dispatchInterceptors) {\n-            try {\n-                message = dispatchInterceptor.intercept(message);\n-            } catch (Throwable t) {\n-                return Mono.error(t);\n-            }\n-        }\n-        return message;\n-    }\n-\n-    /**\n-     * Builder class to instantiate {@link DefaultReactiveCommandGateway}.\n-     * <p>\n-     * The {@code dispatchInterceptors} are defaulted to an empty list.\n-     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n-     * </p>\n-     */\n-    public static class Builder {\n-\n-        private CommandBus commandBus;\n-        private RetryScheduler retryScheduler;\n-        private List<ReactiveMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors = new CopyOnWriteArrayList<>();\n-\n-        /**\n-         * Sets the {@link CommandBus} used to dispatch commands.\n-         *\n-         * @param commandBus a {@link CommandBus} used to dispatch commands\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder commandBus(CommandBus commandBus) {\n-            assertNonNull(commandBus, \"CommandBus may not be null\");\n-            this.commandBus = commandBus;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the {@link RetryScheduler} capable of performing retries of failed commands. May be {@code null} when\n-         * to prevent retries.\n-         *\n-         * @param retryScheduler a {@link RetryScheduler} capable of performing retries of failed commands\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder retryScheduler(RetryScheduler retryScheduler) {\n-            this.retryScheduler = retryScheduler;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the {@link List} of {@link ReactiveMessageDispatchInterceptor}s for {@link CommandMessage}s. Are invoked\n-         * when a command is being dispatched.\n-         *\n-         * @param dispatchInterceptors which are invoked when a command is being dispatched\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        @SafeVarargs\n-        public final Builder dispatchInterceptors(\n-                ReactiveMessageDispatchInterceptor<CommandMessage<?>>... dispatchInterceptors) {\n-            return dispatchInterceptors(asList(dispatchInterceptors));\n-        }\n-\n-        /**\n-         * Sets the {@link List} of {@link ReactiveMessageDispatchInterceptor}s for {@link CommandMessage}s. Are invoked\n-         * when a command is being dispatched.\n-         *\n-         * @param dispatchInterceptors which are invoked when a command is being dispatched\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder dispatchInterceptors(\n-                List<ReactiveMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors) {\n-            this.dispatchInterceptors = dispatchInterceptors != null && dispatchInterceptors.isEmpty()\n-                    ? new CopyOnWriteArrayList<>(dispatchInterceptors)\n-                    : new CopyOnWriteArrayList<>();\n-            return this;\n-        }\n-\n-        /**\n-         * Validate whether the fields contained in this Builder as set accordingly.\n-         *\n-         * @throws AxonConfigurationException if one field is asserted to be incorrect according to the Builder's\n-         *                                    specifications\n-         */\n-        protected void validate() {\n-            assertNonNull(commandBus, \"The CommandBus is a hard requirement and should be provided\");\n-        }\n-\n-        /**\n-         * Initializes a {@link DefaultReactiveCommandGateway} as specified through this Builder.\n-         *\n-         * @return a {@link DefaultReactiveCommandGateway} as specified through this Builder\n-         */\n-        public DefaultReactiveCommandGateway build() {\n-            return new DefaultReactiveCommandGateway(this);\n-        }\n-    }\n-}\n"}}, {"oid": "b99c7becfa3aa1db87fe222b2e6403a61df059aa", "url": "https://github.com/AxonFramework/AxonFramework/commit/b99c7becfa3aa1db87fe222b2e6403a61df059aa", "message": "Handling null query results.", "committedDate": "2020-02-27T14:07:20Z", "type": "commit"}, {"oid": "261c2a4e0bab1400d4318aa6586474e063e270a0", "url": "https://github.com/AxonFramework/AxonFramework/commit/261c2a4e0bab1400d4318aa6586474e063e270a0", "message": "Handle the case when scatter gather query throws an exception.", "committedDate": "2020-02-27T15:05:15Z", "type": "commit"}, {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51", "url": "https://github.com/AxonFramework/AxonFramework/commit/c4511e81820de8d15c641e1c3038f4b688e29b51", "message": "Merge branch 'master' into reactive-gateways", "committedDate": "2020-02-27T15:09:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQzNzQ2Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396437462", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The given {@code command} is wrapped as the payload of the CommandMessage that is eventually posted on the\n          \n          \n            \n                 * Command Bus, unless Command already implements {@link Message}. In that case, a\n          \n          \n            \n                 * CommandMessage is constructed from that message's payload and MetaData.\n          \n          \n            \n                 * The given {@code command} is wrapped as the payload of a {@link CommandMessage} that is eventually posted on the\n          \n          \n            \n                 * {@link CommandBus}, unless the {@code command} already implements {@link Message}. In that case, a\n          \n          \n            \n                 * {@code CommandMessage} is constructed from that message's payload and {@link MetaData}.", "author": "smcvb", "createdAt": "2020-03-23T13:10:03Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.messaging.Message;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveCommandGateway {\n+\n+    /**\n+     * Sends the given {@code command} once the caller subscribes to the command result. Returns immediately.\n+     * <p/>\n+     * The given {@code command} is wrapped as the payload of the CommandMessage that is eventually posted on the\n+     * Command Bus, unless Command already implements {@link Message}. In that case, a\n+     * CommandMessage is constructed from that message's payload and MetaData.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java\ndeleted file mode 100644\nindex c3d667c54..000000000\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java\n+++ /dev/null\n\n@@ -1,55 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.commandhandling.gateway;\n-\n-import org.axonframework.messaging.Message;\n-import reactor.core.publisher.Mono;\n-\n-/**\n- * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n- * Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveCommandGateway {\n-\n-    /**\n-     * Sends the given {@code command} once the caller subscribes to the command result. Returns immediately.\n-     * <p/>\n-     * The given {@code command} is wrapped as the payload of the CommandMessage that is eventually posted on the\n-     * Command Bus, unless Command already implements {@link Message}. In that case, a\n-     * CommandMessage is constructed from that message's payload and MetaData.\n-     *\n-     * @param command the command to dispatch\n-     * @param <R>     the type of the command result\n-     * @return a {@link Mono} which is resolved when the command is executed\n-     */\n-    default <R> Mono<R> send(Object command) {\n-        return send(Mono.just(command));\n-    }\n-\n-    /**\n-     * Sends the given {@code command} once the caller subscribes to the command result. Returns immediately.\n-     *\n-     * @param command a {@link Mono} which is resolved once the caller subscribes to the command result\n-     * @param <R>     the type of the command result\n-     * @return a {@link Mono} which is resolved when the command is executed\n-     * @see #send(Object)\n-     */\n-    <R> Mono<R> send(Mono<Object> command);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQzOTk0Ng==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396439946", "bodyText": "Wouldn't hurt to add @FunctionalInterface here I think. Or, would that auto-magically be populated from the Supplier interface this interface extends?", "author": "smcvb", "createdAt": "2020-03-23T13:13:56Z", "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\nsimilarity index 53%\nrename from messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java\nrename to messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\nindex 02f679f27..52dedc7c3 100644\n--- a/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java\n+++ b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\n\n@@ -14,31 +14,39 @@\n  * limitations under the License.\n  */\n \n-package org.axonframework.messaging;\n+package org.axonframework.messaging.reactive;\n \n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n import reactor.core.publisher.Mono;\n \n-import java.util.function.Function;\n-import java.util.function.Supplier;\n+import java.util.List;\n+import java.util.function.BiFunction;\n \n /**\n  * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n- * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n- * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n+ * be passed down the interceptor chain or to be dispatched.\n  *\n- * @param <T> the message type this interceptor can process\n+ * @param <M> the message type this interceptor can process\n  * @author Milan Savic\n  * @since 4.4\n  */\n-public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+@FunctionalInterface\n+public interface ReactorMessageDispatchInterceptor<M extends Message<?>> extends\n+        MessageDispatchInterceptor<M> {\n \n     /**\n-     * Intercepts a message.\n+     * Intercepts a message. It's possible to break the interceptor chain by returning {@link Mono#empty()} or {@link\n+     * Mono#error(Throwable)} variations.\n      *\n      * @param message a {@link Mono} of a message to be intercepted\n      * @return the message {@link Mono} to dispatch\n      */\n-    default Mono<T> intercept(Mono<T> message) {\n-        return get().apply(message);\n+    Mono<M> intercept(Mono<M> message);\n+\n+    @Override\n+    default BiFunction<Integer, M, M> handle(List<? extends M> messages) {\n+        return (position, message) -> intercept(Mono.just(message)).block();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0MDQzMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396440431", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n          \n          \n            \n             * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n          \n          \n            \n             * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n          \n          \n            \n             * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting messages.", "author": "smcvb", "createdAt": "2020-03-23T13:14:45Z", "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\nsimilarity index 53%\nrename from messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java\nrename to messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\nindex 02f679f27..52dedc7c3 100644\n--- a/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java\n+++ b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\n\n@@ -14,31 +14,39 @@\n  * limitations under the License.\n  */\n \n-package org.axonframework.messaging;\n+package org.axonframework.messaging.reactive;\n \n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n import reactor.core.publisher.Mono;\n \n-import java.util.function.Function;\n-import java.util.function.Supplier;\n+import java.util.List;\n+import java.util.function.BiFunction;\n \n /**\n  * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n- * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n- * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n+ * be passed down the interceptor chain or to be dispatched.\n  *\n- * @param <T> the message type this interceptor can process\n+ * @param <M> the message type this interceptor can process\n  * @author Milan Savic\n  * @since 4.4\n  */\n-public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+@FunctionalInterface\n+public interface ReactorMessageDispatchInterceptor<M extends Message<?>> extends\n+        MessageDispatchInterceptor<M> {\n \n     /**\n-     * Intercepts a message.\n+     * Intercepts a message. It's possible to break the interceptor chain by returning {@link Mono#empty()} or {@link\n+     * Mono#error(Throwable)} variations.\n      *\n      * @param message a {@link Mono} of a message to be intercepted\n      * @return the message {@link Mono} to dispatch\n      */\n-    default Mono<T> intercept(Mono<T> message) {\n-        return get().apply(message);\n+    Mono<M> intercept(Mono<M> message);\n+\n+    @Override\n+    default BiFunction<Integer, M, M> handle(List<? extends M> messages) {\n+        return (position, message) -> intercept(Mono.just(message)).block();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0NzYxNA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396447614", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n          \n          \n            \n                 * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n          \n          \n            \n                 * asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n          \n          \n            \n                 * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n          \n          \n            \n                 * asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "author": "smcvb", "createdAt": "2020-03-23T13:25:42Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0ODI1OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396448259", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "author": "smcvb", "createdAt": "2020-03-23T13:26:44Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0ODY3OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396448679", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n          \n          \n            \n                 * asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n          \n          \n            \n                 * asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "author": "smcvb", "createdAt": "2020-03-23T13:27:28Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0OTEyMA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396449120", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "author": "smcvb", "createdAt": "2020-03-23T13:28:05Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0OTc2Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396449762", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "author": "smcvb", "createdAt": "2020-03-23T13:28:58Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MTI5MQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396451291", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n          \n          \n            \n                 * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n          \n          \n            \n                 * QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible results are received. The\n          \n          \n            \n                 * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n          \n          \n            \n                 * {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactiveQueryGateway}. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@code QueryBus} instead.", "author": "smcvb", "createdAt": "2020-03-23T13:31:13Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1Mjc1MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396452750", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return A flux of results\n          \n          \n            \n                 * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}", "author": "smcvb", "createdAt": "2020-03-23T13:33:25Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MzEzOQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396453139", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return A flux of results.\n          \n          \n            \n                 * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}", "author": "smcvb", "createdAt": "2020-03-23T13:33:59Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MzI1OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396453258", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return A flux of results.\n          \n          \n            \n                 * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}", "author": "smcvb", "createdAt": "2020-03-23T13:34:10Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1NDI3MQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396454271", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n          \n          \n            \n                 * Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results are received.\n          \n          \n            \n                 * Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactiveQueryGateway}. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@code QueryBus} instead.", "author": "smcvb", "createdAt": "2020-03-23T13:35:39Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1NTcwOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396455708", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n          \n          \n            \n                 * Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results are received.\n          \n          \n            \n                 * Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactiveQueryGateway}. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@code QueryBus} instead.", "author": "smcvb", "createdAt": "2020-03-23T13:37:47Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ2NjAzMA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396466030", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "author": "smcvb", "createdAt": "2020-03-23T13:52:34Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ2NzA5MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396467090", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "author": "smcvb", "createdAt": "2020-03-23T13:54:02Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ2NzY4NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396467685", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "author": "smcvb", "createdAt": "2020-03-23T13:54:50Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3MTE5NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396471195", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "author": "smcvb", "createdAt": "2020-03-23T13:59:38Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3MTk5Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396471997", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends thegiven {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "author": "smcvb", "createdAt": "2020-03-23T14:00:47Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3NjgyOQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396476829", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "author": "smcvb", "createdAt": "2020-03-23T14:07:56Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n+     *                            is made\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure,\n+                                                                            int updateBufferSize) {\n+        return subscriptionQuery(queryName,\n+                                 Mono.just(query),\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 updateBufferSize);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\ndeleted file mode 100644\nindex 8ba4a76da..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,386 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import org.axonframework.messaging.responsetypes.ResponseTypes;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.util.concurrent.Queues;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n- * from Project Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveQueryGateway {\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType A {@link Class} describing the desired response type\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n-        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n-     * asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n-        return query(query.getClass().getName(), query, responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n-        return query(queryName, Mono.just(query), responseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n-     */\n-    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n-     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n-     * QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results\n-     */\n-    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n-        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        The {@code query} to be sent\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n-                                         TimeUnit timeUnit) {\n-        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n-     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n-     * Execution may be asynchronous, depending on the QueryBus implementation.\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n-     * to be returned, we suggest using {@link QueryBus} instead.\n-     *\n-     * @param queryName    A {@link String} describing the query to be executed\n-     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param responseType The {@link ResponseType} used for this query\n-     * @param timeout      A timeout of {@code long} for the query\n-     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n-     * @param <R>          The response class contained in the given {@code responseType}\n-     * @param <Q>          The query class\n-     * @return A flux of results.\n-     */\n-    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                 TimeUnit timeUnit);\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            Class<I> initialResponseType,\n-                                                                            Class<U> updateResponseType) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 ResponseTypes.instanceOf(initialResponseType),\n-                                 ResponseTypes.instanceOf(updateResponseType),\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType) {\n-        return subscriptionQuery(query.getClass().getName(),\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 SubscriptionQueryBackpressure.defaultBackpressure());\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure) {\n-        return subscriptionQuery(queryName,\n-                                 query,\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 Queues.SMALL_BUFFER_SIZE);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               The {@code query} to be sent\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n-                                                                            ResponseType<I> initialResponseType,\n-                                                                            ResponseType<U> updateResponseType,\n-                                                                            SubscriptionQueryBackpressure backpressure,\n-                                                                            int updateBufferSize) {\n-        return subscriptionQuery(queryName,\n-                                 Mono.just(query),\n-                                 initialResponseType,\n-                                 updateResponseType,\n-                                 backpressure,\n-                                 updateBufferSize);\n-    }\n-\n-    /**\n-     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n-     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n-     * the emitting side).\n-     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n-     * Mono}</b></p>\n-     * <p>\n-     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n-     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n-     * the {@link QueryBus} instead.\n-     *\n-     * @param queryName           A {@link String} describing query to be executed\n-     * @param query               a {@link Mono} which is resolved once the caller subscribes to the query result\n-     * @param initialResponseType The initial response type used for this query\n-     * @param updateResponseType  The update response type used for this query\n-     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n-     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n-     *                            is made\n-     * @param <Q>                 The type of the query\n-     * @param <I>                 The type of the initial response\n-     * @param <U>                 The type of the incremental update\n-     * @return registration which can be used to cancel receiving updates\n-     *\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n-     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n-     */\n-    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                    ResponseType<I> initialResponseType,\n-                                                                    ResponseType<U> updateResponseType,\n-                                                                    SubscriptionQueryBackpressure backpressure,\n-                                                                    int updateBufferSize);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3NzQyNA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396477424", "bodyText": "I am missing tests which verify these beans are created.", "author": "smcvb", "createdAt": "2020-03-23T14:08:47Z", "path": "spring-boot-autoconfigure/src/main/java/org/axonframework/springboot/autoconfig/AxonAutoConfiguration.java", "diffHunk": "@@ -202,6 +205,24 @@ public QueryGateway queryGateway(QueryBus queryBus) {\n         return DefaultQueryGateway.builder().queryBus(queryBus).build();\n     }\n \n+    @Bean", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/spring-boot-autoconfigure/src/main/java/org/axonframework/springboot/autoconfig/AxonAutoConfiguration.java b/spring-boot-autoconfigure/src/main/java/org/axonframework/springboot/autoconfig/AxonAutoConfiguration.java\nindex b80d6ff83..3f3e4fb70 100644\n--- a/spring-boot-autoconfigure/src/main/java/org/axonframework/springboot/autoconfig/AxonAutoConfiguration.java\n+++ b/spring-boot-autoconfigure/src/main/java/org/axonframework/springboot/autoconfig/AxonAutoConfiguration.java\n\n@@ -208,19 +208,19 @@ public QueryGateway queryGateway(QueryBus queryBus) {\n     @Bean\n     @ConditionalOnMissingBean\n     @ConditionalOnClass(name = \"reactor.core.publisher.Mono\")\n-    public ReactiveCommandGateway reactiveCommandGateway(CommandBus commandBus) {\n-        return DefaultReactiveCommandGateway.builder()\n-                                            .commandBus(commandBus)\n-                                            .build();\n+    public ReactorCommandGateway reactiveCommandGateway(CommandBus commandBus) {\n+        return DefaultReactorCommandGateway.builder()\n+                                           .commandBus(commandBus)\n+                                           .build();\n     }\n \n     @Bean\n     @ConditionalOnMissingBean\n     @ConditionalOnClass(name = \"reactor.core.publisher.Mono\")\n-    public ReactiveQueryGateway reactiveQueryGateway(QueryBus queryBus) {\n-        return DefaultReactiveQueryGateway.builder()\n-                                          .queryBus(queryBus)\n-                                          .build();\n+    public ReactorQueryGateway reactiveQueryGateway(QueryBus queryBus) {\n+        return DefaultReactorQueryGateway.builder()\n+                                         .queryBus(queryBus)\n+                                         .build();\n     }\n \n     @Bean\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3OTQwNw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396479407", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Default implementation of {@link ReactiveCommandGateway}.\n          \n          \n            \n             * Default implementation of the {@link ReactiveCommandGateway}.", "author": "smcvb", "createdAt": "2020-03-23T14:11:36Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveCommandGateway}.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java\ndeleted file mode 100644\nindex 2c7964cb3..000000000\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java\n+++ /dev/null\n\n@@ -1,207 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.commandhandling.gateway;\n-\n-import org.axonframework.commandhandling.CommandBus;\n-import org.axonframework.commandhandling.CommandCallback;\n-import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.commandhandling.GenericCommandMessage;\n-import org.axonframework.common.AxonConfigurationException;\n-import org.axonframework.common.Registration;\n-import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.List;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n-import static java.util.Arrays.asList;\n-import static org.axonframework.common.BuilderUtils.assertNonNull;\n-\n-/**\n- * Default implementation of {@link ReactiveCommandGateway}.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public class DefaultReactiveCommandGateway implements ReactiveCommandGateway {\n-\n-    private final CommandBus commandBus;\n-    private final RetryScheduler retryScheduler;\n-    private final List<ReactiveMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n-\n-    /**\n-     * Creates an instance of {@link DefaultReactiveCommandGateway} based on the fields contained in the {@link\n-     * Builder}.\n-     * <p>\n-     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n-     * it is.\n-     * </p>\n-     *\n-     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactiveCommandGateway} instance\n-     */\n-    protected DefaultReactiveCommandGateway(Builder builder) {\n-        builder.validate();\n-        this.commandBus = builder.commandBus;\n-        this.retryScheduler = builder.retryScheduler;\n-        this.dispatchInterceptors = builder.dispatchInterceptors;\n-    }\n-\n-    /**\n-     * Instantiate a Builder to be able to create a {@link DefaultReactiveCommandGateway}.\n-     * <p>\n-     * The {@code dispatchInterceptors} are defaulted to an empty list.\n-     * The {@link CommandBus} is a <b>hard requirements</b> and as such should be provided.\n-     * </p>\n-     *\n-     * @return a Builder to be able to create a {@link DefaultReactiveCommandGateway}\n-     */\n-    public static Builder builder() {\n-        return new Builder();\n-    }\n-\n-    @Override\n-    public <R> Mono<R> send(Mono<Object> command) {\n-        return processInterceptors(command.map(GenericCommandMessage::asCommandMessage))\n-                .flatMap(commandMessage -> Mono.create(\n-                        sink -> {\n-                            CommandCallback<Object, R> commandCallback = (cm, result) -> {\n-                                try {\n-                                    if (result.isExceptional()) {\n-                                        sink.error(result.exceptionResult());\n-                                    } else {\n-                                        sink.success(result.getPayload());\n-                                    }\n-                                } catch (Exception e) {\n-                                    sink.error(e);\n-                                }\n-                            };\n-                            if (retryScheduler != null) {\n-                                commandCallback = new RetryingCallback<>(commandCallback, retryScheduler, commandBus);\n-                            }\n-                            commandBus.dispatch(commandMessage, commandCallback);\n-                        }));\n-    }\n-\n-    /**\n-     * Registers a {@link ReactiveMessageDispatchInterceptor} within this reactive gateway.\n-     *\n-     * @param interceptor intercepts a command message\n-     * @return a registration which can be used to unregister this {@code interceptor}\n-     */\n-    public Registration registerCommandDispatchInterceptor(\n-            ReactiveMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n-        dispatchInterceptors.add(interceptor);\n-        return () -> dispatchInterceptors.remove(interceptor);\n-    }\n-\n-    private Mono<CommandMessage<?>> processInterceptors(Mono<CommandMessage<?>> commandMessage) {\n-        Mono<CommandMessage<?>> message = commandMessage;\n-        for (ReactiveMessageDispatchInterceptor<CommandMessage<?>> dispatchInterceptor : dispatchInterceptors) {\n-            try {\n-                message = dispatchInterceptor.intercept(message);\n-            } catch (Throwable t) {\n-                return Mono.error(t);\n-            }\n-        }\n-        return message;\n-    }\n-\n-    /**\n-     * Builder class to instantiate {@link DefaultReactiveCommandGateway}.\n-     * <p>\n-     * The {@code dispatchInterceptors} are defaulted to an empty list.\n-     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n-     * </p>\n-     */\n-    public static class Builder {\n-\n-        private CommandBus commandBus;\n-        private RetryScheduler retryScheduler;\n-        private List<ReactiveMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors = new CopyOnWriteArrayList<>();\n-\n-        /**\n-         * Sets the {@link CommandBus} used to dispatch commands.\n-         *\n-         * @param commandBus a {@link CommandBus} used to dispatch commands\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder commandBus(CommandBus commandBus) {\n-            assertNonNull(commandBus, \"CommandBus may not be null\");\n-            this.commandBus = commandBus;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the {@link RetryScheduler} capable of performing retries of failed commands. May be {@code null} when\n-         * to prevent retries.\n-         *\n-         * @param retryScheduler a {@link RetryScheduler} capable of performing retries of failed commands\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder retryScheduler(RetryScheduler retryScheduler) {\n-            this.retryScheduler = retryScheduler;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the {@link List} of {@link ReactiveMessageDispatchInterceptor}s for {@link CommandMessage}s. Are invoked\n-         * when a command is being dispatched.\n-         *\n-         * @param dispatchInterceptors which are invoked when a command is being dispatched\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        @SafeVarargs\n-        public final Builder dispatchInterceptors(\n-                ReactiveMessageDispatchInterceptor<CommandMessage<?>>... dispatchInterceptors) {\n-            return dispatchInterceptors(asList(dispatchInterceptors));\n-        }\n-\n-        /**\n-         * Sets the {@link List} of {@link ReactiveMessageDispatchInterceptor}s for {@link CommandMessage}s. Are invoked\n-         * when a command is being dispatched.\n-         *\n-         * @param dispatchInterceptors which are invoked when a command is being dispatched\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder dispatchInterceptors(\n-                List<ReactiveMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors) {\n-            this.dispatchInterceptors = dispatchInterceptors != null && dispatchInterceptors.isEmpty()\n-                    ? new CopyOnWriteArrayList<>(dispatchInterceptors)\n-                    : new CopyOnWriteArrayList<>();\n-            return this;\n-        }\n-\n-        /**\n-         * Validate whether the fields contained in this Builder as set accordingly.\n-         *\n-         * @throws AxonConfigurationException if one field is asserted to be incorrect according to the Builder's\n-         *                                    specifications\n-         */\n-        protected void validate() {\n-            assertNonNull(commandBus, \"The CommandBus is a hard requirement and should be provided\");\n-        }\n-\n-        /**\n-         * Initializes a {@link DefaultReactiveCommandGateway} as specified through this Builder.\n-         *\n-         * @return a {@link DefaultReactiveCommandGateway} as specified through this Builder\n-         */\n-        public DefaultReactiveCommandGateway build() {\n-            return new DefaultReactiveCommandGateway(this);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDA2NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396484064", "bodyText": "Would it make sense to introduce a ReactiveMessageDispatchInterceptorSupport implementation which this interface extends? I feel it does, but might be suited for a follow up issue.", "author": "smcvb", "createdAt": "2020-03-23T14:18:00Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.messaging.Message;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveCommandGateway {", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java\ndeleted file mode 100644\nindex c3d667c54..000000000\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java\n+++ /dev/null\n\n@@ -1,55 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.commandhandling.gateway;\n-\n-import org.axonframework.messaging.Message;\n-import reactor.core.publisher.Mono;\n-\n-/**\n- * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n- * Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveCommandGateway {\n-\n-    /**\n-     * Sends the given {@code command} once the caller subscribes to the command result. Returns immediately.\n-     * <p/>\n-     * The given {@code command} is wrapped as the payload of the CommandMessage that is eventually posted on the\n-     * Command Bus, unless Command already implements {@link Message}. In that case, a\n-     * CommandMessage is constructed from that message's payload and MetaData.\n-     *\n-     * @param command the command to dispatch\n-     * @param <R>     the type of the command result\n-     * @return a {@link Mono} which is resolved when the command is executed\n-     */\n-    default <R> Mono<R> send(Object command) {\n-        return send(Mono.just(command));\n-    }\n-\n-    /**\n-     * Sends the given {@code command} once the caller subscribes to the command result. Returns immediately.\n-     *\n-     * @param command a {@link Mono} which is resolved once the caller subscribes to the command result\n-     * @param <R>     the type of the command result\n-     * @return a {@link Mono} which is resolved when the command is executed\n-     * @see #send(Object)\n-     */\n-    <R> Mono<R> send(Mono<Object> command);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396484703", "bodyText": "Would there be a way to reuse the existing MessageDispatchInterceptor implementations as a ReactiveMessageDispatchInterceptor?", "author": "smcvb", "createdAt": "2020-03-23T14:18:50Z", "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3MDg3Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r401470872", "bodyText": "Not really, at least I don't see a way since MessageDispatchInterceptor is parameterized with T extends Message<?> and ReactiveMessageDispatchInterceptor assumes using Mono<T extends Message<?>>.\nIf you have something else in mind please share :)", "author": "m1l4n54v1c", "createdAt": "2020-04-01T09:17:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEyMzU2Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404123562", "bodyText": "Nope, not really...let's go with this for now and have both gateways take their own path.", "author": "smcvb", "createdAt": "2020-04-06T14:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NTA2NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413685064", "bodyText": "Can we then at least make sure that existing DispatchInterceptors can be used in the reactive gateway? By means of a wrapper, perhaps?", "author": "abuijze", "createdAt": "2020-04-23T10:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5MDIxNQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413690215", "bodyText": "I actually think it is possible, generics wise....", "author": "abuijze", "createdAt": "2020-04-23T10:12:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ5NzcxNQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r414497715", "bodyText": "Oooh, looking forward to that! Would definitely improve this implementation if the existing interceptors can be used.", "author": "smcvb", "createdAt": "2020-04-24T11:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\nsimilarity index 53%\nrename from messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java\nrename to messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\nindex 02f679f27..52dedc7c3 100644\n--- a/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java\n+++ b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\n\n@@ -14,31 +14,39 @@\n  * limitations under the License.\n  */\n \n-package org.axonframework.messaging;\n+package org.axonframework.messaging.reactive;\n \n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n import reactor.core.publisher.Mono;\n \n-import java.util.function.Function;\n-import java.util.function.Supplier;\n+import java.util.List;\n+import java.util.function.BiFunction;\n \n /**\n  * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n- * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n- * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n+ * be passed down the interceptor chain or to be dispatched.\n  *\n- * @param <T> the message type this interceptor can process\n+ * @param <M> the message type this interceptor can process\n  * @author Milan Savic\n  * @since 4.4\n  */\n-public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+@FunctionalInterface\n+public interface ReactorMessageDispatchInterceptor<M extends Message<?>> extends\n+        MessageDispatchInterceptor<M> {\n \n     /**\n-     * Intercepts a message.\n+     * Intercepts a message. It's possible to break the interceptor chain by returning {@link Mono#empty()} or {@link\n+     * Mono#error(Throwable)} variations.\n      *\n      * @param message a {@link Mono} of a message to be intercepted\n      * @return the message {@link Mono} to dispatch\n      */\n-    default Mono<T> intercept(Mono<T> message) {\n-        return get().apply(message);\n+    Mono<M> intercept(Mono<M> message);\n+\n+    @Override\n+    default BiFunction<Integer, M, M> handle(List<? extends M> messages) {\n+        return (position, message) -> intercept(Mono.just(message)).block();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NTYzMw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396485633", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Default implementation of {@link ReactiveQueryGateway}.\n          \n          \n            \n             * Default implementation of the {@link ReactiveQueryGateway}.", "author": "smcvb", "createdAt": "2020-03-23T14:20:08Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.IllegalPayloadAccessException;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveQueryGateway}.", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java\ndeleted file mode 100644\nindex c030f8fae..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,244 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.common.AxonConfigurationException;\n-import org.axonframework.common.Registration;\n-import org.axonframework.messaging.IllegalPayloadAccessException;\n-import org.axonframework.messaging.Message;\n-import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.util.Arrays.asList;\n-import static org.axonframework.common.BuilderUtils.assertNonNull;\n-\n-/**\n- * Default implementation of {@link ReactiveQueryGateway}.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public class DefaultReactiveQueryGateway implements ReactiveQueryGateway {\n-\n-    private final List<ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n-\n-    private final QueryBus queryBus;\n-\n-    /**\n-     * Creates an instance of {@link DefaultReactiveQueryGateway} based on the fields contained in the {@link\n-     * Builder}.\n-     * <p>\n-     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n-     * it is.\n-     * </p>\n-     *\n-     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactiveQueryGateway} instance\n-     */\n-    protected DefaultReactiveQueryGateway(Builder builder) {\n-        builder.validate();\n-        this.queryBus = builder.queryBus;\n-        this.dispatchInterceptors = builder.dispatchInterceptors;\n-    }\n-\n-    /**\n-     * Instantiate a Builder to be able to create a {@link DefaultReactiveQueryGateway}.\n-     * <p>\n-     * The {@code dispatchInterceptors} are defaulted to an empty list.\n-     * The {@link QueryBus} is a <b>hard requirements</b> and as such should be provided.\n-     * </p>\n-     *\n-     * @return a Builder to be able to create a {@link DefaultReactiveQueryGateway}\n-     */\n-    public static Builder builder() {\n-        return new Builder();\n-    }\n-\n-    /**\n-     * Registers a {@link ReactiveMessageDispatchInterceptor} within this reactive gateway.\n-     *\n-     * @param interceptor intercepts a query message\n-     * @return a registration which can be used to unregister this {@code interceptor}\n-     */\n-    public Registration registerQueryDispatchInterceptor(\n-            ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n-        dispatchInterceptors.add(interceptor);\n-        return () -> dispatchInterceptors.remove(interceptor);\n-    }\n-\n-    private Mono<QueryMessage<?, ?>> processInterceptors(Mono<QueryMessage<?, ?>> queryMessage) {\n-        Mono<QueryMessage<?, ?>> message = queryMessage;\n-        for (ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>> dispatchInterceptor : dispatchInterceptors) {\n-            try {\n-                message = dispatchInterceptor.intercept(message);\n-            } catch (Throwable t) {\n-                return Mono.error(t);\n-            }\n-        }\n-        return message;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType) {\n-        return processInterceptors(query.map(q -> new GenericQueryMessage<>(q, queryName, responseType)))\n-                .flatMap(queryMessage -> Mono.create(\n-                        sink -> queryBus.query(queryMessage).whenComplete((response, throwable) -> {\n-                            try {\n-                                if (throwable != null) {\n-                                    sink.error(throwable);\n-                                } else {\n-                                    if (response.isExceptional()) {\n-                                        sink.error(response.exceptionResult());\n-                                    } else {\n-                                        sink.success(((QueryResponseMessage<R>) response).getPayload());\n-                                    }\n-                                }\n-                            } catch (Exception e) {\n-                                sink.error(e);\n-                            }\n-                        })\n-                ));\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                        TimeUnit timeUnit) {\n-        return processInterceptors(query.map(q -> new GenericQueryMessage<>(q, queryName, responseType)))\n-                .flatMapMany(queryMessage -> Flux.create(\n-                        sink -> {\n-                            try {\n-                                queryBus.scatterGather((QueryMessage<?, R>) queryMessage, timeout, timeUnit)\n-                                        .map(Message::getPayload)\n-                                        .filter(Objects::nonNull)\n-                                        .forEach(sink::next);\n-                                sink.complete();\n-                            } catch (Exception e){\n-                                sink.error(e);\n-                            }\n-                        }\n-                ));\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                           ResponseType<I> initialResponseType,\n-                                                                           ResponseType<U> updateResponseType,\n-                                                                           SubscriptionQueryBackpressure backpressure,\n-                                                                           int updateBufferSize) {\n-        return processInterceptors(query.map(q -> new GenericSubscriptionQueryMessage<>(q,\n-                                                                                        queryName,\n-                                                                                        initialResponseType,\n-                                                                                        updateResponseType)))\n-                .flatMap(queryMessage -> {\n-                    SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>> data = queryBus\n-                            .subscriptionQuery((SubscriptionQueryMessage<Q, I, U>) queryMessage,\n-                                               backpressure,\n-                                               updateBufferSize);\n-                    return Mono.just(new DefaultSubscriptionQueryResult<>(\n-                            data.initialResult()\n-                                .filter(initialResult -> Objects.nonNull(initialResult.getPayload()))\n-                                .map(Message::getPayload)\n-                                .onErrorMap(e -> e instanceof IllegalPayloadAccessException ? e.getCause() : e),\n-                            data.updates()\n-                                .filter(update -> Objects.nonNull(update.getPayload()))\n-                                .map(SubscriptionQueryUpdateMessage::getPayload),\n-                            data\n-                    ));\n-                });\n-    }\n-\n-    /**\n-     * Builder class to instantiate {@link DefaultReactiveQueryGateway}.\n-     * <p>\n-     * The {@code dispatchInterceptors} are defaulted to an empty list.\n-     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n-     * </p>\n-     */\n-    public static class Builder {\n-\n-        private QueryBus queryBus;\n-        private List<ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors = new CopyOnWriteArrayList<>();\n-\n-        /**\n-         * Sets the {@link QueryBus} used to dispatch queries.\n-         *\n-         * @param queryBus a {@link QueryBus} used to dispatch queries\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder queryBus(QueryBus queryBus) {\n-            assertNonNull(queryBus, \"QueryBus may not be null\");\n-            this.queryBus = queryBus;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the {@link List} of {@link ReactiveMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n-         * when a query is being dispatched.\n-         *\n-         * @param dispatchInterceptors which are invoked when a query is being dispatched\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        @SafeVarargs\n-        public final Builder dispatchInterceptors(\n-                ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>>... dispatchInterceptors) {\n-            return dispatchInterceptors(asList(dispatchInterceptors));\n-        }\n-\n-        /**\n-         * Sets the {@link List} of {@link ReactiveMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n-         * when a query is being dispatched.\n-         *\n-         * @param dispatchInterceptors which are invoked when a query is being dispatched\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder dispatchInterceptors(\n-                List<ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors) {\n-            this.dispatchInterceptors = dispatchInterceptors != null && dispatchInterceptors.isEmpty()\n-                    ? new CopyOnWriteArrayList<>(dispatchInterceptors)\n-                    : new CopyOnWriteArrayList<>();\n-            return this;\n-        }\n-\n-        /**\n-         * Validate whether the fields contained in this Builder as set accordingly.\n-         *\n-         * @throws AxonConfigurationException if one field is asserted to be incorrect according to the Builder's\n-         *                                    specifications\n-         */\n-        protected void validate() {\n-            assertNonNull(queryBus, \"The QueryBus is a hard requirement and should be provided\");\n-        }\n-\n-        /**\n-         * Initializes a {@link DefaultReactiveQueryGateway} as specified through this Builder.\n-         *\n-         * @return a {@link DefaultReactiveQueryGateway} as specified through this Builder\n-         */\n-        public DefaultReactiveQueryGateway build() {\n-            return new DefaultReactiveQueryGateway(this);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NzgzMw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396487833", "bodyText": "Thought: I've personally been moving away from method-level warning suppression towards line/statement suppression. Reasoning behind this is that developers can now accidentally add unintended stuff they do not want to suppress. What do you think?", "author": "smcvb", "createdAt": "2020-03-23T14:22:55Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.IllegalPayloadAccessException;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveQueryGateway}.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactiveQueryGateway implements ReactiveQueryGateway {\n+\n+    private final List<ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactiveQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactiveQueryGateway} instance\n+     */\n+    protected DefaultReactiveQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactiveQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirements</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactiveQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Registers a {@link ReactiveMessageDispatchInterceptor} within this reactive gateway.\n+     *\n+     * @param interceptor intercepts a query message\n+     * @return a registration which can be used to unregister this {@code interceptor}\n+     */\n+    public Registration registerQueryDispatchInterceptor(\n+            ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processInterceptors(Mono<QueryMessage<?, ?>> queryMessage) {\n+        Mono<QueryMessage<?, ?>> message = queryMessage;\n+        for (ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>> dispatchInterceptor : dispatchInterceptors) {\n+            try {\n+                message = dispatchInterceptor.intercept(message);\n+            } catch (Throwable t) {\n+                return Mono.error(t);\n+            }\n+        }\n+        return message;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1ODYzNQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r399358635", "bodyText": "Agree!", "author": "m1l4n54v1c", "createdAt": "2020-03-27T15:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NzgzMw=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java\ndeleted file mode 100644\nindex c030f8fae..000000000\n--- a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java\n+++ /dev/null\n\n@@ -1,244 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.queryhandling;\n-\n-import org.axonframework.common.AxonConfigurationException;\n-import org.axonframework.common.Registration;\n-import org.axonframework.messaging.IllegalPayloadAccessException;\n-import org.axonframework.messaging.Message;\n-import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n-import org.axonframework.messaging.responsetypes.ResponseType;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.util.Arrays.asList;\n-import static org.axonframework.common.BuilderUtils.assertNonNull;\n-\n-/**\n- * Default implementation of {@link ReactiveQueryGateway}.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public class DefaultReactiveQueryGateway implements ReactiveQueryGateway {\n-\n-    private final List<ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n-\n-    private final QueryBus queryBus;\n-\n-    /**\n-     * Creates an instance of {@link DefaultReactiveQueryGateway} based on the fields contained in the {@link\n-     * Builder}.\n-     * <p>\n-     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n-     * it is.\n-     * </p>\n-     *\n-     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactiveQueryGateway} instance\n-     */\n-    protected DefaultReactiveQueryGateway(Builder builder) {\n-        builder.validate();\n-        this.queryBus = builder.queryBus;\n-        this.dispatchInterceptors = builder.dispatchInterceptors;\n-    }\n-\n-    /**\n-     * Instantiate a Builder to be able to create a {@link DefaultReactiveQueryGateway}.\n-     * <p>\n-     * The {@code dispatchInterceptors} are defaulted to an empty list.\n-     * The {@link QueryBus} is a <b>hard requirements</b> and as such should be provided.\n-     * </p>\n-     *\n-     * @return a Builder to be able to create a {@link DefaultReactiveQueryGateway}\n-     */\n-    public static Builder builder() {\n-        return new Builder();\n-    }\n-\n-    /**\n-     * Registers a {@link ReactiveMessageDispatchInterceptor} within this reactive gateway.\n-     *\n-     * @param interceptor intercepts a query message\n-     * @return a registration which can be used to unregister this {@code interceptor}\n-     */\n-    public Registration registerQueryDispatchInterceptor(\n-            ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n-        dispatchInterceptors.add(interceptor);\n-        return () -> dispatchInterceptors.remove(interceptor);\n-    }\n-\n-    private Mono<QueryMessage<?, ?>> processInterceptors(Mono<QueryMessage<?, ?>> queryMessage) {\n-        Mono<QueryMessage<?, ?>> message = queryMessage;\n-        for (ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>> dispatchInterceptor : dispatchInterceptors) {\n-            try {\n-                message = dispatchInterceptor.intercept(message);\n-            } catch (Throwable t) {\n-                return Mono.error(t);\n-            }\n-        }\n-        return message;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType) {\n-        return processInterceptors(query.map(q -> new GenericQueryMessage<>(q, queryName, responseType)))\n-                .flatMap(queryMessage -> Mono.create(\n-                        sink -> queryBus.query(queryMessage).whenComplete((response, throwable) -> {\n-                            try {\n-                                if (throwable != null) {\n-                                    sink.error(throwable);\n-                                } else {\n-                                    if (response.isExceptional()) {\n-                                        sink.error(response.exceptionResult());\n-                                    } else {\n-                                        sink.success(((QueryResponseMessage<R>) response).getPayload());\n-                                    }\n-                                }\n-                            } catch (Exception e) {\n-                                sink.error(e);\n-                            }\n-                        })\n-                ));\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n-                                        TimeUnit timeUnit) {\n-        return processInterceptors(query.map(q -> new GenericQueryMessage<>(q, queryName, responseType)))\n-                .flatMapMany(queryMessage -> Flux.create(\n-                        sink -> {\n-                            try {\n-                                queryBus.scatterGather((QueryMessage<?, R>) queryMessage, timeout, timeUnit)\n-                                        .map(Message::getPayload)\n-                                        .filter(Objects::nonNull)\n-                                        .forEach(sink::next);\n-                                sink.complete();\n-                            } catch (Exception e){\n-                                sink.error(e);\n-                            }\n-                        }\n-                ));\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Mono<Q> query,\n-                                                                           ResponseType<I> initialResponseType,\n-                                                                           ResponseType<U> updateResponseType,\n-                                                                           SubscriptionQueryBackpressure backpressure,\n-                                                                           int updateBufferSize) {\n-        return processInterceptors(query.map(q -> new GenericSubscriptionQueryMessage<>(q,\n-                                                                                        queryName,\n-                                                                                        initialResponseType,\n-                                                                                        updateResponseType)))\n-                .flatMap(queryMessage -> {\n-                    SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>> data = queryBus\n-                            .subscriptionQuery((SubscriptionQueryMessage<Q, I, U>) queryMessage,\n-                                               backpressure,\n-                                               updateBufferSize);\n-                    return Mono.just(new DefaultSubscriptionQueryResult<>(\n-                            data.initialResult()\n-                                .filter(initialResult -> Objects.nonNull(initialResult.getPayload()))\n-                                .map(Message::getPayload)\n-                                .onErrorMap(e -> e instanceof IllegalPayloadAccessException ? e.getCause() : e),\n-                            data.updates()\n-                                .filter(update -> Objects.nonNull(update.getPayload()))\n-                                .map(SubscriptionQueryUpdateMessage::getPayload),\n-                            data\n-                    ));\n-                });\n-    }\n-\n-    /**\n-     * Builder class to instantiate {@link DefaultReactiveQueryGateway}.\n-     * <p>\n-     * The {@code dispatchInterceptors} are defaulted to an empty list.\n-     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n-     * </p>\n-     */\n-    public static class Builder {\n-\n-        private QueryBus queryBus;\n-        private List<ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors = new CopyOnWriteArrayList<>();\n-\n-        /**\n-         * Sets the {@link QueryBus} used to dispatch queries.\n-         *\n-         * @param queryBus a {@link QueryBus} used to dispatch queries\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder queryBus(QueryBus queryBus) {\n-            assertNonNull(queryBus, \"QueryBus may not be null\");\n-            this.queryBus = queryBus;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the {@link List} of {@link ReactiveMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n-         * when a query is being dispatched.\n-         *\n-         * @param dispatchInterceptors which are invoked when a query is being dispatched\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        @SafeVarargs\n-        public final Builder dispatchInterceptors(\n-                ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>>... dispatchInterceptors) {\n-            return dispatchInterceptors(asList(dispatchInterceptors));\n-        }\n-\n-        /**\n-         * Sets the {@link List} of {@link ReactiveMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n-         * when a query is being dispatched.\n-         *\n-         * @param dispatchInterceptors which are invoked when a query is being dispatched\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder dispatchInterceptors(\n-                List<ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors) {\n-            this.dispatchInterceptors = dispatchInterceptors != null && dispatchInterceptors.isEmpty()\n-                    ? new CopyOnWriteArrayList<>(dispatchInterceptors)\n-                    : new CopyOnWriteArrayList<>();\n-            return this;\n-        }\n-\n-        /**\n-         * Validate whether the fields contained in this Builder as set accordingly.\n-         *\n-         * @throws AxonConfigurationException if one field is asserted to be incorrect according to the Builder's\n-         *                                    specifications\n-         */\n-        protected void validate() {\n-            assertNonNull(queryBus, \"The QueryBus is a hard requirement and should be provided\");\n-        }\n-\n-        /**\n-         * Initializes a {@link DefaultReactiveQueryGateway} as specified through this Builder.\n-         *\n-         * @return a {@link DefaultReactiveQueryGateway} as specified through this Builder\n-         */\n-        public DefaultReactiveQueryGateway build() {\n-            return new DefaultReactiveQueryGateway(this);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ5Mzc4Ng==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396493786", "bodyText": "With the move to JUnit 5, all test classes have been made package-private.", "author": "smcvb", "createdAt": "2020-03-23T14:31:04Z", "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.SimpleCommandBus;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.util.Collections;\n+\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ */\n+public class DefaultReactiveCommandGatewayTest {", "originalCommit": "c4511e81820de8d15c641e1c3038f4b688e29b51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java b/messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java\ndeleted file mode 100644\nindex 8a3edd890..000000000\n--- a/messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java\n+++ /dev/null\n\n@@ -1,121 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.commandhandling.gateway;\n-\n-import org.axonframework.commandhandling.CommandBus;\n-import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.commandhandling.SimpleCommandBus;\n-import org.axonframework.common.Registration;\n-import org.axonframework.messaging.MessageHandler;\n-import org.junit.jupiter.api.*;\n-import reactor.core.publisher.Mono;\n-import reactor.test.StepVerifier;\n-\n-import java.util.Collections;\n-\n-import static org.mockito.Mockito.*;\n-\n-/**\n- * Tests for {@link ReactiveCommandGateway}.\n- *\n- * @author Milan Savic\n- */\n-public class DefaultReactiveCommandGatewayTest {\n-\n-    private DefaultReactiveCommandGateway reactiveCommandGateway;\n-    private MessageHandler<CommandMessage<?>> commandMessageHandler;\n-    private RetryScheduler mockRetryScheduler;\n-\n-    @BeforeEach\n-    void setUp() {\n-        CommandBus commandBus = SimpleCommandBus.builder().build();\n-        mockRetryScheduler = mock(RetryScheduler.class);\n-        commandMessageHandler = spy(new MessageHandler<CommandMessage<?>>() {\n-            @Override\n-            public Object handle(CommandMessage<?> message) {\n-                return \"handled\";\n-            }\n-        });\n-        commandBus.subscribe(String.class.getName(), commandMessageHandler);\n-        commandBus.subscribe(Integer.class.getName(), message -> {\n-            throw new RuntimeException();\n-        });\n-        commandBus.subscribe(Boolean.class.getName(),\n-                             message -> \"\" + message.getMetaData().getOrDefault(\"key1\", \"\")\n-                                     + message.getMetaData().getOrDefault(\"key2\", \"\"));\n-        reactiveCommandGateway = DefaultReactiveCommandGateway.builder()\n-                                                              .commandBus(commandBus)\n-                                                              .retryScheduler(mockRetryScheduler)\n-                                                              .build();\n-    }\n-\n-    @Test\n-    void testSend() throws Exception {\n-        Mono<String> result = reactiveCommandGateway.send(\"command\");\n-        verifyZeroInteractions(commandMessageHandler);\n-        StepVerifier.create(result)\n-                    .expectNext(\"handled\")\n-                    .verifyComplete();\n-        verify(commandMessageHandler).handle(any());\n-        verifyZeroInteractions(mockRetryScheduler);\n-    }\n-\n-    @Test\n-    void testSendFails() {\n-        StepVerifier.create(reactiveCommandGateway.send(5))\n-                    .verifyError(RuntimeException.class);\n-        verify(mockRetryScheduler).scheduleRetry(any(), any(), anyList(), any());\n-    }\n-\n-    @Test\n-    void testSendWithDispatchInterceptor() {\n-        reactiveCommandGateway\n-                .registerCommandDispatchInterceptor(() -> cmdMono -> cmdMono\n-                        .map(cmd -> cmd.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n-        Registration registration2 = reactiveCommandGateway\n-                .registerCommandDispatchInterceptor(() -> cmdMono -> cmdMono\n-                        .map(cmd -> cmd.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n-\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .expectNext(\"value1value2\")\n-                    .verifyComplete();\n-\n-        registration2.cancel();\n-\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .expectNext(\"value1\")\n-                    .verifyComplete();\n-    }\n-\n-    @Test\n-    void testDispatchInterceptorThrowingAnException() {\n-        reactiveCommandGateway\n-                .registerCommandDispatchInterceptor(() -> cmdMono -> {\n-                    throw new RuntimeException();\n-                });\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .verifyError(RuntimeException.class);\n-    }\n-\n-    @Test\n-    void testDispatchInterceptorReturningErrorMono() {\n-        reactiveCommandGateway\n-                .registerCommandDispatchInterceptor(() -> cmdMono -> Mono.error(new RuntimeException()));\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .verifyError(RuntimeException.class);\n-    }\n-}\n"}}, {"oid": "e8a4f1bd0acc921094c78fddc86bef78628ac343", "url": "https://github.com/AxonFramework/AxonFramework/commit/e8a4f1bd0acc921094c78fddc86bef78628ac343", "message": "Update messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T15:15:58Z", "type": "commit"}, {"oid": "76806ce0f2f7a717f1431a7e913b39d1f251c125", "url": "https://github.com/AxonFramework/AxonFramework/commit/76806ce0f2f7a717f1431a7e913b39d1f251c125", "message": "Update messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T15:19:44Z", "type": "commit"}, {"oid": "61533b20534a7d79b90733b40f251b0f66b9285a", "url": "https://github.com/AxonFramework/AxonFramework/commit/61533b20534a7d79b90733b40f251b0f66b9285a", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T15:19:58Z", "type": "commit"}, {"oid": "3d8f37c6eeb845170d89fd326bd0e685ea740683", "url": "https://github.com/AxonFramework/AxonFramework/commit/3d8f37c6eeb845170d89fd326bd0e685ea740683", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T15:20:11Z", "type": "commit"}, {"oid": "30abd74032e15fa788c91d08a76e22d4b317423e", "url": "https://github.com/AxonFramework/AxonFramework/commit/30abd74032e15fa788c91d08a76e22d4b317423e", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T15:20:40Z", "type": "commit"}, {"oid": "c7753be1e5af6b8484f2051a0e346cbb5cc24e26", "url": "https://github.com/AxonFramework/AxonFramework/commit/c7753be1e5af6b8484f2051a0e346cbb5cc24e26", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T15:21:12Z", "type": "commit"}, {"oid": "65c54ea2ec8d6f80ffca28231a49c0b50d5137c3", "url": "https://github.com/AxonFramework/AxonFramework/commit/65c54ea2ec8d6f80ffca28231a49c0b50d5137c3", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T15:37:59Z", "type": "commit"}, {"oid": "431f9c80cfa5e5f36dec0bcedfbaa90f85cb947c", "url": "https://github.com/AxonFramework/AxonFramework/commit/431f9c80cfa5e5f36dec0bcedfbaa90f85cb947c", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T15:59:04Z", "type": "commit"}, {"oid": "f7447abd7be8613991e5f486acf2a5fff68eb906", "url": "https://github.com/AxonFramework/AxonFramework/commit/f7447abd7be8613991e5f486acf2a5fff68eb906", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T15:59:35Z", "type": "commit"}, {"oid": "ab2068c09f24b5b13bd733c34670903b9cab438e", "url": "https://github.com/AxonFramework/AxonFramework/commit/ab2068c09f24b5b13bd733c34670903b9cab438e", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T16:00:31Z", "type": "commit"}, {"oid": "90c187bbd7121e2c39581e8d3d949ae40f03cf2b", "url": "https://github.com/AxonFramework/AxonFramework/commit/90c187bbd7121e2c39581e8d3d949ae40f03cf2b", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T16:00:55Z", "type": "commit"}, {"oid": "23cf99fde1c11b633fca11dbfa845effb4221a0a", "url": "https://github.com/AxonFramework/AxonFramework/commit/23cf99fde1c11b633fca11dbfa845effb4221a0a", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T16:02:13Z", "type": "commit"}, {"oid": "5a6c286c20bbee8606ec38bd65745df8e894bf19", "url": "https://github.com/AxonFramework/AxonFramework/commit/5a6c286c20bbee8606ec38bd65745df8e894bf19", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T16:02:31Z", "type": "commit"}, {"oid": "09b2cbbd40734404e90b15b156173528616eb1c6", "url": "https://github.com/AxonFramework/AxonFramework/commit/09b2cbbd40734404e90b15b156173528616eb1c6", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T16:03:02Z", "type": "commit"}, {"oid": "f7e0229d07511ba15613e0d8a1700bb74fa154d9", "url": "https://github.com/AxonFramework/AxonFramework/commit/f7e0229d07511ba15613e0d8a1700bb74fa154d9", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T16:03:34Z", "type": "commit"}, {"oid": "e7874eda9eef72539f8f6205fe5f4daf12837f76", "url": "https://github.com/AxonFramework/AxonFramework/commit/e7874eda9eef72539f8f6205fe5f4daf12837f76", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T16:08:24Z", "type": "commit"}, {"oid": "00546f0d9851a60cf41315cec8d8d846f886465a", "url": "https://github.com/AxonFramework/AxonFramework/commit/00546f0d9851a60cf41315cec8d8d846f886465a", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T16:09:08Z", "type": "commit"}, {"oid": "073798ea757fbd6d934e99b6d34c4cfaa6e246ea", "url": "https://github.com/AxonFramework/AxonFramework/commit/073798ea757fbd6d934e99b6d34c4cfaa6e246ea", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T16:09:30Z", "type": "commit"}, {"oid": "571a1b8fca3258310d83783170fe29109349864d", "url": "https://github.com/AxonFramework/AxonFramework/commit/571a1b8fca3258310d83783170fe29109349864d", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T16:10:21Z", "type": "commit"}, {"oid": "aed059d8c015a032831dd6f823c66adc402ae0db", "url": "https://github.com/AxonFramework/AxonFramework/commit/aed059d8c015a032831dd6f823c66adc402ae0db", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T16:11:16Z", "type": "commit"}, {"oid": "6579c13c23c460d07a169539b877250ade1b5004", "url": "https://github.com/AxonFramework/AxonFramework/commit/6579c13c23c460d07a169539b877250ade1b5004", "message": "Update messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-03-27T16:11:45Z", "type": "commit"}, {"oid": "e3760cdbb3f94d0f80b56f8bbff571857c605194", "url": "https://github.com/AxonFramework/AxonFramework/commit/e3760cdbb3f94d0f80b56f8bbff571857c605194", "message": "Code review remarks.", "committedDate": "2020-04-01T09:03:37Z", "type": "commit"}, {"oid": "1c189880a72b9b745b3dec904f64a029cbf7fce8", "url": "https://github.com/AxonFramework/AxonFramework/commit/1c189880a72b9b745b3dec904f64a029cbf7fce8", "message": "Introduced ReactiveMessageDispatchInterceptorSupport.", "committedDate": "2020-04-02T07:53:33Z", "type": "commit"}, {"oid": "3d12250dbd32f20a5486e67c65db919e36b30370", "url": "https://github.com/AxonFramework/AxonFramework/commit/3d12250dbd32f20a5486e67c65db919e36b30370", "message": "Formatted code.", "committedDate": "2020-04-04T11:01:23Z", "type": "commit"}, {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5", "url": "https://github.com/AxonFramework/AxonFramework/commit/d85b4f18074f957a2039ac08fdfb6e5a86d919f5", "message": "SimpleQueryBus - report errors as QueryResponseMessage (but keep errorHandler reporting for backwards compatibility)\nDefaultReactiveQueryGateway - react on these errors and report them on fluxSink.error", "committedDate": "2020-04-06T11:28:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0MDk0Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404140942", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interface marking components capable of registering Reactive Dispatch Interceptors. Generally, these are Messaging\n          \n          \n            \n             * Interface marking components capable of registering a {@link ReactiveMessageDispatchInterceptor}. Generally, these are messaging", "author": "smcvb", "createdAt": "2020-04-06T14:35:09Z", "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import org.axonframework.common.Registration;\n+\n+/**\n+ * Interface marking components capable of registering Reactive Dispatch Interceptors. Generally, these are Messaging", "originalCommit": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java b/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java\ndeleted file mode 100644\nindex 6933ff479..000000000\n--- a/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java\n+++ /dev/null\n\n@@ -1,39 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.messaging;\n-\n-import org.axonframework.common.Registration;\n-\n-/**\n- * Interface marking components capable of registering Reactive Dispatch Interceptors. Generally, these are Messaging\n- * components injected into the sending end of the communication.\n- *\n- * @param <T>\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveMessageDispatchInterceptorSupport<T extends Message<?>> {\n-\n-    /**\n-     * Register the given Reactive Dispatch Interceptor. After registration, the interceptor will be invoked for each\n-     * Message dispatched on the messaging component that it was registered to.\n-     *\n-     * @param interceptor The reactive interceptor to register\n-     * @return a Registration, which may be used to remove the unregister the interceptor\n-     */\n-    Registration registerDispatchInterceptor(ReactiveMessageDispatchInterceptor<T> interceptor);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0MTUyMw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404141523", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Register the given Reactive Dispatch Interceptor. After registration, the interceptor will be invoked for each\n          \n          \n            \n                 * Message dispatched on the messaging component that it was registered to.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param interceptor The reactive interceptor to register\n          \n          \n            \n                 * @return a Registration, which may be used to remove the unregister the interceptor\n          \n          \n            \n                 * Register the given {@link ReactiveMessageDispatchInterceptor}. After registration, the interceptor will be invoked for each\n          \n          \n            \n                 * message dispatched on the messaging component that it was registered to.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param interceptor The reactive interceptor to register\n          \n          \n            \n                 * @return a Registration, which may be used to unregister the interceptor", "author": "smcvb", "createdAt": "2020-04-06T14:35:58Z", "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import org.axonframework.common.Registration;\n+\n+/**\n+ * Interface marking components capable of registering Reactive Dispatch Interceptors. Generally, these are Messaging\n+ * components injected into the sending end of the communication.\n+ *\n+ * @param <T>\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptorSupport<T extends Message<?>> {\n+\n+    /**\n+     * Register the given Reactive Dispatch Interceptor. After registration, the interceptor will be invoked for each\n+     * Message dispatched on the messaging component that it was registered to.\n+     *\n+     * @param interceptor The reactive interceptor to register\n+     * @return a Registration, which may be used to remove the unregister the interceptor", "originalCommit": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAwNjQ1MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r406006450", "bodyText": "essage? :O", "author": "m1l4n54v1c", "createdAt": "2020-04-09T07:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0MTUyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkzMDIyMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r407930221", "bodyText": "Whoops, that suggestion isn't entirely correct. Updated it just now.", "author": "smcvb", "createdAt": "2020-04-14T07:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0MTUyMw=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java b/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java\ndeleted file mode 100644\nindex 6933ff479..000000000\n--- a/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java\n+++ /dev/null\n\n@@ -1,39 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.messaging;\n-\n-import org.axonframework.common.Registration;\n-\n-/**\n- * Interface marking components capable of registering Reactive Dispatch Interceptors. Generally, these are Messaging\n- * components injected into the sending end of the communication.\n- *\n- * @param <T>\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactiveMessageDispatchInterceptorSupport<T extends Message<?>> {\n-\n-    /**\n-     * Register the given Reactive Dispatch Interceptor. After registration, the interceptor will be invoked for each\n-     * Message dispatched on the messaging component that it was registered to.\n-     *\n-     * @param interceptor The reactive interceptor to register\n-     * @return a Registration, which may be used to remove the unregister the interceptor\n-     */\n-    Registration registerDispatchInterceptor(ReactiveMessageDispatchInterceptor<T> interceptor);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NTExOQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404145119", "bodyText": "This change makes it so that the javadoc of the QueryBus#scatterGather method is no longer incorrect, as it states:\n\nIf no handlers are available to provide a result, or when all available handlers throw an exception while attempting to do so, the returned Stream is empty.\n\nWith these, exceptions are also reported. Sounds fine to me, but the documentation should be correct on the matter.", "author": "smcvb", "createdAt": "2020-04-06T14:40:38Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/SimpleQueryBus.java", "diffHunk": "@@ -198,16 +198,22 @@ private boolean unsubscribe(String queryName,\n                                    interceptAndInvoke(DefaultUnitOfWork.startAndGet(interceptedQuery),\n                                                       handler);\n                            QueryResponseMessage<R> response = null;\n+                           //noinspection unchecked", "originalCommit": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NzY5Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404147692", "bodyText": "Additionally, this change will make it so that users of the DefaultQueryGateway now experience IllegalPayloadAccessException when going through the stream of results.\nThis occurs because the GenericResultMessage#getPayload will throw this in case of an exception. Is that desired?", "author": "smcvb", "createdAt": "2020-04-06T14:44:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NTExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAxMTExNA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r406011114", "bodyText": "Good point! I propose to filter out exceptional results on the gateway. @abuijze what's your take on the bus change?", "author": "m1l4n54v1c", "createdAt": "2020-04-09T07:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NTExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyNDM4NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r406724384", "bodyText": "Had a discussion with Allard. The conclusion is not to report query handling errors of scatter-gather queries to the calling side. Rationale: scatter-gather is best effort query and it shouldn't care about errors like a simple query.", "author": "m1l4n54v1c", "createdAt": "2020-04-10T11:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NTExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkzMDM5Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r407930397", "bodyText": "Thanks for the clarification \ud83d\udc4d", "author": "smcvb", "createdAt": "2020-04-14T07:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NTExOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/SimpleQueryBus.java b/messaging/src/main/java/org/axonframework/queryhandling/SimpleQueryBus.java\nindex bd0f16e61..ae7e6fa8b 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/SimpleQueryBus.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/SimpleQueryBus.java\n\n@@ -198,14 +198,9 @@ private boolean unsubscribe(String queryName,\n                                    interceptAndInvoke(DefaultUnitOfWork.startAndGet(interceptedQuery),\n                                                       handler);\n                            QueryResponseMessage<R> response = null;\n-                           //noinspection unchecked\n-                           Class<R> responseType = (Class<R>) interceptedQuery.getResponseType()\n-                                                                              .getExpectedResponseType();\n                            if (resultMessage.isExceptional()) {\n                                monitorCallback.reportFailure(resultMessage.exceptionResult());\n                                errorHandler.onError(resultMessage.exceptionResult(), interceptedQuery, handler);\n-                               response = GenericQueryResponseMessage.asResponseMessage(responseType,\n-                                                                                        resultMessage.exceptionResult());\n                            } else {\n                                try {\n                                    response = resultMessage.getPayload().get(leftTimeout, TimeUnit.MILLISECONDS);\n"}}, {"oid": "3020030bdbf6e5bf940f50a404b3bf8f84b8ac07", "url": "https://github.com/AxonFramework/AxonFramework/commit/3020030bdbf6e5bf940f50a404b3bf8f84b8ac07", "message": "Added Flux<Result> dispatch(Publisher<?> data) to reactive gateways.", "committedDate": "2020-04-09T07:21:56Z", "type": "commit"}, {"oid": "5a100cbfea9f16409bec9ca7a4ecb730f74c4fd0", "url": "https://github.com/AxonFramework/AxonFramework/commit/5a100cbfea9f16409bec9ca7a4ecb730f74c4fd0", "message": "Update messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-04-09T07:24:07Z", "type": "commit"}, {"oid": "3f86798e78dc96b2ee2d844411e786300d3e5144", "url": "https://github.com/AxonFramework/AxonFramework/commit/3f86798e78dc96b2ee2d844411e786300d3e5144", "message": "Merge remote-tracking branch 'origin/reactive-gateways' into reactive-gateways", "committedDate": "2020-04-09T07:36:30Z", "type": "commit"}, {"oid": "fed248c8e117f0334af95f899d86d3007752c065", "url": "https://github.com/AxonFramework/AxonFramework/commit/fed248c8e117f0334af95f899d86d3007752c065", "message": "Rolled back error reporting for scatter-gather queries.", "committedDate": "2020-04-10T11:52:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkzODE0Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r407938147", "bodyText": "At this stage, it's still zero because the Flux/Publisher hasn't begun publishing yet, right? That only starts as soon as you push the result through the StepVerifier(?).", "author": "smcvb", "createdAt": "2020-04-14T07:56:50Z", "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.AsynchronousCommandBus;\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ */\n+class DefaultReactiveCommandGatewayTest {\n+\n+    private DefaultReactiveCommandGateway reactiveCommandGateway;\n+    private MessageHandler<CommandMessage<?>> commandMessageHandler;\n+    private RetryScheduler mockRetryScheduler;\n+\n+    @BeforeEach\n+    void setUp() {\n+        CommandBus commandBus = AsynchronousCommandBus.builder().build();\n+        mockRetryScheduler = mock(RetryScheduler.class);\n+        commandMessageHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+\n+            private final AtomicInteger count = new AtomicInteger();\n+\n+            @Override\n+            public Object handle(CommandMessage<?> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        commandBus.subscribe(String.class.getName(), commandMessageHandler);\n+        commandBus.subscribe(Integer.class.getName(), message -> {\n+            throw new RuntimeException();\n+        });\n+        commandBus.subscribe(Boolean.class.getName(),\n+                             message -> \"\" + message.getMetaData().getOrDefault(\"key1\", \"\")\n+                                     + message.getMetaData().getOrDefault(\"key2\", \"\"));\n+        reactiveCommandGateway = DefaultReactiveCommandGateway.builder()\n+                                                              .commandBus(commandBus)\n+                                                              .retryScheduler(mockRetryScheduler)\n+                                                              .build();\n+    }\n+\n+    @Test\n+    void testSend() throws Exception {\n+        Mono<String> result = reactiveCommandGateway.send(\"command\");\n+        verifyZeroInteractions(commandMessageHandler);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        verify(commandMessageHandler).handle(any());\n+        verifyZeroInteractions(mockRetryScheduler);\n+    }\n+\n+    @Test\n+    void testSendAll() throws Exception {\n+        Flux<Object> commands = Flux.fromIterable(Arrays.asList(\"command1\", 4, \"command2\", 5, true));\n+\n+        Flux<Object> result = reactiveCommandGateway.sendAll(commands);\n+        verifyZeroInteractions(commandMessageHandler);", "originalCommit": "fed248c8e117f0334af95f899d86d3007752c065", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5Mzk5OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r415693999", "bodyText": "As soon as you subscribe, not before. That's what we're testing here - laziness.", "author": "m1l4n54v1c", "createdAt": "2020-04-27T10:25:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkzODE0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java b/messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java\ndeleted file mode 100644\nindex 148e6a134..000000000\n--- a/messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java\n+++ /dev/null\n\n@@ -1,168 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.commandhandling.gateway;\n-\n-import org.axonframework.commandhandling.AsynchronousCommandBus;\n-import org.axonframework.commandhandling.CommandBus;\n-import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.common.Registration;\n-import org.axonframework.messaging.MessageHandler;\n-import org.junit.jupiter.api.*;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.test.StepVerifier;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.stream.IntStream;\n-\n-import static java.util.stream.Collectors.toList;\n-import static org.junit.jupiter.api.Assertions.*;\n-import static org.mockito.Mockito.*;\n-\n-/**\n- * Tests for {@link ReactiveCommandGateway}.\n- *\n- * @author Milan Savic\n- */\n-class DefaultReactiveCommandGatewayTest {\n-\n-    private DefaultReactiveCommandGateway reactiveCommandGateway;\n-    private MessageHandler<CommandMessage<?>> commandMessageHandler;\n-    private RetryScheduler mockRetryScheduler;\n-\n-    @BeforeEach\n-    void setUp() {\n-        CommandBus commandBus = AsynchronousCommandBus.builder().build();\n-        mockRetryScheduler = mock(RetryScheduler.class);\n-        commandMessageHandler = spy(new MessageHandler<CommandMessage<?>>() {\n-\n-            private final AtomicInteger count = new AtomicInteger();\n-\n-            @Override\n-            public Object handle(CommandMessage<?> message) {\n-                if (\"backpressure\".equals(message.getPayload())) {\n-                    return count.incrementAndGet();\n-                }\n-                return \"handled\";\n-            }\n-        });\n-        commandBus.subscribe(String.class.getName(), commandMessageHandler);\n-        commandBus.subscribe(Integer.class.getName(), message -> {\n-            throw new RuntimeException();\n-        });\n-        commandBus.subscribe(Boolean.class.getName(),\n-                             message -> \"\" + message.getMetaData().getOrDefault(\"key1\", \"\")\n-                                     + message.getMetaData().getOrDefault(\"key2\", \"\"));\n-        reactiveCommandGateway = DefaultReactiveCommandGateway.builder()\n-                                                              .commandBus(commandBus)\n-                                                              .retryScheduler(mockRetryScheduler)\n-                                                              .build();\n-    }\n-\n-    @Test\n-    void testSend() throws Exception {\n-        Mono<String> result = reactiveCommandGateway.send(\"command\");\n-        verifyZeroInteractions(commandMessageHandler);\n-        StepVerifier.create(result)\n-                    .expectNext(\"handled\")\n-                    .verifyComplete();\n-        verify(commandMessageHandler).handle(any());\n-        verifyZeroInteractions(mockRetryScheduler);\n-    }\n-\n-    @Test\n-    void testSendAll() throws Exception {\n-        Flux<Object> commands = Flux.fromIterable(Arrays.asList(\"command1\", 4, \"command2\", 5, true));\n-\n-        Flux<Object> result = reactiveCommandGateway.sendAll(commands);\n-        verifyZeroInteractions(commandMessageHandler);\n-\n-        List<Throwable> exceptions = new ArrayList<>(2);\n-        StepVerifier.create(result.onErrorContinue((t, o) -> exceptions.add(t)))\n-                    .expectNext(\"handled\", \"handled\", \"\")\n-                    .verifyComplete();\n-\n-        assertEquals(2, exceptions.size());\n-        assertTrue(exceptions.get(0) instanceof RuntimeException);\n-        assertTrue(exceptions.get(1) instanceof RuntimeException);\n-        verify(commandMessageHandler, times(2)).handle(any());\n-    }\n-\n-    @Test\n-    void testSendAllOrdering() throws Exception {\n-        int numberOfCommands = 10_000;\n-        Flux<String> commands = Flux.fromStream(IntStream.range(0, numberOfCommands)\n-                                                         .mapToObj(i -> \"backpressure\"));\n-        List<Integer> expectedResults = IntStream.range(1, numberOfCommands + 1)\n-                                                 .boxed()\n-                                                 .collect(toList());\n-        Flux<Object> result = reactiveCommandGateway.sendAll(commands);\n-        StepVerifier.create(result)\n-                    .expectNext(expectedResults.toArray(new Integer[0]))\n-                    .verifyComplete();\n-        verify(commandMessageHandler, times(numberOfCommands)).handle(any());\n-    }\n-\n-    @Test\n-    void testSendFails() {\n-        StepVerifier.create(reactiveCommandGateway.send(5))\n-                    .verifyError(RuntimeException.class);\n-        verify(mockRetryScheduler).scheduleRetry(any(), any(), anyList(), any());\n-    }\n-\n-    @Test\n-    void testSendWithDispatchInterceptor() {\n-        reactiveCommandGateway\n-                .registerDispatchInterceptor(() -> cmdMono -> cmdMono\n-                        .map(cmd -> cmd.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n-        Registration registration2 = reactiveCommandGateway\n-                .registerDispatchInterceptor(() -> cmdMono -> cmdMono\n-                        .map(cmd -> cmd.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n-\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .expectNext(\"value1value2\")\n-                    .verifyComplete();\n-\n-        registration2.cancel();\n-\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .expectNext(\"value1\")\n-                    .verifyComplete();\n-    }\n-\n-    @Test\n-    void testDispatchInterceptorThrowingAnException() {\n-        reactiveCommandGateway\n-                .registerDispatchInterceptor(() -> cmdMono -> {\n-                    throw new RuntimeException();\n-                });\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .verifyError(RuntimeException.class);\n-    }\n-\n-    @Test\n-    void testDispatchInterceptorReturningErrorMono() {\n-        reactiveCommandGateway\n-                .registerDispatchInterceptor(() -> cmdMono -> Mono.error(new RuntimeException()));\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .verifyError(RuntimeException.class);\n-    }\n-}\n"}}, {"oid": "458600ec7c51f894a998d38906b60087fe1ccc7a", "url": "https://github.com/AxonFramework/AxonFramework/commit/458600ec7c51f894a998d38906b60087fe1ccc7a", "message": "Merge remote-tracking branch 'origin/master' into reactive-gateways", "committedDate": "2020-04-17T20:45:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NzAyOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413687028", "bodyText": "Is this the DefaultReactiveCommandGateway or a ReactorReactiveCommandGateway? The implementation \"assumption\" this makes, is that you use Project Reactor, right?", "author": "abuijze", "createdAt": "2020-04-23T10:07:33Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of the {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactiveCommandGateway implements ReactiveCommandGateway {", "originalCommit": "458600ec7c51f894a998d38906b60087fe1ccc7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NzI4OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413687289", "bodyText": "That's also something that's worth mentioning in the class level Javadoc", "author": "abuijze", "createdAt": "2020-04-23T10:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NzAyOA=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java\ndeleted file mode 100644\nindex ccae733d9..000000000\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java\n+++ /dev/null\n\n@@ -1,201 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.commandhandling.gateway;\n-\n-import org.axonframework.commandhandling.CommandBus;\n-import org.axonframework.commandhandling.CommandCallback;\n-import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.commandhandling.GenericCommandMessage;\n-import org.axonframework.common.AxonConfigurationException;\n-import org.axonframework.common.Registration;\n-import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.List;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n-import static java.util.Arrays.asList;\n-import static org.axonframework.common.BuilderUtils.assertNonNull;\n-\n-/**\n- * Default implementation of the {@link ReactiveCommandGateway}.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public class DefaultReactiveCommandGateway implements ReactiveCommandGateway {\n-\n-    private final CommandBus commandBus;\n-    private final RetryScheduler retryScheduler;\n-    private final List<ReactiveMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n-\n-    /**\n-     * Creates an instance of {@link DefaultReactiveCommandGateway} based on the fields contained in the {@link\n-     * Builder}.\n-     * <p>\n-     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n-     * it is.\n-     * </p>\n-     *\n-     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactiveCommandGateway} instance\n-     */\n-    protected DefaultReactiveCommandGateway(Builder builder) {\n-        builder.validate();\n-        this.commandBus = builder.commandBus;\n-        this.retryScheduler = builder.retryScheduler;\n-        this.dispatchInterceptors = builder.dispatchInterceptors;\n-    }\n-\n-    /**\n-     * Instantiate a Builder to be able to create a {@link DefaultReactiveCommandGateway}.\n-     * <p>\n-     * The {@code dispatchInterceptors} are defaulted to an empty list.\n-     * The {@link CommandBus} is a <b>hard requirements</b> and as such should be provided.\n-     * </p>\n-     *\n-     * @return a Builder to be able to create a {@link DefaultReactiveCommandGateway}\n-     */\n-    public static Builder builder() {\n-        return new Builder();\n-    }\n-\n-    @Override\n-    public <R> Mono<R> send(Object command) {\n-        return processInterceptors(Mono.just(GenericCommandMessage.asCommandMessage(command)))\n-                .flatMap(commandMessage -> Mono.create(\n-                        sink -> {\n-                            CommandCallback<Object, R> commandCallback = (cm, result) -> {\n-                                try {\n-                                    if (result.isExceptional()) {\n-                                        sink.error(result.exceptionResult());\n-                                    } else {\n-                                        sink.success(result.getPayload());\n-                                    }\n-                                } catch (Exception e) {\n-                                    sink.error(e);\n-                                }\n-                            };\n-                            if (retryScheduler != null) {\n-                                commandCallback = new RetryingCallback<>(commandCallback, retryScheduler, commandBus);\n-                            }\n-                            commandBus.dispatch(commandMessage, commandCallback);\n-                        }));\n-    }\n-\n-    @Override\n-    public Registration registerDispatchInterceptor(ReactiveMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n-        dispatchInterceptors.add(interceptor);\n-        return () -> dispatchInterceptors.remove(interceptor);\n-    }\n-\n-    private Mono<CommandMessage<?>> processInterceptors(Mono<CommandMessage<?>> commandMessage) {\n-        Mono<CommandMessage<?>> message = commandMessage;\n-        for (ReactiveMessageDispatchInterceptor<CommandMessage<?>> dispatchInterceptor : dispatchInterceptors) {\n-            try {\n-                message = dispatchInterceptor.intercept(message);\n-            } catch (Throwable t) {\n-                return Mono.error(t);\n-            }\n-        }\n-        return message;\n-    }\n-\n-    /**\n-     * Builder class to instantiate {@link DefaultReactiveCommandGateway}.\n-     * <p>\n-     * The {@code dispatchInterceptors} are defaulted to an empty list.\n-     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n-     * </p>\n-     */\n-    public static class Builder {\n-\n-        private CommandBus commandBus;\n-        private RetryScheduler retryScheduler;\n-        private List<ReactiveMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors = new CopyOnWriteArrayList<>();\n-\n-        /**\n-         * Sets the {@link CommandBus} used to dispatch commands.\n-         *\n-         * @param commandBus a {@link CommandBus} used to dispatch commands\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder commandBus(CommandBus commandBus) {\n-            assertNonNull(commandBus, \"CommandBus may not be null\");\n-            this.commandBus = commandBus;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the {@link RetryScheduler} capable of performing retries of failed commands. May be {@code null} when\n-         * to prevent retries.\n-         *\n-         * @param retryScheduler a {@link RetryScheduler} capable of performing retries of failed commands\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder retryScheduler(RetryScheduler retryScheduler) {\n-            this.retryScheduler = retryScheduler;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the {@link List} of {@link ReactiveMessageDispatchInterceptor}s for {@link CommandMessage}s. Are invoked\n-         * when a command is being dispatched.\n-         *\n-         * @param dispatchInterceptors which are invoked when a command is being dispatched\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        @SafeVarargs\n-        public final Builder dispatchInterceptors(\n-                ReactiveMessageDispatchInterceptor<CommandMessage<?>>... dispatchInterceptors) {\n-            return dispatchInterceptors(asList(dispatchInterceptors));\n-        }\n-\n-        /**\n-         * Sets the {@link List} of {@link ReactiveMessageDispatchInterceptor}s for {@link CommandMessage}s. Are invoked\n-         * when a command is being dispatched.\n-         *\n-         * @param dispatchInterceptors which are invoked when a command is being dispatched\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder dispatchInterceptors(\n-                List<ReactiveMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors) {\n-            this.dispatchInterceptors = dispatchInterceptors != null && dispatchInterceptors.isEmpty()\n-                    ? new CopyOnWriteArrayList<>(dispatchInterceptors)\n-                    : new CopyOnWriteArrayList<>();\n-            return this;\n-        }\n-\n-        /**\n-         * Validate whether the fields contained in this Builder as set accordingly.\n-         *\n-         * @throws AxonConfigurationException if one field is asserted to be incorrect according to the Builder's\n-         *                                    specifications\n-         */\n-        protected void validate() {\n-            assertNonNull(commandBus, \"The CommandBus is a hard requirement and should be provided\");\n-        }\n-\n-        /**\n-         * Initializes a {@link DefaultReactiveCommandGateway} as specified through this Builder.\n-         *\n-         * @return a {@link DefaultReactiveCommandGateway} as specified through this Builder\n-         */\n-        public DefaultReactiveCommandGateway build() {\n-            return new DefaultReactiveCommandGateway(this);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4OTkwMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413689901", "bodyText": "Please also have it implement MessageDispatchInterceptorSupport. Preferably, I'd like the Reactive implementations to show more compatibility by extending the MessageDispatchInterceptorSupport. The reactive impl could do an instanceof check to see if implementations are already reactive. If not, it could wrap them with a reactive wrapper implementation.", "author": "abuijze", "createdAt": "2020-04-23T10:11:55Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MetaData;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveCommandGateway extends ReactiveMessageDispatchInterceptorSupport<CommandMessage<?>> {", "originalCommit": "458600ec7c51f894a998d38906b60087fe1ccc7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java\nsimilarity index 84%\nrename from messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java\nrename to messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java\nindex 7c0c72b96..92427346b 100644\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java\n+++ b/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java\n\n@@ -18,9 +18,11 @@\n \n import org.axonframework.commandhandling.CommandBus;\n import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n import org.axonframework.messaging.Message;\n import org.axonframework.messaging.MetaData;\n-import org.axonframework.messaging.ReactiveMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n import org.reactivestreams.Publisher;\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5MDkxNQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413690915", "bodyText": "Why does it need to be a Supplier of a Function, and not just the Function itself?", "author": "abuijze", "createdAt": "2020-04-23T10:13:27Z", "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n+ * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+@FunctionalInterface\n+public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {", "originalCommit": "458600ec7c51f894a998d38906b60087fe1ccc7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\nsimilarity index 57%\nrename from messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java\nrename to messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\nindex cafa5c4a7..52dedc7c3 100644\n--- a/messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java\n+++ b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\n\n@@ -14,32 +14,39 @@\n  * limitations under the License.\n  */\n \n-package org.axonframework.messaging;\n+package org.axonframework.messaging.reactive;\n \n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n import reactor.core.publisher.Mono;\n \n-import java.util.function.Function;\n-import java.util.function.Supplier;\n+import java.util.List;\n+import java.util.function.BiFunction;\n \n /**\n  * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n  * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n- * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting messages.\n+ * be passed down the interceptor chain or to be dispatched.\n  *\n- * @param <T> the message type this interceptor can process\n+ * @param <M> the message type this interceptor can process\n  * @author Milan Savic\n  * @since 4.4\n  */\n @FunctionalInterface\n-public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+public interface ReactorMessageDispatchInterceptor<M extends Message<?>> extends\n+        MessageDispatchInterceptor<M> {\n \n     /**\n-     * Intercepts a message.\n+     * Intercepts a message. It's possible to break the interceptor chain by returning {@link Mono#empty()} or {@link\n+     * Mono#error(Throwable)} variations.\n      *\n      * @param message a {@link Mono} of a message to be intercepted\n      * @return the message {@link Mono} to dispatch\n      */\n-    default Mono<T> intercept(Mono<T> message) {\n-        return get().apply(message);\n+    Mono<M> intercept(Mono<M> message);\n+\n+    @Override\n+    default BiFunction<Integer, M, M> handle(List<? extends M> messages) {\n+        return (position, message) -> intercept(Mono.just(message)).block();\n     }\n }\n"}}, {"oid": "7f459636344b73ed8abc6abe001ad00e56bec648", "url": "https://github.com/AxonFramework/AxonFramework/commit/7f459636344b73ed8abc6abe001ad00e56bec648", "message": "Merge branch 'master' into reactive-gateways", "committedDate": "2020-04-27T10:09:36Z", "type": "commit"}, {"oid": "e6b06990aac973cb69ccbced6027101bc383b4db", "url": "https://github.com/AxonFramework/AxonFramework/commit/e6b06990aac973cb69ccbced6027101bc383b4db", "message": "Update messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-04-27T10:22:59Z", "type": "commit"}, {"oid": "e643ca6834cb7ccc9aa6bc3b5a3d52844da17ebd", "url": "https://github.com/AxonFramework/AxonFramework/commit/e643ca6834cb7ccc9aa6bc3b5a3d52844da17ebd", "message": "Merge remote-tracking branch 'origin/reactive-gateways' into reactive-gateways", "committedDate": "2020-04-27T10:30:52Z", "type": "commit"}, {"oid": "344d60e342ea50d792092f7c1ee148c719f3f9bf", "url": "https://github.com/AxonFramework/AxonFramework/commit/344d60e342ea50d792092f7c1ee148c719f3f9bf", "message": "Renamed DefaultReactiveGateways to ReactorGateways.", "committedDate": "2020-04-27T11:36:31Z", "type": "commit"}, {"oid": "775aaaeda23e86c844b10afb84f1903964f8a37a", "url": "https://github.com/AxonFramework/AxonFramework/commit/775aaaeda23e86c844b10afb84f1903964f8a37a", "message": "Reactive publisher callback", "committedDate": "2020-05-22T15:54:18Z", "type": "commit"}, {"oid": "899aace41640212b7ae5df13a3f54971aa047107", "url": "https://github.com/AxonFramework/AxonFramework/commit/899aace41640212b7ae5df13a3f54971aa047107", "message": "Introduce new API for reactive interceptors.", "committedDate": "2020-05-25T10:51:47Z", "type": "commit"}, {"oid": "68e814e1659371bc50a2baa23da33fc64983603d", "url": "https://github.com/AxonFramework/AxonFramework/commit/68e814e1659371bc50a2baa23da33fc64983603d", "message": "First partial implementation for ReactorCommandGateway new API.", "committedDate": "2020-05-27T10:34:09Z", "type": "commit"}, {"oid": "b9da29b9c6ed669493331a468aa9ce6d0a17daf9", "url": "https://github.com/AxonFramework/AxonFramework/commit/b9da29b9c6ed669493331a468aa9ce6d0a17daf9", "message": "Reactive query implementation, few improvements and renaming's", "committedDate": "2020-05-27T16:09:19Z", "type": "commit"}, {"oid": "ec2e8ff341a2c5a3f107e001ff6468082846e6e6", "url": "https://github.com/AxonFramework/AxonFramework/commit/ec2e8ff341a2c5a3f107e001ff6468082846e6e6", "message": "Reactive scatter gather implementation", "committedDate": "2020-06-04T12:01:22Z", "type": "commit"}, {"oid": "b23bfb078148eca09942e726f55b512f038eab22", "url": "https://github.com/AxonFramework/AxonFramework/commit/b23bfb078148eca09942e726f55b512f038eab22", "message": "Reactive Gateways - subscription queries, clean up, tests", "committedDate": "2020-06-12T12:14:49Z", "type": "commit"}, {"oid": "71aa01c568702d0d68fbcdc9afbdb07e628d10cd", "url": "https://github.com/AxonFramework/AxonFramework/commit/71aa01c568702d0d68fbcdc9afbdb07e628d10cd", "message": "Remove system.out", "committedDate": "2020-06-12T12:28:15Z", "type": "commit"}, {"oid": "1a196932f6cde9f0bee19b8609d5edb93937162b", "url": "https://github.com/AxonFramework/AxonFramework/commit/1a196932f6cde9f0bee19b8609d5edb93937162b", "message": "Adjusted GenericSubscriptionQueryUpdateMessage to implement ResultMessage.", "committedDate": "2020-06-15T09:43:29Z", "type": "commit"}, {"oid": "a659f518ce181f9cb959506778752a0902c919a9", "url": "https://github.com/AxonFramework/AxonFramework/commit/a659f518ce181f9cb959506778752a0902c919a9", "message": "Merge branch 'master' into reactive-gateways", "committedDate": "2020-06-15T09:44:39Z", "type": "commit"}, {"oid": "64817afe5233f7790aa5e0483dd92f5f41d6635d", "url": "https://github.com/AxonFramework/AxonFramework/commit/64817afe5233f7790aa5e0483dd92f5f41d6635d", "message": "Renamed Reactive to Reactor Gateways.", "committedDate": "2020-06-15T10:29:48Z", "type": "commit"}, {"oid": "fdcbac0aacd4ca6621e06af194ca4c0055c8d667", "url": "https://github.com/AxonFramework/AxonFramework/commit/fdcbac0aacd4ca6621e06af194ca4c0055c8d667", "message": "Reactor Command Gateway Tests", "committedDate": "2020-06-18T14:45:27Z", "type": "commit"}, {"oid": "9eb35bde4737bcf2828b77fb48655350fa0b23a1", "url": "https://github.com/AxonFramework/AxonFramework/commit/9eb35bde4737bcf2828b77fb48655350fa0b23a1", "message": "Renamed Reactive Interceptors to Reactor Interceptors.", "committedDate": "2020-06-22T09:08:58Z", "type": "commit"}, {"oid": "2c783a51ce37bc1259c27997024dc90c906c8a58", "url": "https://github.com/AxonFramework/AxonFramework/commit/2c783a51ce37bc1259c27997024dc90c906c8a58", "message": "Enhanced ReactorQueryGateway API.", "committedDate": "2020-06-22T09:30:56Z", "type": "commit"}, {"oid": "d747ba0b44c2006beac72a7faae3a3dc5cd56183", "url": "https://github.com/AxonFramework/AxonFramework/commit/d747ba0b44c2006beac72a7faae3a3dc5cd56183", "message": "Added support to GrpcBackedQueryUpdateMessage for errors.", "committedDate": "2020-06-23T15:29:48Z", "type": "commit"}, {"oid": "4208bd41187caca66f6422eb8280f014716f1a6f", "url": "https://github.com/AxonFramework/AxonFramework/commit/4208bd41187caca66f6422eb8280f014716f1a6f", "message": "Solve case when command handler is void type or returns null", "committedDate": "2020-06-23T15:29:53Z", "type": "commit"}, {"oid": "dbe26de15a85ee168bfbf9232adcd939f53a9cca", "url": "https://github.com/AxonFramework/AxonFramework/commit/dbe26de15a85ee168bfbf9232adcd939f53a9cca", "message": "Merge branch 'reactive-gateways' of github.com:AxonFramework/AxonFramework into reactive-gateways", "committedDate": "2020-06-23T15:31:06Z", "type": "commit"}, {"oid": "127c01e78625dfc62bd199aa17bc34bab2b4acf0", "url": "https://github.com/AxonFramework/AxonFramework/commit/127c01e78625dfc62bd199aa17bc34bab2b4acf0", "message": "Merge branch 'master' into reactive-gateways", "committedDate": "2020-06-23T15:34:02Z", "type": "commit"}, {"oid": "440176753605f7e0dd5da749335c96de71bebc2d", "url": "https://github.com/AxonFramework/AxonFramework/commit/440176753605f7e0dd5da749335c96de71bebc2d", "message": "removed unnecessary code. we already map to error in reactive callback", "committedDate": "2020-06-23T15:42:12Z", "type": "commit"}, {"oid": "570a1c6bc56a5f72077b2450ee6ecfe370334844", "url": "https://github.com/AxonFramework/AxonFramework/commit/570a1c6bc56a5f72077b2450ee6ecfe370334844", "message": "Removed additional reactor-core dep.\nFormatted ReactiveCallbackTest.", "committedDate": "2020-06-24T11:34:33Z", "type": "commit"}, {"oid": "edb8263633031512b43ebcf5dc47b4c65ffebbd6", "url": "https://github.com/AxonFramework/AxonFramework/commit/edb8263633031512b43ebcf5dc47b4c65ffebbd6", "message": "Merge remote-tracking branch 'origin/reactive-gateways' into reactive-gateways", "committedDate": "2020-06-24T11:34:58Z", "type": "commit"}, {"oid": "c047ece2cd069f4189247f83bc94536a606a05d3", "url": "https://github.com/AxonFramework/AxonFramework/commit/c047ece2cd069f4189247f83bc94536a606a05d3", "message": "Increased Project Reactor version.", "committedDate": "2020-06-29T06:54:22Z", "type": "commit"}, {"oid": "56966d4168fde1fff0307269ffe91c05259df0cd", "url": "https://github.com/AxonFramework/AxonFramework/commit/56966d4168fde1fff0307269ffe91c05259df0cd", "message": "Merge branch 'master' into reactive-gateways", "committedDate": "2020-06-29T06:55:21Z", "type": "commit"}, {"oid": "fb5618a60243784657fce38c376d4c62f3b5abd4", "url": "https://github.com/AxonFramework/AxonFramework/commit/fb5618a60243784657fce38c376d4c62f3b5abd4", "message": "Detect context loss & security context filters tests", "committedDate": "2020-06-29T09:11:11Z", "type": "commit"}, {"oid": "e6882dbe07c5b3785702364d7a67bb41ad563d10", "url": "https://github.com/AxonFramework/AxonFramework/commit/e6882dbe07c5b3785702364d7a67bb41ad563d10", "message": "Merge branch 'master' into reactive-gateways", "committedDate": "2020-06-29T12:33:58Z", "type": "commit"}, {"oid": "586775639f2cf646664779c47f6add110b3334b4", "url": "https://github.com/AxonFramework/AxonFramework/commit/586775639f2cf646664779c47f6add110b3334b4", "message": "Merge remote-tracking branch 'origin/reactive-gateways' into reactive-gateways", "committedDate": "2020-06-29T12:34:40Z", "type": "commit"}, {"oid": "e7da852c0adbaeb8abc3ee419f54f2ce31cb820c", "url": "https://github.com/AxonFramework/AxonFramework/commit/e7da852c0adbaeb8abc3ee419f54f2ce31cb820c", "message": "Added tests for queryUpdates and subscriptionQueryMany methods.\nAdded tests for ReactorMessageDispatchInterceptor default method.\nFixed Sonar issues.", "committedDate": "2020-06-30T07:49:14Z", "type": "commit"}, {"oid": "a90cc9c1f9184218c8667ac796367d0b55730bc5", "url": "https://github.com/AxonFramework/AxonFramework/commit/a90cc9c1f9184218c8667ac796367d0b55730bc5", "message": "Added tests for GenericSubscriptionQueryUpdateMessage.", "committedDate": "2020-06-30T09:38:32Z", "type": "commit"}, {"oid": "eec6bd0db95448564114ec9a451770b6827855c3", "url": "https://github.com/AxonFramework/AxonFramework/commit/eec6bd0db95448564114ec9a451770b6827855c3", "message": "Added tests for exceptional cases in SubscriptionMessageSerializerTest.", "committedDate": "2020-06-30T10:19:27Z", "type": "commit"}, {"oid": "0f81708cdc145726b9a836c4b08462c3720103d1", "url": "https://github.com/AxonFramework/AxonFramework/commit/0f81708cdc145726b9a836c4b08462c3720103d1", "message": "Added ReactorEventGateway.", "committedDate": "2020-06-30T16:11:21Z", "type": "commit"}, {"oid": "f1e5788b49252c33d6af8d7f82fd5e4de4699bc9", "url": "https://github.com/AxonFramework/AxonFramework/commit/f1e5788b49252c33d6af8d7f82fd5e4de4699bc9", "message": "Removed wildcards from generics as return type of ReactorEventGateway methods.", "committedDate": "2020-07-01T07:48:17Z", "type": "commit"}, {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "url": "https://github.com/AxonFramework/AxonFramework/commit/98865ab1427e4d879301c1bf542842eccc8aa3c3", "message": "Removed blocking publishing of event message.", "committedDate": "2020-07-01T10:08:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MjA3MQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452682071", "bodyText": "Nit: details sounds a little vague here if you ask me.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Supplier<Object> details = serializedPayload == null\n          \n          \n            \n                    Supplier<Object> exceptionDetails = serializedPayload == null", "author": "smcvb", "createdAt": "2020-07-10T07:52:10Z", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java", "diffHunk": "@@ -49,18 +53,27 @@\n      *                    given {@code queryUpdate}\n      */\n     public GrpcBackedQueryUpdateMessage(QueryUpdate queryUpdate, Serializer serializer) {\n-        this(\n-                queryUpdate,\n-                new LazyDeserializingObject<>(new GrpcSerializedObject(queryUpdate.getPayload()), serializer),\n-                new GrpcMetaData(queryUpdate.getMetaDataMap(), serializer)\n-        );\n+        this.queryUpdate = queryUpdate;\n+        this.serializedPayload = queryUpdate.hasPayload()\n+                ? new LazyDeserializingObject<>(new GrpcSerializedObject(queryUpdate.getPayload()), serializer)\n+                : null;\n+        Supplier<Object> details = serializedPayload == null", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java\nindex 106f7d6b0..ddf1c1074 100644\n--- a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java\n+++ b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java\n\n@@ -57,7 +57,7 @@ public GrpcBackedQueryUpdateMessage(QueryUpdate queryUpdate, Serializer serializ\n         this.serializedPayload = queryUpdate.hasPayload()\n                 ? new LazyDeserializingObject<>(new GrpcSerializedObject(queryUpdate.getPayload()), serializer)\n                 : null;\n-        Supplier<Object> details = serializedPayload == null\n+        Supplier<Object> exceptionDetails = serializedPayload == null\n                 ? () -> null\n                 : serializedPayload::getObject;\n         this.exception = queryUpdate.hasErrorMessage()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452683252", "bodyText": "Super nit: indenting looks a little awful here if you ask me.", "author": "smcvb", "createdAt": "2020-07-10T07:54:33Z", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java", "diffHunk": "@@ -116,19 +118,28 @@ public SubscriptionQuery serialize(SubscriptionQueryMessage subscriptionQueryMes\n         return new GrpcBackedSubscriptionQueryMessage<>(subscriptionQuery, messageSerializer, serializer);\n     }\n \n-    QueryProviderOutbound serialize(QueryResponseMessage initialResult, String subscriptionId) {\n-        QueryResponse queryResponse =\n+    QueryProviderOutbound serialize(QueryResponseMessage<?> initialResult, String subscriptionId) {\n+        QueryResponse.Builder responseBuilder =\n                 QueryResponse.newBuilder()\n-                             .setPayload(payloadSerializer.apply(initialResult))\n                              .putAllMetaData(metadataSerializer.apply(initialResult.getMetaData()))\n                              .setMessageIdentifier(initialResult.getIdentifier())\n-                             .setRequestIdentifier(subscriptionId)\n-                             .build();\n+                             .setRequestIdentifier(subscriptionId);\n+        if (initialResult.isExceptional()) {\n+            Throwable exceptionResult = initialResult.exceptionResult();\n+            responseBuilder.setErrorCode(ErrorCode.QUERY_EXECUTION_ERROR.errorCode());\n+            responseBuilder.setErrorMessage(ExceptionSerializer", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI2MjA5OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457262099", "bodyText": "Not sure what you mean by it :)", "author": "m1l4n54v1c", "createdAt": "2020-07-20T10:31:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI2MjMwMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457262301", "bodyText": "IntelliJ does not complain...", "author": "m1l4n54v1c", "createdAt": "2020-07-20T10:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA1Nzk5MQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458057991", "bodyText": "Intellij might not, but my eyes do when I see this:\nresponseBuilder.setErrorMessage(ExceptionSerializer\n                                        .serialize(configuration.getClientId(), exceptionResult));\nwhich I would rewrite to\nresponseBuilder.setErrorMessage(\n    ExceptionSerializer.serialize(configuration.getClientId(), exceptionResult)\n);\nHence why it is a super nit.", "author": "smcvb", "createdAt": "2020-07-21T12:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA1OTg2NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458059864", "bodyText": "Let me just provide a suggestion instead of a comment.", "author": "smcvb", "createdAt": "2020-07-21T12:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA2NTU1OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458065558", "bodyText": "responseBuilder.setErrorMessage(\n                ExceptionSerializer.serialize(configuration.getClientId(), exceptionResult)\n            );\n            initialResult.exceptionDetails()\n                         .ifPresent(details -> responseBuilder.setPayload(exceptionDetailsSerializer.apply(details)));", "author": "smcvb", "createdAt": "2020-07-21T12:42:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc4MzQ3MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460783470", "bodyText": "I'm gonna do it this way!", "author": "m1l4n54v1c", "createdAt": "2020-07-27T10:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9d2da7ff7507791063c95d39681098c708145c94", "chunk": "diff --git a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java\nindex 1fd0593cd..268f94f6f 100644\n--- a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java\n+++ b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java\n\n@@ -127,11 +127,11 @@ QueryProviderOutbound serialize(QueryResponseMessage<?> initialResult, String su\n         if (initialResult.isExceptional()) {\n             Throwable exceptionResult = initialResult.exceptionResult();\n             responseBuilder.setErrorCode(ErrorCode.QUERY_EXECUTION_ERROR.errorCode());\n-            responseBuilder.setErrorMessage(ExceptionSerializer\n-                                                    .serialize(configuration.getClientId(), exceptionResult));\n+            responseBuilder.setErrorMessage(\n+                    ExceptionSerializer.serialize(configuration.getClientId(), exceptionResult)\n+            );\n             initialResult.exceptionDetails()\n-                         .ifPresent(details -> responseBuilder\n-                                 .setPayload(exceptionDetailsSerializer.apply(details)));\n+                         .ifPresent(details -> responseBuilder.setPayload(exceptionDetailsSerializer.apply(details)));\n         } else {\n             responseBuilder.setPayload(payloadSerializer.apply(initialResult));\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452685557", "bodyText": "Nit: might be worth validating there is a null payload? If that's what we're going to tell our users, than making sure it is so sounds reasonable to me.", "author": "smcvb", "createdAt": "2020-07-10T07:58:44Z", "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "diffHunk": "@@ -76,12 +77,29 @@ void testInitialResponse() {\n         assertEquals(message.getMetaData(), deserialized.getMetaData());\n     }\n \n+    @Test\n+    void testExceptionalInitialResponse() {\n+        MetaData metadata = MetaData.with(\"firstKey\", \"firstValue\")\n+                                    .mergedWith(MetaData.with(\"secondKey\", \"secondValue\"));\n+        QueryResponseMessage<String> message = new GenericQueryResponseMessage<>(String.class,\n+                                                                                 new RuntimeException(\"oops\"),\n+                                                                                 metadata);\n+        QueryProviderOutbound grpcMessage = testSubject.serialize(message, \"subscriptionId\");\n+        assertEquals(\"subscriptionId\", grpcMessage.getSubscriptionQueryResponse().getSubscriptionIdentifier());\n+        QueryResponse initialResponse = grpcMessage.getSubscriptionQueryResponse().getInitialResult();\n+        QueryResponseMessage<Object> deserialized = testSubject.deserialize(initialResponse);\n+        assertEquals(message.getIdentifier(), deserialized.getIdentifier());\n+        assertEquals(message.getMetaData(), deserialized.getMetaData());", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NjU3MQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452686571", "bodyText": "You could similarly argue that validating the following for successful calls makes sense: assertFalse(message.isExceptional())", "author": "smcvb", "createdAt": "2020-07-10T08:00:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI2NTQzOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457265438", "bodyText": "Actually, .getPayload should throw an IllegalPayloadException in this case :) I'll validate that.", "author": "m1l4n54v1c", "createdAt": "2020-07-20T10:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5NDQ1OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457394459", "bodyText": "Hmmmm, you're actually right! But I'm not sure now whether we should throw an exception here or return null in an exceptional case. What's your take on it?", "author": "m1l4n54v1c", "createdAt": "2020-07-20T13:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA3NTAyNA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458075024", "bodyText": "To be a 100% honest with you, I am uncertain why I suggested this \ud83e\udd14\nMight be worth to have a short call about this when time allows it.", "author": "smcvb", "createdAt": "2020-07-21T12:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg4MTMwMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460881302", "bodyText": "After a discussion, we decided to address this concern in a separate issue: #1477", "author": "m1l4n54v1c", "createdAt": "2020-07-27T13:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NjAwNw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452686007", "bodyText": "Same asserrtNull(message.getPayload()) suggestions as for the testExceptionalInitialResponse().", "author": "smcvb", "createdAt": "2020-07-10T07:59:38Z", "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "diffHunk": "@@ -92,6 +110,21 @@ void testUpdate() {\n         assertEquals(message.getMetaData(), deserialized.getMetaData());\n     }\n \n+    @Test\n+    void testExceptionalUpdate() {\n+        MetaData metaData = MetaData.with(\"k1\", \"v1\");\n+        SubscriptionQueryUpdateMessage<String> message =\n+                new GenericSubscriptionQueryUpdateMessage<>(String.class, new RuntimeException(\"oops\"), metaData);\n+        QueryProviderOutbound grpcMessage = testSubject.serialize(message, \"subscriptionId\");\n+        assertEquals(\"subscriptionId\", grpcMessage.getSubscriptionQueryResponse().getSubscriptionIdentifier());\n+        QueryUpdate update = grpcMessage.getSubscriptionQueryResponse().getUpdate();\n+        SubscriptionQueryUpdateMessage<Object> deserialized = testSubject.deserialize(update);\n+        assertEquals(message.getIdentifier(), deserialized.getIdentifier());\n+        assertEquals(message.getMetaData(), deserialized.getMetaData());", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM3NzYwOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461377608", "bodyText": "Resolved verbally; this will be tackled in a different issue.", "author": "smcvb", "createdAt": "2020-07-28T07:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NjAwNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NzA3NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452687074", "bodyText": "Nits: I'd {@link ...} to CommandCallback and CommandBus here. Definitely no blocker though.", "author": "smcvb", "createdAt": "2020-07-10T08:01:45Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MTkwMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460791901", "bodyText": "Done!", "author": "m1l4n54v1c", "createdAt": "2020-07-27T10:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NzA3NA=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java b/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java\nsimilarity index 82%\nrename from messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java\nrename to messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java\nindex 223c02dfb..489cf92b2 100644\n--- a/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java\n+++ b/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java\n\n@@ -19,10 +19,10 @@\n import org.axonframework.commandhandling.CommandCallback;\n import org.axonframework.commandhandling.CommandMessage;\n import org.axonframework.commandhandling.CommandResultMessage;\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n+import reactor.core.CoreSubscriber;\n import reactor.core.publisher.EmitterProcessor;\n import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n \n /**\n  * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NzMzMA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452687330", "bodyText": "What's this suppression for? Worth adding a short comment on in the code why this is suppressed?", "author": "smcvb", "createdAt": "2020-07-10T08:02:12Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the\n+ * Project Reactor mechanisms. This callback allows the caller to synchronize calls when an asynchronous command bus is\n+ * being used.\n+ *\n+ * @author Stefan Dragisic\n+ * @since 4.4\n+ */\n+@SuppressWarnings(\"ReactiveStreamsPublisherImplementation\")", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY5NTcxOQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r453695719", "bodyText": "The warning is due to recommendation not to extend the Publisher class. Extending Mono instead to remove warning and ease the use of API", "author": "schananas", "createdAt": "2020-07-13T14:35:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NzMzMA=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java b/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java\nsimilarity index 82%\nrename from messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java\nrename to messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java\nindex 223c02dfb..489cf92b2 100644\n--- a/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java\n+++ b/messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java\n\n@@ -19,10 +19,10 @@\n import org.axonframework.commandhandling.CommandCallback;\n import org.axonframework.commandhandling.CommandMessage;\n import org.axonframework.commandhandling.CommandResultMessage;\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n+import reactor.core.CoreSubscriber;\n import reactor.core.publisher.EmitterProcessor;\n import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n \n /**\n  * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4OTQzOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452689438", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n          \n          \n            \n             * Variation of the {@link CommandGateway}, wrapping a {@link CommandBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} from Project", "author": "smcvb", "createdAt": "2020-07-10T08:06:37Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MetaData;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30ba00c255b5a867f13c792cd330dde0bb30cc9d", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java\ndeleted file mode 100644\nindex 92427346b..000000000\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java\n+++ /dev/null\n\n@@ -1,71 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.commandhandling.gateway;\n-\n-import org.axonframework.commandhandling.CommandBus;\n-import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.commandhandling.CommandResultMessage;\n-import org.axonframework.messaging.Message;\n-import org.axonframework.messaging.MetaData;\n-import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n-import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n-import org.reactivestreams.Publisher;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.function.Function;\n-\n-/**\n- * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n- * Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactorCommandGateway\n-        extends ReactorMessageDispatchInterceptorSupport<CommandMessage<?>>,\n-        ReactorResultHandlerInterceptorSupport<CommandMessage<?>, CommandResultMessage<?>> {\n-\n-    /**\n-     * Sends the given {@code command} once the caller subscribes to the command result. Returns immediately.\n-     * <p/>\n-     * The given {@code command} is wrapped as the payload of a {@link CommandMessage} that is eventually posted on the\n-     * {@link CommandBus}, unless the {@code command} already implements {@link Message}. In that case, a\n-     * {@code CommandMessage} is constructed from that message's payload and {@link MetaData}.\n-     *\n-     * @param command the command to dispatch\n-     * @param <R>     the type of the command result\n-     * @return a {@link Mono} which is resolved when the command is executed\n-     */\n-    <R> Mono<R> send(Object command);\n-\n-    /**\n-     * Uses given Publisher of commands to send incoming commands away. Commands will be sent sequentially - once a\n-     * result of Nth command arrives, (N + 1)th command is dispatched.\n-     *\n-     * @param commands a Publisher stream of commands to be dispatched\n-     * @return a Flux of command results. An ordering of command results corresponds to an ordering of commands being\n-     * dispatched\n-     *\n-     * @see #send(Object)\n-     * @see Flux#concatMap(Function)\n-     */\n-    default Flux<Object> sendAll(Publisher<?> commands) {\n-        return Flux.from(commands)\n-                   .concatMap(this::send);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MDU5OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452690598", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of commands to send incoming commands away. Commands will be sent sequentially - once a\n          \n          \n            \n                 * result of Nth command arrives, (N + 1)th command is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param commands a Publisher stream of commands to be dispatched\n          \n          \n            \n                 * @return a Flux of command results. An ordering of command results corresponds to an ordering of commands being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of commands to send incoming commands away. Commands will be sent sequentially. Once the\n          \n          \n            \n                 * result of the Nth command arrives, the (N + 1)th command is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param commands a {@link Publisher} stream of commands to be dispatched\n          \n          \n            \n                 * @return a {@link Flux} of command results. The ordering of command results corresponds to the ordering of commands being\n          \n          \n            \n                 * dispatched", "author": "smcvb", "createdAt": "2020-07-10T08:09:03Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MetaData;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorCommandGateway\n+        extends ReactorMessageDispatchInterceptorSupport<CommandMessage<?>>,\n+        ReactorResultHandlerInterceptorSupport<CommandMessage<?>, CommandResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code command} once the caller subscribes to the command result. Returns immediately.\n+     * <p/>\n+     * The given {@code command} is wrapped as the payload of a {@link CommandMessage} that is eventually posted on the\n+     * {@link CommandBus}, unless the {@code command} already implements {@link Message}. In that case, a\n+     * {@code CommandMessage} is constructed from that message's payload and {@link MetaData}.\n+     *\n+     * @param command the command to dispatch\n+     * @param <R>     the type of the command result\n+     * @return a {@link Mono} which is resolved when the command is executed\n+     */\n+    <R> Mono<R> send(Object command);\n+\n+    /**\n+     * Uses given Publisher of commands to send incoming commands away. Commands will be sent sequentially - once a\n+     * result of Nth command arrives, (N + 1)th command is dispatched.\n+     *\n+     * @param commands a Publisher stream of commands to be dispatched\n+     * @return a Flux of command results. An ordering of command results corresponds to an ordering of commands being\n+     * dispatched", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30ba00c255b5a867f13c792cd330dde0bb30cc9d", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java\ndeleted file mode 100644\nindex 92427346b..000000000\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java\n+++ /dev/null\n\n@@ -1,71 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.commandhandling.gateway;\n-\n-import org.axonframework.commandhandling.CommandBus;\n-import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.commandhandling.CommandResultMessage;\n-import org.axonframework.messaging.Message;\n-import org.axonframework.messaging.MetaData;\n-import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n-import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n-import org.reactivestreams.Publisher;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.function.Function;\n-\n-/**\n- * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n- * Reactor.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public interface ReactorCommandGateway\n-        extends ReactorMessageDispatchInterceptorSupport<CommandMessage<?>>,\n-        ReactorResultHandlerInterceptorSupport<CommandMessage<?>, CommandResultMessage<?>> {\n-\n-    /**\n-     * Sends the given {@code command} once the caller subscribes to the command result. Returns immediately.\n-     * <p/>\n-     * The given {@code command} is wrapped as the payload of a {@link CommandMessage} that is eventually posted on the\n-     * {@link CommandBus}, unless the {@code command} already implements {@link Message}. In that case, a\n-     * {@code CommandMessage} is constructed from that message's payload and {@link MetaData}.\n-     *\n-     * @param command the command to dispatch\n-     * @param <R>     the type of the command result\n-     * @return a {@link Mono} which is resolved when the command is executed\n-     */\n-    <R> Mono<R> send(Object command);\n-\n-    /**\n-     * Uses given Publisher of commands to send incoming commands away. Commands will be sent sequentially - once a\n-     * result of Nth command arrives, (N + 1)th command is dispatched.\n-     *\n-     * @param commands a Publisher stream of commands to be dispatched\n-     * @return a Flux of command results. An ordering of command results corresponds to an ordering of commands being\n-     * dispatched\n-     *\n-     * @see #send(Object)\n-     * @see Flux#concatMap(Function)\n-     */\n-    default Flux<Object> sendAll(Publisher<?> commands) {\n-        return Flux.from(commands)\n-                   .concatMap(this::send);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MDgzOQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452690839", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n          \n          \n            \n             * Variation of the {@link EventGateway}, wrapping a {@link EventBus} for a friendlier API. Provides support for reactive return types such as {@link Flux} from Project", "author": "smcvb", "createdAt": "2020-07-10T08:09:32Z", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java b/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\nindex bf4e42f45..ed6694bcb 100644\n--- a/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n+++ b/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n\n@@ -27,7 +27,7 @@\n import java.util.List;\n \n /**\n- * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Variation of the {@link EventGateway}, wrapping a {@link EventBus} for a friendlier API. Provides support for reactive return types such as {@link Flux} from Project\n  * Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MTIyNw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452691227", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n          \n          \n            \n                 * Publishes the given {@code events} once the caller subscribes to the resulting {@link Flux}. Returns immediately.", "author": "smcvb", "createdAt": "2020-07-10T08:10:20Z", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java b/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\nindex bf4e42f45..ed6694bcb 100644\n--- a/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n+++ b/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n\n@@ -27,7 +27,7 @@\n import java.util.List;\n \n /**\n- * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Variation of the {@link EventGateway}, wrapping a {@link EventBus} for a friendlier API. Provides support for reactive return types such as {@link Flux} from Project\n  * Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MTQ3MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452691470", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n          \n          \n            \n                 * Publishes the given {@code events} once the caller subscribes to the resulting {@link Flux}. Returns immediately.", "author": "smcvb", "createdAt": "2020-07-10T08:10:53Z", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    default Flux<Object> publish(Object... events) { // NOSONAR\n+        return publish(Arrays.asList(events));\n+    }\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java b/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\nindex bf4e42f45..ed6694bcb 100644\n--- a/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n+++ b/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n\n@@ -27,7 +27,7 @@\n import java.util.List;\n \n /**\n- * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Variation of the {@link EventGateway}, wrapping a {@link EventBus} for a friendlier API. Provides support for reactive return types such as {@link Flux} from Project\n  * Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MTc3Ng==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452691776", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n          \n          \n            \n                 * Publishes the given {@code events} once the caller subscribes to the resulting {@link Flux}. Returns immediately.", "author": "smcvb", "createdAt": "2020-07-10T08:11:30Z", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    default Flux<Object> publish(Object... events) { // NOSONAR\n+        return publish(Arrays.asList(events));\n+    }\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events the list of events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    Flux<Object> publish(List<?> events);\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java b/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\nindex bf4e42f45..ed6694bcb 100644\n--- a/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n+++ b/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n\n@@ -27,7 +27,7 @@\n import java.util.List;\n \n /**\n- * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Variation of the {@link EventGateway}, wrapping a {@link EventBus} for a friendlier API. Provides support for reactive return types such as {@link Flux} from Project\n  * Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MjEyOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452692128", "bodyText": "Nit: Slightly doubtful on this, but might be nice to reference the MessageDispatchInterceptor instead of just stating interceptors.", "author": "smcvb", "createdAt": "2020-07-10T08:12:13Z", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MjMwMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460792301", "bodyText": "Done!", "author": "m1l4n54v1c", "createdAt": "2020-07-27T10:21:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MjEyOA=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java b/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\nindex bf4e42f45..ed6694bcb 100644\n--- a/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n+++ b/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n\n@@ -27,7 +27,7 @@\n import java.util.List;\n \n /**\n- * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Variation of the {@link EventGateway}, wrapping a {@link EventBus} for a friendlier API. Provides support for reactive return types such as {@link Flux} from Project\n  * Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MjY5Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452692692", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n          \n          \n            \n             * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n          \n          \n            \n             * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting\n          \n          \n            \n             * messages.\n          \n          \n            \n             * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n          \n          \n            \n             * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n          \n          \n            \n             * be passed down the interceptor chain or to be dispatched.\n          \n      \n    \n    \n  \n\nAlthough that last sentence is true, I believe this speaks for itself.", "author": "smcvb", "createdAt": "2020-07-10T08:13:27Z", "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.reactive;\n+\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.function.BiFunction;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n+ * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting\n+ * messages.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MzI2OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452693268", "bodyText": "Added, would it make sense to state something like the following in the class level javadoc too:\nThis interceptor provides a very early means to alter or reject Messages, even before any Unit of Work is created.", "author": "smcvb", "createdAt": "2020-07-10T08:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MjY5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\nindex 48eec45b5..52dedc7c3 100644\n--- a/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\n+++ b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\n\n@@ -26,8 +26,7 @@\n /**\n  * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n  * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n- * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting\n- * messages.\n+ * be passed down the interceptor chain or to be dispatched.\n  *\n  * @param <M> the message type this interceptor can process\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NDIyNQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452694225", "bodyText": "Curious: why would you break a result message chain?", "author": "smcvb", "createdAt": "2020-07-10T08:16:26Z", "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.reactive;\n+\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ResultMessage;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Interceptor that allows results to be intercepted and modified before they are handled. Implementations are required\n+ * to operate on a {@link Flux} of results or return a new {@link Flux} which will be passed down the interceptor chain.\n+ * Also, implementations may make decisions based on the message that was dispatched.\n+ *\n+ * @param <M> The type of the message for which the result is going to be intercepted\n+ * @param <R> The type of the result to be intercepted\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+@FunctionalInterface\n+public interface ReactorResultHandlerInterceptor<M extends Message<?>, R extends ResultMessage<?>> {\n+\n+    /**\n+     * Intercepts result messages. It's possible to break the interceptor chain by returning {@link Flux#empty()} or", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyMzkyMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r453723922", "bodyText": "Few ideas:\nHistorically in the regular interceptor, you have the chain control viaproceed() function (this is reactive way of doing it)\nHandling transient exception, via flat map you can convert error to empty publisher\nThis could be useful for subscription queries, with result interceptor you could define global rule when \"infinitive\" subscriber should stop listening for updates\nYou want to filter messages that fulfill client predicate (filter function can be used for this)", "author": "schananas", "createdAt": "2020-07-13T15:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NDIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4MDMyNg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458080326", "bodyText": "Sweet, sounds good.\nIt would be very helpful to add these suggestions to the Reference Guide (to build) around the Reactive Gateways, as this will definitely help out our users.", "author": "smcvb", "createdAt": "2020-07-21T13:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NDIyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java\nindex 405e0b165..edcf8f246 100644\n--- a/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java\n+++ b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java\n\n@@ -38,8 +38,8 @@\n      * {@link Flux#error(Throwable)} variations.\n      *\n      * @param message a message that was dispatched (and caused these {@code results})\n-     * @param results results of a dispatched message\n-     * @return intercepted results\n+     * @param results the outcome of the dispatched {@code message}\n+     * @return the intercepted {@code results}\n      */\n     Flux<R> intercept(M message, Flux<R> results);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NDY3NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452694675", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param results results of a dispatched message\n          \n          \n            \n                 * @return intercepted results\n          \n          \n            \n                 * @param results the outcome of the dispatched {@code message}\n          \n          \n            \n                 * @return the intercepted {@code results}", "author": "smcvb", "createdAt": "2020-07-10T08:17:21Z", "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.reactive;\n+\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ResultMessage;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Interceptor that allows results to be intercepted and modified before they are handled. Implementations are required\n+ * to operate on a {@link Flux} of results or return a new {@link Flux} which will be passed down the interceptor chain.\n+ * Also, implementations may make decisions based on the message that was dispatched.\n+ *\n+ * @param <M> The type of the message for which the result is going to be intercepted\n+ * @param <R> The type of the result to be intercepted\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+@FunctionalInterface\n+public interface ReactorResultHandlerInterceptor<M extends Message<?>, R extends ResultMessage<?>> {\n+\n+    /**\n+     * Intercepts result messages. It's possible to break the interceptor chain by returning {@link Flux#empty()} or\n+     * {@link Flux#error(Throwable)} variations.\n+     *\n+     * @param message a message that was dispatched (and caused these {@code results})\n+     * @param results results of a dispatched message\n+     * @return intercepted results", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java\nindex 405e0b165..edcf8f246 100644\n--- a/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java\n+++ b/messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java\n\n@@ -38,8 +38,8 @@\n      * {@link Flux#error(Throwable)} variations.\n      *\n      * @param message a message that was dispatched (and caused these {@code results})\n-     * @param results results of a dispatched message\n-     * @return intercepted results\n+     * @param results the outcome of the dispatched {@code message}\n+     * @return the intercepted {@code results}\n      */\n     Flux<R> intercept(M message, Flux<R> results);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NTIxOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452695218", "bodyText": "Have you verified this serialVersionUID is the actual serialVersionUID used prior to having specified it?", "author": "smcvb", "createdAt": "2020-07-10T08:18:33Z", "path": "messaging/src/main/java/org/axonframework/messaging/responsetypes/ConvertingResponseMessage.java", "diffHunk": "@@ -21,6 +21,7 @@\n  */\n public class ConvertingResponseMessage<R> implements QueryResponseMessage<R> {\n \n+    private static final long serialVersionUID = -8926628997626431513L;", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQxODA2OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457418068", "bodyText": "Uh no! Nice catch, I'll remove it!", "author": "m1l4n54v1c", "createdAt": "2020-07-20T14:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NTIxOA=="}], "type": "inlineReview", "revised_code": {"commit": "b1184583fc50ca0b0ae81bdefc41b0a3772aa8f4", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/messaging/responsetypes/ConvertingResponseMessage.java b/messaging/src/main/java/org/axonframework/messaging/responsetypes/ConvertingResponseMessage.java\nindex 669358e00..46595a8d3 100644\n--- a/messaging/src/main/java/org/axonframework/messaging/responsetypes/ConvertingResponseMessage.java\n+++ b/messaging/src/main/java/org/axonframework/messaging/responsetypes/ConvertingResponseMessage.java\n\n@@ -21,7 +21,6 @@\n  */\n public class ConvertingResponseMessage<R> implements QueryResponseMessage<R> {\n \n-    private static final long serialVersionUID = -8926628997626431513L;\n     private final ResponseType<R> expectedResponseType;\n     private final QueryResponseMessage<?> responseMessage;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NTI5Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452695292", "bodyText": "Have you verified this serialVersionUID is the actual serialVersionUID used prior to having specified it?", "author": "smcvb", "createdAt": "2020-07-10T08:18:43Z", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java", "diffHunk": "@@ -36,8 +38,10 @@\n  */\n class GrpcBackedQueryUpdateMessage<U> implements SubscriptionQueryUpdateMessage<U> {\n \n+    private static final long serialVersionUID = 488652969630034329L;", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQxODg4MQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457418881", "bodyText": "I haven't ;(", "author": "m1l4n54v1c", "createdAt": "2020-07-20T14:07:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NTI5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4MDcyNA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458080724", "bodyText": "That's ok, that's why I've asked it! Worth verifying prior to pushing this at least :-)", "author": "smcvb", "createdAt": "2020-07-21T13:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NTI5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b1184583fc50ca0b0ae81bdefc41b0a3772aa8f4", "chunk": "diff --git a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java\nindex 106f7d6b0..1069906e9 100644\n--- a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java\n+++ b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java\n\n@@ -38,7 +38,6 @@\n  */\n class GrpcBackedQueryUpdateMessage<U> implements SubscriptionQueryUpdateMessage<U> {\n \n-    private static final long serialVersionUID = 488652969630034329L;\n     private final QueryUpdate queryUpdate;\n     private final LazyDeserializingObject<U> serializedPayload;\n     private final Throwable exception;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NjU2Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452696567", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n          \n          \n            \n             * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}", "author": "smcvb", "createdAt": "2020-07-10T08:21:09Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNTE5OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452705198", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "author": "smcvb", "createdAt": "2020-07-10T08:38:05Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MzEzMA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460793130", "bodyText": "Done!", "author": "m1l4n54v1c", "createdAt": "2020-07-27T10:23:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNTE5OA=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNTk0Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452705942", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "author": "smcvb", "createdAt": "2020-07-10T08:39:36Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MzIxMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460793211", "bodyText": "Done!", "author": "m1l4n54v1c", "createdAt": "2020-07-27T10:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNTk0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNzE4Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452707187", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n          \n          \n            \n                 * result of Nth query arrives, (N + 1)th query is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Use the given {@link Publisher} of {@link QueryMessage}s to send the incoming queries away. Queries will be sent sequentially. Once the\n          \n          \n            \n                 * result of the Nth query arrives, the (N + 1)th query is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "author": "smcvb", "createdAt": "2020-07-10T08:41:57Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNzU4Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452707582", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "author": "smcvb", "createdAt": "2020-07-10T08:42:46Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MzI2OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460793268", "bodyText": "Done!", "author": "m1l4n54v1c", "createdAt": "2020-07-27T10:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNzU4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwODEwOQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452708109", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "author": "smcvb", "createdAt": "2020-07-10T08:43:48Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MzUxMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460793512", "bodyText": "Addressed.", "author": "m1l4n54v1c", "createdAt": "2020-07-27T10:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwODEwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwODk2NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452708965", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "author": "smcvb", "createdAt": "2020-07-10T08:45:23Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MzU2NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460793564", "bodyText": "Addressed.", "author": "m1l4n54v1c", "createdAt": "2020-07-27T10:24:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwODk2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwOTY2Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452709667", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n          \n          \n            \n                 * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n          \n          \n            \n                 * using given {@code timeout} and {@code timeUnit}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries  a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @param timeout  A timeout of {@code long} for the query\n          \n          \n            \n                 * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of {@link QueryMessage}s to send incoming queries in scatter gather manner. Queries will be sent\n          \n          \n            \n                 * sequentially. Once the result of Nth query arrives, the (N + 1)th query is dispatched. All queries will be dispatched\n          \n          \n            \n                 * using given {@code timeout} and {@code timeUnit}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries  a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @param timeout  A timeout of {@code long} for the query\n          \n          \n            \n                 * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "author": "smcvb", "createdAt": "2020-07-10T08:46:42Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMDE0Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452710142", "bodyText": "Why is there no reference to the concatMap operation, like on the Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) javadoc?", "author": "smcvb", "createdAt": "2020-07-10T08:47:40Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5ODIzNg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460798236", "bodyText": "Because I forgot :/ Adding it :)", "author": "m1l4n54v1c", "createdAt": "2020-07-27T10:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMDE0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMTE0NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452711144", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n          \n          \n            \n                 * incremental updates until subscriber unsubscribes from Flux.\n          \n          \n            \n                 * Should be used when response type of initial result and incremental update match.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, returning the initial result and a stream of\n          \n          \n            \n                 * incremental updates until the subscriber unsubscribes from the resulting {@link Flux}.\n          \n          \n            \n                 * Should be used when the response type of the initial result and incremental update match.", "author": "smcvb", "createdAt": "2020-07-10T08:49:46Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMTMyMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452711322", "bodyText": "Why this this sentence between brackets?", "author": "smcvb", "createdAt": "2020-07-10T08:50:01Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQzMjU0NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457432544", "bodyText": "I guess it's not that important to be the part of the main sentence, but it provides additional info. Just tried to underline an important part of JavaDoc. Could be removed though...", "author": "m1l4n54v1c", "createdAt": "2020-07-20T14:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMTMyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4MzU4NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458083585", "bodyText": "Hmm, I think it makes sense to have this bit in here to be honest! So I'd personally be fine with removing the brackets and making it a fullfledged sentence.", "author": "smcvb", "createdAt": "2020-07-21T13:11:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMTMyMg=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMTU5Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452711592", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "author": "smcvb", "createdAt": "2020-07-10T08:50:33Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMjczNQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452712735", "bodyText": "The same javadoc comments I placed on the previous method apply to this guy.", "author": "smcvb", "createdAt": "2020-07-10T08:52:43Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMzI2MQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452713261", "bodyText": "The same javadoc comments I placed on the previous method apply to this guy.", "author": "smcvb", "createdAt": "2020-07-10T08:53:34Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMzcxMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452713712", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "author": "smcvb", "createdAt": "2020-07-10T08:54:19Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDEyNg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452714126", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, and streams\n          \n          \n            \n                 * incremental updates until subscriber unsubscribes from Flux.\n          \n          \n            \n                 * Should be used when subscriber is interested only in updates.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, streaming\n          \n          \n            \n                 * incremental updates until the subscriber unsubscribes from the resulting {@link Flux}.\n          \n          \n            \n                 * Should be used when the subscriber is interested only in updates.", "author": "smcvb", "createdAt": "2020-07-10T08:54:59Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDU0MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452714540", "bodyText": "Interesting, using Void as the initial result will make it so we disregard the initial result?", "author": "smcvb", "createdAt": "2020-07-10T08:55:39Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0MTk3MQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457441971", "bodyText": "Actually, it's never invoked, essentially it doesn't matter.", "author": "m1l4n54v1c", "createdAt": "2020-07-20T14:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDU0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4NDEyMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458084121", "bodyText": "Aaah gotcha, because this is just a query for the updates... Thanks for clarifying!", "author": "smcvb", "createdAt": "2020-07-21T13:12:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDU0MA=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDc1Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452714757", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "author": "smcvb", "createdAt": "2020-07-10T08:56:01Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzI1Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452783252", "bodyText": "I see it come back in the other subscription query methods too, so I'll stop copying this comment.", "author": "smcvb", "createdAt": "2020-07-10T11:20:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDc1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDk5OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452714998", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, and streams\n          \n          \n            \n                 * incremental updates until subscriber unsubscribes from Flux.\n          \n          \n            \n                 * Should be used when subscriber is interested only in updates.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, streaming\n          \n          \n            \n                 * incremental updates until hte subscriber unsubscribes from the resulting {@link Flux}.\n          \n          \n            \n                 * Should be used when the subscriber is interested only in updates.", "author": "smcvb", "createdAt": "2020-07-10T08:56:27Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNTMwMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452715302", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "author": "smcvb", "createdAt": "2020-07-10T08:56:55Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzM4Mw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452783383", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "author": "smcvb", "createdAt": "2020-07-10T11:20:39Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzk3Mw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452783973", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n          \n          \n            \n                 * of Nth query arrives, (N + 1)th query is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of {@link SubscriptionQueryMessage}s to send incoming queries away. Queries will be sent sequentially. Once the result\n          \n          \n            \n                 * of Nth query arrives, the (N + 1)th query is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "author": "smcvb", "createdAt": "2020-07-10T11:22:12Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code flux}\n+     *                            is made\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                    ResponseType<I> initialResponseType,\n+                                                                    ResponseType<U> updateResponseType,\n+                                                                    SubscriptionQueryBackpressure backpressure,\n+                                                                    int updateBufferSize);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NDM5OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452784398", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n          \n          \n            \n                 * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n          \n          \n            \n                 * backpressure}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries      a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @param backpressure The backpressure mechanism to deal with producing of incremental updates\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of {@link SubscriptionQueryMessage}s to send incoming queries away. Queries will be sent sequentially. Once the result\n          \n          \n            \n                 * of Nth query arrives, the (N + 1)th query is dispatched. All queries will be dispatched using the given {@code\n          \n          \n            \n                 * backpressure}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries      a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @param backpressure the backpressure mechanism to deal with producing of incremental updates\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "author": "smcvb", "createdAt": "2020-07-10T11:23:24Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code flux}\n+     *                            is made\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                    ResponseType<I> initialResponseType,\n+                                                                    ResponseType<U> updateResponseType,\n+                                                                    SubscriptionQueryBackpressure backpressure,\n+                                                                    int updateBufferSize);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #subscriptionQuery(String, Object, Class, Class)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<SubscriptionQueryResult<?, ?>> subscriptionQuery( // NOSONAR\n+                                                                   Publisher<SubscriptionQueryMessage<?, ?, ?>> queries) {\n+        return subscriptionQuery(queries, SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n+     * backpressure}.\n+     *\n+     * @param queries      a Publisher stream of queries to be dispatched\n+     * @param backpressure The backpressure mechanism to deal with producing of incremental updates\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NDg0OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452784848", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n          \n          \n            \n                 * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n          \n          \n            \n                 * backpressure} and {@code updateBufferSize}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries          a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @param backpressure     The backpressure mechanism to deal with producing of incremental updates\n          \n          \n            \n                 * @param updateBufferSize The size of buffer which accumulates updates before subscription to the {@code flux}\n          \n          \n            \n                 *                         is made\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of {@link SubscriptionQueryMessage}s to send incoming queries away. Queries will be sent sequentially. Once the result\n          \n          \n            \n                 * of Nth query arrives, the (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n          \n          \n            \n                 * backpressure} and {@code updateBufferSize}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries          a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @param backpressure     the backpressure mechanism to deal with producing of incremental updates\n          \n          \n            \n                 * @param updateBufferSize the size of buffer which accumulates updates before subscription to the {@code flux}\n          \n          \n            \n                 *                         is made\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "author": "smcvb", "createdAt": "2020-07-10T11:24:28Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code flux}\n+     *                            is made\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                    ResponseType<I> initialResponseType,\n+                                                                    ResponseType<U> updateResponseType,\n+                                                                    SubscriptionQueryBackpressure backpressure,\n+                                                                    int updateBufferSize);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #subscriptionQuery(String, Object, Class, Class)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<SubscriptionQueryResult<?, ?>> subscriptionQuery( // NOSONAR\n+                                                                   Publisher<SubscriptionQueryMessage<?, ?, ?>> queries) {\n+        return subscriptionQuery(queries, SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n+     * backpressure}.\n+     *\n+     * @param queries      a Publisher stream of queries to be dispatched\n+     * @param backpressure The backpressure mechanism to deal with producing of incremental updates\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #subscriptionQuery(String, Object, Class, Class)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<SubscriptionQueryResult<?, ?>> subscriptionQuery( // NOSONAR\n+                                                                   Publisher<SubscriptionQueryMessage<?, ?, ?>> queries,\n+                                                                   SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queries, backpressure, Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n+     * backpressure} and {@code updateBufferSize}.\n+     *\n+     * @param queries          a Publisher stream of queries to be dispatched\n+     * @param backpressure     The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize The size of buffer which accumulates updates before subscription to the {@code flux}\n+     *                         is made\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex 27590167d..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -30,7 +30,7 @@\n import java.util.function.Function;\n \n /**\n- * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n  * from Project Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NTc1Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452785757", "bodyText": "Might be more reasonable to reuse the org.axonframework.test.utils.RecordingCommandBus instead of building a new.", "author": "smcvb", "createdAt": "2020-07-10T11:26:39Z", "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/CommandBusStub.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n+import org.axonframework.messaging.MessageHandler;\n+import org.axonframework.messaging.MessageHandlerInterceptor;\n+\n+import java.util.LinkedList;\n+\n+/**\n+ * A stub of {@link CommandBus} that captures sent commands.\n+ *\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+public class CommandBusStub implements CommandBus {", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ2OTA1NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457469055", "bodyText": "we should build axon-messaging with test-jar goal. Is this smth we want to do?", "author": "m1l4n54v1c", "createdAt": "2020-07-20T15:01:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NTc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4NDY4NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458084685", "bodyText": "Hmmm good point...Let's put this in the incubator to look into at a latter stage.", "author": "smcvb", "createdAt": "2020-07-21T13:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NTc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4NjA5NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458086094", "bodyText": "Added it there, so I'll resolve this thread.", "author": "smcvb", "createdAt": "2020-07-21T13:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NTc1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "30ba00c255b5a867f13c792cd330dde0bb30cc9d", "chunk": "diff --git a/messaging/src/test/java/org/axonframework/commandhandling/gateway/CommandBusStub.java b/messaging/src/test/java/org/axonframework/commandhandling/gateway/CommandBusStub.java\ndeleted file mode 100644\nindex af9946a78..000000000\n--- a/messaging/src/test/java/org/axonframework/commandhandling/gateway/CommandBusStub.java\n+++ /dev/null\n\n@@ -1,70 +0,0 @@\n-package org.axonframework.commandhandling.gateway;\n-\n-import org.axonframework.commandhandling.CommandBus;\n-import org.axonframework.commandhandling.CommandCallback;\n-import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.commandhandling.CommandResultMessage;\n-import org.axonframework.commandhandling.GenericCommandResultMessage;\n-import org.axonframework.common.Registration;\n-import org.axonframework.messaging.MessageDispatchInterceptor;\n-import org.axonframework.messaging.MessageHandler;\n-import org.axonframework.messaging.MessageHandlerInterceptor;\n-\n-import java.util.LinkedList;\n-\n-/**\n- * A stub of {@link CommandBus} that captures sent commands.\n- *\n- * @author Sara Pellegrini\n- * @since 4.4\n- */\n-public class CommandBusStub implements CommandBus {\n-\n-    private final LinkedList<CommandMessage<?>> sent = new LinkedList<>();\n-\n-    private final CommandResultMessage result;\n-\n-    public CommandBusStub() {\n-        this(new GenericCommandResultMessage<Object>(\"\"));\n-    }\n-\n-    public CommandBusStub(CommandResultMessage<?> result) {\n-        this.result = result;\n-    }\n-\n-    @Override\n-    public <C> void dispatch(CommandMessage<C> command) {\n-        sent.add(command);\n-    }\n-\n-    @Override\n-    public <C, R> void dispatch(CommandMessage<C> command, CommandCallback<? super C, ? super R> callback) {\n-        sent.add(command);\n-        callback.onResult(command, result);\n-    }\n-\n-    @Override\n-    public Registration subscribe(String commandName, MessageHandler<? super CommandMessage<?>> handler) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Registration registerDispatchInterceptor(\n-            MessageDispatchInterceptor<? super CommandMessage<?>> dispatchInterceptor) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Registration registerHandlerInterceptor(\n-            MessageHandlerInterceptor<? super CommandMessage<?>> handlerInterceptor) {\n-        return null;\n-    }\n-\n-    public CommandMessage<?> lastSentCommand() {\n-        return sent.getLast();\n-    }\n-\n-    public int numberOfSentCommands() {\n-        return sent.size();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4OTAxNg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452789016", "bodyText": "\"reactiveness\", nice \ud83d\ude0e", "author": "smcvb", "createdAt": "2020-07-10T11:34:34Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\nindex ce0c01955..98b7749b9 100644\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\n+++ b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\n\n@@ -17,10 +17,9 @@\n package org.axonframework.commandhandling.gateway;\n \n import org.axonframework.commandhandling.*;\n-import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n import org.axonframework.common.AxonConfigurationException;\n import org.axonframework.common.Registration;\n-import org.axonframework.messaging.ResultMessage;\n import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n import reactor.core.publisher.Flux;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MDc3NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452790774", "bodyText": "Curious: do we need to do Flux.from(reactiveCallback) because the the ReactiveCallback is an implementation of Publisher? Looks somewhat funky to do Mono.just(Flux.from(...)), so assuming you cannot make a Mono from a Publisher directly?", "author": "smcvb", "createdAt": "2020-07-10T11:39:15Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactiveCallback<C, R> reactiveCallback = new ReactiveCallback<>();\n+        CommandCallback<C, R> callback = reactiveCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactiveCallback)));", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4Mzg1MQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r453583851", "bodyText": "Unfortunately, it's not because of making Mono from Publisher, the common result interceptor signature makes this code complex.\nIf ReactiveCallback would extend Mono instead of Published we would still need to convert Mono to Flux because of result interceptor signature (intercepts flux of results).\nAnyway will try to think if there is a way to improve interceptor signature to make this code more readable and less complex", "author": "schananas", "createdAt": "2020-07-13T11:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MDc3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM3ODc0NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461378745", "bodyText": "Thanks for the explanation here @stefanvozd. Think for now, this is ok; it's good to have a think about this if we can improve this.", "author": "smcvb", "createdAt": "2020-07-28T07:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MDc3NA=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\nindex ce0c01955..98b7749b9 100644\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\n+++ b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\n\n@@ -17,10 +17,9 @@\n package org.axonframework.commandhandling.gateway;\n \n import org.axonframework.commandhandling.*;\n-import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n import org.axonframework.common.AxonConfigurationException;\n import org.axonframework.common.Registration;\n-import org.axonframework.messaging.ResultMessage;\n import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n import reactor.core.publisher.Flux;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MTk2Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452791967", "bodyText": "What makes null a response type to filter out? Couldn't a null be valid as a command response?", "author": "smcvb", "createdAt": "2020-07-10T11:42:08Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactiveCallback<C, R> reactiveCallback = new ReactiveCallback<>();\n+        CommandCallback<C, R> callback = reactiveCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactiveCallback)));\n+    }\n+\n+    private <C> Mono<? extends CommandResultMessage<?>> processResultsInterceptors(\n+            Tuple2<CommandMessage<C>, Flux<CommandResultMessage<?>>> commandWithResults) {\n+        CommandMessage<?> commandMessage = commandWithResults.getT1();\n+        Flux<CommandResultMessage<?>> commandResultMessages = commandWithResults.getT2();\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(commandResultMessages,\n+                           (result, interceptor) -> interceptor.intercept(commandMessage, result))\n+                   .flatMap(Flux::next); // command handlers provide only one result!\n+    }\n+\n+    private <R> Mono<R> getPayload(Mono<? extends CommandResultMessage<?>> commandResultMessage) {\n+        //noinspection unchecked\n+        return commandResultMessage\n+                .filter(r -> Objects.nonNull(r.getPayload()))\n+                .map(it -> (R) it.getPayload());", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU3MzYyOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r453573628", "bodyText": "The reactor doesn't support null values in a stream. Null value is equivalent of Mono.empty() in this case. Filter operator archive's that.", "author": "schananas", "createdAt": "2020-07-13T11:09:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwODkwMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458108901", "bodyText": "What does it mean to be archived? Does that mean that users can still see there were null responses?\nI'd argue that null is a valid response for some queries, hence why I am asking for it.\nYou could however further argue that if users are interested in this, that they can use the OptionalResponseType to better tie into that.\nAnyhow, what I am angling for, is there a way to get such a result to users at all?", "author": "smcvb", "createdAt": "2020-07-21T13:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc0MTYyMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460741622", "bodyText": "sorry not achieve, its achieve. so if query returns null it will be mapped to Mono.empty, and user can react on that as it can on null value, but in a reactive, functional way. Instead of using optional or writing if statements, different operators like .switchIfEmpty could be used to handle null return values. Additionally, as you mentioned user can introduce OptionalResponseType, but I see that as an anti-pattern, since Mono offers the same functionality.\nBottom line:   Optional.empty = Mono.empty,  for reactive streams mono.empty should be used instead of optional", "author": "schananas", "createdAt": "2020-07-27T08:51:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM3OTMwMw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461379303", "bodyText": "Gotcha, thanks for explaining this further @stefanvozd!", "author": "smcvb", "createdAt": "2020-07-28T07:37:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MTk2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\nindex ce0c01955..98b7749b9 100644\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\n+++ b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\n\n@@ -17,10 +17,9 @@\n package org.axonframework.commandhandling.gateway;\n \n import org.axonframework.commandhandling.*;\n-import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n import org.axonframework.common.AxonConfigurationException;\n import org.axonframework.common.Registration;\n-import org.axonframework.messaging.ResultMessage;\n import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n import reactor.core.publisher.Flux;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NDM5Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452794392", "bodyText": "Why is there a result to publishing events? Is that a necessity which follows from being able to subscribe to this Flux, which will be the actual initiation of publishing the events?\nIf so, could we change this to Flux<Void> instead of Flux<Object>? Object makes it seem (to me at least) like they'll get an actual response.", "author": "smcvb", "createdAt": "2020-07-10T11:48:11Z", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    default Flux<Object> publish(Object... events) { // NOSONAR\n+        return publish(Arrays.asList(events));\n+    }\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events the list of events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    Flux<Object> publish(List<?> events);", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3MTgxMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457471812", "bodyText": "I get your point! Return values, in this case, are intercepted events. One of the reasons why we return a flux here is to be more consistent with other Reactor APIs - don't do anything until you subscribe. We could change it to Void, but I felt it is more useful to see how your events look before hitting the bus.", "author": "m1l4n54v1c", "createdAt": "2020-07-20T15:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NDM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExMDIxNg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458110216", "bodyText": "Aaah gotcha, as the Flux returned is indeed allowing you to do additional steps prior to subscription. Using Object as the generic type makes total sense than. Thanks for clarifying @m1l4n54v1c, I'll resolve this thread.", "author": "smcvb", "createdAt": "2020-07-21T13:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NDM5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java b/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\nindex bf4e42f45..ed6694bcb 100644\n--- a/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n+++ b/messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n\n@@ -27,7 +27,7 @@\n import java.util.List;\n \n /**\n- * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Variation of the {@link EventGateway}, wrapping a {@link EventBus} for a friendlier API. Provides support for reactive return types such as {@link Flux} from Project\n  * Reactor.\n  *\n  * @author Milan Savic\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NDYxMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452794612", "bodyText": "Curious whether this is actually needed in this form, or whether we can just do void/null here by default. Follows from my comment on the interface by the way.", "author": "smcvb", "createdAt": "2020-07-10T11:48:51Z", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/DefaultReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.eventhandling.GenericEventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorEventGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorEventGateway implements ReactorEventGateway {\n+\n+    private final EventBus eventBus;\n+    private final List<ReactorMessageDispatchInterceptor<EventMessage<?>>> dispatchInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorEventGateway} based on the fields contained in the {@link Builder}.\n+     * <p>\n+     * Will assert that the {@link EventBus} is not {@code null} and throws an {@link\n+     * org.axonframework.common.AxonConfigurationException} if it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorEventGateway} instance\n+     */\n+    protected DefaultReactorEventGateway(Builder builder) {\n+        builder.validate();\n+        this.eventBus = builder.eventBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorEventGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link EventBus} is a <b>hard requirement</b>\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorEventGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Flux<Object> publish(List<?> events) {\n+        return Flux.fromIterable(events)\n+                   .map(event -> Mono.<EventMessage<?>>just(GenericEventMessage.asEventMessage(event)))\n+                   .flatMap(this::processEventInterceptors)\n+                   .flatMap(this::publishEvent)\n+                   .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<EventMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<EventMessage<?>> processEventInterceptors(Mono<EventMessage<?>> eventMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(eventMessage, (event, interceptor) -> interceptor.intercept(event))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Mono<EventMessage<?>> publishEvent(EventMessage<?> eventMessage) {\n+        return Mono.fromRunnable(() -> eventBus.publish(eventMessage))\n+                   .thenReturn(eventMessage);\n+    }\n+\n+    private Flux<Object> getPayload(Flux<EventMessage<?>> eventMessage) {", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4MDcyMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461380722", "bodyText": "Resolved through the previous comment in this file.", "author": "smcvb", "createdAt": "2020-07-28T07:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NDYxMg=="}], "type": "inlineReview", "revised_code": {"commit": "30ba00c255b5a867f13c792cd330dde0bb30cc9d", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/eventhandling/gateway/DefaultReactorEventGateway.java b/messaging/src/main/java/org/axonframework/eventhandling/gateway/DefaultReactorEventGateway.java\ndeleted file mode 100644\nindex c08158f18..000000000\n--- a/messaging/src/main/java/org/axonframework/eventhandling/gateway/DefaultReactorEventGateway.java\n+++ /dev/null\n\n@@ -1,177 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.eventhandling.gateway;\n-\n-import org.axonframework.common.AxonConfigurationException;\n-import org.axonframework.common.Registration;\n-import org.axonframework.eventhandling.EventBus;\n-import org.axonframework.eventhandling.EventMessage;\n-import org.axonframework.eventhandling.GenericEventMessage;\n-import org.axonframework.messaging.Message;\n-import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n-import static java.util.Arrays.asList;\n-import static org.axonframework.common.BuilderUtils.assertNonNull;\n-\n-/**\n- * Implementation of the {@link ReactorEventGateway} that uses Project Reactor to achieve reactiveness.\n- *\n- * @author Milan Savic\n- * @since 4.4\n- */\n-public class DefaultReactorEventGateway implements ReactorEventGateway {\n-\n-    private final EventBus eventBus;\n-    private final List<ReactorMessageDispatchInterceptor<EventMessage<?>>> dispatchInterceptors;\n-\n-    /**\n-     * Creates an instance of {@link DefaultReactorEventGateway} based on the fields contained in the {@link Builder}.\n-     * <p>\n-     * Will assert that the {@link EventBus} is not {@code null} and throws an {@link\n-     * org.axonframework.common.AxonConfigurationException} if it is.\n-     * </p>\n-     *\n-     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorEventGateway} instance\n-     */\n-    protected DefaultReactorEventGateway(Builder builder) {\n-        builder.validate();\n-        this.eventBus = builder.eventBus;\n-        this.dispatchInterceptors = builder.dispatchInterceptors;\n-    }\n-\n-    /**\n-     * Instantiate a Builder to be able to create a {@link DefaultReactorEventGateway}.\n-     * <p>\n-     * The {@code dispatchInterceptors} are defaulted to an empty list.\n-     * The {@link EventBus} is a <b>hard requirement</b>\n-     * </p>\n-     *\n-     * @return a Builder to be able to create a {@link DefaultReactorEventGateway}\n-     */\n-    public static Builder builder() {\n-        return new Builder();\n-    }\n-\n-    @Override\n-    public Flux<Object> publish(List<?> events) {\n-        return Flux.fromIterable(events)\n-                   .map(event -> Mono.<EventMessage<?>>just(GenericEventMessage.asEventMessage(event)))\n-                   .flatMap(this::processEventInterceptors)\n-                   .flatMap(this::publishEvent)\n-                   .transform(this::getPayload);\n-    }\n-\n-    @Override\n-    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<EventMessage<?>> interceptor) {\n-        dispatchInterceptors.add(interceptor);\n-        return () -> dispatchInterceptors.remove(interceptor);\n-    }\n-\n-    private Mono<EventMessage<?>> processEventInterceptors(Mono<EventMessage<?>> eventMessage) {\n-        return Flux.fromIterable(dispatchInterceptors)\n-                   .reduce(eventMessage, (event, interceptor) -> interceptor.intercept(event))\n-                   .flatMap(Mono::from);\n-    }\n-\n-    private Mono<EventMessage<?>> publishEvent(EventMessage<?> eventMessage) {\n-        return Mono.fromRunnable(() -> eventBus.publish(eventMessage))\n-                   .thenReturn(eventMessage);\n-    }\n-\n-    private Flux<Object> getPayload(Flux<EventMessage<?>> eventMessage) {\n-        return eventMessage.filter(r -> Objects.nonNull(r.getPayload()))\n-                           .map(Message::getPayload);\n-    }\n-\n-    /**\n-     * Builder class to instantiate {@link DefaultReactorEventGateway}.\n-     * <p>\n-     * The {@code dispatchInterceptors} are defaulted to an empty list.\n-     * The {@link EventBus} is a <b>hard requirement</b>\n-     * </p>\n-     */\n-    public static class Builder {\n-\n-        private EventBus eventBus;\n-        private List<ReactorMessageDispatchInterceptor<EventMessage<?>>> dispatchInterceptors = new CopyOnWriteArrayList<>();\n-\n-        /**\n-         * Sets the {@link EventBus} used to publish events.\n-         *\n-         * @param eventBus a {@link EventBus} used to publish events\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder eventBus(EventBus eventBus) {\n-            assertNonNull(eventBus, \"EventBus may not be null\");\n-            this.eventBus = eventBus;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets {@link ReactorMessageDispatchInterceptor}s for {@link EventMessage}s. Are invoked when an event is\n-         * being dispatched.\n-         *\n-         * @param dispatchInterceptors which are invoked when an event is being published\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        @SafeVarargs\n-        public final Builder dispatchInterceptors(\n-                ReactorMessageDispatchInterceptor<EventMessage<?>>... dispatchInterceptors) {\n-            return dispatchInterceptors(asList(dispatchInterceptors));\n-        }\n-\n-        /**\n-         * Sets the {@link List} of {@link ReactorMessageDispatchInterceptor}s for {@link EventMessage}s. Are invoked\n-         * when an event is being dispatched.\n-         *\n-         * @param dispatchInterceptors which are invoked when an event is being published\n-         * @return the current Builder instance, for fluent interfacing\n-         */\n-        public Builder dispatchInterceptors(\n-                List<ReactorMessageDispatchInterceptor<EventMessage<?>>> dispatchInterceptors) {\n-            this.dispatchInterceptors = dispatchInterceptors != null && !dispatchInterceptors.isEmpty()\n-                    ? new CopyOnWriteArrayList<>(dispatchInterceptors)\n-                    : new CopyOnWriteArrayList<>();\n-            return this;\n-        }\n-\n-        /**\n-         * Validate whether the fields contained in this Builder as set accordingly.\n-         *\n-         * @throws AxonConfigurationException if one field is asserted to be incorrect according to the Builder's\n-         *                                    specifications\n-         */\n-        protected void validate() {\n-            assertNonNull(eventBus, \"The EventBus is a hard requirement and should be provided\");\n-        }\n-\n-        /**\n-         * Initializes a {@link DefaultReactorEventGateway} as specified through this Builder.\n-         *\n-         * @return a {@link DefaultReactorEventGateway} as specified through this Builder\n-         */\n-        public DefaultReactorEventGateway build() {\n-            return new DefaultReactorEventGateway(this);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwMDUyNA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452800524", "bodyText": "The second assert here is the same as the first one. Think the second one is intended to verify k2 == k3.", "author": "smcvb", "createdAt": "2020-07-10T12:03:07Z", "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+/**\n+ * Unit tests for {@link DefaultReactorCommandGateway}.\n+ *\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+class DefaultReactorCommandGatewayTest {\n+\n+    private CommandBusStub commandBus;\n+    private ReactorCommandGateway gateway;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        commandBus = new CommandBusStub();\n+        gateway = DefaultReactorCommandGateway.builder()\n+                                              .commandBus(commandBus)\n+                                              .build();\n+    }\n+\n+    @Test\n+    void testInterceptorOrder() {\n+\n+        // int 1 -> metadata on command k1 -> v1\n+        Map<String, String> metadata1 = new HashMap<>();\n+        metadata1.put(\"k1\", \"v1\");\n+        registerMessageMapping(gateway, command -> command.andMetaData(metadata1));\n+\n+        // int 2 -> copy metadata from command into results\n+        registerResultMapping(gateway,\n+                              (command, result) -> new GenericCommandResultMessage<>(command.getMetaData().get(\"k1\")));\n+\n+        // int 3 -> metadata on command k1 -> v2\n+        Map<String, String> metadata2 = new HashMap<>();\n+        metadata1.put(\"k1\", \"v2\");\n+        registerMessageMapping(gateway, command -> command.andMetaData(metadata2));\n+\n+        //send\n+        Mono<String> results = gateway.send(\"\");\n+\n+        // verify -> results equals v2\n+        StepVerifier.create(results)\n+                    .expectNextMatches(result -> result.equals(\"v2\"))\n+                    .verifyComplete();\n+\n+        // verify -> command sent has k1 -> v2\n+        CommandMessage<?> sentCommand = commandBus.lastSentCommand();\n+        assertEquals(\"v2\", sentCommand.getMetaData().get(\"k1\"));\n+    }\n+\n+    @Test\n+    void testResultFiltering() {\n+        registerResultsFilter(gateway, result -> result.getMetaData().containsKey(\"K\"));\n+        // int 1 -> flux of results is filtered\n+\n+        Mono<CommandResultMessage<?>> results = gateway.send(\"\");\n+        StepVerifier.create(results)\n+                    .verifyComplete();\n+        // verify -> command has been sent\n+        assertEquals(1, commandBus.numberOfSentCommands());\n+    }\n+\n+    @Test\n+    void testCommandFiltering() {\n+        registerMessageFilter(gateway, result -> result.getMetaData().containsKey(\"K\"));\n+        // int 1 -> flux of results is filtered\n+\n+        Mono<CommandResultMessage<?>> results = gateway.send(\"\");\n+        StepVerifier.create(results)\n+                    .verifyComplete();\n+        // verify -> command has not been sent\n+        assertEquals(0, commandBus.numberOfSentCommands());\n+    }\n+\n+    @Test\n+    void testCommandDispatchAndResultHandlerInterceptor() {\n+        // int 1 -> add Principal to command and results\n+        Map<String, String> principalMetadata = new HashMap<>();\n+        principalMetadata.put(\"username\", \"admin\");\n+        registerMapping(gateway,\n+                        command -> command.andMetaData(principalMetadata),\n+                        (command, result) -> result.andMetaData(principalMetadata));\n+\n+        // int 2 -> validate authorizations and results\n+        registerMapping(gateway,\n+                        command -> {\n+                            assert command.getMetaData().get(\"username\").equals(\"admin\");\n+                            return command;\n+                        },\n+                        (command, result) -> {\n+                            assert result.getMetaData().get(\"username\").equals(\"admin\");\n+                            return result;\n+                        });\n+\n+        Mono<CommandResultMessage<?>> results = gateway.send(\"\");\n+\n+        StepVerifier.create(results)\n+                    .expectNextCount(1)\n+                    .verifyComplete();\n+\n+        assertEquals(1, commandBus.numberOfSentCommands());\n+    }\n+\n+    @Test\n+    void testCommandResultHandlerChain() {\n+        // int 1 -> metadata on result k1 -> v1\n+        Map<String, String> metadata1 = new HashMap<>();\n+        metadata1.put(\"k1\", \"v1\");\n+        registerResultMapping(gateway, (command, result) -> result.andMetaData(metadata1));\n+\n+        // int 2 -> metadata on result k1 -> v2\n+        Map<String, String> metadata2 = new HashMap<>();\n+        metadata2.put(\"k1\", \"v2\");\n+        registerResultMapping(gateway, (command, result) -> result.andMetaData(metadata2));\n+\n+        // int 3 -> metadata on result k2 -> v3\n+        Map<String, String> metadata3 = new HashMap<>();\n+        metadata3.put(\"k2\", \"v3\");\n+        registerResultMapping(gateway, (command, result) -> result.andMetaData(metadata3));\n+\n+        Mono<CommandResultMessage<?>> results = gateway.send(\"\");\n+\n+        // verify -> results have k1 -> v2 and k2 -> v3\n+        StepVerifier.create(results)\n+                    .expectNextMatches(result -> result.getMetaData().get(\"k1\").equals(\"v2\") &&", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b1184583fc50ca0b0ae81bdefc41b0a3772aa8f4", "chunk": "diff --git a/messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayTest.java b/messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayTest.java\nindex 35b313d37..abb0775a5 100644\n--- a/messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayTest.java\n+++ b/messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayTest.java\n\n@@ -141,7 +141,7 @@ void testCommandResultHandlerChain() {\n         // verify -> results have k1 -> v2 and k2 -> v3\n         StepVerifier.create(results)\n                     .expectNextMatches(result -> result.getMetaData().get(\"k1\").equals(\"v2\") &&\n-                            result.getMetaData().get(\"k1\").equals(\"v2\"));\n+                            result.getMetaData().get(\"k2\").equals(\"v3\"));\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwMjMzMA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452802330", "bodyText": "Curious: Why not make it actually void, without a return statement?", "author": "smcvb", "createdAt": "2020-07-10T12:07:15Z", "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayComponentTest.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.AsynchronousCommandBus;\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.util.context.Context;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link DefaultReactorCommandGateway} all together with Command Bus.\n+ *\n+ * @author Milan Savic\n+ */\n+class DefaultReactorCommandGatewayComponentTest {\n+\n+    private DefaultReactorCommandGateway reactiveCommandGateway;\n+    private MessageHandler<CommandMessage<?>> commandMessageHandler;\n+    private MessageHandler<CommandMessage<?>> failingCommandHandler;\n+    private MessageHandler<CommandMessage<?>> voidCommandHandler;\n+    private RetryScheduler mockRetryScheduler;\n+    private CommandBus commandBus;\n+\n+    @BeforeEach\n+    void setUp() {\n+        Hooks.enableContextLossTracking();\n+        Hooks.onOperatorDebug();\n+\n+        commandBus = spy(AsynchronousCommandBus.builder().build());\n+\n+        mockRetryScheduler = mock(RetryScheduler.class);\n+        commandMessageHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+\n+            private final AtomicInteger count = new AtomicInteger();\n+\n+            @Override\n+            public Object handle(CommandMessage<?> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        commandBus.subscribe(String.class.getName(), commandMessageHandler);\n+        failingCommandHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+            @Override\n+            public Object handle(CommandMessage<?> message) throws Exception {\n+                throw new RuntimeException();\n+            }\n+        });\n+\n+        voidCommandHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+            @Override\n+            public Object handle(CommandMessage<?> message) throws Exception {", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3NDM5Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457474392", "bodyText": "That's the signature of MessageHandler :)", "author": "m1l4n54v1c", "createdAt": "2020-07-20T15:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwMjMzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExMDgwOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458110808", "bodyText": "You are completely right here @m1l4n54v1c >_>", "author": "smcvb", "createdAt": "2020-07-21T13:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwMjMzMA=="}], "type": "inlineReview", "revised_code": {"commit": "30ba00c255b5a867f13c792cd330dde0bb30cc9d", "chunk": "diff --git a/messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayComponentTest.java b/messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayComponentTest.java\ndeleted file mode 100644\nindex cd7236158..000000000\n--- a/messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayComponentTest.java\n+++ /dev/null\n\n@@ -1,321 +0,0 @@\n-/*\n- * Copyright (c) 2010-2020. Axon Framework\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.axonframework.commandhandling.gateway;\n-\n-import org.axonframework.commandhandling.AsynchronousCommandBus;\n-import org.axonframework.commandhandling.CommandBus;\n-import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.commandhandling.GenericCommandResultMessage;\n-import org.axonframework.common.Registration;\n-import org.axonframework.messaging.MessageHandler;\n-import org.junit.jupiter.api.*;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Hooks;\n-import reactor.core.publisher.Mono;\n-import reactor.test.StepVerifier;\n-import reactor.util.context.Context;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.stream.IntStream;\n-\n-import static java.util.stream.Collectors.toList;\n-import static org.junit.jupiter.api.Assertions.*;\n-import static org.mockito.Mockito.*;\n-\n-/**\n- * Tests for {@link DefaultReactorCommandGateway} all together with Command Bus.\n- *\n- * @author Milan Savic\n- */\n-class DefaultReactorCommandGatewayComponentTest {\n-\n-    private DefaultReactorCommandGateway reactiveCommandGateway;\n-    private MessageHandler<CommandMessage<?>> commandMessageHandler;\n-    private MessageHandler<CommandMessage<?>> failingCommandHandler;\n-    private MessageHandler<CommandMessage<?>> voidCommandHandler;\n-    private RetryScheduler mockRetryScheduler;\n-    private CommandBus commandBus;\n-\n-    @BeforeEach\n-    void setUp() {\n-        Hooks.enableContextLossTracking();\n-        Hooks.onOperatorDebug();\n-\n-        commandBus = spy(AsynchronousCommandBus.builder().build());\n-\n-        mockRetryScheduler = mock(RetryScheduler.class);\n-        commandMessageHandler = spy(new MessageHandler<CommandMessage<?>>() {\n-\n-            private final AtomicInteger count = new AtomicInteger();\n-\n-            @Override\n-            public Object handle(CommandMessage<?> message) {\n-                if (\"backpressure\".equals(message.getPayload())) {\n-                    return count.incrementAndGet();\n-                }\n-                return \"handled\";\n-            }\n-        });\n-        commandBus.subscribe(String.class.getName(), commandMessageHandler);\n-        failingCommandHandler = spy(new MessageHandler<CommandMessage<?>>() {\n-            @Override\n-            public Object handle(CommandMessage<?> message) throws Exception {\n-                throw new RuntimeException();\n-            }\n-        });\n-\n-        voidCommandHandler = spy(new MessageHandler<CommandMessage<?>>() {\n-            @Override\n-            public Object handle(CommandMessage<?> message) throws Exception {\n-                return null;\n-            }\n-        });\n-\n-        commandBus.subscribe(Integer.class.getName(), failingCommandHandler);\n-        commandBus.subscribe(Boolean.class.getName(),\n-                             message -> \"\" + message.getMetaData().getOrDefault(\"key1\", \"\")\n-                                     + message.getMetaData().getOrDefault(\"key2\", \"\"));\n-        commandBus.subscribe(Long.class.getName(), voidCommandHandler);\n-        reactiveCommandGateway = DefaultReactorCommandGateway.builder()\n-                                                             .commandBus(commandBus)\n-                                                             .retryScheduler(mockRetryScheduler)\n-                                                             .build();\n-    }\n-\n-    @Test\n-    void testSend() throws Exception {\n-        Mono<String> result = reactiveCommandGateway.send(\"command\");\n-        verifyZeroInteractions(commandMessageHandler);\n-        StepVerifier.create(result)\n-                    .expectNext(\"handled\")\n-                    .verifyComplete();\n-        verify(commandMessageHandler).handle(any());\n-        verifyZeroInteractions(mockRetryScheduler);\n-    }\n-\n-    @Test\n-    void testSendContext() throws Exception {\n-        Mono<String> result = reactiveCommandGateway.send(\"command\");\n-        verifyZeroInteractions(commandMessageHandler);\n-\n-        Context context = Context.of(\"k1\", \"v1\");\n-\n-        StepVerifier.create(result.subscriberContext(context))\n-                .expectNext(\"handled\")\n-                .expectAccessibleContext()\n-                .containsOnly(context)\n-                .then()\n-                .verifyComplete();\n-        verify(commandMessageHandler).handle(any());\n-        verifyZeroInteractions(mockRetryScheduler);\n-    }\n-\n-    @Test\n-    void testSendVoidHandler() throws Exception {\n-        Mono<String> result = reactiveCommandGateway.send(1L);\n-        verifyZeroInteractions(voidCommandHandler);\n-        StepVerifier.create(result)\n-                .expectComplete()\n-                .verify();\n-        verify(voidCommandHandler).handle(any());\n-        verifyZeroInteractions(mockRetryScheduler);\n-    }\n-\n-\n-    @Test\n-    void testSendAll() throws Exception {\n-        Flux<Object> commands = Flux.fromIterable(Arrays.asList(\"command1\", 4, \"command2\", 5, true));\n-\n-        Flux<Object> result = reactiveCommandGateway.sendAll(commands);\n-        verifyZeroInteractions(commandMessageHandler);\n-\n-        List<Throwable> exceptions = new ArrayList<>(2);\n-        StepVerifier.create(result.onErrorContinue((t, o) -> exceptions.add(t)))\n-                    .expectNext(\"handled\", \"handled\", \"\")\n-                    .verifyComplete();\n-\n-        assertEquals(2, exceptions.size());\n-        assertTrue(exceptions.get(0) instanceof RuntimeException);\n-        assertTrue(exceptions.get(1) instanceof RuntimeException);\n-        verify(commandMessageHandler, times(2)).handle(any());\n-    }\n-\n-    @Test\n-    void testSendAllOrdering() throws Exception {\n-        int numberOfCommands = 10_000;\n-        Flux<String> commands = Flux.fromStream(IntStream.range(0, numberOfCommands)\n-                                                         .mapToObj(i -> \"backpressure\"));\n-        Flux<Object> result = reactiveCommandGateway.sendAll(commands);\n-        StepVerifier.create(result)\n-                    .expectNext(IntStream.range(1, numberOfCommands + 1)\n-                                         .boxed().toArray(Integer[]::new))\n-                    .verifyComplete();\n-        verify(commandMessageHandler, times(numberOfCommands)).handle(any());\n-    }\n-\n-    @Test\n-    void testDispatchFails() throws Exception {\n-        StepVerifier.create(reactiveCommandGateway.send(5)\n-                                                  .retry(5))\n-                    .verifyError(RuntimeException.class);\n-        verify(mockRetryScheduler, times(6)).scheduleRetry(any(), any(), anyList(), any());\n-        verify(failingCommandHandler, times(6)).handle(any());\n-    }\n-\n-    @Test\n-    void testSendWithDispatchInterceptor() {\n-        reactiveCommandGateway\n-                .registerDispatchInterceptor(cmdMono -> cmdMono\n-                        .map(cmd -> cmd.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n-        Registration registration2 = reactiveCommandGateway\n-                .registerDispatchInterceptor(cmdMono -> cmdMono\n-                        .map(cmd -> cmd.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n-\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .expectNext(\"value1value2\")\n-                    .verifyComplete();\n-\n-        registration2.cancel();\n-\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .expectNext(\"value1\")\n-                    .verifyComplete();\n-    }\n-\n-    @Test\n-    void testSendWithDispatchInterceptorWithContext() {\n-        Context context = Context.of(\"security\", true);\n-\n-        reactiveCommandGateway\n-                .registerDispatchInterceptor(cmdMono -> cmdMono\n-                        .filterWhen(v-> Mono.subscriberContext()\n-                                .filter(it-> it.hasKey(\"security\"))\n-                                .map(it->it.get(\"security\")))\n-                        .map(cmd -> cmd.andMetaData(Collections.singletonMap(\"key1\", \"value1\")))\n-                );\n-\n-        StepVerifier.create(reactiveCommandGateway.send(true)\n-                .subscriberContext(context))\n-                .expectNext(\"value1\")\n-                .expectAccessibleContext()\n-                .containsOnly(context)\n-                .then()\n-                .verifyComplete();\n-    }\n-\n-    @Test\n-    void testSendWithDispatchInterceptorWithContextFiltered() {\n-        Context context = Context.of(\"security\", false);\n-\n-        reactiveCommandGateway\n-                .registerDispatchInterceptor(cmdMono -> cmdMono\n-                        .filterWhen(v-> Mono.subscriberContext()\n-                                .filter(it-> it.hasKey(\"security\"))\n-                                .map(it->it.get(\"security\")))\n-                        .map(cmd -> cmd.andMetaData(Collections.singletonMap(\"key1\", \"value1\")))\n-                );\n-\n-        StepVerifier.create(reactiveCommandGateway.send(true).subscriberContext(context))\n-                .expectComplete()\n-                .verify();\n-    }\n-\n-    @Test\n-    void testDispatchInterceptorThrowingAnException() {\n-        reactiveCommandGateway\n-                .registerDispatchInterceptor(cmdMono -> {\n-                    throw new RuntimeException();\n-                });\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .verifyError(RuntimeException.class);\n-        verify(commandBus, times(0)).dispatch(any());\n-        verify(commandBus, times(0)).dispatch(any(), any());\n-    }\n-\n-    @Test\n-    void testDispatchInterceptorReturningErrorMono() {\n-        reactiveCommandGateway\n-                .registerDispatchInterceptor(cmdMono -> Mono.error(new RuntimeException()));\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .verifyError(RuntimeException.class);\n-        verify(commandBus, times(0)).dispatch(any());\n-        verify(commandBus, times(0)).dispatch(any(), any());\n-    }\n-\n-    @Test\n-    void testDispatchInterceptorStoppingTheFlow() {\n-        reactiveCommandGateway\n-                .registerDispatchInterceptor(cmdMono -> Mono.empty());\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .verifyComplete();\n-        verify(commandBus, times(0)).dispatch(any());\n-        verify(commandBus, times(0)).dispatch(any(), any());\n-    }\n-\n-    @Test\n-    void testSendWithResultInterceptor() {\n-        reactiveCommandGateway\n-                .registerResultHandlerInterceptor((command, results) -> results\n-                        .map(r -> new GenericCommandResultMessage<Object>(r.getPayload() + \"value1\")));\n-        Registration registration2 = reactiveCommandGateway\n-                .registerResultHandlerInterceptor((command, results) -> results\n-                        .map(r -> new GenericCommandResultMessage<Object>(r.getPayload() + \"value2\")));\n-\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .expectNext(\"value1value2\")\n-                    .verifyComplete();\n-\n-        registration2.cancel();\n-\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .expectNext(\"value1\")\n-                    .verifyComplete();\n-    }\n-\n-    @Test\n-    void testResultHandlerInterceptorThrowingAnException() {\n-        reactiveCommandGateway\n-                .registerResultHandlerInterceptor((command, results) -> {\n-                    throw new RuntimeException();\n-                });\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .verifyError(RuntimeException.class);\n-        verify(commandBus, times(1)).dispatch(any(), any());\n-    }\n-\n-    @Test\n-    void testResultHandlerInterceptorReturningErrorFlux() {\n-        reactiveCommandGateway\n-                .registerResultHandlerInterceptor((command, results) -> Flux.error(new RuntimeException()));\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .verifyError(RuntimeException.class);\n-        verify(commandBus, times(1)).dispatch(any(), any());\n-    }\n-\n-    @Test\n-    void testResultHandlerInterceptorStoppingTheFlow() {\n-        reactiveCommandGateway\n-                .registerResultHandlerInterceptor((command, results) -> Flux.empty());\n-        StepVerifier.create(reactiveCommandGateway.send(true))\n-                    .verifyComplete();\n-        verify(commandBus, times(1)).dispatch(any(), any());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwODE4Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452808182", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Sets {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n          \n          \n            \n                     * Are invoked when a result has been received.\n          \n          \n            \n                     * Sets {@link ReactorResultHandlerInterceptor}s for {@link ResultMessage}s.\n          \n          \n            \n                     * Are invoked when a result has been received.", "author": "smcvb", "createdAt": "2020-07-10T12:20:46Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);\n+    }\n+\n+    private <Q, I, U> Function<Tuple2<QueryMessage<Q, U>,\n+            Mono<SubscriptionQueryResult<QueryResponseMessage<U>, SubscriptionQueryUpdateMessage<I>>>>,\n+            Mono<SubscriptionQueryResult<I, U>>> processSubscriptionQueryResult() {\n+\n+        return messageWithResult -> messageWithResult.getT2().map(sqr -> {\n+            Mono<I> interceptedInitialResult = Mono.<QueryMessage<?, ?>>just(messageWithResult.getT1())\n+                    .zipWith(Mono.just(Flux.<ResultMessage<?>>from(sqr.initialResult())))\n+                    .flatMapMany(this::processResultsInterceptors)\n+                    .<I>transform(this::getPayload)\n+                    .next();\n+\n+            Flux<U> interceptedUpdates = Mono.<QueryMessage<?, ?>>just(messageWithResult.getT1())\n+                    .zipWith(Mono.just(sqr.updates().<ResultMessage<?>>map(it -> it)))\n+                    .flatMapMany(this::processResultsInterceptors)\n+                    .transform(this::getPayload);\n+\n+            return new DefaultSubscriptionQueryResult<>(interceptedInitialResult, interceptedUpdates, sqr);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <R> Flux<R> getPayload(Flux<ResultMessage<?>> resultMessageFlux) {\n+        return resultMessageFlux\n+                .flatMap(this::mapResult)\n+                .filter(r -> Objects.nonNull(r.getPayload()))\n+                .map(it -> (R) it.getPayload());\n+    }\n+\n+    private Flux<? extends ResultMessage<?>> mapResult(ResultMessage<?> response) {\n+        return response.isExceptional() ? Flux.error(response.exceptionResult()) : Flux.just(response);\n+    }\n+\n+    /**\n+     * Builder class to instantiate {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     */\n+    public static class Builder {\n+\n+        private QueryBus queryBus;\n+        private List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors = new CopyOnWriteArrayList<>();\n+        private List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors = new CopyOnWriteArrayList<>();\n+\n+        /**\n+         * Sets the {@link QueryBus} used to dispatch queries.\n+         *\n+         * @param queryBus a {@link QueryBus} used to dispatch queries\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        public Builder queryBus(QueryBus queryBus) {\n+            assertNonNull(queryBus, \"QueryBus may not be null\");\n+            this.queryBus = queryBus;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets {@link ReactorMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n+         * when a query is being dispatched.\n+         *\n+         * @param dispatchInterceptors which are invoked when a query is being dispatched\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        @SafeVarargs\n+        public final Builder dispatchInterceptors(\n+                ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>... dispatchInterceptors) {\n+            return dispatchInterceptors(asList(dispatchInterceptors));\n+        }\n+\n+        /**\n+         * Sets the {@link List} of {@link ReactorMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n+         * when a query is being dispatched.\n+         *\n+         * @param dispatchInterceptors which are invoked when a query is being dispatched\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        public Builder dispatchInterceptors(\n+                List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors) {\n+            this.dispatchInterceptors = dispatchInterceptors != null && dispatchInterceptors.isEmpty()\n+                    ? new CopyOnWriteArrayList<>(dispatchInterceptors)\n+                    : new CopyOnWriteArrayList<>();\n+            return this;\n+        }\n+\n+        /**\n+         * Sets {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n+         * Are invoked when a result has been received.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\nindex 080a0871b..c249fc2c0 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n\n@@ -281,7 +281,7 @@ public final Builder resultInterceptors(\n         }\n \n         /**\n-         * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n+         * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link ResultMessage}s.\n          * Are invoked when a result has been received.\n          *\n          * @param resultInterceptors which are invoked when a result has been received\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwODI5MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452808290", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n          \n          \n            \n                     * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link ResultMessage}s.", "author": "smcvb", "createdAt": "2020-07-10T12:20:59Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);\n+    }\n+\n+    private <Q, I, U> Function<Tuple2<QueryMessage<Q, U>,\n+            Mono<SubscriptionQueryResult<QueryResponseMessage<U>, SubscriptionQueryUpdateMessage<I>>>>,\n+            Mono<SubscriptionQueryResult<I, U>>> processSubscriptionQueryResult() {\n+\n+        return messageWithResult -> messageWithResult.getT2().map(sqr -> {\n+            Mono<I> interceptedInitialResult = Mono.<QueryMessage<?, ?>>just(messageWithResult.getT1())\n+                    .zipWith(Mono.just(Flux.<ResultMessage<?>>from(sqr.initialResult())))\n+                    .flatMapMany(this::processResultsInterceptors)\n+                    .<I>transform(this::getPayload)\n+                    .next();\n+\n+            Flux<U> interceptedUpdates = Mono.<QueryMessage<?, ?>>just(messageWithResult.getT1())\n+                    .zipWith(Mono.just(sqr.updates().<ResultMessage<?>>map(it -> it)))\n+                    .flatMapMany(this::processResultsInterceptors)\n+                    .transform(this::getPayload);\n+\n+            return new DefaultSubscriptionQueryResult<>(interceptedInitialResult, interceptedUpdates, sqr);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <R> Flux<R> getPayload(Flux<ResultMessage<?>> resultMessageFlux) {\n+        return resultMessageFlux\n+                .flatMap(this::mapResult)\n+                .filter(r -> Objects.nonNull(r.getPayload()))\n+                .map(it -> (R) it.getPayload());\n+    }\n+\n+    private Flux<? extends ResultMessage<?>> mapResult(ResultMessage<?> response) {\n+        return response.isExceptional() ? Flux.error(response.exceptionResult()) : Flux.just(response);\n+    }\n+\n+    /**\n+     * Builder class to instantiate {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     */\n+    public static class Builder {\n+\n+        private QueryBus queryBus;\n+        private List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors = new CopyOnWriteArrayList<>();\n+        private List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors = new CopyOnWriteArrayList<>();\n+\n+        /**\n+         * Sets the {@link QueryBus} used to dispatch queries.\n+         *\n+         * @param queryBus a {@link QueryBus} used to dispatch queries\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        public Builder queryBus(QueryBus queryBus) {\n+            assertNonNull(queryBus, \"QueryBus may not be null\");\n+            this.queryBus = queryBus;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets {@link ReactorMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n+         * when a query is being dispatched.\n+         *\n+         * @param dispatchInterceptors which are invoked when a query is being dispatched\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        @SafeVarargs\n+        public final Builder dispatchInterceptors(\n+                ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>... dispatchInterceptors) {\n+            return dispatchInterceptors(asList(dispatchInterceptors));\n+        }\n+\n+        /**\n+         * Sets the {@link List} of {@link ReactorMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n+         * when a query is being dispatched.\n+         *\n+         * @param dispatchInterceptors which are invoked when a query is being dispatched\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        public Builder dispatchInterceptors(\n+                List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors) {\n+            this.dispatchInterceptors = dispatchInterceptors != null && dispatchInterceptors.isEmpty()\n+                    ? new CopyOnWriteArrayList<>(dispatchInterceptors)\n+                    : new CopyOnWriteArrayList<>();\n+            return this;\n+        }\n+\n+        /**\n+         * Sets {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n+         * Are invoked when a result has been received.\n+         *\n+         * @param resultInterceptors which are invoked when a result has been received\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        @SafeVarargs\n+        public final Builder resultInterceptors(\n+                ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>... resultInterceptors) {\n+            return resultInterceptors(asList(resultInterceptors));\n+        }\n+\n+        /**\n+         * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\nindex 080a0871b..c249fc2c0 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n\n@@ -281,7 +281,7 @@ public final Builder resultInterceptors(\n         }\n \n         /**\n-         * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n+         * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link ResultMessage}s.\n          * Are invoked when a result has been received.\n          *\n          * @param resultInterceptors which are invoked when a result has been received\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjIwMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452812201", "bodyText": "My personal preference would go to using interceptedQuery instead of isq. The abbreviation forces people to think what the original author meant with the name.", "author": "smcvb", "createdAt": "2020-07-10T12:29:36Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4NzEwMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461387102", "bodyText": "Sad to see this hasn't been discussed or altered, but just resolved ;-)", "author": "smcvb", "createdAt": "2020-07-28T07:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjIwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\nindex 080a0871b..c249fc2c0 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n\n@@ -281,7 +281,7 @@ public final Builder resultInterceptors(\n         }\n \n         /**\n-         * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n+         * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link ResultMessage}s.\n          * Are invoked when a result has been received.\n          *\n          * @param resultInterceptors which are invoked when a result has been received\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjU3NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452812574", "bodyText": "Daaaaamn what a signature. Almost calls for type aliases to make things human readable.", "author": "smcvb", "createdAt": "2020-07-10T12:30:21Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcwNTA0NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r453705045", "bodyText": "not much we can do here, lot of complexity comes from how result interceptor works :/", "author": "schananas", "createdAt": "2020-07-13T14:48:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExMTQ4MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458111480", "bodyText": "Yep...gotcha there. Just wanted to call it out so that it (hopefully) better sticks in our minds as \"something to improve when possible\".", "author": "smcvb", "createdAt": "2020-07-21T13:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjU3NA=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\nindex 080a0871b..c249fc2c0 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n\n@@ -281,7 +281,7 @@ public final Builder resultInterceptors(\n         }\n \n         /**\n-         * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n+         * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link ResultMessage}s.\n          * Are invoked when a result has been received.\n          *\n          * @param resultInterceptors which are invoked when a result has been received\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxNDE5MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452814190", "bodyText": "My personal preference would go to using subscriptionResult instead of sqr. The abbreviation forces people to think what the original author meant with the name.", "author": "smcvb", "createdAt": "2020-07-10T12:33:29Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);\n+    }\n+\n+    private <Q, I, U> Function<Tuple2<QueryMessage<Q, U>,\n+            Mono<SubscriptionQueryResult<QueryResponseMessage<U>, SubscriptionQueryUpdateMessage<I>>>>,\n+            Mono<SubscriptionQueryResult<I, U>>> processSubscriptionQueryResult() {\n+\n+        return messageWithResult -> messageWithResult.getT2().map(sqr -> {", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4Njc4NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461386784", "bodyText": "Sad to see this hasn't been discussed or altered, but just resolved ;-)", "author": "smcvb", "createdAt": "2020-07-28T07:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxNDE5MA=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\nindex 080a0871b..c249fc2c0 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n\n@@ -281,7 +281,7 @@ public final Builder resultInterceptors(\n         }\n \n         /**\n-         * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n+         * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link ResultMessage}s.\n          * Are invoked when a result has been received.\n          *\n          * @param resultInterceptors which are invoked when a result has been received\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzMDY0MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452830640", "bodyText": "Curious/nit: Why is the lambda variable a p for the QueryUpdateEmitter#complete call? Shouldn't that be a q too?", "author": "smcvb", "createdAt": "2020-07-10T13:06:08Z", "path": "messaging/src/test/java/org/axonframework/queryhandling/DefaultReactorQueryGatewayTest.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.junit.jupiter.api.*;\n+import org.junit.jupiter.api.extension.*;\n+import org.mockito.junit.jupiter.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.util.context.Context;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.axonframework.common.ReflectionUtils.methodOf;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link DefaultReactorQueryGateway}.\n+ *\n+ * @author Milan Savic\n+ */\n+@ExtendWith(MockitoExtension.class)\n+class DefaultReactorQueryGatewayTest {\n+\n+    private DefaultReactorQueryGateway reactiveQueryGateway;\n+    private QueryUpdateEmitter queryUpdateEmitter;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler1;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler2;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler3;\n+    private SimpleQueryBus queryBus;\n+\n+    @BeforeEach\n+    void setUp() throws NoSuchMethodException {\n+        Hooks.enableContextLossTracking();\n+        Hooks.onOperatorDebug();\n+\n+        queryBus = spy(SimpleQueryBus.builder().build());\n+\n+        queryUpdateEmitter = queryBus.queryUpdateEmitter();\n+        AtomicInteger count = new AtomicInteger();\n+        queryMessageHandler1 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        queryMessageHandler2 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+\n+        queryMessageHandler3 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                throw new RuntimeException();\n+            }\n+        });\n+\n+        queryBus.subscribe(String.class.getName(), String.class, queryMessageHandler1);\n+        queryBus.subscribe(String.class.getName(), String.class, queryMessageHandler2);\n+        queryBus.subscribe(Integer.class.getName(), Integer.class, queryMessageHandler3);\n+\n+        queryBus.subscribe(Boolean.class.getName(),\n+                           String.class,\n+                           message -> \"\" + message.getMetaData().getOrDefault(\"key1\", \"\")\n+                                   + message.getMetaData().getOrDefault(\"key2\", \"\"));\n+\n+        queryBus.subscribe(Long.class.getName(), String.class, message -> null);\n+\n+        queryBus.subscribe(Double.class.getName(),\n+                           methodOf(this.getClass(), \"stringListQueryHandler\").getGenericReturnType(),\n+                           message -> Arrays.asList(\"value1\", \"value2\", \"value3\"));\n+\n+        reactiveQueryGateway = DefaultReactorQueryGateway.builder()\n+                                                         .queryBus(queryBus)\n+                                                         .build();\n+    }\n+\n+    @SuppressWarnings(\"unused\") // Used by 'testSubscriptionQueryMany()' to generate query handler response type\n+    public List<String> stringListQueryHandler() {\n+        return new ArrayList<>();\n+    }\n+\n+    @Test\n+    void testQuery() throws Exception {\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithContext() throws Exception {\n+        Context context = Context.of(\"k1\", \"v1\");\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class).subscriberContext(context);\n+\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .expectAccessibleContext()\n+                    .containsOnly(context)\n+                    .then()\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleQueries() throws Exception {\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.query(queries);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        List<Throwable> exceptions = new ArrayList<>(2);\n+        StepVerifier.create(result.onErrorContinue((t, o) -> exceptions.add(t)))\n+                    .expectNext(\"handled\", \"handled\", \"\")\n+                    .verifyComplete();\n+\n+        assertEquals(2, exceptions.size());\n+        assertTrue(exceptions.get(0) instanceof RuntimeException);\n+        assertTrue(exceptions.get(1) instanceof RuntimeException);\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleQueriesOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<QueryMessage<?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericQueryMessage<>(\"backpressure\",\n+                                                                              ResponseTypes.instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<Object> result = reactiveQueryGateway.query(queries);\n+        StepVerifier.create(result)\n+                    .expectNext(expectedResults.toArray(new Integer[0]))\n+                    .verifyComplete();\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryReturningNull() {\n+        assertNull(reactiveQueryGateway.query(0L, String.class).block());\n+        StepVerifier.create(reactiveQueryGateway.query(0L, String.class))\n+                    .expectComplete()\n+                    .verify();\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorWithContext() {\n+        Context context = Context.of(\"security\", true);\n+\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .filterWhen(v -> Mono.subscriberContext()\n+                                             .filter(ctx -> ctx.hasKey(\"security\"))\n+                                             .map(ctx -> ctx.get(\"security\")))\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class).subscriberContext(context))\n+                    .expectNext(\"value1\")\n+                    .expectAccessibleContext()\n+                    .containsOnly(context)\n+                    .then()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorAlterResult() throws Exception {\n+        reactiveQueryGateway.registerResultHandlerInterceptor((q, results) -> results\n+                .map(it -> new GenericQueryResponseMessage<>(\"handled-modified\")));\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled-modified\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorFilterResult() throws Exception {\n+        reactiveQueryGateway.registerResultHandlerInterceptor((q, results) -> results\n+                .filter(it -> !it.getPayload().equals(\"handled\")));\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectComplete()\n+                    .verify();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryFails() {\n+        StepVerifier.create(reactiveQueryGateway.query(5, Integer.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryFailsWithRetry() throws Exception {\n+\n+        Mono<Integer> query = reactiveQueryGateway.query(5, Integer.class).retry(5);\n+\n+        StepVerifier.create(query)\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler3, times(6)).handle(any());\n+    }\n+\n+\n+    @Test\n+    void testScatterGather() throws Exception {\n+        Flux<String> result = reactiveQueryGateway.scatterGather(\"criteria\",\n+                                                                 ResponseTypes.instanceOf(String.class),\n+                                                                 1,\n+                                                                 TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+        verify(queryMessageHandler2).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleScatterGather() throws Exception {\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\", \"\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleScatterGatherOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<QueryMessage<?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericQueryMessage<>(\"backpressure\",\n+                                                                              ResponseTypes.instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, 2 * numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        StepVerifier.create(result)\n+                    .expectNext(expectedResults.toArray(new Integer[0]))\n+                    .verifyComplete();\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+        verify(queryMessageHandler2, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherReturningNull() {\n+        assertNull(reactiveQueryGateway.scatterGather(0L, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS)\n+                                       .blockFirst());\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(0L, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .expectNext()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherWithResultIntercept() throws Exception {\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor(\n+                        (query, results) -> results\n+                                .map(it -> new GenericQueryResponseMessage<>(\"handled-modified\"))\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorModifyResultBasedOnQuery() throws Exception {\n+        reactiveQueryGateway.registerDispatchInterceptor(q -> q.map(it ->\n+                                                                            it.andMetaData(Collections.singletonMap(\n+                                                                                    \"block\",\n+                                                                                    it.getPayload() instanceof Boolean)\n+                                                                            )));\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor((q, results) -> results\n+                        .filter(it -> !((boolean) q.getMetaData().get(\"block\")))\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(Boolean.TRUE, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherWithResultInterceptReplacedWithError() throws Exception {\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor(\n+                        (query, results) -> results.flatMap(r -> {\n+                            if (r.getPayload().equals(\"\")) {\n+                                return Flux.<ResultMessage<?>>error(new RuntimeException(\"no empty strings allowed\"));\n+                            } else {\n+                                return Flux.just(r);\n+                            }\n+                        })\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\")\n+                    .expectError(RuntimeException.class)\n+                    .verify();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testScatterGatherFails() {\n+        StepVerifier.create(reactiveQueryGateway.scatterGather(6,\n+                                                               ResponseTypes.instanceOf(Integer.class),\n+                                                               1,\n+                                                               TimeUnit.SECONDS))\n+                    .expectNextCount(0)\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherFailsWithRetry() throws Exception {\n+        doThrow(new RuntimeException(\":(\")).when(queryBus).scatterGather(any(), anyLong(), any());\n+\n+        Flux<Integer> query = reactiveQueryGateway.scatterGather(6,\n+                                                                 ResponseTypes.instanceOf(Integer.class),\n+                                                                 1,\n+                                                                 TimeUnit.SECONDS).retry(5);\n+\n+        StepVerifier.create(query)\n+                    .verifyError();\n+\n+\n+        verify(queryBus, times(6)).scatterGather(any(), anyLong(), any());\n+    }\n+\n+\n+    @Test\n+    void testSubscriptionQuery() throws Exception {\n+        Mono<SubscriptionQueryResult<String, String>> monoResult = reactiveQueryGateway.subscriptionQuery(\"criteria\",\n+                                                                                                          String.class,\n+                                                                                                          String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        SubscriptionQueryResult<String, String> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        StepVerifier.create(result.updates()\n+                                  .doOnSubscribe(s -> {\n+                                      queryUpdateEmitter.emit(String.class, q -> true, \"update\");\n+                                      queryUpdateEmitter.complete(String.class, q -> true);\n+                                  }))\n+                    .expectNext(\"update\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleSubscriptionQueries() throws Exception {\n+        Flux<SubscriptionQueryMessage<?, ?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericSubscriptionQueryMessage<>(\"query1\",\n+                                                      ResponseTypes.instanceOf(String.class),\n+                                                      ResponseTypes.instanceOf(String.class)),\n+                new GenericSubscriptionQueryMessage<>(4,\n+                                                      ResponseTypes.instanceOf(Integer.class),\n+                                                      ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<SubscriptionQueryResult<?, ?>> result = reactiveQueryGateway.subscriptionQuery(queries);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        List<Mono<Object>> initialResults = new ArrayList<>(2);\n+        //noinspection unchecked\n+        result.subscribe(sqr -> initialResults.add((Mono<Object>) sqr.initialResult()));\n+        assertEquals(2, initialResults.size());\n+        StepVerifier.create(initialResults.get(0))\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        StepVerifier.create(initialResults.get(1))\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleSubscriptionQueriesOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<SubscriptionQueryMessage<?, ?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericSubscriptionQueryMessage<>(\"backpressure\",\n+                                                                                          ResponseTypes\n+                                                                                                  .instanceOf(String.class),\n+                                                                                          ResponseTypes\n+                                                                                                  .instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<SubscriptionQueryResult<?, ?>> result = reactiveQueryGateway.subscriptionQuery(queries);\n+        List<Mono<Object>> initialResults = new ArrayList<>(numberOfQueries);\n+        //noinspection unchecked\n+        result.subscribe(sqr -> initialResults.add((Mono<Object>) sqr.initialResult()));\n+        assertEquals(numberOfQueries, initialResults.size());\n+        for (int i = 0; i < numberOfQueries; i++) {\n+            StepVerifier.create(initialResults.get(i))\n+                        .expectNext(expectedResults.get(i))\n+                        .verifyComplete();\n+        }\n+\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryReturningNull() {\n+        SubscriptionQueryResult<String, String> result = reactiveQueryGateway.subscriptionQuery(0L,\n+                                                                                                String.class,\n+                                                                                                String.class)\n+                                                                             .block();\n+        assertNotNull(result);\n+        assertNull(result.initialResult().block());\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext()\n+                    .verifyComplete();\n+        StepVerifier.create(result.updates()\n+                                  .doOnSubscribe(s -> {\n+                                      queryUpdateEmitter.emit(Long.class, q -> true, (String) null);\n+                                      queryUpdateEmitter.complete(Long.class, q -> true);\n+                                  }))\n+                    .expectNext()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        Mono<SubscriptionQueryResult<String, String>> monoResult = reactiveQueryGateway\n+                .subscriptionQuery(true, String.class, String.class);\n+        SubscriptionQueryResult<String, String> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        monoResult = reactiveQueryGateway.subscriptionQuery(true, String.class, String.class);\n+        result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway.subscriptionQuery(true, String.class, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway.subscriptionQuery(true, String.class, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFails() {\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class);\n+        SubscriptionQueryResult<Integer, Integer> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFailsRetryInitialDispatchQuery() throws Exception {\n+\n+        doThrow(new RuntimeException(\":(\")).when(queryBus).subscriptionQuery(any(), any(), anyInt());\n+\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class)\n+                                                                                         .retry(5);\n+\n+        StepVerifier.create(monoResult)\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryBus, times(6)).subscriptionQuery(any(), any(), anyInt());\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFailsRetryInitialResult() throws Exception {\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class);\n+\n+        SubscriptionQueryResult<Integer, Integer> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult().retry(5))\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler3, times(6)).handle(any());\n+    }\n+\n+    @Test\n+    void testSubscriptionQuerySingleInitialResultAndUpdates() {\n+        Flux<String> result = reactiveQueryGateway.subscriptionQuery(\"6\", String.class);\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+\n+        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();\n+        executorService.execute(() -> {\n+            try {\n+                countDownLatch.await();\n+            } catch (InterruptedException e) {\n+                fail(e.getMessage());\n+            }\n+            queryUpdateEmitter.emit(String.class, q -> true, \"1\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"2\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"3\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"4\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"5\");\n+            queryUpdateEmitter.complete(String.class, p -> true);", "originalCommit": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcwNjg4Mw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r453706883", "bodyText": "changed to p", "author": "schananas", "createdAt": "2020-07-13T14:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzMDY0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM5MTU4Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461391587", "bodyText": "My intention was to change this to q to mirror the emit calls. But as stated, this is definitely a nit.", "author": "smcvb", "createdAt": "2020-07-28T07:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzMDY0MA=="}], "type": "inlineReview", "revised_code": {"commit": "b1184583fc50ca0b0ae81bdefc41b0a3772aa8f4", "chunk": "diff --git a/messaging/src/test/java/org/axonframework/queryhandling/DefaultReactorQueryGatewayTest.java b/messaging/src/test/java/org/axonframework/queryhandling/DefaultReactorQueryGatewayTest.java\nindex 60e5c6ed5..ebd74660c 100644\n--- a/messaging/src/test/java/org/axonframework/queryhandling/DefaultReactorQueryGatewayTest.java\n+++ b/messaging/src/test/java/org/axonframework/queryhandling/DefaultReactorQueryGatewayTest.java\n\n@@ -29,6 +29,7 @@\n import reactor.test.StepVerifier;\n import reactor.util.context.Context;\n \n+import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n"}}, {"oid": "7113d03d8dd6b9f8ba847ae6b872a9f415d88399", "url": "https://github.com/AxonFramework/AxonFramework/commit/7113d03d8dd6b9f8ba847ae6b872a9f415d88399", "message": "Extend Mono for ReactiveCallback instead of Publisher", "committedDate": "2020-07-13T14:36:08Z", "type": "commit"}, {"oid": "74bf5d23722a08b6472378bf49061e0441f55012", "url": "https://github.com/AxonFramework/AxonFramework/commit/74bf5d23722a08b6472378bf49061e0441f55012", "message": "Rename ReactiveCallback to ReactorCallback", "committedDate": "2020-07-13T14:37:53Z", "type": "commit"}, {"oid": "1386c0f757f80e3c178f2f68452fe2a4c8c32aed", "url": "https://github.com/AxonFramework/AxonFramework/commit/1386c0f757f80e3c178f2f68452fe2a4c8c32aed", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-13T14:45:47Z", "type": "commit"}, {"oid": "924dec53a5a27af4adfaf5a9e622ca6b005dd7c2", "url": "https://github.com/AxonFramework/AxonFramework/commit/924dec53a5a27af4adfaf5a9e622ca6b005dd7c2", "message": "Update axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-13T14:52:22Z", "type": "commit"}, {"oid": "b215bbdc42cb50cc79fc3d4581c5f960f96f1066", "url": "https://github.com/AxonFramework/AxonFramework/commit/b215bbdc42cb50cc79fc3d4581c5f960f96f1066", "message": "Update messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-13T15:06:38Z", "type": "commit"}, {"oid": "9a058a0221303d8e1b0c400c3b080d4724b8b348", "url": "https://github.com/AxonFramework/AxonFramework/commit/9a058a0221303d8e1b0c400c3b080d4724b8b348", "message": "Update messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-13T15:06:58Z", "type": "commit"}, {"oid": "f609554f36164a88fec7563533a8a18a095d6478", "url": "https://github.com/AxonFramework/AxonFramework/commit/f609554f36164a88fec7563533a8a18a095d6478", "message": "Update messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-13T15:07:16Z", "type": "commit"}, {"oid": "ffb61b6bf7ddfb7bda8d32c45f6d57c9aedccab0", "url": "https://github.com/AxonFramework/AxonFramework/commit/ffb61b6bf7ddfb7bda8d32c45f6d57c9aedccab0", "message": "Update messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-13T15:07:43Z", "type": "commit"}, {"oid": "02688581e2cf74452505996da9c6dad7b2fc2f2d", "url": "https://github.com/AxonFramework/AxonFramework/commit/02688581e2cf74452505996da9c6dad7b2fc2f2d", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-13T15:14:14Z", "type": "commit"}, {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e", "url": "https://github.com/AxonFramework/AxonFramework/commit/3697d15e2f6025bbb49a23e02e7c24c79f341d2e", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-13T15:14:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI5OTg4OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457299888", "bodyText": "Is a new Mono needed here, or can Function.identity() be used instead of Mono::from?", "author": "sandjelkovic", "createdAt": "2020-07-20T11:32:03Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);", "originalCommit": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3NzM3OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457477378", "bodyText": "Not sure I follow how you'd use Function.identity() in this case. Could you provide an example?", "author": "m1l4n54v1c", "createdAt": "2020-07-20T15:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI5OTg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMzUxMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457513511", "bodyText": "Since at this point when flatMap is called, the variable is of type Mono<Mono<CommandMessage<?>>>. Unless there's a special reason to use Mono.from to create another Mono from a Mono (wrapping inner one), it can be simplified to flatMap(it -> it) to use the already existing inner Mono instance directly. In this case, Function.identity() would replace it -> it lambda expression, same as here", "author": "sandjelkovic", "createdAt": "2020-07-20T15:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI5OTg4OA=="}], "type": "inlineReview", "revised_code": {"commit": "65a12c975a900e96412a6b2f2c5fa222cbcb07a1", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\nindex 98b7749b9..6ffd7b0de 100644\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\n+++ b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\n\n@@ -29,6 +29,7 @@\n import java.util.List;\n import java.util.Objects;\n import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.function.Function;\n \n import static java.util.Arrays.asList;\n import static org.axonframework.common.BuilderUtils.assertNonNull;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMwNDYzOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457304638", "bodyText": "Can this be a Mono<CommandResultMessage<? extends R>> instead of Flux<CommandResultMessage<? extends R>>.\nFor a full return value signature of Mono<Tuple2<CommandMessage<C>, Mono<CommandResultMessage<? extends R>>>>", "author": "sandjelkovic", "createdAt": "2020-07-20T11:39:51Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(", "originalCommit": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3ODU3MQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457478571", "bodyText": "No, since result interceptors work with a flux.", "author": "m1l4n54v1c", "createdAt": "2020-07-20T15:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMwNDYzOA=="}], "type": "inlineReview", "revised_code": {"commit": "65a12c975a900e96412a6b2f2c5fa222cbcb07a1", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\nindex 98b7749b9..6ffd7b0de 100644\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\n+++ b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\n\n@@ -29,6 +29,7 @@\n import java.util.List;\n import java.util.Objects;\n import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.function.Function;\n \n import static java.util.Arrays.asList;\n import static org.axonframework.common.BuilderUtils.assertNonNull;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMxMDY2NQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457310665", "bodyText": "Considering that Command handling can provide only one result, shouldn't this also be a Mono<CommandResultMessage<?>> instead of a Flux<CommandResultMessage<?>>?", "author": "sandjelkovic", "createdAt": "2020-07-20T11:48:55Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactorCallback<C, R> reactorCallback = new ReactorCallback<>();\n+        CommandCallback<C, R> callback = reactorCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactorCallback)));\n+    }\n+\n+    private <C> Mono<? extends CommandResultMessage<?>> processResultsInterceptors(\n+            Tuple2<CommandMessage<C>, Flux<CommandResultMessage<?>>> commandWithResults) {", "originalCommit": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3OTcyMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457479722", "bodyText": "The same reason I stated for the previous comment.", "author": "m1l4n54v1c", "createdAt": "2020-07-20T15:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMxMDY2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "65a12c975a900e96412a6b2f2c5fa222cbcb07a1", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\nindex 98b7749b9..6ffd7b0de 100644\n--- a/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\n+++ b/messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java\n\n@@ -29,6 +29,7 @@\n import java.util.List;\n import java.util.Objects;\n import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.function.Function;\n \n import static java.util.Arrays.asList;\n import static org.axonframework.common.BuilderUtils.assertNonNull;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMyMjA2Mw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457322063", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                               .flatMapMany(it -> it);\n          \n          \n            \n                               .flatMapMany(Function.identity());", "author": "sandjelkovic", "createdAt": "2020-07-20T12:05:57Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);", "originalCommit": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a405b511d9d26bacc42f8d2c437a834b4f0fd5c4", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\nindex c249fc2c0..ab2eabe46 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n\n@@ -268,7 +268,7 @@ public Builder dispatchInterceptors(\n         }\n \n         /**\n-         * Sets {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n+         * Sets {@link ReactorResultHandlerInterceptor}s for {@link ResultMessage}s.\n          * Are invoked when a result has been received.\n          *\n          * @param resultInterceptors which are invoked when a result has been received\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMyNjUzOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457326538", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n          \n          \n            \n                 * Should be used when initial result contains multiple instances of response type and needs to be flattened.", "author": "sandjelkovic", "createdAt": "2020-07-20T12:12:39Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses the given {@link Publisher} of {@link QueryMessage}s to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially. Once the result of Nth query arrives, the (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a {@link Publisher} stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.", "originalCommit": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex ec492e77e..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -106,11 +106,11 @@\n     <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n \n     /**\n-     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n-     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     * Use the given {@link Publisher} of {@link QueryMessage}s to send the incoming queries away. Queries will be sent sequentially. Once the\n+     * result of the Nth query arrives, the (N + 1)th query is dispatched.\n      *\n-     * @param queries a Publisher stream of queries to be dispatched\n-     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * @param queries a {@link Publisher} stream of queries to be dispatched\n+     * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n      * dispatched\n      *\n      * @see #query(String, Object, ResponseType)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMyOTcwNw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457329707", "bodyText": "Is it possible to use Duration instead of long timeout, TimeUnit timeUnit for the public interface and convert/split to TimeUnit and long for QueryBus's needs?", "author": "sandjelkovic", "createdAt": "2020-07-20T12:17:25Z", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {", "originalCommit": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ4MTUyMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457481521", "bodyText": "yes! good suggestion!", "author": "m1l4n54v1c", "createdAt": "2020-07-20T15:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMyOTcwNw=="}], "type": "inlineReview", "revised_code": {"commit": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\nindex ec492e77e..64652aa1d 100644\n--- a/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n+++ b/messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\n@@ -106,11 +106,11 @@\n     <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n \n     /**\n-     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n-     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     * Use the given {@link Publisher} of {@link QueryMessage}s to send the incoming queries away. Queries will be sent sequentially. Once the\n+     * result of the Nth query arrives, the (N + 1)th query is dispatched.\n      *\n-     * @param queries a Publisher stream of queries to be dispatched\n-     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * @param queries a {@link Publisher} stream of queries to be dispatched\n+     * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n      * dispatched\n      *\n      * @see #query(String, Object, ResponseType)\n"}}, {"oid": "207abde71f84524f00fc85fe6f0b24616a2f4949", "url": "https://github.com/AxonFramework/AxonFramework/commit/207abde71f84524f00fc85fe6f0b24616a2f4949", "message": "Update messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>", "committedDate": "2020-07-20T13:53:28Z", "type": "commit"}]}