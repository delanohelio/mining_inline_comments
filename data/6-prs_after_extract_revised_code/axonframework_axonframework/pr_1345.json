{"pr_number": 1345, "pr_title": "[#891] Graceful Start up and Shutdown API", "pr_createdAt": "2020-02-12T16:05:21Z", "pr_url": "https://github.com/AxonFramework/AxonFramework/pull/1345", "timeline": [{"oid": "88365728e181ea508137a563edc0104b63c4630f", "url": "https://github.com/AxonFramework/AxonFramework/commit/88365728e181ea508137a563edc0104b63c4630f", "message": "Introduce the lifecycle package\n\nIntroduce the lifecycle package, containing a StartHandler and\nShutdownHandler annotation. A utility class should be provided to\ncontain some phases, as well as an exception dedicated to a failing\nlifecycle handler method.\n\n#891", "committedDate": "2020-02-04T13:05:00Z", "type": "commit"}, {"oid": "23ddfe193889754242dc10d1b02d15484a597db7", "url": "https://github.com/AxonFramework/AxonFramework/commit/23ddfe193889754242dc10d1b02d15484a597db7", "message": "Add the LifecycleHandler, it's registration and invocation\n\nAdjust the Configuration API to introduce an onStart/onShutdown which\ntakes in the LifecycleHandler functional interface. The collections of\nstart and shutdown handlers should become TreeMaps taking in the phase\nas the ordering parameter. A failure during start should result in\nthrowing a LifecycleHandlerInvocationException and initiations of the\nshutdown process. During shutdown the failure should be logged.\nLastly, init handlers no longer need to be phased, and start/shutdown\nhandlers added out of order should be given precedence.\n\n#891", "committedDate": "2020-02-04T13:36:09Z", "type": "commit"}, {"oid": "2ac02f93144ef3c9f3d81fce100099aadbba26b1", "url": "https://github.com/AxonFramework/AxonFramework/commit/2ac02f93144ef3c9f3d81fce100099aadbba26b1", "message": "Introduce the LifecycleHandlerInspector\n\nThe LifecycleHandlerInspector will inspect the instances created in the\nComponent for StartHandler/ShutdownHandler annotated methods without\nparameters. If those are present, they'll be registered to the\nConfiguration's onStart/onShutdown methods.\n\n#891", "committedDate": "2020-02-04T13:38:30Z", "type": "commit"}, {"oid": "3fc92c92868392b9797ba4d468156fe5f62d0e84", "url": "https://github.com/AxonFramework/AxonFramework/commit/3fc92c92868392b9797ba4d468156fe5f62d0e84", "message": "Drop phasing logic for registering command/query handlers\n\nThe Configurer should no longer allow phased registration of a\ncommand/query handler, as the phase is now defined on a\nStartHandler/ShutdownHandler.\n\n#891", "committedDate": "2020-02-04T14:14:26Z", "type": "commit"}, {"oid": "bc8d15ec63b60d51d426321d2f07802703d93d45", "url": "https://github.com/AxonFramework/AxonFramework/commit/bc8d15ec63b60d51d426321d2f07802703d93d45", "message": "Deprecate several methods from the ModuleConfiguration\n\nThe ModuleConfiguration currently partakes in the start/shutdown cycle\nentirely, by providing a start(), shutdown() and phase() method. All\nimpls of the ModuleConfiguration should however add LifecycleHandlers in\n the initialize method instead, to keep the Component +\n LifecycleHandlerInspector in charge of this task\n\n#891", "committedDate": "2020-02-04T14:18:00Z", "type": "commit"}, {"oid": "4ccbf1dfee2778f2799f26a236b8e3289b115efd", "url": "https://github.com/AxonFramework/AxonFramework/commit/4ccbf1dfee2778f2799f26a236b8e3289b115efd", "message": "Adjust AggregateConfigurer according to deprecated methods\n\nAs an implementation of the ModuleConfiguration, the AggregateConfigurer\n should no longer have a start/shutdown method, but instead register the\n aggregates command handlers as lifecycle handlers to the configuration\n directly. Also, the configureAggregate method can be delegated through\n to the registerModule method, since the DefaultConfigurer has no need\n to keep both a modules and aggregateConfigurers collection\n\n#891", "committedDate": "2020-02-04T14:20:43Z", "type": "commit"}, {"oid": "eb302fb7efcf8d836018443a9f6d025a1725648a", "url": "https://github.com/AxonFramework/AxonFramework/commit/eb302fb7efcf8d836018443a9f6d025a1725648a", "message": "Remove start/shutdown methods from the EventProcessingModule\n\nAs a ModuleConfiguration implementation, the EventProcessingModule\nshould register start/shutdown handlers in the initialize method. Due to\n a discrepancy with Axon's Spring config, we add a start handler to\n create the EventProcessors in the earliest phase.\n\n#891", "committedDate": "2020-02-04T14:23:30Z", "type": "commit"}, {"oid": "be5b9f03e17a6378c998dc21528cc835885506ae", "url": "https://github.com/AxonFramework/AxonFramework/commit/be5b9f03e17a6378c998dc21528cc835885506ae", "message": "Remove remaining impls of deprecated ModuleConfiguration methods\n\nRemove all remaining implementations of ModuleConfiguration#start() and\nModuleConfiguration#shutdown() in favor of adding lifecycle handlers to\nthe Configuration upon initialization of the module\n\n#891", "committedDate": "2020-02-04T14:25:45Z", "type": "commit"}, {"oid": "36a768f03069ae3fd8dc5b96dedb597a326d82cd", "url": "https://github.com/AxonFramework/AxonFramework/commit/36a768f03069ae3fd8dc5b96dedb597a326d82cd", "message": "Align AxonConfiguration with the new API\n\nAlign the AxonConfiguration with the new LifecycleHandler API\n\n#891", "committedDate": "2020-02-04T14:26:22Z", "type": "commit"}, {"oid": "b10c56512c7dcb97202d72b16691b453ec0bf646", "url": "https://github.com/AxonFramework/AxonFramework/commit/b10c56512c7dcb97202d72b16691b453ec0bf646", "message": "Add tests, adjust tests and fix some ParameterResolver logic\n\nAll the API changes should not have any impact on the existing tests.\nHowever, Spring's wiring logic combined with the\nSpringBeanParameterResolverFactory caused for issues. Additionally,\ntests should be introduced to cover the changed lifecycle logic in the\nDefaultConfigurer, as well as the removal of init-ordering tests in the\nDefaultConfigurerTest class\n\n#891", "committedDate": "2020-02-04T14:29:27Z", "type": "commit"}, {"oid": "d55f22666fa20e2b90d40c1d10375b5637ada4a9", "url": "https://github.com/AxonFramework/AxonFramework/commit/d55f22666fa20e2b90d40c1d10375b5637ada4a9", "message": "Add start/shutdown handlers to AS-Connector ModuleConfiguration comp's\n\nAdd StartHandler/ShutdownHandler annotations to AxonServerConnector\ncomponents build through ModuleConfigurations. Since this is additional\nlogic, they start last and shutdown first by using phase\nINBOUND_EVENT_CONNECTORS + 1\n\n#891", "committedDate": "2020-02-04T14:35:35Z", "type": "commit"}, {"oid": "1b478d6284f91ee5a493479d7deae8418e3d2708", "url": "https://github.com/AxonFramework/AxonFramework/commit/1b478d6284f91ee5a493479d7deae8418e3d2708", "message": "Add lifecycle handlers to deadline managers and event schedulers\n\nAdd lifecycle handlers to deadline managers and event schedulers in the\nINBOUND_EVENT_CONNECTORS phase\n\n#891", "committedDate": "2020-02-04T14:40:05Z", "type": "commit"}, {"oid": "f56db8079bbaf31f3171555b1b2f0e8ea1716d3e", "url": "https://github.com/AxonFramework/AxonFramework/commit/f56db8079bbaf31f3171555b1b2f0e8ea1716d3e", "message": "Add lifecycle handlers to the EventProcessor implementations\n\nAdd lifecycle handler annotations to the start/shutdown of the\nSubscribingEventProcessor and TrackingEventProcessor. As the\nSubscribingEventProcessor technically belongs to the\n\"LOCAL_COMMAND_OR_QUERY_REGISTRATIONS\", rename that constant to general\nmessage handler registration\n\n#891", "committedDate": "2020-02-04T15:52:01Z", "type": "commit"}, {"oid": "3f22b93b5237265cc5922f10c30179f8ecf8e497", "url": "https://github.com/AxonFramework/AxonFramework/commit/3f22b93b5237265cc5922f10c30179f8ecf8e497", "message": "Maintain lifecycle state in the DefaultConfigurer\n\nThe DefaultConfigurer should maintain the lifecycle state, as otherwise\nwe cannot deduce whether a startHandler or shutdownHandler should be\ncalled immediately instead of just added to the map\n\n#891", "committedDate": "2020-02-06T09:42:29Z", "type": "commit"}, {"oid": "5ee7961453248a5c891bdaaba36001e01da38bea", "url": "https://github.com/AxonFramework/AxonFramework/commit/5ee7961453248a5c891bdaaba36001e01da38bea", "message": "Merge remote-tracking branch 'origin/master' into feature/891", "committedDate": "2020-02-06T09:42:42Z", "type": "commit"}, {"oid": "5bc406d53dccdf38f404639777ef76320436edb2", "url": "https://github.com/AxonFramework/AxonFramework/commit/5bc406d53dccdf38f404639777ef76320436edb2", "message": "Change phase numbering\n\nChange the Phase numbers\n\n#891", "committedDate": "2020-02-06T09:53:11Z", "type": "commit"}, {"oid": "e6f03a306dd1ebd03318a34e829de99471177aed", "url": "https://github.com/AxonFramework/AxonFramework/commit/e6f03a306dd1ebd03318a34e829de99471177aed", "message": "Change LifecycleState from Life to Up\n\nChange LifecycleState from Life to Up\n\n#891", "committedDate": "2020-02-06T10:17:16Z", "type": "commit"}, {"oid": "bf31629839fd86a97ed23823b8af9d601e3f0e8b", "url": "https://github.com/AxonFramework/AxonFramework/commit/bf31629839fd86a97ed23823b8af9d601e3f0e8b", "message": "Merge remote-tracking branch 'origin/master' into feature/891", "committedDate": "2020-02-07T11:07:47Z", "type": "commit"}, {"oid": "db5575c27173caba393907b9cbef035c8a035bd8", "url": "https://github.com/AxonFramework/AxonFramework/commit/db5575c27173caba393907b9cbef035c8a035bd8", "message": "Added shutdown handlers to AxonServerEventStore.", "committedDate": "2020-02-07T16:45:29Z", "type": "commit"}, {"oid": "cd7c74a021212ff64a1c245a60ac7e676a542c4e", "url": "https://github.com/AxonFramework/AxonFramework/commit/cd7c74a021212ff64a1c245a60ac7e676a542c4e", "message": "Merge remote-tracking branch 'origin/feature/891' into feature/891", "committedDate": "2020-02-07T16:45:50Z", "type": "commit"}, {"oid": "835180f9ba3816058f524ccc2cd3fe20429d0a50", "url": "https://github.com/AxonFramework/AxonFramework/commit/835180f9ba3816058f524ccc2cd3fe20429d0a50", "message": "Graceful shutdown - unregister pending transactions and listening stream observer once they are completed.", "committedDate": "2020-02-11T08:52:54Z", "type": "commit"}, {"oid": "9febc7797528c8a57090a95fc6f82e16195c66fe", "url": "https://github.com/AxonFramework/AxonFramework/commit/9febc7797528c8a57090a95fc6f82e16195c66fe", "message": "Graceful shutdown - DistributedCommandBus.", "committedDate": "2020-02-11T11:17:44Z", "type": "commit"}, {"oid": "614b274e1daf6774a132df2f13b09741d250955c", "url": "https://github.com/AxonFramework/AxonFramework/commit/614b274e1daf6774a132df2f13b09741d250955c", "message": "Remove destroy handlers for AS Command and Query bus\n\nThe lifecycle operations will be added through the Start/ShutdownHandler\n annotations. Thus, the bean destroyMethod references and the disconnect\n calls no longer have to be added manually\n\n#891", "committedDate": "2020-02-11T13:03:17Z", "type": "commit"}, {"oid": "971da59eec92d17dfc8879c47ee13c68a090c44e", "url": "https://github.com/AxonFramework/AxonFramework/commit/971da59eec92d17dfc8879c47ee13c68a090c44e", "message": "Merge remote-tracking branch 'origin/master' into feature/891", "committedDate": "2020-02-11T14:16:50Z", "type": "commit"}, {"oid": "5db1b544cd3946c191405ba9d2c939facc6878c9", "url": "https://github.com/AxonFramework/AxonFramework/commit/5db1b544cd3946c191405ba9d2c939facc6878c9", "message": "Added a handler to CommandCallbackRepository to be invoked once a callback has been removed from the repository.", "committedDate": "2020-02-12T14:34:11Z", "type": "commit"}, {"oid": "e784c7f933847517e7ad5749bf96d7443ef81dab", "url": "https://github.com/AxonFramework/AxonFramework/commit/e784c7f933847517e7ad5749bf96d7443ef81dab", "message": "Introduce shutdown handlers\n\nIntroduce shutdown handlers in the AxonServerCommandBus. Firstly,\ncommand receiving from the outside world should be closed off, by\nunsubscribing all handlers and disconnecting the receiving end. In a\nfollow up phase, the sending of commands should be closed, being\nmindful of commands which are still in transit\n\n#891", "committedDate": "2020-02-12T14:39:24Z", "type": "commit"}, {"oid": "54bb2e4c06071a3fc1d25ccfec10f70b7a3c50fe", "url": "https://github.com/AxonFramework/AxonFramework/commit/54bb2e4c06071a3fc1d25ccfec10f70b7a3c50fe", "message": "Introduce shutdown handlers\n\nIntroduce shutdown handlers in the AxonServerQueryBus. Firstly,\nquery receiving from the outside world should be closed off, by\nunsubscribing all handlers and disconnecting the receiving end. In a\nfollow up phase, the sending of queries should be closed, being\nmindful of queries which are still in transit\n\n#891", "committedDate": "2020-02-12T14:40:43Z", "type": "commit"}, {"oid": "7d98eb3abc7c6c0bd0dd4dad270d4f57e02b5af0", "url": "https://github.com/AxonFramework/AxonFramework/commit/7d98eb3abc7c6c0bd0dd4dad270d4f57e02b5af0", "message": "Merge remote-tracking branch 'origin/feature/891' into feature/891", "committedDate": "2020-02-12T14:40:53Z", "type": "commit"}, {"oid": "26a2a0c6d60d468f30e2e12202dbedb123d1f125", "url": "https://github.com/AxonFramework/AxonFramework/commit/26a2a0c6d60d468f30e2e12202dbedb123d1f125", "message": "Merge remote-tracking branch 'origin/master' into feature/891", "committedDate": "2020-02-12T14:44:23Z", "type": "commit"}, {"oid": "41bd1422a22637018226baba4c1530c147003afa", "url": "https://github.com/AxonFramework/AxonFramework/commit/41bd1422a22637018226baba4c1530c147003afa", "message": "Merge remote-tracking branch 'origin/master' into feature/891", "committedDate": "2020-02-12T14:47:34Z", "type": "commit"}, {"oid": "d984819518ed796aefedbded6a13fa50e0234f32", "url": "https://github.com/AxonFramework/AxonFramework/commit/d984819518ed796aefedbded6a13fa50e0234f32", "message": "Test fix\n\nThe tests might be fast, meaning that the command/query was already\nhandled since the shutdown was already resolved. Guard for this in the\ntests\n\n#891", "committedDate": "2020-02-12T16:08:22Z", "type": "commit"}, {"oid": "87d2f21799216859f6d3b46251ff805f15abe397", "url": "https://github.com/AxonFramework/AxonFramework/commit/87d2f21799216859f6d3b46251ff805f15abe397", "message": "Add shutdown tests\n\nAdd shutdown tests cases\n\n#891", "committedDate": "2020-02-13T08:58:51Z", "type": "commit"}, {"oid": "8c61363f349918fff089ea4647b4bbd629289730", "url": "https://github.com/AxonFramework/AxonFramework/commit/8c61363f349918fff089ea4647b4bbd629289730", "message": "Removed a handler to CommandCallbackRepository to be invoked once a callback has been removed from the repository.\nAdded a return value to cancelling callbacks for a channel.", "committedDate": "2020-02-13T10:20:34Z", "type": "commit"}, {"oid": "29eaa93b873df27ace981f3b6da418f620160e94", "url": "https://github.com/AxonFramework/AxonFramework/commit/29eaa93b873df27ace981f3b6da418f620160e94", "message": "Merge remote-tracking branch 'origin/feature/891' into feature/891", "committedDate": "2020-02-13T10:20:53Z", "type": "commit"}, {"oid": "778db2406b43c4ec4df729e96ded6ed69ece98ff", "url": "https://github.com/AxonFramework/AxonFramework/commit/778db2406b43c4ec4df729e96ded6ed69ece98ff", "message": "Merge remote-tracking branch 'origin/master' into feature/891\n\n# Conflicts:\n#\taxon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "committedDate": "2020-02-13T13:54:28Z", "type": "commit"}, {"oid": "0834d2ab67497ad7987112546c5e1dc7fa74daeb", "url": "https://github.com/AxonFramework/AxonFramework/commit/0834d2ab67497ad7987112546c5e1dc7fa74daeb", "message": "Add some additional logging\n\nAs is suggested in issue #713, it would be beneficial to have some\nadditional debug logging during configuration, start up and shutdown. As\n the lifecycle handler approach is being revised in #891, adding logging\n along the way is relatively trivial. Hence, debug statements should be\n added when a component is created and configured, when a module\n configuration is configured, when start/shutdown handlers are being\n  called and in which phase of the cycle we are.\n\n#891 & #713", "committedDate": "2020-02-13T14:58:45Z", "type": "commit"}, {"oid": "2dfa3b11e1824f932ecd6ac8cbf8f471b2e4efb3", "url": "https://github.com/AxonFramework/AxonFramework/commit/2dfa3b11e1824f932ecd6ac8cbf8f471b2e4efb3", "message": "Slight logging improvements\n\nSlight logging improvements\n\n#891", "committedDate": "2020-02-13T16:09:18Z", "type": "commit"}, {"oid": "bb3388934ab774e306ca374e506623a209d19475", "url": "https://github.com/AxonFramework/AxonFramework/commit/bb3388934ab774e306ca374e506623a209d19475", "message": "Introduce instruction component phase\n\nIntroduce a phase which is dedicated for starting up and shutting down\ncomponents which deal with instructions of components\n\n#891", "committedDate": "2020-02-14T15:46:05Z", "type": "commit"}, {"oid": "cdaec2cba51b92411027b6b4c031b51e431a80f6", "url": "https://github.com/AxonFramework/AxonFramework/commit/cdaec2cba51b92411027b6b4c031b51e431a80f6", "message": "Change shutdown phase\n\nChange the shutdown phase of the AxonServerConnectionManager to be the\nlast. Introduce a dedicated phase for this to be overly specific about\nit's use case\n\n#891", "committedDate": "2020-02-14T15:47:01Z", "type": "commit"}, {"oid": "6c9bca1ef700a248a24719d046a0fea41f1835e1", "url": "https://github.com/AxonFramework/AxonFramework/commit/6c9bca1ef700a248a24719d046a0fea41f1835e1", "message": "Introduce the ShutdownLatch\n\nIntroduce the ShutdownLatch class to be used to wait until a defined set\n of operations has completed\n\n#891", "committedDate": "2020-02-14T15:48:04Z", "type": "commit"}, {"oid": "7566c222c13c933738d2d4f1170e4c619bfa5b43", "url": "https://github.com/AxonFramework/AxonFramework/commit/7566c222c13c933738d2d4f1170e4c619bfa5b43", "message": "Drop shutdown logic from the Axon Server Event Store\n\nDrop shutdown logic from the Axon Server Event Store, as this will stop\non it's own once all incoming channels for commands and queries have\nbeen closed off\n\n#891", "committedDate": "2020-02-14T15:55:32Z", "type": "commit"}, {"oid": "2be21d37af5cff71eaf60fd488c5faaa2b51d013", "url": "https://github.com/AxonFramework/AxonFramework/commit/2be21d37af5cff71eaf60fd488c5faaa2b51d013", "message": "Streamline shutdown process\n\nThe shutdown process within the AxonServerCommandBus can be streamlined:\n-Use the ShutdownLatch i.o. the boolean shuttingDown and the list of\ncompletable futures. This is should be cleaner and more efficient\n-Drop the disconnectAsync call entirely, as the disconnect operation\nwill be pretty quick\n-Change the wait period on the CommandProcessor to first wait 5 seconds,\n and after that only 30 seconds more\n\n#891", "committedDate": "2020-02-14T15:57:41Z", "type": "commit"}, {"oid": "020652e3db2c75909843c4e53fa12ae34771cec0", "url": "https://github.com/AxonFramework/AxonFramework/commit/020652e3db2c75909843c4e53fa12ae34771cec0", "message": "Streamline shutdown process\n\nThe shutdown process within the AxonServerQueryBus can be streamlined:\n-Use the ShutdownLatch i.o. the boolean shuttingDown and the list of\ncompletable futures. This is should be cleaner and more efficient\n-Drop the disconnectAsync call entirely, as the disconnect operation\nwill be pretty quick\n-Change the wait period on the QueryProcessor to first wait 5 seconds,\n and after that only 30 seconds more\n\n#891", "committedDate": "2020-02-14T15:58:17Z", "type": "commit"}, {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "url": "https://github.com/AxonFramework/AxonFramework/commit/2ef829cce30a13105fe9c1d1398f2e0141393a13", "message": "Remove manual shutdown hook introduction\n\nRemove manual shutdown hook introduction of the\nAxonServerConnectionManager as this is now dealt with through the\nLifecycleHandlerInspector\n\n#891", "committedDate": "2020-02-14T15:58:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MTk4Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379851987", "bodyText": "Suggestion: rename to ifShuttingDown, similar to Optional's ifPresent(...) method.", "author": "abuijze", "createdAt": "2020-02-15T19:45:57Z", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -276,6 +283,10 @@ private void unsubscribe() {\n \n     private <C, R> void doDispatch(CommandMessage<C> commandMessage,\n                                    CommandCallback<? super C, ? super R> commandCallback) {\n+        shutdownLatch.isShuttingDown(", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1NTYwNw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380055607", "bodyText": "Good call, will do.", "author": "smcvb", "createdAt": "2020-02-17T09:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MTk4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\nindex 6882f4714..caffe420f 100644\n--- a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\n+++ b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\n\n@@ -283,71 +283,67 @@ private void unsubscribe() {\n \n     private <C, R> void doDispatch(CommandMessage<C> commandMessage,\n                                    CommandCallback<? super C, ? super R> commandCallback) {\n-        shutdownLatch.isShuttingDown(\n+        shutdownLatch.ifShuttingDown(\n                 () -> new IllegalStateException(\"Cannot dispatch new commands as this bus is being shutdown\")\n         );\n \n+        ShutdownLatch.ActivityHandle commandInTransit = shutdownLatch.registerActivity();\n         AtomicBoolean serverResponded = new AtomicBoolean(false);\n         try {\n             String context = targetContextResolver.resolveContext(commandMessage);\n             Command command = serializer.serialize(commandMessage,\n                                                    routingStrategy.getRoutingKey(commandMessage),\n                                                    priorityCalculator.determinePriority(commandMessage));\n+            CommandServiceGrpc.CommandServiceStub commandService =\n+                    CommandServiceGrpc.newStub(axonServerConnectionManager.getChannel(context));\n \n-            CommandServiceGrpc\n-                    .newStub(axonServerConnectionManager.getChannel(context))\n-                    .dispatch(command,\n-                              new StreamObserver<CommandResponse>() {\n-                                  @Override\n-                                  public void onNext(CommandResponse commandResponse) {\n-                                      serverResponded.set(true);\n-                                      logger.debug(\"Received command response [{}]\", commandResponse);\n-\n-                                      try {\n-                                          CommandResultMessage<R> resultMessage =\n-                                                  serializer.deserialize(commandResponse);\n-                                          commandCallback.onResult(commandMessage, resultMessage);\n-                                      } catch (Exception ex) {\n-                                          commandCallback.onResult(commandMessage, asCommandResultMessage(ex));\n-                                          logger.info(\"Failed to deserialize payload [{}] - Cause: {}\",\n-                                                      commandResponse.getPayload().getData(),\n-                                                      ex.getCause().getMessage());\n-                                      }\n-                                  }\n-\n-                                  @Override\n-                                  public void onError(Throwable throwable) {\n-                                      serverResponded.set(true);\n-                                      commandCallback.onResult(commandMessage, asCommandResultMessage(\n-                                              ErrorCode.COMMAND_DISPATCH_ERROR.convert(\n-                                                      configuration.getClientId(), throwable\n-                                              )\n-                                      ));\n-                                      shutdownLatch.decrement();\n-                                  }\n-\n-                                  @Override\n-                                  public void onCompleted() {\n-                                      if (!serverResponded.get()) {\n-                                          ErrorMessage errorMessage =\n-                                                  ErrorMessage.newBuilder()\n-                                                              .setMessage(\"No result from command executor\")\n-                                                              .build();\n-                                          commandCallback.onResult(commandMessage, asCommandResultMessage(\n-                                                  ErrorCode.COMMAND_DISPATCH_ERROR.convert(errorMessage))\n-                                          );\n-                                      }\n-                                      shutdownLatch.decrement();\n-                                  }\n-                              }\n-                    );\n-            shutdownLatch.increment();\n+            commandService.dispatch(command, new StreamObserver<CommandResponse>() {\n+                @Override\n+                public void onNext(CommandResponse commandResponse) {\n+                    serverResponded.set(true);\n+                    logger.debug(\"Received command response [{}]\", commandResponse);\n+\n+                    try {\n+                        CommandResultMessage<R> resultMessage = serializer.deserialize(commandResponse);\n+                        commandCallback.onResult(commandMessage, resultMessage);\n+                    } catch (Exception ex) {\n+                        commandCallback.onResult(commandMessage, asCommandResultMessage(ex));\n+                        logger.info(\"Failed to deserialize payload [{}] - Cause: {}\",\n+                                    commandResponse.getPayload().getData(),\n+                                    ex.getCause().getMessage());\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(Throwable throwable) {\n+                    serverResponded.set(true);\n+                    commandCallback.onResult(commandMessage, asCommandResultMessage(\n+                            ErrorCode.COMMAND_DISPATCH_ERROR.convert(configuration.getClientId(), throwable)\n+                    ));\n+                    commandInTransit.end();\n+                }\n+\n+                @Override\n+                public void onCompleted() {\n+                    if (!serverResponded.get()) {\n+                        ErrorMessage errorMessage = ErrorMessage.newBuilder()\n+                                                                .setMessage(\"No result from command executor\")\n+                                                                .build();\n+                        commandCallback.onResult(\n+                                commandMessage,\n+                                asCommandResultMessage(ErrorCode.COMMAND_DISPATCH_ERROR.convert(errorMessage))\n+                        );\n+                    }\n+                    commandInTransit.end();\n+                }\n+            });\n         } catch (Exception e) {\n             logger.debug(\"There was a problem dispatching command [{}].\", commandMessage, e);\n             commandCallback.onResult(\n                     commandMessage,\n                     asCommandResultMessage(ErrorCode.COMMAND_DISPATCH_ERROR.convert(configuration.getClientId(), e))\n             );\n+            commandInTransit.end();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjE3MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379852170", "bodyText": "the names increment and decrement don't seem to make much sense when reading the code. What about names like registerActivityStart, and finishActivityEnd? They're not perfect (open to better suggestions), but make more sense in the context of a shutdown latch.", "author": "abuijze", "createdAt": "2020-02-15T19:49:43Z", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -325,9 +337,11 @@ public void onCompleted() {\n                                                   ErrorCode.COMMAND_DISPATCH_ERROR.convert(errorMessage))\n                                           );\n                                       }\n+                                      shutdownLatch.decrement();\n                                   }\n                               }\n                     );\n+            shutdownLatch.increment();", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjI5Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379852297", "bodyText": "Also, the increment may possibly be invoked before the decrement in this setup. Make sure increment is called before. The thing above that could cause trouble is acquiring the channel. I suggest moving that to a separate line, 'increment' therafter and then call the stub.\nTo be really safe (even without moving the channel acquisition), you can wrap the code in a try-catch, and have the catch decrement and rethrow.", "author": "abuijze", "createdAt": "2020-02-15T19:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1ODQ5Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380058497", "bodyText": "Already was in doubt about the method naming; personally I was playing with \"operation\" rather than \"activity\". Renamed the methods to registerOperation and deregisterOperation.\nAnd good call on the point in time when calling increment/registerOperation. Moved this to before try statement. Also added deregister in the catch block.", "author": "smcvb", "createdAt": "2020-02-17T09:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjE3MA=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\nindex 6882f4714..caffe420f 100644\n--- a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\n+++ b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\n\n@@ -283,71 +283,67 @@ private void unsubscribe() {\n \n     private <C, R> void doDispatch(CommandMessage<C> commandMessage,\n                                    CommandCallback<? super C, ? super R> commandCallback) {\n-        shutdownLatch.isShuttingDown(\n+        shutdownLatch.ifShuttingDown(\n                 () -> new IllegalStateException(\"Cannot dispatch new commands as this bus is being shutdown\")\n         );\n \n+        ShutdownLatch.ActivityHandle commandInTransit = shutdownLatch.registerActivity();\n         AtomicBoolean serverResponded = new AtomicBoolean(false);\n         try {\n             String context = targetContextResolver.resolveContext(commandMessage);\n             Command command = serializer.serialize(commandMessage,\n                                                    routingStrategy.getRoutingKey(commandMessage),\n                                                    priorityCalculator.determinePriority(commandMessage));\n+            CommandServiceGrpc.CommandServiceStub commandService =\n+                    CommandServiceGrpc.newStub(axonServerConnectionManager.getChannel(context));\n \n-            CommandServiceGrpc\n-                    .newStub(axonServerConnectionManager.getChannel(context))\n-                    .dispatch(command,\n-                              new StreamObserver<CommandResponse>() {\n-                                  @Override\n-                                  public void onNext(CommandResponse commandResponse) {\n-                                      serverResponded.set(true);\n-                                      logger.debug(\"Received command response [{}]\", commandResponse);\n-\n-                                      try {\n-                                          CommandResultMessage<R> resultMessage =\n-                                                  serializer.deserialize(commandResponse);\n-                                          commandCallback.onResult(commandMessage, resultMessage);\n-                                      } catch (Exception ex) {\n-                                          commandCallback.onResult(commandMessage, asCommandResultMessage(ex));\n-                                          logger.info(\"Failed to deserialize payload [{}] - Cause: {}\",\n-                                                      commandResponse.getPayload().getData(),\n-                                                      ex.getCause().getMessage());\n-                                      }\n-                                  }\n-\n-                                  @Override\n-                                  public void onError(Throwable throwable) {\n-                                      serverResponded.set(true);\n-                                      commandCallback.onResult(commandMessage, asCommandResultMessage(\n-                                              ErrorCode.COMMAND_DISPATCH_ERROR.convert(\n-                                                      configuration.getClientId(), throwable\n-                                              )\n-                                      ));\n-                                      shutdownLatch.decrement();\n-                                  }\n-\n-                                  @Override\n-                                  public void onCompleted() {\n-                                      if (!serverResponded.get()) {\n-                                          ErrorMessage errorMessage =\n-                                                  ErrorMessage.newBuilder()\n-                                                              .setMessage(\"No result from command executor\")\n-                                                              .build();\n-                                          commandCallback.onResult(commandMessage, asCommandResultMessage(\n-                                                  ErrorCode.COMMAND_DISPATCH_ERROR.convert(errorMessage))\n-                                          );\n-                                      }\n-                                      shutdownLatch.decrement();\n-                                  }\n-                              }\n-                    );\n-            shutdownLatch.increment();\n+            commandService.dispatch(command, new StreamObserver<CommandResponse>() {\n+                @Override\n+                public void onNext(CommandResponse commandResponse) {\n+                    serverResponded.set(true);\n+                    logger.debug(\"Received command response [{}]\", commandResponse);\n+\n+                    try {\n+                        CommandResultMessage<R> resultMessage = serializer.deserialize(commandResponse);\n+                        commandCallback.onResult(commandMessage, resultMessage);\n+                    } catch (Exception ex) {\n+                        commandCallback.onResult(commandMessage, asCommandResultMessage(ex));\n+                        logger.info(\"Failed to deserialize payload [{}] - Cause: {}\",\n+                                    commandResponse.getPayload().getData(),\n+                                    ex.getCause().getMessage());\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(Throwable throwable) {\n+                    serverResponded.set(true);\n+                    commandCallback.onResult(commandMessage, asCommandResultMessage(\n+                            ErrorCode.COMMAND_DISPATCH_ERROR.convert(configuration.getClientId(), throwable)\n+                    ));\n+                    commandInTransit.end();\n+                }\n+\n+                @Override\n+                public void onCompleted() {\n+                    if (!serverResponded.get()) {\n+                        ErrorMessage errorMessage = ErrorMessage.newBuilder()\n+                                                                .setMessage(\"No result from command executor\")\n+                                                                .build();\n+                        commandCallback.onResult(\n+                                commandMessage,\n+                                asCommandResultMessage(ErrorCode.COMMAND_DISPATCH_ERROR.convert(errorMessage))\n+                        );\n+                    }\n+                    commandInTransit.end();\n+                }\n+            });\n         } catch (Exception e) {\n             logger.debug(\"There was a problem dispatching command [{}].\", commandMessage, e);\n             commandCallback.onResult(\n                     commandMessage,\n                     asCommandResultMessage(ErrorCode.COMMAND_DISPATCH_ERROR.convert(configuration.getClientId(), e))\n             );\n+            commandInTransit.end();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjQyMw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379852423", "bodyText": "Rename suggestion: 'initiateShutdown'. await is misleading, because it doesn't really wait (which is a good thing).", "author": "abuijze", "createdAt": "2020-02-15T19:54:21Z", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -359,19 +373,33 @@ public Registration registerHandlerInterceptor(\n         return localSegment.registerHandlerInterceptor(handlerInterceptor);\n     }\n \n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            MessageDispatchInterceptor<? super CommandMessage<?>> dispatchInterceptor) {\n+        return dispatchInterceptors.registerDispatchInterceptor(dispatchInterceptor);\n+    }\n+\n     /**\n-     * Disconnect the command bus from the Axon Server.\n+     * Disconnect the command bus for receiving commands from Axon Server, by unsubscribing all registered command\n+     * handlers. After this the connection will be closed, waiting until all command processing tasks have been\n+     * resolved. This shutdown operation is performed in the {@link Phase#INBOUND_COMMAND_OR_QUERY_CONNECTOR} phase.\n      */\n+    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_OR_QUERY_CONNECTOR)\n     public void disconnect() {\n-        if (commandProcessor != null) {\n-            commandProcessor.disconnect();\n-        }\n+        commandProcessor.unsubscribeAndRemoveAll();\n+        commandProcessor.disconnect();\n     }\n \n-    @Override\n-    public Registration registerDispatchInterceptor(\n-            MessageDispatchInterceptor<? super CommandMessage<?>> dispatchInterceptor) {\n-        return dispatchInterceptors.registerDispatchInterceptor(dispatchInterceptor);\n+    /**\n+     * Shutdown the command bus asynchronously for dispatching commands to Axon Server. This process will wait for\n+     * dispatched commands which have not received a response yet. This shutdown operation is performed in the {@link\n+     * Phase#OUTBOUND_COMMAND_OR_QUERY_CONNECTORS} phase.\n+     *\n+     * @return a completable future which is resolved once all command dispatching activities are completed\n+     */\n+    @ShutdownHandler(phase = Phase.OUTBOUND_COMMAND_OR_QUERY_CONNECTORS)\n+    public CompletableFuture<Void> shutdownDispatching() {\n+        return shutdownLatch.await();", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\nindex 6882f4714..caffe420f 100644\n--- a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\n+++ b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\n\n@@ -382,24 +378,25 @@ public Registration registerDispatchInterceptor(\n     /**\n      * Disconnect the command bus for receiving commands from Axon Server, by unsubscribing all registered command\n      * handlers. After this the connection will be closed, waiting until all command processing tasks have been\n-     * resolved. This shutdown operation is performed in the {@link Phase#INBOUND_COMMAND_OR_QUERY_CONNECTOR} phase.\n+     * resolved. This shutdown operation is performed in the {@link Phase#INBOUND_COMMAND_CONNECTOR} phase.\n      */\n-    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_OR_QUERY_CONNECTOR)\n+    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_CONNECTOR)\n     public void disconnect() {\n-        commandProcessor.unsubscribeAndRemoveAll();\n+        commandProcessor.unsubscribeAll();\n         commandProcessor.disconnect();\n     }\n \n     /**\n      * Shutdown the command bus asynchronously for dispatching commands to Axon Server. This process will wait for\n      * dispatched commands which have not received a response yet. This shutdown operation is performed in the {@link\n-     * Phase#OUTBOUND_COMMAND_OR_QUERY_CONNECTORS} phase.\n+     * Phase#OUTBOUND_COMMAND_CONNECTORS} phase.\n      *\n      * @return a completable future which is resolved once all command dispatching activities are completed\n      */\n-    @ShutdownHandler(phase = Phase.OUTBOUND_COMMAND_OR_QUERY_CONNECTORS)\n+    @ShutdownHandler(phase = Phase.OUTBOUND_COMMAND_CONNECTORS)\n     public CompletableFuture<Void> shutdownDispatching() {\n-        return shutdownLatch.await();\n+        commandProcessor.removeLocalSubscriptions();\n+        return shutdownLatch.initiateShutdown();\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjcwNQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379852705", "bodyText": "I suppose this is where only an unsubscribe should happen, just disconnecting the remote source, but leaving the internal state intact. The actual \"removal\" (=local unsubscription) can actually wait till the next phase (OUTBOUND_COMMAND_OR_QUERY_CONNECTORS in this case). This would allow for commands already in transit to still be processed, rather than cutting those off.", "author": "abuijze", "createdAt": "2020-02-15T19:59:21Z", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -359,19 +373,33 @@ public Registration registerHandlerInterceptor(\n         return localSegment.registerHandlerInterceptor(handlerInterceptor);\n     }\n \n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            MessageDispatchInterceptor<? super CommandMessage<?>> dispatchInterceptor) {\n+        return dispatchInterceptors.registerDispatchInterceptor(dispatchInterceptor);\n+    }\n+\n     /**\n-     * Disconnect the command bus from the Axon Server.\n+     * Disconnect the command bus for receiving commands from Axon Server, by unsubscribing all registered command\n+     * handlers. After this the connection will be closed, waiting until all command processing tasks have been\n+     * resolved. This shutdown operation is performed in the {@link Phase#INBOUND_COMMAND_OR_QUERY_CONNECTOR} phase.\n      */\n+    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_OR_QUERY_CONNECTOR)\n     public void disconnect() {\n-        if (commandProcessor != null) {\n-            commandProcessor.disconnect();\n-        }\n+        commandProcessor.unsubscribeAndRemoveAll();", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA2MDcyMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380060722", "bodyText": "Agreed, that should be just a tad safer, although I'd expect the ExecutorService's shutdown approach in the CommandProcessor to be kind for tasks still in progress. I've added a CommandProcessor#removeLocalSubscriptions method to be called on the AxonServerCommandBus#shutdownDispatching method and replaced unsubscribeAndRemoveAll for unsubscribeAll.", "author": "smcvb", "createdAt": "2020-02-17T09:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjcwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\nindex 6882f4714..caffe420f 100644\n--- a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\n+++ b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\n\n@@ -382,24 +378,25 @@ public Registration registerDispatchInterceptor(\n     /**\n      * Disconnect the command bus for receiving commands from Axon Server, by unsubscribing all registered command\n      * handlers. After this the connection will be closed, waiting until all command processing tasks have been\n-     * resolved. This shutdown operation is performed in the {@link Phase#INBOUND_COMMAND_OR_QUERY_CONNECTOR} phase.\n+     * resolved. This shutdown operation is performed in the {@link Phase#INBOUND_COMMAND_CONNECTOR} phase.\n      */\n-    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_OR_QUERY_CONNECTOR)\n+    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_CONNECTOR)\n     public void disconnect() {\n-        commandProcessor.unsubscribeAndRemoveAll();\n+        commandProcessor.unsubscribeAll();\n         commandProcessor.disconnect();\n     }\n \n     /**\n      * Shutdown the command bus asynchronously for dispatching commands to Axon Server. This process will wait for\n      * dispatched commands which have not received a response yet. This shutdown operation is performed in the {@link\n-     * Phase#OUTBOUND_COMMAND_OR_QUERY_CONNECTORS} phase.\n+     * Phase#OUTBOUND_COMMAND_CONNECTORS} phase.\n      *\n      * @return a completable future which is resolved once all command dispatching activities are completed\n      */\n-    @ShutdownHandler(phase = Phase.OUTBOUND_COMMAND_OR_QUERY_CONNECTORS)\n+    @ShutdownHandler(phase = Phase.OUTBOUND_COMMAND_CONNECTORS)\n     public CompletableFuture<Void> shutdownDispatching() {\n-        return shutdownLatch.await();\n+        commandProcessor.removeLocalSubscriptions();\n+        return shutdownLatch.initiateShutdown();\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjgwOQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379852809", "bodyText": "Might be my math skills, but 5 + 20 != 35 ;-)", "author": "abuijze", "createdAt": "2020-02-15T20:01:23Z", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -832,8 +859,22 @@ void disconnect() {\n             if (subscriberStreamObserver != null) {\n                 subscriberStreamObserver.onCompleted();\n             }\n-            running = false;\n+\n             commandExecutor.shutdown();\n+            try {\n+                if (!commandExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n+                    logger.warn(\"Awaited Command Bus termination for 5 seconds. Wait period extended by 30 seconds.\");\n+                }\n+                if (!commandExecutor.awaitTermination(20, TimeUnit.SECONDS)) {\n+                    logger.warn(\"Awaited Command Bus termination for 35 seconds. Will shutdown forcefully.\");", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA2MDkyMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380060922", "bodyText": "Might be a typo \ud83d\ude48\nThanks for spotting it.", "author": "smcvb", "createdAt": "2020-02-17T09:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjgwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\nindex 6882f4714..caffe420f 100644\n--- a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\n+++ b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java\n\n@@ -865,7 +860,7 @@ void disconnect() {\n                 if (!commandExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n                     logger.warn(\"Awaited Command Bus termination for 5 seconds. Wait period extended by 30 seconds.\");\n                 }\n-                if (!commandExecutor.awaitTermination(20, TimeUnit.SECONDS)) {\n+                if (!commandExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n                     logger.warn(\"Awaited Command Bus termination for 35 seconds. Will shutdown forcefully.\");\n                     commandExecutor.shutdownNow();\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzQ5Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379853497", "bodyText": "Make sure increment is guaranteed to be invoked before decrement.", "author": "abuijze", "createdAt": "2020-02-15T20:14:03Z", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "diffHunk": "@@ -324,48 +328,53 @@ private void onApplicationDisconnected(String context) {\n                                @Override\n                                public void onNext(QueryResponse queryResponse) {\n                                    logger.debug(\"Received query response [{}]\", queryResponse);\n-                                   completableFuture.complete(serializer.deserializeResponse(queryResponse, queryMessage.getResponseType()));\n+                                   queryTransaction.complete(\n+                                           serializer.deserializeResponse(queryResponse, queryMessage.getResponseType())\n+                                   );\n                                }\n \n                                @Override\n                                public void onError(Throwable throwable) {\n-                                   if (logger.isDebugEnabled()) {\n-                                       logger.debug(\"Received error while waiting for first response\", throwable);\n-                                   }\n-                                   completableFuture.completeExceptionally(\n+                                   logger.debug(\"Received error while waiting for first response\", throwable);\n+                                   queryTransaction.completeExceptionally(\n                                            ErrorCode.QUERY_DISPATCH_ERROR.convert(\n                                                    configuration.getClientId(), throwable\n                                            )\n                                    );\n+                                   shutdownLatch.decrement();\n                                }\n \n                                @Override\n                                public void onCompleted() {\n-                                   if (completableFuture.isDone()) {\n-                                       return;\n+                                   if (!queryTransaction.isDone()) {\n+                                       queryTransaction.completeExceptionally(\n+                                               ErrorCode.QUERY_DISPATCH_ERROR.convert(\n+                                                       ErrorMessage.newBuilder()\n+                                                                   .setMessage(\"No result from query executor\")\n+                                                                   .build()\n+                                               )\n+                                       );\n                                    }\n-\n-                                   completableFuture.completeExceptionally(\n-                                           ErrorCode.QUERY_DISPATCH_ERROR.convert(\n-                                                   ErrorMessage.newBuilder()\n-                                                               .setMessage(\"No result from query executor\")\n-                                                               .build()\n-                                           ));\n+                                   shutdownLatch.decrement();\n                                }\n                            });\n+            shutdownLatch.increment();", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA2ODA0Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380068047", "bodyText": "Good point. Made a similar change as you suggested in the AxonServerCommandBus: increment prior to entering try-catch block, decrement on onError, onCompleted and in the catch.", "author": "smcvb", "createdAt": "2020-02-17T09:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzQ5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\nindex c315e997c..9dc91f1f1 100644\n--- a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\n+++ b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\n\n@@ -311,59 +312,55 @@ private void onApplicationDisconnected(String context) {\n \n     @Override\n     public <Q, R> CompletableFuture<QueryResponseMessage<R>> query(QueryMessage<Q, R> queryMessage) {\n-        validateShutdown(\"queries\");\n+        assertActive(\"queries\");\n \n         QueryMessage<Q, R> interceptedQuery = dispatchInterceptors.intercept(queryMessage);\n+        ShutdownLatch.ActivityHandle queryInTransit = shutdownLatch.registerActivity();\n         CompletableFuture<QueryResponseMessage<R>> queryTransaction = new CompletableFuture<>();\n         try {\n             String context = targetContextResolver.resolveContext(interceptedQuery);\n-            QueryRequest queryRequest = serializer.serializeRequest(\n-                    interceptedQuery, DIRECT_QUERY_NUMBER_OF_RESULTS, DIRECT_QUERY_TIMEOUT_MS,\n-                    priorityCalculator.determinePriority(interceptedQuery)\n-            );\n+            QueryRequest queryRequest =\n+                    serializer.serializeRequest(interceptedQuery,\n+                                                DIRECT_QUERY_NUMBER_OF_RESULTS,\n+                                                DIRECT_QUERY_TIMEOUT_MS,\n+                                                priorityCalculator.determinePriority(interceptedQuery));\n+\n+            QueryServiceGrpc.QueryServiceStub queryService = queryService(context);\n+            queryService.query(queryRequest, new StreamObserver<QueryResponse>() {\n+                @Override\n+                public void onNext(QueryResponse queryResponse) {\n+                    logger.debug(\"Received query response [{}]\", queryResponse);\n+                    QueryResponseMessage<R> responseMessage =\n+                            serializer.deserializeResponse(queryResponse, queryMessage.getResponseType());\n+                    queryTransaction.complete(responseMessage);\n+                }\n \n-            queryService(context)\n-                    .query(queryRequest,\n-                           new StreamObserver<QueryResponse>() {\n-                               @Override\n-                               public void onNext(QueryResponse queryResponse) {\n-                                   logger.debug(\"Received query response [{}]\", queryResponse);\n-                                   queryTransaction.complete(\n-                                           serializer.deserializeResponse(queryResponse, queryMessage.getResponseType())\n-                                   );\n-                               }\n-\n-                               @Override\n-                               public void onError(Throwable throwable) {\n-                                   logger.debug(\"Received error while waiting for first response\", throwable);\n-                                   queryTransaction.completeExceptionally(\n-                                           ErrorCode.QUERY_DISPATCH_ERROR.convert(\n-                                                   configuration.getClientId(), throwable\n-                                           )\n-                                   );\n-                                   shutdownLatch.decrement();\n-                               }\n-\n-                               @Override\n-                               public void onCompleted() {\n-                                   if (!queryTransaction.isDone()) {\n-                                       queryTransaction.completeExceptionally(\n-                                               ErrorCode.QUERY_DISPATCH_ERROR.convert(\n-                                                       ErrorMessage.newBuilder()\n-                                                                   .setMessage(\"No result from query executor\")\n-                                                                   .build()\n-                                               )\n-                                       );\n-                                   }\n-                                   shutdownLatch.decrement();\n-                               }\n-                           });\n-            shutdownLatch.increment();\n+                @Override\n+                public void onError(Throwable throwable) {\n+                    logger.debug(\"Received error while waiting for first response\", throwable);\n+                    AxonException exception =\n+                            ErrorCode.QUERY_DISPATCH_ERROR.convert(configuration.getClientId(), throwable);\n+                    queryTransaction.completeExceptionally(exception);\n+                    queryInTransit.end();\n+                }\n+\n+                @Override\n+                public void onCompleted() {\n+                    if (!queryTransaction.isDone()) {\n+                        ErrorMessage errorMessage = ErrorMessage.newBuilder()\n+                                                                .setMessage(\"No result from query executor\")\n+                                                                .build();\n+                        AxonException exception = ErrorCode.QUERY_DISPATCH_ERROR.convert(errorMessage);\n+                        queryTransaction.completeExceptionally(exception);\n+                    }\n+                    queryInTransit.end();\n+                }\n+            });\n         } catch (Exception e) {\n             logger.debug(\"There was a problem issuing a query {}.\", interceptedQuery, e);\n-            queryTransaction.completeExceptionally(\n-                    ErrorCode.QUERY_DISPATCH_ERROR.convert(configuration.getClientId(), e)\n-            );\n+            AxonException exception = ErrorCode.QUERY_DISPATCH_ERROR.convert(configuration.getClientId(), e);\n+            queryTransaction.completeExceptionally(exception);\n+            queryInTransit.end();\n         }\n \n         return queryTransaction;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzUyNA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379853524", "bodyText": "Suggestion: assertRunning or assertNotShuttingDown", "author": "abuijze", "createdAt": "2020-02-15T20:14:56Z", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "diffHunk": "@@ -324,48 +328,53 @@ private void onApplicationDisconnected(String context) {\n                                @Override\n                                public void onNext(QueryResponse queryResponse) {\n                                    logger.debug(\"Received query response [{}]\", queryResponse);\n-                                   completableFuture.complete(serializer.deserializeResponse(queryResponse, queryMessage.getResponseType()));\n+                                   queryTransaction.complete(\n+                                           serializer.deserializeResponse(queryResponse, queryMessage.getResponseType())\n+                                   );\n                                }\n \n                                @Override\n                                public void onError(Throwable throwable) {\n-                                   if (logger.isDebugEnabled()) {\n-                                       logger.debug(\"Received error while waiting for first response\", throwable);\n-                                   }\n-                                   completableFuture.completeExceptionally(\n+                                   logger.debug(\"Received error while waiting for first response\", throwable);\n+                                   queryTransaction.completeExceptionally(\n                                            ErrorCode.QUERY_DISPATCH_ERROR.convert(\n                                                    configuration.getClientId(), throwable\n                                            )\n                                    );\n+                                   shutdownLatch.decrement();\n                                }\n \n                                @Override\n                                public void onCompleted() {\n-                                   if (completableFuture.isDone()) {\n-                                       return;\n+                                   if (!queryTransaction.isDone()) {\n+                                       queryTransaction.completeExceptionally(\n+                                               ErrorCode.QUERY_DISPATCH_ERROR.convert(\n+                                                       ErrorMessage.newBuilder()\n+                                                                   .setMessage(\"No result from query executor\")\n+                                                                   .build()\n+                                               )\n+                                       );\n                                    }\n-\n-                                   completableFuture.completeExceptionally(\n-                                           ErrorCode.QUERY_DISPATCH_ERROR.convert(\n-                                                   ErrorMessage.newBuilder()\n-                                                               .setMessage(\"No result from query executor\")\n-                                                               .build()\n-                                           ));\n+                                   shutdownLatch.decrement();\n                                }\n                            });\n+            shutdownLatch.increment();\n         } catch (Exception e) {\n             logger.debug(\"There was a problem issuing a query {}.\", interceptedQuery, e);\n-            completableFuture.completeExceptionally(\n+            queryTransaction.completeExceptionally(\n                     ErrorCode.QUERY_DISPATCH_ERROR.convert(configuration.getClientId(), e)\n             );\n         }\n-        return completableFuture;\n+\n+        return queryTransaction;\n     }\n \n     @Override\n     public <Q, R> Stream<QueryResponseMessage<R>> scatterGather(QueryMessage<Q, R> queryMessage,\n                                                                 long timeout,\n                                                                 TimeUnit timeUnit) {\n+        validateShutdown(\"scatter-gather queries\");", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA2ODUwMw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380068503", "bodyText": "Changed to assertActive(String).", "author": "smcvb", "createdAt": "2020-02-17T09:30:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzUyNA=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\nindex c315e997c..9dc91f1f1 100644\n--- a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\n+++ b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\n\n@@ -311,59 +312,55 @@ private void onApplicationDisconnected(String context) {\n \n     @Override\n     public <Q, R> CompletableFuture<QueryResponseMessage<R>> query(QueryMessage<Q, R> queryMessage) {\n-        validateShutdown(\"queries\");\n+        assertActive(\"queries\");\n \n         QueryMessage<Q, R> interceptedQuery = dispatchInterceptors.intercept(queryMessage);\n+        ShutdownLatch.ActivityHandle queryInTransit = shutdownLatch.registerActivity();\n         CompletableFuture<QueryResponseMessage<R>> queryTransaction = new CompletableFuture<>();\n         try {\n             String context = targetContextResolver.resolveContext(interceptedQuery);\n-            QueryRequest queryRequest = serializer.serializeRequest(\n-                    interceptedQuery, DIRECT_QUERY_NUMBER_OF_RESULTS, DIRECT_QUERY_TIMEOUT_MS,\n-                    priorityCalculator.determinePriority(interceptedQuery)\n-            );\n+            QueryRequest queryRequest =\n+                    serializer.serializeRequest(interceptedQuery,\n+                                                DIRECT_QUERY_NUMBER_OF_RESULTS,\n+                                                DIRECT_QUERY_TIMEOUT_MS,\n+                                                priorityCalculator.determinePriority(interceptedQuery));\n+\n+            QueryServiceGrpc.QueryServiceStub queryService = queryService(context);\n+            queryService.query(queryRequest, new StreamObserver<QueryResponse>() {\n+                @Override\n+                public void onNext(QueryResponse queryResponse) {\n+                    logger.debug(\"Received query response [{}]\", queryResponse);\n+                    QueryResponseMessage<R> responseMessage =\n+                            serializer.deserializeResponse(queryResponse, queryMessage.getResponseType());\n+                    queryTransaction.complete(responseMessage);\n+                }\n \n-            queryService(context)\n-                    .query(queryRequest,\n-                           new StreamObserver<QueryResponse>() {\n-                               @Override\n-                               public void onNext(QueryResponse queryResponse) {\n-                                   logger.debug(\"Received query response [{}]\", queryResponse);\n-                                   queryTransaction.complete(\n-                                           serializer.deserializeResponse(queryResponse, queryMessage.getResponseType())\n-                                   );\n-                               }\n-\n-                               @Override\n-                               public void onError(Throwable throwable) {\n-                                   logger.debug(\"Received error while waiting for first response\", throwable);\n-                                   queryTransaction.completeExceptionally(\n-                                           ErrorCode.QUERY_DISPATCH_ERROR.convert(\n-                                                   configuration.getClientId(), throwable\n-                                           )\n-                                   );\n-                                   shutdownLatch.decrement();\n-                               }\n-\n-                               @Override\n-                               public void onCompleted() {\n-                                   if (!queryTransaction.isDone()) {\n-                                       queryTransaction.completeExceptionally(\n-                                               ErrorCode.QUERY_DISPATCH_ERROR.convert(\n-                                                       ErrorMessage.newBuilder()\n-                                                                   .setMessage(\"No result from query executor\")\n-                                                                   .build()\n-                                               )\n-                                       );\n-                                   }\n-                                   shutdownLatch.decrement();\n-                               }\n-                           });\n-            shutdownLatch.increment();\n+                @Override\n+                public void onError(Throwable throwable) {\n+                    logger.debug(\"Received error while waiting for first response\", throwable);\n+                    AxonException exception =\n+                            ErrorCode.QUERY_DISPATCH_ERROR.convert(configuration.getClientId(), throwable);\n+                    queryTransaction.completeExceptionally(exception);\n+                    queryInTransit.end();\n+                }\n+\n+                @Override\n+                public void onCompleted() {\n+                    if (!queryTransaction.isDone()) {\n+                        ErrorMessage errorMessage = ErrorMessage.newBuilder()\n+                                                                .setMessage(\"No result from query executor\")\n+                                                                .build();\n+                        AxonException exception = ErrorCode.QUERY_DISPATCH_ERROR.convert(errorMessage);\n+                        queryTransaction.completeExceptionally(exception);\n+                    }\n+                    queryInTransit.end();\n+                }\n+            });\n         } catch (Exception e) {\n             logger.debug(\"There was a problem issuing a query {}.\", interceptedQuery, e);\n-            queryTransaction.completeExceptionally(\n-                    ErrorCode.QUERY_DISPATCH_ERROR.convert(configuration.getClientId(), e)\n-            );\n+            AxonException exception = ErrorCode.QUERY_DISPATCH_ERROR.convert(configuration.getClientId(), e);\n+            queryTransaction.completeExceptionally(exception);\n+            queryInTransit.end();\n         }\n \n         return queryTransaction;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzU1Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379853552", "bodyText": "Same: ensure incrementing before decrementing", "author": "abuijze", "createdAt": "2020-02-15T20:15:40Z", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "diffHunk": "@@ -395,17 +406,19 @@ public void onNext(QueryResponse queryResponse) {\n                            @Override\n                            public void onError(Throwable throwable) {\n                                if (!isDeadlineExceeded(throwable)) {\n-                                   logger.info(\"Received error while waiting for responses\",\n-                                               throwable);\n+                                   logger.info(\"Received error while waiting for responses\", throwable);\n                                }\n                                resultSpliterator.cancel(throwable);\n+                               shutdownLatch.decrement();\n                            }\n \n                            @Override\n                            public void onCompleted() {\n                                resultSpliterator.cancel(null);\n+                               shutdownLatch.decrement();\n                            }\n                        });\n+        shutdownLatch.increment();", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\nindex c315e997c..9dc91f1f1 100644\n--- a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\n+++ b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\n\n@@ -373,52 +370,58 @@ public void onCompleted() {\n     public <Q, R> Stream<QueryResponseMessage<R>> scatterGather(QueryMessage<Q, R> queryMessage,\n                                                                 long timeout,\n                                                                 TimeUnit timeUnit) {\n-        validateShutdown(\"scatter-gather queries\");\n+        assertActive(\"scatter-gather queries\");\n \n         QueryMessage<Q, R> interceptedQuery = dispatchInterceptors.intercept(queryMessage);\n-        String context = targetContextResolver.resolveContext(interceptedQuery);\n-        QueryRequest queryRequest = serializer.serializeRequest(interceptedQuery,\n-                                                                SCATTER_GATHER_NUMBER_OF_RESULTS,\n-                                                                timeUnit.toMillis(timeout),\n-                                                                priorityCalculator.determinePriority(interceptedQuery));\n+        ShutdownLatch.ActivityHandle queryInTransit = shutdownLatch.registerActivity();\n         BufferingSpliterator<QueryResponseMessage<R>> resultSpliterator =\n                 new BufferingSpliterator<>(Instant.now().plusMillis(timeUnit.toMillis(timeout)));\n+        try {\n+            String context = targetContextResolver.resolveContext(interceptedQuery);\n+            QueryRequest queryRequest =\n+                    serializer.serializeRequest(interceptedQuery,\n+                                                SCATTER_GATHER_NUMBER_OF_RESULTS,\n+                                                timeUnit.toMillis(timeout),\n+                                                priorityCalculator.determinePriority(interceptedQuery));\n+\n+            QueryServiceGrpc.QueryServiceStub queryService =\n+                    queryService(context).withDeadlineAfter(timeout, timeUnit);\n+            queryService.query(queryRequest, new UpstreamAwareStreamObserver<QueryResponse>() {\n+                @Override\n+                public void onNext(QueryResponse queryResponse) {\n+                    logger.debug(\"Received query response [{}]\", queryResponse);\n+                    if (queryResponse.hasErrorMessage()) {\n+                        logger.debug(\"The received query response has error message [{}]\",\n+                                     queryResponse.getErrorMessage());\n+                    } else {\n+                        if (!resultSpliterator.put(serializer.deserializeResponse(\n+                                queryResponse, queryMessage.getResponseType()\n+                        ))) {\n+                            getRequestStream().cancel(\"Cancellation requested by client\", null);\n+                        }\n+                    }\n+                }\n \n-        queryService(context)\n-                .withDeadlineAfter(timeout, timeUnit)\n-                .query(queryRequest,\n-                       new UpstreamAwareStreamObserver<QueryResponse>() {\n-                           @Override\n-                           public void onNext(QueryResponse queryResponse) {\n-                               logger.debug(\"Received query response [{}]\", queryResponse);\n-                               if (queryResponse.hasErrorMessage()) {\n-                                   logger.debug(\"The received query response has error message [{}]\",\n-                                                queryResponse.getErrorMessage());\n-                               } else {\n-                                   if (!resultSpliterator.put(\n-                                           serializer.deserializeResponse(queryResponse, queryMessage.getResponseType())\n-                                   )) {\n-                                       getRequestStream().cancel(\"Cancellation requested by client\", null);\n-                                   }\n-                               }\n-                           }\n-\n-                           @Override\n-                           public void onError(Throwable throwable) {\n-                               if (!isDeadlineExceeded(throwable)) {\n-                                   logger.info(\"Received error while waiting for responses\", throwable);\n-                               }\n-                               resultSpliterator.cancel(throwable);\n-                               shutdownLatch.decrement();\n-                           }\n-\n-                           @Override\n-                           public void onCompleted() {\n-                               resultSpliterator.cancel(null);\n-                               shutdownLatch.decrement();\n-                           }\n-                       });\n-        shutdownLatch.increment();\n+                @Override\n+                public void onError(Throwable throwable) {\n+                    if (!isDeadlineExceeded(throwable)) {\n+                        logger.info(\"Received error while waiting for responses\", throwable);\n+                    }\n+                    resultSpliterator.cancel(throwable);\n+                    queryInTransit.end();\n+                }\n+\n+                @Override\n+                public void onCompleted() {\n+                    resultSpliterator.cancel(null);\n+                    queryInTransit.end();\n+                }\n+            });\n+        } catch (Exception e) {\n+            logger.debug(\"There was a problem issuing a scatter-gather query {}.\", interceptedQuery, e);\n+            queryInTransit.end();\n+            throw e;\n+        }\n \n         return StreamSupport.stream(resultSpliterator, false).onClose(() -> resultSpliterator.cancel(null));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzU5Mw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379853593", "bodyText": "25 or 35?", "author": "abuijze", "createdAt": "2020-02-15T20:16:31Z", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "diffHunk": "@@ -720,33 +783,24 @@ public void unsubscribe(String queryName, Type responseType, String componentNam\n             }\n         }\n \n-        private void clearOutboundStream() {\n-            StreamObserver<QueryProviderOutbound> out = outboundStreamObserver;\n-            if (out != null) {\n-                outboundStreamObserver = null;\n-                try {\n-                    subscribedQueries.forEach((queryDefinition, handlerSet) -> out.onNext(\n-                            QueryProviderOutbound.newBuilder()\n-                                                 .setUnsubscribe(buildQuerySubscription(queryDefinition, 1))\n-                                                 .build()\n-                    ));\n-                    out.onCompleted();\n-                } catch (Exception e) {\n-                    // This exception is ignored\n-                }\n-            }\n-        }\n-\n         void disconnect() {\n             running = false;\n-            clearOutboundStream();\n+\n             queryExecutor.shutdown();\n             try {\n-                queryExecutor.awaitTermination(5, TimeUnit.SECONDS);\n+                if (!queryExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n+                    logger.warn(\"Awaited Query Bus termination for 5 seconds. Wait period extended by 30 seconds.\");\n+                }\n+                if (!queryExecutor.awaitTermination(20, TimeUnit.SECONDS)) {\n+                    logger.warn(\"Awaited Query Bus termination for 35 seconds. Will shutdown forcefully.\");", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\nindex c315e997c..9dc91f1f1 100644\n--- a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\n+++ b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\n\n@@ -783,6 +779,10 @@ private void unsubscribe(QueryDefinition queryDefinition) {\n             }\n         }\n \n+        private void removeLocalSubscriptions() {\n+            subscribedQueries.clear();\n+        }\n+\n         void disconnect() {\n             running = false;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzYyMA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379853620", "bodyText": "30 or 20?", "author": "abuijze", "createdAt": "2020-02-15T20:16:41Z", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "diffHunk": "@@ -720,33 +783,24 @@ public void unsubscribe(String queryName, Type responseType, String componentNam\n             }\n         }\n \n-        private void clearOutboundStream() {\n-            StreamObserver<QueryProviderOutbound> out = outboundStreamObserver;\n-            if (out != null) {\n-                outboundStreamObserver = null;\n-                try {\n-                    subscribedQueries.forEach((queryDefinition, handlerSet) -> out.onNext(\n-                            QueryProviderOutbound.newBuilder()\n-                                                 .setUnsubscribe(buildQuerySubscription(queryDefinition, 1))\n-                                                 .build()\n-                    ));\n-                    out.onCompleted();\n-                } catch (Exception e) {\n-                    // This exception is ignored\n-                }\n-            }\n-        }\n-\n         void disconnect() {\n             running = false;\n-            clearOutboundStream();\n+\n             queryExecutor.shutdown();\n             try {\n-                queryExecutor.awaitTermination(5, TimeUnit.SECONDS);\n+                if (!queryExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n+                    logger.warn(\"Awaited Query Bus termination for 5 seconds. Wait period extended by 30 seconds.\");", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA2OTU1OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380069559", "bodyText": "The second awaitTermination should use 30 - typo from my end which has been resolved.", "author": "smcvb", "createdAt": "2020-02-17T09:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\nindex c315e997c..9dc91f1f1 100644\n--- a/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\n+++ b/axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java\n\n@@ -783,6 +779,10 @@ private void unsubscribe(QueryDefinition queryDefinition) {\n             }\n         }\n \n+        private void removeLocalSubscriptions() {\n+            subscribedQueries.clear();\n+        }\n+\n         void disconnect() {\n             running = false;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NTM3OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379855378", "bodyText": "Consider renaming this method. Something like disconnect, initiateShutdown", "author": "abuijze", "createdAt": "2020-02-15T20:51:49Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/CommandBusConnector.java", "diffHunk": "@@ -96,4 +97,13 @@\n     default Optional<CommandBus> localSegment() {\n         return Optional.empty();\n     }\n+\n+    /**\n+     * Stops sending new commands.\n+     *\n+     * @return a Completable Future indicating that all previously sent commands are completed\n+     */\n+    default CompletableFuture<Void> stopSendingCommands() {", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA3MTkzNA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380071934", "bodyText": "Renamed to initiateShutdown", "author": "smcvb", "createdAt": "2020-02-17T09:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NTM3OA=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/distributed/CommandBusConnector.java b/messaging/src/main/java/org/axonframework/commandhandling/distributed/CommandBusConnector.java\nindex 5b635e263..c257b3e0b 100644\n--- a/messaging/src/main/java/org/axonframework/commandhandling/distributed/CommandBusConnector.java\n+++ b/messaging/src/main/java/org/axonframework/commandhandling/distributed/CommandBusConnector.java\n\n@@ -99,11 +99,12 @@\n     }\n \n     /**\n-     * Stops sending new commands.\n+     * Initiate the shutdown of a {@link CommandBusConnector}. {@link CommandMessage}s should no longer be dispatched\n+     * after this method has been invoked.\n      *\n-     * @return a Completable Future indicating that all previously sent commands are completed\n+     * @return a {@link CompletableFuture} indicating when all previously sent commands are completed\n      */\n-    default CompletableFuture<Void> stopSendingCommands() {\n+    default CompletableFuture<Void> initiateShutdown() {\n         return CompletableFuture.completedFuture(null);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NTY0MQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379855641", "bodyText": "Suggest renaming to disconnect. Why is a \"stopSending\" (= outbound) annotated with a phase for INBOUND?", "author": "abuijze", "createdAt": "2020-02-15T20:57:44Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/DistributedCommandBus.java", "diffHunk": "@@ -101,6 +104,24 @@ protected DistributedCommandBus(Builder builder) {\n         this.defaultCommandCallback = builder.defaultCommandCallback;\n     }\n \n+    /**\n+     * Shutdown handler that unsubscribes all command handlers subscribed via this Distributed Command Bus.\n+     */\n+    @ShutdownHandler(phase = Phase.OUTBOUND_COMMAND_OR_QUERY_CONNECTORS)\n+    public void unsubscribeCommandHandlers() {\n+        commandRouter.updateMembership(loadFactor, DenyAll.INSTANCE);\n+    }\n+\n+    /**\n+     * Shutdown handler that stops sending new commands.\n+     *\n+     * @return a Completable Future indicating that all previously sent commands are completed\n+     */\n+    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_OR_QUERY_CONNECTOR)\n+    public CompletableFuture<Void> stopSendingCommands() {", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA3Mzg3Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380073872", "bodyText": "Renamed to shutdownDispatching, thus mirroring the AxonServerCommandBus' equivalent phase.\nAnd you're right on the phases, they've been accidentally switched. This method should be called in phase OUTBOUND_COMMAND_OR_QUERY_CONNECTORS.", "author": "smcvb", "createdAt": "2020-02-17T09:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NTY0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/commandhandling/distributed/DistributedCommandBus.java b/messaging/src/main/java/org/axonframework/commandhandling/distributed/DistributedCommandBus.java\nindex efefbc5ca..cad554227 100644\n--- a/messaging/src/main/java/org/axonframework/commandhandling/distributed/DistributedCommandBus.java\n+++ b/messaging/src/main/java/org/axonframework/commandhandling/distributed/DistributedCommandBus.java\n\n@@ -105,21 +105,24 @@ protected DistributedCommandBus(Builder builder) {\n     }\n \n     /**\n-     * Shutdown handler that unsubscribes all command handlers subscribed via this Distributed Command Bus.\n+     * Disconnect the command bus for receiving new commands, by unsubscribing all registered command handlers. This\n+     * shutdown operation is performed in the {@link Phase#INBOUND_COMMAND_CONNECTOR} phase.\n      */\n-    @ShutdownHandler(phase = Phase.OUTBOUND_COMMAND_OR_QUERY_CONNECTORS)\n-    public void unsubscribeCommandHandlers() {\n+    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_CONNECTOR)\n+    public void disconnect() {\n         commandRouter.updateMembership(loadFactor, DenyAll.INSTANCE);\n     }\n \n     /**\n-     * Shutdown handler that stops sending new commands.\n+     * Shutdown the command bus asynchronously for dispatching commands to other instances. This process will wait for\n+     * dispatched commands which have not received a response yet. This shutdown operation is performed in the {@link\n+     * Phase#OUTBOUND_COMMAND_CONNECTORS} phase.\n      *\n-     * @return a Completable Future indicating that all previously sent commands are completed\n+     * @return a completable future which is resolved once all command dispatching activities are completed\n      */\n-    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_OR_QUERY_CONNECTOR)\n-    public CompletableFuture<Void> stopSendingCommands() {\n-        return connector.stopSendingCommands();\n+    @ShutdownHandler(phase = Phase.OUTBOUND_COMMAND_CONNECTORS)\n+    public CompletableFuture<Void> shutdownDispatching() {\n+        return connector.initiateShutdown();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjAzNQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856035", "bodyText": "I suggest creating two different fields for Commands and Queries, even though they have the same value.", "author": "abuijze", "createdAt": "2020-02-15T21:05:35Z", "path": "messaging/src/main/java/org/axonframework/lifecycle/Phase.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.lifecycle;\n+\n+/**\n+ * Utility class containing constants which can be used as input for the {@link StartHandler} and {@link\n+ * ShutdownHandler} annotations.\n+ *\n+ * @author Steven van Beelen\n+ * @see StartHandler\n+ * @see ShutdownHandler\n+ * @since 4.3\n+ */\n+public abstract class Phase {\n+\n+    private Phase() {\n+        // Utility class\n+    }\n+\n+    /**\n+     * Phase to start or shutdown all external connections.\n+     */\n+    public static final int EXTERNAL_CONNECTIONS = Integer.MIN_VALUE >> 4;\n+    /**\n+     * Phase to register or cancel the registration of any local message handler.\n+     */\n+    public static final int LOCAL_MESSAGE_HANDLER_REGISTRATIONS = 0;\n+    /**\n+     * Phase to start or shutdown inbound command and/or query connectors. It is targeted towards connectors which\n+     * receive commands and/or queries from external applications.\n+     */\n+    public static final int INBOUND_COMMAND_OR_QUERY_CONNECTOR = 0;", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA4NDIxMQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380084211", "bodyText": "Fair point, added those.", "author": "smcvb", "createdAt": "2020-02-17T09:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjAzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/lifecycle/Phase.java b/messaging/src/main/java/org/axonframework/lifecycle/Phase.java\nindex 8e91c0733..3844efae4 100644\n--- a/messaging/src/main/java/org/axonframework/lifecycle/Phase.java\n+++ b/messaging/src/main/java/org/axonframework/lifecycle/Phase.java\n\n@@ -40,10 +40,15 @@ private Phase() {\n      */\n     public static final int LOCAL_MESSAGE_HANDLER_REGISTRATIONS = 0;\n     /**\n-     * Phase to start or shutdown inbound command and/or query connectors. It is targeted towards connectors which\n-     * receive commands and/or queries from external applications.\n+     * Phase to start or shutdown inbound command connectors. It is targeted towards connectors which\n+     * receive commands from external applications.\n      */\n-    public static final int INBOUND_COMMAND_OR_QUERY_CONNECTOR = 0;\n+    public static final int INBOUND_COMMAND_CONNECTOR = 0;\n+    /**\n+     * Phase to start or shutdown inbound query connectors. It is targeted towards connectors which\n+     * receive queries from external applications.\n+     */\n+    public static final int INBOUND_QUERY_CONNECTOR = 0;\n     /**\n      * Phase to start or shutdown outbound event connectors. It is targeted towards connectors which can send events out\n      * to external applications.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjIzOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856238", "bodyText": "This field needs to be volatile, to be thread-safe", "author": "abuijze", "createdAt": "2020-02-15T21:09:09Z", "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java b/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\nindex 1d63e842f..a951d561d 100644\n--- a/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\n+++ b/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\n\n@@ -1,18 +1,15 @@\n package org.axonframework.lifecycle;\n \n-import java.time.Duration;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Supplier;\n \n /**\n- * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n- * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n- * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n- * operations can no longer be added.\n+ * A latch implementation to be used in shutdown scenarios. Activities to wait for can be added by invoking {@link\n+ * #registerActivity()}. An registered activity should always shutdown through the returned {@link ActivityHandle}'s\n+ * {@link ActivityHandle#end()} method once it has completed. Otherwise {@link #initiateShutdown()} will block\n+ * indefinitely. If the latch is waited on through {@link #initiateShutdown()}, new operations can no longer be added.\n  *\n  * @author Steven van Beelen\n  * @since 4.3\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjM4MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856380", "bodyText": "To make this method completely safe in its usage, it's best if this method returns a \"handle\" that can be closed to indicate that a certain workload has been finished. The method signature could look like:\npublic ActivityHandle registerActivity(). ActivityHandler would have a single method: void end().\nThis implementation of ActivtyHandle.end() could also verify that it wasn't invoked more than once. Decrementing the counter more than incrementing it can be problematic.", "author": "abuijze", "createdAt": "2020-02-15T21:12:05Z", "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;\n+\n+    /**\n+     * Add an operation this latch should wait on before opening up. If this operation is called whilst {@link #await()}\n+     * is already called an {@link IllegalStateException} will be thrown.\n+     *\n+     * @throws IllegalStateException if {@link #await()} has been called prior to invoking this method\n+     */\n+    public void increment() {", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA4Nzk0MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380087940", "bodyText": "Brilliant idea to make this even safer. Gonna do something like this.", "author": "smcvb", "createdAt": "2020-02-17T10:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjM4MA=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java b/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\nindex 1d63e842f..a951d561d 100644\n--- a/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\n+++ b/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\n\n@@ -1,18 +1,15 @@\n package org.axonframework.lifecycle;\n \n-import java.time.Duration;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Supplier;\n \n /**\n- * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n- * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n- * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n- * operations can no longer be added.\n+ * A latch implementation to be used in shutdown scenarios. Activities to wait for can be added by invoking {@link\n+ * #registerActivity()}. An registered activity should always shutdown through the returned {@link ActivityHandle}'s\n+ * {@link ActivityHandle#end()} method once it has completed. Otherwise {@link #initiateShutdown()} will block\n+ * indefinitely. If the latch is waited on through {@link #initiateShutdown()}, new operations can no longer be added.\n  *\n  * @author Steven van Beelen\n  * @since 4.3\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjQ2OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856468", "bodyText": "This message won't mean much to people who are not familiar with the implementation details. Consider throwing a \"ShutdownInProgressException\" and/or change the message to \"Cannot start activity. Shutdown in progress.\"", "author": "abuijze", "createdAt": "2020-02-15T21:13:48Z", "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;\n+\n+    /**\n+     * Add an operation this latch should wait on before opening up. If this operation is called whilst {@link #await()}\n+     * is already called an {@link IllegalStateException} will be thrown.\n+     *\n+     * @throws IllegalStateException if {@link #await()} has been called prior to invoking this method\n+     */\n+    public void increment() {\n+        if (isShuttingDown()) {\n+            throw new IllegalStateException(\"No new operations can be added, since this latched is waited for.\");", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java b/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\nindex 1d63e842f..a951d561d 100644\n--- a/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\n+++ b/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\n\n@@ -1,18 +1,15 @@\n package org.axonframework.lifecycle;\n \n-import java.time.Duration;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Supplier;\n \n /**\n- * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n- * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n- * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n- * operations can no longer be added.\n+ * A latch implementation to be used in shutdown scenarios. Activities to wait for can be added by invoking {@link\n+ * #registerActivity()}. An registered activity should always shutdown through the returned {@link ActivityHandle}'s\n+ * {@link ActivityHandle#end()} method once it has completed. Otherwise {@link #initiateShutdown()} will block\n+ * indefinitely. If the latch is waited on through {@link #initiateShutdown()}, new operations can no longer be added.\n  *\n  * @author Steven van Beelen\n  * @since 4.3\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjUwNQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856505", "bodyText": "See above. Consider moving this method to a \"Handle\".", "author": "abuijze", "createdAt": "2020-02-15T21:14:28Z", "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;\n+\n+    /**\n+     * Add an operation this latch should wait on before opening up. If this operation is called whilst {@link #await()}\n+     * is already called an {@link IllegalStateException} will be thrown.\n+     *\n+     * @throws IllegalStateException if {@link #await()} has been called prior to invoking this method\n+     */\n+    public void increment() {\n+        if (isShuttingDown()) {\n+            throw new IllegalStateException(\"No new operations can be added, since this latched is waited for.\");\n+        }\n+        operationCounter.incrementAndGet();\n+    }\n+\n+    /**\n+     * Remove an operation this latch waits on. This method should be invoked once the added operations has ended. This\n+     * method will complete the latch if {@link #await()} has been invoked abd all operations are removed.\n+     */\n+    public void decrement() {", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java b/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\nindex 1d63e842f..a951d561d 100644\n--- a/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\n+++ b/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\n\n@@ -1,18 +1,15 @@\n package org.axonframework.lifecycle;\n \n-import java.time.Duration;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Supplier;\n \n /**\n- * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n- * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n- * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n- * operations can no longer be added.\n+ * A latch implementation to be used in shutdown scenarios. Activities to wait for can be added by invoking {@link\n+ * #registerActivity()}. An registered activity should always shutdown through the returned {@link ActivityHandle}'s\n+ * {@link ActivityHandle#end()} method once it has completed. Otherwise {@link #initiateShutdown()} will block\n+ * indefinitely. If the latch is waited on through {@link #initiateShutdown()}, new operations can no longer be added.\n  *\n  * @author Steven van Beelen\n  * @since 4.3\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjU4NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856584", "bodyText": "This effectively initiates the shutdown process. Consider renaming to initiateShutdown", "author": "abuijze", "createdAt": "2020-02-15T21:15:53Z", "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;\n+\n+    /**\n+     * Add an operation this latch should wait on before opening up. If this operation is called whilst {@link #await()}\n+     * is already called an {@link IllegalStateException} will be thrown.\n+     *\n+     * @throws IllegalStateException if {@link #await()} has been called prior to invoking this method\n+     */\n+    public void increment() {\n+        if (isShuttingDown()) {\n+            throw new IllegalStateException(\"No new operations can be added, since this latched is waited for.\");\n+        }\n+        operationCounter.incrementAndGet();\n+    }\n+\n+    /**\n+     * Remove an operation this latch waits on. This method should be invoked once the added operations has ended. This\n+     * method will complete the latch if {@link #await()} has been invoked abd all operations are removed.\n+     */\n+    public void decrement() {\n+        if (operationCounter.decrementAndGet() <= 0 && isShuttingDown()) {\n+            latch.complete(null);\n+        }\n+    }\n+\n+    /**\n+     * Check whether this {@link ShutdownLatch} is waited on. The exception retrieved from the {@code exceptionSupplier}\n+     * will be thrown if this latch is shutting down.\n+     *\n+     * @param exceptionSupplier a {@link Supplier} of a {@link RuntimeException} to throw if this latch is waited on\n+     */\n+    public void isShuttingDown(Supplier<RuntimeException> exceptionSupplier) {\n+        if (isShuttingDown()) {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    /**\n+     * Check whether this {@link ShutdownLatch} is waited on.\n+     *\n+     * @return {@code true} if the latch is waited on, {@code false} otherwise\n+     */\n+    public boolean isShuttingDown() {\n+        return latch != null;\n+    }\n+\n+    /**\n+     * Wait for this latch to complete all the operations given to it through {@link #increment()}.\n+     *\n+     * @return a {@link CompletableFuture} which completes once all operations are done\n+     */\n+    public CompletableFuture<Void> await() {", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java b/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\nindex 1d63e842f..a951d561d 100644\n--- a/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\n+++ b/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\n\n@@ -1,18 +1,15 @@\n package org.axonframework.lifecycle;\n \n-import java.time.Duration;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Supplier;\n \n /**\n- * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n- * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n- * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n- * operations can no longer be added.\n+ * A latch implementation to be used in shutdown scenarios. Activities to wait for can be added by invoking {@link\n+ * #registerActivity()}. An registered activity should always shutdown through the returned {@link ActivityHandle}'s\n+ * {@link ActivityHandle#end()} method once it has completed. Otherwise {@link #initiateShutdown()} will block\n+ * indefinitely. If the latch is waited on through {@link #initiateShutdown()}, new operations can no longer be added.\n  *\n  * @author Steven van Beelen\n  * @since 4.3\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjY3Mw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856673", "bodyText": "Why is this necessary? Components already have the \"freedom\" to wait for the CompletableFuture to complete with a timeout.", "author": "abuijze", "createdAt": "2020-02-15T21:17:14Z", "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;\n+\n+    /**\n+     * Add an operation this latch should wait on before opening up. If this operation is called whilst {@link #await()}\n+     * is already called an {@link IllegalStateException} will be thrown.\n+     *\n+     * @throws IllegalStateException if {@link #await()} has been called prior to invoking this method\n+     */\n+    public void increment() {\n+        if (isShuttingDown()) {\n+            throw new IllegalStateException(\"No new operations can be added, since this latched is waited for.\");\n+        }\n+        operationCounter.incrementAndGet();\n+    }\n+\n+    /**\n+     * Remove an operation this latch waits on. This method should be invoked once the added operations has ended. This\n+     * method will complete the latch if {@link #await()} has been invoked abd all operations are removed.\n+     */\n+    public void decrement() {\n+        if (operationCounter.decrementAndGet() <= 0 && isShuttingDown()) {\n+            latch.complete(null);\n+        }\n+    }\n+\n+    /**\n+     * Check whether this {@link ShutdownLatch} is waited on. The exception retrieved from the {@code exceptionSupplier}\n+     * will be thrown if this latch is shutting down.\n+     *\n+     * @param exceptionSupplier a {@link Supplier} of a {@link RuntimeException} to throw if this latch is waited on\n+     */\n+    public void isShuttingDown(Supplier<RuntimeException> exceptionSupplier) {\n+        if (isShuttingDown()) {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    /**\n+     * Check whether this {@link ShutdownLatch} is waited on.\n+     *\n+     * @return {@code true} if the latch is waited on, {@code false} otherwise\n+     */\n+    public boolean isShuttingDown() {\n+        return latch != null;\n+    }\n+\n+    /**\n+     * Wait for this latch to complete all the operations given to it through {@link #increment()}.\n+     *\n+     * @return a {@link CompletableFuture} which completes once all operations are done\n+     */\n+    public CompletableFuture<Void> await() {\n+        latch = new CompletableFuture<>();\n+        return latch;\n+    }\n+\n+    /**\n+     * Wait for this latch to complete all the operations given to it through {@link #increment()}. If the given {@code\n+     * duration} has passed the returned {@link CompletableFuture} will be completed exceptionally.\n+     *\n+     * @param duration the time to wait for this latch to complete\n+     * @return a {@link CompletableFuture} which completes successfully once all operations are done or exceptionally\n+     * after the given {@code duration}\n+     */\n+    public CompletableFuture<Void> await(Duration duration) {", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA3MzIzMA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380073230", "bodyText": "If we for some reason want to have a duration on this method, it should be blocking. But I agree that we probably don't need this one.", "author": "m1l4n54v1c", "createdAt": "2020-02-17T09:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzNDg0MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380134840", "bodyText": "It's not used, no. Felt nice to include. Let's call this premature optimization, which I'll drop in favor of conciseness.", "author": "smcvb", "createdAt": "2020-02-17T11:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjY3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java b/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\nindex 1d63e842f..a951d561d 100644\n--- a/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\n+++ b/messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java\n\n@@ -1,18 +1,15 @@\n package org.axonframework.lifecycle;\n \n-import java.time.Duration;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Supplier;\n \n /**\n- * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n- * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n- * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n- * operations can no longer be added.\n+ * A latch implementation to be used in shutdown scenarios. Activities to wait for can be added by invoking {@link\n+ * #registerActivity()}. An registered activity should always shutdown through the returned {@link ActivityHandle}'s\n+ * {@link ActivityHandle#end()} method once it has completed. Otherwise {@link #initiateShutdown()} will block\n+ * indefinitely. If the latch is waited on through {@link #initiateShutdown()}, new operations can no longer be added.\n  *\n  * @author Steven van Beelen\n  * @since 4.3\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1Njc5OQ==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856799", "bodyText": "Strictly speaking, this is a backward-incompatible change...", "author": "abuijze", "createdAt": "2020-02-15T21:19:48Z", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/ParameterResolverFactory.java", "diffHunk": "@@ -52,5 +52,5 @@\n      * @param parameterIndex The index of the parameter to return a ParameterResolver for\n      * @return a suitable ParameterResolver, or {@code null} if none is found\n      */\n-    ParameterResolver createInstance(Executable executable, Parameter[] parameters, int parameterIndex);\n+    ParameterResolver<?> createInstance(Executable executable, Parameter[] parameters, int parameterIndex);", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1NjY5NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380156694", "bodyText": "Of course...I'll place this \"warning inducing issue\" back in then.", "author": "smcvb", "createdAt": "2020-02-17T12:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1Njc5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/messaging/src/main/java/org/axonframework/messaging/annotation/ParameterResolverFactory.java b/messaging/src/main/java/org/axonframework/messaging/annotation/ParameterResolverFactory.java\nindex 618171b7f..e2f34bd88 100644\n--- a/messaging/src/main/java/org/axonframework/messaging/annotation/ParameterResolverFactory.java\n+++ b/messaging/src/main/java/org/axonframework/messaging/annotation/ParameterResolverFactory.java\n\n@@ -52,5 +52,5 @@\n      * @param parameterIndex The index of the parameter to return a ParameterResolver for\n      * @return a suitable ParameterResolver, or {@code null} if none is found\n      */\n-    ParameterResolver<?> createInstance(Executable executable, Parameter[] parameters, int parameterIndex);\n+    ParameterResolver createInstance(Executable executable, Parameter[] parameters, int parameterIndex);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NzIwNw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379857207", "bodyText": "These methods were the reason this class implements SmartLifecycle. If this isn't necessary anymore, the SmartLifecycle methods can also be removed.", "author": "abuijze", "createdAt": "2020-02-15T21:27:17Z", "path": "spring/src/main/java/org/axonframework/spring/config/EventHandlerRegistrar.java", "diffHunk": "@@ -84,13 +87,11 @@ public void stop(Runnable callback) {\n \n     @Override\n     public void start() {\n-        eventProcessingConfiguration.start();", "originalCommit": "2ef829cce30a13105fe9c1d1398f2e0141393a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1ODIxMA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380158210", "bodyText": "Good point. I'll remove the SmartLifecycle implementation details from this class.", "author": "smcvb", "createdAt": "2020-02-17T12:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NzIwNw=="}], "type": "inlineReview", "revised_code": {"commit": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "chunk": "diff --git a/spring/src/main/java/org/axonframework/spring/config/EventHandlerRegistrar.java b/spring/src/main/java/org/axonframework/spring/config/EventHandlerRegistrar.java\nindex 96378d59f..e622d4270 100644\n--- a/spring/src/main/java/org/axonframework/spring/config/EventHandlerRegistrar.java\n+++ b/spring/src/main/java/org/axonframework/spring/config/EventHandlerRegistrar.java\n\n@@ -74,37 +71,6 @@ public void setEventHandlers(List<Object> beans) {\n         beans.forEach(b -> eventProcessingConfigurer.registerEventHandler(c -> b));\n     }\n \n-    @Override\n-    public boolean isAutoStartup() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void stop(Runnable callback) {\n-        stop();\n-        callback.run();\n-    }\n-\n-    @Override\n-    public void start() {\n-        running = true;\n-    }\n-\n-    @Override\n-    public void stop() {\n-        running = false;\n-    }\n-\n-    @Override\n-    public boolean isRunning() {\n-        return running;\n-    }\n-\n-    @Override\n-    public int getPhase() {\n-        return EARLY_PHASE;\n-    }\n-\n     @Override\n     public void afterPropertiesSet() {\n         if (!initialized) {\n"}}, {"oid": "0c96544fe0f7e20e26a4ebd5eb7a43490355a89e", "url": "https://github.com/AxonFramework/AxonFramework/commit/0c96544fe0f7e20e26a4ebd5eb7a43490355a89e", "message": "Merge remote-tracking branch 'origin/master' into feature/891", "committedDate": "2020-02-17T09:03:39Z", "type": "commit"}, {"oid": "96d60d235b78329cd2d6719cd3140f7eb59f32c2", "url": "https://github.com/AxonFramework/AxonFramework/commit/96d60d235b78329cd2d6719cd3140f7eb59f32c2", "message": "Process review comments\n\n-Remove generic wildcard mention on ParameterResolverFactory for\nbackwards compatibility\n-Rename shutdown handlers on the DistributedCommandBus and\nCommandBusConnector, as well as adjusting the phasing.\n-Update the ShutdownLatch to use an ActivityHandle to end a registered\nactivity. Rename methods and the adjust the javadoc accordingly\n-Create a dedicated ShutdownInProgressException to be thrown by the\nShutdownLatch in case registerActivity is called on a closing latch\n-Add distinct command and query outbound/inbound phases\n-Ensure the \"activity\" is registered prior to any possibility of\nderegistering. Adjust this behaviour for both the AxonServerCommandBus\nand AxonServerQueryBus\n-Remove all subscriptions in the shutdownDispatching phase instead of\nthe disconnect phase for the AxonServerCommandBus and AxonServerQueryBus\n-Fix await termination time in the AxonServerCommandBus and\nAxonServerQueryBus\n-Remove the SmartLifecycle implementation of the EventHandlerRegistrar\nentirely\n\n#891", "committedDate": "2020-02-17T13:18:11Z", "type": "commit"}, {"oid": "28b580fbf0e159add3cc30e199b9cc63c8173bc1", "url": "https://github.com/AxonFramework/AxonFramework/commit/28b580fbf0e159add3cc30e199b9cc63c8173bc1", "message": "Last ShutdownLatch improvements\n\n-Be more precise in the Javadoc\n-Add ifShuttingDown(String) method to overload the ifShuttingDown\n(Supplier<Exception) method\n-Make ActivityHandle#end idempotent\n-Fix bug in ActivityHandle#end method; firstInvocation check wasn't used\n-Change usage of ifShuttingDown in the AxonServer command and query bus\n\n#891", "committedDate": "2020-02-18T08:58:57Z", "type": "commit"}, {"oid": "0d1fa004fdd715658294fcc7f926dd0075bca207", "url": "https://github.com/AxonFramework/AxonFramework/commit/0d1fa004fdd715658294fcc7f926dd0075bca207", "message": "Introduce timeout for the phased lifecycle process\n\nThe invocation of start/shutdown handlers will now wait indefinitely.\nIntroducing a time out is thus necessary to ensure start/shutdown does\nno become an never ending process\n\n#891", "committedDate": "2020-02-18T12:34:10Z", "type": "commit"}, {"oid": "0e8f3a50c3d2ce30858f7c159c116c9006ce5397", "url": "https://github.com/AxonFramework/AxonFramework/commit/0e8f3a50c3d2ce30858f7c159c116c9006ce5397", "message": "Even further ShutdownLatch improvements\n\n-Introduce an initialize method, so that the latch can be started again\n-Use an atomic reference of a CompletableFuture as the latch to be\nthread safe\n-Make sure that initiateShutdown can complete the latch immediately in\ncase no activities are present\n\n#891", "committedDate": "2020-02-18T12:35:32Z", "type": "commit"}, {"oid": "fbe2814478820573c09961a4ac068e019106bc1c", "url": "https://github.com/AxonFramework/AxonFramework/commit/fbe2814478820573c09961a4ac068e019106bc1c", "message": "Add start handlers\n\nAdd StartHandler annotated methods to initialize the ShutdownLatch\n\n#891", "committedDate": "2020-02-18T12:36:27Z", "type": "commit"}, {"oid": "86323a03967a51c208e7e1a303defc049163780d", "url": "https://github.com/AxonFramework/AxonFramework/commit/86323a03967a51c208e7e1a303defc049163780d", "message": "Merge remote-tracking branch 'origin/master' into feature/891", "committedDate": "2020-02-18T12:55:57Z", "type": "commit"}, {"oid": "1ae9bd42c108d49e91a5882aa9b34500c852667e", "url": "https://github.com/AxonFramework/AxonFramework/commit/1ae9bd42c108d49e91a5882aa9b34500c852667e", "message": "Merge remote-tracking branch 'origin/master' into feature/891", "committedDate": "2020-02-18T14:55:29Z", "type": "commit"}, {"oid": "c8a9528494d05994da038613080e10a76303f4ff", "url": "https://github.com/AxonFramework/AxonFramework/commit/c8a9528494d05994da038613080e10a76303f4ff", "message": "Ensure the stream observers are completed\n\nEnsure the stream observers are completed upon a disconnect and\nunsubscribeAll\n\n#891", "committedDate": "2020-02-18T15:59:20Z", "type": "commit"}, {"oid": "82cc572872dd850e55f08f3e4374020ea8681a2a", "url": "https://github.com/AxonFramework/AxonFramework/commit/82cc572872dd850e55f08f3e4374020ea8681a2a", "message": "Introduce cleaner shutdown approach\n\nUse the shutdownNow method as is for existing cases. On a disconnect, we\n can do a shutdown + await termination process. Thus ensure we do not\n harshly close the stream(s) when the ShutdownHandler is called\n\n#891", "committedDate": "2020-02-18T16:54:05Z", "type": "commit"}, {"oid": "ebb59e2644b5a28c3c9fa267aa1bff94f9d37c8d", "url": "https://github.com/AxonFramework/AxonFramework/commit/ebb59e2644b5a28c3c9fa267aa1bff94f9d37c8d", "message": "Use a thead safe list\n\nUse a thead safe list to start lifecycle handlers in, as handlers can be\n registered in the phase being active at that point in time\n\n#891", "committedDate": "2020-02-18T16:55:26Z", "type": "commit"}, {"oid": "40cb0dcfd1dd60b6e09d1de95531fa37e6283791", "url": "https://github.com/AxonFramework/AxonFramework/commit/40cb0dcfd1dd60b6e09d1de95531fa37e6283791", "message": "Introduce onInit method\n\nAdd an onInit method through which users can add handlers which should\nbe called prior to starting the start-phase\n\n#891", "committedDate": "2020-02-18T16:56:18Z", "type": "commit"}, {"oid": "d7a407fe82cf556607197f5f70e1e41fa880bd75", "url": "https://github.com/AxonFramework/AxonFramework/commit/d7a407fe82cf556607197f5f70e1e41fa880bd75", "message": "Slight logging expansion\n\nSlight logging expansion on the Component to state the actual instance\nbeing instantiated\n\n#891", "committedDate": "2020-02-19T10:36:08Z", "type": "commit"}, {"oid": "7559600bcea6f4691e9d333a703471ee99ff33e3", "url": "https://github.com/AxonFramework/AxonFramework/commit/7559600bcea6f4691e9d333a703471ee99ff33e3", "message": "Adjust bean-as-component registration\n\nThrough Spring wiring we aren't always ensured the components are\ninstantiated through the Component class. Thus, no certainty the\nLifecycleHandlerInspector is invoked. Hence we should ensure that for\nsome of the component in a Spring environment we enforce an init-handler\n to be added in the earliest phase possible, which simply pulls the\n object from the Configuration\n\n#891", "committedDate": "2020-02-19T10:39:18Z", "type": "commit"}, {"oid": "fc114f1af787477db64b94abdcd037c46439f0b6", "url": "https://github.com/AxonFramework/AxonFramework/commit/fc114f1af787477db64b94abdcd037c46439f0b6", "message": "Rename onInit to onInitialize\n\nRename onInit to onInitialize\n\n#891", "committedDate": "2020-02-19T10:45:34Z", "type": "commit"}, {"oid": "58d82931577eb561d7139e173b5b223607742f8e", "url": "https://github.com/AxonFramework/AxonFramework/commit/58d82931577eb561d7139e173b5b223607742f8e", "message": "Fixed issue in loading repository for Aggregate", "committedDate": "2020-02-19T11:50:26Z", "type": "commit"}, {"oid": "28cb987fbcde57e489e050309a014586ae844b2b", "url": "https://github.com/AxonFramework/AxonFramework/commit/28cb987fbcde57e489e050309a014586ae844b2b", "message": "Removed race conditions from AxonServer Command and QueryBus tests", "committedDate": "2020-02-19T12:45:33Z", "type": "commit"}]}