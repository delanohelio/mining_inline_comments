{"pr_number": 4589, "pr_title": "Persistence redesign", "pr_createdAt": "2020-10-02T04:06:15Z", "pr_url": "https://github.com/bisq-network/bisq/pull/4589", "timeline": [{"oid": "207d0989612c70dadb7d333cbedced06b9cf3548", "url": "https://github.com/bisq-network/bisq/commit/207d0989612c70dadb7d333cbedced06b9cf3548", "message": "Fix rename mistakes", "committedDate": "2020-10-02T21:48:37Z", "type": "forcePushed"}, {"oid": "8aff1f8665e4446179451d883cc2bda964ed6f16", "url": "https://github.com/bisq-network/bisq/commit/8aff1f8665e4446179451d883cc2bda964ed6f16", "message": "Refactor: Move FileUtil", "committedDate": "2020-10-03T17:48:14Z", "type": "commit"}, {"oid": "23507102ddad8a842a252e61396c75f851308543", "url": "https://github.com/bisq-network/bisq/commit/23507102ddad8a842a252e61396c75f851308543", "message": "Refactor: Move CorruptedDatabaseFilesHandler", "committedDate": "2020-10-03T17:48:14Z", "type": "commit"}, {"oid": "cda9d9eccf32804e62fa82c83f87da9c9b3ad419", "url": "https://github.com/bisq-network/bisq/commit/cda9d9eccf32804e62fa82c83f87da9c9b3ad419", "message": "Refactor: Move other 2 classes to file package", "committedDate": "2020-10-03T17:48:14Z", "type": "commit"}, {"oid": "802dcad2fb4fab976f618bc94b5ca0ab9021d04a", "url": "https://github.com/bisq-network/bisq/commit/802dcad2fb4fab976f618bc94b5ca0ab9021d04a", "message": "Refactor: Rename CorruptedDatabaseFilesHandler", "committedDate": "2020-10-03T17:48:14Z", "type": "commit"}, {"oid": "d27e4dc24970204e04ced49ff87aff7f4f4c1b60", "url": "https://github.com/bisq-network/bisq/commit/d27e4dc24970204e04ced49ff87aff7f4f4c1b60", "message": "Refactor: Rename fields and methods, return early", "committedDate": "2020-10-03T17:48:14Z", "type": "commit"}, {"oid": "6f6836f733bc571836ab6d981fa94887d10b434d", "url": "https://github.com/bisq-network/bisq/commit/6f6836f733bc571836ab6d981fa94887d10b434d", "message": "Refactor: Add removeAndBackupFile method", "committedDate": "2020-10-03T17:48:15Z", "type": "commit"}, {"oid": "85b33bcfce2532e7d7bd579e8d733b10c955adca", "url": "https://github.com/bisq-network/bisq/commit/85b33bcfce2532e7d7bd579e8d733b10c955adca", "message": "Remove awaitTermination\nRemove UserThread.execute on shutdown\nRename threadname", "committedDate": "2020-10-03T17:48:15Z", "type": "commit"}, {"oid": "92c9c3cd7e4ae27e5c2446cf73b024e94756d756", "url": "https://github.com/bisq-network/bisq/commit/92c9c3cd7e4ae27e5c2446cf73b024e94756d756", "message": "Add getDefaultStorageFileName method", "committedDate": "2020-10-03T17:48:15Z", "type": "commit"}, {"oid": "937c006d73ebb2cfeb590d54a908b3073eaf3c9a", "url": "https://github.com/bisq-network/bisq/commit/937c006d73ebb2cfeb590d54a908b3073eaf3c9a", "message": "Add PersistenceManager class", "committedDate": "2020-10-03T17:48:15Z", "type": "commit"}, {"oid": "fd0cc63e7cb0611fc68e1bbb5f5ac3156ac1e365", "url": "https://github.com/bisq-network/bisq/commit/fd0cc63e7cb0611fc68e1bbb5f5ac3156ac1e365", "message": "Refactor: use FileUtil.removeAndBackupFile instead of FileManager.removeAndBackupFile", "committedDate": "2020-10-03T17:48:15Z", "type": "commit"}, {"oid": "c245026eff44e5c0b582ebfaccf801c2c90b1581", "url": "https://github.com/bisq-network/bisq/commit/c245026eff44e5c0b582ebfaccf801c2c90b1581", "message": "Remove Storage and FileManager from logback", "committedDate": "2020-10-03T17:48:15Z", "type": "commit"}, {"oid": "93f1108a776fa6d1e0478ec3eb1025350b6ddddf", "url": "https://github.com/bisq-network/bisq/commit/93f1108a776fa6d1e0478ec3eb1025350b6ddddf", "message": "Add PersistenceManager.flushAllDataToDisk to shutdown to write all pending data to disk\nUse new readAllPersisted method instead of setupPersistedDataHosts. Run read tasks in a thread in parallel.\n\nRead is only done at startup.\n\nRemove unused restart method", "committedDate": "2020-10-03T17:48:15Z", "type": "commit"}, {"oid": "4f3ded6acfe9b6bca2f32ce5302fb697443e22f0", "url": "https://github.com/bisq-network/bisq/commit/4f3ded6acfe9b6bca2f32ce5302fb697443e22f0", "message": "Use PersistenceManager instead of Storage for import/export", "committedDate": "2020-10-03T17:48:15Z", "type": "commit"}, {"oid": "35d9338615a48d30bd72efd31db186b7a629819c", "url": "https://github.com/bisq-network/bisq/commit/35d9338615a48d30bd72efd31db186b7a629819c", "message": "Remove UserThreadMappedPersistableList and use PersistableList instead\n\nWe will not need threading support anymore once we use the new persistenceManager as serialisation is done on the userThread.", "committedDate": "2020-10-03T17:48:15Z", "type": "commit"}, {"oid": "d3be8dd48bc4197d4ba50aac3e3d5f9ebbe13669", "url": "https://github.com/bisq-network/bisq/commit/d3be8dd48bc4197d4ba50aac3e3d5f9ebbe13669", "message": "Remove UserThreadMappedPersistableEnvelope and use PersistableEnvelope instead\n\nWe will not need threading support anymore once we use the new persistenceManager as serialisation is done on the userThread.", "committedDate": "2020-10-03T17:48:16Z", "type": "commit"}, {"oid": "3a348d5a0ffa37436782f28e4c6b6e3790dd1817", "url": "https://github.com/bisq-network/bisq/commit/3a348d5a0ffa37436782f28e4c6b6e3790dd1817", "message": "Remove ThreadedPersistableEnvelope and use PersistableEnvelope instead\n\nWe will not need threading support anymore once we use the new persistenceManager as serialisation is done on the userThread.", "committedDate": "2020-10-03T17:48:16Z", "type": "commit"}, {"oid": "2e55251bcff3cbb66615c4cdb14c144e119f0cf1", "url": "https://github.com/bisq-network/bisq/commit/2e55251bcff3cbb66615c4cdb14c144e119f0cf1", "message": "Use PersistenceManager for StoreService (not yet supported for subclasses)", "committedDate": "2020-10-03T17:48:16Z", "type": "commit"}, {"oid": "92b0ea9f13654506ef4e7c926d570f13a3959d8e", "url": "https://github.com/bisq-network/bisq/commit/92b0ea9f13654506ef4e7c926d570f13a3959d8e", "message": "Use PersistenceManager for MapStoreService (not yet supported for subclasses)", "committedDate": "2020-10-03T17:48:16Z", "type": "commit"}, {"oid": "5a1cd0ee2c4e5fd3ad5be20915a391b3fb94a890", "url": "https://github.com/bisq-network/bisq/commit/5a1cd0ee2c4e5fd3ad5be20915a391b3fb94a890", "message": "Use PersistableNetworkPayloadStore for AppendOnlyDataStoreService", "committedDate": "2020-10-03T17:48:16Z", "type": "commit"}, {"oid": "e2f0f61943d196ba05cc7112a5a2f64e7f35d741", "url": "https://github.com/bisq-network/bisq/commit/e2f0f61943d196ba05cc7112a5a2f64e7f35d741", "message": "Update PersistableNetworkPayloadStore", "committedDate": "2020-10-03T17:48:16Z", "type": "commit"}, {"oid": "0682b991f7493470302a600463e478d25b9d9e0d", "url": "https://github.com/bisq-network/bisq/commit/0682b991f7493470302a600463e478d25b9d9e0d", "message": "Update ProtectedDataStoreService\nUse AtomicReference instead of array, add final", "committedDate": "2020-10-03T17:48:16Z", "type": "commit"}, {"oid": "94944393cf1f19a4f00c853627ba6f0ed31206bf", "url": "https://github.com/bisq-network/bisq/commit/94944393cf1f19a4f00c853627ba6f0ed31206bf", "message": "Use PersistenceManager in HistoricalDataStoreService", "committedDate": "2020-10-03T17:48:16Z", "type": "commit"}, {"oid": "827775c32c46522f54d09683fed0e8978c9ad970", "url": "https://github.com/bisq-network/bisq/commit/827775c32c46522f54d09683fed0e8978c9ad970", "message": "Add missing import", "committedDate": "2020-10-03T17:48:16Z", "type": "commit"}, {"oid": "34d89092ad33ab0e5e693f4b2d06d0fbdb4a4a0d", "url": "https://github.com/bisq-network/bisq/commit/34d89092ad33ab0e5e693f4b2d06d0fbdb4a4a0d", "message": "Add final at ResourceDataStoreService\nRemove clone from SequenceNumberMap.", "committedDate": "2020-10-03T17:48:17Z", "type": "commit"}, {"oid": "a4acddac4aff705036a4566e772a774ef7b4ce46", "url": "https://github.com/bisq-network/bisq/commit/a4acddac4aff705036a4566e772a774ef7b4ce46", "message": "Apply generics and super class methods", "committedDate": "2020-10-03T17:48:17Z", "type": "commit"}, {"oid": "dc77b5cab851cadbb51ce1fdbce368e25eeeb560", "url": "https://github.com/bisq-network/bisq/commit/dc77b5cab851cadbb51ce1fdbce368e25eeeb560", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:17Z", "type": "commit"}, {"oid": "d9a7aacf98a3f2858a4eaf4fe3ea7b5b8edabeac", "url": "https://github.com/bisq-network/bisq/commit/d9a7aacf98a3f2858a4eaf4fe3ea7b5b8edabeac", "message": "Update SignedWitness classes", "committedDate": "2020-10-03T17:48:17Z", "type": "commit"}, {"oid": "8781c80fb03aba6678a0ac4d67ba5848856f1db2", "url": "https://github.com/bisq-network/bisq/commit/8781c80fb03aba6678a0ac4d67ba5848856f1db2", "message": "Update AccountAgeWitnessStorage classes", "committedDate": "2020-10-03T17:48:17Z", "type": "commit"}, {"oid": "e6211ef9fe1a071c7d892644b38baa5aa7e8d351", "url": "https://github.com/bisq-network/bisq/commit/e6211ef9fe1a071c7d892644b38baa5aa7e8d351", "message": "Update TempProposalStore and ProposalStore classes", "committedDate": "2020-10-03T17:48:17Z", "type": "commit"}, {"oid": "9190f17966fb559556e05de92d497512121a0d4a", "url": "https://github.com/bisq-network/bisq/commit/9190f17966fb559556e05de92d497512121a0d4a", "message": "Update TradeStatistics2Storage classes", "committedDate": "2020-10-03T17:48:17Z", "type": "commit"}, {"oid": "074ed6753bc2354c7eaf0aed17abf63a541c4d56", "url": "https://github.com/bisq-network/bisq/commit/074ed6753bc2354c7eaf0aed17abf63a541c4d56", "message": "Remove lombok Delegate from PersistableList\nAdd final\nAdd setAll method\nRemove Iterable interface", "committedDate": "2020-10-03T17:48:17Z", "type": "commit"}, {"oid": "80e16a05ef3becffdb600582c412e1becf69a774", "url": "https://github.com/bisq-network/bisq/commit/80e16a05ef3becffdb600582c412e1becf69a774", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:17Z", "type": "commit"}, {"oid": "308c970b68017934063a8b17bee0ab79da8fcb1e", "url": "https://github.com/bisq-network/bisq/commit/308c970b68017934063a8b17bee0ab79da8fcb1e", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:17Z", "type": "commit"}, {"oid": "878f64555cad934c178ded6458b0f39451bf5413", "url": "https://github.com/bisq-network/bisq/commit/878f64555cad934c178ded6458b0f39451bf5413", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:18Z", "type": "commit"}, {"oid": "5d6cbf5e23089e5f760adb2612560f2eb233d073", "url": "https://github.com/bisq-network/bisq/commit/5d6cbf5e23089e5f760adb2612560f2eb233d073", "message": "Refactor: Move classes to new package", "committedDate": "2020-10-03T17:48:18Z", "type": "commit"}, {"oid": "0eb99f77ef8bed5eeee2988fc677fdaf68c41d35", "url": "https://github.com/bisq-network/bisq/commit/0eb99f77ef8bed5eeee2988fc677fdaf68c41d35", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:18Z", "type": "commit"}, {"oid": "8f38de30e913178586e5d6fb9a1c8bcbbb71fe17", "url": "https://github.com/bisq-network/bisq/commit/8f38de30e913178586e5d6fb9a1c8bcbbb71fe17", "message": "Use PersistableList as base class", "committedDate": "2020-10-03T17:48:18Z", "type": "commit"}, {"oid": "158b7a92f9d6d79d900736946d98098d37199be4", "url": "https://github.com/bisq-network/bisq/commit/158b7a92f9d6d79d900736946d98098d37199be4", "message": "Remove storage from dispute. We do persistence from outside now.\nImpl. PersistablePayload\nMake openingDate final and contr param", "committedDate": "2020-10-03T17:48:18Z", "type": "commit"}, {"oid": "8a6b2a77d645c142807bb1a13597ef3ba079d4cd", "url": "https://github.com/bisq-network/bisq/commit/8a6b2a77d645c142807bb1a13597ef3ba079d4cd", "message": "Use PersistenceManager. Make disputeList final", "committedDate": "2020-10-03T17:48:18Z", "type": "commit"}, {"oid": "2d91c268d07f8f9b25e348b740f1e69a5bb31db8", "url": "https://github.com/bisq-network/bisq/commit/2d91c268d07f8f9b25e348b740f1e69a5bb31db8", "message": "Remove storage and persist calls. Remove unused methods", "committedDate": "2020-10-03T17:48:18Z", "type": "commit"}, {"oid": "1e91b09f7df3f8960bbc055696b6d0ff51579c2b", "url": "https://github.com/bisq-network/bisq/commit/1e91b09f7df3f8960bbc055696b6d0ff51579c2b", "message": "Remove persist method", "committedDate": "2020-10-03T17:48:18Z", "type": "commit"}, {"oid": "63fe1c9dbd017f86275b025c577517f59c1635fb", "url": "https://github.com/bisq-network/bisq/commit/63fe1c9dbd017f86275b025c577517f59c1635fb", "message": "Remove storage", "committedDate": "2020-10-03T17:48:18Z", "type": "commit"}, {"oid": "4f1857700232123aa820547a2a97560ef4493817", "url": "https://github.com/bisq-network/bisq/commit/4f1857700232123aa820547a2a97560ef4493817", "message": "Extend PersistableList, remvoe storage", "committedDate": "2020-10-03T17:48:19Z", "type": "commit"}, {"oid": "f6be9b0f6bc22b43bdced1af07780a4126312a59", "url": "https://github.com/bisq-network/bisq/commit/f6be9b0f6bc22b43bdced1af07780a4126312a59", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:19Z", "type": "commit"}, {"oid": "2582f58e0a0cf7cc4845f40fe6e4221496db46e0", "url": "https://github.com/bisq-network/bisq/commit/2582f58e0a0cf7cc4845f40fe6e4221496db46e0", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:19Z", "type": "commit"}, {"oid": "f4165dc9af66ef27a5391146ec8dd573340487e7", "url": "https://github.com/bisq-network/bisq/commit/f4165dc9af66ef27a5391146ec8dd573340487e7", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:19Z", "type": "commit"}, {"oid": "c3c869b5ad45414ef1794f76a63f1dc8c112c778", "url": "https://github.com/bisq-network/bisq/commit/c3c869b5ad45414ef1794f76a63f1dc8c112c778", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:19Z", "type": "commit"}, {"oid": "d4f460b4b0c5adc7d4e0fb3d178106b68769cb6e", "url": "https://github.com/bisq-network/bisq/commit/d4f460b4b0c5adc7d4e0fb3d178106b68769cb6e", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:19Z", "type": "commit"}, {"oid": "406afa9dad20386ad8b9d311cf23f6b4bdcb5468", "url": "https://github.com/bisq-network/bisq/commit/406afa9dad20386ad8b9d311cf23f6b4bdcb5468", "message": "Use PersistenceManager. Add setAll method", "committedDate": "2020-10-03T17:48:19Z", "type": "commit"}, {"oid": "fae1cda7013c498cde24cc94bdee20f60fb860bf", "url": "https://github.com/bisq-network/bisq/commit/fae1cda7013c498cde24cc94bdee20f60fb860bf", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:19Z", "type": "commit"}, {"oid": "986f1bf33c7ce7bc5b68aa6ae90fdfdb28d0c27b", "url": "https://github.com/bisq-network/bisq/commit/986f1bf33c7ce7bc5b68aa6ae90fdfdb28d0c27b", "message": "Use PersistenceManager. We do not persist inside openOffer anymore but from outside", "committedDate": "2020-10-03T17:48:19Z", "type": "commit"}, {"oid": "27c2cb894c0e7fa195d1554ddf90b75765579459", "url": "https://github.com/bisq-network/bisq/commit/27c2cb894c0e7fa195d1554ddf90b75765579459", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:20Z", "type": "commit"}, {"oid": "e0ea742a47014a769171a6b2692e75c2840f2c53", "url": "https://github.com/bisq-network/bisq/commit/e0ea742a47014a769171a6b2692e75c2840f2c53", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:20Z", "type": "commit"}, {"oid": "e825613f5c163ac8beb6ae7dc3630e6403201bac", "url": "https://github.com/bisq-network/bisq/commit/e825613f5c163ac8beb6ae7dc3630e6403201bac", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:20Z", "type": "commit"}, {"oid": "fac42008256255895d76d5e2eaf378fa42218f4f", "url": "https://github.com/bisq-network/bisq/commit/fac42008256255895d76d5e2eaf378fa42218f4f", "message": "Remove unused fields, apply new params", "committedDate": "2020-10-03T17:48:20Z", "type": "commit"}, {"oid": "486e6f49858215876d8d383cf59bb8575dc5cd6b", "url": "https://github.com/bisq-network/bisq/commit/486e6f49858215876d8d383cf59bb8575dc5cd6b", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:20Z", "type": "commit"}, {"oid": "9da13c35f233c21b5c074516a69bc224824a3515", "url": "https://github.com/bisq-network/bisq/commit/9da13c35f233c21b5c074516a69bc224824a3515", "message": "Refactor: Rename persist to requestPersistence", "committedDate": "2020-10-03T17:48:20Z", "type": "commit"}, {"oid": "482bc560363431c20fa065733dce1e93b97471a2", "url": "https://github.com/bisq-network/bisq/commit/482bc560363431c20fa065733dce1e93b97471a2", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:20Z", "type": "commit"}, {"oid": "fe4c21b35cdb101d71c411cfb61e849a67e5c656", "url": "https://github.com/bisq-network/bisq/commit/fe4c21b35cdb101d71c411cfb61e849a67e5c656", "message": "Use PersistenceManager", "committedDate": "2020-10-03T17:48:20Z", "type": "commit"}, {"oid": "197e871a7bc14b8858b7ea2af1ae0677886cd422", "url": "https://github.com/bisq-network/bisq/commit/197e871a7bc14b8858b7ea2af1ae0677886cd422", "message": "Remove FileManager ans Storage. All is replaces not by PersistenceManager", "committedDate": "2020-10-03T17:48:20Z", "type": "commit"}, {"oid": "42e10f28b7ef198a4559968222979f5a007babf4", "url": "https://github.com/bisq-network/bisq/commit/42e10f28b7ef198a4559968222979f5a007babf4", "message": "Apply generics", "committedDate": "2020-10-03T17:48:21Z", "type": "commit"}, {"oid": "a797413c7e396cf69e86a6e9ce9892c28938cd29", "url": "https://github.com/bisq-network/bisq/commit/a797413c7e396cf69e86a6e9ce9892c28938cd29", "message": "Remove persist method", "committedDate": "2020-10-03T17:48:21Z", "type": "commit"}, {"oid": "7b4611e177fdb0afdf1dc07149f75788aa6f5d8b", "url": "https://github.com/bisq-network/bisq/commit/7b4611e177fdb0afdf1dc07149f75788aa6f5d8b", "message": "Add requestPersistence call\nCleanups", "committedDate": "2020-10-03T17:48:21Z", "type": "commit"}, {"oid": "b901f358a74a679d80c5ab5afeea431a6a306988", "url": "https://github.com/bisq-network/bisq/commit/b901f358a74a679d80c5ab5afeea431a6a306988", "message": "Add missing persist calls. Add generics. Remove persist method. Add final.", "committedDate": "2020-10-03T17:48:21Z", "type": "commit"}, {"oid": "253c6c3336f0f8cbef38fa67119bdd553a069b17", "url": "https://github.com/bisq-network/bisq/commit/253c6c3336f0f8cbef38fa67119bdd553a069b17", "message": "Remove unneeded param. Add requestPersistence calls. Cleanup removeTrade and addTrade methods", "committedDate": "2020-10-03T17:48:21Z", "type": "commit"}, {"oid": "fa0d26139760674a7dc83d4583146b8d8cabd2ea", "url": "https://github.com/bisq-network/bisq/commit/fa0d26139760674a7dc83d4583146b8d8cabd2ea", "message": "Fix remaining issues, cleanups, add persit calls, remove unused code,...\n\nSorry too tired to create another 20 commits...", "committedDate": "2020-10-03T17:48:21Z", "type": "commit"}, {"oid": "270e89a25a8f6ba861c877a2557bc63e7fd112fa", "url": "https://github.com/bisq-network/bisq/commit/270e89a25a8f6ba861c877a2557bc63e7fd112fa", "message": "Fix wrong params", "committedDate": "2020-10-03T17:48:21Z", "type": "commit"}, {"oid": "ccfda5b043a0c20cd9061ca676f05763ccff0477", "url": "https://github.com/bisq-network/bisq/commit/ccfda5b043a0c20cd9061ca676f05763ccff0477", "message": "Cleanups, add generics, add final, remove unused code/comments/todos,", "committedDate": "2020-10-03T17:48:21Z", "type": "commit"}, {"oid": "5f47ed20d8294f5c7cd6806a0ccb5f39ce3e0770", "url": "https://github.com/bisq-network/bisq/commit/5f47ed20d8294f5c7cd6806a0ccb5f39ce3e0770", "message": "Use decrementAndGet instead of getAndDecrement", "committedDate": "2020-10-03T17:48:21Z", "type": "commit"}, {"oid": "e242c54dab128aaa1a2605a00604f8bdb68db332", "url": "https://github.com/bisq-network/bisq/commit/e242c54dab128aaa1a2605a00604f8bdb68db332", "message": "Refactor: Rename getTradesAsObservableList to getObservableList", "committedDate": "2020-10-03T17:48:22Z", "type": "commit"}, {"oid": "e88a810dd09575082e4fbca7f577eef58daba518", "url": "https://github.com/bisq-network/bisq/commit/e88a810dd09575082e4fbca7f577eef58daba518", "message": "Revert exit code to 1 as it was before. Not sure if there have been some scripts for seeds which expect an error code at shutdown for auto restart. I remotely remember there have been something...", "committedDate": "2020-10-03T17:48:22Z", "type": "commit"}, {"oid": "c789650d0b90fc31a120eadc20e4c735dddf4ccc", "url": "https://github.com/bisq-network/bisq/commit/c789650d0b90fc31a120eadc20e4c735dddf4ccc", "message": "Move methods to base class", "committedDate": "2020-10-03T17:48:22Z", "type": "commit"}, {"oid": "32238f2050a151b2ea545bea331d06270426cd1c", "url": "https://github.com/bisq-network/bisq/commit/32238f2050a151b2ea545bea331d06270426cd1c", "message": "Rename getClosedTradables and getFailedTrades to getObservableList", "committedDate": "2020-10-03T17:48:22Z", "type": "commit"}, {"oid": "b712445e34d3f4240612e2859ff24f26ff59f420", "url": "https://github.com/bisq-network/bisq/commit/b712445e34d3f4240612e2859ff24f26ff59f420", "message": "Remove duplicate startApplication call. Remove checkCryptoSetup call and fields used only for that.", "committedDate": "2020-10-03T17:48:22Z", "type": "commit"}, {"oid": "232fa8ddee2c1d9308061d0f133429f2db0cf5d5", "url": "https://github.com/bisq-network/bisq/commit/232fa8ddee2c1d9308061d0f133429f2db0cf5d5", "message": "Execute result handler on userThread", "committedDate": "2020-10-03T17:48:22Z", "type": "commit"}, {"oid": "10e9b054a047891fa03e72bf2d267c2d1a3d46a4", "url": "https://github.com/bisq-network/bisq/commit/10e9b054a047891fa03e72bf2d267c2d1a3d46a4", "message": "Rename writeCompleted to onWriteCompleted\nAdd comment\nUse decrementAndGet instead of getAndDecrement\n\nTested cases when there is an exception at write to disk, but as we call the result handler in the finally clause we get always called onWriteCompleted, so it cannot happen that we get stuck.", "committedDate": "2020-10-03T17:48:22Z", "type": "commit"}, {"oid": "18f64d53ca693b8400967ab6cc41a1dd0b1228d0", "url": "https://github.com/bisq-network/bisq/commit/18f64d53ca693b8400967ab6cc41a1dd0b1228d0", "message": "Persist all Priority.HIGH stores at shutdown to be more safe that we did not miss any state update.\nPriority.HIGH stores are all those which contain private data. Others can be rebuilt from network data or are not critical like navigationPath.", "committedDate": "2020-10-03T17:48:22Z", "type": "commit"}, {"oid": "137b5e81d12936b9399ccc0888fcccebd3589b5e", "url": "https://github.com/bisq-network/bisq/commit/137b5e81d12936b9399ccc0888fcccebd3589b5e", "message": "Enforce that clients set the priority. Remove the initialize methods which did not have priority as a param.\nMake initializePersistenceManager in StorageService abstract to enforce in concrete class to define priority.\n\nChange priorities for future renaming to a different meaning. instead of priority we want to describe the category: private data, public data,.... will come in next commit", "committedDate": "2020-10-03T17:48:22Z", "type": "commit"}, {"oid": "e9db7c6808b822c4cc4675eabe9ffbc4b0fae253", "url": "https://github.com/bisq-network/bisq/commit/e9db7c6808b822c4cc4675eabe9ffbc4b0fae253", "message": "Rename Priority to Source. This should make it more clear what is the intention of the usage.\n\nRename:\nLOW to NETWORK\nMID to PRIVATE_LOW_PRIO\nHIGH to PRIVATE\n\nChange delay of MID/PRIVATE_LOW_PRIO from 30 min to 2 hours (we had different datastores before using it, now its only real low prio stores)\n\nAdd comment to each enum", "committedDate": "2020-10-03T17:48:23Z", "type": "commit"}, {"oid": "c9cd58a3783f996eac06873e8529eb02a3ccdbe4", "url": "https://github.com/bisq-network/bisq/commit/c9cd58a3783f996eac06873e8529eb02a3ccdbe4", "message": "Fix rename mistakes", "committedDate": "2020-10-03T17:48:23Z", "type": "commit"}, {"oid": "6693a03f96e45c3ecd98bb879d91c7274c971784", "url": "https://github.com/bisq-network/bisq/commit/6693a03f96e45c3ecd98bb879d91c7274c971784", "message": "Fix test class", "committedDate": "2020-10-03T17:48:23Z", "type": "commit"}, {"oid": "6693a03f96e45c3ecd98bb879d91c7274c971784", "url": "https://github.com/bisq-network/bisq/commit/6693a03f96e45c3ecd98bb879d91c7274c971784", "message": "Fix test class", "committedDate": "2020-10-03T17:48:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1MzE2OA==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499153168", "bodyText": "To reduce confusion, how about\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    openInstances.decrementAndGet();\n          \n          \n            \n                    if (openInstances.get() == 0) {\n          \n          \n            \n                    if (openInstances.decrementAndGet() == 0) {", "author": "sqrrm", "createdAt": "2020-10-03T14:37:05Z", "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.common.persistence;\n+\n+import bisq.common.Timer;\n+import bisq.common.UserThread;\n+import bisq.common.app.DevEnv;\n+import bisq.common.config.Config;\n+import bisq.common.file.CorruptedStorageFileHandler;\n+import bisq.common.file.FileUtil;\n+import bisq.common.handlers.ResultHandler;\n+import bisq.common.proto.persistable.PersistableEnvelope;\n+import bisq.common.proto.persistable.PersistenceProtoResolver;\n+import bisq.common.util.Utilities;\n+\n+import com.google.inject.Inject;\n+\n+import javax.inject.Named;\n+\n+import java.nio.file.Path;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nullable;\n+\n+import static bisq.common.util.Preconditions.checkDir;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Responsible for reading persisted data and writing it on disk. We read usually only at start-up and keep data in RAM.\n+ * We write all data which got a request for persistence at shut down at the very last moment when all other services\n+ * are shut down, so allowing changes to the data in the very last moment. For critical data we set {@link Source}\n+ * to HIGH which causes a timer to trigger a write to disk after 1 minute. We use that for not very frequently altered\n+ * data and data which cannot be recovered from the network.\n+ *\n+ * We decided to not use threading (as it was in previous versions) as the read operation happens only at start-up and\n+ * with the modified model that data is written at shut down we eliminate frequent and expensive disk I/O. Risks of\n+ * deadlock or data inconsistency and a more complex model have been a further argument for that model. In fact\n+ * previously we wasted a lot of resources as way too many threads have been created without doing actual work as well\n+ * the write operations got triggered way too often specially for the very frequent changes at SequenceNumberMap and\n+ * the very large DaoState (at dao blockchain sync that slowed down sync).\n+ *\n+ *\n+ * @param <T>   The type of the {@link PersistableEnvelope} to be written or read from disk\n+ */\n+@Slf4j\n+public class PersistenceManager<T extends PersistableEnvelope> {\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Static\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public static final Map<String, PersistenceManager<?>> ALL_PERSISTENCE_MANAGERS = new HashMap<>();\n+\n+    // We don't know from which thread we are called so we map back to user thread\n+    public static void flushAllDataToDisk(ResultHandler completeHandler) {\n+        log.info(\"Start flushAllDataToDisk at shutdown\");\n+        AtomicInteger openInstances = new AtomicInteger(ALL_PERSISTENCE_MANAGERS.size());\n+\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+\n+        new HashSet<>(ALL_PERSISTENCE_MANAGERS.values()).forEach(persistenceManager -> {\n+            // For Priority.HIGH data we want to write to disk in any case to be on the safe side if we might have missed\n+            // a requestPersistence call after an important state update. Those are usually rather small data stores.\n+            // Otherwise we only persist if requestPersistence was called since the last persist call.\n+            if (persistenceManager.source.flushAtShutDown || persistenceManager.persistenceRequested) {\n+                // We don't know from which thread we are called so we map back to user thread when calling persistNow\n+                UserThread.execute(() -> {\n+                    // We always get our completeHandler called even if exceptions happen. In case a file write fails\n+                    // we still call our shutdown and count down routine as the completeHandler is triggered in any case.\n+                    persistenceManager.persistNow(() ->\n+                            onWriteCompleted(completeHandler, openInstances, persistenceManager));\n+                });\n+            } else {\n+                onWriteCompleted(completeHandler, openInstances, persistenceManager);\n+            }\n+        });\n+    }\n+\n+    private static void onWriteCompleted(ResultHandler completeHandler,\n+                                         AtomicInteger openInstances,\n+                                         PersistenceManager<?> persistenceManager) {\n+        persistenceManager.shutdown();\n+        openInstances.decrementAndGet();\n+        if (openInstances.get() == 0) {", "originalCommit": "fbaef268ffc1ef669c8e264ef65c8beccdea1bd5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8aff1f8665e4446179451d883cc2bda964ed6f16", "chunk": "diff --git a/common/src/main/java/bisq/common/persistence/PersistenceManager.java b/common/src/main/java/bisq/common/persistence/PersistenceManager.java\ndeleted file mode 100644\nindex b0772c72eb..0000000000\n--- a/common/src/main/java/bisq/common/persistence/PersistenceManager.java\n+++ /dev/null\n\n@@ -1,378 +0,0 @@\n-/*\n- * This file is part of Bisq.\n- *\n- * Bisq is free software: you can redistribute it and/or modify it\n- * under the terms of the GNU Affero General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or (at\n- * your option) any later version.\n- *\n- * Bisq is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n- * License for more details.\n- *\n- * You should have received a copy of the GNU Affero General Public License\n- * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package bisq.common.persistence;\n-\n-import bisq.common.Timer;\n-import bisq.common.UserThread;\n-import bisq.common.app.DevEnv;\n-import bisq.common.config.Config;\n-import bisq.common.file.CorruptedStorageFileHandler;\n-import bisq.common.file.FileUtil;\n-import bisq.common.handlers.ResultHandler;\n-import bisq.common.proto.persistable.PersistableEnvelope;\n-import bisq.common.proto.persistable.PersistenceProtoResolver;\n-import bisq.common.util.Utilities;\n-\n-import com.google.inject.Inject;\n-\n-import javax.inject.Named;\n-\n-import java.nio.file.Path;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import lombok.Getter;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import javax.annotation.Nullable;\n-\n-import static bisq.common.util.Preconditions.checkDir;\n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n-/**\n- * Responsible for reading persisted data and writing it on disk. We read usually only at start-up and keep data in RAM.\n- * We write all data which got a request for persistence at shut down at the very last moment when all other services\n- * are shut down, so allowing changes to the data in the very last moment. For critical data we set {@link Source}\n- * to HIGH which causes a timer to trigger a write to disk after 1 minute. We use that for not very frequently altered\n- * data and data which cannot be recovered from the network.\n- *\n- * We decided to not use threading (as it was in previous versions) as the read operation happens only at start-up and\n- * with the modified model that data is written at shut down we eliminate frequent and expensive disk I/O. Risks of\n- * deadlock or data inconsistency and a more complex model have been a further argument for that model. In fact\n- * previously we wasted a lot of resources as way too many threads have been created without doing actual work as well\n- * the write operations got triggered way too often specially for the very frequent changes at SequenceNumberMap and\n- * the very large DaoState (at dao blockchain sync that slowed down sync).\n- *\n- *\n- * @param <T>   The type of the {@link PersistableEnvelope} to be written or read from disk\n- */\n-@Slf4j\n-public class PersistenceManager<T extends PersistableEnvelope> {\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // Static\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    public static final Map<String, PersistenceManager<?>> ALL_PERSISTENCE_MANAGERS = new HashMap<>();\n-\n-    // We don't know from which thread we are called so we map back to user thread\n-    public static void flushAllDataToDisk(ResultHandler completeHandler) {\n-        log.info(\"Start flushAllDataToDisk at shutdown\");\n-        AtomicInteger openInstances = new AtomicInteger(ALL_PERSISTENCE_MANAGERS.size());\n-\n-        if (openInstances.get() == 0) {\n-            log.info(\"flushAllDataToDisk completed\");\n-            UserThread.execute(completeHandler::handleResult);\n-        }\n-\n-        new HashSet<>(ALL_PERSISTENCE_MANAGERS.values()).forEach(persistenceManager -> {\n-            // For Priority.HIGH data we want to write to disk in any case to be on the safe side if we might have missed\n-            // a requestPersistence call after an important state update. Those are usually rather small data stores.\n-            // Otherwise we only persist if requestPersistence was called since the last persist call.\n-            if (persistenceManager.source.flushAtShutDown || persistenceManager.persistenceRequested) {\n-                // We don't know from which thread we are called so we map back to user thread when calling persistNow\n-                UserThread.execute(() -> {\n-                    // We always get our completeHandler called even if exceptions happen. In case a file write fails\n-                    // we still call our shutdown and count down routine as the completeHandler is triggered in any case.\n-                    persistenceManager.persistNow(() ->\n-                            onWriteCompleted(completeHandler, openInstances, persistenceManager));\n-                });\n-            } else {\n-                onWriteCompleted(completeHandler, openInstances, persistenceManager);\n-            }\n-        });\n-    }\n-\n-    private static void onWriteCompleted(ResultHandler completeHandler,\n-                                         AtomicInteger openInstances,\n-                                         PersistenceManager<?> persistenceManager) {\n-        persistenceManager.shutdown();\n-        openInstances.decrementAndGet();\n-        if (openInstances.get() == 0) {\n-            log.info(\"flushAllDataToDisk completed\");\n-            UserThread.execute(completeHandler::handleResult);\n-        }\n-    }\n-\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // Enum\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    public enum Source {\n-        // For data stores we received from the network and which could be rebuilt. We store only for avoiding too much network traffic.\n-        NETWORK(1, TimeUnit.HOURS.toSeconds(1), false),\n-\n-        // For data stores which are created from private local data. This data could only be rebuilt from backup files.\n-        PRIVATE(10, TimeUnit.SECONDS.toSeconds(30), true),\n-\n-        // For data stores which are created from private local data. Loss of that data would not have any critical consequences.\n-        PRIVATE_LOW_PRIO(4, TimeUnit.HOURS.toSeconds(2), false);\n-\n-\n-        @Getter\n-        private final int numMaxBackupFiles;\n-        @Getter\n-        private final long delayInSec;\n-        @Getter\n-        private final boolean flushAtShutDown;\n-\n-        Source(int numMaxBackupFiles, long delayInSec, boolean flushAtShutDown) {\n-            this.numMaxBackupFiles = numMaxBackupFiles;\n-            this.delayInSec = delayInSec;\n-            this.flushAtShutDown = flushAtShutDown;\n-        }\n-    }\n-\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // Class fields\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    private final File dir;\n-    private final PersistenceProtoResolver persistenceProtoResolver;\n-    private final CorruptedStorageFileHandler corruptedStorageFileHandler;\n-    private File storageFile;\n-    private T persistable;\n-    private String fileName;\n-    private Source source = Source.PRIVATE_LOW_PRIO;\n-    private Path usedTempFilePath;\n-    private volatile boolean persistenceRequested;\n-    @Nullable\n-    private Timer timer;\n-    private ExecutorService writeToDiskExecutor;\n-\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // Constructor\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    @Inject\n-    public PersistenceManager(@Named(Config.STORAGE_DIR) File dir,\n-                              PersistenceProtoResolver persistenceProtoResolver,\n-                              CorruptedStorageFileHandler corruptedStorageFileHandler) {\n-        this.dir = checkDir(dir);\n-        this.persistenceProtoResolver = persistenceProtoResolver;\n-        this.corruptedStorageFileHandler = corruptedStorageFileHandler;\n-    }\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // API\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    public void initialize(T persistable, Source sourcce) {\n-        this.initialize(persistable, persistable.getDefaultStorageFileName(), sourcce);\n-    }\n-\n-    public void initialize(T persistable, String fileName, Source sourcce) {\n-        this.persistable = persistable;\n-        this.fileName = fileName;\n-        this.source = sourcce;\n-        storageFile = new File(dir, fileName);\n-        ALL_PERSISTENCE_MANAGERS.put(fileName, this);\n-    }\n-\n-    public void shutdown() {\n-        ALL_PERSISTENCE_MANAGERS.remove(fileName);\n-\n-        if (timer != null) {\n-            timer.stop();\n-        }\n-\n-        if (writeToDiskExecutor != null) {\n-            writeToDiskExecutor.shutdown();\n-        }\n-    }\n-\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // Reading file\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    @Nullable\n-    public T getPersisted() {\n-        return getPersisted(checkNotNull(fileName));\n-    }\n-\n-    //TODO use threading here instead in the clients\n-    // We get called at startup either by readAllPersisted or readFromResources. Both are wrapped in a thread so we\n-    // are not on the user thread.\n-    @Nullable\n-    public T getPersisted(String fileName) {\n-        File storageFile = new File(dir, fileName);\n-        if (!storageFile.exists()) {\n-            return null;\n-        }\n-\n-        long ts = System.currentTimeMillis();\n-        try (FileInputStream fileInputStream = new FileInputStream(storageFile)) {\n-            protobuf.PersistableEnvelope proto = protobuf.PersistableEnvelope.parseDelimitedFrom(fileInputStream);\n-            //noinspection unchecked\n-            T persistableEnvelope = (T) persistenceProtoResolver.fromProto(proto);\n-            log.info(\"Reading {} completed in {} ms\", fileName, System.currentTimeMillis() - ts);\n-            return persistableEnvelope;\n-        } catch (Throwable t) {\n-            log.error(\"Reading {} failed with {}.\", fileName, t.getMessage());\n-            try {\n-                // We keep a backup which might be used for recovery\n-                FileUtil.removeAndBackupFile(dir, storageFile, fileName, \"backup_of_corrupted_data\");\n-                DevEnv.logErrorAndThrowIfDevMode(t.toString());\n-            } catch (IOException e1) {\n-                e1.printStackTrace();\n-                log.error(e1.getMessage());\n-                // We swallow Exception if backup fails\n-            }\n-            if (corruptedStorageFileHandler != null) {\n-                corruptedStorageFileHandler.addFile(storageFile.getName());\n-            }\n-        }\n-        return null;\n-    }\n-\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // Write file to disk\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    public void requestPersistence() {\n-        persistenceRequested = true;\n-\n-        // We write to disk with a delay to avoid frequent write operations. Depending on the priority those delays\n-        // can be rather long.\n-        if (timer == null) {\n-            timer = UserThread.runPeriodically(() -> {\n-                persistNow(null);\n-                UserThread.execute(() -> timer = null);\n-            }, source.delayInSec, TimeUnit.SECONDS);\n-        }\n-    }\n-\n-    public void persistNow(@Nullable Runnable completeHandler) {\n-        long ts = System.currentTimeMillis();\n-        try {\n-            // The serialisation is done on the user thread to avoid threading issue with potential mutations of the\n-            // persistable object. Keeping it on the user thread we are in a synchronize model.\n-            protobuf.PersistableEnvelope serialized = (protobuf.PersistableEnvelope) persistable.toPersistableMessage();\n-\n-            // For the write to disk task we use a thread. We do not have any issues anymore if the persistable objects\n-            // gets mutated while the thread is running as we have serialized it already and do not operate on the\n-            // reference to the persistable object.\n-            getWriteToDiskExecutor().execute(() -> writeToDisk(serialized, completeHandler));\n-\n-            log.info(\"Serializing {} took {} msec\", fileName, System.currentTimeMillis() - ts);\n-        } catch (Throwable e) {\n-            log.error(\"Error in saveToFile toProtoMessage: {}, {}\", persistable.getClass().getSimpleName(), fileName);\n-            e.printStackTrace();\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public void writeToDisk(protobuf.PersistableEnvelope serialized, @Nullable Runnable completeHandler) {\n-        long ts = System.currentTimeMillis();\n-        File tempFile = null;\n-        FileOutputStream fileOutputStream = null;\n-\n-        try {\n-            // Before we write we backup existing file\n-            FileUtil.rollingBackup(dir, fileName, source.getNumMaxBackupFiles());\n-\n-            if (!dir.exists() && !dir.mkdir())\n-                log.warn(\"make dir failed {}\", fileName);\n-\n-            tempFile = usedTempFilePath != null\n-                    ? FileUtil.createNewFile(usedTempFilePath)\n-                    : File.createTempFile(\"temp\", null, dir);\n-            // Don't use a new temp file path each time, as that causes the delete-on-exit hook to leak memory:\n-            tempFile.deleteOnExit();\n-\n-            fileOutputStream = new FileOutputStream(tempFile);\n-\n-            serialized.writeDelimitedTo(fileOutputStream);\n-\n-            // Attempt to force the bits to hit the disk. In reality the OS or hard disk itself may still decide\n-            // to not write through to physical media for at least a few seconds, but this is the best we can do.\n-            fileOutputStream.flush();\n-            fileOutputStream.getFD().sync();\n-\n-            // Close resources before replacing file with temp file because otherwise it causes problems on windows\n-            // when rename temp file\n-            fileOutputStream.close();\n-\n-            FileUtil.renameFile(tempFile, storageFile);\n-            usedTempFilePath = tempFile.toPath();\n-        } catch (Throwable t) {\n-            // If an error occurred, don't attempt to reuse this path again, in case temp file cleanup fails.\n-            usedTempFilePath = null;\n-            log.error(\"Error at saveToFile, storageFile={}\", fileName, t);\n-        } finally {\n-            if (tempFile != null && tempFile.exists()) {\n-                log.warn(\"Temp file still exists after failed save. We will delete it now. storageFile={}\", fileName);\n-                if (!tempFile.delete()) {\n-                    log.error(\"Cannot delete temp file.\");\n-                }\n-            }\n-\n-            try {\n-                if (fileOutputStream != null) {\n-                    fileOutputStream.close();\n-                }\n-            } catch (IOException e) {\n-                // We swallow that\n-                e.printStackTrace();\n-                log.error(\"Cannot close resources.\" + e.getMessage());\n-            }\n-            log.info(\"Writing the serialized {} completed in {} msec\", fileName, System.currentTimeMillis() - ts);\n-            persistenceRequested = false;\n-            if (completeHandler != null) {\n-                UserThread.execute(completeHandler);\n-            }\n-        }\n-    }\n-\n-    private ExecutorService getWriteToDiskExecutor() {\n-        if (writeToDiskExecutor == null) {\n-            String name = \"Write-\" + fileName + \"_to-disk\";\n-            writeToDiskExecutor = Utilities.getSingleThreadExecutor(name);\n-        }\n-        return writeToDiskExecutor;\n-    }\n-\n-\n-    @Override\n-    public String toString() {\n-        return \"PersistenceManager{\" +\n-                \"\\n     fileName='\" + fileName + '\\'' +\n-                \",\\n     dir=\" + dir +\n-                \",\\n     storageFile=\" + storageFile +\n-                \",\\n     persistable=\" + persistable +\n-                \",\\n     priority=\" + source +\n-                \",\\n     usedTempFilePath=\" + usedTempFilePath +\n-                \",\\n     persistenceRequested=\" + persistenceRequested +\n-                \"\\n}\";\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2NDk2Mg==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499164962", "bodyText": "Misspelled sourcce", "author": "sqrrm", "createdAt": "2020-10-03T17:10:56Z", "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.common.persistence;\n+\n+import bisq.common.Timer;\n+import bisq.common.UserThread;\n+import bisq.common.app.DevEnv;\n+import bisq.common.config.Config;\n+import bisq.common.file.CorruptedStorageFileHandler;\n+import bisq.common.file.FileUtil;\n+import bisq.common.handlers.ResultHandler;\n+import bisq.common.proto.persistable.PersistableEnvelope;\n+import bisq.common.proto.persistable.PersistenceProtoResolver;\n+import bisq.common.util.Utilities;\n+\n+import com.google.inject.Inject;\n+\n+import javax.inject.Named;\n+\n+import java.nio.file.Path;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nullable;\n+\n+import static bisq.common.util.Preconditions.checkDir;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Responsible for reading persisted data and writing it on disk. We read usually only at start-up and keep data in RAM.\n+ * We write all data which got a request for persistence at shut down at the very last moment when all other services\n+ * are shut down, so allowing changes to the data in the very last moment. For critical data we set {@link Source}\n+ * to HIGH which causes a timer to trigger a write to disk after 1 minute. We use that for not very frequently altered\n+ * data and data which cannot be recovered from the network.\n+ *\n+ * We decided to not use threading (as it was in previous versions) as the read operation happens only at start-up and\n+ * with the modified model that data is written at shut down we eliminate frequent and expensive disk I/O. Risks of\n+ * deadlock or data inconsistency and a more complex model have been a further argument for that model. In fact\n+ * previously we wasted a lot of resources as way too many threads have been created without doing actual work as well\n+ * the write operations got triggered way too often specially for the very frequent changes at SequenceNumberMap and\n+ * the very large DaoState (at dao blockchain sync that slowed down sync).\n+ *\n+ *\n+ * @param <T>   The type of the {@link PersistableEnvelope} to be written or read from disk\n+ */\n+@Slf4j\n+public class PersistenceManager<T extends PersistableEnvelope> {\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Static\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public static final Map<String, PersistenceManager<?>> ALL_PERSISTENCE_MANAGERS = new HashMap<>();\n+\n+    // We don't know from which thread we are called so we map back to user thread\n+    public static void flushAllDataToDisk(ResultHandler completeHandler) {\n+        log.info(\"Start flushAllDataToDisk at shutdown\");\n+        AtomicInteger openInstances = new AtomicInteger(ALL_PERSISTENCE_MANAGERS.size());\n+\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+\n+        new HashSet<>(ALL_PERSISTENCE_MANAGERS.values()).forEach(persistenceManager -> {\n+            // For Priority.HIGH data we want to write to disk in any case to be on the safe side if we might have missed\n+            // a requestPersistence call after an important state update. Those are usually rather small data stores.\n+            // Otherwise we only persist if requestPersistence was called since the last persist call.\n+            if (persistenceManager.source.flushAtShutDown || persistenceManager.persistenceRequested) {\n+                // We don't know from which thread we are called so we map back to user thread when calling persistNow\n+                UserThread.execute(() -> {\n+                    // We always get our completeHandler called even if exceptions happen. In case a file write fails\n+                    // we still call our shutdown and count down routine as the completeHandler is triggered in any case.\n+                    persistenceManager.persistNow(() ->\n+                            onWriteCompleted(completeHandler, openInstances, persistenceManager));\n+                });\n+            } else {\n+                onWriteCompleted(completeHandler, openInstances, persistenceManager);\n+            }\n+        });\n+    }\n+\n+    private static void onWriteCompleted(ResultHandler completeHandler,\n+                                         AtomicInteger openInstances,\n+                                         PersistenceManager<?> persistenceManager) {\n+        persistenceManager.shutdown();\n+        openInstances.decrementAndGet();\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Enum\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public enum Source {\n+        // For data stores we received from the network and which could be rebuilt. We store only for avoiding too much network traffic.\n+        NETWORK(1, TimeUnit.HOURS.toSeconds(1), false),\n+\n+        // For data stores which are created from private local data. This data could only be rebuilt from backup files.\n+        PRIVATE(10, TimeUnit.SECONDS.toSeconds(30), true),\n+\n+        // For data stores which are created from private local data. Loss of that data would not have any critical consequences.\n+        PRIVATE_LOW_PRIO(4, TimeUnit.HOURS.toSeconds(2), false);\n+\n+\n+        @Getter\n+        private final int numMaxBackupFiles;\n+        @Getter\n+        private final long delayInSec;\n+        @Getter\n+        private final boolean flushAtShutDown;\n+\n+        Source(int numMaxBackupFiles, long delayInSec, boolean flushAtShutDown) {\n+            this.numMaxBackupFiles = numMaxBackupFiles;\n+            this.delayInSec = delayInSec;\n+            this.flushAtShutDown = flushAtShutDown;\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Class fields\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    private final File dir;\n+    private final PersistenceProtoResolver persistenceProtoResolver;\n+    private final CorruptedStorageFileHandler corruptedStorageFileHandler;\n+    private File storageFile;\n+    private T persistable;\n+    private String fileName;\n+    private Source source = Source.PRIVATE_LOW_PRIO;\n+    private Path usedTempFilePath;\n+    private volatile boolean persistenceRequested;\n+    @Nullable\n+    private Timer timer;\n+    private ExecutorService writeToDiskExecutor;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    @Inject\n+    public PersistenceManager(@Named(Config.STORAGE_DIR) File dir,\n+                              PersistenceProtoResolver persistenceProtoResolver,\n+                              CorruptedStorageFileHandler corruptedStorageFileHandler) {\n+        this.dir = checkDir(dir);\n+        this.persistenceProtoResolver = persistenceProtoResolver;\n+        this.corruptedStorageFileHandler = corruptedStorageFileHandler;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public void initialize(T persistable, Source sourcce) {", "originalCommit": "fbaef268ffc1ef669c8e264ef65c8beccdea1bd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3MTYwNQ==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499271605", "bodyText": "fixed", "author": "chimp1984", "createdAt": "2020-10-04T17:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2NDk2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "8aff1f8665e4446179451d883cc2bda964ed6f16", "chunk": "diff --git a/common/src/main/java/bisq/common/persistence/PersistenceManager.java b/common/src/main/java/bisq/common/persistence/PersistenceManager.java\ndeleted file mode 100644\nindex b0772c72eb..0000000000\n--- a/common/src/main/java/bisq/common/persistence/PersistenceManager.java\n+++ /dev/null\n\n@@ -1,378 +0,0 @@\n-/*\n- * This file is part of Bisq.\n- *\n- * Bisq is free software: you can redistribute it and/or modify it\n- * under the terms of the GNU Affero General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or (at\n- * your option) any later version.\n- *\n- * Bisq is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n- * License for more details.\n- *\n- * You should have received a copy of the GNU Affero General Public License\n- * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package bisq.common.persistence;\n-\n-import bisq.common.Timer;\n-import bisq.common.UserThread;\n-import bisq.common.app.DevEnv;\n-import bisq.common.config.Config;\n-import bisq.common.file.CorruptedStorageFileHandler;\n-import bisq.common.file.FileUtil;\n-import bisq.common.handlers.ResultHandler;\n-import bisq.common.proto.persistable.PersistableEnvelope;\n-import bisq.common.proto.persistable.PersistenceProtoResolver;\n-import bisq.common.util.Utilities;\n-\n-import com.google.inject.Inject;\n-\n-import javax.inject.Named;\n-\n-import java.nio.file.Path;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import lombok.Getter;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import javax.annotation.Nullable;\n-\n-import static bisq.common.util.Preconditions.checkDir;\n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n-/**\n- * Responsible for reading persisted data and writing it on disk. We read usually only at start-up and keep data in RAM.\n- * We write all data which got a request for persistence at shut down at the very last moment when all other services\n- * are shut down, so allowing changes to the data in the very last moment. For critical data we set {@link Source}\n- * to HIGH which causes a timer to trigger a write to disk after 1 minute. We use that for not very frequently altered\n- * data and data which cannot be recovered from the network.\n- *\n- * We decided to not use threading (as it was in previous versions) as the read operation happens only at start-up and\n- * with the modified model that data is written at shut down we eliminate frequent and expensive disk I/O. Risks of\n- * deadlock or data inconsistency and a more complex model have been a further argument for that model. In fact\n- * previously we wasted a lot of resources as way too many threads have been created without doing actual work as well\n- * the write operations got triggered way too often specially for the very frequent changes at SequenceNumberMap and\n- * the very large DaoState (at dao blockchain sync that slowed down sync).\n- *\n- *\n- * @param <T>   The type of the {@link PersistableEnvelope} to be written or read from disk\n- */\n-@Slf4j\n-public class PersistenceManager<T extends PersistableEnvelope> {\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // Static\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    public static final Map<String, PersistenceManager<?>> ALL_PERSISTENCE_MANAGERS = new HashMap<>();\n-\n-    // We don't know from which thread we are called so we map back to user thread\n-    public static void flushAllDataToDisk(ResultHandler completeHandler) {\n-        log.info(\"Start flushAllDataToDisk at shutdown\");\n-        AtomicInteger openInstances = new AtomicInteger(ALL_PERSISTENCE_MANAGERS.size());\n-\n-        if (openInstances.get() == 0) {\n-            log.info(\"flushAllDataToDisk completed\");\n-            UserThread.execute(completeHandler::handleResult);\n-        }\n-\n-        new HashSet<>(ALL_PERSISTENCE_MANAGERS.values()).forEach(persistenceManager -> {\n-            // For Priority.HIGH data we want to write to disk in any case to be on the safe side if we might have missed\n-            // a requestPersistence call after an important state update. Those are usually rather small data stores.\n-            // Otherwise we only persist if requestPersistence was called since the last persist call.\n-            if (persistenceManager.source.flushAtShutDown || persistenceManager.persistenceRequested) {\n-                // We don't know from which thread we are called so we map back to user thread when calling persistNow\n-                UserThread.execute(() -> {\n-                    // We always get our completeHandler called even if exceptions happen. In case a file write fails\n-                    // we still call our shutdown and count down routine as the completeHandler is triggered in any case.\n-                    persistenceManager.persistNow(() ->\n-                            onWriteCompleted(completeHandler, openInstances, persistenceManager));\n-                });\n-            } else {\n-                onWriteCompleted(completeHandler, openInstances, persistenceManager);\n-            }\n-        });\n-    }\n-\n-    private static void onWriteCompleted(ResultHandler completeHandler,\n-                                         AtomicInteger openInstances,\n-                                         PersistenceManager<?> persistenceManager) {\n-        persistenceManager.shutdown();\n-        openInstances.decrementAndGet();\n-        if (openInstances.get() == 0) {\n-            log.info(\"flushAllDataToDisk completed\");\n-            UserThread.execute(completeHandler::handleResult);\n-        }\n-    }\n-\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // Enum\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    public enum Source {\n-        // For data stores we received from the network and which could be rebuilt. We store only for avoiding too much network traffic.\n-        NETWORK(1, TimeUnit.HOURS.toSeconds(1), false),\n-\n-        // For data stores which are created from private local data. This data could only be rebuilt from backup files.\n-        PRIVATE(10, TimeUnit.SECONDS.toSeconds(30), true),\n-\n-        // For data stores which are created from private local data. Loss of that data would not have any critical consequences.\n-        PRIVATE_LOW_PRIO(4, TimeUnit.HOURS.toSeconds(2), false);\n-\n-\n-        @Getter\n-        private final int numMaxBackupFiles;\n-        @Getter\n-        private final long delayInSec;\n-        @Getter\n-        private final boolean flushAtShutDown;\n-\n-        Source(int numMaxBackupFiles, long delayInSec, boolean flushAtShutDown) {\n-            this.numMaxBackupFiles = numMaxBackupFiles;\n-            this.delayInSec = delayInSec;\n-            this.flushAtShutDown = flushAtShutDown;\n-        }\n-    }\n-\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // Class fields\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    private final File dir;\n-    private final PersistenceProtoResolver persistenceProtoResolver;\n-    private final CorruptedStorageFileHandler corruptedStorageFileHandler;\n-    private File storageFile;\n-    private T persistable;\n-    private String fileName;\n-    private Source source = Source.PRIVATE_LOW_PRIO;\n-    private Path usedTempFilePath;\n-    private volatile boolean persistenceRequested;\n-    @Nullable\n-    private Timer timer;\n-    private ExecutorService writeToDiskExecutor;\n-\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // Constructor\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    @Inject\n-    public PersistenceManager(@Named(Config.STORAGE_DIR) File dir,\n-                              PersistenceProtoResolver persistenceProtoResolver,\n-                              CorruptedStorageFileHandler corruptedStorageFileHandler) {\n-        this.dir = checkDir(dir);\n-        this.persistenceProtoResolver = persistenceProtoResolver;\n-        this.corruptedStorageFileHandler = corruptedStorageFileHandler;\n-    }\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // API\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    public void initialize(T persistable, Source sourcce) {\n-        this.initialize(persistable, persistable.getDefaultStorageFileName(), sourcce);\n-    }\n-\n-    public void initialize(T persistable, String fileName, Source sourcce) {\n-        this.persistable = persistable;\n-        this.fileName = fileName;\n-        this.source = sourcce;\n-        storageFile = new File(dir, fileName);\n-        ALL_PERSISTENCE_MANAGERS.put(fileName, this);\n-    }\n-\n-    public void shutdown() {\n-        ALL_PERSISTENCE_MANAGERS.remove(fileName);\n-\n-        if (timer != null) {\n-            timer.stop();\n-        }\n-\n-        if (writeToDiskExecutor != null) {\n-            writeToDiskExecutor.shutdown();\n-        }\n-    }\n-\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // Reading file\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    @Nullable\n-    public T getPersisted() {\n-        return getPersisted(checkNotNull(fileName));\n-    }\n-\n-    //TODO use threading here instead in the clients\n-    // We get called at startup either by readAllPersisted or readFromResources. Both are wrapped in a thread so we\n-    // are not on the user thread.\n-    @Nullable\n-    public T getPersisted(String fileName) {\n-        File storageFile = new File(dir, fileName);\n-        if (!storageFile.exists()) {\n-            return null;\n-        }\n-\n-        long ts = System.currentTimeMillis();\n-        try (FileInputStream fileInputStream = new FileInputStream(storageFile)) {\n-            protobuf.PersistableEnvelope proto = protobuf.PersistableEnvelope.parseDelimitedFrom(fileInputStream);\n-            //noinspection unchecked\n-            T persistableEnvelope = (T) persistenceProtoResolver.fromProto(proto);\n-            log.info(\"Reading {} completed in {} ms\", fileName, System.currentTimeMillis() - ts);\n-            return persistableEnvelope;\n-        } catch (Throwable t) {\n-            log.error(\"Reading {} failed with {}.\", fileName, t.getMessage());\n-            try {\n-                // We keep a backup which might be used for recovery\n-                FileUtil.removeAndBackupFile(dir, storageFile, fileName, \"backup_of_corrupted_data\");\n-                DevEnv.logErrorAndThrowIfDevMode(t.toString());\n-            } catch (IOException e1) {\n-                e1.printStackTrace();\n-                log.error(e1.getMessage());\n-                // We swallow Exception if backup fails\n-            }\n-            if (corruptedStorageFileHandler != null) {\n-                corruptedStorageFileHandler.addFile(storageFile.getName());\n-            }\n-        }\n-        return null;\n-    }\n-\n-\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-    // Write file to disk\n-    ///////////////////////////////////////////////////////////////////////////////////////////\n-\n-    public void requestPersistence() {\n-        persistenceRequested = true;\n-\n-        // We write to disk with a delay to avoid frequent write operations. Depending on the priority those delays\n-        // can be rather long.\n-        if (timer == null) {\n-            timer = UserThread.runPeriodically(() -> {\n-                persistNow(null);\n-                UserThread.execute(() -> timer = null);\n-            }, source.delayInSec, TimeUnit.SECONDS);\n-        }\n-    }\n-\n-    public void persistNow(@Nullable Runnable completeHandler) {\n-        long ts = System.currentTimeMillis();\n-        try {\n-            // The serialisation is done on the user thread to avoid threading issue with potential mutations of the\n-            // persistable object. Keeping it on the user thread we are in a synchronize model.\n-            protobuf.PersistableEnvelope serialized = (protobuf.PersistableEnvelope) persistable.toPersistableMessage();\n-\n-            // For the write to disk task we use a thread. We do not have any issues anymore if the persistable objects\n-            // gets mutated while the thread is running as we have serialized it already and do not operate on the\n-            // reference to the persistable object.\n-            getWriteToDiskExecutor().execute(() -> writeToDisk(serialized, completeHandler));\n-\n-            log.info(\"Serializing {} took {} msec\", fileName, System.currentTimeMillis() - ts);\n-        } catch (Throwable e) {\n-            log.error(\"Error in saveToFile toProtoMessage: {}, {}\", persistable.getClass().getSimpleName(), fileName);\n-            e.printStackTrace();\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public void writeToDisk(protobuf.PersistableEnvelope serialized, @Nullable Runnable completeHandler) {\n-        long ts = System.currentTimeMillis();\n-        File tempFile = null;\n-        FileOutputStream fileOutputStream = null;\n-\n-        try {\n-            // Before we write we backup existing file\n-            FileUtil.rollingBackup(dir, fileName, source.getNumMaxBackupFiles());\n-\n-            if (!dir.exists() && !dir.mkdir())\n-                log.warn(\"make dir failed {}\", fileName);\n-\n-            tempFile = usedTempFilePath != null\n-                    ? FileUtil.createNewFile(usedTempFilePath)\n-                    : File.createTempFile(\"temp\", null, dir);\n-            // Don't use a new temp file path each time, as that causes the delete-on-exit hook to leak memory:\n-            tempFile.deleteOnExit();\n-\n-            fileOutputStream = new FileOutputStream(tempFile);\n-\n-            serialized.writeDelimitedTo(fileOutputStream);\n-\n-            // Attempt to force the bits to hit the disk. In reality the OS or hard disk itself may still decide\n-            // to not write through to physical media for at least a few seconds, but this is the best we can do.\n-            fileOutputStream.flush();\n-            fileOutputStream.getFD().sync();\n-\n-            // Close resources before replacing file with temp file because otherwise it causes problems on windows\n-            // when rename temp file\n-            fileOutputStream.close();\n-\n-            FileUtil.renameFile(tempFile, storageFile);\n-            usedTempFilePath = tempFile.toPath();\n-        } catch (Throwable t) {\n-            // If an error occurred, don't attempt to reuse this path again, in case temp file cleanup fails.\n-            usedTempFilePath = null;\n-            log.error(\"Error at saveToFile, storageFile={}\", fileName, t);\n-        } finally {\n-            if (tempFile != null && tempFile.exists()) {\n-                log.warn(\"Temp file still exists after failed save. We will delete it now. storageFile={}\", fileName);\n-                if (!tempFile.delete()) {\n-                    log.error(\"Cannot delete temp file.\");\n-                }\n-            }\n-\n-            try {\n-                if (fileOutputStream != null) {\n-                    fileOutputStream.close();\n-                }\n-            } catch (IOException e) {\n-                // We swallow that\n-                e.printStackTrace();\n-                log.error(\"Cannot close resources.\" + e.getMessage());\n-            }\n-            log.info(\"Writing the serialized {} completed in {} msec\", fileName, System.currentTimeMillis() - ts);\n-            persistenceRequested = false;\n-            if (completeHandler != null) {\n-                UserThread.execute(completeHandler);\n-            }\n-        }\n-    }\n-\n-    private ExecutorService getWriteToDiskExecutor() {\n-        if (writeToDiskExecutor == null) {\n-            String name = \"Write-\" + fileName + \"_to-disk\";\n-            writeToDiskExecutor = Utilities.getSingleThreadExecutor(name);\n-        }\n-        return writeToDiskExecutor;\n-    }\n-\n-\n-    @Override\n-    public String toString() {\n-        return \"PersistenceManager{\" +\n-                \"\\n     fileName='\" + fileName + '\\'' +\n-                \",\\n     dir=\" + dir +\n-                \",\\n     storageFile=\" + storageFile +\n-                \",\\n     persistable=\" + persistable +\n-                \",\\n     priority=\" + source +\n-                \",\\n     usedTempFilePath=\" + usedTempFilePath +\n-                \",\\n     persistenceRequested=\" + persistenceRequested +\n-                \"\\n}\";\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4MjA3OQ==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499182079", "bodyText": "Why use runPeriodically() instead of runAfter()? The effect would be the same but now it seems the write is intended to happen periodically, but two lines later that we see that it's not.", "author": "sqrrm", "createdAt": "2020-10-03T21:09:06Z", "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.common.persistence;\n+\n+import bisq.common.Timer;\n+import bisq.common.UserThread;\n+import bisq.common.app.DevEnv;\n+import bisq.common.config.Config;\n+import bisq.common.file.CorruptedStorageFileHandler;\n+import bisq.common.file.FileUtil;\n+import bisq.common.handlers.ResultHandler;\n+import bisq.common.proto.persistable.PersistableEnvelope;\n+import bisq.common.proto.persistable.PersistenceProtoResolver;\n+import bisq.common.util.Utilities;\n+\n+import com.google.inject.Inject;\n+\n+import javax.inject.Named;\n+\n+import java.nio.file.Path;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nullable;\n+\n+import static bisq.common.util.Preconditions.checkDir;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Responsible for reading persisted data and writing it on disk. We read usually only at start-up and keep data in RAM.\n+ * We write all data which got a request for persistence at shut down at the very last moment when all other services\n+ * are shut down, so allowing changes to the data in the very last moment. For critical data we set {@link Source}\n+ * to HIGH which causes a timer to trigger a write to disk after 1 minute. We use that for not very frequently altered\n+ * data and data which cannot be recovered from the network.\n+ *\n+ * We decided to not use threading (as it was in previous versions) as the read operation happens only at start-up and\n+ * with the modified model that data is written at shut down we eliminate frequent and expensive disk I/O. Risks of\n+ * deadlock or data inconsistency and a more complex model have been a further argument for that model. In fact\n+ * previously we wasted a lot of resources as way too many threads have been created without doing actual work as well\n+ * the write operations got triggered way too often specially for the very frequent changes at SequenceNumberMap and\n+ * the very large DaoState (at dao blockchain sync that slowed down sync).\n+ *\n+ *\n+ * @param <T>   The type of the {@link PersistableEnvelope} to be written or read from disk\n+ */\n+@Slf4j\n+public class PersistenceManager<T extends PersistableEnvelope> {\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Static\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public static final Map<String, PersistenceManager<?>> ALL_PERSISTENCE_MANAGERS = new HashMap<>();\n+\n+    // We don't know from which thread we are called so we map back to user thread\n+    public static void flushAllDataToDisk(ResultHandler completeHandler) {\n+        log.info(\"Start flushAllDataToDisk at shutdown\");\n+        AtomicInteger openInstances = new AtomicInteger(ALL_PERSISTENCE_MANAGERS.size());\n+\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+\n+        new HashSet<>(ALL_PERSISTENCE_MANAGERS.values()).forEach(persistenceManager -> {\n+            // For Priority.HIGH data we want to write to disk in any case to be on the safe side if we might have missed\n+            // a requestPersistence call after an important state update. Those are usually rather small data stores.\n+            // Otherwise we only persist if requestPersistence was called since the last persist call.\n+            if (persistenceManager.source.flushAtShutDown || persistenceManager.persistenceRequested) {\n+                // We don't know from which thread we are called so we map back to user thread when calling persistNow\n+                UserThread.execute(() -> {\n+                    // We always get our completeHandler called even if exceptions happen. In case a file write fails\n+                    // we still call our shutdown and count down routine as the completeHandler is triggered in any case.\n+                    persistenceManager.persistNow(() ->\n+                            onWriteCompleted(completeHandler, openInstances, persistenceManager));\n+                });\n+            } else {\n+                onWriteCompleted(completeHandler, openInstances, persistenceManager);\n+            }\n+        });\n+    }\n+\n+    private static void onWriteCompleted(ResultHandler completeHandler,\n+                                         AtomicInteger openInstances,\n+                                         PersistenceManager<?> persistenceManager) {\n+        persistenceManager.shutdown();\n+        openInstances.decrementAndGet();\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Enum\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public enum Source {\n+        // For data stores we received from the network and which could be rebuilt. We store only for avoiding too much network traffic.\n+        NETWORK(1, TimeUnit.HOURS.toSeconds(1), false),\n+\n+        // For data stores which are created from private local data. This data could only be rebuilt from backup files.\n+        PRIVATE(10, TimeUnit.SECONDS.toSeconds(30), true),\n+\n+        // For data stores which are created from private local data. Loss of that data would not have any critical consequences.\n+        PRIVATE_LOW_PRIO(4, TimeUnit.HOURS.toSeconds(2), false);\n+\n+\n+        @Getter\n+        private final int numMaxBackupFiles;\n+        @Getter\n+        private final long delayInSec;\n+        @Getter\n+        private final boolean flushAtShutDown;\n+\n+        Source(int numMaxBackupFiles, long delayInSec, boolean flushAtShutDown) {\n+            this.numMaxBackupFiles = numMaxBackupFiles;\n+            this.delayInSec = delayInSec;\n+            this.flushAtShutDown = flushAtShutDown;\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Class fields\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    private final File dir;\n+    private final PersistenceProtoResolver persistenceProtoResolver;\n+    private final CorruptedStorageFileHandler corruptedStorageFileHandler;\n+    private File storageFile;\n+    private T persistable;\n+    private String fileName;\n+    private Source source = Source.PRIVATE_LOW_PRIO;\n+    private Path usedTempFilePath;\n+    private volatile boolean persistenceRequested;\n+    @Nullable\n+    private Timer timer;\n+    private ExecutorService writeToDiskExecutor;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    @Inject\n+    public PersistenceManager(@Named(Config.STORAGE_DIR) File dir,\n+                              PersistenceProtoResolver persistenceProtoResolver,\n+                              CorruptedStorageFileHandler corruptedStorageFileHandler) {\n+        this.dir = checkDir(dir);\n+        this.persistenceProtoResolver = persistenceProtoResolver;\n+        this.corruptedStorageFileHandler = corruptedStorageFileHandler;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public void initialize(T persistable, Source sourcce) {\n+        this.initialize(persistable, persistable.getDefaultStorageFileName(), sourcce);\n+    }\n+\n+    public void initialize(T persistable, String fileName, Source sourcce) {\n+        this.persistable = persistable;\n+        this.fileName = fileName;\n+        this.source = sourcce;\n+        storageFile = new File(dir, fileName);\n+        ALL_PERSISTENCE_MANAGERS.put(fileName, this);\n+    }\n+\n+    public void shutdown() {\n+        ALL_PERSISTENCE_MANAGERS.remove(fileName);\n+\n+        if (timer != null) {\n+            timer.stop();\n+        }\n+\n+        if (writeToDiskExecutor != null) {\n+            writeToDiskExecutor.shutdown();\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Reading file\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    @Nullable\n+    public T getPersisted() {\n+        return getPersisted(checkNotNull(fileName));\n+    }\n+\n+    //TODO use threading here instead in the clients\n+    // We get called at startup either by readAllPersisted or readFromResources. Both are wrapped in a thread so we\n+    // are not on the user thread.\n+    @Nullable\n+    public T getPersisted(String fileName) {\n+        File storageFile = new File(dir, fileName);\n+        if (!storageFile.exists()) {\n+            return null;\n+        }\n+\n+        long ts = System.currentTimeMillis();\n+        try (FileInputStream fileInputStream = new FileInputStream(storageFile)) {\n+            protobuf.PersistableEnvelope proto = protobuf.PersistableEnvelope.parseDelimitedFrom(fileInputStream);\n+            //noinspection unchecked\n+            T persistableEnvelope = (T) persistenceProtoResolver.fromProto(proto);\n+            log.info(\"Reading {} completed in {} ms\", fileName, System.currentTimeMillis() - ts);\n+            return persistableEnvelope;\n+        } catch (Throwable t) {\n+            log.error(\"Reading {} failed with {}.\", fileName, t.getMessage());\n+            try {\n+                // We keep a backup which might be used for recovery\n+                FileUtil.removeAndBackupFile(dir, storageFile, fileName, \"backup_of_corrupted_data\");\n+                DevEnv.logErrorAndThrowIfDevMode(t.toString());\n+            } catch (IOException e1) {\n+                e1.printStackTrace();\n+                log.error(e1.getMessage());\n+                // We swallow Exception if backup fails\n+            }\n+            if (corruptedStorageFileHandler != null) {\n+                corruptedStorageFileHandler.addFile(storageFile.getName());\n+            }\n+        }\n+        return null;\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Write file to disk\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public void requestPersistence() {\n+        persistenceRequested = true;\n+\n+        // We write to disk with a delay to avoid frequent write operations. Depending on the priority those delays\n+        // can be rather long.\n+        if (timer == null) {\n+            timer = UserThread.runPeriodically(() -> {", "originalCommit": "6693a03f96e45c3ecd98bb879d91c7274c971784", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3MTczOA==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499271738", "bodyText": "Yes was from earlier version, should be runAfter.", "author": "chimp1984", "createdAt": "2020-10-04T17:54:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4MjA3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a612405d9d6af726be014df0fd48ca24c0f8944d", "chunk": "diff --git a/common/src/main/java/bisq/common/persistence/PersistenceManager.java b/common/src/main/java/bisq/common/persistence/PersistenceManager.java\nindex b0772c72eb..b3076a2c90 100644\n--- a/common/src/main/java/bisq/common/persistence/PersistenceManager.java\n+++ b/common/src/main/java/bisq/common/persistence/PersistenceManager.java\n\n@@ -112,8 +112,7 @@ public class PersistenceManager<T extends PersistableEnvelope> {\n                                          AtomicInteger openInstances,\n                                          PersistenceManager<?> persistenceManager) {\n         persistenceManager.shutdown();\n-        openInstances.decrementAndGet();\n-        if (openInstances.get() == 0) {\n+        if (openInstances.decrementAndGet() == 0) {\n             log.info(\"flushAllDataToDisk completed\");\n             UserThread.execute(completeHandler::handleResult);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODU1Mw==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499258553", "bodyText": "This does not look safe. I think list should be an ObservableList since it's required by this interface. It's first initiated to an ArrayList (line 39) but I assume all implementations of PersistableList passes an ObservableList as the constructor argument.", "author": "sqrrm", "createdAt": "2020-10-04T15:29:28Z", "path": "common/src/main/java/bisq/common/proto/persistable/PersistableList.java", "diffHunk": "@@ -17,43 +17,85 @@\n \n package bisq.common.proto.persistable;\n \n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.function.Consumer;\n import java.util.stream.Stream;\n \n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n-import lombok.experimental.Delegate;\n \n @EqualsAndHashCode\n-public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope, Iterable<T> {\n-    @Delegate(excludes = ExcludesDelegateMethods.class)\n+public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope {\n+\n     @Getter\n-    @Setter\n-    private List<T> list;\n+    public final List<T> list = createList();\n+\n+    protected List<T> createList() {\n+        return new ArrayList<>();\n+    }\n \n     public PersistableList() {\n-        list = new ArrayList<>();\n     }\n \n     public PersistableList(List<T> list) {\n-        this.list = list;\n+        setAll(list);\n+    }\n+\n+    public void addListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).addListener(listener);", "originalCommit": "6693a03f96e45c3ecd98bb879d91c7274c971784", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3MTg3OA==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499271878", "bodyText": "Yes, was moving the listeners later to the base class. But I think best here is to enforce observeable list as it is used anyway by all subclasses.", "author": "chimp1984", "createdAt": "2020-10-04T17:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3MjE4OA==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499272188", "bodyText": "After looking at subclasses its not true. many dont use ObservableList. I will move back the ObservableList methods to the classes which actually use them and remove all ObservableList casts from the base class", "author": "chimp1984", "createdAt": "2020-10-04T17:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODU1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f9f33aa16deb5c4dada2883d24dfd5d7867a4e21", "chunk": "diff --git a/common/src/main/java/bisq/common/proto/persistable/PersistableList.java b/common/src/main/java/bisq/common/proto/persistable/PersistableList.java\nindex 26893132ce..288d52314d 100644\n--- a/common/src/main/java/bisq/common/proto/persistable/PersistableList.java\n+++ b/common/src/main/java/bisq/common/proto/persistable/PersistableList.java\n\n@@ -17,19 +17,14 @@\n \n package bisq.common.proto.persistable;\n \n-import javafx.collections.ListChangeListener;\n-import javafx.collections.ObservableList;\n-\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.function.Consumer;\n import java.util.stream.Stream;\n \n-import lombok.EqualsAndHashCode;\n import lombok.Getter;\n \n-@EqualsAndHashCode\n public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope {\n \n     @Getter\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODg4MA==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499258880", "bodyText": "Naming the generic tradable is confusing, item is more neutral", "author": "sqrrm", "createdAt": "2020-10-04T15:32:40Z", "path": "common/src/main/java/bisq/common/proto/persistable/PersistableList.java", "diffHunk": "@@ -17,43 +17,85 @@\n \n package bisq.common.proto.persistable;\n \n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.function.Consumer;\n import java.util.stream.Stream;\n \n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n-import lombok.experimental.Delegate;\n \n @EqualsAndHashCode\n-public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope, Iterable<T> {\n-    @Delegate(excludes = ExcludesDelegateMethods.class)\n+public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope {\n+\n     @Getter\n-    @Setter\n-    private List<T> list;\n+    public final List<T> list = createList();\n+\n+    protected List<T> createList() {\n+        return new ArrayList<>();\n+    }\n \n     public PersistableList() {\n-        list = new ArrayList<>();\n     }\n \n     public PersistableList(List<T> list) {\n-        this.list = list;\n+        setAll(list);\n+    }\n+\n+    public void addListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).addListener(listener);\n+    }\n+\n+    public void removeListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).removeListener(listener);\n+    }\n+\n+    public ObservableList<T> getObservableList() {\n+        return (ObservableList<T>) getList();\n+    }\n+\n+    public void setAll(Collection<T> collection) {\n+        this.list.clear();\n+        this.list.addAll(collection);\n+    }\n+\n+    public boolean add(T item) {\n+        if (!list.contains(item)) {\n+            list.add(item);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean remove(T tradable) {", "originalCommit": "6693a03f96e45c3ecd98bb879d91c7274c971784", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3Mjc5NA==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499272794", "bodyText": "Yes, will fix", "author": "chimp1984", "createdAt": "2020-10-04T18:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODg4MA=="}], "type": "inlineReview", "revised_code": {"commit": "f9f33aa16deb5c4dada2883d24dfd5d7867a4e21", "chunk": "diff --git a/common/src/main/java/bisq/common/proto/persistable/PersistableList.java b/common/src/main/java/bisq/common/proto/persistable/PersistableList.java\nindex 26893132ce..288d52314d 100644\n--- a/common/src/main/java/bisq/common/proto/persistable/PersistableList.java\n+++ b/common/src/main/java/bisq/common/proto/persistable/PersistableList.java\n\n@@ -17,19 +17,14 @@\n \n package bisq.common.proto.persistable;\n \n-import javafx.collections.ListChangeListener;\n-import javafx.collections.ObservableList;\n-\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.function.Consumer;\n import java.util.stream.Stream;\n \n-import lombok.EqualsAndHashCode;\n import lombok.Getter;\n \n-@EqualsAndHashCode\n public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope {\n \n     @Getter\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODkxNw==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499258917", "bodyText": "Rather use a uniform naming for the generic, like item", "author": "sqrrm", "createdAt": "2020-10-04T15:33:05Z", "path": "common/src/main/java/bisq/common/proto/persistable/PersistableList.java", "diffHunk": "@@ -17,43 +17,85 @@\n \n package bisq.common.proto.persistable;\n \n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.function.Consumer;\n import java.util.stream.Stream;\n \n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n-import lombok.experimental.Delegate;\n \n @EqualsAndHashCode\n-public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope, Iterable<T> {\n-    @Delegate(excludes = ExcludesDelegateMethods.class)\n+public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope {\n+\n     @Getter\n-    @Setter\n-    private List<T> list;\n+    public final List<T> list = createList();\n+\n+    protected List<T> createList() {\n+        return new ArrayList<>();\n+    }\n \n     public PersistableList() {\n-        list = new ArrayList<>();\n     }\n \n     public PersistableList(List<T> list) {\n-        this.list = list;\n+        setAll(list);\n+    }\n+\n+    public void addListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).addListener(listener);\n+    }\n+\n+    public void removeListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).removeListener(listener);\n+    }\n+\n+    public ObservableList<T> getObservableList() {\n+        return (ObservableList<T>) getList();\n+    }\n+\n+    public void setAll(Collection<T> collection) {\n+        this.list.clear();\n+        this.list.addAll(collection);\n+    }\n+\n+    public boolean add(T item) {\n+        if (!list.contains(item)) {\n+            list.add(item);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean remove(T tradable) {\n+        return list.remove(tradable);\n     }\n \n-    // this.stream() does not compile for unknown reasons, so add that manual delegate method\n     public Stream<T> stream() {\n         return list.stream();\n     }\n \n-    private interface ExcludesDelegateMethods<T> {\n-        Stream<T> stream();\n+    public int size() {\n+        return list.size();\n+    }\n+\n+    public boolean contains(T thing) {", "originalCommit": "6693a03f96e45c3ecd98bb879d91c7274c971784", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3Mjg2Mg==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499272862", "bodyText": "Agree.", "author": "chimp1984", "createdAt": "2020-10-04T18:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODkxNw=="}], "type": "inlineReview", "revised_code": {"commit": "f9f33aa16deb5c4dada2883d24dfd5d7867a4e21", "chunk": "diff --git a/common/src/main/java/bisq/common/proto/persistable/PersistableList.java b/common/src/main/java/bisq/common/proto/persistable/PersistableList.java\nindex 26893132ce..288d52314d 100644\n--- a/common/src/main/java/bisq/common/proto/persistable/PersistableList.java\n+++ b/common/src/main/java/bisq/common/proto/persistable/PersistableList.java\n\n@@ -17,19 +17,14 @@\n \n package bisq.common.proto.persistable;\n \n-import javafx.collections.ListChangeListener;\n-import javafx.collections.ObservableList;\n-\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.function.Consumer;\n import java.util.stream.Stream;\n \n-import lombok.EqualsAndHashCode;\n import lombok.Getter;\n \n-@EqualsAndHashCode\n public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope {\n \n     @Getter\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1OTQ5Mg==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499259492", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Subclassed might configure classes with the injector here\n          \n          \n            \n                    // Subclasses might configure classes with the injector here", "author": "sqrrm", "createdAt": "2020-10-04T15:38:28Z", "path": "core/src/main/java/bisq/core/app/BisqExecutable.java", "diffHunk": "@@ -148,21 +153,30 @@ protected Injector getInjector() {\n     }\n \n     protected void applyInjector() {\n-        setupPersistedDataHosts(injector);\n+        // Subclassed might configure classes with the injector here", "originalCommit": "6693a03f96e45c3ecd98bb879d91c7274c971784", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3MjkxMA==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499272910", "bodyText": "Will fix in a new commit with other changes...", "author": "chimp1984", "createdAt": "2020-10-04T18:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1OTQ5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f7c2464fbcbfaa0d5f760a2a56f01f1f925e186a", "chunk": "diff --git a/core/src/main/java/bisq/core/app/BisqExecutable.java b/core/src/main/java/bisq/core/app/BisqExecutable.java\nindex 7ebfcacf05..8e403b97dc 100644\n--- a/core/src/main/java/bisq/core/app/BisqExecutable.java\n+++ b/core/src/main/java/bisq/core/app/BisqExecutable.java\n\n@@ -153,7 +153,7 @@ public abstract class BisqExecutable implements GracefulShutDownHandler, BisqSet\n     }\n \n     protected void applyInjector() {\n-        // Subclassed might configure classes with the injector here\n+        // Subclasses might configure classes with the injector here\n     }\n \n     protected void readAllPersisted(Runnable completeHandler) {\n"}}, {"oid": "a612405d9d6af726be014df0fd48ca24c0f8944d", "url": "https://github.com/bisq-network/bisq/commit/a612405d9d6af726be014df0fd48ca24c0f8944d", "message": "Update common/src/main/java/bisq/common/persistence/PersistenceManager.java\n\nCo-authored-by: sqrrm <sqrrm@users.noreply.github.com>", "committedDate": "2020-10-04T17:49:02Z", "type": "commit"}, {"oid": "3b31dc9ff3484204b4784f354ab1ca7cdba6a9b9", "url": "https://github.com/bisq-network/bisq/commit/3b31dc9ff3484204b4784f354ab1ca7cdba6a9b9", "message": "Fix typo", "committedDate": "2020-10-04T17:53:20Z", "type": "commit"}, {"oid": "0cc0cfc9a50c76ef06b15825cec8e54af20844ef", "url": "https://github.com/bisq-network/bisq/commit/0cc0cfc9a50c76ef06b15825cec8e54af20844ef", "message": "Use runAfter instead of runPeriodically", "committedDate": "2020-10-04T17:54:27Z", "type": "commit"}, {"oid": "f7c2464fbcbfaa0d5f760a2a56f01f1f925e186a", "url": "https://github.com/bisq-network/bisq/commit/f7c2464fbcbfaa0d5f760a2a56f01f1f925e186a", "message": "Fix typo", "committedDate": "2020-10-04T18:16:49Z", "type": "commit"}, {"oid": "f9f33aa16deb5c4dada2883d24dfd5d7867a4e21", "url": "https://github.com/bisq-network/bisq/commit/f9f33aa16deb5c4dada2883d24dfd5d7867a4e21", "message": "Add PersistableListAsObservable\nRemove ObservableList methods from PersistableList\nLet DisputeList and TradableList extend PersistableListAsObservable\nFix param names", "committedDate": "2020-10-04T18:18:25Z", "type": "commit"}, {"oid": "d18b24332256ab8cb6be11fd37f35160a4851f33", "url": "https://github.com/bisq-network/bisq/commit/d18b24332256ab8cb6be11fd37f35160a4851f33", "message": "Do not use persistNow for snapshots but requestPersistence\n\nThis avoids frequent write at dao sync and better performance.", "committedDate": "2020-10-04T18:34:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTA5Mg==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499285092", "bodyText": "The typo continues...", "author": "sqrrm", "createdAt": "2020-10-04T20:22:21Z", "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "diffHunk": "@@ -184,8 +184,8 @@ public PersistenceManager(@Named(Config.STORAGE_DIR) File dir,\n     // API\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n-    public void initialize(T persistable, Source sourcce) {\n-        this.initialize(persistable, persistable.getDefaultStorageFileName(), sourcce);\n+    public void initialize(T persistable, Source source) {\n+        this.initialize(persistable, persistable.getDefaultStorageFileName(), source);\n     }\n \n     public void initialize(T persistable, String fileName, Source sourcce) {", "originalCommit": "3b31dc9ff3484204b4784f354ab1ca7cdba6a9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4ODgxMQ==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499288811", "bodyText": "ups...", "author": "chimp1984", "createdAt": "2020-10-04T21:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTA5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c797317c0dad7202b31756fe09c09c9c26ce9122", "chunk": "diff --git a/common/src/main/java/bisq/common/persistence/PersistenceManager.java b/common/src/main/java/bisq/common/persistence/PersistenceManager.java\nindex f670af193b..ec8d1ee005 100644\n--- a/common/src/main/java/bisq/common/persistence/PersistenceManager.java\n+++ b/common/src/main/java/bisq/common/persistence/PersistenceManager.java\n\n@@ -188,10 +188,10 @@ public class PersistenceManager<T extends PersistableEnvelope> {\n         this.initialize(persistable, persistable.getDefaultStorageFileName(), source);\n     }\n \n-    public void initialize(T persistable, String fileName, Source sourcce) {\n+    public void initialize(T persistable, String fileName, Source source) {\n         this.persistable = persistable;\n         this.fileName = fileName;\n-        this.source = sourcce;\n+        this.source = source;\n         storageFile = new File(dir, fileName);\n         ALL_PERSISTENCE_MANAGERS.put(fileName, this);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTI4MQ==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499285281", "bodyText": "Should take ObservableList<T>", "author": "sqrrm", "createdAt": "2020-10-04T20:24:43Z", "path": "common/src/main/java/bisq/common/proto/persistable/PersistableListAsObservable.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.common.proto.persistable;\n+\n+import javafx.collections.FXCollections;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n+import java.util.List;\n+\n+public abstract class PersistableListAsObservable<T extends PersistablePayload> extends PersistableList<T> {\n+\n+    public PersistableListAsObservable() {\n+    }\n+\n+    protected PersistableListAsObservable(List<T> list) {", "originalCommit": "f9f33aa16deb5c4dada2883d24dfd5d7867a4e21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4ODk2Ng==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499288966", "bodyText": "No, that is called from protobug methods and there we map to a list, will be copied over to the observable in the base class. We could use a collection here as well to make it more clear that its not setting the list.", "author": "chimp1984", "createdAt": "2020-10-04T21:07:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4OTMxMQ==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499289311", "bodyText": "Right you are, since the list is created by createList(). No need to change, this is correct.", "author": "sqrrm", "createdAt": "2020-10-04T21:11:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4OTQ4Ng==", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499289486", "bodyText": "See last commit...", "author": "chimp1984", "createdAt": "2020-10-04T21:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTI4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e179ee4e32a6621df0d085a0bf1d41cd49664728", "chunk": "diff --git a/common/src/main/java/bisq/common/proto/persistable/PersistableListAsObservable.java b/common/src/main/java/bisq/common/proto/persistable/PersistableListAsObservable.java\nindex 87c1e3fc19..782e44b9e8 100644\n--- a/common/src/main/java/bisq/common/proto/persistable/PersistableListAsObservable.java\n+++ b/common/src/main/java/bisq/common/proto/persistable/PersistableListAsObservable.java\n\n@@ -21,6 +21,7 @@ import javafx.collections.FXCollections;\n import javafx.collections.ListChangeListener;\n import javafx.collections.ObservableList;\n \n+import java.util.Collection;\n import java.util.List;\n \n public abstract class PersistableListAsObservable<T extends PersistablePayload> extends PersistableList<T> {\n"}}, {"oid": "c797317c0dad7202b31756fe09c09c9c26ce9122", "url": "https://github.com/bisq-network/bisq/commit/c797317c0dad7202b31756fe09c09c9c26ce9122", "message": "Fix typo", "committedDate": "2020-10-04T21:05:43Z", "type": "commit"}, {"oid": "e179ee4e32a6621df0d085a0bf1d41cd49664728", "url": "https://github.com/bisq-network/bisq/commit/e179ee4e32a6621df0d085a0bf1d41cd49664728", "message": "Use Collection for constructor which is called from the fromProto methods.\nWe do not set the collection as list but we fill the list created via the createList method.", "committedDate": "2020-10-04T21:13:45Z", "type": "commit"}]}