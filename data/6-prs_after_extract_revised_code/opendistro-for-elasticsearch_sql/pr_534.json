{"pr_number": 534, "pr_title": "Support LIKE operator", "pr_createdAt": "2020-06-26T19:44:58Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/sql/pull/534", "timeline": [{"oid": "036c5962229d874ca8d6628b35b0242fbf8ab177", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/036c5962229d874ca8d6628b35b0242fbf8ab177", "message": "Added like operator", "committedDate": "2020-06-26T19:35:17Z", "type": "commit"}, {"oid": "c70847b187adee79cb4865687f54aa3e70b490f7", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/c70847b187adee79cb4865687f54aa3e70b490f7", "message": "Added integration test case", "committedDate": "2020-06-26T20:02:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwMjI2NA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/534#discussion_r446402264", "bodyText": "I checked a few methods in JDK, such as Pattern.matches. I think it's more intuitive to put pattern as first argument for this util method as well as like operator argument?", "author": "dai-chen", "createdAt": "2020-06-26T20:46:47Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java", "diffHunk": "@@ -171,4 +171,69 @@ public String toString() {\n    */\n   public static final BiPredicate<ExprValue, ExprValue> COMPARE_WITH_NULL_OR_MISSING =\n       (left, right) -> left.isMissing() || right.isMissing() || left.isNull() || right.isNull();\n+\n+  /**\n+   * Wildcard pattern matcher util.\n+   * Percent (%) character for wildcard,\n+   * Underscore (_) character for a single character match.\n+   * @param pattern string pattern to match.\n+   * @return if text matches pattern returns true; else return false.\n+   */\n+  public static boolean matches(String text, String pattern) {\n+    return Pattern.compile(patternToRegex(pattern)).matcher(text).matches();", "originalCommit": "c70847b187adee79cb4865687f54aa3e70b490f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwNTI3NA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/534#discussion_r446405274", "bodyText": "Good point! Will change the argument order in the util method to follow the JDK custom. As for the like operator, I think it would be better to keep consistent with the PPL specification, which is text like pattern.", "author": "chloe-zh", "createdAt": "2020-06-26T20:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwMjI2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwNTg5NA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/534#discussion_r446405894", "bodyText": "I see. I wan't aware of that. Thanks!", "author": "dai-chen", "createdAt": "2020-06-26T20:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwMjI2NA=="}], "type": "inlineReview", "revised_code": {"commit": "33207138007e0e78d0d9c7fae04fac5979334ebe", "chunk": "diff --git a/core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java b/core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java\nindex 491b5a39..8af736b8 100644\n--- a/core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java\n+++ b/core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java\n\n@@ -179,7 +179,7 @@ public class OperatorUtils {\n    * @param pattern string pattern to match.\n    * @return if text matches pattern returns true; else return false.\n    */\n-  public static boolean matches(String text, String pattern) {\n+  public static boolean matches(String pattern, String text) {\n     return Pattern.compile(patternToRegex(pattern)).matcher(text).matches();\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwNDgyOQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/534#discussion_r446404829", "bodyText": "Just did a quick look and found this method is very similar to others, ex. compareValue, equalPredicate and binaryPredicate. The equalPredicate method signature looks most generic. I'm curious is there any chance to only keep or reuse a most generic function generator method.", "author": "dai-chen", "createdAt": "2020-06-26T20:53:11Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/predicate/BinaryPredicateOperator.java", "diffHunk": "@@ -475,4 +513,34 @@ public String toString() {\n       }\n     };\n   }\n+\n+  private static <T, R> FunctionBuilder likePattern(FunctionName functionName,\n+                                                    BiFunction<T, T, R> function,\n+                                                    Function<ExprValue, T> observer,\n+                                                    ExprType returnType) {", "originalCommit": "c70847b187adee79cb4865687f54aa3e70b490f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwOTY5Mg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/534#discussion_r446409692", "bodyText": "Yes that's also I'm considering, I will take a look into it", "author": "chloe-zh", "createdAt": "2020-06-26T21:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwNDgyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE4ODgyNw==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/534#discussion_r447188827", "bodyText": "Used generic function bundles generating method binaryOperator in OperatorUtils, but some for special cases are remained and added java doc for them.", "author": "chloe-zh", "createdAt": "2020-06-29T19:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwNDgyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "37414675b781982e0f13e6a01ba196dcb719aa69", "chunk": "diff --git a/core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/predicate/BinaryPredicateOperator.java b/core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/predicate/BinaryPredicateOperator.java\nindex 7a816ae7..36f5c33a 100644\n--- a/core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/predicate/BinaryPredicateOperator.java\n+++ b/core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/predicate/BinaryPredicateOperator.java\n\n@@ -469,78 +490,4 @@ public class BinaryPredicateOperator {\n       }\n     };\n   }\n-\n-  private static Map<FunctionSignature, FunctionBuilder> likePredicate(\n-      FunctionName functionName,\n-      BiFunction<String, String, Boolean> stringFunc) {\n-    ImmutableMap.Builder<FunctionSignature, FunctionBuilder> builder = new ImmutableMap.Builder<>();\n-    return builder\n-        .put(new FunctionSignature(functionName, Arrays.asList(ExprType.STRING, ExprType.STRING)),\n-            likePattern(functionName, stringFunc, ExprValueUtils::getStringValue,\n-                ExprType.BOOLEAN))\n-        .build();\n-  }\n-\n-  /**\n-   * Building method for operators including.\n-   * less than (<) operator\n-   * less than or equal to (<=) operator\n-   * greater than (>) operator\n-   * greater than or equal to (>=) operator\n-   */\n-  private static <T, R> FunctionBuilder compareValue(FunctionName functionName,\n-                                                     BiFunction<T, T, R> function,\n-                                                     Function<ExprValue, T> observer,\n-                                                     ExprType returnType) {\n-    return arguments -> new FunctionExpression(functionName, arguments) {\n-      @Override\n-      public ExprValue valueOf(Environment<Expression, ExprValue> env) {\n-        ExprValue arg1 = arguments.get(0).valueOf(env);\n-        ExprValue arg2 = arguments.get(1).valueOf(env);\n-        return ExprValueUtils.fromObjectValue(\n-            function.apply(observer.apply(arg1), observer.apply(arg2)));\n-      }\n-\n-      @Override\n-      public ExprType type(Environment<Expression, ExprType> env) {\n-        return returnType;\n-      }\n-\n-      @Override\n-      public String toString() {\n-        return String.format(\"%s %s %s\", arguments.get(0).toString(), functionName, arguments\n-            .get(1).toString());\n-      }\n-    };\n-  }\n-\n-  private static <T, R> FunctionBuilder likePattern(FunctionName functionName,\n-                                                    BiFunction<T, T, R> function,\n-                                                    Function<ExprValue, T> observer,\n-                                                    ExprType returnType) {\n-    return arguments -> new FunctionExpression(functionName, arguments) {\n-      @Override\n-      public ExprValue valueOf(Environment<Expression, ExprValue> env) {\n-        ExprValue arg1 = arguments.get(0).valueOf(env);\n-        ExprValue arg2 = arguments.get(1).valueOf(env);\n-        if (likeTable.contains(arg1, arg2)) {\n-          return likeTable.get(arg1, arg2);\n-        } else {\n-          return ExprValueUtils.fromObjectValue(\n-              function.apply(observer.apply(arg1), observer.apply(arg2)));\n-        }\n-      }\n-\n-      @Override\n-      public ExprType type(Environment<Expression, ExprType> typeEnv) {\n-        return returnType;\n-      }\n-\n-      @Override\n-      public String toString() {\n-        return String.format(\"%s %s %s\", arguments.get(0).toString(), functionName, arguments\n-            .get(1).toString());\n-      }\n-    };\n-  }\n }\n"}}, {"oid": "33207138007e0e78d0d9c7fae04fac5979334ebe", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/33207138007e0e78d0d9c7fae04fac5979334ebe", "message": "Change the matches method argument order", "committedDate": "2020-06-26T21:04:33Z", "type": "commit"}, {"oid": "37414675b781982e0f13e6a01ba196dcb719aa69", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/37414675b781982e0f13e6a01ba196dcb719aa69", "message": "generified building methods for function bundles and function builders", "committedDate": "2020-06-29T18:58:41Z", "type": "commit"}, {"oid": "a82f9dc11477ae416e786b83fb5bec1950b4581c", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/a82f9dc11477ae416e786b83fb5bec1950b4581c", "message": "Added tests", "committedDate": "2020-06-29T18:58:58Z", "type": "commit"}, {"oid": "314b0e06cf0acb8f5b06c85504b2cd85f507f477", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/314b0e06cf0acb8f5b06c85504b2cd85f507f477", "message": "Merge remote-tracking branch 'upstream/develop' into operator-like\n\n# Conflicts:\n#\tcore/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/DSL.java", "committedDate": "2020-06-29T19:05:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0MDM3Nw==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/534#discussion_r447840377", "bodyText": "could you seperate it from OperatorUtils in case is more focus on SQL regex to Java regex.\nby define the ESCAPE is defined in SQL language, how do we support it?\nis it possible to seperate the translation rule from translation logic.\nfor example,\nTranslationRule.Buidler.put(\"//%\", %\").put(\"%\", \".*\").build()\nThen, apply rule on the input REGEX.", "author": "penghuo", "createdAt": "2020-06-30T17:01:17Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java", "diffHunk": "@@ -171,4 +171,69 @@ public String toString() {\n    */\n   public static final BiPredicate<ExprValue, ExprValue> COMPARE_WITH_NULL_OR_MISSING =\n       (left, right) -> left.isMissing() || right.isMissing() || left.isNull() || right.isNull();\n+\n+  /**\n+   * Wildcard pattern matcher util.\n+   * Percent (%) character for wildcard,\n+   * Underscore (_) character for a single character match.\n+   * @param pattern string pattern to match.\n+   * @return if text matches pattern returns true; else return false.\n+   */\n+  public static boolean matches(String pattern, String text) {\n+    return Pattern.compile(patternToRegex(pattern)).matcher(text).matches();\n+  }\n+\n+  private static final char DEFAULT_ESCAPE = '\\\\';\n+\n+  private static String patternToRegex(String patternString) {", "originalCommit": "314b0e06cf0acb8f5b06c85504b2cd85f507f477", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "075a260b5bda837cadfed837bc0d442fb64a84c8", "chunk": "diff --git a/core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java b/core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java\nindex 8af736b8..fa231c75 100644\n--- a/core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java\n+++ b/core/src/main/java/com/amazon/opendistroforelasticsearch/sql/expression/operator/OperatorUtils.java\n\n@@ -171,69 +170,4 @@ public class OperatorUtils {\n    */\n   public static final BiPredicate<ExprValue, ExprValue> COMPARE_WITH_NULL_OR_MISSING =\n       (left, right) -> left.isMissing() || right.isMissing() || left.isNull() || right.isNull();\n-\n-  /**\n-   * Wildcard pattern matcher util.\n-   * Percent (%) character for wildcard,\n-   * Underscore (_) character for a single character match.\n-   * @param pattern string pattern to match.\n-   * @return if text matches pattern returns true; else return false.\n-   */\n-  public static boolean matches(String pattern, String text) {\n-    return Pattern.compile(patternToRegex(pattern)).matcher(text).matches();\n-  }\n-\n-  private static final char DEFAULT_ESCAPE = '\\\\';\n-\n-  private static String patternToRegex(String patternString) {\n-    StringBuilder regex = new StringBuilder(patternString.length() * 2);\n-    regex.append('^');\n-    boolean escaped = false;\n-    for (char currentChar : patternString.toCharArray()) {\n-      if (!escaped && currentChar == DEFAULT_ESCAPE) {\n-        escaped = true;\n-      } else {\n-        switch (currentChar) {\n-          case '%':\n-            if (escaped) {\n-              regex.append(\"%\");\n-            } else {\n-              regex.append(\".*\");\n-            }\n-            escaped = false;\n-            break;\n-          case '_':\n-            if (escaped) {\n-              regex.append(\"_\");\n-            } else {\n-              regex.append('.');\n-            }\n-            escaped = false;\n-            break;\n-          default:\n-            switch (currentChar) {\n-              case '\\\\':\n-              case '^':\n-              case '$':\n-              case '.':\n-              case '*':\n-              case '[':\n-              case ']':\n-              case '(':\n-              case ')':\n-              case '|':\n-              case '+':\n-                regex.append('\\\\');\n-                break;\n-              default:\n-            }\n-\n-            regex.append(currentChar);\n-            escaped = false;\n-        }\n-      }\n-    }\n-    regex.append('$');\n-    return regex.toString();\n-  }\n }\n"}}, {"oid": "075a260b5bda837cadfed837bc0d442fb64a84c8", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/075a260b5bda837cadfed837bc0d442fb64a84c8", "message": "Separate matches method from operator utils", "committedDate": "2020-07-08T15:23:53Z", "type": "commit"}, {"oid": "6c6d18d29d0c5ec3aacc967bf5e5c2cb1ec9597a", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/6c6d18d29d0c5ec3aacc967bf5e5c2cb1ec9597a", "message": "Merge remote-tracking branch 'upstream/develop' into operator-like", "committedDate": "2020-07-08T15:33:55Z", "type": "commit"}]}