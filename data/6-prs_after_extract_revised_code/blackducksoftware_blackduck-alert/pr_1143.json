{"pr_number": 1143, "pr_title": "Ps authenticate save fix", "pr_createdAt": "2020-08-28T16:14:48Z", "pr_url": "https://github.com/blackducksoftware/blackduck-alert/pull/1143", "timeline": [{"oid": "7ccb9982ae0ab61711ee24e51eb39be5cfeb1fa0", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/7ccb9982ae0ab61711ee24e51eb39be5cfeb1fa0", "message": "fix: Provide UI feedback that progress is happening.", "committedDate": "2020-08-27T17:12:10Z", "type": "commit"}, {"oid": "5f96b02ab8740815b1000a10e12ac1939e47f405", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/5f96b02ab8740815b1000a10e12ac1939e47f405", "message": "Merge remote-tracking branch 'origin/6.2.0' into ps_authenticate_save_fix", "committedDate": "2020-08-27T18:11:49Z", "type": "commit"}, {"oid": "4923b33bf3869e933871e602b4e9a7c77b9f32d9", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/4923b33bf3869e933871e602b4e9a7c77b9f32d9", "message": "fix: Add a validator to see if there are pending authentication requests.", "committedDate": "2020-08-27T19:34:11Z", "type": "commit"}, {"oid": "a86a4da0a68c9371ddf43db6a1fa831db439559f", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/a86a4da0a68c9371ddf43db6a1fa831db439559f", "message": "fix: Save the existing tokens and email on save/update.", "committedDate": "2020-08-28T15:57:19Z", "type": "commit"}, {"oid": "b6ea82fbb9bc96c4880b900a001b342b6dbe543c", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/b6ea82fbb9bc96c4880b900a001b342b6dbe543c", "message": "refactor: Encapsulate error messages and add a comment.", "committedDate": "2020-08-28T16:12:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQxNjQ3NA==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1143#discussion_r479416474", "bodyText": "It seems odd that we need to add these flushes throughout our code.", "author": "jamesrichard91", "createdAt": "2020-08-28T16:38:41Z", "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/api/DefaultConfigurationAccessor.java", "diffHunk": "@@ -325,6 +325,7 @@ public ConfigurationModel updateConfiguration(Long descriptorConfigId, Collectio\n \n         List<FieldValueEntity> oldValues = fieldValueRepository.findByConfigId(descriptorConfigId);\n         fieldValueRepository.deleteAll(oldValues);\n+        fieldValueRepository.flush();", "originalCommit": "b6ea82fbb9bc96c4880b900a001b342b6dbe543c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyOTIyMA==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1143#discussion_r479429220", "bodyText": "Yeah, seems like a code smell, but it shouldn't cause an issue other than a minor performance hit.", "author": "gkillough", "createdAt": "2020-08-28T17:03:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQxNjQ3NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyMjQ0MA==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1143#discussion_r479422440", "bodyText": "I think this method should take in only a ConfigurationModel and return a Map<String, FieldValueModel> object. Then wherever we generate the Optional, we instead call map and pass this method as a method reference. Then just return the new object like we do on line 93. Does that make sense?", "author": "bamandel", "createdAt": "2020-08-28T16:50:30Z", "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * blackduck-alert\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.channel.azure.boards.actions;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import com.synopsys.integration.alert.channel.azure.boards.descriptor.AzureBoardsDescriptor;\n+import com.synopsys.integration.alert.common.action.ApiAction;\n+import com.synopsys.integration.alert.common.descriptor.DescriptorKey;\n+import com.synopsys.integration.alert.common.descriptor.DescriptorMap;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.rest.model.FieldValueModel;\n+\n+@Component\n+public class AzureBoardsGlobalApiAction extends ApiAction {\n+    private ConfigurationAccessor configurationAccessor;\n+    private DescriptorMap descriptorMap;\n+    private ConfigurationFieldModelConverter fieldModelConverter;\n+\n+    @Autowired\n+    public AzureBoardsGlobalApiAction(ConfigurationAccessor configurationAccessor, DescriptorMap descriptorMap, ConfigurationFieldModelConverter configurationFieldModelConverter) {\n+        this.configurationAccessor = configurationAccessor;\n+        this.descriptorMap = descriptorMap;\n+        this.fieldModelConverter = configurationFieldModelConverter;\n+    }\n+\n+    @Override\n+    public FieldModel beforeSaveAction(FieldModel fieldModel) throws AlertException {\n+        FieldModel updatedFieldModel = super.beforeSaveAction(fieldModel);\n+        Optional<DescriptorKey> descriptorKey = descriptorMap.getDescriptorKey(fieldModel.getDescriptorName());\n+\n+        if (descriptorKey.isPresent()) {\n+            ConfigContextEnum context = ConfigContextEnum.valueOf(fieldModel.getContext());\n+            List<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationsByDescriptorKeyAndContext(descriptorKey.get(), context);\n+            Optional<ConfigurationModel> configurationModel = existingConfig.stream()\n+                                                                  .findFirst();\n+            updatedFieldModel = updateTokenFields(updatedFieldModel, configurationModel);\n+        }\n+        return updatedFieldModel;\n+    }\n+\n+    @Override\n+    public FieldModel beforeUpdateAction(FieldModel fieldModel) throws AlertException {\n+        FieldModel updatedFieldModel = super.beforeUpdateAction(fieldModel);\n+        Optional<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()));\n+        return updateTokenFields(updatedFieldModel, existingConfig);\n+    }\n+\n+    private FieldModel updateTokenFields(FieldModel fieldModel, Optional<ConfigurationModel> existingConfig) {", "originalCommit": "b6ea82fbb9bc96c4880b900a001b342b6dbe543c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "77c3541b961fc66de052fd70194a85369cffcb18", "chunk": "diff --git a/src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java b/src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java\nindex 3534301ec..0616eb95a 100644\n--- a/src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java\n+++ b/src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java\n\n@@ -60,35 +60,37 @@ public class AzureBoardsGlobalApiAction extends ApiAction {\n         FieldModel updatedFieldModel = super.beforeSaveAction(fieldModel);\n         Optional<DescriptorKey> descriptorKey = descriptorMap.getDescriptorKey(fieldModel.getDescriptorName());\n \n-        if (descriptorKey.isPresent()) {\n-            ConfigContextEnum context = ConfigContextEnum.valueOf(fieldModel.getContext());\n-            List<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationsByDescriptorKeyAndContext(descriptorKey.get(), context);\n-            Optional<ConfigurationModel> configurationModel = existingConfig.stream()\n-                                                                  .findFirst();\n-            updatedFieldModel = updateTokenFields(updatedFieldModel, configurationModel);\n+        if (!descriptorKey.isPresent()) {\n+            return updatedFieldModel;\n         }\n-        return updatedFieldModel;\n+        ConfigContextEnum context = ConfigContextEnum.valueOf(fieldModel.getContext());\n+        List<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationsByDescriptorKeyAndContext(descriptorKey.get(), context);\n+        Optional<ConfigurationModel> configurationModel = existingConfig.stream()\n+                                                              .findFirst();\n+        return configurationModel\n+                   .map((config) -> updateTokenFields(updatedFieldModel, config))\n+                   .orElse(updatedFieldModel);\n+\n     }\n \n     @Override\n     public FieldModel beforeUpdateAction(FieldModel fieldModel) throws AlertException {\n         FieldModel updatedFieldModel = super.beforeUpdateAction(fieldModel);\n         Optional<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()));\n-        return updateTokenFields(updatedFieldModel, existingConfig);\n+        return existingConfig\n+                   .map((config) -> updateTokenFields(updatedFieldModel, config))\n+                   .orElse(updatedFieldModel);\n     }\n \n-    private FieldModel updateTokenFields(FieldModel fieldModel, Optional<ConfigurationModel> existingConfig) {\n+    private FieldModel updateTokenFields(FieldModel fieldModel, ConfigurationModel configurationModel) {\n         Map<String, FieldValueModel> keyToValues = new HashMap<>(fieldModel.getKeyToValues());\n-        if (existingConfig.isPresent()) {\n-            ConfigurationModel configurationModel = existingConfig.get();\n-            Map<String, FieldValueModel> existingFields = fieldModelConverter.convertToFieldValuesMap(configurationModel.getCopyOfFieldList());\n+        Map<String, FieldValueModel> existingFields = fieldModelConverter.convertToFieldValuesMap(configurationModel.getCopyOfFieldList());\n \n-            // These fields are saved in the OAuth callback controller so we need to preserve their values on a save or an update.\n-            updateMapWithMissingField(AzureBoardsDescriptor.KEY_ACCESS_TOKEN, existingFields, keyToValues);\n-            updateMapWithMissingField(AzureBoardsDescriptor.KEY_REFRESH_TOKEN, existingFields, keyToValues);\n-            updateMapWithMissingField(AzureBoardsDescriptor.KEY_TOKEN_EXPIRATION_MILLIS, existingFields, keyToValues);\n-            updateMapWithMissingField(AzureBoardsDescriptor.KEY_OAUTH_USER_EMAIL, existingFields, keyToValues);\n-        }\n+        // These fields are saved in the OAuth callback controller so we need to preserve their values on a save or an update.\n+        updateMapWithMissingField(AzureBoardsDescriptor.KEY_ACCESS_TOKEN, existingFields, keyToValues);\n+        updateMapWithMissingField(AzureBoardsDescriptor.KEY_REFRESH_TOKEN, existingFields, keyToValues);\n+        updateMapWithMissingField(AzureBoardsDescriptor.KEY_TOKEN_EXPIRATION_MILLIS, existingFields, keyToValues);\n+        updateMapWithMissingField(AzureBoardsDescriptor.KEY_OAUTH_USER_EMAIL, existingFields, keyToValues);\n \n         return new FieldModel(fieldModel.getDescriptorName(), fieldModel.getContext(), fieldModel.getCreatedAt(), fieldModel.getLastUpdated(), keyToValues);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQzMTQ0NA==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1143#discussion_r479431444", "bodyText": "Do we always want to prefer what's in the DB? Or should we use the value of the FieldValueModel if it has one?", "author": "gkillough", "createdAt": "2020-08-28T17:08:02Z", "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * blackduck-alert\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.channel.azure.boards.actions;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import com.synopsys.integration.alert.channel.azure.boards.descriptor.AzureBoardsDescriptor;\n+import com.synopsys.integration.alert.common.action.ApiAction;\n+import com.synopsys.integration.alert.common.descriptor.DescriptorKey;\n+import com.synopsys.integration.alert.common.descriptor.DescriptorMap;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.rest.model.FieldValueModel;\n+\n+@Component\n+public class AzureBoardsGlobalApiAction extends ApiAction {\n+    private ConfigurationAccessor configurationAccessor;\n+    private DescriptorMap descriptorMap;\n+    private ConfigurationFieldModelConverter fieldModelConverter;\n+\n+    @Autowired\n+    public AzureBoardsGlobalApiAction(ConfigurationAccessor configurationAccessor, DescriptorMap descriptorMap, ConfigurationFieldModelConverter configurationFieldModelConverter) {\n+        this.configurationAccessor = configurationAccessor;\n+        this.descriptorMap = descriptorMap;\n+        this.fieldModelConverter = configurationFieldModelConverter;\n+    }\n+\n+    @Override\n+    public FieldModel beforeSaveAction(FieldModel fieldModel) throws AlertException {\n+        FieldModel updatedFieldModel = super.beforeSaveAction(fieldModel);\n+        Optional<DescriptorKey> descriptorKey = descriptorMap.getDescriptorKey(fieldModel.getDescriptorName());\n+\n+        if (descriptorKey.isPresent()) {\n+            ConfigContextEnum context = ConfigContextEnum.valueOf(fieldModel.getContext());\n+            List<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationsByDescriptorKeyAndContext(descriptorKey.get(), context);\n+            Optional<ConfigurationModel> configurationModel = existingConfig.stream()\n+                                                                  .findFirst();\n+            updatedFieldModel = updateTokenFields(updatedFieldModel, configurationModel);\n+        }\n+        return updatedFieldModel;\n+    }\n+\n+    @Override\n+    public FieldModel beforeUpdateAction(FieldModel fieldModel) throws AlertException {\n+        FieldModel updatedFieldModel = super.beforeUpdateAction(fieldModel);\n+        Optional<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()));\n+        return updateTokenFields(updatedFieldModel, existingConfig);\n+    }\n+\n+    private FieldModel updateTokenFields(FieldModel fieldModel, Optional<ConfigurationModel> existingConfig) {\n+        Map<String, FieldValueModel> keyToValues = new HashMap<>(fieldModel.getKeyToValues());\n+        if (existingConfig.isPresent()) {\n+            ConfigurationModel configurationModel = existingConfig.get();\n+            Map<String, FieldValueModel> existingFields = fieldModelConverter.convertToFieldValuesMap(configurationModel.getCopyOfFieldList());\n+\n+            // These fields are saved in the OAuth callback controller so we need to preserve their values on a save or an update.\n+            updateMapWithMissingField(AzureBoardsDescriptor.KEY_ACCESS_TOKEN, existingFields, keyToValues);\n+            updateMapWithMissingField(AzureBoardsDescriptor.KEY_REFRESH_TOKEN, existingFields, keyToValues);\n+            updateMapWithMissingField(AzureBoardsDescriptor.KEY_TOKEN_EXPIRATION_MILLIS, existingFields, keyToValues);\n+            updateMapWithMissingField(AzureBoardsDescriptor.KEY_OAUTH_USER_EMAIL, existingFields, keyToValues);\n+        }\n+\n+        return new FieldModel(fieldModel.getDescriptorName(), fieldModel.getContext(), fieldModel.getCreatedAt(), fieldModel.getLastUpdated(), keyToValues);\n+    }\n+\n+    private void updateMapWithMissingField(String key, Map<String, FieldValueModel> databaseFields, Map<String, FieldValueModel> fieldModelFields) {\n+        if (databaseFields.containsKey(key)) {\n+            fieldModelFields.put(key, databaseFields.get(key));\n+        }", "originalCommit": "b6ea82fbb9bc96c4880b900a001b342b6dbe543c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQzNjQ3OA==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1143#discussion_r479436478", "bodyText": "The fieldModel on a save will not have the token fields.  They aren't rendered at all in the UI, therefore the FieldModel we are trying to save will be missing those values always.", "author": "psantos1113", "createdAt": "2020-08-28T17:18:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQzMTQ0NA=="}], "type": "inlineReview", "revised_code": {"commit": "77c3541b961fc66de052fd70194a85369cffcb18", "chunk": "diff --git a/src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java b/src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java\nindex 3534301ec..0616eb95a 100644\n--- a/src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java\n+++ b/src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java\n\n@@ -60,35 +60,37 @@ public class AzureBoardsGlobalApiAction extends ApiAction {\n         FieldModel updatedFieldModel = super.beforeSaveAction(fieldModel);\n         Optional<DescriptorKey> descriptorKey = descriptorMap.getDescriptorKey(fieldModel.getDescriptorName());\n \n-        if (descriptorKey.isPresent()) {\n-            ConfigContextEnum context = ConfigContextEnum.valueOf(fieldModel.getContext());\n-            List<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationsByDescriptorKeyAndContext(descriptorKey.get(), context);\n-            Optional<ConfigurationModel> configurationModel = existingConfig.stream()\n-                                                                  .findFirst();\n-            updatedFieldModel = updateTokenFields(updatedFieldModel, configurationModel);\n+        if (!descriptorKey.isPresent()) {\n+            return updatedFieldModel;\n         }\n-        return updatedFieldModel;\n+        ConfigContextEnum context = ConfigContextEnum.valueOf(fieldModel.getContext());\n+        List<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationsByDescriptorKeyAndContext(descriptorKey.get(), context);\n+        Optional<ConfigurationModel> configurationModel = existingConfig.stream()\n+                                                              .findFirst();\n+        return configurationModel\n+                   .map((config) -> updateTokenFields(updatedFieldModel, config))\n+                   .orElse(updatedFieldModel);\n+\n     }\n \n     @Override\n     public FieldModel beforeUpdateAction(FieldModel fieldModel) throws AlertException {\n         FieldModel updatedFieldModel = super.beforeUpdateAction(fieldModel);\n         Optional<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()));\n-        return updateTokenFields(updatedFieldModel, existingConfig);\n+        return existingConfig\n+                   .map((config) -> updateTokenFields(updatedFieldModel, config))\n+                   .orElse(updatedFieldModel);\n     }\n \n-    private FieldModel updateTokenFields(FieldModel fieldModel, Optional<ConfigurationModel> existingConfig) {\n+    private FieldModel updateTokenFields(FieldModel fieldModel, ConfigurationModel configurationModel) {\n         Map<String, FieldValueModel> keyToValues = new HashMap<>(fieldModel.getKeyToValues());\n-        if (existingConfig.isPresent()) {\n-            ConfigurationModel configurationModel = existingConfig.get();\n-            Map<String, FieldValueModel> existingFields = fieldModelConverter.convertToFieldValuesMap(configurationModel.getCopyOfFieldList());\n+        Map<String, FieldValueModel> existingFields = fieldModelConverter.convertToFieldValuesMap(configurationModel.getCopyOfFieldList());\n \n-            // These fields are saved in the OAuth callback controller so we need to preserve their values on a save or an update.\n-            updateMapWithMissingField(AzureBoardsDescriptor.KEY_ACCESS_TOKEN, existingFields, keyToValues);\n-            updateMapWithMissingField(AzureBoardsDescriptor.KEY_REFRESH_TOKEN, existingFields, keyToValues);\n-            updateMapWithMissingField(AzureBoardsDescriptor.KEY_TOKEN_EXPIRATION_MILLIS, existingFields, keyToValues);\n-            updateMapWithMissingField(AzureBoardsDescriptor.KEY_OAUTH_USER_EMAIL, existingFields, keyToValues);\n-        }\n+        // These fields are saved in the OAuth callback controller so we need to preserve their values on a save or an update.\n+        updateMapWithMissingField(AzureBoardsDescriptor.KEY_ACCESS_TOKEN, existingFields, keyToValues);\n+        updateMapWithMissingField(AzureBoardsDescriptor.KEY_REFRESH_TOKEN, existingFields, keyToValues);\n+        updateMapWithMissingField(AzureBoardsDescriptor.KEY_TOKEN_EXPIRATION_MILLIS, existingFields, keyToValues);\n+        updateMapWithMissingField(AzureBoardsDescriptor.KEY_OAUTH_USER_EMAIL, existingFields, keyToValues);\n \n         return new FieldModel(fieldModel.getDescriptorName(), fieldModel.getContext(), fieldModel.getCreatedAt(), fieldModel.getLastUpdated(), keyToValues);\n     }\n"}}, {"oid": "77c3541b961fc66de052fd70194a85369cffcb18", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/77c3541b961fc66de052fd70194a85369cffcb18", "message": "refactor: Use map function of optionals based on PR feedback.", "committedDate": "2020-08-28T18:21:24Z", "type": "commit"}]}