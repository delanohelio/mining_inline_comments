{"pr_number": 3649, "pr_title": "Add TransactionEvent for successful transactions", "pr_createdAt": "2020-09-05T05:12:52Z", "pr_url": "https://github.com/EssentialsX/Essentials/pull/3649", "timeline": [{"oid": "efd0e0d5bfd9d2577a136224ac18854f3f225105", "url": "https://github.com/EssentialsX/Essentials/commit/efd0e0d5bfd9d2577a136224ac18854f3f225105", "message": "Add TransactionEvent for successful transactions\nThis adds an event for plugins to hook into when a transaction occurs, allowing them to do whatever they want.\n\nImplements #3635", "committedDate": "2020-09-05T05:10:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY3MDYyNA==", "url": "https://github.com/EssentialsX/Essentials/pull/3649#discussion_r485670624", "bodyText": "Should probably check the current thread here, in case transactions occur async.", "author": "mdcfe", "createdAt": "2020-09-09T14:46:10Z", "path": "Essentials/src/net/ess3/api/events/TransactionEvent.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package net.ess3.api.events;\n+\n+import com.earth2me.essentials.CommandSource;\n+import net.ess3.api.IUser;\n+import org.bukkit.event.Event;\n+import org.bukkit.event.HandlerList;\n+\n+import java.math.BigDecimal;\n+\n+public class TransactionEvent extends Event {\n+    private static final HandlerList handlers = new HandlerList();\n+\n+    private final CommandSource requester;\n+    private final IUser target;\n+    private final BigDecimal amount;\n+\n+    public TransactionEvent(CommandSource requester, IUser target, BigDecimal amount) {\n+        super();", "originalCommit": "efd0e0d5bfd9d2577a136224ac18854f3f225105", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY5ODc1Mg==", "url": "https://github.com/EssentialsX/Essentials/pull/3649#discussion_r485698752", "bodyText": "Not sure what you mean, doesn't the event get raised after the transaction is over?", "author": "Chew", "createdAt": "2020-09-09T15:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY3MDYyNA=="}], "type": "inlineReview", "revised_code": {"commit": "8623afced6d069c05863b956c717ed7693d34d61", "chunk": "diff --git a/Essentials/src/net/ess3/api/events/TransactionEvent.java b/Essentials/src/net/ess3/api/events/TransactionEvent.java\nindex 334b4a781..874d3f7fa 100644\n--- a/Essentials/src/net/ess3/api/events/TransactionEvent.java\n+++ b/Essentials/src/net/ess3/api/events/TransactionEvent.java\n\n@@ -2,6 +2,7 @@ package net.ess3.api.events;\n \n import com.earth2me.essentials.CommandSource;\n import net.ess3.api.IUser;\n+import org.bukkit.Bukkit;\n import org.bukkit.event.Event;\n import org.bukkit.event.HandlerList;\n \n"}}, {"oid": "8623afced6d069c05863b956c717ed7693d34d61", "url": "https://github.com/EssentialsX/Essentials/commit/8623afced6d069c05863b956c717ed7693d34d61", "message": "Check if thread is primary thread", "committedDate": "2020-09-09T15:37:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2NTE5OQ==", "url": "https://github.com/EssentialsX/Essentials/pull/3649#discussion_r489165199", "bodyText": "Don't use * imports", "author": "pop4959", "createdAt": "2020-09-16T05:05:43Z", "path": "Essentials/src/com/earth2me/essentials/User.java", "diffHunk": "@@ -11,10 +11,7 @@\n import com.earth2me.essentials.utils.VersionUtil;\n import net.ess3.api.IEssentials;\n import net.ess3.api.MaxMoneyException;\n-import net.ess3.api.events.AfkStatusChangeEvent;\n-import net.ess3.api.events.JailStatusChangeEvent;\n-import net.ess3.api.events.MuteStatusChangeEvent;\n-import net.ess3.api.events.UserBalanceUpdateEvent;\n+import net.ess3.api.events.*;", "originalCommit": "8623afced6d069c05863b956c717ed7693d34d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3MDA0Mw==", "url": "https://github.com/EssentialsX/Essentials/pull/3649#discussion_r489170043", "bodyText": "That's just what IntelliJ auto optimize did ;-;", "author": "Chew", "createdAt": "2020-09-16T05:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2NTE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MzUyOA==", "url": "https://github.com/EssentialsX/Essentials/pull/3649#discussion_r489243528", "bodyText": "you can turn it off", "author": "pop4959", "createdAt": "2020-09-16T08:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2NTE5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6bb3f3acced48eb1b1bc10015028be94b0881ca3", "chunk": "diff --git a/Essentials/src/com/earth2me/essentials/User.java b/Essentials/src/com/earth2me/essentials/User.java\nindex 383d187a6..5ddd9852a 100644\n--- a/Essentials/src/com/earth2me/essentials/User.java\n+++ b/Essentials/src/com/earth2me/essentials/User.java\n\n@@ -11,7 +11,11 @@ import com.earth2me.essentials.utils.NumberUtil;\n import com.earth2me.essentials.utils.VersionUtil;\n import net.ess3.api.IEssentials;\n import net.ess3.api.MaxMoneyException;\n-import net.ess3.api.events.*;\n+import net.ess3.api.events.AfkStatusChangeEvent;\n+import net.ess3.api.events.JailStatusChangeEvent;\n+import net.ess3.api.events.MuteStatusChangeEvent;\n+import net.ess3.api.events.TransactionEvent;\n+import net.ess3.api.events.UserBalanceUpdateEvent;\n import org.bukkit.Location;\n import org.bukkit.Material;\n import org.bukkit.entity.Player;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3MzI2MA==", "url": "https://github.com/EssentialsX/Essentials/pull/3649#discussion_r489173260", "bodyText": "It's \"receiver\"", "author": "l1ttleO", "createdAt": "2020-09-16T05:34:00Z", "path": "Essentials/src/com/earth2me/essentials/User.java", "diffHunk": "@@ -199,6 +196,8 @@ public void payUser(final User reciever, final BigDecimal value, UserBalanceUpda\n             reciever.setMoney(reciever.getMoney().add(value), cause);\n             sendMessage(tl(\"moneySentTo\", NumberUtil.displayCurrency(value, ess), reciever.getDisplayName()));\n             reciever.sendMessage(tl(\"moneyRecievedFrom\", NumberUtil.displayCurrency(value, ess), getDisplayName()));\n+            TransactionEvent transactionEvent = new TransactionEvent(this.getSource(), reciever, value);\n+            ess.getServer().getPluginManager().callEvent(transactionEvent);", "originalCommit": "8623afced6d069c05863b956c717ed7693d34d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU5MTIwNg==", "url": "https://github.com/EssentialsX/Essentials/pull/3649#discussion_r489591206", "bodyText": "No it's not", "author": "Chew", "createdAt": "2020-09-16T17:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3MzI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU5MTc4OQ==", "url": "https://github.com/EssentialsX/Essentials/pull/3649#discussion_r489591789", "bodyText": "To clarify: it's spelt that way in the code, not necessarily the proper spelling. I'm not here to fix typos.", "author": "Chew", "createdAt": "2020-09-16T17:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3MzI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU5MjMzOQ==", "url": "https://github.com/EssentialsX/Essentials/pull/3649#discussion_r489592339", "bodyText": "My inner perfectionist couldn't resist.", "author": "l1ttleO", "createdAt": "2020-09-16T17:08:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3MzI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYzMTk0NA==", "url": "https://github.com/EssentialsX/Essentials/pull/3649#discussion_r489631944", "bodyText": "@l1ttleO Feel free to make a separate PR to fix the typos if you feel the need, but it's not in scope for this one.", "author": "pop4959", "createdAt": "2020-09-16T18:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3MzI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "448661cbde2ac8248a9de3cbeedbadb56fcba731", "chunk": "diff --git a/Essentials/src/com/earth2me/essentials/User.java b/Essentials/src/com/earth2me/essentials/User.java\ndeleted file mode 100644\nindex 383d187a6..000000000\n--- a/Essentials/src/com/earth2me/essentials/User.java\n+++ /dev/null\n\n@@ -1,1002 +0,0 @@\n-package com.earth2me.essentials;\n-\n-import com.earth2me.essentials.commands.IEssentialsCommand;\n-import com.earth2me.essentials.messaging.IMessageRecipient;\n-import com.earth2me.essentials.messaging.SimpleMessageRecipient;\n-import com.earth2me.essentials.register.payment.Method;\n-import com.earth2me.essentials.register.payment.Methods;\n-import com.earth2me.essentials.utils.DateUtil;\n-import com.earth2me.essentials.utils.FormatUtil;\n-import com.earth2me.essentials.utils.NumberUtil;\n-import com.earth2me.essentials.utils.VersionUtil;\n-import net.ess3.api.IEssentials;\n-import net.ess3.api.MaxMoneyException;\n-import net.ess3.api.events.*;\n-import org.bukkit.Location;\n-import org.bukkit.Material;\n-import org.bukkit.entity.Player;\n-import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;\n-import org.bukkit.inventory.ItemStack;\n-import org.bukkit.inventory.PlayerInventory;\n-import org.bukkit.potion.PotionEffect;\n-import org.bukkit.potion.PotionEffectType;\n-\n-import java.math.BigDecimal;\n-import java.util.Calendar;\n-import java.util.GregorianCalendar;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.UUID;\n-import java.util.WeakHashMap;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-\n-import static com.earth2me.essentials.I18n.tl;\n-\n-\n-public class User extends UserData implements Comparable<User>, IMessageRecipient, net.ess3.api.IUser {\n-    private static final Logger logger = Logger.getLogger(\"Essentials\");\n-    private final IMessageRecipient messageRecipient;\n-    private transient UUID teleportRequester;\n-    private transient boolean teleportRequestHere;\n-    private transient Location teleportLocation;\n-    private transient boolean vanished;\n-    private transient final AsyncTeleport teleport;\n-    private transient final Teleport legacyTeleport;\n-    private transient long teleportRequestTime;\n-    private transient long lastOnlineActivity;\n-    private transient long lastThrottledAction;\n-    private transient long lastActivity = System.currentTimeMillis();\n-    private boolean hidden = false;\n-    private boolean rightClickJump = false;\n-    private transient Location afkPosition = null;\n-    private boolean invSee = false;\n-    private boolean recipeSee = false;\n-    private boolean enderSee = false;\n-    private transient long teleportInvulnerabilityTimestamp = 0;\n-    private boolean ignoreMsg = false;\n-    private String afkMessage;\n-    private long afkSince;\n-    private final Map<User, BigDecimal> confirmingPayments = new WeakHashMap<>();\n-    private String confirmingClearCommand;\n-    private long lastNotifiedAboutMailsMs;\n-    private String lastHomeConfirmation;\n-    private long lastHomeConfirmationTimestamp;\n-\n-    public User(final Player base, final IEssentials ess) {\n-        super(base, ess);\n-        teleport = new AsyncTeleport(this, ess);\n-        legacyTeleport = new Teleport(this, ess);\n-        if (isAfk()) {\n-            afkPosition = this.getLocation();\n-        }\n-        if (this.getBase().isOnline()) {\n-            lastOnlineActivity = System.currentTimeMillis();\n-        }\n-        this.messageRecipient = new SimpleMessageRecipient(ess, this);\n-    }\n-\n-    User update(final Player base) {\n-        setBase(base);\n-        return this;\n-    }\n-\n-    @Override\n-    public boolean isAuthorized(final IEssentialsCommand cmd) {\n-        return isAuthorized(cmd, \"essentials.\");\n-    }\n-\n-    @Override\n-    public boolean isAuthorized(final IEssentialsCommand cmd, final String permissionPrefix) {\n-        return isAuthorized(permissionPrefix + (cmd.getName().equals(\"r\") ? \"msg\" : cmd.getName()));\n-    }\n-\n-    @Override\n-    public boolean isAuthorized(final String node) {\n-        final boolean result = isAuthorizedCheck(node);\n-        if (ess.getSettings().isDebug()) {\n-            ess.getLogger().log(Level.INFO, \"checking if \" + base.getName() + \" has \" + node + \" - \" + result);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public boolean isPermissionSet(final String node) {\n-        return isPermSetCheck(node);\n-    }\n-\n-    private boolean isAuthorizedCheck(final String node) {\n-\n-        if (base instanceof OfflinePlayer) {\n-            return false;\n-        }\n-\n-        try {\n-            return ess.getPermissionsHandler().hasPermission(base, node);\n-        } catch (Exception ex) {\n-            if (ess.getSettings().isDebug()) {\n-                ess.getLogger().log(Level.SEVERE, \"Permission System Error: \" + ess.getPermissionsHandler().getName() + \" returned: \" + ex.getMessage(), ex);\n-            } else {\n-                ess.getLogger().log(Level.SEVERE, \"Permission System Error: \" + ess.getPermissionsHandler().getName() + \" returned: \" + ex.getMessage());\n-            }\n-\n-            return false;\n-        }\n-    }\n-\n-    private boolean isPermSetCheck(final String node) {\n-        if (base instanceof OfflinePlayer) {\n-            return false;\n-        }\n-\n-        try {\n-            return ess.getPermissionsHandler().isPermissionSet(base, node);\n-        } catch (Exception ex) {\n-            if (ess.getSettings().isDebug()) {\n-                ess.getLogger().log(Level.SEVERE, \"Permission System Error: \" + ess.getPermissionsHandler().getName() + \" returned: \" + ex.getMessage(), ex);\n-            } else {\n-                ess.getLogger().log(Level.SEVERE, \"Permission System Error: \" + ess.getPermissionsHandler().getName() + \" returned: \" + ex.getMessage());\n-            }\n-\n-            return false;\n-        }\n-    }\n-\n-    @Override\n-    public void healCooldown() throws Exception {\n-        final Calendar now = new GregorianCalendar();\n-        if (getLastHealTimestamp() > 0) {\n-            final double cooldown = ess.getSettings().getHealCooldown();\n-            final Calendar cooldownTime = new GregorianCalendar();\n-            cooldownTime.setTimeInMillis(getLastHealTimestamp());\n-            cooldownTime.add(Calendar.SECOND, (int) cooldown);\n-            cooldownTime.add(Calendar.MILLISECOND, (int) ((cooldown * 1000.0) % 1000.0));\n-            if (cooldownTime.after(now) && !isAuthorized(\"essentials.heal.cooldown.bypass\")) {\n-                throw new Exception(tl(\"timeBeforeHeal\", DateUtil.formatDateDiff(cooldownTime.getTimeInMillis())));\n-            }\n-        }\n-        setLastHealTimestamp(now.getTimeInMillis());\n-    }\n-\n-    @Override\n-    public void giveMoney(final BigDecimal value) throws MaxMoneyException {\n-        giveMoney(value, null);\n-    }\n-\n-    @Override\n-    public void giveMoney(final BigDecimal value, final CommandSource initiator) throws MaxMoneyException {\n-        giveMoney(value, initiator, UserBalanceUpdateEvent.Cause.UNKNOWN);\n-    }\n-\n-    public void giveMoney(final BigDecimal value, final CommandSource initiator, UserBalanceUpdateEvent.Cause cause) throws MaxMoneyException {\n-        if (value.signum() == 0) {\n-            return;\n-        }\n-        setMoney(getMoney().add(value), cause);\n-        sendMessage(tl(\"addedToAccount\", NumberUtil.displayCurrency(value, ess)));\n-        if (initiator != null) {\n-            initiator.sendMessage(tl(\"addedToOthersAccount\", NumberUtil.displayCurrency(value, ess), this.getDisplayName(), NumberUtil.displayCurrency(getMoney(), ess)));\n-        }\n-    }\n-\n-    @Override\n-    public void payUser(final User reciever, final BigDecimal value) throws Exception {\n-        payUser(reciever, value, UserBalanceUpdateEvent.Cause.UNKNOWN);\n-    }\n-\n-    public void payUser(final User reciever, final BigDecimal value, UserBalanceUpdateEvent.Cause cause) throws Exception {\n-        if (value.compareTo(BigDecimal.ZERO) < 1) {\n-            throw new Exception(tl(\"payMustBePositive\"));\n-        }\n-\n-        if (canAfford(value)) {\n-            setMoney(getMoney().subtract(value), cause);\n-            reciever.setMoney(reciever.getMoney().add(value), cause);\n-            sendMessage(tl(\"moneySentTo\", NumberUtil.displayCurrency(value, ess), reciever.getDisplayName()));\n-            reciever.sendMessage(tl(\"moneyRecievedFrom\", NumberUtil.displayCurrency(value, ess), getDisplayName()));\n-            TransactionEvent transactionEvent = new TransactionEvent(this.getSource(), reciever, value);\n-            ess.getServer().getPluginManager().callEvent(transactionEvent);\n-        } else {\n-            throw new ChargeException(tl(\"notEnoughMoney\", NumberUtil.displayCurrency(value, ess)));\n-        }\n-    }\n-\n-    @Override\n-    public void takeMoney(final BigDecimal value) {\n-        takeMoney(value, null);\n-    }\n-\n-    @Override\n-    public void takeMoney(final BigDecimal value, final CommandSource initiator) {\n-        takeMoney(value, initiator, UserBalanceUpdateEvent.Cause.UNKNOWN);\n-    }\n-\n-    public void takeMoney(final BigDecimal value, final CommandSource initiator, UserBalanceUpdateEvent.Cause cause) {\n-        if (value.signum() == 0) {\n-            return;\n-        }\n-        try {\n-            setMoney(getMoney().subtract(value), cause);\n-        } catch (MaxMoneyException ex) {\n-            ess.getLogger().log(Level.WARNING, \"Invalid call to takeMoney, total balance can't be more than the max-money limit.\", ex);\n-        }\n-        sendMessage(tl(\"takenFromAccount\", NumberUtil.displayCurrency(value, ess)));\n-        if (initiator != null) {\n-            initiator.sendMessage(tl(\"takenFromOthersAccount\", NumberUtil.displayCurrency(value, ess), this.getDisplayName(), NumberUtil.displayCurrency(getMoney(), ess)));\n-        }\n-    }\n-\n-    @Override\n-    public boolean canAfford(final BigDecimal cost) {\n-        return canAfford(cost, true);\n-    }\n-\n-    public boolean canAfford(final BigDecimal cost, final boolean permcheck) {\n-        if (cost.signum() <= 0) {\n-            return true;\n-        }\n-        final BigDecimal remainingBalance = getMoney().subtract(cost);\n-        if (!permcheck || isAuthorized(\"essentials.eco.loan\")) {\n-            return (remainingBalance.compareTo(ess.getSettings().getMinMoney()) >= 0);\n-        }\n-        return (remainingBalance.signum() >= 0);\n-    }\n-\n-    public void dispose() {\n-        ess.runTaskAsynchronously(this::_dispose);\n-    }\n-\n-    private void _dispose() {\n-        if (!base.isOnline()) {\n-            this.base = new OfflinePlayer(getConfigUUID(), ess.getServer());\n-        }\n-        cleanup();\n-    }\n-\n-    @Override\n-    public Boolean canSpawnItem(final Material material) {\n-        if (ess.getSettings().permissionBasedItemSpawn()) {\n-            final String name = material.toString().toLowerCase(Locale.ENGLISH).replace(\"_\", \"\");\n-\n-            if (isAuthorized(\"essentials.itemspawn.item-all\") || isAuthorized(\"essentials.itemspawn.item-\" + name)) return true;\n-\n-            if (VersionUtil.getServerBukkitVersion().isLowerThan(VersionUtil.v1_13_0_R01)) {\n-                final int id = material.getId();\n-                if (isAuthorized(\"essentials.itemspawn.item-\" + id)) return true;\n-            }\n-        }\n-\n-        return isAuthorized(\"essentials.itemspawn.exempt\") || !ess.getSettings().itemSpawnBlacklist().contains(material);\n-    }\n-\n-    @Override\n-    public void setLastLocation() {\n-        setLastLocation(this.getLocation());\n-    }\n-\n-    @Override\n-    public void setLogoutLocation() {\n-        setLogoutLocation(this.getLocation());\n-    }\n-\n-    @Override\n-    public void requestTeleport(final User player, final boolean here) {\n-        teleportRequestTime = System.currentTimeMillis();\n-        teleportRequester = player == null ? null : player.getBase().getUniqueId();\n-        teleportRequestHere = here;\n-        if (player == null) {\n-            teleportLocation = null;\n-        } else {\n-            teleportLocation = here ? player.getLocation() : this.getLocation();\n-        }\n-    }\n-\n-    @Override\n-    public boolean hasOutstandingTeleportRequest() {\n-        if (getTeleportRequest() != null) { // Player has outstanding teleport request.\n-            long timeout = ess.getSettings().getTpaAcceptCancellation();\n-            if (timeout != 0) {\n-                if ((System.currentTimeMillis() - getTeleportRequestTime()) / 1000 <= timeout) { // Player has outstanding request\n-                    return true;\n-                } else { // outstanding request expired.\n-                    requestTeleport(null, false);\n-                    return false;\n-                }\n-            } else { // outstanding request does not expire\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public UUID getTeleportRequest() {\n-        return teleportRequester;\n-    }\n-\n-    public boolean isTpRequestHere() {\n-        return teleportRequestHere;\n-    }\n-\n-    public Location getTpRequestLocation() {\n-        return teleportLocation;\n-    }\n-\n-    public String getNick() {\n-        return getNick(true, true);\n-    }\n-\n-    /**\n-     * Needed for backwards compatibility.\n-     */\n-    public String getNick(final boolean longnick) {\n-        return getNick(true, true);\n-    }\n-\n-    /**\n-     * Needed for backwards compatibility.\n-     */\n-    public String getNick(boolean longnick, final boolean withPrefix, final boolean withSuffix) {\n-        return getNick(withPrefix, withSuffix);\n-    }\n-\n-    public String getNick(final boolean withPrefix, final boolean withSuffix) {\n-        final StringBuilder prefix = new StringBuilder();\n-        String nickname;\n-        String suffix = \"\";\n-        final String nick = getNickname();\n-        if (ess.getSettings().isCommandDisabled(\"nick\") || nick == null || nick.isEmpty() || nick.equals(getName())) {\n-            nickname = getName();\n-        } else if (nick.equalsIgnoreCase(getName())) {\n-            nickname = nick;\n-        } else {\n-            nickname = FormatUtil.replaceFormat(ess.getSettings().getNicknamePrefix()) + nick;\n-            suffix = \"\u00a7r\";\n-        }\n-\n-        if (this.getBase().isOp()) {\n-            try {\n-                final String opPrefix = ess.getSettings().getOperatorColor();\n-                if (opPrefix != null && !opPrefix.isEmpty()) {\n-                    prefix.insert(0, opPrefix);\n-                    suffix = \"\u00a7r\";\n-                }\n-            } catch (Exception e) {\n-                if (ess.getSettings().isDebug()) {\n-                    e.printStackTrace();\n-                }\n-            }\n-        }\n-\n-        if (ess.getSettings().addPrefixSuffix()) {\n-            //These two extra toggles are not documented, because they are mostly redundant #EasterEgg\n-            if (withPrefix || !ess.getSettings().disablePrefix()) {\n-                final String ptext = FormatUtil.replaceFormat(ess.getPermissionsHandler().getPrefix(base));\n-                prefix.insert(0, ptext);\n-                suffix = \"\u00a7r\";\n-            }\n-            if (withSuffix || !ess.getSettings().disableSuffix()) {\n-                final String stext = FormatUtil.replaceFormat(ess.getPermissionsHandler().getSuffix(base));\n-                suffix = stext + \"\u00a7r\";\n-                // :YEP: WHAT ARE THEY DOING?\n-                // :YEP: STILL. LEGACY CODE.\n-                // :YEP: BUT WHY?\n-                // :YEP: I CAN'T BELIEVE THIS!\n-                // Code from 1542 BC #EasterEgg\n-                suffix = suffix.replace(\"\u00a7f\u00a7r\", \"\u00a7r\").replace(\"\u00a7r\u00a7r\", \"\u00a7r\");\n-            }\n-        }\n-        final String strPrefix = prefix.toString();\n-        String output = strPrefix + nickname + suffix;\n-        if (output.charAt(output.length() - 1) == '\u00a7') {\n-            output = output.substring(0, output.length() - 1);\n-        }\n-        return output;\n-    }\n-\n-    public void setDisplayNick() {\n-        if (base.isOnline() && ess.getSettings().changeDisplayName()) {\n-            this.getBase().setDisplayName(getNick(true));\n-            if (isAfk()) {\n-                updateAfkListName();\n-            } else if (ess.getSettings().changePlayerListName()) {\n-                String name = getNick(ess.getSettings().isAddingPrefixInPlayerlist(), ess.getSettings().isAddingSuffixInPlayerlist());\n-                try {\n-                    this.getBase().setPlayerListName(name);\n-                } catch (IllegalArgumentException e) {\n-                    if (ess.getSettings().isDebug()) {\n-                        logger.log(Level.INFO, \"Playerlist for \" + name + \" was not updated. Name clashed with another online player.\");\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String getDisplayName() {\n-        return super.getBase().getDisplayName() == null || (ess.getSettings().hideDisplayNameInVanish() && isHidden()) ? super.getBase().getName() : super.getBase().getDisplayName();\n-    }\n-\n-    @Override\n-    public AsyncTeleport getAsyncTeleport() {\n-        return teleport;\n-    }\n-\n-    /**\n-     * @deprecated This API is not asynchronous. Use {@link User#getAsyncTeleport()}\n-     */\n-    @Override\n-    @Deprecated\n-    public Teleport getTeleport() {\n-        return legacyTeleport;\n-    }\n-\n-    public long getLastOnlineActivity() {\n-        return lastOnlineActivity;\n-    }\n-\n-    public void setLastOnlineActivity(final long timestamp) {\n-        lastOnlineActivity = timestamp;\n-    }\n-\n-    @Override\n-    public BigDecimal getMoney() {\n-        final long start = System.nanoTime();\n-        final BigDecimal value = _getMoney();\n-        final long elapsed = System.nanoTime() - start;\n-        if (elapsed > ess.getSettings().getEconomyLagWarning()) {\n-            ess.getLogger().log(Level.INFO, \"Lag Notice - Slow Economy Response - Request took over {0}ms!\", elapsed / 1000000.0);\n-        }\n-        return value;\n-    }\n-\n-    private BigDecimal _getMoney() {\n-        if (ess.getSettings().isEcoDisabled()) {\n-            if (ess.getSettings().isDebug()) {\n-                ess.getLogger().info(\"Internal economy functions disabled, aborting balance check.\");\n-            }\n-            return BigDecimal.ZERO;\n-        }\n-        if (Methods.hasMethod()) {\n-            try {\n-                final Method method = Methods.getMethod();\n-                if (!method.hasAccount(this.getName())) {\n-                    throw new Exception();\n-                }\n-                final Method.MethodAccount account = Methods.getMethod().getAccount(this.getName());\n-                return BigDecimal.valueOf(account.balance());\n-            } catch (Exception ignored) {\n-            }\n-        }\n-        return super.getMoney();\n-    }\n-\n-    @Override\n-    public void setMoney(final BigDecimal value) throws MaxMoneyException {\n-        setMoney(value, UserBalanceUpdateEvent.Cause.UNKNOWN);\n-    }\n-\n-    public void setMoney(final BigDecimal value, UserBalanceUpdateEvent.Cause cause) throws MaxMoneyException {\n-        if (ess.getSettings().isEcoDisabled()) {\n-            if (ess.getSettings().isDebug()) {\n-                ess.getLogger().info(\"Internal economy functions disabled, aborting balance change.\");\n-            }\n-            return;\n-        }\n-        final BigDecimal oldBalance = _getMoney();\n-\n-        UserBalanceUpdateEvent updateEvent = new UserBalanceUpdateEvent(this.getBase(), oldBalance, value, cause);\n-        ess.getServer().getPluginManager().callEvent(updateEvent);\n-        BigDecimal newBalance = updateEvent.getNewBalance();\n-\n-        if (Methods.hasMethod()) {\n-            try {\n-                final Method method = Methods.getMethod();\n-                if (!method.hasAccount(this.getName())) {\n-                    throw new Exception();\n-                }\n-                final Method.MethodAccount account = Methods.getMethod().getAccount(this.getName());\n-                account.set(newBalance.doubleValue());\n-            } catch (Exception ignored) {\n-            }\n-        }\n-        super.setMoney(newBalance, true);\n-        Trade.log(\"Update\", \"Set\", \"API\", getName(), new Trade(newBalance, ess), null, null, null, ess);\n-    }\n-\n-    public void updateMoneyCache(final BigDecimal value) {\n-        if (ess.getSettings().isEcoDisabled()) {\n-            return;\n-        }\n-        if (Methods.hasMethod() && !super.getMoney().equals(value)) {\n-            try {\n-                super.setMoney(value, false);\n-            } catch (MaxMoneyException ex) {\n-                // We don't want to throw any errors here, just updating a cache\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void setAfk(final boolean set) {\n-        setAfk(set, AfkStatusChangeEvent.Cause.UNKNOWN);\n-    }\n-\n-    @Override\n-    public void setAfk(boolean set, AfkStatusChangeEvent.Cause cause) {\n-        final AfkStatusChangeEvent afkEvent = new AfkStatusChangeEvent(this, set, cause);\n-        ess.getServer().getPluginManager().callEvent(afkEvent);\n-        if (afkEvent.isCancelled()) {\n-            return;\n-        }\n-\n-        this.getBase().setSleepingIgnored(this.isAuthorized(\"essentials.sleepingignored\") || set && ess.getSettings().sleepIgnoresAfkPlayers());\n-        if (set && !isAfk()) {\n-            afkPosition = this.getLocation();\n-            this.afkSince = System.currentTimeMillis();\n-        } else if (!set && isAfk()) {\n-            afkPosition = null;\n-            this.afkMessage = null;\n-            this.afkSince = 0;\n-        }\n-        _setAfk(set);\n-        updateAfkListName();\n-    }\n-\n-    private void updateAfkListName() {\n-        if (ess.getSettings().isAfkListName()) {\n-            if(isAfk()) {\n-                String afkName = ess.getSettings().getAfkListName().replace(\"{PLAYER}\", getDisplayName()).replace(\"{USERNAME}\", getName());\n-                getBase().setPlayerListName(afkName);\n-            } else {\n-                getBase().setPlayerListName(null);\n-                setDisplayNick();\n-            }\n-        }\n-    }\n-\n-    @Deprecated\n-    public boolean toggleAfk() {\n-        return toggleAfk(AfkStatusChangeEvent.Cause.UNKNOWN);\n-    }\n-\n-    public boolean toggleAfk(AfkStatusChangeEvent.Cause cause) {\n-        setAfk(!isAfk(), cause);\n-        return isAfk();\n-    }\n-\n-    @Override\n-    public boolean isHidden() {\n-        return hidden;\n-    }\n-\n-    public boolean isHidden(final Player player) {\n-        return hidden || !player.canSee(getBase());\n-    }\n-\n-    @Override\n-    public void setHidden(final boolean hidden) {\n-        this.hidden = hidden;\n-        if (hidden) {\n-            setLastLogout(getLastOnlineActivity());\n-        }\n-    }\n-\n-    //Returns true if status expired during this check\n-    public boolean checkJailTimeout(final long currentTime) {\n-        if (getJailTimeout() > 0 && getJailTimeout() < currentTime && isJailed()) {\n-            final JailStatusChangeEvent event = new JailStatusChangeEvent(this, null, false);\n-            ess.getServer().getPluginManager().callEvent(event);\n-\n-            if (!event.isCancelled()) {\n-                setJailTimeout(0);\n-                setJailed(false);\n-                sendMessage(tl(\"haveBeenReleased\"));\n-                setJail(null);\n-                if (ess.getSettings().isTeleportBackWhenFreedFromJail()) {\n-                    CompletableFuture<Boolean> future = new CompletableFuture<>();\n-                    getAsyncTeleport().back(future);\n-                    future.exceptionally(e -> {\n-                        getAsyncTeleport().respawn(null, TeleportCause.PLUGIN, new CompletableFuture<>());\n-                        return false;\n-                    });\n-                }\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    //Returns true if status expired during this check\n-    public boolean checkMuteTimeout(final long currentTime) {\n-        if (getMuteTimeout() > 0 && getMuteTimeout() < currentTime && isMuted()) {\n-            final MuteStatusChangeEvent event = new MuteStatusChangeEvent(this, null, false, getMuteTimeout(), getMuteReason());\n-            ess.getServer().getPluginManager().callEvent(event);\n-            \n-            if (!event.isCancelled()) {\n-                setMuteTimeout(0);\n-                sendMessage(tl(\"canTalkAgain\"));\n-                setMuted(false);\n-                setMuteReason(null);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    @Deprecated\n-    public void updateActivity(final boolean broadcast) {\n-        updateActivity(broadcast, AfkStatusChangeEvent.Cause.UNKNOWN);\n-    }\n-\n-    public void updateActivity(final boolean broadcast, AfkStatusChangeEvent.Cause cause) {\n-        if (isAfk()) {\n-            setAfk(false, cause);\n-            if (broadcast && !isHidden()) {\n-                setDisplayNick();\n-                final String msg = tl(\"userIsNotAway\", getDisplayName());\n-                final String selfmsg = tl(\"userIsNotAwaySelf\", getDisplayName());\n-                if (!msg.isEmpty() && ess.getSettings().broadcastAfkMessage()) {\n-                    // exclude user from receiving general AFK announcement in favor of personal message\n-                    ess.broadcastMessage(this, msg, u -> u == this);\n-                }\n-                if (!selfmsg.isEmpty()) {\n-                    this.sendMessage(selfmsg);\n-                }\n-            }\n-        }\n-        lastActivity = System.currentTimeMillis();\n-    }\n-\n-    public void updateActivityOnMove(final boolean broadcast) {\n-        if(ess.getSettings().cancelAfkOnMove()) {\n-            updateActivity(broadcast, AfkStatusChangeEvent.Cause.MOVE);\n-        }\n-    }\n-\n-    public void updateActivityOnInteract(final boolean broadcast) {\n-        if(ess.getSettings().cancelAfkOnInteract()) {\n-            updateActivity(broadcast, AfkStatusChangeEvent.Cause.INTERACT);\n-        }\n-    }\n-\n-    public void checkActivity() {\n-        // Graceful time before the first afk check call. \n-        if (System.currentTimeMillis() - lastActivity <= 10000) {\n-            return;\n-        }\n-\n-        final long autoafkkick = ess.getSettings().getAutoAfkKick();\n-        if (autoafkkick > 0\n-            && lastActivity > 0 && (lastActivity + (autoafkkick * 1000)) < System.currentTimeMillis()\n-            && !isAuthorized(\"essentials.kick.exempt\")\n-            && !isAuthorized(\"essentials.afk.kickexempt\")) {\n-            final String kickReason = tl(\"autoAfkKickReason\", autoafkkick / 60.0);\n-            lastActivity = 0;\n-            this.getBase().kickPlayer(kickReason);\n-\n-\n-            for (User user : ess.getOnlineUsers()) {\n-                if (user.isAuthorized(\"essentials.kick.notify\")) {\n-                    user.sendMessage(tl(\"playerKicked\", Console.NAME, getName(), kickReason));\n-                }\n-            }\n-        }\n-        final long autoafk = ess.getSettings().getAutoAfk();\n-        if (!isAfk() && autoafk > 0 && lastActivity + autoafk * 1000 < System.currentTimeMillis() && isAuthorized(\"essentials.afk.auto\")) {\n-            setAfk(true, AfkStatusChangeEvent.Cause.ACTIVITY);\n-            if (!isHidden()) {\n-                setDisplayNick();\n-                final String msg = tl(\"userIsAway\", getDisplayName());\n-                final String selfmsg = tl(\"userIsAwaySelf\", getDisplayName());\n-                if (!msg.isEmpty() && ess.getSettings().broadcastAfkMessage()) {\n-                    // exclude user from receiving general AFK announcement in favor of personal message\n-                    ess.broadcastMessage(this, msg, u -> u == this);\n-                }\n-                if (!selfmsg.isEmpty()) {\n-                    this.sendMessage(selfmsg);\n-                }\n-            }\n-        }\n-    }\n-\n-    public Location getAfkPosition() {\n-        return afkPosition;\n-    }\n-\n-    @Override\n-    public boolean isGodModeEnabled() {\n-        if (super.isGodModeEnabled()) {\n-            // This enables the no-god-in-worlds functionality where the actual player god mode state is never modified in disabled worlds,\n-            // but this method gets called every time the player takes damage. In the case that the world has god-mode disabled then this method\n-            // will return false and the player will take damage, even though they are in god mode (isGodModeEnabledRaw()).\n-            if (!ess.getSettings().getNoGodWorlds().contains(this.getLocation().getWorld().getName())) {\n-                return true;\n-            }\n-        }\n-        if (isAfk()) {\n-            // Protect AFK players by representing them in a god mode state to render them invulnerable to damage.\n-            return ess.getSettings().getFreezeAfkPlayers();\n-        }\n-        return false;\n-    }\n-\n-    public boolean isGodModeEnabledRaw() {\n-        return super.isGodModeEnabled();\n-    }\n-\n-    @Override\n-    public String getGroup() {\n-        final String result = ess.getPermissionsHandler().getGroup(base);\n-        if (ess.getSettings().isDebug()) {\n-            ess.getLogger().log(Level.INFO, \"looking up groupname of \" + base.getName() + \" - \" + result);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public boolean inGroup(final String group) {\n-        final boolean result = ess.getPermissionsHandler().inGroup(base, group);\n-        if (ess.getSettings().isDebug()) {\n-            ess.getLogger().log(Level.INFO, \"checking if \" + base.getName() + \" is in group \" + group + \" - \" + result);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public boolean canBuild() {\n-        if (this.getBase().isOp()) {\n-            return true;\n-        }\n-        return ess.getPermissionsHandler().canBuild(base, getGroup());\n-    }\n-\n-    public long getTeleportRequestTime() {\n-        return teleportRequestTime;\n-    }\n-\n-    public boolean isInvSee() {\n-        return invSee;\n-    }\n-\n-    public void setInvSee(final boolean set) {\n-        invSee = set;\n-    }\n-\n-    public boolean isEnderSee() {\n-        return enderSee;\n-    }\n-\n-    public void setEnderSee(final boolean set) {\n-        enderSee = set;\n-    }\n-\n-    @Override\n-    public void enableInvulnerabilityAfterTeleport() {\n-        final long time = ess.getSettings().getTeleportInvulnerability();\n-        if (time > 0) {\n-            teleportInvulnerabilityTimestamp = System.currentTimeMillis() + time;\n-        }\n-    }\n-\n-    @Override\n-    public void resetInvulnerabilityAfterTeleport() {\n-        if (teleportInvulnerabilityTimestamp != 0 && teleportInvulnerabilityTimestamp < System.currentTimeMillis()) {\n-            teleportInvulnerabilityTimestamp = 0;\n-        }\n-    }\n-\n-    @Override\n-    public boolean hasInvulnerabilityAfterTeleport() {\n-        return teleportInvulnerabilityTimestamp != 0 && teleportInvulnerabilityTimestamp >= System.currentTimeMillis();\n-    }\n-\n-    public boolean canInteractVanished() {\n-        return isAuthorized(\"essentials.vanish.interact\");\n-    }\n-\n-    @Override\n-    public boolean isIgnoreMsg() {\n-        return ignoreMsg;\n-    }\n-\n-    @Override\n-    public void setIgnoreMsg(boolean ignoreMsg) {\n-        this.ignoreMsg = ignoreMsg;\n-    }\n-\n-    @Override\n-    public boolean isVanished() {\n-        return vanished;\n-    }\n-\n-    @Override\n-    public void setVanished(final boolean set) {\n-        vanished = set;\n-        if (set) {\n-            for (User user : ess.getOnlineUsers()) {\n-                if (!user.isAuthorized(\"essentials.vanish.see\")) {\n-                    user.getBase().hidePlayer(getBase());\n-                }\n-            }\n-            setHidden(true);\n-            ess.getVanishedPlayersNew().add(getName());\n-            if (isAuthorized(\"essentials.vanish.effect\")) {\n-                this.getBase().addPotionEffect(new PotionEffect(PotionEffectType.INVISIBILITY, Integer.MAX_VALUE, 1, false));\n-            }\n-        } else {\n-            for (Player p : ess.getOnlinePlayers()) {\n-                p.showPlayer(getBase());\n-            }\n-            setHidden(false);\n-            ess.getVanishedPlayersNew().remove(getName());\n-            if (isAuthorized(\"essentials.vanish.effect\")) {\n-                this.getBase().removePotionEffect(PotionEffectType.INVISIBILITY);\n-            }\n-        }\n-    }\n-\n-    public boolean checkSignThrottle() {\n-        if (isSignThrottled()) {\n-            return true;\n-        }\n-        updateThrottle();\n-        return false;\n-    }\n-\n-    public boolean isSignThrottled() {\n-        final long minTime = lastThrottledAction + (1000 / ess.getSettings().getSignUsePerSecond());\n-        return (System.currentTimeMillis() < minTime);\n-    }\n-\n-    public void updateThrottle() {\n-        lastThrottledAction = System.currentTimeMillis();\n-    }\n-\n-    public boolean isFlyClickJump() {\n-        return rightClickJump;\n-    }\n-\n-    public void setRightClickJump(boolean rightClickJump) {\n-        this.rightClickJump = rightClickJump;\n-    }\n-\n-    @Override\n-    public boolean isIgnoreExempt() {\n-        return this.isAuthorized(\"essentials.chat.ignoreexempt\");\n-    }\n-\n-    public boolean isRecipeSee() {\n-        return recipeSee;\n-    }\n-\n-    public void setRecipeSee(boolean recipeSee) {\n-        this.recipeSee = recipeSee;\n-    }\n-\n-    @Override\n-    public void sendMessage(String message) {\n-        if (!message.isEmpty()) {\n-            base.sendMessage(message);\n-        }\n-    }\n-\n-    @Override\n-    public int compareTo(final User other) {\n-        return FormatUtil.stripFormat(getDisplayName()).compareToIgnoreCase(FormatUtil.stripFormat(other.getDisplayName()));\n-    }\n-\n-    @Override\n-    public boolean equals(final Object object) {\n-        if (!(object instanceof User)) {\n-            return false;\n-        }\n-        return this.getName().equalsIgnoreCase(((User) object).getName());\n-\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return this.getName().hashCode();\n-    }\n-\n-    @Override\n-    public CommandSource getSource() {\n-        return new CommandSource(getBase());\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return this.getBase().getName();\n-    }\n-    \n-    @Override public boolean isReachable() {\n-        return getBase().isOnline();\n-    }\n-\n-    @Override public MessageResponse sendMessage(IMessageRecipient recipient, String message) {\n-        return this.messageRecipient.sendMessage(recipient, message);\n-    }\n-\n-    @Override public MessageResponse onReceiveMessage(IMessageRecipient sender, String message) {\n-        return this.messageRecipient.onReceiveMessage(sender, message);\n-    }\n-\n-    @Override public IMessageRecipient getReplyRecipient() {\n-        return this.messageRecipient.getReplyRecipient();\n-    }\n-\n-    @Override public void setReplyRecipient(IMessageRecipient recipient) {\n-        this.messageRecipient.setReplyRecipient(recipient);\n-    }\n-\n-    @Override\n-    public String getAfkMessage() {\n-        return this.afkMessage;\n-    }\n-\n-    @Override\n-    public void setAfkMessage(String message) {\n-        if (isAfk()) {\n-            this.afkMessage = message;\n-        }\n-    }\n-\n-    @Override\n-    public long getAfkSince() {\n-        return afkSince;\n-    }\n-\n-    @Override\n-    public Map<User, BigDecimal> getConfirmingPayments() {\n-        return confirmingPayments;\n-    }\n-\n-    public String getConfirmingClearCommand() {\n-        return confirmingClearCommand;\n-    }\n-    \n-    public void setConfirmingClearCommand(String command) {\n-        this.confirmingClearCommand = command;\n-    }\n-\n-    /**\n-     * Returns the {@link ItemStack} in the main hand or off-hand. If the main hand is empty then the offhand item is returned - also nullable.\n-     */\n-    public ItemStack getItemInHand() {\n-        if (VersionUtil.getServerBukkitVersion().isLowerThan(VersionUtil.v1_9_R01)) {\n-            return getBase().getInventory().getItemInHand();\n-        } else {\n-            PlayerInventory inventory = getBase().getInventory();\n-            return inventory.getItemInMainHand() != null ? inventory.getItemInMainHand() : inventory.getItemInOffHand();\n-        }\n-    }\n-    \n-    public void notifyOfMail() {\n-        List<String> mails = getMails();\n-        if (mails != null && !mails.isEmpty()) {\n-            int notifyPlayerOfMailCooldown = ess.getSettings().getNotifyPlayerOfMailCooldown() * 1000;\n-            if (System.currentTimeMillis() - lastNotifiedAboutMailsMs >= notifyPlayerOfMailCooldown) {\n-                sendMessage(tl(\"youHaveNewMail\", mails.size()));\n-                lastNotifiedAboutMailsMs = System.currentTimeMillis();\n-            }\n-        }\n-    }\n-\n-    public String getLastHomeConfirmation() {\n-        return lastHomeConfirmation;\n-    }\n-\n-    public void setLastHomeConfirmation(String lastHomeConfirmation) {\n-        this.lastHomeConfirmation = lastHomeConfirmation;\n-    }\n-\n-    public long getLastHomeConfirmationTimestamp() {\n-        return lastHomeConfirmationTimestamp;\n-    }\n-\n-    public void setLastHomeConfirmationTimestamp() {\n-        this.lastHomeConfirmationTimestamp = System.currentTimeMillis();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc4MDk3Mw==", "url": "https://github.com/EssentialsX/Essentials/pull/3649#discussion_r489780973", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import net.ess3.api.events.*;\n          \n          \n            \n            import net.ess3.api.events.AfkStatusChangeEvent;\n          \n          \n            \n            import net.ess3.api.events.JailStatusChangeEvent;\t\n          \n          \n            \n            import net.ess3.api.events.MuteStatusChangeEvent;\t\n          \n          \n            \n            import net.ess3.api.events.UserBalanceUpdateEvent;", "author": "pop4959", "createdAt": "2020-09-16T22:06:25Z", "path": "Essentials/src/com/earth2me/essentials/User.java", "diffHunk": "@@ -11,10 +11,7 @@\n import com.earth2me.essentials.utils.VersionUtil;\n import net.ess3.api.IEssentials;\n import net.ess3.api.MaxMoneyException;\n-import net.ess3.api.events.AfkStatusChangeEvent;\n-import net.ess3.api.events.JailStatusChangeEvent;\n-import net.ess3.api.events.MuteStatusChangeEvent;\n-import net.ess3.api.events.UserBalanceUpdateEvent;\n+import net.ess3.api.events.*;", "originalCommit": "8623afced6d069c05863b956c717ed7693d34d61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6bb3f3acced48eb1b1bc10015028be94b0881ca3", "chunk": "diff --git a/Essentials/src/com/earth2me/essentials/User.java b/Essentials/src/com/earth2me/essentials/User.java\nindex 383d187a6..5ddd9852a 100644\n--- a/Essentials/src/com/earth2me/essentials/User.java\n+++ b/Essentials/src/com/earth2me/essentials/User.java\n\n@@ -11,7 +11,11 @@ import com.earth2me.essentials.utils.NumberUtil;\n import com.earth2me.essentials.utils.VersionUtil;\n import net.ess3.api.IEssentials;\n import net.ess3.api.MaxMoneyException;\n-import net.ess3.api.events.*;\n+import net.ess3.api.events.AfkStatusChangeEvent;\n+import net.ess3.api.events.JailStatusChangeEvent;\n+import net.ess3.api.events.MuteStatusChangeEvent;\n+import net.ess3.api.events.TransactionEvent;\n+import net.ess3.api.events.UserBalanceUpdateEvent;\n import org.bukkit.Location;\n import org.bukkit.Material;\n import org.bukkit.entity.Player;\n"}}, {"oid": "6bb3f3acced48eb1b1bc10015028be94b0881ca3", "url": "https://github.com/EssentialsX/Essentials/commit/6bb3f3acced48eb1b1bc10015028be94b0881ca3", "message": "Remove wildcard import\nBeing harassed by wildcard imports? Just say no! IntellJ legally cannot use wildcard imports without your consent!", "committedDate": "2020-09-17T03:46:47Z", "type": "commit"}, {"oid": "448661cbde2ac8248a9de3cbeedbadb56fcba731", "url": "https://github.com/EssentialsX/Essentials/commit/448661cbde2ac8248a9de3cbeedbadb56fcba731", "message": "Merge remote-tracking branch 'original/2.x' into feature/transactionevent", "committedDate": "2020-11-25T22:48:38Z", "type": "commit"}, {"oid": "448661cbde2ac8248a9de3cbeedbadb56fcba731", "url": "https://github.com/EssentialsX/Essentials/commit/448661cbde2ac8248a9de3cbeedbadb56fcba731", "message": "Merge remote-tracking branch 'original/2.x' into feature/transactionevent", "committedDate": "2020-11-25T22:48:38Z", "type": "forcePushed"}, {"oid": "cc371f69b4f67d99b309de67e75769ba4f00f9c9", "url": "https://github.com/EssentialsX/Essentials/commit/cc371f69b4f67d99b309de67e75769ba4f00f9c9", "message": "Move TransactionEvent.java to proper folder", "committedDate": "2020-11-25T22:58:26Z", "type": "commit"}, {"oid": "78dc1a96b3af96ec0b0d1d0ccef409774aca4b57", "url": "https://github.com/EssentialsX/Essentials/commit/78dc1a96b3af96ec0b0d1d0ccef409774aca4b57", "message": "Fix some CheckStyle errors", "committedDate": "2020-11-25T23:12:20Z", "type": "commit"}, {"oid": "9b138510c950ffdc29dc57a2264d0484aaa4d841", "url": "https://github.com/EssentialsX/Essentials/commit/9b138510c950ffdc29dc57a2264d0484aaa4d841", "message": "Move TransactionEvent.java to proper folder... again", "committedDate": "2021-01-02T03:34:19Z", "type": "commit"}, {"oid": "24b0a98874d8b39fafb5a3d33208c344dcabae39", "url": "https://github.com/EssentialsX/Essentials/commit/24b0a98874d8b39fafb5a3d33208c344dcabae39", "message": "Merge remote-tracking branch 'original/2.x' into feature/transactionevent", "committedDate": "2021-01-02T03:39:51Z", "type": "commit"}, {"oid": "fb961505df5897dea4fce56e40643682074311a8", "url": "https://github.com/EssentialsX/Essentials/commit/fb961505df5897dea4fce56e40643682074311a8", "message": "Fix TransactionEvent import in User.java", "committedDate": "2021-01-02T03:42:01Z", "type": "commit"}]}